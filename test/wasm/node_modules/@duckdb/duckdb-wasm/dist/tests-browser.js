"use strict";
var duckdb = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x + '" is not supported');
  });
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name2 in all)
      __defProp(target, name2, { get: all[name2], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // (disabled):crypto
  var require_crypto = __commonJS({
    "(disabled):crypto"() {
    }
  });

  // (disabled):../../node_modules/buffer/index.js
  var require_buffer = __commonJS({
    "(disabled):../../node_modules/buffer/index.js"() {
    }
  });

  // ../../node_modules/js-sha256/src/sha256.js
  var require_sha256 = __commonJS({
    "../../node_modules/js-sha256/src/sha256.js"(exports2, module2) {
      (function() {
        "use strict";
        var ERROR = "input is invalid type";
        var WINDOW = typeof window === "object";
        var root = WINDOW ? window : {};
        if (root.JS_SHA256_NO_WINDOW) {
          WINDOW = false;
        }
        var WEB_WORKER = !WINDOW && typeof self === "object";
        var NODE_JS = !root.JS_SHA256_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
        if (NODE_JS) {
          root = global;
        } else if (WEB_WORKER) {
          root = self;
        }
        var COMMON_JS = !root.JS_SHA256_NO_COMMON_JS && typeof module2 === "object" && module2.exports;
        var AMD = typeof define === "function" && define.amd;
        var ARRAY_BUFFER = !root.JS_SHA256_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
        var HEX_CHARS = "0123456789abcdef".split("");
        var EXTRA = [-2147483648, 8388608, 32768, 128];
        var SHIFT = [24, 16, 8, 0];
        var K = [
          1116352408,
          1899447441,
          3049323471,
          3921009573,
          961987163,
          1508970993,
          2453635748,
          2870763221,
          3624381080,
          310598401,
          607225278,
          1426881987,
          1925078388,
          2162078206,
          2614888103,
          3248222580,
          3835390401,
          4022224774,
          264347078,
          604807628,
          770255983,
          1249150122,
          1555081692,
          1996064986,
          2554220882,
          2821834349,
          2952996808,
          3210313671,
          3336571891,
          3584528711,
          113926993,
          338241895,
          666307205,
          773529912,
          1294757372,
          1396182291,
          1695183700,
          1986661051,
          2177026350,
          2456956037,
          2730485921,
          2820302411,
          3259730800,
          3345764771,
          3516065817,
          3600352804,
          4094571909,
          275423344,
          430227734,
          506948616,
          659060556,
          883997877,
          958139571,
          1322822218,
          1537002063,
          1747873779,
          1955562222,
          2024104815,
          2227730452,
          2361852424,
          2428436474,
          2756734187,
          3204031479,
          3329325298
        ];
        var OUTPUT_TYPES = ["hex", "array", "digest", "arrayBuffer"];
        var blocks = [];
        if (root.JS_SHA256_NO_NODE_JS || !Array.isArray) {
          Array.isArray = function(obj) {
            return Object.prototype.toString.call(obj) === "[object Array]";
          };
        }
        if (ARRAY_BUFFER && (root.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
          ArrayBuffer.isView = function(obj) {
            return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
          };
        }
        var createOutputMethod = function(outputType, is224) {
          return function(message) {
            return new Sha256(is224, true).update(message)[outputType]();
          };
        };
        var createMethod = function(is224) {
          var method = createOutputMethod("hex", is224);
          if (NODE_JS) {
            method = nodeWrap(method, is224);
          }
          method.create = function() {
            return new Sha256(is224);
          };
          method.update = function(message) {
            return method.create().update(message);
          };
          for (var i2 = 0; i2 < OUTPUT_TYPES.length; ++i2) {
            var type = OUTPUT_TYPES[i2];
            method[type] = createOutputMethod(type, is224);
          }
          return method;
        };
        var nodeWrap = function(method, is224) {
          var crypto2 = require_crypto();
          var Buffer3 = require_buffer().Buffer;
          var algorithm = is224 ? "sha224" : "sha256";
          var bufferFrom;
          if (Buffer3.from && !root.JS_SHA256_NO_BUFFER_FROM) {
            bufferFrom = Buffer3.from;
          } else {
            bufferFrom = function(message) {
              return new Buffer3(message);
            };
          }
          var nodeMethod = function(message) {
            if (typeof message === "string") {
              return crypto2.createHash(algorithm).update(message, "utf8").digest("hex");
            } else {
              if (message === null || message === void 0) {
                throw new Error(ERROR);
              } else if (message.constructor === ArrayBuffer) {
                message = new Uint8Array(message);
              }
            }
            if (Array.isArray(message) || ArrayBuffer.isView(message) || message.constructor === Buffer3) {
              return crypto2.createHash(algorithm).update(bufferFrom(message)).digest("hex");
            } else {
              return method(message);
            }
          };
          return nodeMethod;
        };
        var createHmacOutputMethod = function(outputType, is224) {
          return function(key, message) {
            return new HmacSha256(key, is224, true).update(message)[outputType]();
          };
        };
        var createHmacMethod = function(is224) {
          var method = createHmacOutputMethod("hex", is224);
          method.create = function(key) {
            return new HmacSha256(key, is224);
          };
          method.update = function(key, message) {
            return method.create(key).update(message);
          };
          for (var i2 = 0; i2 < OUTPUT_TYPES.length; ++i2) {
            var type = OUTPUT_TYPES[i2];
            method[type] = createHmacOutputMethod(type, is224);
          }
          return method;
        };
        function Sha256(is224, sharedMemory) {
          if (sharedMemory) {
            blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
            this.blocks = blocks;
          } else {
            this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
          }
          if (is224) {
            this.h0 = 3238371032;
            this.h1 = 914150663;
            this.h2 = 812702999;
            this.h3 = 4144912697;
            this.h4 = 4290775857;
            this.h5 = 1750603025;
            this.h6 = 1694076839;
            this.h7 = 3204075428;
          } else {
            this.h0 = 1779033703;
            this.h1 = 3144134277;
            this.h2 = 1013904242;
            this.h3 = 2773480762;
            this.h4 = 1359893119;
            this.h5 = 2600822924;
            this.h6 = 528734635;
            this.h7 = 1541459225;
          }
          this.block = this.start = this.bytes = this.hBytes = 0;
          this.finalized = this.hashed = false;
          this.first = true;
          this.is224 = is224;
        }
        Sha256.prototype.update = function(message) {
          if (this.finalized) {
            return;
          }
          var notString, type = typeof message;
          if (type !== "string") {
            if (type === "object") {
              if (message === null) {
                throw new Error(ERROR);
              } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
                message = new Uint8Array(message);
              } else if (!Array.isArray(message)) {
                if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
                  throw new Error(ERROR);
                }
              }
            } else {
              throw new Error(ERROR);
            }
            notString = true;
          }
          var code, index = 0, i2, length = message.length, blocks2 = this.blocks;
          while (index < length) {
            if (this.hashed) {
              this.hashed = false;
              blocks2[0] = this.block;
              this.block = blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
            }
            if (notString) {
              for (i2 = this.start; index < length && i2 < 64; ++index) {
                blocks2[i2 >>> 2] |= message[index] << SHIFT[i2++ & 3];
              }
            } else {
              for (i2 = this.start; index < length && i2 < 64; ++index) {
                code = message.charCodeAt(index);
                if (code < 128) {
                  blocks2[i2 >>> 2] |= code << SHIFT[i2++ & 3];
                } else if (code < 2048) {
                  blocks2[i2 >>> 2] |= (192 | code >>> 6) << SHIFT[i2++ & 3];
                  blocks2[i2 >>> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];
                } else if (code < 55296 || code >= 57344) {
                  blocks2[i2 >>> 2] |= (224 | code >>> 12) << SHIFT[i2++ & 3];
                  blocks2[i2 >>> 2] |= (128 | code >>> 6 & 63) << SHIFT[i2++ & 3];
                  blocks2[i2 >>> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];
                } else {
                  code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                  blocks2[i2 >>> 2] |= (240 | code >>> 18) << SHIFT[i2++ & 3];
                  blocks2[i2 >>> 2] |= (128 | code >>> 12 & 63) << SHIFT[i2++ & 3];
                  blocks2[i2 >>> 2] |= (128 | code >>> 6 & 63) << SHIFT[i2++ & 3];
                  blocks2[i2 >>> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];
                }
              }
            }
            this.lastByteIndex = i2;
            this.bytes += i2 - this.start;
            if (i2 >= 64) {
              this.block = blocks2[16];
              this.start = i2 - 64;
              this.hash();
              this.hashed = true;
            } else {
              this.start = i2;
            }
          }
          if (this.bytes > 4294967295) {
            this.hBytes += this.bytes / 4294967296 << 0;
            this.bytes = this.bytes % 4294967296;
          }
          return this;
        };
        Sha256.prototype.finalize = function() {
          if (this.finalized) {
            return;
          }
          this.finalized = true;
          var blocks2 = this.blocks, i2 = this.lastByteIndex;
          blocks2[16] = this.block;
          blocks2[i2 >>> 2] |= EXTRA[i2 & 3];
          this.block = blocks2[16];
          if (i2 >= 56) {
            if (!this.hashed) {
              this.hash();
            }
            blocks2[0] = this.block;
            blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
          }
          blocks2[14] = this.hBytes << 3 | this.bytes >>> 29;
          blocks2[15] = this.bytes << 3;
          this.hash();
        };
        Sha256.prototype.hash = function() {
          var a = this.h0, b = this.h1, c = this.h2, d = this.h3, e = this.h4, f = this.h5, g = this.h6, h = this.h7, blocks2 = this.blocks, j, s0, s1, maj, t1, t2, ch, ab, da, cd, bc;
          for (j = 16; j < 64; ++j) {
            t1 = blocks2[j - 15];
            s0 = (t1 >>> 7 | t1 << 25) ^ (t1 >>> 18 | t1 << 14) ^ t1 >>> 3;
            t1 = blocks2[j - 2];
            s1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
            blocks2[j] = blocks2[j - 16] + s0 + blocks2[j - 7] + s1 << 0;
          }
          bc = b & c;
          for (j = 0; j < 64; j += 4) {
            if (this.first) {
              if (this.is224) {
                ab = 300032;
                t1 = blocks2[0] - 1413257819;
                h = t1 - 150054599 << 0;
                d = t1 + 24177077 << 0;
              } else {
                ab = 704751109;
                t1 = blocks2[0] - 210244248;
                h = t1 - 1521486534 << 0;
                d = t1 + 143694565 << 0;
              }
              this.first = false;
            } else {
              s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);
              s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);
              ab = a & b;
              maj = ab ^ a & c ^ bc;
              ch = e & f ^ ~e & g;
              t1 = h + s1 + ch + K[j] + blocks2[j];
              t2 = s0 + maj;
              h = d + t1 << 0;
              d = t1 + t2 << 0;
            }
            s0 = (d >>> 2 | d << 30) ^ (d >>> 13 | d << 19) ^ (d >>> 22 | d << 10);
            s1 = (h >>> 6 | h << 26) ^ (h >>> 11 | h << 21) ^ (h >>> 25 | h << 7);
            da = d & a;
            maj = da ^ d & b ^ ab;
            ch = h & e ^ ~h & f;
            t1 = g + s1 + ch + K[j + 1] + blocks2[j + 1];
            t2 = s0 + maj;
            g = c + t1 << 0;
            c = t1 + t2 << 0;
            s0 = (c >>> 2 | c << 30) ^ (c >>> 13 | c << 19) ^ (c >>> 22 | c << 10);
            s1 = (g >>> 6 | g << 26) ^ (g >>> 11 | g << 21) ^ (g >>> 25 | g << 7);
            cd = c & d;
            maj = cd ^ c & a ^ da;
            ch = g & h ^ ~g & e;
            t1 = f + s1 + ch + K[j + 2] + blocks2[j + 2];
            t2 = s0 + maj;
            f = b + t1 << 0;
            b = t1 + t2 << 0;
            s0 = (b >>> 2 | b << 30) ^ (b >>> 13 | b << 19) ^ (b >>> 22 | b << 10);
            s1 = (f >>> 6 | f << 26) ^ (f >>> 11 | f << 21) ^ (f >>> 25 | f << 7);
            bc = b & c;
            maj = bc ^ b & d ^ cd;
            ch = f & g ^ ~f & h;
            t1 = e + s1 + ch + K[j + 3] + blocks2[j + 3];
            t2 = s0 + maj;
            e = a + t1 << 0;
            a = t1 + t2 << 0;
            this.chromeBugWorkAround = true;
          }
          this.h0 = this.h0 + a << 0;
          this.h1 = this.h1 + b << 0;
          this.h2 = this.h2 + c << 0;
          this.h3 = this.h3 + d << 0;
          this.h4 = this.h4 + e << 0;
          this.h5 = this.h5 + f << 0;
          this.h6 = this.h6 + g << 0;
          this.h7 = this.h7 + h << 0;
        };
        Sha256.prototype.hex = function() {
          this.finalize();
          var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
          var hex = HEX_CHARS[h0 >>> 28 & 15] + HEX_CHARS[h0 >>> 24 & 15] + HEX_CHARS[h0 >>> 20 & 15] + HEX_CHARS[h0 >>> 16 & 15] + HEX_CHARS[h0 >>> 12 & 15] + HEX_CHARS[h0 >>> 8 & 15] + HEX_CHARS[h0 >>> 4 & 15] + HEX_CHARS[h0 & 15] + HEX_CHARS[h1 >>> 28 & 15] + HEX_CHARS[h1 >>> 24 & 15] + HEX_CHARS[h1 >>> 20 & 15] + HEX_CHARS[h1 >>> 16 & 15] + HEX_CHARS[h1 >>> 12 & 15] + HEX_CHARS[h1 >>> 8 & 15] + HEX_CHARS[h1 >>> 4 & 15] + HEX_CHARS[h1 & 15] + HEX_CHARS[h2 >>> 28 & 15] + HEX_CHARS[h2 >>> 24 & 15] + HEX_CHARS[h2 >>> 20 & 15] + HEX_CHARS[h2 >>> 16 & 15] + HEX_CHARS[h2 >>> 12 & 15] + HEX_CHARS[h2 >>> 8 & 15] + HEX_CHARS[h2 >>> 4 & 15] + HEX_CHARS[h2 & 15] + HEX_CHARS[h3 >>> 28 & 15] + HEX_CHARS[h3 >>> 24 & 15] + HEX_CHARS[h3 >>> 20 & 15] + HEX_CHARS[h3 >>> 16 & 15] + HEX_CHARS[h3 >>> 12 & 15] + HEX_CHARS[h3 >>> 8 & 15] + HEX_CHARS[h3 >>> 4 & 15] + HEX_CHARS[h3 & 15] + HEX_CHARS[h4 >>> 28 & 15] + HEX_CHARS[h4 >>> 24 & 15] + HEX_CHARS[h4 >>> 20 & 15] + HEX_CHARS[h4 >>> 16 & 15] + HEX_CHARS[h4 >>> 12 & 15] + HEX_CHARS[h4 >>> 8 & 15] + HEX_CHARS[h4 >>> 4 & 15] + HEX_CHARS[h4 & 15] + HEX_CHARS[h5 >>> 28 & 15] + HEX_CHARS[h5 >>> 24 & 15] + HEX_CHARS[h5 >>> 20 & 15] + HEX_CHARS[h5 >>> 16 & 15] + HEX_CHARS[h5 >>> 12 & 15] + HEX_CHARS[h5 >>> 8 & 15] + HEX_CHARS[h5 >>> 4 & 15] + HEX_CHARS[h5 & 15] + HEX_CHARS[h6 >>> 28 & 15] + HEX_CHARS[h6 >>> 24 & 15] + HEX_CHARS[h6 >>> 20 & 15] + HEX_CHARS[h6 >>> 16 & 15] + HEX_CHARS[h6 >>> 12 & 15] + HEX_CHARS[h6 >>> 8 & 15] + HEX_CHARS[h6 >>> 4 & 15] + HEX_CHARS[h6 & 15];
          if (!this.is224) {
            hex += HEX_CHARS[h7 >>> 28 & 15] + HEX_CHARS[h7 >>> 24 & 15] + HEX_CHARS[h7 >>> 20 & 15] + HEX_CHARS[h7 >>> 16 & 15] + HEX_CHARS[h7 >>> 12 & 15] + HEX_CHARS[h7 >>> 8 & 15] + HEX_CHARS[h7 >>> 4 & 15] + HEX_CHARS[h7 & 15];
          }
          return hex;
        };
        Sha256.prototype.toString = Sha256.prototype.hex;
        Sha256.prototype.digest = function() {
          this.finalize();
          var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
          var arr = [
            h0 >>> 24 & 255,
            h0 >>> 16 & 255,
            h0 >>> 8 & 255,
            h0 & 255,
            h1 >>> 24 & 255,
            h1 >>> 16 & 255,
            h1 >>> 8 & 255,
            h1 & 255,
            h2 >>> 24 & 255,
            h2 >>> 16 & 255,
            h2 >>> 8 & 255,
            h2 & 255,
            h3 >>> 24 & 255,
            h3 >>> 16 & 255,
            h3 >>> 8 & 255,
            h3 & 255,
            h4 >>> 24 & 255,
            h4 >>> 16 & 255,
            h4 >>> 8 & 255,
            h4 & 255,
            h5 >>> 24 & 255,
            h5 >>> 16 & 255,
            h5 >>> 8 & 255,
            h5 & 255,
            h6 >>> 24 & 255,
            h6 >>> 16 & 255,
            h6 >>> 8 & 255,
            h6 & 255
          ];
          if (!this.is224) {
            arr.push(h7 >>> 24 & 255, h7 >>> 16 & 255, h7 >>> 8 & 255, h7 & 255);
          }
          return arr;
        };
        Sha256.prototype.array = Sha256.prototype.digest;
        Sha256.prototype.arrayBuffer = function() {
          this.finalize();
          var buffer = new ArrayBuffer(this.is224 ? 28 : 32);
          var dataView = new DataView(buffer);
          dataView.setUint32(0, this.h0);
          dataView.setUint32(4, this.h1);
          dataView.setUint32(8, this.h2);
          dataView.setUint32(12, this.h3);
          dataView.setUint32(16, this.h4);
          dataView.setUint32(20, this.h5);
          dataView.setUint32(24, this.h6);
          if (!this.is224) {
            dataView.setUint32(28, this.h7);
          }
          return buffer;
        };
        function HmacSha256(key, is224, sharedMemory) {
          var i2, type = typeof key;
          if (type === "string") {
            var bytes = [], length = key.length, index = 0, code;
            for (i2 = 0; i2 < length; ++i2) {
              code = key.charCodeAt(i2);
              if (code < 128) {
                bytes[index++] = code;
              } else if (code < 2048) {
                bytes[index++] = 192 | code >>> 6;
                bytes[index++] = 128 | code & 63;
              } else if (code < 55296 || code >= 57344) {
                bytes[index++] = 224 | code >>> 12;
                bytes[index++] = 128 | code >>> 6 & 63;
                bytes[index++] = 128 | code & 63;
              } else {
                code = 65536 + ((code & 1023) << 10 | key.charCodeAt(++i2) & 1023);
                bytes[index++] = 240 | code >>> 18;
                bytes[index++] = 128 | code >>> 12 & 63;
                bytes[index++] = 128 | code >>> 6 & 63;
                bytes[index++] = 128 | code & 63;
              }
            }
            key = bytes;
          } else {
            if (type === "object") {
              if (key === null) {
                throw new Error(ERROR);
              } else if (ARRAY_BUFFER && key.constructor === ArrayBuffer) {
                key = new Uint8Array(key);
              } else if (!Array.isArray(key)) {
                if (!ARRAY_BUFFER || !ArrayBuffer.isView(key)) {
                  throw new Error(ERROR);
                }
              }
            } else {
              throw new Error(ERROR);
            }
          }
          if (key.length > 64) {
            key = new Sha256(is224, true).update(key).array();
          }
          var oKeyPad = [], iKeyPad = [];
          for (i2 = 0; i2 < 64; ++i2) {
            var b = key[i2] || 0;
            oKeyPad[i2] = 92 ^ b;
            iKeyPad[i2] = 54 ^ b;
          }
          Sha256.call(this, is224, sharedMemory);
          this.update(iKeyPad);
          this.oKeyPad = oKeyPad;
          this.inner = true;
          this.sharedMemory = sharedMemory;
        }
        HmacSha256.prototype = new Sha256();
        HmacSha256.prototype.finalize = function() {
          Sha256.prototype.finalize.call(this);
          if (this.inner) {
            this.inner = false;
            var innerHash = this.array();
            Sha256.call(this, this.is224, this.sharedMemory);
            this.update(this.oKeyPad);
            this.update(innerHash);
            Sha256.prototype.finalize.call(this);
          }
        };
        var exports3 = createMethod();
        exports3.sha256 = exports3;
        exports3.sha224 = createMethod(true);
        exports3.sha256.hmac = createHmacMethod();
        exports3.sha224.hmac = createHmacMethod(true);
        if (COMMON_JS) {
          module2.exports = exports3;
        } else {
          root.sha256 = exports3.sha256;
          root.sha224 = exports3.sha224;
          if (AMD) {
            define(function() {
              return exports3;
            });
          }
        }
      })();
    }
  });

  // (disabled):fs
  var require_fs = __commonJS({
    "(disabled):fs"() {
    }
  });

  // (disabled):path
  var require_path = __commonJS({
    "(disabled):path"() {
    }
  });

  // (disabled):os
  var require_os = __commonJS({
    "(disabled):os"() {
    }
  });

  // ../../node_modules/ws/browser.js
  var require_browser = __commonJS({
    "../../node_modules/ws/browser.js"(exports2, module2) {
      "use strict";
      module2.exports = function() {
        throw new Error(
          "ws does not work in the browser. Browser clients must use the native WebSocket object"
        );
      };
    }
  });

  // src/bindings/duckdb-mvp.js
  var require_duckdb_mvp = __commonJS({
    "src/bindings/duckdb-mvp.js"(exports, module) {
      "use strict";
      var DuckDB = (() => {
        var _scriptDir = typeof document !== "undefined" && document.currentScript ? document.currentScript.src : void 0;
        if (typeof __filename !== "undefined")
          _scriptDir || (_scriptDir = __filename);
        return function(moduleArg = {}) {
          var Module = moduleArg;
          var readyPromiseResolve, readyPromiseReject;
          Module["ready"] = new Promise((resolve, reject) => {
            readyPromiseResolve = resolve;
            readyPromiseReject = reject;
          });
          var moduleOverrides = Object.assign({}, Module);
          var arguments_ = [];
          var thisProgram = "./this.program";
          var quit_ = (status, toThrow) => {
            throw toThrow;
          };
          var ENVIRONMENT_IS_WEB = typeof window == "object";
          var ENVIRONMENT_IS_WORKER = typeof importScripts == "function";
          var ENVIRONMENT_IS_NODE = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string";
          var ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;
          var scriptDirectory = "";
          function locateFile(path) {
            if (Module["locateFile"]) {
              return Module["locateFile"](path, scriptDirectory);
            }
            return scriptDirectory + path;
          }
          var read_, readAsync, readBinary;
          if (ENVIRONMENT_IS_NODE) {
            var fs = require_fs();
            var nodePath = require_path();
            if (ENVIRONMENT_IS_WORKER) {
              scriptDirectory = nodePath.dirname(scriptDirectory) + "/";
            } else {
              scriptDirectory = __dirname + "/";
            }
            read_ = (filename, binary2) => {
              filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
              return fs.readFileSync(filename, binary2 ? void 0 : "utf8");
            };
            readBinary = (filename) => {
              var ret = read_(filename, true);
              if (!ret.buffer) {
                ret = new Uint8Array(ret);
              }
              return ret;
            };
            readAsync = (filename, onload2, onerror2, binary2 = true) => {
              filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
              fs.readFile(filename, binary2 ? void 0 : "utf8", (err2, data2) => {
                if (err2)
                  onerror2(err2);
                else
                  onload2(binary2 ? data2.buffer : data2);
              });
            };
            if (!Module["thisProgram"] && process.argv.length > 1) {
              thisProgram = process.argv[1].replace(/\\/g, "/");
            }
            arguments_ = process.argv.slice(2);
            quit_ = (status, toThrow) => {
              process.exitCode = status;
              throw toThrow;
            };
          } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
            if (ENVIRONMENT_IS_WORKER) {
              scriptDirectory = self.location.href;
            } else if (typeof document != "undefined" && document.currentScript) {
              scriptDirectory = document.currentScript.src;
            }
            if (_scriptDir) {
              scriptDirectory = _scriptDir;
            }
            if (scriptDirectory.indexOf("blob:") !== 0) {
              scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, "").lastIndexOf("/") + 1);
            } else {
              scriptDirectory = "";
            }
            {
              read_ = (url2) => {
                var xhr = new XMLHttpRequest();
                xhr.open("GET", url2, false);
                xhr.send(null);
                return xhr.responseText;
              };
              if (ENVIRONMENT_IS_WORKER) {
                readBinary = (url2) => {
                  var xhr = new XMLHttpRequest();
                  xhr.open("GET", url2, false);
                  xhr.responseType = "arraybuffer";
                  xhr.send(null);
                  return new Uint8Array(xhr.response);
                };
              }
              readAsync = (url2, onload2, onerror2) => {
                var xhr = new XMLHttpRequest();
                xhr.open("GET", url2, true);
                xhr.responseType = "arraybuffer";
                xhr.onload = () => {
                  if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
                    onload2(xhr.response);
                    return;
                  }
                  onerror2();
                };
                xhr.onerror = onerror2;
                xhr.send(null);
              };
            }
          } else {
          }
          var out = Module["print"] || console.log.bind(console);
          var err = Module["printErr"] || console.error.bind(console);
          Object.assign(Module, moduleOverrides);
          moduleOverrides = null;
          if (Module["arguments"])
            arguments_ = Module["arguments"];
          if (Module["thisProgram"])
            thisProgram = Module["thisProgram"];
          if (Module["quit"])
            quit_ = Module["quit"];
          var dynamicLibraries = Module["dynamicLibraries"] || [];
          var wasmBinary;
          if (Module["wasmBinary"])
            wasmBinary = Module["wasmBinary"];
          if (typeof WebAssembly != "object") {
            abort("no native wasm support detected");
          }
          var wasmMemory;
          var ABORT = false;
          var EXITSTATUS;
          function assert(condition, text) {
            if (!condition) {
              abort(text);
            }
          }
          var HEAP, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
          function updateMemoryViews() {
            var b = wasmMemory.buffer;
            Module["HEAP8"] = HEAP8 = new Int8Array(b);
            Module["HEAP16"] = HEAP16 = new Int16Array(b);
            Module["HEAPU8"] = HEAPU8 = new Uint8Array(b);
            Module["HEAPU16"] = HEAPU16 = new Uint16Array(b);
            Module["HEAP32"] = HEAP32 = new Int32Array(b);
            Module["HEAPU32"] = HEAPU32 = new Uint32Array(b);
            Module["HEAPF32"] = HEAPF32 = new Float32Array(b);
            Module["HEAPF64"] = HEAPF64 = new Float64Array(b);
          }
          var INITIAL_MEMORY = Module["INITIAL_MEMORY"] || 16777216;
          if (Module["wasmMemory"]) {
            wasmMemory = Module["wasmMemory"];
          } else {
            wasmMemory = new WebAssembly.Memory({
              "initial": INITIAL_MEMORY / 65536,
              "maximum": 4294967296 / 65536
            });
          }
          updateMemoryViews();
          INITIAL_MEMORY = wasmMemory.buffer.byteLength;
          var __ATPRERUN__ = [];
          var __ATINIT__ = [];
          var __ATMAIN__ = [];
          var __ATEXIT__ = [];
          var __ATPOSTRUN__ = [];
          var __RELOC_FUNCS__ = [];
          var runtimeInitialized = false;
          function preRun() {
            if (Module["preRun"]) {
              if (typeof Module["preRun"] == "function")
                Module["preRun"] = [Module["preRun"]];
              while (Module["preRun"].length) {
                addOnPreRun(Module["preRun"].shift());
              }
            }
            callRuntimeCallbacks(__ATPRERUN__);
          }
          function initRuntime() {
            runtimeInitialized = true;
            callRuntimeCallbacks(__RELOC_FUNCS__);
            if (!Module["noFSInit"] && !FS.init.initialized)
              FS.init();
            FS.ignorePermissions = false;
            TTY.init();
            SOCKFS.root = FS.mount(SOCKFS, {}, null);
            PIPEFS.root = FS.mount(PIPEFS, {}, null);
            callRuntimeCallbacks(__ATINIT__);
          }
          function preMain() {
            callRuntimeCallbacks(__ATMAIN__);
          }
          function postRun() {
            if (Module["postRun"]) {
              if (typeof Module["postRun"] == "function")
                Module["postRun"] = [Module["postRun"]];
              while (Module["postRun"].length) {
                addOnPostRun(Module["postRun"].shift());
              }
            }
            callRuntimeCallbacks(__ATPOSTRUN__);
          }
          function addOnPreRun(cb) {
            __ATPRERUN__.unshift(cb);
          }
          function addOnInit(cb) {
            __ATINIT__.unshift(cb);
          }
          function addOnPreMain(cb) {
            __ATMAIN__.unshift(cb);
          }
          function addOnExit(cb) {
          }
          function addOnPostRun(cb) {
            __ATPOSTRUN__.unshift(cb);
          }
          var runDependencies = 0;
          var runDependencyWatcher = null;
          var dependenciesFulfilled = null;
          function getUniqueRunDependency(id) {
            return id;
          }
          function addRunDependency(id) {
            runDependencies++;
            Module["monitorRunDependencies"]?.(runDependencies);
          }
          function removeRunDependency(id) {
            runDependencies--;
            Module["monitorRunDependencies"]?.(runDependencies);
            if (runDependencies == 0) {
              if (runDependencyWatcher !== null) {
                clearInterval(runDependencyWatcher);
                runDependencyWatcher = null;
              }
              if (dependenciesFulfilled) {
                var callback = dependenciesFulfilled;
                dependenciesFulfilled = null;
                callback();
              }
            }
          }
          function abort(what) {
            Module["onAbort"]?.(what);
            what = "Aborted(" + what + ")";
            err(what);
            ABORT = true;
            EXITSTATUS = 1;
            what += ". Build with -sASSERTIONS for more info.";
            var e = new WebAssembly.RuntimeError(what);
            readyPromiseReject(e);
            throw e;
          }
          var dataURIPrefix = "data:application/octet-stream;base64,";
          var isDataURI = (filename) => filename.startsWith(dataURIPrefix);
          var isFileURI = (filename) => filename.startsWith("file://");
          var wasmBinaryFile;
          wasmBinaryFile = "./duckdb-mvp.wasm";
          if (!isDataURI(wasmBinaryFile)) {
            wasmBinaryFile = locateFile(wasmBinaryFile);
          }
          function getBinarySync(file) {
            if (file == wasmBinaryFile && wasmBinary) {
              return new Uint8Array(wasmBinary);
            }
            if (readBinary) {
              return readBinary(file);
            }
            throw "both async and sync fetching of the wasm failed";
          }
          function getBinaryPromise(binaryFile) {
            if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
              if (typeof fetch == "function") {
                return fetch(binaryFile, {
                  credentials: "same-origin"
                }).then((response) => {
                  if (!response["ok"]) {
                    throw "failed to load wasm binary file at '" + binaryFile + "'";
                  }
                  return response["arrayBuffer"]();
                }).catch(() => getBinarySync(binaryFile));
              }
            }
            return Promise.resolve().then(() => getBinarySync(binaryFile));
          }
          function instantiateArrayBuffer(binaryFile, imports, receiver) {
            return getBinaryPromise(binaryFile).then((binary2) => WebAssembly.instantiate(binary2, imports)).then((instance10) => instance10).then(receiver, (reason) => {
              err(`failed to asynchronously prepare wasm: ${reason}`);
              abort(reason);
            });
          }
          function instantiateAsync(binary2, binaryFile, imports, callback) {
            if (!binary2 && typeof WebAssembly.instantiateStreaming == "function" && !isDataURI(binaryFile) && !ENVIRONMENT_IS_NODE && typeof fetch == "function") {
              return fetch(binaryFile, {
                credentials: "same-origin"
              }).then((response) => {
                var result = WebAssembly.instantiateStreaming(response, imports);
                return result.then(callback, function(reason) {
                  err(`wasm streaming compile failed: ${reason}`);
                  err("falling back to ArrayBuffer instantiation");
                  return instantiateArrayBuffer(binaryFile, imports, callback);
                });
              });
            }
            return instantiateArrayBuffer(binaryFile, imports, callback);
          }
          function createWasm() {
            var info2 = {
              "env": wasmImports,
              "wasi_snapshot_preview1": wasmImports,
              "GOT.mem": new Proxy(wasmImports, GOTHandler),
              "GOT.func": new Proxy(wasmImports, GOTHandler)
            };
            function receiveInstance(instance10, module2) {
              wasmExports = instance10.exports;
              wasmExports = relocateExports(wasmExports, 1024);
              var metadata2 = getDylinkMetadata(module2);
              if (metadata2.neededDynlibs) {
                dynamicLibraries = metadata2.neededDynlibs.concat(dynamicLibraries);
              }
              mergeLibSymbols(wasmExports, "main");
              LDSO.init();
              loadDylibs();
              wasmExports = applySignatureConversions(wasmExports);
              addOnInit(wasmExports["__wasm_call_ctors"]);
              __RELOC_FUNCS__.push(wasmExports["__wasm_apply_data_relocs"]);
              removeRunDependency("wasm-instantiate");
              return wasmExports;
            }
            addRunDependency("wasm-instantiate");
            function receiveInstantiationResult(result) {
              receiveInstance(result["instance"], result["module"]);
            }
            if (Module["instantiateWasm"]) {
              try {
                return Module["instantiateWasm"](info2, receiveInstance);
              } catch (e) {
                err(`Module.instantiateWasm callback failed with error: ${e}`);
                readyPromiseReject(e);
              }
            }
            instantiateAsync(wasmBinary, wasmBinaryFile, info2, receiveInstantiationResult).catch(readyPromiseReject);
            return {};
          }
          var tempDouble;
          var tempI64;
          var ASM_CONSTS = {
            2132064: ($0, $1) => {
              var jsString2 = typeof runtime == "object" && runtime && typeof runtime.whereToLoad == "function" && runtime.whereToLoad ? runtime.whereToLoad(UTF8ToString($0)) : UTF8ToString($1);
              var lengthBytes = lengthBytesUTF8(jsString2) + 1;
              var stringOnWasmHeap = _malloc(lengthBytes);
              stringToUTF8(jsString2, stringOnWasmHeap, lengthBytes);
              return stringOnWasmHeap;
            },
            2132430: ($0, $1) => {
              var url2 = UTF8ToString($0);
              if (typeof XMLHttpRequest === "undefined") {
                const os = require_os();
                const path = require_path();
                const fs2 = require_fs();
                var array = url2.split("/");
                var l = array.length;
                var folder = path.join(os.homedir(), ".duckdb/extensions/" + array[l - 4] + "/" + array[l - 3] + "/" + array[l - 2] + "/");
                var filePath = path.join(folder, array[l - 1]);
                try {
                  if (!fs2.existsSync(folder)) {
                    fs2.mkdirSync(folder, {
                      recursive: true
                    });
                  }
                  if (!fs2.existsSync(filePath)) {
                    const int322 = new Int32Array(new SharedArrayBuffer(8));
                    var Worker3 = __require("node:worker_threads").Worker;
                    var worker2 = new Worker3("const {Worker,isMainThread,parentPort,workerData,} = require('node:worker_threads');var times = 0;var SAB = 23;var Z = 0;async function ZZZ(e) {var x = await fetch(e);var res = await x.arrayBuffer();Atomics.store(SAB, 1, res.byteLength);Atomics.store(SAB, 0, 1);Atomics.notify(SAB, 1);Atomics.notify(SAB, 0);Z = res;};parentPort.on('message', function(event) {if (times == 0) {times++;SAB = event;} else if (times == 1) {times++;ZZZ(event);} else {const a = new Uint8Array(Z);const b = new Uint8Array(event.buffer);var K = Z.byteLength;for (var i = 0; i < K; i++) {b[i] = a[i];}Atomics.notify(event, 0);Atomics.store(SAB, 0, 2);Atomics.notify(SAB, 0);}});", {
                      eval: true
                    });
                    var uInt8Array;
                    int322[0] = 0;
                    int322[2] = 4;
                    worker2.postMessage(int322);
                    worker2.postMessage(url2);
                    Atomics.wait(int322, 0, 0);
                    const int32_2 = new Int32Array(new SharedArrayBuffer(int322[1] + 3 - (int322[1] + 3) % 4));
                    worker2.postMessage(int32_2);
                    Atomics.wait(int322, 0, 1);
                    var x = new Uint8Array(int32_2.buffer, 0, int322[1]);
                    uInt8Array = x;
                    worker2.terminate();
                    fs2.writeFileSync(filePath, uInt8Array);
                  } else {
                    uInt8Array = fs2.readFileSync(filePath);
                  }
                } catch (e) {
                  console.log("Error fetching module", e);
                  return 0;
                }
              } else {
                const xhr = new XMLHttpRequest();
                xhr.open("GET", url2, false);
                xhr.responseType = "arraybuffer";
                xhr.send(null);
                if (xhr.status != 200)
                  return 0;
                uInt8Array = xhr.response;
              }
              var valid = WebAssembly.validate(uInt8Array);
              var len2 = uInt8Array.byteLength;
              var fileOnWasmHeap = _malloc(len2 + 4);
              var properArray = new Uint8Array(uInt8Array);
              for (var iii = 0; iii < len2; iii++) {
                Module.HEAPU8[iii + fileOnWasmHeap + 4] = properArray[iii];
              }
              var LEN123 = new Uint8Array(4);
              LEN123[0] = len2 % 256;
              len2 -= LEN123[0];
              len2 /= 256;
              LEN123[1] = len2 % 256;
              len2 -= LEN123[1];
              len2 /= 256;
              LEN123[2] = len2 % 256;
              len2 -= LEN123[2];
              len2 /= 256;
              LEN123[3] = len2 % 256;
              len2 -= LEN123[3];
              len2 /= 256;
              Module.HEAPU8.set(LEN123, fileOnWasmHeap);
              FS.writeFile(UTF8ToString($1), new Uint8Array(uInt8Array));
              return fileOnWasmHeap;
            },
            2135069: ($0) => {
              if (!$0) {
                AL.alcErr = 40964;
                return 1;
              }
            },
            2135117: ($0) => {
              if (!AL.currentCtx) {
                err("alGetProcAddress() called without a valid context");
                return 1;
              }
              if (!$0) {
                AL.currentCtx.err = 40963;
                return 1;
              }
            }
          };
          function ExitStatus(status) {
            this.name = "ExitStatus";
            this.message = `Program terminated with exit(${status})`;
            this.status = status;
          }
          var GOT = {};
          var currentModuleWeakSymbols = /* @__PURE__ */ new Set([]);
          var GOTHandler = {
            get(obj, symName) {
              var rtn = GOT[symName];
              if (!rtn) {
                rtn = GOT[symName] = new WebAssembly.Global({
                  "value": "i32",
                  "mutable": true
                });
              }
              if (!currentModuleWeakSymbols.has(symName)) {
                rtn.required = true;
              }
              return rtn;
            }
          };
          var callRuntimeCallbacks = (callbacks) => {
            while (callbacks.length > 0) {
              callbacks.shift()(Module);
            }
          };
          var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : void 0;
          var UTF8ArrayToString = (heapOrArray, idx, maxBytesToRead) => {
            idx >>>= 0;
            var endIdx = idx + maxBytesToRead;
            var endPtr = idx;
            while (heapOrArray[endPtr] && !(endPtr >= endIdx))
              ++endPtr;
            if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
              return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
            }
            var str = "";
            while (idx < endPtr) {
              var u0 = heapOrArray[idx++];
              if (!(u0 & 128)) {
                str += String.fromCharCode(u0);
                continue;
              }
              var u1 = heapOrArray[idx++] & 63;
              if ((u0 & 224) == 192) {
                str += String.fromCharCode((u0 & 31) << 6 | u1);
                continue;
              }
              var u2 = heapOrArray[idx++] & 63;
              if ((u0 & 240) == 224) {
                u0 = (u0 & 15) << 12 | u1 << 6 | u2;
              } else {
                u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
              }
              if (u0 < 65536) {
                str += String.fromCharCode(u0);
              } else {
                var ch = u0 - 65536;
                str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
              }
            }
            return str;
          };
          var getDylinkMetadata = (binary2) => {
            var offset = 0;
            var end = 0;
            function getU8() {
              return binary2[offset++];
            }
            function getLEB() {
              var ret = 0;
              var mul = 1;
              while (1) {
                var byte = binary2[offset++];
                ret += (byte & 127) * mul;
                mul *= 128;
                if (!(byte & 128))
                  break;
              }
              return ret;
            }
            function getString() {
              var len2 = getLEB();
              offset += len2;
              return UTF8ArrayToString(binary2, offset - len2, len2);
            }
            function failIf(condition, message) {
              if (condition)
                throw new Error(message);
            }
            var name2 = "dylink.0";
            if (binary2 instanceof WebAssembly.Module) {
              var dylinkSection = WebAssembly.Module.customSections(binary2, name2);
              if (dylinkSection.length === 0) {
                name2 = "dylink";
                dylinkSection = WebAssembly.Module.customSections(binary2, name2);
              }
              failIf(dylinkSection.length === 0, "need dylink section");
              binary2 = new Uint8Array(dylinkSection[0]);
              end = binary2.length;
            } else {
              var int32View = new Uint32Array(new Uint8Array(binary2.subarray(0, 24)).buffer);
              var magicNumberFound = int32View[0] == 1836278016;
              failIf(!magicNumberFound, "need to see wasm magic number");
              failIf(binary2[8] !== 0, "need the dylink section to be first");
              offset = 9;
              var section_size = getLEB();
              end = offset + section_size;
              name2 = getString();
            }
            var customSection = {
              neededDynlibs: [],
              tlsExports: /* @__PURE__ */ new Set(),
              weakImports: /* @__PURE__ */ new Set()
            };
            if (name2 == "dylink") {
              customSection.memorySize = getLEB();
              customSection.memoryAlign = getLEB();
              customSection.tableSize = getLEB();
              customSection.tableAlign = getLEB();
              var neededDynlibsCount = getLEB();
              for (var i2 = 0; i2 < neededDynlibsCount; ++i2) {
                var libname = getString();
                customSection.neededDynlibs.push(libname);
              }
            } else {
              failIf(name2 !== "dylink.0");
              var WASM_DYLINK_MEM_INFO = 1;
              var WASM_DYLINK_NEEDED = 2;
              var WASM_DYLINK_EXPORT_INFO = 3;
              var WASM_DYLINK_IMPORT_INFO = 4;
              var WASM_SYMBOL_TLS = 256;
              var WASM_SYMBOL_BINDING_MASK = 3;
              var WASM_SYMBOL_BINDING_WEAK = 1;
              while (offset < end) {
                var subsectionType = getU8();
                var subsectionSize = getLEB();
                if (subsectionType === WASM_DYLINK_MEM_INFO) {
                  customSection.memorySize = getLEB();
                  customSection.memoryAlign = getLEB();
                  customSection.tableSize = getLEB();
                  customSection.tableAlign = getLEB();
                } else if (subsectionType === WASM_DYLINK_NEEDED) {
                  var neededDynlibsCount = getLEB();
                  for (var i2 = 0; i2 < neededDynlibsCount; ++i2) {
                    libname = getString();
                    customSection.neededDynlibs.push(libname);
                  }
                } else if (subsectionType === WASM_DYLINK_EXPORT_INFO) {
                  var count = getLEB();
                  while (count--) {
                    var symname = getString();
                    var flags2 = getLEB();
                    if (flags2 & WASM_SYMBOL_TLS) {
                      customSection.tlsExports.add(symname);
                    }
                  }
                } else if (subsectionType === WASM_DYLINK_IMPORT_INFO) {
                  var count = getLEB();
                  while (count--) {
                    var modname = getString();
                    var symname = getString();
                    var flags2 = getLEB();
                    if ((flags2 & WASM_SYMBOL_BINDING_MASK) == WASM_SYMBOL_BINDING_WEAK) {
                      customSection.weakImports.add(symname);
                    }
                  }
                } else {
                  offset += subsectionSize;
                }
              }
            }
            return customSection;
          };
          function getValue(ptr2, type = "i8") {
            if (type.endsWith("*"))
              type = "*";
            switch (type) {
              case "i1":
                return HEAP8[ptr2 >>> 0 >>> 0];
              case "i8":
                return HEAP8[ptr2 >>> 0 >>> 0];
              case "i16":
                return HEAP16[ptr2 >>> 1 >>> 0];
              case "i32":
                return HEAP32[ptr2 >>> 2 >>> 0];
              case "i64":
                abort("to do getValue(i64) use WASM_BIGINT");
              case "float":
                return HEAPF32[ptr2 >>> 2 >>> 0];
              case "double":
                return HEAPF64[ptr2 >>> 3 >>> 0];
              case "*":
                return HEAPU32[ptr2 >>> 2 >>> 0];
              default:
                abort(`invalid type for getValue: ${type}`);
            }
          }
          var newDSO = (name2, handle2, syms) => {
            var dso = {
              refcount: Infinity,
              name: name2,
              exports: syms,
              global: true
            };
            LDSO.loadedLibsByName[name2] = dso;
            if (handle2 != void 0) {
              LDSO.loadedLibsByHandle[handle2] = dso;
            }
            return dso;
          };
          var LDSO = {
            loadedLibsByName: {},
            loadedLibsByHandle: {},
            init() {
              newDSO("__main__", 0, wasmImports);
            }
          };
          var ___heap_base = 2277632;
          var zeroMemory = (address, size) => {
            HEAPU8.fill(0, address, address + size);
            return address;
          };
          var alignMemory = (size, alignment) => Math.ceil(size / alignment) * alignment;
          var getMemory = (size) => {
            if (runtimeInitialized) {
              return zeroMemory(_malloc(size), size);
            }
            var ret = ___heap_base;
            var end = ret + alignMemory(size, 16);
            ___heap_base = end;
            GOT["__heap_base"].value = end;
            return ret;
          };
          var isInternalSym = (symName) => ["__cpp_exception", "__c_longjmp", "__wasm_apply_data_relocs", "__dso_handle", "__tls_size", "__tls_align", "__set_stack_limits", "_emscripten_tls_init", "__wasm_init_tls", "__wasm_call_ctors", "__start_em_asm", "__stop_em_asm", "__start_em_js", "__stop_em_js"].includes(symName) || symName.startsWith("__em_js__");
          var uleb128Encode = (n, target) => {
            if (n < 128) {
              target.push(n);
            } else {
              target.push(n % 128 | 128, n >> 7);
            }
          };
          var sigToWasmTypes = (sig) => {
            var typeNames = {
              "i": "i32",
              "j": "i64",
              "f": "f32",
              "d": "f64",
              "e": "externref",
              "p": "i32"
            };
            var type = {
              parameters: [],
              results: sig[0] == "v" ? [] : [typeNames[sig[0]]]
            };
            for (var i2 = 1; i2 < sig.length; ++i2) {
              type.parameters.push(typeNames[sig[i2]]);
            }
            return type;
          };
          var generateFuncType = (sig, target) => {
            var sigRet = sig.slice(0, 1);
            var sigParam = sig.slice(1);
            var typeCodes = {
              "i": 127,
              "p": 127,
              "j": 126,
              "f": 125,
              "d": 124,
              "e": 111
            };
            target.push(96);
            uleb128Encode(sigParam.length, target);
            for (var i2 = 0; i2 < sigParam.length; ++i2) {
              target.push(typeCodes[sigParam[i2]]);
            }
            if (sigRet == "v") {
              target.push(0);
            } else {
              target.push(1, typeCodes[sigRet]);
            }
          };
          var convertJsFunctionToWasm = (func2, sig) => {
            if (typeof WebAssembly.Function == "function") {
              return new WebAssembly.Function(sigToWasmTypes(sig), func2);
            }
            var typeSectionBody = [1];
            generateFuncType(sig, typeSectionBody);
            var bytes = [0, 97, 115, 109, 1, 0, 0, 0, 1];
            uleb128Encode(typeSectionBody.length, bytes);
            bytes.push.apply(bytes, typeSectionBody);
            bytes.push(2, 7, 1, 1, 101, 1, 102, 0, 0, 7, 5, 1, 1, 102, 0, 0);
            var module2 = new WebAssembly.Module(new Uint8Array(bytes));
            var instance10 = new WebAssembly.Instance(module2, {
              "e": {
                "f": func2
              }
            });
            var wrappedFunc = instance10.exports["f"];
            return wrappedFunc;
          };
          var wasmTable = new WebAssembly.Table({
            "initial": 36736,
            "element": "anyfunc"
          });
          var getWasmTableEntry = (funcPtr) => wasmTable.get(funcPtr);
          var updateTableMap = (offset, count) => {
            if (functionsInTableMap) {
              for (var i2 = offset; i2 < offset + count; i2++) {
                var item = getWasmTableEntry(i2);
                if (item) {
                  functionsInTableMap.set(item, i2);
                }
              }
            }
          };
          var functionsInTableMap;
          var getFunctionAddress = (func2) => {
            if (!functionsInTableMap) {
              functionsInTableMap = /* @__PURE__ */ new WeakMap();
              updateTableMap(0, wasmTable.length);
            }
            return functionsInTableMap.get(func2) || 0;
          };
          var freeTableIndexes = [];
          var getEmptyTableSlot = () => {
            if (freeTableIndexes.length) {
              return freeTableIndexes.pop();
            }
            try {
              wasmTable.grow(1);
            } catch (err2) {
              if (!(err2 instanceof RangeError)) {
                throw err2;
              }
              throw "Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.";
            }
            return wasmTable.length - 1;
          };
          var setWasmTableEntry = (idx, func2) => wasmTable.set(idx, func2);
          var addFunction = (func2, sig) => {
            var rtn = getFunctionAddress(func2);
            if (rtn) {
              return rtn;
            }
            var ret = getEmptyTableSlot();
            try {
              setWasmTableEntry(ret, func2);
            } catch (err2) {
              if (!(err2 instanceof TypeError)) {
                throw err2;
              }
              var wrapped = convertJsFunctionToWasm(func2, sig);
              setWasmTableEntry(ret, wrapped);
            }
            functionsInTableMap.set(func2, ret);
            return ret;
          };
          var updateGOT = (exports2, replace) => {
            for (var symName in exports2) {
              if (isInternalSym(symName)) {
                continue;
              }
              var value = exports2[symName];
              if (symName.startsWith("orig$")) {
                symName = symName.split("$")[1];
                replace = true;
              }
              GOT[symName] || (GOT[symName] = new WebAssembly.Global({
                "value": "i32",
                "mutable": true
              }));
              if (replace || GOT[symName].value == 0) {
                if (typeof value == "function") {
                  GOT[symName].value = addFunction(value);
                } else if (typeof value == "number") {
                  GOT[symName].value = value;
                } else {
                  err(`unhandled export type for '${symName}': ${typeof value}`);
                }
              }
            }
          };
          var relocateExports = (exports2, memoryBase2, replace) => {
            var relocated = {};
            for (var e in exports2) {
              var value = exports2[e];
              if (typeof value == "object") {
                value = value.value;
              }
              if (typeof value == "number") {
                value += memoryBase2;
              }
              relocated[e] = value;
            }
            updateGOT(relocated, replace);
            return relocated;
          };
          var isSymbolDefined = (symName) => {
            var existing = wasmImports[symName];
            if (!existing || existing.stub) {
              return false;
            }
            return true;
          };
          var createDyncallWrapper = (sig) => {
            var sections = [];
            var prelude = [0, 97, 115, 109, 1, 0, 0, 0];
            sections.push(prelude);
            var wrappersig = [sig[0].replace("j", "i"), "i", sig.slice(1).replace(/j/g, "ii")].join("");
            var typeSectionBody = [3];
            generateFuncType(wrappersig, typeSectionBody);
            generateFuncType(sig, typeSectionBody);
            generateFuncType("vi", typeSectionBody);
            var typeSection = [1];
            uleb128Encode(typeSectionBody.length, typeSection);
            typeSection.push.apply(typeSection, typeSectionBody);
            sections.push(typeSection);
            var importSection = [2, 15, 2, 1, 101, 1, 116, 1, 112, 0, 0, 1, 101, 1, 114, 0, 2];
            sections.push(importSection);
            var functionSection = [3, 2, 1, 0];
            sections.push(functionSection);
            var exportSection = [7, 5, 1, 1, 102, 0, 1];
            sections.push(exportSection);
            var convert_code = [];
            if (sig[0] === "j") {
              convert_code = [1, 1, 126];
            } else {
              convert_code.push(0);
            }
            function localGet(j2) {
              convert_code.push(32);
              uleb128Encode(j2, convert_code);
            }
            var j = 1;
            for (var i2 = 1; i2 < sig.length; i2++) {
              if (sig[i2] == "j") {
                localGet(j + 1);
                convert_code.push(173, 66, 32, 134);
                localGet(j);
                convert_code.push(172, 132);
                j += 2;
              } else {
                localGet(j);
                j++;
              }
            }
            convert_code.push(32, 0, 17, 1, 0);
            if (sig[0] === "j") {
              convert_code.push(34);
              uleb128Encode(j, convert_code);
              convert_code.push(66, 32, 136, 167, 16, 0);
              localGet(j);
              convert_code.push(167);
            }
            convert_code.push(11);
            var codeBody = [1];
            uleb128Encode(convert_code.length, codeBody);
            codeBody.push.apply(codeBody, convert_code);
            var codeSection = [10];
            uleb128Encode(codeBody.length, codeSection);
            codeSection.push.apply(codeSection, codeBody);
            sections.push(codeSection);
            var bytes = new Uint8Array([].concat.apply([], sections));
            var module2 = new WebAssembly.Module(bytes);
            var instance10 = new WebAssembly.Instance(module2, {
              "e": {
                "t": wasmTable,
                "r": setTempRet0
              }
            });
            var wrappedFunc = instance10.exports["f"];
            return wrappedFunc;
          };
          var dynCallLegacy = (sig, ptr2, args2) => {
            if (!("dynCall_" + sig in Module)) {
              Module["dynCall_" + sig] = createDyncallWrapper(sig);
            }
            var f = Module["dynCall_" + sig];
            return args2 && args2.length ? f.apply(null, [ptr2].concat(args2)) : f.call(null, ptr2);
          };
          var dynCall = (sig, ptr2, args2) => {
            if (sig.includes("j")) {
              return dynCallLegacy(sig, ptr2, args2);
            }
            var rtn = getWasmTableEntry(ptr2).apply(null, args2);
            return rtn;
          };
          var createInvokeFunction = (sig) => function() {
            var sp = stackSave();
            try {
              return dynCall(sig, arguments[0], Array.prototype.slice.call(arguments, 1));
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          };
          var resolveGlobalSymbol = (symName, direct = false) => {
            var sym;
            if (direct && "orig$" + symName in wasmImports) {
              symName = "orig$" + symName;
            }
            if (isSymbolDefined(symName)) {
              sym = wasmImports[symName];
            } else if (symName.startsWith("invoke_")) {
              sym = wasmImports[symName] = createInvokeFunction(symName.split("_")[1]);
            } else if (symName.startsWith("__cxa_find_matching_catch_")) {
              sym = wasmImports[symName] = function() {
                var args2 = Array.from(arguments);
                var rtn = findMatchingCatch(args2);
                return rtn;
              };
            }
            return {
              sym,
              name: symName
            };
          };
          var UTF8ToString = (ptr2, maxBytesToRead) => {
            ptr2 >>>= 0;
            return ptr2 ? UTF8ArrayToString(HEAPU8, ptr2, maxBytesToRead) : "";
          };
          var loadWebAssemblyModule = (binary, flags, libName, localScope, handle) => {
            var metadata = getDylinkMetadata(binary);
            currentModuleWeakSymbols = metadata.weakImports;
            function loadModule() {
              var firstLoad = !handle || !HEAP8[handle + 8 >>> 0 >>> 0];
              if (firstLoad) {
                var memAlign = Math.pow(2, metadata.memoryAlign);
                var memoryBase = metadata.memorySize ? alignMemory(getMemory(metadata.memorySize + memAlign), memAlign) : 0;
                var tableBase = metadata.tableSize ? wasmTable.length : 0;
                if (handle) {
                  HEAP8[handle + 8 >>> 0 >>> 0] = 1;
                  HEAPU32[handle + 12 >>> 2 >>> 0] = memoryBase;
                  HEAP32[handle + 16 >>> 2 >>> 0] = metadata.memorySize;
                  HEAPU32[handle + 20 >>> 2 >>> 0] = tableBase;
                  HEAP32[handle + 24 >>> 2 >>> 0] = metadata.tableSize;
                }
              } else {
                memoryBase = HEAPU32[handle + 12 >>> 2 >>> 0];
                tableBase = HEAPU32[handle + 20 >>> 2 >>> 0];
              }
              var tableGrowthNeeded = tableBase + metadata.tableSize - wasmTable.length;
              if (tableGrowthNeeded > 0) {
                wasmTable.grow(tableGrowthNeeded);
              }
              var moduleExports;
              function resolveSymbol(sym) {
                var resolved = resolveGlobalSymbol(sym).sym;
                if (!resolved && localScope) {
                  resolved = localScope[sym];
                }
                if (!resolved) {
                  resolved = moduleExports[sym];
                }
                return resolved;
              }
              var proxyHandler = {
                get(stubs, prop) {
                  switch (prop) {
                    case "__memory_base":
                      return memoryBase;
                    case "__table_base":
                      return tableBase;
                  }
                  if (prop in wasmImports && !wasmImports[prop].stub) {
                    return wasmImports[prop];
                  }
                  if (!(prop in stubs)) {
                    var resolved;
                    stubs[prop] = function() {
                      resolved || (resolved = resolveSymbol(prop));
                      return resolved.apply(null, arguments);
                    };
                  }
                  return stubs[prop];
                }
              };
              var proxy = new Proxy({}, proxyHandler);
              var info = {
                "GOT.mem": new Proxy({}, GOTHandler),
                "GOT.func": new Proxy({}, GOTHandler),
                "env": proxy,
                "wasi_snapshot_preview1": proxy
              };
              function postInstantiation(module, instance) {
                updateTableMap(tableBase, metadata.tableSize);
                moduleExports = relocateExports(instance.exports, memoryBase);
                if (!flags.allowUndefined) {
                  reportUndefinedSymbols();
                }
                function addEmAsm(addr, body) {
                  var args = [];
                  var arity = 0;
                  for (; arity < 16; arity++) {
                    if (body.indexOf("$" + arity) != -1) {
                      args.push("$" + arity);
                    } else {
                      break;
                    }
                  }
                  args = args.join(",");
                  var func = `(${args}) => { ${body} };`;
                  ASM_CONSTS[start] = eval(func);
                }
                if ("__start_em_asm" in moduleExports) {
                  var start = moduleExports["__start_em_asm"];
                  var stop = moduleExports["__stop_em_asm"];
                  while (start < stop) {
                    var jsString = UTF8ToString(start);
                    addEmAsm(start, jsString);
                    start = HEAPU8.indexOf(0, start) + 1;
                  }
                }
                function addEmJs(name, cSig, body) {
                  var jsArgs = [];
                  cSig = cSig.slice(1, -1);
                  if (cSig != "void") {
                    cSig = cSig.split(",");
                    for (var i in cSig) {
                      var jsArg = cSig[i].split(" ").pop();
                      jsArgs.push(jsArg.replace("*", ""));
                    }
                  }
                  var func = `(${jsArgs}) => ${body};`;
                  moduleExports[name] = eval(func);
                }
                for (var name in moduleExports) {
                  if (name.startsWith("__em_js__")) {
                    var start = moduleExports[name];
                    var jsString = UTF8ToString(start);
                    var parts = jsString.split("<::>");
                    addEmJs(name.replace("__em_js__", ""), parts[0], parts[1]);
                    delete moduleExports[name];
                  }
                }
                var applyRelocs = moduleExports["__wasm_apply_data_relocs"];
                if (applyRelocs) {
                  if (runtimeInitialized) {
                    applyRelocs();
                  } else {
                    __RELOC_FUNCS__.push(applyRelocs);
                  }
                }
                var init = moduleExports["__wasm_call_ctors"];
                if (init) {
                  if (runtimeInitialized) {
                    init();
                  } else {
                    __ATINIT__.push(init);
                  }
                }
                return moduleExports;
              }
              if (flags.loadAsync) {
                if (binary instanceof WebAssembly.Module) {
                  var instance = new WebAssembly.Instance(binary, info);
                  return Promise.resolve(postInstantiation(binary, instance));
                }
                return WebAssembly.instantiate(binary, info).then((result) => postInstantiation(result.module, result.instance));
              }
              var module = binary instanceof WebAssembly.Module ? binary : new WebAssembly.Module(binary);
              var instance = new WebAssembly.Instance(module, info);
              return postInstantiation(module, instance);
            }
            if (flags.loadAsync) {
              return metadata.neededDynlibs.reduce((chain, dynNeeded) => chain.then(() => loadDynamicLibrary(dynNeeded, flags)), Promise.resolve()).then(loadModule);
            }
            metadata.neededDynlibs.forEach((needed) => loadDynamicLibrary(needed, flags, localScope));
            return loadModule();
          };
          var mergeLibSymbols = (exports2, libName2) => {
            for (var [sym, exp] of Object.entries(exports2)) {
              const setImport = (target) => {
                if (!isSymbolDefined(target)) {
                  wasmImports[target] = exp;
                }
              };
              setImport(sym);
              if (sym.startsWith("dynCall_") && !Module.hasOwnProperty(sym)) {
                Module[sym] = exp;
              }
            }
          };
          var asyncLoad = (url2, onload2, onerror2, noRunDep) => {
            var dep = !noRunDep ? getUniqueRunDependency(`al ${url2}`) : "";
            readAsync(url2, (arrayBuffer) => {
              onload2(new Uint8Array(arrayBuffer));
              if (dep)
                removeRunDependency(dep);
            }, (event2) => {
              if (onerror2) {
                onerror2();
              } else {
                throw `Loading data file "${url2}" failed.`;
              }
            });
            if (dep)
              addRunDependency(dep);
          };
          var preloadPlugins = Module["preloadPlugins"] || [];
          var registerWasmPlugin = () => {
            var wasmPlugin = {
              "promiseChainEnd": Promise.resolve(),
              "canHandle": (name2) => !Module.noWasmDecoding && name2.endsWith(".so"),
              "handle": (byteArray, name2, onload2, onerror2) => {
                wasmPlugin["promiseChainEnd"] = wasmPlugin["promiseChainEnd"].then(() => loadWebAssemblyModule(byteArray, {
                  loadAsync: true,
                  nodelete: true
                }, name2)).then((exports2) => {
                  preloadedWasm[name2] = exports2;
                  onload2(byteArray);
                }, (error) => {
                  err(`failed to instantiate wasm: ${name2}: ${error}`);
                  onerror2();
                });
              }
            };
            preloadPlugins.push(wasmPlugin);
          };
          var preloadedWasm = {};
          function loadDynamicLibrary(libName2, flags2 = {
            global: true,
            nodelete: true
          }, localScope2, handle2) {
            var dso = LDSO.loadedLibsByName[libName2];
            if (dso) {
              if (!flags2.global) {
                if (localScope2) {
                  Object.assign(localScope2, dso.exports);
                }
              } else if (!dso.global) {
                dso.global = true;
                mergeLibSymbols(dso.exports, libName2);
              }
              if (flags2.nodelete && dso.refcount !== Infinity) {
                dso.refcount = Infinity;
              }
              dso.refcount++;
              if (handle2) {
                LDSO.loadedLibsByHandle[handle2] = dso;
              }
              return flags2.loadAsync ? Promise.resolve(true) : true;
            }
            dso = newDSO(libName2, handle2, "loading");
            dso.refcount = flags2.nodelete ? Infinity : 1;
            dso.global = flags2.global;
            function loadLibData() {
              if (handle2) {
                var data2 = HEAPU32[handle2 + 28 >>> 2 >>> 0];
                var dataSize = HEAPU32[handle2 + 32 >>> 2 >>> 0];
                if (data2 && dataSize) {
                  var libData = HEAP8.slice(data2, data2 + dataSize);
                  return flags2.loadAsync ? Promise.resolve(libData) : libData;
                }
              }
              var libFile = locateFile(libName2);
              if (flags2.loadAsync) {
                return new Promise(function(resolve, reject) {
                  asyncLoad(libFile, resolve, reject);
                });
              }
              if (!readBinary) {
                throw new Error(`${libFile}: file not found, and synchronous loading of external files is not available`);
              }
              return readBinary(libFile);
            }
            function getExports() {
              var preloaded = preloadedWasm[libName2];
              if (preloaded) {
                return flags2.loadAsync ? Promise.resolve(preloaded) : preloaded;
              }
              if (flags2.loadAsync) {
                return loadLibData().then((libData) => loadWebAssemblyModule(libData, flags2, libName2, localScope2, handle2));
              }
              return loadWebAssemblyModule(loadLibData(), flags2, libName2, localScope2, handle2);
            }
            function moduleLoaded(exports2) {
              if (dso.global) {
                mergeLibSymbols(exports2, libName2);
              } else if (localScope2) {
                Object.assign(localScope2, exports2);
              }
              dso.exports = exports2;
            }
            if (flags2.loadAsync) {
              return getExports().then((exports2) => {
                moduleLoaded(exports2);
                return true;
              });
            }
            moduleLoaded(getExports());
            return true;
          }
          var reportUndefinedSymbols = () => {
            for (var [symName, entry] of Object.entries(GOT)) {
              if (entry.value == 0) {
                var value = resolveGlobalSymbol(symName, true).sym;
                if (!value && !entry.required) {
                  continue;
                }
                if (typeof value == "function") {
                  entry.value = addFunction(value, value.sig);
                } else if (typeof value == "number") {
                  entry.value = value;
                } else {
                  throw new Error(`bad export type for '${symName}': ${typeof value}`);
                }
              }
            }
          };
          var loadDylibs = () => {
            if (!dynamicLibraries.length) {
              reportUndefinedSymbols();
              return;
            }
            addRunDependency("loadDylibs");
            dynamicLibraries.reduce((chain, lib) => chain.then(() => loadDynamicLibrary(lib, {
              loadAsync: true,
              global: true,
              nodelete: true,
              allowUndefined: true
            })), Promise.resolve()).then(() => {
              reportUndefinedSymbols();
              removeRunDependency("loadDylibs");
            });
          };
          var noExitRuntime = Module["noExitRuntime"] || true;
          function setValue(ptr2, value, type = "i8") {
            if (type.endsWith("*"))
              type = "*";
            switch (type) {
              case "i1":
                HEAP8[ptr2 >>> 0 >>> 0] = value;
                break;
              case "i8":
                HEAP8[ptr2 >>> 0 >>> 0] = value;
                break;
              case "i16":
                HEAP16[ptr2 >>> 1 >>> 0] = value;
                break;
              case "i32":
                HEAP32[ptr2 >>> 2 >>> 0] = value;
                break;
              case "i64":
                abort("to do setValue(i64) use WASM_BIGINT");
              case "float":
                HEAPF32[ptr2 >>> 2 >>> 0] = value;
                break;
              case "double":
                HEAPF64[ptr2 >>> 3 >>> 0] = value;
                break;
              case "*":
                HEAPU32[ptr2 >>> 2 >>> 0] = value;
                break;
              default:
                abort(`invalid type for setValue: ${type}`);
            }
          }
          var convertI32PairToI53Checked = (lo, hi) => hi + 2097152 >>> 0 < 4194305 - !!lo ? (lo >>> 0) + hi * 4294967296 : NaN;
          function ___assert_fail(condition, filename, line, func2) {
            condition >>>= 0;
            filename >>>= 0;
            func2 >>>= 0;
            abort(`Assertion failed: ${UTF8ToString(condition)}, at: ` + [filename ? UTF8ToString(filename) : "unknown filename", line, func2 ? UTF8ToString(func2) : "unknown function"]);
          }
          ___assert_fail.sig = "vppip";
          function ___call_sighandler(fp, sig) {
            fp >>>= 0;
            return getWasmTableEntry(fp)(sig);
          }
          ___call_sighandler.sig = "vpi";
          var exceptionCaught = [];
          var uncaughtExceptionCount = 0;
          function ___cxa_begin_catch(ptr2) {
            ptr2 >>>= 0;
            var info2 = new ExceptionInfo(ptr2);
            if (!info2.get_caught()) {
              info2.set_caught(true);
              uncaughtExceptionCount--;
            }
            info2.set_rethrown(false);
            exceptionCaught.push(info2);
            ___cxa_increment_exception_refcount(info2.excPtr);
            return info2.get_exception_ptr();
          }
          ___cxa_begin_catch.sig = "pp";
          function ___cxa_current_primary_exception() {
            if (!exceptionCaught.length) {
              return 0;
            }
            var info2 = exceptionCaught[exceptionCaught.length - 1];
            ___cxa_increment_exception_refcount(info2.excPtr);
            return info2.excPtr;
          }
          ___cxa_current_primary_exception.sig = "p";
          var exceptionLast = 0;
          var ___cxa_end_catch = () => {
            _setThrew(0, 0);
            var info2 = exceptionCaught.pop();
            ___cxa_decrement_exception_refcount(info2.excPtr);
            exceptionLast = 0;
          };
          ___cxa_end_catch.sig = "v";
          class ExceptionInfo {
            constructor(excPtr) {
              this.excPtr = excPtr;
              this.ptr = excPtr - 24;
            }
            set_type(type) {
              HEAPU32[this.ptr + 4 >>> 2 >>> 0] = type;
            }
            get_type() {
              return HEAPU32[this.ptr + 4 >>> 2 >>> 0];
            }
            set_destructor(destructor) {
              HEAPU32[this.ptr + 8 >>> 2 >>> 0] = destructor;
            }
            get_destructor() {
              return HEAPU32[this.ptr + 8 >>> 2 >>> 0];
            }
            set_caught(caught) {
              caught = caught ? 1 : 0;
              HEAP8[this.ptr + 12 >>> 0 >>> 0] = caught;
            }
            get_caught() {
              return HEAP8[this.ptr + 12 >>> 0 >>> 0] != 0;
            }
            set_rethrown(rethrown) {
              rethrown = rethrown ? 1 : 0;
              HEAP8[this.ptr + 13 >>> 0 >>> 0] = rethrown;
            }
            get_rethrown() {
              return HEAP8[this.ptr + 13 >>> 0 >>> 0] != 0;
            }
            init(type, destructor) {
              this.set_adjusted_ptr(0);
              this.set_type(type);
              this.set_destructor(destructor);
            }
            set_adjusted_ptr(adjustedPtr) {
              HEAPU32[this.ptr + 16 >>> 2 >>> 0] = adjustedPtr;
            }
            get_adjusted_ptr() {
              return HEAPU32[this.ptr + 16 >>> 2 >>> 0];
            }
            get_exception_ptr() {
              var isPointer = ___cxa_is_pointer_type(this.get_type());
              if (isPointer) {
                return HEAPU32[this.excPtr >>> 2 >>> 0];
              }
              var adjusted = this.get_adjusted_ptr();
              if (adjusted !== 0)
                return adjusted;
              return this.excPtr;
            }
          }
          function ___resumeException(ptr2) {
            ptr2 >>>= 0;
            if (!exceptionLast) {
              exceptionLast = ptr2;
            }
            throw exceptionLast;
          }
          ___resumeException.sig = "vp";
          var findMatchingCatch = (args2) => {
            var thrown = exceptionLast;
            if (!thrown) {
              setTempRet0(0);
              return 0;
            }
            var info2 = new ExceptionInfo(thrown);
            info2.set_adjusted_ptr(thrown);
            var thrownType = info2.get_type();
            if (!thrownType) {
              setTempRet0(0);
              return thrown;
            }
            for (var arg in args2) {
              var caughtType = args2[arg];
              if (caughtType === 0 || caughtType === thrownType) {
                break;
              }
              var adjusted_ptr_addr = info2.ptr + 16;
              if (___cxa_can_catch(caughtType, thrownType, adjusted_ptr_addr)) {
                setTempRet0(caughtType);
                return thrown;
              }
            }
            setTempRet0(thrownType);
            return thrown;
          };
          function ___cxa_find_matching_catch_2() {
            return findMatchingCatch([]);
          }
          ___cxa_find_matching_catch_2.sig = "p";
          function ___cxa_find_matching_catch_3(arg0) {
            arg0 >>>= 0;
            return findMatchingCatch([arg0]);
          }
          ___cxa_find_matching_catch_3.sig = "pp";
          function ___cxa_find_matching_catch_4(arg0, arg1) {
            arg0 >>>= 0;
            arg1 >>>= 0;
            return findMatchingCatch([arg0, arg1]);
          }
          ___cxa_find_matching_catch_4.sig = "ppp";
          function ___cxa_find_matching_catch_5(arg0, arg1, arg2) {
            arg0 >>>= 0;
            arg1 >>>= 0;
            arg2 >>>= 0;
            return findMatchingCatch([arg0, arg1, arg2]);
          }
          ___cxa_find_matching_catch_5.sig = "pppp";
          function ___cxa_find_matching_catch_6(arg0, arg1, arg2, arg3) {
            arg0 >>>= 0;
            arg1 >>>= 0;
            arg2 >>>= 0;
            arg3 >>>= 0;
            return findMatchingCatch([arg0, arg1, arg2, arg3]);
          }
          ___cxa_find_matching_catch_6.sig = "ppppp";
          function ___cxa_find_matching_catch_7(arg0, arg1, arg2, arg3, arg4) {
            arg0 >>>= 0;
            arg1 >>>= 0;
            arg2 >>>= 0;
            arg3 >>>= 0;
            arg4 >>>= 0;
            return findMatchingCatch([arg0, arg1, arg2, arg3, arg4]);
          }
          ___cxa_find_matching_catch_7.sig = "pppppp";
          var ___cxa_rethrow = () => {
            var info2 = exceptionCaught.pop();
            if (!info2) {
              abort("no exception to throw");
            }
            var ptr2 = info2.excPtr;
            if (!info2.get_rethrown()) {
              exceptionCaught.push(info2);
              info2.set_rethrown(true);
              info2.set_caught(false);
              uncaughtExceptionCount++;
            }
            exceptionLast = ptr2;
            throw exceptionLast;
          };
          ___cxa_rethrow.sig = "v";
          function ___cxa_rethrow_primary_exception(ptr2) {
            ptr2 >>>= 0;
            if (!ptr2)
              return;
            var info2 = new ExceptionInfo(ptr2);
            exceptionCaught.push(info2);
            info2.set_rethrown(true);
            ___cxa_rethrow();
          }
          ___cxa_rethrow_primary_exception.sig = "vp";
          function ___cxa_throw(ptr2, type, destructor) {
            ptr2 >>>= 0;
            type >>>= 0;
            destructor >>>= 0;
            var info2 = new ExceptionInfo(ptr2);
            info2.init(type, destructor);
            exceptionLast = ptr2;
            uncaughtExceptionCount++;
            throw exceptionLast;
          }
          ___cxa_throw.sig = "vppp";
          var ___cxa_uncaught_exceptions = () => uncaughtExceptionCount;
          ___cxa_uncaught_exceptions.sig = "i";
          var ___memory_base = new WebAssembly.Global({
            "value": "i32",
            "mutable": false
          }, 1024);
          var ___stack_high = 2277632;
          var ___stack_low = 2212096;
          var ___stack_pointer = new WebAssembly.Global({
            "value": "i32",
            "mutable": true
          }, 2277632);
          var PATH = {
            isAbs: (path) => path.charAt(0) === "/",
            splitPath: (filename) => {
              var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
              return splitPathRe.exec(filename).slice(1);
            },
            normalizeArray: (parts2, allowAboveRoot) => {
              var up = 0;
              for (var i2 = parts2.length - 1; i2 >= 0; i2--) {
                var last = parts2[i2];
                if (last === ".") {
                  parts2.splice(i2, 1);
                } else if (last === "..") {
                  parts2.splice(i2, 1);
                  up++;
                } else if (up) {
                  parts2.splice(i2, 1);
                  up--;
                }
              }
              if (allowAboveRoot) {
                for (; up; up--) {
                  parts2.unshift("..");
                }
              }
              return parts2;
            },
            normalize: (path) => {
              var isAbsolute = PATH.isAbs(path), trailingSlash = path.substr(-1) === "/";
              path = PATH.normalizeArray(path.split("/").filter((p) => !!p), !isAbsolute).join("/");
              if (!path && !isAbsolute) {
                path = ".";
              }
              if (path && trailingSlash) {
                path += "/";
              }
              return (isAbsolute ? "/" : "") + path;
            },
            dirname: (path) => {
              var result = PATH.splitPath(path), root = result[0], dir = result[1];
              if (!root && !dir) {
                return ".";
              }
              if (dir) {
                dir = dir.substr(0, dir.length - 1);
              }
              return root + dir;
            },
            basename: (path) => {
              if (path === "/")
                return "/";
              path = PATH.normalize(path);
              path = path.replace(/\/$/, "");
              var lastSlash = path.lastIndexOf("/");
              if (lastSlash === -1)
                return path;
              return path.substr(lastSlash + 1);
            },
            join: function() {
              var paths = Array.prototype.slice.call(arguments);
              return PATH.normalize(paths.join("/"));
            },
            join2: (l, r) => PATH.normalize(l + "/" + r)
          };
          var initRandomFill = () => {
            if (typeof crypto == "object" && typeof crypto["getRandomValues"] == "function") {
              return (view) => crypto.getRandomValues(view);
            } else if (ENVIRONMENT_IS_NODE) {
              try {
                var crypto_module = __require("crypto");
                var randomFillSync = crypto_module["randomFillSync"];
                if (randomFillSync) {
                  return (view) => crypto_module["randomFillSync"](view);
                }
                var randomBytes = crypto_module["randomBytes"];
                return (view) => (view.set(randomBytes(view.byteLength)), view);
              } catch (e) {
              }
            }
            abort("initRandomDevice");
          };
          var randomFill = (view) => (randomFill = initRandomFill())(view);
          var PATH_FS = {
            resolve: function() {
              var resolvedPath = "", resolvedAbsolute = false;
              for (var i2 = arguments.length - 1; i2 >= -1 && !resolvedAbsolute; i2--) {
                var path = i2 >= 0 ? arguments[i2] : FS.cwd();
                if (typeof path != "string") {
                  throw new TypeError("Arguments to path.resolve must be strings");
                } else if (!path) {
                  return "";
                }
                resolvedPath = path + "/" + resolvedPath;
                resolvedAbsolute = PATH.isAbs(path);
              }
              resolvedPath = PATH.normalizeArray(resolvedPath.split("/").filter((p) => !!p), !resolvedAbsolute).join("/");
              return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
            },
            relative: (from, to) => {
              from = PATH_FS.resolve(from).substr(1);
              to = PATH_FS.resolve(to).substr(1);
              function trim(arr) {
                var start2 = 0;
                for (; start2 < arr.length; start2++) {
                  if (arr[start2] !== "")
                    break;
                }
                var end = arr.length - 1;
                for (; end >= 0; end--) {
                  if (arr[end] !== "")
                    break;
                }
                if (start2 > end)
                  return [];
                return arr.slice(start2, end - start2 + 1);
              }
              var fromParts = trim(from.split("/"));
              var toParts = trim(to.split("/"));
              var length = Math.min(fromParts.length, toParts.length);
              var samePartsLength = length;
              for (var i2 = 0; i2 < length; i2++) {
                if (fromParts[i2] !== toParts[i2]) {
                  samePartsLength = i2;
                  break;
                }
              }
              var outputParts = [];
              for (var i2 = samePartsLength; i2 < fromParts.length; i2++) {
                outputParts.push("..");
              }
              outputParts = outputParts.concat(toParts.slice(samePartsLength));
              return outputParts.join("/");
            }
          };
          var FS_stdin_getChar_buffer = [];
          var lengthBytesUTF8 = (str) => {
            var len2 = 0;
            for (var i2 = 0; i2 < str.length; ++i2) {
              var c = str.charCodeAt(i2);
              if (c <= 127) {
                len2++;
              } else if (c <= 2047) {
                len2 += 2;
              } else if (c >= 55296 && c <= 57343) {
                len2 += 4;
                ++i2;
              } else {
                len2 += 3;
              }
            }
            return len2;
          };
          var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {
            outIdx >>>= 0;
            if (!(maxBytesToWrite > 0))
              return 0;
            var startIdx = outIdx;
            var endIdx = outIdx + maxBytesToWrite - 1;
            for (var i2 = 0; i2 < str.length; ++i2) {
              var u = str.charCodeAt(i2);
              if (u >= 55296 && u <= 57343) {
                var u1 = str.charCodeAt(++i2);
                u = 65536 + ((u & 1023) << 10) | u1 & 1023;
              }
              if (u <= 127) {
                if (outIdx >= endIdx)
                  break;
                heap[outIdx++ >>> 0] = u;
              } else if (u <= 2047) {
                if (outIdx + 1 >= endIdx)
                  break;
                heap[outIdx++ >>> 0] = 192 | u >> 6;
                heap[outIdx++ >>> 0] = 128 | u & 63;
              } else if (u <= 65535) {
                if (outIdx + 2 >= endIdx)
                  break;
                heap[outIdx++ >>> 0] = 224 | u >> 12;
                heap[outIdx++ >>> 0] = 128 | u >> 6 & 63;
                heap[outIdx++ >>> 0] = 128 | u & 63;
              } else {
                if (outIdx + 3 >= endIdx)
                  break;
                heap[outIdx++ >>> 0] = 240 | u >> 18;
                heap[outIdx++ >>> 0] = 128 | u >> 12 & 63;
                heap[outIdx++ >>> 0] = 128 | u >> 6 & 63;
                heap[outIdx++ >>> 0] = 128 | u & 63;
              }
            }
            heap[outIdx >>> 0] = 0;
            return outIdx - startIdx;
          };
          function intArrayFromString(stringy, dontAddNull, length) {
            var len2 = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
            var u8array = new Array(len2);
            var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
            if (dontAddNull)
              u8array.length = numBytesWritten;
            return u8array;
          }
          var FS_stdin_getChar = () => {
            if (!FS_stdin_getChar_buffer.length) {
              var result = null;
              if (ENVIRONMENT_IS_NODE) {
                var BUFSIZE = 256;
                var buf = Buffer.alloc(BUFSIZE);
                var bytesRead = 0;
                var fd = process.stdin.fd;
                try {
                  bytesRead = fs.readSync(fd, buf);
                } catch (e) {
                  if (e.toString().includes("EOF"))
                    bytesRead = 0;
                  else
                    throw e;
                }
                if (bytesRead > 0) {
                  result = buf.slice(0, bytesRead).toString("utf-8");
                } else {
                  result = null;
                }
              } else if (typeof window != "undefined" && typeof window.prompt == "function") {
                result = window.prompt("Input: ");
                if (result !== null) {
                  result += "\n";
                }
              } else if (typeof readline == "function") {
                result = readline();
                if (result !== null) {
                  result += "\n";
                }
              }
              if (!result) {
                return null;
              }
              FS_stdin_getChar_buffer = intArrayFromString(result, true);
            }
            return FS_stdin_getChar_buffer.shift();
          };
          var TTY = {
            ttys: [],
            init() {
            },
            shutdown() {
            },
            register(dev, ops) {
              TTY.ttys[dev] = {
                input: [],
                output: [],
                ops
              };
              FS.registerDevice(dev, TTY.stream_ops);
            },
            stream_ops: {
              open(stream) {
                var tty = TTY.ttys[stream.node.rdev];
                if (!tty) {
                  throw new FS.ErrnoError(43);
                }
                stream.tty = tty;
                stream.seekable = false;
              },
              close(stream) {
                stream.tty.ops.fsync(stream.tty);
              },
              fsync(stream) {
                stream.tty.ops.fsync(stream.tty);
              },
              read(stream, buffer, offset, length, pos) {
                if (!stream.tty || !stream.tty.ops.get_char) {
                  throw new FS.ErrnoError(60);
                }
                var bytesRead = 0;
                for (var i2 = 0; i2 < length; i2++) {
                  var result;
                  try {
                    result = stream.tty.ops.get_char(stream.tty);
                  } catch (e) {
                    throw new FS.ErrnoError(29);
                  }
                  if (result === void 0 && bytesRead === 0) {
                    throw new FS.ErrnoError(6);
                  }
                  if (result === null || result === void 0)
                    break;
                  bytesRead++;
                  buffer[offset + i2] = result;
                }
                if (bytesRead) {
                  stream.node.timestamp = Date.now();
                }
                return bytesRead;
              },
              write(stream, buffer, offset, length, pos) {
                if (!stream.tty || !stream.tty.ops.put_char) {
                  throw new FS.ErrnoError(60);
                }
                try {
                  for (var i2 = 0; i2 < length; i2++) {
                    stream.tty.ops.put_char(stream.tty, buffer[offset + i2]);
                  }
                } catch (e) {
                  throw new FS.ErrnoError(29);
                }
                if (length) {
                  stream.node.timestamp = Date.now();
                }
                return i2;
              }
            },
            default_tty_ops: {
              get_char(tty) {
                return FS_stdin_getChar();
              },
              put_char(tty, val) {
                if (val === null || val === 10) {
                  out(UTF8ArrayToString(tty.output, 0));
                  tty.output = [];
                } else {
                  if (val != 0)
                    tty.output.push(val);
                }
              },
              fsync(tty) {
                if (tty.output && tty.output.length > 0) {
                  out(UTF8ArrayToString(tty.output, 0));
                  tty.output = [];
                }
              },
              ioctl_tcgets(tty) {
                return {
                  c_iflag: 25856,
                  c_oflag: 5,
                  c_cflag: 191,
                  c_lflag: 35387,
                  c_cc: [3, 28, 127, 21, 4, 0, 1, 0, 17, 19, 26, 0, 18, 15, 23, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
                };
              },
              ioctl_tcsets(tty, optional_actions, data2) {
                return 0;
              },
              ioctl_tiocgwinsz(tty) {
                return [24, 80];
              }
            },
            default_tty1_ops: {
              put_char(tty, val) {
                if (val === null || val === 10) {
                  err(UTF8ArrayToString(tty.output, 0));
                  tty.output = [];
                } else {
                  if (val != 0)
                    tty.output.push(val);
                }
              },
              fsync(tty) {
                if (tty.output && tty.output.length > 0) {
                  err(UTF8ArrayToString(tty.output, 0));
                  tty.output = [];
                }
              }
            }
          };
          var mmapAlloc = (size) => {
            size = alignMemory(size, 65536);
            var ptr2 = _emscripten_builtin_memalign(65536, size);
            if (!ptr2)
              return 0;
            return zeroMemory(ptr2, size);
          };
          var MEMFS = {
            ops_table: null,
            mount(mount) {
              return MEMFS.createNode(null, "/", 16384 | 511, 0);
            },
            createNode(parent, name2, mode, dev) {
              if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
                throw new FS.ErrnoError(63);
              }
              MEMFS.ops_table || (MEMFS.ops_table = {
                dir: {
                  node: {
                    getattr: MEMFS.node_ops.getattr,
                    setattr: MEMFS.node_ops.setattr,
                    lookup: MEMFS.node_ops.lookup,
                    mknod: MEMFS.node_ops.mknod,
                    rename: MEMFS.node_ops.rename,
                    unlink: MEMFS.node_ops.unlink,
                    rmdir: MEMFS.node_ops.rmdir,
                    readdir: MEMFS.node_ops.readdir,
                    symlink: MEMFS.node_ops.symlink
                  },
                  stream: {
                    llseek: MEMFS.stream_ops.llseek
                  }
                },
                file: {
                  node: {
                    getattr: MEMFS.node_ops.getattr,
                    setattr: MEMFS.node_ops.setattr
                  },
                  stream: {
                    llseek: MEMFS.stream_ops.llseek,
                    read: MEMFS.stream_ops.read,
                    write: MEMFS.stream_ops.write,
                    allocate: MEMFS.stream_ops.allocate,
                    mmap: MEMFS.stream_ops.mmap,
                    msync: MEMFS.stream_ops.msync
                  }
                },
                link: {
                  node: {
                    getattr: MEMFS.node_ops.getattr,
                    setattr: MEMFS.node_ops.setattr,
                    readlink: MEMFS.node_ops.readlink
                  },
                  stream: {}
                },
                chrdev: {
                  node: {
                    getattr: MEMFS.node_ops.getattr,
                    setattr: MEMFS.node_ops.setattr
                  },
                  stream: FS.chrdev_stream_ops
                }
              });
              var node = FS.createNode(parent, name2, mode, dev);
              if (FS.isDir(node.mode)) {
                node.node_ops = MEMFS.ops_table.dir.node;
                node.stream_ops = MEMFS.ops_table.dir.stream;
                node.contents = {};
              } else if (FS.isFile(node.mode)) {
                node.node_ops = MEMFS.ops_table.file.node;
                node.stream_ops = MEMFS.ops_table.file.stream;
                node.usedBytes = 0;
                node.contents = null;
              } else if (FS.isLink(node.mode)) {
                node.node_ops = MEMFS.ops_table.link.node;
                node.stream_ops = MEMFS.ops_table.link.stream;
              } else if (FS.isChrdev(node.mode)) {
                node.node_ops = MEMFS.ops_table.chrdev.node;
                node.stream_ops = MEMFS.ops_table.chrdev.stream;
              }
              node.timestamp = Date.now();
              if (parent) {
                parent.contents[name2] = node;
                parent.timestamp = node.timestamp;
              }
              return node;
            },
            getFileDataAsTypedArray(node) {
              if (!node.contents)
                return new Uint8Array(0);
              if (node.contents.subarray)
                return node.contents.subarray(0, node.usedBytes);
              return new Uint8Array(node.contents);
            },
            expandFileStorage(node, newCapacity) {
              var prevCapacity = node.contents ? node.contents.length : 0;
              if (prevCapacity >= newCapacity)
                return;
              var CAPACITY_DOUBLING_MAX = 1024 * 1024;
              newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0);
              if (prevCapacity != 0)
                newCapacity = Math.max(newCapacity, 256);
              var oldContents = node.contents;
              node.contents = new Uint8Array(newCapacity);
              if (node.usedBytes > 0)
                node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
            },
            resizeFileStorage(node, newSize) {
              if (node.usedBytes == newSize)
                return;
              if (newSize == 0) {
                node.contents = null;
                node.usedBytes = 0;
              } else {
                var oldContents = node.contents;
                node.contents = new Uint8Array(newSize);
                if (oldContents) {
                  node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));
                }
                node.usedBytes = newSize;
              }
            },
            node_ops: {
              getattr(node) {
                var attr = {};
                attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
                attr.ino = node.id;
                attr.mode = node.mode;
                attr.nlink = 1;
                attr.uid = 0;
                attr.gid = 0;
                attr.rdev = node.rdev;
                if (FS.isDir(node.mode)) {
                  attr.size = 4096;
                } else if (FS.isFile(node.mode)) {
                  attr.size = node.usedBytes;
                } else if (FS.isLink(node.mode)) {
                  attr.size = node.link.length;
                } else {
                  attr.size = 0;
                }
                attr.atime = new Date(node.timestamp);
                attr.mtime = new Date(node.timestamp);
                attr.ctime = new Date(node.timestamp);
                attr.blksize = 4096;
                attr.blocks = Math.ceil(attr.size / attr.blksize);
                return attr;
              },
              setattr(node, attr) {
                if (attr.mode !== void 0) {
                  node.mode = attr.mode;
                }
                if (attr.timestamp !== void 0) {
                  node.timestamp = attr.timestamp;
                }
                if (attr.size !== void 0) {
                  MEMFS.resizeFileStorage(node, attr.size);
                }
              },
              lookup(parent, name2) {
                throw FS.genericErrors[44];
              },
              mknod(parent, name2, mode, dev) {
                return MEMFS.createNode(parent, name2, mode, dev);
              },
              rename(old_node, new_dir, new_name) {
                if (FS.isDir(old_node.mode)) {
                  var new_node;
                  try {
                    new_node = FS.lookupNode(new_dir, new_name);
                  } catch (e) {
                  }
                  if (new_node) {
                    for (var i2 in new_node.contents) {
                      throw new FS.ErrnoError(55);
                    }
                  }
                }
                delete old_node.parent.contents[old_node.name];
                old_node.parent.timestamp = Date.now();
                old_node.name = new_name;
                new_dir.contents[new_name] = old_node;
                new_dir.timestamp = old_node.parent.timestamp;
                old_node.parent = new_dir;
              },
              unlink(parent, name2) {
                delete parent.contents[name2];
                parent.timestamp = Date.now();
              },
              rmdir(parent, name2) {
                var node = FS.lookupNode(parent, name2);
                for (var i2 in node.contents) {
                  throw new FS.ErrnoError(55);
                }
                delete parent.contents[name2];
                parent.timestamp = Date.now();
              },
              readdir(node) {
                var entries = [".", ".."];
                for (var key of Object.keys(node.contents)) {
                  entries.push(key);
                }
                return entries;
              },
              symlink(parent, newname, oldpath) {
                var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
                node.link = oldpath;
                return node;
              },
              readlink(node) {
                if (!FS.isLink(node.mode)) {
                  throw new FS.ErrnoError(28);
                }
                return node.link;
              }
            },
            stream_ops: {
              read(stream, buffer, offset, length, position) {
                var contents = stream.node.contents;
                if (position >= stream.node.usedBytes)
                  return 0;
                var size = Math.min(stream.node.usedBytes - position, length);
                if (size > 8 && contents.subarray) {
                  buffer.set(contents.subarray(position, position + size), offset);
                } else {
                  for (var i2 = 0; i2 < size; i2++)
                    buffer[offset + i2] = contents[position + i2];
                }
                return size;
              },
              write(stream, buffer, offset, length, position, canOwn) {
                if (buffer.buffer === HEAP8.buffer) {
                  canOwn = false;
                }
                if (!length)
                  return 0;
                var node = stream.node;
                node.timestamp = Date.now();
                if (buffer.subarray && (!node.contents || node.contents.subarray)) {
                  if (canOwn) {
                    node.contents = buffer.subarray(offset, offset + length);
                    node.usedBytes = length;
                    return length;
                  } else if (node.usedBytes === 0 && position === 0) {
                    node.contents = buffer.slice(offset, offset + length);
                    node.usedBytes = length;
                    return length;
                  } else if (position + length <= node.usedBytes) {
                    node.contents.set(buffer.subarray(offset, offset + length), position);
                    return length;
                  }
                }
                MEMFS.expandFileStorage(node, position + length);
                if (node.contents.subarray && buffer.subarray) {
                  node.contents.set(buffer.subarray(offset, offset + length), position);
                } else {
                  for (var i2 = 0; i2 < length; i2++) {
                    node.contents[position + i2] = buffer[offset + i2];
                  }
                }
                node.usedBytes = Math.max(node.usedBytes, position + length);
                return length;
              },
              llseek(stream, offset, whence) {
                var position = offset;
                if (whence === 1) {
                  position += stream.position;
                } else if (whence === 2) {
                  if (FS.isFile(stream.node.mode)) {
                    position += stream.node.usedBytes;
                  }
                }
                if (position < 0) {
                  throw new FS.ErrnoError(28);
                }
                return position;
              },
              allocate(stream, offset, length) {
                MEMFS.expandFileStorage(stream.node, offset + length);
                stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
              },
              mmap(stream, length, position, prot, flags2) {
                if (!FS.isFile(stream.node.mode)) {
                  throw new FS.ErrnoError(43);
                }
                var ptr2;
                var allocated;
                var contents = stream.node.contents;
                if (!(flags2 & 2) && contents.buffer === HEAP8.buffer) {
                  allocated = false;
                  ptr2 = contents.byteOffset;
                } else {
                  if (position > 0 || position + length < contents.length) {
                    if (contents.subarray) {
                      contents = contents.subarray(position, position + length);
                    } else {
                      contents = Array.prototype.slice.call(contents, position, position + length);
                    }
                  }
                  allocated = true;
                  ptr2 = mmapAlloc(length);
                  if (!ptr2) {
                    throw new FS.ErrnoError(48);
                  }
                  HEAP8.set(contents, ptr2 >>> 0);
                }
                return {
                  ptr: ptr2,
                  allocated
                };
              },
              msync(stream, buffer, offset, length, mmapFlags) {
                MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);
                return 0;
              }
            }
          };
          var FS_createDataFile = (parent, name2, fileData, canRead, canWrite, canOwn) => {
            FS.createDataFile(parent, name2, fileData, canRead, canWrite, canOwn);
          };
          var FS_handledByPreloadPlugin = (byteArray, fullname, finish, onerror2) => {
            if (typeof Browser != "undefined")
              Browser.init();
            var handled = false;
            preloadPlugins.forEach((plugin) => {
              if (handled)
                return;
              if (plugin["canHandle"](fullname)) {
                plugin["handle"](byteArray, fullname, finish, onerror2);
                handled = true;
              }
            });
            return handled;
          };
          var FS_createPreloadedFile = (parent, name2, url2, canRead, canWrite, onload2, onerror2, dontCreateFile, canOwn, preFinish) => {
            var fullname = name2 ? PATH_FS.resolve(PATH.join2(parent, name2)) : parent;
            var dep = getUniqueRunDependency(`cp ${fullname}`);
            function processData(byteArray) {
              function finish(byteArray2) {
                preFinish?.();
                if (!dontCreateFile) {
                  FS_createDataFile(parent, name2, byteArray2, canRead, canWrite, canOwn);
                }
                onload2?.();
                removeRunDependency(dep);
              }
              if (FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {
                onerror2?.();
                removeRunDependency(dep);
              })) {
                return;
              }
              finish(byteArray);
            }
            addRunDependency(dep);
            if (typeof url2 == "string") {
              asyncLoad(url2, processData, onerror2);
            } else {
              processData(url2);
            }
          };
          var FS_modeStringToFlags = (str) => {
            var flagModes = {
              "r": 0,
              "r+": 2,
              "w": 512 | 64 | 1,
              "w+": 512 | 64 | 2,
              "a": 1024 | 64 | 1,
              "a+": 1024 | 64 | 2
            };
            var flags2 = flagModes[str];
            if (typeof flags2 == "undefined") {
              throw new Error(`Unknown file open mode: ${str}`);
            }
            return flags2;
          };
          var FS_getMode = (canRead, canWrite) => {
            var mode = 0;
            if (canRead)
              mode |= 292 | 73;
            if (canWrite)
              mode |= 146;
            return mode;
          };
          var FS = {
            root: null,
            mounts: [],
            devices: {},
            streams: [],
            nextInode: 1,
            nameTable: null,
            currentPath: "/",
            initialized: false,
            ignorePermissions: true,
            ErrnoError: null,
            genericErrors: {},
            filesystems: null,
            syncFSRequests: 0,
            lookupPath(path, opts = {}) {
              path = PATH_FS.resolve(path);
              if (!path)
                return {
                  path: "",
                  node: null
                };
              var defaults = {
                follow_mount: true,
                recurse_count: 0
              };
              opts = Object.assign(defaults, opts);
              if (opts.recurse_count > 8) {
                throw new FS.ErrnoError(32);
              }
              var parts2 = path.split("/").filter((p) => !!p);
              var current = FS.root;
              var current_path = "/";
              for (var i2 = 0; i2 < parts2.length; i2++) {
                var islast = i2 === parts2.length - 1;
                if (islast && opts.parent) {
                  break;
                }
                current = FS.lookupNode(current, parts2[i2]);
                current_path = PATH.join2(current_path, parts2[i2]);
                if (FS.isMountpoint(current)) {
                  if (!islast || islast && opts.follow_mount) {
                    current = current.mounted.root;
                  }
                }
                if (!islast || opts.follow) {
                  var count = 0;
                  while (FS.isLink(current.mode)) {
                    var link = FS.readlink(current_path);
                    current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
                    var lookup = FS.lookupPath(current_path, {
                      recurse_count: opts.recurse_count + 1
                    });
                    current = lookup.node;
                    if (count++ > 40) {
                      throw new FS.ErrnoError(32);
                    }
                  }
                }
              }
              return {
                path: current_path,
                node: current
              };
            },
            getPath(node) {
              var path;
              while (true) {
                if (FS.isRoot(node)) {
                  var mount = node.mount.mountpoint;
                  if (!path)
                    return mount;
                  return mount[mount.length - 1] !== "/" ? `${mount}/${path}` : mount + path;
                }
                path = path ? `${node.name}/${path}` : node.name;
                node = node.parent;
              }
            },
            hashName(parentid, name2) {
              var hash = 0;
              for (var i2 = 0; i2 < name2.length; i2++) {
                hash = (hash << 5) - hash + name2.charCodeAt(i2) | 0;
              }
              return (parentid + hash >>> 0) % FS.nameTable.length;
            },
            hashAddNode(node) {
              var hash = FS.hashName(node.parent.id, node.name);
              node.name_next = FS.nameTable[hash];
              FS.nameTable[hash] = node;
            },
            hashRemoveNode(node) {
              var hash = FS.hashName(node.parent.id, node.name);
              if (FS.nameTable[hash] === node) {
                FS.nameTable[hash] = node.name_next;
              } else {
                var current = FS.nameTable[hash];
                while (current) {
                  if (current.name_next === node) {
                    current.name_next = node.name_next;
                    break;
                  }
                  current = current.name_next;
                }
              }
            },
            lookupNode(parent, name2) {
              var errCode = FS.mayLookup(parent);
              if (errCode) {
                throw new FS.ErrnoError(errCode, parent);
              }
              var hash = FS.hashName(parent.id, name2);
              for (var node = FS.nameTable[hash]; node; node = node.name_next) {
                var nodeName = node.name;
                if (node.parent.id === parent.id && nodeName === name2) {
                  return node;
                }
              }
              return FS.lookup(parent, name2);
            },
            createNode(parent, name2, mode, rdev) {
              var node = new FS.FSNode(parent, name2, mode, rdev);
              FS.hashAddNode(node);
              return node;
            },
            destroyNode(node) {
              FS.hashRemoveNode(node);
            },
            isRoot(node) {
              return node === node.parent;
            },
            isMountpoint(node) {
              return !!node.mounted;
            },
            isFile(mode) {
              return (mode & 61440) === 32768;
            },
            isDir(mode) {
              return (mode & 61440) === 16384;
            },
            isLink(mode) {
              return (mode & 61440) === 40960;
            },
            isChrdev(mode) {
              return (mode & 61440) === 8192;
            },
            isBlkdev(mode) {
              return (mode & 61440) === 24576;
            },
            isFIFO(mode) {
              return (mode & 61440) === 4096;
            },
            isSocket(mode) {
              return (mode & 49152) === 49152;
            },
            flagsToPermissionString(flag) {
              var perms = ["r", "w", "rw"][flag & 3];
              if (flag & 512) {
                perms += "w";
              }
              return perms;
            },
            nodePermissions(node, perms) {
              if (FS.ignorePermissions) {
                return 0;
              }
              if (perms.includes("r") && !(node.mode & 292)) {
                return 2;
              } else if (perms.includes("w") && !(node.mode & 146)) {
                return 2;
              } else if (perms.includes("x") && !(node.mode & 73)) {
                return 2;
              }
              return 0;
            },
            mayLookup(dir) {
              var errCode = FS.nodePermissions(dir, "x");
              if (errCode)
                return errCode;
              if (!dir.node_ops.lookup)
                return 2;
              return 0;
            },
            mayCreate(dir, name2) {
              try {
                var node = FS.lookupNode(dir, name2);
                return 20;
              } catch (e) {
              }
              return FS.nodePermissions(dir, "wx");
            },
            mayDelete(dir, name2, isdir) {
              var node;
              try {
                node = FS.lookupNode(dir, name2);
              } catch (e) {
                return e.errno;
              }
              var errCode = FS.nodePermissions(dir, "wx");
              if (errCode) {
                return errCode;
              }
              if (isdir) {
                if (!FS.isDir(node.mode)) {
                  return 54;
                }
                if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
                  return 10;
                }
              } else {
                if (FS.isDir(node.mode)) {
                  return 31;
                }
              }
              return 0;
            },
            mayOpen(node, flags2) {
              if (!node) {
                return 44;
              }
              if (FS.isLink(node.mode)) {
                return 32;
              } else if (FS.isDir(node.mode)) {
                if (FS.flagsToPermissionString(flags2) !== "r" || flags2 & 512) {
                  return 31;
                }
              }
              return FS.nodePermissions(node, FS.flagsToPermissionString(flags2));
            },
            MAX_OPEN_FDS: 4096,
            nextfd() {
              for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {
                if (!FS.streams[fd]) {
                  return fd;
                }
              }
              throw new FS.ErrnoError(33);
            },
            getStreamChecked(fd) {
              var stream = FS.getStream(fd);
              if (!stream) {
                throw new FS.ErrnoError(8);
              }
              return stream;
            },
            getStream: (fd) => FS.streams[fd],
            createStream(stream, fd = -1) {
              if (!FS.FSStream) {
                FS.FSStream = function() {
                  this.shared = {};
                };
                FS.FSStream.prototype = {};
                Object.defineProperties(FS.FSStream.prototype, {
                  object: {
                    get() {
                      return this.node;
                    },
                    set(val) {
                      this.node = val;
                    }
                  },
                  isRead: {
                    get() {
                      return (this.flags & 2097155) !== 1;
                    }
                  },
                  isWrite: {
                    get() {
                      return (this.flags & 2097155) !== 0;
                    }
                  },
                  isAppend: {
                    get() {
                      return this.flags & 1024;
                    }
                  },
                  flags: {
                    get() {
                      return this.shared.flags;
                    },
                    set(val) {
                      this.shared.flags = val;
                    }
                  },
                  position: {
                    get() {
                      return this.shared.position;
                    },
                    set(val) {
                      this.shared.position = val;
                    }
                  }
                });
              }
              stream = Object.assign(new FS.FSStream(), stream);
              if (fd == -1) {
                fd = FS.nextfd();
              }
              stream.fd = fd;
              FS.streams[fd] = stream;
              return stream;
            },
            closeStream(fd) {
              FS.streams[fd] = null;
            },
            chrdev_stream_ops: {
              open(stream) {
                var device = FS.getDevice(stream.node.rdev);
                stream.stream_ops = device.stream_ops;
                stream.stream_ops.open?.(stream);
              },
              llseek() {
                throw new FS.ErrnoError(70);
              }
            },
            major: (dev) => dev >> 8,
            minor: (dev) => dev & 255,
            makedev: (ma, mi) => ma << 8 | mi,
            registerDevice(dev, ops) {
              FS.devices[dev] = {
                stream_ops: ops
              };
            },
            getDevice: (dev) => FS.devices[dev],
            getMounts(mount) {
              var mounts = [];
              var check = [mount];
              while (check.length) {
                var m = check.pop();
                mounts.push(m);
                check.push.apply(check, m.mounts);
              }
              return mounts;
            },
            syncfs(populate, callback) {
              if (typeof populate == "function") {
                callback = populate;
                populate = false;
              }
              FS.syncFSRequests++;
              if (FS.syncFSRequests > 1) {
                err(`warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`);
              }
              var mounts = FS.getMounts(FS.root.mount);
              var completed = 0;
              function doCallback(errCode) {
                FS.syncFSRequests--;
                return callback(errCode);
              }
              function done(errCode) {
                if (errCode) {
                  if (!done.errored) {
                    done.errored = true;
                    return doCallback(errCode);
                  }
                  return;
                }
                if (++completed >= mounts.length) {
                  doCallback(null);
                }
              }
              mounts.forEach((mount) => {
                if (!mount.type.syncfs) {
                  return done(null);
                }
                mount.type.syncfs(mount, populate, done);
              });
            },
            mount(type, opts, mountpoint) {
              var root = mountpoint === "/";
              var pseudo = !mountpoint;
              var node;
              if (root && FS.root) {
                throw new FS.ErrnoError(10);
              } else if (!root && !pseudo) {
                var lookup = FS.lookupPath(mountpoint, {
                  follow_mount: false
                });
                mountpoint = lookup.path;
                node = lookup.node;
                if (FS.isMountpoint(node)) {
                  throw new FS.ErrnoError(10);
                }
                if (!FS.isDir(node.mode)) {
                  throw new FS.ErrnoError(54);
                }
              }
              var mount = {
                type,
                opts,
                mountpoint,
                mounts: []
              };
              var mountRoot = type.mount(mount);
              mountRoot.mount = mount;
              mount.root = mountRoot;
              if (root) {
                FS.root = mountRoot;
              } else if (node) {
                node.mounted = mount;
                if (node.mount) {
                  node.mount.mounts.push(mount);
                }
              }
              return mountRoot;
            },
            unmount(mountpoint) {
              var lookup = FS.lookupPath(mountpoint, {
                follow_mount: false
              });
              if (!FS.isMountpoint(lookup.node)) {
                throw new FS.ErrnoError(28);
              }
              var node = lookup.node;
              var mount = node.mounted;
              var mounts = FS.getMounts(mount);
              Object.keys(FS.nameTable).forEach((hash) => {
                var current = FS.nameTable[hash];
                while (current) {
                  var next = current.name_next;
                  if (mounts.includes(current.mount)) {
                    FS.destroyNode(current);
                  }
                  current = next;
                }
              });
              node.mounted = null;
              var idx = node.mount.mounts.indexOf(mount);
              node.mount.mounts.splice(idx, 1);
            },
            lookup(parent, name2) {
              return parent.node_ops.lookup(parent, name2);
            },
            mknod(path, mode, dev) {
              var lookup = FS.lookupPath(path, {
                parent: true
              });
              var parent = lookup.node;
              var name2 = PATH.basename(path);
              if (!name2 || name2 === "." || name2 === "..") {
                throw new FS.ErrnoError(28);
              }
              var errCode = FS.mayCreate(parent, name2);
              if (errCode) {
                throw new FS.ErrnoError(errCode);
              }
              if (!parent.node_ops.mknod) {
                throw new FS.ErrnoError(63);
              }
              return parent.node_ops.mknod(parent, name2, mode, dev);
            },
            create(path, mode) {
              mode = mode !== void 0 ? mode : 438;
              mode &= 4095;
              mode |= 32768;
              return FS.mknod(path, mode, 0);
            },
            mkdir(path, mode) {
              mode = mode !== void 0 ? mode : 511;
              mode &= 511 | 512;
              mode |= 16384;
              return FS.mknod(path, mode, 0);
            },
            mkdirTree(path, mode) {
              var dirs = path.split("/");
              var d = "";
              for (var i2 = 0; i2 < dirs.length; ++i2) {
                if (!dirs[i2])
                  continue;
                d += "/" + dirs[i2];
                try {
                  FS.mkdir(d, mode);
                } catch (e) {
                  if (e.errno != 20)
                    throw e;
                }
              }
            },
            mkdev(path, mode, dev) {
              if (typeof dev == "undefined") {
                dev = mode;
                mode = 438;
              }
              mode |= 8192;
              return FS.mknod(path, mode, dev);
            },
            symlink(oldpath, newpath) {
              if (!PATH_FS.resolve(oldpath)) {
                throw new FS.ErrnoError(44);
              }
              var lookup = FS.lookupPath(newpath, {
                parent: true
              });
              var parent = lookup.node;
              if (!parent) {
                throw new FS.ErrnoError(44);
              }
              var newname = PATH.basename(newpath);
              var errCode = FS.mayCreate(parent, newname);
              if (errCode) {
                throw new FS.ErrnoError(errCode);
              }
              if (!parent.node_ops.symlink) {
                throw new FS.ErrnoError(63);
              }
              return parent.node_ops.symlink(parent, newname, oldpath);
            },
            rename(old_path, new_path) {
              var old_dirname = PATH.dirname(old_path);
              var new_dirname = PATH.dirname(new_path);
              var old_name = PATH.basename(old_path);
              var new_name = PATH.basename(new_path);
              var lookup, old_dir, new_dir;
              lookup = FS.lookupPath(old_path, {
                parent: true
              });
              old_dir = lookup.node;
              lookup = FS.lookupPath(new_path, {
                parent: true
              });
              new_dir = lookup.node;
              if (!old_dir || !new_dir)
                throw new FS.ErrnoError(44);
              if (old_dir.mount !== new_dir.mount) {
                throw new FS.ErrnoError(75);
              }
              var old_node = FS.lookupNode(old_dir, old_name);
              var relative = PATH_FS.relative(old_path, new_dirname);
              if (relative.charAt(0) !== ".") {
                throw new FS.ErrnoError(28);
              }
              relative = PATH_FS.relative(new_path, old_dirname);
              if (relative.charAt(0) !== ".") {
                throw new FS.ErrnoError(55);
              }
              var new_node;
              try {
                new_node = FS.lookupNode(new_dir, new_name);
              } catch (e) {
              }
              if (old_node === new_node) {
                return;
              }
              var isdir = FS.isDir(old_node.mode);
              var errCode = FS.mayDelete(old_dir, old_name, isdir);
              if (errCode) {
                throw new FS.ErrnoError(errCode);
              }
              errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
              if (errCode) {
                throw new FS.ErrnoError(errCode);
              }
              if (!old_dir.node_ops.rename) {
                throw new FS.ErrnoError(63);
              }
              if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
                throw new FS.ErrnoError(10);
              }
              if (new_dir !== old_dir) {
                errCode = FS.nodePermissions(old_dir, "w");
                if (errCode) {
                  throw new FS.ErrnoError(errCode);
                }
              }
              FS.hashRemoveNode(old_node);
              try {
                old_dir.node_ops.rename(old_node, new_dir, new_name);
              } catch (e) {
                throw e;
              } finally {
                FS.hashAddNode(old_node);
              }
            },
            rmdir(path) {
              var lookup = FS.lookupPath(path, {
                parent: true
              });
              var parent = lookup.node;
              var name2 = PATH.basename(path);
              var node = FS.lookupNode(parent, name2);
              var errCode = FS.mayDelete(parent, name2, true);
              if (errCode) {
                throw new FS.ErrnoError(errCode);
              }
              if (!parent.node_ops.rmdir) {
                throw new FS.ErrnoError(63);
              }
              if (FS.isMountpoint(node)) {
                throw new FS.ErrnoError(10);
              }
              parent.node_ops.rmdir(parent, name2);
              FS.destroyNode(node);
            },
            readdir(path) {
              var lookup = FS.lookupPath(path, {
                follow: true
              });
              var node = lookup.node;
              if (!node.node_ops.readdir) {
                throw new FS.ErrnoError(54);
              }
              return node.node_ops.readdir(node);
            },
            unlink(path) {
              var lookup = FS.lookupPath(path, {
                parent: true
              });
              var parent = lookup.node;
              if (!parent) {
                throw new FS.ErrnoError(44);
              }
              var name2 = PATH.basename(path);
              var node = FS.lookupNode(parent, name2);
              var errCode = FS.mayDelete(parent, name2, false);
              if (errCode) {
                throw new FS.ErrnoError(errCode);
              }
              if (!parent.node_ops.unlink) {
                throw new FS.ErrnoError(63);
              }
              if (FS.isMountpoint(node)) {
                throw new FS.ErrnoError(10);
              }
              parent.node_ops.unlink(parent, name2);
              FS.destroyNode(node);
            },
            readlink(path) {
              var lookup = FS.lookupPath(path);
              var link = lookup.node;
              if (!link) {
                throw new FS.ErrnoError(44);
              }
              if (!link.node_ops.readlink) {
                throw new FS.ErrnoError(28);
              }
              return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
            },
            stat(path, dontFollow) {
              var lookup = FS.lookupPath(path, {
                follow: !dontFollow
              });
              var node = lookup.node;
              if (!node) {
                throw new FS.ErrnoError(44);
              }
              if (!node.node_ops.getattr) {
                throw new FS.ErrnoError(63);
              }
              return node.node_ops.getattr(node);
            },
            lstat(path) {
              return FS.stat(path, true);
            },
            chmod(path, mode, dontFollow) {
              var node;
              if (typeof path == "string") {
                var lookup = FS.lookupPath(path, {
                  follow: !dontFollow
                });
                node = lookup.node;
              } else {
                node = path;
              }
              if (!node.node_ops.setattr) {
                throw new FS.ErrnoError(63);
              }
              node.node_ops.setattr(node, {
                mode: mode & 4095 | node.mode & ~4095,
                timestamp: Date.now()
              });
            },
            lchmod(path, mode) {
              FS.chmod(path, mode, true);
            },
            fchmod(fd, mode) {
              var stream = FS.getStreamChecked(fd);
              FS.chmod(stream.node, mode);
            },
            chown(path, uid, gid, dontFollow) {
              var node;
              if (typeof path == "string") {
                var lookup = FS.lookupPath(path, {
                  follow: !dontFollow
                });
                node = lookup.node;
              } else {
                node = path;
              }
              if (!node.node_ops.setattr) {
                throw new FS.ErrnoError(63);
              }
              node.node_ops.setattr(node, {
                timestamp: Date.now()
              });
            },
            lchown(path, uid, gid) {
              FS.chown(path, uid, gid, true);
            },
            fchown(fd, uid, gid) {
              var stream = FS.getStreamChecked(fd);
              FS.chown(stream.node, uid, gid);
            },
            truncate(path, len2) {
              if (len2 < 0) {
                throw new FS.ErrnoError(28);
              }
              var node;
              if (typeof path == "string") {
                var lookup = FS.lookupPath(path, {
                  follow: true
                });
                node = lookup.node;
              } else {
                node = path;
              }
              if (!node.node_ops.setattr) {
                throw new FS.ErrnoError(63);
              }
              if (FS.isDir(node.mode)) {
                throw new FS.ErrnoError(31);
              }
              if (!FS.isFile(node.mode)) {
                throw new FS.ErrnoError(28);
              }
              var errCode = FS.nodePermissions(node, "w");
              if (errCode) {
                throw new FS.ErrnoError(errCode);
              }
              node.node_ops.setattr(node, {
                size: len2,
                timestamp: Date.now()
              });
            },
            ftruncate(fd, len2) {
              var stream = FS.getStreamChecked(fd);
              if ((stream.flags & 2097155) === 0) {
                throw new FS.ErrnoError(28);
              }
              FS.truncate(stream.node, len2);
            },
            utime(path, atime, mtime) {
              var lookup = FS.lookupPath(path, {
                follow: true
              });
              var node = lookup.node;
              node.node_ops.setattr(node, {
                timestamp: Math.max(atime, mtime)
              });
            },
            open(path, flags2, mode) {
              if (path === "") {
                throw new FS.ErrnoError(44);
              }
              flags2 = typeof flags2 == "string" ? FS_modeStringToFlags(flags2) : flags2;
              mode = typeof mode == "undefined" ? 438 : mode;
              if (flags2 & 64) {
                mode = mode & 4095 | 32768;
              } else {
                mode = 0;
              }
              var node;
              if (typeof path == "object") {
                node = path;
              } else {
                path = PATH.normalize(path);
                try {
                  var lookup = FS.lookupPath(path, {
                    follow: !(flags2 & 131072)
                  });
                  node = lookup.node;
                } catch (e) {
                }
              }
              var created = false;
              if (flags2 & 64) {
                if (node) {
                  if (flags2 & 128) {
                    throw new FS.ErrnoError(20);
                  }
                } else {
                  node = FS.mknod(path, mode, 0);
                  created = true;
                }
              }
              if (!node) {
                throw new FS.ErrnoError(44);
              }
              if (FS.isChrdev(node.mode)) {
                flags2 &= ~512;
              }
              if (flags2 & 65536 && !FS.isDir(node.mode)) {
                throw new FS.ErrnoError(54);
              }
              if (!created) {
                var errCode = FS.mayOpen(node, flags2);
                if (errCode) {
                  throw new FS.ErrnoError(errCode);
                }
              }
              if (flags2 & 512 && !created) {
                FS.truncate(node, 0);
              }
              flags2 &= ~(128 | 512 | 131072);
              var stream = FS.createStream({
                node,
                path: FS.getPath(node),
                flags: flags2,
                seekable: true,
                position: 0,
                stream_ops: node.stream_ops,
                ungotten: [],
                error: false
              });
              if (stream.stream_ops.open) {
                stream.stream_ops.open(stream);
              }
              if (Module["logReadFiles"] && !(flags2 & 1)) {
                if (!FS.readFiles)
                  FS.readFiles = {};
                if (!(path in FS.readFiles)) {
                  FS.readFiles[path] = 1;
                }
              }
              return stream;
            },
            close(stream) {
              if (FS.isClosed(stream)) {
                throw new FS.ErrnoError(8);
              }
              if (stream.getdents)
                stream.getdents = null;
              try {
                if (stream.stream_ops.close) {
                  stream.stream_ops.close(stream);
                }
              } catch (e) {
                throw e;
              } finally {
                FS.closeStream(stream.fd);
              }
              stream.fd = null;
            },
            isClosed(stream) {
              return stream.fd === null;
            },
            llseek(stream, offset, whence) {
              if (FS.isClosed(stream)) {
                throw new FS.ErrnoError(8);
              }
              if (!stream.seekable || !stream.stream_ops.llseek) {
                throw new FS.ErrnoError(70);
              }
              if (whence != 0 && whence != 1 && whence != 2) {
                throw new FS.ErrnoError(28);
              }
              stream.position = stream.stream_ops.llseek(stream, offset, whence);
              stream.ungotten = [];
              return stream.position;
            },
            read(stream, buffer, offset, length, position) {
              if (length < 0 || position < 0) {
                throw new FS.ErrnoError(28);
              }
              if (FS.isClosed(stream)) {
                throw new FS.ErrnoError(8);
              }
              if ((stream.flags & 2097155) === 1) {
                throw new FS.ErrnoError(8);
              }
              if (FS.isDir(stream.node.mode)) {
                throw new FS.ErrnoError(31);
              }
              if (!stream.stream_ops.read) {
                throw new FS.ErrnoError(28);
              }
              var seeking = typeof position != "undefined";
              if (!seeking) {
                position = stream.position;
              } else if (!stream.seekable) {
                throw new FS.ErrnoError(70);
              }
              var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
              if (!seeking)
                stream.position += bytesRead;
              return bytesRead;
            },
            write(stream, buffer, offset, length, position, canOwn) {
              if (length < 0 || position < 0) {
                throw new FS.ErrnoError(28);
              }
              if (FS.isClosed(stream)) {
                throw new FS.ErrnoError(8);
              }
              if ((stream.flags & 2097155) === 0) {
                throw new FS.ErrnoError(8);
              }
              if (FS.isDir(stream.node.mode)) {
                throw new FS.ErrnoError(31);
              }
              if (!stream.stream_ops.write) {
                throw new FS.ErrnoError(28);
              }
              if (stream.seekable && stream.flags & 1024) {
                FS.llseek(stream, 0, 2);
              }
              var seeking = typeof position != "undefined";
              if (!seeking) {
                position = stream.position;
              } else if (!stream.seekable) {
                throw new FS.ErrnoError(70);
              }
              var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
              if (!seeking)
                stream.position += bytesWritten;
              return bytesWritten;
            },
            allocate(stream, offset, length) {
              if (FS.isClosed(stream)) {
                throw new FS.ErrnoError(8);
              }
              if (offset < 0 || length <= 0) {
                throw new FS.ErrnoError(28);
              }
              if ((stream.flags & 2097155) === 0) {
                throw new FS.ErrnoError(8);
              }
              if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
                throw new FS.ErrnoError(43);
              }
              if (!stream.stream_ops.allocate) {
                throw new FS.ErrnoError(138);
              }
              stream.stream_ops.allocate(stream, offset, length);
            },
            mmap(stream, length, position, prot, flags2) {
              if ((prot & 2) !== 0 && (flags2 & 2) === 0 && (stream.flags & 2097155) !== 2) {
                throw new FS.ErrnoError(2);
              }
              if ((stream.flags & 2097155) === 1) {
                throw new FS.ErrnoError(2);
              }
              if (!stream.stream_ops.mmap) {
                throw new FS.ErrnoError(43);
              }
              return stream.stream_ops.mmap(stream, length, position, prot, flags2);
            },
            msync(stream, buffer, offset, length, mmapFlags) {
              if (!stream.stream_ops.msync) {
                return 0;
              }
              return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);
            },
            munmap: (stream) => 0,
            ioctl(stream, cmd, arg) {
              if (!stream.stream_ops.ioctl) {
                throw new FS.ErrnoError(59);
              }
              return stream.stream_ops.ioctl(stream, cmd, arg);
            },
            readFile(path, opts = {}) {
              opts.flags = opts.flags || 0;
              opts.encoding = opts.encoding || "binary";
              if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
                throw new Error(`Invalid encoding type "${opts.encoding}"`);
              }
              var ret;
              var stream = FS.open(path, opts.flags);
              var stat = FS.stat(path);
              var length = stat.size;
              var buf = new Uint8Array(length);
              FS.read(stream, buf, 0, length, 0);
              if (opts.encoding === "utf8") {
                ret = UTF8ArrayToString(buf, 0);
              } else if (opts.encoding === "binary") {
                ret = buf;
              }
              FS.close(stream);
              return ret;
            },
            writeFile(path, data2, opts = {}) {
              opts.flags = opts.flags || 577;
              var stream = FS.open(path, opts.flags, opts.mode);
              if (typeof data2 == "string") {
                var buf = new Uint8Array(lengthBytesUTF8(data2) + 1);
                var actualNumBytes = stringToUTF8Array(data2, buf, 0, buf.length);
                FS.write(stream, buf, 0, actualNumBytes, void 0, opts.canOwn);
              } else if (ArrayBuffer.isView(data2)) {
                FS.write(stream, data2, 0, data2.byteLength, void 0, opts.canOwn);
              } else {
                throw new Error("Unsupported data type");
              }
              FS.close(stream);
            },
            cwd: () => FS.currentPath,
            chdir(path) {
              var lookup = FS.lookupPath(path, {
                follow: true
              });
              if (lookup.node === null) {
                throw new FS.ErrnoError(44);
              }
              if (!FS.isDir(lookup.node.mode)) {
                throw new FS.ErrnoError(54);
              }
              var errCode = FS.nodePermissions(lookup.node, "x");
              if (errCode) {
                throw new FS.ErrnoError(errCode);
              }
              FS.currentPath = lookup.path;
            },
            createDefaultDirectories() {
              FS.mkdir("/tmp");
              FS.mkdir("/home");
              FS.mkdir("/home/web_user");
            },
            createDefaultDevices() {
              FS.mkdir("/dev");
              FS.registerDevice(FS.makedev(1, 3), {
                read: () => 0,
                write: (stream, buffer, offset, length, pos) => length
              });
              FS.mkdev("/dev/null", FS.makedev(1, 3));
              TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
              TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
              FS.mkdev("/dev/tty", FS.makedev(5, 0));
              FS.mkdev("/dev/tty1", FS.makedev(6, 0));
              var randomBuffer = new Uint8Array(1024), randomLeft = 0;
              var randomByte = () => {
                if (randomLeft === 0) {
                  randomLeft = randomFill(randomBuffer).byteLength;
                }
                return randomBuffer[--randomLeft];
              };
              FS.createDevice("/dev", "random", randomByte);
              FS.createDevice("/dev", "urandom", randomByte);
              FS.mkdir("/dev/shm");
              FS.mkdir("/dev/shm/tmp");
            },
            createSpecialDirectories() {
              FS.mkdir("/proc");
              var proc_self = FS.mkdir("/proc/self");
              FS.mkdir("/proc/self/fd");
              FS.mount({
                mount() {
                  var node = FS.createNode(proc_self, "fd", 16384 | 511, 73);
                  node.node_ops = {
                    lookup(parent, name2) {
                      var fd = +name2;
                      var stream = FS.getStreamChecked(fd);
                      var ret = {
                        parent: null,
                        mount: {
                          mountpoint: "fake"
                        },
                        node_ops: {
                          readlink: () => stream.path
                        }
                      };
                      ret.parent = ret;
                      return ret;
                    }
                  };
                  return node;
                }
              }, {}, "/proc/self/fd");
            },
            createStandardStreams() {
              if (Module["stdin"]) {
                FS.createDevice("/dev", "stdin", Module["stdin"]);
              } else {
                FS.symlink("/dev/tty", "/dev/stdin");
              }
              if (Module["stdout"]) {
                FS.createDevice("/dev", "stdout", null, Module["stdout"]);
              } else {
                FS.symlink("/dev/tty", "/dev/stdout");
              }
              if (Module["stderr"]) {
                FS.createDevice("/dev", "stderr", null, Module["stderr"]);
              } else {
                FS.symlink("/dev/tty1", "/dev/stderr");
              }
              var stdin = FS.open("/dev/stdin", 0);
              var stdout = FS.open("/dev/stdout", 1);
              var stderr = FS.open("/dev/stderr", 1);
            },
            ensureErrnoError() {
              if (FS.ErrnoError)
                return;
              FS.ErrnoError = function ErrnoError(errno, node) {
                this.name = "ErrnoError";
                this.node = node;
                this.setErrno = function(errno2) {
                  this.errno = errno2;
                };
                this.setErrno(errno);
                this.message = "FS error";
              };
              FS.ErrnoError.prototype = new Error();
              FS.ErrnoError.prototype.constructor = FS.ErrnoError;
              [44].forEach((code) => {
                FS.genericErrors[code] = new FS.ErrnoError(code);
                FS.genericErrors[code].stack = "<generic error, no stack>";
              });
            },
            staticInit() {
              FS.ensureErrnoError();
              FS.nameTable = new Array(4096);
              FS.mount(MEMFS, {}, "/");
              FS.createDefaultDirectories();
              FS.createDefaultDevices();
              FS.createSpecialDirectories();
              FS.filesystems = {
                "MEMFS": MEMFS
              };
            },
            init(input, output, error) {
              FS.init.initialized = true;
              FS.ensureErrnoError();
              Module["stdin"] = input || Module["stdin"];
              Module["stdout"] = output || Module["stdout"];
              Module["stderr"] = error || Module["stderr"];
              FS.createStandardStreams();
            },
            quit() {
              FS.init.initialized = false;
              _fflush(0);
              for (var i2 = 0; i2 < FS.streams.length; i2++) {
                var stream = FS.streams[i2];
                if (!stream) {
                  continue;
                }
                FS.close(stream);
              }
            },
            findObject(path, dontResolveLastLink) {
              var ret = FS.analyzePath(path, dontResolveLastLink);
              if (!ret.exists) {
                return null;
              }
              return ret.object;
            },
            analyzePath(path, dontResolveLastLink) {
              try {
                var lookup = FS.lookupPath(path, {
                  follow: !dontResolveLastLink
                });
                path = lookup.path;
              } catch (e) {
              }
              var ret = {
                isRoot: false,
                exists: false,
                error: 0,
                name: null,
                path: null,
                object: null,
                parentExists: false,
                parentPath: null,
                parentObject: null
              };
              try {
                var lookup = FS.lookupPath(path, {
                  parent: true
                });
                ret.parentExists = true;
                ret.parentPath = lookup.path;
                ret.parentObject = lookup.node;
                ret.name = PATH.basename(path);
                lookup = FS.lookupPath(path, {
                  follow: !dontResolveLastLink
                });
                ret.exists = true;
                ret.path = lookup.path;
                ret.object = lookup.node;
                ret.name = lookup.node.name;
                ret.isRoot = lookup.path === "/";
              } catch (e) {
                ret.error = e.errno;
              }
              return ret;
            },
            createPath(parent, path, canRead, canWrite) {
              parent = typeof parent == "string" ? parent : FS.getPath(parent);
              var parts2 = path.split("/").reverse();
              while (parts2.length) {
                var part = parts2.pop();
                if (!part)
                  continue;
                var current = PATH.join2(parent, part);
                try {
                  FS.mkdir(current);
                } catch (e) {
                }
                parent = current;
              }
              return current;
            },
            createFile(parent, name2, properties, canRead, canWrite) {
              var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name2);
              var mode = FS_getMode(canRead, canWrite);
              return FS.create(path, mode);
            },
            createDataFile(parent, name2, data2, canRead, canWrite, canOwn) {
              var path = name2;
              if (parent) {
                parent = typeof parent == "string" ? parent : FS.getPath(parent);
                path = name2 ? PATH.join2(parent, name2) : parent;
              }
              var mode = FS_getMode(canRead, canWrite);
              var node = FS.create(path, mode);
              if (data2) {
                if (typeof data2 == "string") {
                  var arr = new Array(data2.length);
                  for (var i2 = 0, len2 = data2.length; i2 < len2; ++i2)
                    arr[i2] = data2.charCodeAt(i2);
                  data2 = arr;
                }
                FS.chmod(node, mode | 146);
                var stream = FS.open(node, 577);
                FS.write(stream, data2, 0, data2.length, 0, canOwn);
                FS.close(stream);
                FS.chmod(node, mode);
              }
            },
            createDevice(parent, name2, input, output) {
              var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name2);
              var mode = FS_getMode(!!input, !!output);
              if (!FS.createDevice.major)
                FS.createDevice.major = 64;
              var dev = FS.makedev(FS.createDevice.major++, 0);
              FS.registerDevice(dev, {
                open(stream) {
                  stream.seekable = false;
                },
                close(stream) {
                  if (output?.buffer?.length) {
                    output(10);
                  }
                },
                read(stream, buffer, offset, length, pos) {
                  var bytesRead = 0;
                  for (var i2 = 0; i2 < length; i2++) {
                    var result;
                    try {
                      result = input();
                    } catch (e) {
                      throw new FS.ErrnoError(29);
                    }
                    if (result === void 0 && bytesRead === 0) {
                      throw new FS.ErrnoError(6);
                    }
                    if (result === null || result === void 0)
                      break;
                    bytesRead++;
                    buffer[offset + i2] = result;
                  }
                  if (bytesRead) {
                    stream.node.timestamp = Date.now();
                  }
                  return bytesRead;
                },
                write(stream, buffer, offset, length, pos) {
                  for (var i2 = 0; i2 < length; i2++) {
                    try {
                      output(buffer[offset + i2]);
                    } catch (e) {
                      throw new FS.ErrnoError(29);
                    }
                  }
                  if (length) {
                    stream.node.timestamp = Date.now();
                  }
                  return i2;
                }
              });
              return FS.mkdev(path, mode, dev);
            },
            forceLoadFile(obj) {
              if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
                return true;
              if (typeof XMLHttpRequest != "undefined") {
                throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
              } else if (read_) {
                try {
                  obj.contents = intArrayFromString(read_(obj.url), true);
                  obj.usedBytes = obj.contents.length;
                } catch (e) {
                  throw new FS.ErrnoError(29);
                }
              } else {
                throw new Error("Cannot load without read() or XMLHttpRequest.");
              }
            },
            createLazyFile(parent, name2, url2, canRead, canWrite) {
              function LazyUint8Array() {
                this.lengthKnown = false;
                this.chunks = [];
              }
              LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {
                if (idx > this.length - 1 || idx < 0) {
                  return void 0;
                }
                var chunkOffset = idx % this.chunkSize;
                var chunkNum = idx / this.chunkSize | 0;
                return this.getter(chunkNum)[chunkOffset];
              };
              LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
                this.getter = getter;
              };
              LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
                var xhr = new XMLHttpRequest();
                xhr.open("HEAD", url2, false);
                xhr.send(null);
                if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))
                  throw new Error("Couldn't load " + url2 + ". Status: " + xhr.status);
                var datalength = Number(xhr.getResponseHeader("Content-length"));
                var header;
                var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
                var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
                var chunkSize = 1024 * 1024;
                if (!hasByteServing)
                  chunkSize = datalength;
                var doXHR = (from, to) => {
                  if (from > to)
                    throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
                  if (to > datalength - 1)
                    throw new Error("only " + datalength + " bytes available! programmer error!");
                  var xhr2 = new XMLHttpRequest();
                  xhr2.open("GET", url2, false);
                  if (datalength !== chunkSize)
                    xhr2.setRequestHeader("Range", "bytes=" + from + "-" + to);
                  xhr2.responseType = "arraybuffer";
                  if (xhr2.overrideMimeType) {
                    xhr2.overrideMimeType("text/plain; charset=x-user-defined");
                  }
                  xhr2.send(null);
                  if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))
                    throw new Error("Couldn't load " + url2 + ". Status: " + xhr2.status);
                  if (xhr2.response !== void 0) {
                    return new Uint8Array(xhr2.response || []);
                  }
                  return intArrayFromString(xhr2.responseText || "", true);
                };
                var lazyArray2 = this;
                lazyArray2.setDataGetter((chunkNum) => {
                  var start2 = chunkNum * chunkSize;
                  var end = (chunkNum + 1) * chunkSize - 1;
                  end = Math.min(end, datalength - 1);
                  if (typeof lazyArray2.chunks[chunkNum] == "undefined") {
                    lazyArray2.chunks[chunkNum] = doXHR(start2, end);
                  }
                  if (typeof lazyArray2.chunks[chunkNum] == "undefined")
                    throw new Error("doXHR failed!");
                  return lazyArray2.chunks[chunkNum];
                });
                if (usesGzip || !datalength) {
                  chunkSize = datalength = 1;
                  datalength = this.getter(0).length;
                  chunkSize = datalength;
                  out("LazyFiles on gzip forces download of the whole file when length is accessed");
                }
                this._length = datalength;
                this._chunkSize = chunkSize;
                this.lengthKnown = true;
              };
              if (typeof XMLHttpRequest != "undefined") {
                if (!ENVIRONMENT_IS_WORKER)
                  throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
                var lazyArray = new LazyUint8Array();
                Object.defineProperties(lazyArray, {
                  length: {
                    get: function() {
                      if (!this.lengthKnown) {
                        this.cacheLength();
                      }
                      return this._length;
                    }
                  },
                  chunkSize: {
                    get: function() {
                      if (!this.lengthKnown) {
                        this.cacheLength();
                      }
                      return this._chunkSize;
                    }
                  }
                });
                var properties = {
                  isDevice: false,
                  contents: lazyArray
                };
              } else {
                var properties = {
                  isDevice: false,
                  url: url2
                };
              }
              var node = FS.createFile(parent, name2, properties, canRead, canWrite);
              if (properties.contents) {
                node.contents = properties.contents;
              } else if (properties.url) {
                node.contents = null;
                node.url = properties.url;
              }
              Object.defineProperties(node, {
                usedBytes: {
                  get: function() {
                    return this.contents.length;
                  }
                }
              });
              var stream_ops = {};
              var keys = Object.keys(node.stream_ops);
              keys.forEach((key) => {
                var fn = node.stream_ops[key];
                stream_ops[key] = function forceLoadLazyFile() {
                  FS.forceLoadFile(node);
                  return fn.apply(null, arguments);
                };
              });
              function writeChunks(stream, buffer, offset, length, position) {
                var contents = stream.node.contents;
                if (position >= contents.length)
                  return 0;
                var size = Math.min(contents.length - position, length);
                if (contents.slice) {
                  for (var i2 = 0; i2 < size; i2++) {
                    buffer[offset + i2] = contents[position + i2];
                  }
                } else {
                  for (var i2 = 0; i2 < size; i2++) {
                    buffer[offset + i2] = contents.get(position + i2);
                  }
                }
                return size;
              }
              stream_ops.read = (stream, buffer, offset, length, position) => {
                FS.forceLoadFile(node);
                return writeChunks(stream, buffer, offset, length, position);
              };
              stream_ops.mmap = (stream, length, position, prot, flags2) => {
                FS.forceLoadFile(node);
                var ptr2 = mmapAlloc(length);
                if (!ptr2) {
                  throw new FS.ErrnoError(48);
                }
                writeChunks(stream, HEAP8, ptr2, length, position);
                return {
                  ptr: ptr2,
                  allocated: true
                };
              };
              node.stream_ops = stream_ops;
              return node;
            }
          };
          var SYSCALLS = {
            DEFAULT_POLLMASK: 5,
            calculateAt(dirfd, path, allowEmpty) {
              if (PATH.isAbs(path)) {
                return path;
              }
              var dir;
              if (dirfd === -100) {
                dir = FS.cwd();
              } else {
                var dirstream = SYSCALLS.getStreamFromFD(dirfd);
                dir = dirstream.path;
              }
              if (path.length == 0) {
                if (!allowEmpty) {
                  throw new FS.ErrnoError(44);
                }
                return dir;
              }
              return PATH.join2(dir, path);
            },
            doStat(func2, path, buf) {
              try {
                var stat = func2(path);
              } catch (e) {
                if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {
                  return -54;
                }
                throw e;
              }
              HEAP32[buf >>> 2 >>> 0] = stat.dev;
              HEAP32[buf + 4 >>> 2 >>> 0] = stat.mode;
              HEAPU32[buf + 8 >>> 2 >>> 0] = stat.nlink;
              HEAP32[buf + 12 >>> 2 >>> 0] = stat.uid;
              HEAP32[buf + 16 >>> 2 >>> 0] = stat.gid;
              HEAP32[buf + 20 >>> 2 >>> 0] = stat.rdev;
              tempI64 = [stat.size >>> 0, (tempDouble = stat.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 24 >>> 2 >>> 0] = tempI64[0], HEAP32[buf + 28 >>> 2 >>> 0] = tempI64[1];
              HEAP32[buf + 32 >>> 2 >>> 0] = 4096;
              HEAP32[buf + 36 >>> 2 >>> 0] = stat.blocks;
              var atime = stat.atime.getTime();
              var mtime = stat.mtime.getTime();
              var ctime = stat.ctime.getTime();
              tempI64 = [Math.floor(atime / 1e3) >>> 0, (tempDouble = Math.floor(atime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 40 >>> 2 >>> 0] = tempI64[0], HEAP32[buf + 44 >>> 2 >>> 0] = tempI64[1];
              HEAPU32[buf + 48 >>> 2 >>> 0] = atime % 1e3 * 1e3;
              tempI64 = [Math.floor(mtime / 1e3) >>> 0, (tempDouble = Math.floor(mtime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 56 >>> 2 >>> 0] = tempI64[0], HEAP32[buf + 60 >>> 2 >>> 0] = tempI64[1];
              HEAPU32[buf + 64 >>> 2 >>> 0] = mtime % 1e3 * 1e3;
              tempI64 = [Math.floor(ctime / 1e3) >>> 0, (tempDouble = Math.floor(ctime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 72 >>> 2 >>> 0] = tempI64[0], HEAP32[buf + 76 >>> 2 >>> 0] = tempI64[1];
              HEAPU32[buf + 80 >>> 2 >>> 0] = ctime % 1e3 * 1e3;
              tempI64 = [stat.ino >>> 0, (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 88 >>> 2 >>> 0] = tempI64[0], HEAP32[buf + 92 >>> 2 >>> 0] = tempI64[1];
              return 0;
            },
            doMsync(addr2, stream, len2, flags2, offset) {
              if (!FS.isFile(stream.node.mode)) {
                throw new FS.ErrnoError(43);
              }
              if (flags2 & 2) {
                return 0;
              }
              var buffer = HEAPU8.slice(addr2, addr2 + len2);
              FS.msync(stream, buffer, offset, len2, flags2);
            },
            varargs: void 0,
            get() {
              var ret = HEAP32[+SYSCALLS.varargs >>> 2 >>> 0];
              SYSCALLS.varargs += 4;
              return ret;
            },
            getp() {
              return SYSCALLS.get();
            },
            getStr(ptr2) {
              var ret = UTF8ToString(ptr2);
              return ret;
            },
            getStreamFromFD(fd) {
              var stream = FS.getStreamChecked(fd);
              return stream;
            }
          };
          function ___syscall__newselect(nfds, readfds, writefds, exceptfds, timeout) {
            readfds >>>= 0;
            writefds >>>= 0;
            exceptfds >>>= 0;
            timeout >>>= 0;
            try {
              var total = 0;
              var srcReadLow = readfds ? HEAP32[readfds >>> 2 >>> 0] : 0, srcReadHigh = readfds ? HEAP32[readfds + 4 >>> 2 >>> 0] : 0;
              var srcWriteLow = writefds ? HEAP32[writefds >>> 2 >>> 0] : 0, srcWriteHigh = writefds ? HEAP32[writefds + 4 >>> 2 >>> 0] : 0;
              var srcExceptLow = exceptfds ? HEAP32[exceptfds >>> 2 >>> 0] : 0, srcExceptHigh = exceptfds ? HEAP32[exceptfds + 4 >>> 2 >>> 0] : 0;
              var dstReadLow = 0, dstReadHigh = 0;
              var dstWriteLow = 0, dstWriteHigh = 0;
              var dstExceptLow = 0, dstExceptHigh = 0;
              var allLow = (readfds ? HEAP32[readfds >>> 2 >>> 0] : 0) | (writefds ? HEAP32[writefds >>> 2 >>> 0] : 0) | (exceptfds ? HEAP32[exceptfds >>> 2 >>> 0] : 0);
              var allHigh = (readfds ? HEAP32[readfds + 4 >>> 2 >>> 0] : 0) | (writefds ? HEAP32[writefds + 4 >>> 2 >>> 0] : 0) | (exceptfds ? HEAP32[exceptfds + 4 >>> 2 >>> 0] : 0);
              var check = function(fd2, low, high, val) {
                return fd2 < 32 ? low & val : high & val;
              };
              for (var fd = 0; fd < nfds; fd++) {
                var mask = 1 << fd % 32;
                if (!check(fd, allLow, allHigh, mask)) {
                  continue;
                }
                var stream = SYSCALLS.getStreamFromFD(fd);
                var flags2 = SYSCALLS.DEFAULT_POLLMASK;
                if (stream.stream_ops.poll) {
                  var timeoutInMillis = -1;
                  if (timeout) {
                    var tv_sec = readfds ? HEAP32[timeout >>> 2 >>> 0] : 0, tv_usec = readfds ? HEAP32[timeout + 4 >>> 2 >>> 0] : 0;
                    timeoutInMillis = (tv_sec + tv_usec / 1e6) * 1e3;
                  }
                  flags2 = stream.stream_ops.poll(stream, timeoutInMillis);
                }
                if (flags2 & 1 && check(fd, srcReadLow, srcReadHigh, mask)) {
                  fd < 32 ? dstReadLow = dstReadLow | mask : dstReadHigh = dstReadHigh | mask;
                  total++;
                }
                if (flags2 & 4 && check(fd, srcWriteLow, srcWriteHigh, mask)) {
                  fd < 32 ? dstWriteLow = dstWriteLow | mask : dstWriteHigh = dstWriteHigh | mask;
                  total++;
                }
                if (flags2 & 2 && check(fd, srcExceptLow, srcExceptHigh, mask)) {
                  fd < 32 ? dstExceptLow = dstExceptLow | mask : dstExceptHigh = dstExceptHigh | mask;
                  total++;
                }
              }
              if (readfds) {
                HEAP32[readfds >>> 2 >>> 0] = dstReadLow;
                HEAP32[readfds + 4 >>> 2 >>> 0] = dstReadHigh;
              }
              if (writefds) {
                HEAP32[writefds >>> 2 >>> 0] = dstWriteLow;
                HEAP32[writefds + 4 >>> 2 >>> 0] = dstWriteHigh;
              }
              if (exceptfds) {
                HEAP32[exceptfds >>> 2 >>> 0] = dstExceptLow;
                HEAP32[exceptfds + 4 >>> 2 >>> 0] = dstExceptHigh;
              }
              return total;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall__newselect.sig = "iipppp";
          var SOCKFS = {
            mount(mount) {
              Module["websocket"] = Module["websocket"] && "object" === typeof Module["websocket"] ? Module["websocket"] : {};
              Module["websocket"]._callbacks = {};
              Module["websocket"]["on"] = function(event2, callback) {
                if ("function" === typeof callback) {
                  this._callbacks[event2] = callback;
                }
                return this;
              };
              Module["websocket"].emit = function(event2, param) {
                if ("function" === typeof this._callbacks[event2]) {
                  this._callbacks[event2].call(this, param);
                }
              };
              return FS.createNode(null, "/", 16384 | 511, 0);
            },
            createSocket(family, type, protocol) {
              type &= ~526336;
              var streaming = type == 1;
              if (streaming && protocol && protocol != 6) {
                throw new FS.ErrnoError(66);
              }
              var sock = {
                family,
                type,
                protocol,
                server: null,
                error: null,
                peers: {},
                pending: [],
                recv_queue: [],
                sock_ops: SOCKFS.websocket_sock_ops
              };
              var name2 = SOCKFS.nextname();
              var node = FS.createNode(SOCKFS.root, name2, 49152, 0);
              node.sock = sock;
              var stream = FS.createStream({
                path: name2,
                node,
                flags: 2,
                seekable: false,
                stream_ops: SOCKFS.stream_ops
              });
              sock.stream = stream;
              return sock;
            },
            getSocket(fd) {
              var stream = FS.getStream(fd);
              if (!stream || !FS.isSocket(stream.node.mode)) {
                return null;
              }
              return stream.node.sock;
            },
            stream_ops: {
              poll(stream) {
                var sock = stream.node.sock;
                return sock.sock_ops.poll(sock);
              },
              ioctl(stream, request, varargs) {
                var sock = stream.node.sock;
                return sock.sock_ops.ioctl(sock, request, varargs);
              },
              read(stream, buffer, offset, length, position) {
                var sock = stream.node.sock;
                var msg = sock.sock_ops.recvmsg(sock, length);
                if (!msg) {
                  return 0;
                }
                buffer.set(msg.buffer, offset);
                return msg.buffer.length;
              },
              write(stream, buffer, offset, length, position) {
                var sock = stream.node.sock;
                return sock.sock_ops.sendmsg(sock, buffer, offset, length);
              },
              close(stream) {
                var sock = stream.node.sock;
                sock.sock_ops.close(sock);
              }
            },
            nextname() {
              if (!SOCKFS.nextname.current) {
                SOCKFS.nextname.current = 0;
              }
              return "socket[" + SOCKFS.nextname.current++ + "]";
            },
            websocket_sock_ops: {
              createPeer(sock, addr2, port) {
                var ws;
                if (typeof addr2 == "object") {
                  ws = addr2;
                  addr2 = null;
                  port = null;
                }
                if (ws) {
                  if (ws._socket) {
                    addr2 = ws._socket.remoteAddress;
                    port = ws._socket.remotePort;
                  } else {
                    var result = /ws[s]?:\/\/([^:]+):(\d+)/.exec(ws.url);
                    if (!result) {
                      throw new Error("WebSocket URL must be in the format ws(s)://address:port");
                    }
                    addr2 = result[1];
                    port = parseInt(result[2], 10);
                  }
                } else {
                  try {
                    var runtimeConfig = Module["websocket"] && "object" === typeof Module["websocket"];
                    var url2 = "ws:#".replace("#", "//");
                    if (runtimeConfig) {
                      if ("string" === typeof Module["websocket"]["url"]) {
                        url2 = Module["websocket"]["url"];
                      }
                    }
                    if (url2 === "ws://" || url2 === "wss://") {
                      var parts2 = addr2.split("/");
                      url2 = url2 + parts2[0] + ":" + port + "/" + parts2.slice(1).join("/");
                    }
                    var subProtocols = "binary";
                    if (runtimeConfig) {
                      if ("string" === typeof Module["websocket"]["subprotocol"]) {
                        subProtocols = Module["websocket"]["subprotocol"];
                      }
                    }
                    var opts = void 0;
                    if (subProtocols !== "null") {
                      subProtocols = subProtocols.replace(/^ +| +$/g, "").split(/ *, */);
                      opts = subProtocols;
                    }
                    if (runtimeConfig && null === Module["websocket"]["subprotocol"]) {
                      subProtocols = "null";
                      opts = void 0;
                    }
                    var WebSocketConstructor;
                    if (ENVIRONMENT_IS_NODE) {
                      WebSocketConstructor = require_browser();
                    } else {
                      WebSocketConstructor = WebSocket;
                    }
                    ws = new WebSocketConstructor(url2, opts);
                    ws.binaryType = "arraybuffer";
                  } catch (e) {
                    throw new FS.ErrnoError(23);
                  }
                }
                var peer = {
                  addr: addr2,
                  port,
                  socket: ws,
                  dgram_send_queue: []
                };
                SOCKFS.websocket_sock_ops.addPeer(sock, peer);
                SOCKFS.websocket_sock_ops.handlePeerEvents(sock, peer);
                if (sock.type === 2 && typeof sock.sport != "undefined") {
                  peer.dgram_send_queue.push(new Uint8Array([255, 255, 255, 255, "p".charCodeAt(0), "o".charCodeAt(0), "r".charCodeAt(0), "t".charCodeAt(0), (sock.sport & 65280) >> 8, sock.sport & 255]));
                }
                return peer;
              },
              getPeer(sock, addr2, port) {
                return sock.peers[addr2 + ":" + port];
              },
              addPeer(sock, peer) {
                sock.peers[peer.addr + ":" + peer.port] = peer;
              },
              removePeer(sock, peer) {
                delete sock.peers[peer.addr + ":" + peer.port];
              },
              handlePeerEvents(sock, peer) {
                var first = true;
                var handleOpen = function() {
                  Module["websocket"].emit("open", sock.stream.fd);
                  try {
                    var queued = peer.dgram_send_queue.shift();
                    while (queued) {
                      peer.socket.send(queued);
                      queued = peer.dgram_send_queue.shift();
                    }
                  } catch (e) {
                    peer.socket.close();
                  }
                };
                function handleMessage(data2) {
                  if (typeof data2 == "string") {
                    var encoder4 = new TextEncoder();
                    data2 = encoder4.encode(data2);
                  } else {
                    assert(data2.byteLength !== void 0);
                    if (data2.byteLength == 0) {
                      return;
                    }
                    data2 = new Uint8Array(data2);
                  }
                  var wasfirst = first;
                  first = false;
                  if (wasfirst && data2.length === 10 && data2[0] === 255 && data2[1] === 255 && data2[2] === 255 && data2[3] === 255 && data2[4] === "p".charCodeAt(0) && data2[5] === "o".charCodeAt(0) && data2[6] === "r".charCodeAt(0) && data2[7] === "t".charCodeAt(0)) {
                    var newport = data2[8] << 8 | data2[9];
                    SOCKFS.websocket_sock_ops.removePeer(sock, peer);
                    peer.port = newport;
                    SOCKFS.websocket_sock_ops.addPeer(sock, peer);
                    return;
                  }
                  sock.recv_queue.push({
                    addr: peer.addr,
                    port: peer.port,
                    data: data2
                  });
                  Module["websocket"].emit("message", sock.stream.fd);
                }
                if (ENVIRONMENT_IS_NODE) {
                  peer.socket.on("open", handleOpen);
                  peer.socket.on("message", function(data2, isBinary) {
                    if (!isBinary) {
                      return;
                    }
                    handleMessage(new Uint8Array(data2).buffer);
                  });
                  peer.socket.on("close", function() {
                    Module["websocket"].emit("close", sock.stream.fd);
                  });
                  peer.socket.on("error", function(error) {
                    sock.error = 14;
                    Module["websocket"].emit("error", [sock.stream.fd, sock.error, "ECONNREFUSED: Connection refused"]);
                  });
                } else {
                  peer.socket.onopen = handleOpen;
                  peer.socket.onclose = function() {
                    Module["websocket"].emit("close", sock.stream.fd);
                  };
                  peer.socket.onmessage = function peer_socket_onmessage(event2) {
                    handleMessage(event2.data);
                  };
                  peer.socket.onerror = function(error) {
                    sock.error = 14;
                    Module["websocket"].emit("error", [sock.stream.fd, sock.error, "ECONNREFUSED: Connection refused"]);
                  };
                }
              },
              poll(sock) {
                if (sock.type === 1 && sock.server) {
                  return sock.pending.length ? 64 | 1 : 0;
                }
                var mask = 0;
                var dest = sock.type === 1 ? SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport) : null;
                if (sock.recv_queue.length || !dest || dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
                  mask |= 64 | 1;
                }
                if (!dest || dest && dest.socket.readyState === dest.socket.OPEN) {
                  mask |= 4;
                }
                if (dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
                  mask |= 16;
                }
                return mask;
              },
              ioctl(sock, request, arg) {
                switch (request) {
                  case 21531:
                    var bytes = 0;
                    if (sock.recv_queue.length) {
                      bytes = sock.recv_queue[0].data.length;
                    }
                    HEAP32[arg >>> 2 >>> 0] = bytes;
                    return 0;
                  default:
                    return 28;
                }
              },
              close(sock) {
                if (sock.server) {
                  try {
                    sock.server.close();
                  } catch (e) {
                  }
                  sock.server = null;
                }
                var peers = Object.keys(sock.peers);
                for (var i2 = 0; i2 < peers.length; i2++) {
                  var peer = sock.peers[peers[i2]];
                  try {
                    peer.socket.close();
                  } catch (e) {
                  }
                  SOCKFS.websocket_sock_ops.removePeer(sock, peer);
                }
                return 0;
              },
              bind(sock, addr2, port) {
                if (typeof sock.saddr != "undefined" || typeof sock.sport != "undefined") {
                  throw new FS.ErrnoError(28);
                }
                sock.saddr = addr2;
                sock.sport = port;
                if (sock.type === 2) {
                  if (sock.server) {
                    sock.server.close();
                    sock.server = null;
                  }
                  try {
                    sock.sock_ops.listen(sock, 0);
                  } catch (e) {
                    if (!(e.name === "ErrnoError"))
                      throw e;
                    if (e.errno !== 138)
                      throw e;
                  }
                }
              },
              connect(sock, addr2, port) {
                if (sock.server) {
                  throw new FS.ErrnoError(138);
                }
                if (typeof sock.daddr != "undefined" && typeof sock.dport != "undefined") {
                  var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
                  if (dest) {
                    if (dest.socket.readyState === dest.socket.CONNECTING) {
                      throw new FS.ErrnoError(7);
                    } else {
                      throw new FS.ErrnoError(30);
                    }
                  }
                }
                var peer = SOCKFS.websocket_sock_ops.createPeer(sock, addr2, port);
                sock.daddr = peer.addr;
                sock.dport = peer.port;
                throw new FS.ErrnoError(26);
              },
              listen(sock, backlog) {
                if (!ENVIRONMENT_IS_NODE) {
                  throw new FS.ErrnoError(138);
                }
                if (sock.server) {
                  throw new FS.ErrnoError(28);
                }
                var WebSocketServer = require_browser().Server;
                var host = sock.saddr;
                sock.server = new WebSocketServer({
                  host,
                  port: sock.sport
                });
                Module["websocket"].emit("listen", sock.stream.fd);
                sock.server.on("connection", function(ws) {
                  if (sock.type === 1) {
                    var newsock = SOCKFS.createSocket(sock.family, sock.type, sock.protocol);
                    var peer = SOCKFS.websocket_sock_ops.createPeer(newsock, ws);
                    newsock.daddr = peer.addr;
                    newsock.dport = peer.port;
                    sock.pending.push(newsock);
                    Module["websocket"].emit("connection", newsock.stream.fd);
                  } else {
                    SOCKFS.websocket_sock_ops.createPeer(sock, ws);
                    Module["websocket"].emit("connection", sock.stream.fd);
                  }
                });
                sock.server.on("close", function() {
                  Module["websocket"].emit("close", sock.stream.fd);
                  sock.server = null;
                });
                sock.server.on("error", function(error) {
                  sock.error = 23;
                  Module["websocket"].emit("error", [sock.stream.fd, sock.error, "EHOSTUNREACH: Host is unreachable"]);
                });
              },
              accept(listensock) {
                if (!listensock.server || !listensock.pending.length) {
                  throw new FS.ErrnoError(28);
                }
                var newsock = listensock.pending.shift();
                newsock.stream.flags = listensock.stream.flags;
                return newsock;
              },
              getname(sock, peer) {
                var addr2, port;
                if (peer) {
                  if (sock.daddr === void 0 || sock.dport === void 0) {
                    throw new FS.ErrnoError(53);
                  }
                  addr2 = sock.daddr;
                  port = sock.dport;
                } else {
                  addr2 = sock.saddr || 0;
                  port = sock.sport || 0;
                }
                return {
                  addr: addr2,
                  port
                };
              },
              sendmsg(sock, buffer, offset, length, addr2, port) {
                if (sock.type === 2) {
                  if (addr2 === void 0 || port === void 0) {
                    addr2 = sock.daddr;
                    port = sock.dport;
                  }
                  if (addr2 === void 0 || port === void 0) {
                    throw new FS.ErrnoError(17);
                  }
                } else {
                  addr2 = sock.daddr;
                  port = sock.dport;
                }
                var dest = SOCKFS.websocket_sock_ops.getPeer(sock, addr2, port);
                if (sock.type === 1) {
                  if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
                    throw new FS.ErrnoError(53);
                  } else if (dest.socket.readyState === dest.socket.CONNECTING) {
                    throw new FS.ErrnoError(6);
                  }
                }
                if (ArrayBuffer.isView(buffer)) {
                  offset += buffer.byteOffset;
                  buffer = buffer.buffer;
                }
                var data2;
                data2 = buffer.slice(offset, offset + length);
                if (sock.type === 2) {
                  if (!dest || dest.socket.readyState !== dest.socket.OPEN) {
                    if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
                      dest = SOCKFS.websocket_sock_ops.createPeer(sock, addr2, port);
                    }
                    dest.dgram_send_queue.push(data2);
                    return length;
                  }
                }
                try {
                  dest.socket.send(data2);
                  return length;
                } catch (e) {
                  throw new FS.ErrnoError(28);
                }
              },
              recvmsg(sock, length) {
                if (sock.type === 1 && sock.server) {
                  throw new FS.ErrnoError(53);
                }
                var queued = sock.recv_queue.shift();
                if (!queued) {
                  if (sock.type === 1) {
                    var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
                    if (!dest) {
                      throw new FS.ErrnoError(53);
                    }
                    if (dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
                      return null;
                    }
                    throw new FS.ErrnoError(6);
                  }
                  throw new FS.ErrnoError(6);
                }
                var queuedLength = queued.data.byteLength || queued.data.length;
                var queuedOffset = queued.data.byteOffset || 0;
                var queuedBuffer = queued.data.buffer || queued.data;
                var bytesRead = Math.min(length, queuedLength);
                var res = {
                  buffer: new Uint8Array(queuedBuffer, queuedOffset, bytesRead),
                  addr: queued.addr,
                  port: queued.port
                };
                if (sock.type === 1 && bytesRead < queuedLength) {
                  var bytesRemaining = queuedLength - bytesRead;
                  queued.data = new Uint8Array(queuedBuffer, queuedOffset + bytesRead, bytesRemaining);
                  sock.recv_queue.unshift(queued);
                }
                return res;
              }
            }
          };
          var getSocketFromFD = (fd) => {
            var socket = SOCKFS.getSocket(fd);
            if (!socket)
              throw new FS.ErrnoError(8);
            return socket;
          };
          var Sockets = {
            BUFFER_SIZE: 10240,
            MAX_BUFFER_SIZE: 10485760,
            nextFd: 1,
            fds: {},
            nextport: 1,
            maxport: 65535,
            peer: null,
            connections: {},
            portmap: {},
            localAddr: 4261412874,
            addrPool: [33554442, 50331658, 67108874, 83886090, 100663306, 117440522, 134217738, 150994954, 167772170, 184549386, 201326602, 218103818, 234881034]
          };
          var inetPton4 = (str) => {
            var b = str.split(".");
            for (var i2 = 0; i2 < 4; i2++) {
              var tmp2 = Number(b[i2]);
              if (isNaN(tmp2))
                return null;
              b[i2] = tmp2;
            }
            return (b[0] | b[1] << 8 | b[2] << 16 | b[3] << 24) >>> 0;
          };
          var jstoi_q = (str) => parseInt(str);
          var inetPton6 = (str) => {
            var words;
            var w, offset, z, i2;
            var valid6regx = /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i;
            var parts2 = [];
            if (!valid6regx.test(str)) {
              return null;
            }
            if (str === "::") {
              return [0, 0, 0, 0, 0, 0, 0, 0];
            }
            if (str.startsWith("::")) {
              str = str.replace("::", "Z:");
            } else {
              str = str.replace("::", ":Z:");
            }
            if (str.indexOf(".") > 0) {
              str = str.replace(new RegExp("[.]", "g"), ":");
              words = str.split(":");
              words[words.length - 4] = jstoi_q(words[words.length - 4]) + jstoi_q(words[words.length - 3]) * 256;
              words[words.length - 3] = jstoi_q(words[words.length - 2]) + jstoi_q(words[words.length - 1]) * 256;
              words = words.slice(0, words.length - 2);
            } else {
              words = str.split(":");
            }
            offset = 0;
            z = 0;
            for (w = 0; w < words.length; w++) {
              if (typeof words[w] == "string") {
                if (words[w] === "Z") {
                  for (z = 0; z < 8 - words.length + 1; z++) {
                    parts2[w + z] = 0;
                  }
                  offset = z - 1;
                } else {
                  parts2[w + offset] = _htons(parseInt(words[w], 16));
                }
              } else {
                parts2[w + offset] = words[w];
              }
            }
            return [parts2[1] << 16 | parts2[0], parts2[3] << 16 | parts2[2], parts2[5] << 16 | parts2[4], parts2[7] << 16 | parts2[6]];
          };
          var writeSockaddr = (sa, family, addr2, port, addrlen) => {
            switch (family) {
              case 2:
                addr2 = inetPton4(addr2);
                zeroMemory(sa, 16);
                if (addrlen) {
                  HEAP32[addrlen >>> 2 >>> 0] = 16;
                }
                HEAP16[sa >>> 1 >>> 0] = family;
                HEAP32[sa + 4 >>> 2 >>> 0] = addr2;
                HEAP16[sa + 2 >>> 1 >>> 0] = _htons(port);
                break;
              case 10:
                addr2 = inetPton6(addr2);
                zeroMemory(sa, 28);
                if (addrlen) {
                  HEAP32[addrlen >>> 2 >>> 0] = 28;
                }
                HEAP32[sa >>> 2 >>> 0] = family;
                HEAP32[sa + 8 >>> 2 >>> 0] = addr2[0];
                HEAP32[sa + 12 >>> 2 >>> 0] = addr2[1];
                HEAP32[sa + 16 >>> 2 >>> 0] = addr2[2];
                HEAP32[sa + 20 >>> 2 >>> 0] = addr2[3];
                HEAP16[sa + 2 >>> 1 >>> 0] = _htons(port);
                break;
              default:
                return 5;
            }
            return 0;
          };
          var DNS = {
            address_map: {
              id: 1,
              addrs: {},
              names: {}
            },
            lookup_name(name2) {
              var res = inetPton4(name2);
              if (res !== null) {
                return name2;
              }
              res = inetPton6(name2);
              if (res !== null) {
                return name2;
              }
              var addr2;
              if (DNS.address_map.addrs[name2]) {
                addr2 = DNS.address_map.addrs[name2];
              } else {
                var id = DNS.address_map.id++;
                assert(id < 65535, "exceeded max address mappings of 65535");
                addr2 = "172.29." + (id & 255) + "." + (id & 65280);
                DNS.address_map.names[addr2] = name2;
                DNS.address_map.addrs[name2] = addr2;
              }
              return addr2;
            },
            lookup_addr(addr2) {
              if (DNS.address_map.names[addr2]) {
                return DNS.address_map.names[addr2];
              }
              return null;
            }
          };
          function ___syscall_accept4(fd, addr2, addrlen, flags2, d1, d2) {
            addr2 >>>= 0;
            addrlen >>>= 0;
            try {
              var sock = getSocketFromFD(fd);
              var newsock = sock.sock_ops.accept(sock);
              if (addr2) {
                var errno = writeSockaddr(addr2, newsock.family, DNS.lookup_name(newsock.daddr), newsock.dport, addrlen);
              }
              return newsock.stream.fd;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_accept4.sig = "iippiii";
          var inetNtop4 = (addr2) => (addr2 & 255) + "." + (addr2 >> 8 & 255) + "." + (addr2 >> 16 & 255) + "." + (addr2 >> 24 & 255);
          var inetNtop6 = (ints) => {
            var str = "";
            var word = 0;
            var longest = 0;
            var lastzero = 0;
            var zstart = 0;
            var len2 = 0;
            var i2 = 0;
            var parts2 = [ints[0] & 65535, ints[0] >> 16, ints[1] & 65535, ints[1] >> 16, ints[2] & 65535, ints[2] >> 16, ints[3] & 65535, ints[3] >> 16];
            var hasipv4 = true;
            var v4part = "";
            for (i2 = 0; i2 < 5; i2++) {
              if (parts2[i2] !== 0) {
                hasipv4 = false;
                break;
              }
            }
            if (hasipv4) {
              v4part = inetNtop4(parts2[6] | parts2[7] << 16);
              if (parts2[5] === -1) {
                str = "::ffff:";
                str += v4part;
                return str;
              }
              if (parts2[5] === 0) {
                str = "::";
                if (v4part === "0.0.0.0")
                  v4part = "";
                if (v4part === "0.0.0.1")
                  v4part = "1";
                str += v4part;
                return str;
              }
            }
            for (word = 0; word < 8; word++) {
              if (parts2[word] === 0) {
                if (word - lastzero > 1) {
                  len2 = 0;
                }
                lastzero = word;
                len2++;
              }
              if (len2 > longest) {
                longest = len2;
                zstart = word - longest + 1;
              }
            }
            for (word = 0; word < 8; word++) {
              if (longest > 1) {
                if (parts2[word] === 0 && word >= zstart && word < zstart + longest) {
                  if (word === zstart) {
                    str += ":";
                    if (zstart === 0)
                      str += ":";
                  }
                  continue;
                }
              }
              str += Number(_ntohs(parts2[word] & 65535)).toString(16);
              str += word < 7 ? ":" : "";
            }
            return str;
          };
          var readSockaddr = (sa, salen) => {
            var family = HEAP16[sa >>> 1 >>> 0];
            var port = _ntohs(HEAPU16[sa + 2 >>> 1 >>> 0]);
            var addr2;
            switch (family) {
              case 2:
                if (salen !== 16) {
                  return {
                    errno: 28
                  };
                }
                addr2 = HEAP32[sa + 4 >>> 2 >>> 0];
                addr2 = inetNtop4(addr2);
                break;
              case 10:
                if (salen !== 28) {
                  return {
                    errno: 28
                  };
                }
                addr2 = [HEAP32[sa + 8 >>> 2 >>> 0], HEAP32[sa + 12 >>> 2 >>> 0], HEAP32[sa + 16 >>> 2 >>> 0], HEAP32[sa + 20 >>> 2 >>> 0]];
                addr2 = inetNtop6(addr2);
                break;
              default:
                return {
                  errno: 5
                };
            }
            return {
              family,
              addr: addr2,
              port
            };
          };
          var getSocketAddress = (addrp, addrlen, allowNull) => {
            if (allowNull && addrp === 0)
              return null;
            var info2 = readSockaddr(addrp, addrlen);
            if (info2.errno)
              throw new FS.ErrnoError(info2.errno);
            info2.addr = DNS.lookup_addr(info2.addr) || info2.addr;
            return info2;
          };
          function ___syscall_bind(fd, addr2, addrlen, d1, d2, d3) {
            addr2 >>>= 0;
            addrlen >>>= 0;
            try {
              var sock = getSocketFromFD(fd);
              var info2 = getSocketAddress(addr2, addrlen);
              sock.sock_ops.bind(sock, info2.addr, info2.port);
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_bind.sig = "iippiii";
          function ___syscall_chdir(path) {
            path >>>= 0;
            try {
              path = SYSCALLS.getStr(path);
              FS.chdir(path);
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_chdir.sig = "ip";
          function ___syscall_chmod(path, mode) {
            path >>>= 0;
            try {
              path = SYSCALLS.getStr(path);
              FS.chmod(path, mode);
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_chmod.sig = "ipi";
          function ___syscall_connect(fd, addr2, addrlen, d1, d2, d3) {
            addr2 >>>= 0;
            addrlen >>>= 0;
            try {
              var sock = getSocketFromFD(fd);
              var info2 = getSocketAddress(addr2, addrlen);
              sock.sock_ops.connect(sock, info2.addr, info2.port);
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_connect.sig = "iippiii";
          function ___syscall_dup(fd) {
            try {
              var old = SYSCALLS.getStreamFromFD(fd);
              return FS.createStream(old).fd;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_dup.sig = "ii";
          function ___syscall_dup3(fd, newfd, flags2) {
            try {
              var old = SYSCALLS.getStreamFromFD(fd);
              if (old.fd === newfd)
                return -28;
              var existing = FS.getStream(newfd);
              if (existing)
                FS.close(existing);
              return FS.createStream(old, newfd).fd;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_dup3.sig = "iiii";
          function ___syscall_faccessat(dirfd, path, amode, flags2) {
            path >>>= 0;
            try {
              path = SYSCALLS.getStr(path);
              path = SYSCALLS.calculateAt(dirfd, path);
              if (amode & ~7) {
                return -28;
              }
              var lookup = FS.lookupPath(path, {
                follow: true
              });
              var node = lookup.node;
              if (!node) {
                return -44;
              }
              var perms = "";
              if (amode & 4)
                perms += "r";
              if (amode & 2)
                perms += "w";
              if (amode & 1)
                perms += "x";
              if (perms && FS.nodePermissions(node, perms)) {
                return -2;
              }
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_faccessat.sig = "iipii";
          var ___syscall_fadvise64 = (fd, offset, len2, advice) => 0;
          ___syscall_fadvise64.sig = "iiiiiii";
          function ___syscall_fallocate(fd, mode, offset_low, offset_high, len_low, len_high) {
            var offset = convertI32PairToI53Checked(offset_low, offset_high);
            var len2 = convertI32PairToI53Checked(len_low, len_high);
            try {
              if (isNaN(offset))
                return 61;
              var stream = SYSCALLS.getStreamFromFD(fd);
              FS.allocate(stream, offset, len2);
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_fallocate.sig = "iiiiiii";
          function ___syscall_fchdir(fd) {
            try {
              var stream = SYSCALLS.getStreamFromFD(fd);
              FS.chdir(stream.path);
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_fchdir.sig = "ii";
          function ___syscall_fchmod(fd, mode) {
            try {
              FS.fchmod(fd, mode);
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_fchmod.sig = "iii";
          function ___syscall_fchmodat(dirfd, path, mode, varargs) {
            path >>>= 0;
            varargs >>>= 0;
            SYSCALLS.varargs = varargs;
            try {
              path = SYSCALLS.getStr(path);
              path = SYSCALLS.calculateAt(dirfd, path);
              FS.chmod(path, mode);
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_fchmodat.sig = "iipip";
          function ___syscall_fchown32(fd, owner, group) {
            try {
              FS.fchown(fd, owner, group);
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_fchown32.sig = "iiii";
          function ___syscall_fchownat(dirfd, path, owner, group, flags2) {
            path >>>= 0;
            try {
              path = SYSCALLS.getStr(path);
              var nofollow = flags2 & 256;
              flags2 = flags2 & ~256;
              path = SYSCALLS.calculateAt(dirfd, path);
              (nofollow ? FS.lchown : FS.chown)(path, owner, group);
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_fchownat.sig = "iipiii";
          function ___syscall_fcntl64(fd, cmd, varargs) {
            varargs >>>= 0;
            SYSCALLS.varargs = varargs;
            try {
              var stream = SYSCALLS.getStreamFromFD(fd);
              switch (cmd) {
                case 0: {
                  var arg = SYSCALLS.get();
                  if (arg < 0) {
                    return -28;
                  }
                  while (FS.streams[arg]) {
                    arg++;
                  }
                  var newStream;
                  newStream = FS.createStream(stream, arg);
                  return newStream.fd;
                }
                case 1:
                case 2:
                  return 0;
                case 3:
                  return stream.flags;
                case 4: {
                  var arg = SYSCALLS.get();
                  stream.flags |= arg;
                  return 0;
                }
                case 12: {
                  var arg = SYSCALLS.getp();
                  var offset = 0;
                  HEAP16[arg + offset >>> 1 >>> 0] = 2;
                  return 0;
                }
                case 13:
                case 14:
                  return 0;
              }
              return -28;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_fcntl64.sig = "iiip";
          function ___syscall_fdatasync(fd) {
            try {
              var stream = SYSCALLS.getStreamFromFD(fd);
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_fdatasync.sig = "ii";
          function ___syscall_fstat64(fd, buf) {
            buf >>>= 0;
            try {
              var stream = SYSCALLS.getStreamFromFD(fd);
              return SYSCALLS.doStat(FS.stat, stream.path, buf);
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_fstat64.sig = "iip";
          function ___syscall_statfs64(path, size, buf) {
            path >>>= 0;
            size >>>= 0;
            buf >>>= 0;
            try {
              path = SYSCALLS.getStr(path);
              HEAP32[buf + 4 >>> 2 >>> 0] = 4096;
              HEAP32[buf + 40 >>> 2 >>> 0] = 4096;
              HEAP32[buf + 8 >>> 2 >>> 0] = 1e6;
              HEAP32[buf + 12 >>> 2 >>> 0] = 5e5;
              HEAP32[buf + 16 >>> 2 >>> 0] = 5e5;
              HEAP32[buf + 20 >>> 2 >>> 0] = FS.nextInode;
              HEAP32[buf + 24 >>> 2 >>> 0] = 1e6;
              HEAP32[buf + 28 >>> 2 >>> 0] = 42;
              HEAP32[buf + 44 >>> 2 >>> 0] = 2;
              HEAP32[buf + 36 >>> 2 >>> 0] = 255;
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_statfs64.sig = "ippp";
          function ___syscall_fstatfs64(fd, size, buf) {
            size >>>= 0;
            buf >>>= 0;
            try {
              var stream = SYSCALLS.getStreamFromFD(fd);
              return ___syscall_statfs64(0, size, buf);
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_fstatfs64.sig = "iipp";
          function ___syscall_ftruncate64(fd, length_low, length_high) {
            var length = convertI32PairToI53Checked(length_low, length_high);
            try {
              if (isNaN(length))
                return 61;
              FS.ftruncate(fd, length);
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_ftruncate64.sig = "iiii";
          var stringToUTF8 = (str, outPtr, maxBytesToWrite) => stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
          function ___syscall_getcwd(buf, size) {
            buf >>>= 0;
            size >>>= 0;
            try {
              if (size === 0)
                return -28;
              var cwd = FS.cwd();
              var cwdLengthInBytes = lengthBytesUTF8(cwd) + 1;
              if (size < cwdLengthInBytes)
                return -68;
              stringToUTF8(cwd, buf, size);
              return cwdLengthInBytes;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_getcwd.sig = "ipp";
          function ___syscall_getdents64(fd, dirp, count) {
            dirp >>>= 0;
            count >>>= 0;
            try {
              var stream = SYSCALLS.getStreamFromFD(fd);
              stream.getdents || (stream.getdents = FS.readdir(stream.path));
              var struct_size = 280;
              var pos = 0;
              var off = FS.llseek(stream, 0, 1);
              var idx = Math.floor(off / struct_size);
              while (idx < stream.getdents.length && pos + struct_size <= count) {
                var id;
                var type;
                var name2 = stream.getdents[idx];
                if (name2 === ".") {
                  id = stream.node.id;
                  type = 4;
                } else if (name2 === "..") {
                  var lookup = FS.lookupPath(stream.path, {
                    parent: true
                  });
                  id = lookup.node.id;
                  type = 4;
                } else {
                  var child = FS.lookupNode(stream.node, name2);
                  id = child.id;
                  type = FS.isChrdev(child.mode) ? 2 : FS.isDir(child.mode) ? 4 : FS.isLink(child.mode) ? 10 : 8;
                }
                tempI64 = [id >>> 0, (tempDouble = id, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[dirp + pos >>> 2 >>> 0] = tempI64[0], HEAP32[dirp + pos + 4 >>> 2 >>> 0] = tempI64[1];
                tempI64 = [(idx + 1) * struct_size >>> 0, (tempDouble = (idx + 1) * struct_size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[dirp + pos + 8 >>> 2 >>> 0] = tempI64[0], HEAP32[dirp + pos + 12 >>> 2 >>> 0] = tempI64[1];
                HEAP16[dirp + pos + 16 >>> 1 >>> 0] = 280;
                HEAP8[dirp + pos + 18 >>> 0 >>> 0] = type;
                stringToUTF8(name2, dirp + pos + 19, 256);
                pos += struct_size;
                idx += 1;
              }
              FS.llseek(stream, idx * struct_size, 0);
              return pos;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_getdents64.sig = "iipp";
          function ___syscall_getpeername(fd, addr2, addrlen, d1, d2, d3) {
            addr2 >>>= 0;
            addrlen >>>= 0;
            try {
              var sock = getSocketFromFD(fd);
              if (!sock.daddr) {
                return -53;
              }
              var errno = writeSockaddr(addr2, sock.family, DNS.lookup_name(sock.daddr), sock.dport, addrlen);
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_getpeername.sig = "iippiii";
          function ___syscall_getsockname(fd, addr2, addrlen, d1, d2, d3) {
            addr2 >>>= 0;
            addrlen >>>= 0;
            try {
              var sock = getSocketFromFD(fd);
              var errno = writeSockaddr(addr2, sock.family, DNS.lookup_name(sock.saddr || "0.0.0.0"), sock.sport, addrlen);
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_getsockname.sig = "iippiii";
          function ___syscall_getsockopt(fd, level, optname, optval, optlen, d1) {
            optval >>>= 0;
            optlen >>>= 0;
            try {
              var sock = getSocketFromFD(fd);
              if (level === 1) {
                if (optname === 4) {
                  HEAP32[optval >>> 2 >>> 0] = sock.error;
                  HEAP32[optlen >>> 2 >>> 0] = 4;
                  sock.error = null;
                  return 0;
                }
              }
              return -50;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_getsockopt.sig = "iiiippi";
          function ___syscall_ioctl(fd, op, varargs) {
            varargs >>>= 0;
            SYSCALLS.varargs = varargs;
            try {
              var stream = SYSCALLS.getStreamFromFD(fd);
              switch (op) {
                case 21509: {
                  if (!stream.tty)
                    return -59;
                  return 0;
                }
                case 21505: {
                  if (!stream.tty)
                    return -59;
                  if (stream.tty.ops.ioctl_tcgets) {
                    var termios = stream.tty.ops.ioctl_tcgets(stream);
                    var argp = SYSCALLS.getp();
                    HEAP32[argp >>> 2 >>> 0] = termios.c_iflag || 0;
                    HEAP32[argp + 4 >>> 2 >>> 0] = termios.c_oflag || 0;
                    HEAP32[argp + 8 >>> 2 >>> 0] = termios.c_cflag || 0;
                    HEAP32[argp + 12 >>> 2 >>> 0] = termios.c_lflag || 0;
                    for (var i2 = 0; i2 < 32; i2++) {
                      HEAP8[argp + i2 + 17 >>> 0 >>> 0] = termios.c_cc[i2] || 0;
                    }
                    return 0;
                  }
                  return 0;
                }
                case 21510:
                case 21511:
                case 21512: {
                  if (!stream.tty)
                    return -59;
                  return 0;
                }
                case 21506:
                case 21507:
                case 21508: {
                  if (!stream.tty)
                    return -59;
                  if (stream.tty.ops.ioctl_tcsets) {
                    var argp = SYSCALLS.getp();
                    var c_iflag = HEAP32[argp >>> 2 >>> 0];
                    var c_oflag = HEAP32[argp + 4 >>> 2 >>> 0];
                    var c_cflag = HEAP32[argp + 8 >>> 2 >>> 0];
                    var c_lflag = HEAP32[argp + 12 >>> 2 >>> 0];
                    var c_cc = [];
                    for (var i2 = 0; i2 < 32; i2++) {
                      c_cc.push(HEAP8[argp + i2 + 17 >>> 0 >>> 0]);
                    }
                    return stream.tty.ops.ioctl_tcsets(stream.tty, op, {
                      c_iflag,
                      c_oflag,
                      c_cflag,
                      c_lflag,
                      c_cc
                    });
                  }
                  return 0;
                }
                case 21519: {
                  if (!stream.tty)
                    return -59;
                  var argp = SYSCALLS.getp();
                  HEAP32[argp >>> 2 >>> 0] = 0;
                  return 0;
                }
                case 21520: {
                  if (!stream.tty)
                    return -59;
                  return -28;
                }
                case 21531: {
                  var argp = SYSCALLS.getp();
                  return FS.ioctl(stream, op, argp);
                }
                case 21523: {
                  if (!stream.tty)
                    return -59;
                  if (stream.tty.ops.ioctl_tiocgwinsz) {
                    var winsize = stream.tty.ops.ioctl_tiocgwinsz(stream.tty);
                    var argp = SYSCALLS.getp();
                    HEAP16[argp >>> 1 >>> 0] = winsize[0];
                    HEAP16[argp + 2 >>> 1 >>> 0] = winsize[1];
                  }
                  return 0;
                }
                case 21524: {
                  if (!stream.tty)
                    return -59;
                  return 0;
                }
                case 21515: {
                  if (!stream.tty)
                    return -59;
                  return 0;
                }
                default:
                  return -28;
              }
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_ioctl.sig = "iiip";
          function ___syscall_listen(fd, backlog) {
            try {
              var sock = getSocketFromFD(fd);
              sock.sock_ops.listen(sock, backlog);
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_listen.sig = "iiiiiii";
          function ___syscall_lstat64(path, buf) {
            path >>>= 0;
            buf >>>= 0;
            try {
              path = SYSCALLS.getStr(path);
              return SYSCALLS.doStat(FS.lstat, path, buf);
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_lstat64.sig = "ipp";
          function ___syscall_mkdirat(dirfd, path, mode) {
            path >>>= 0;
            try {
              path = SYSCALLS.getStr(path);
              path = SYSCALLS.calculateAt(dirfd, path);
              path = PATH.normalize(path);
              if (path[path.length - 1] === "/")
                path = path.substr(0, path.length - 1);
              FS.mkdir(path, mode, 0);
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_mkdirat.sig = "iipi";
          function ___syscall_mknodat(dirfd, path, mode, dev) {
            path >>>= 0;
            try {
              path = SYSCALLS.getStr(path);
              path = SYSCALLS.calculateAt(dirfd, path);
              switch (mode & 61440) {
                case 32768:
                case 8192:
                case 24576:
                case 4096:
                case 49152:
                  break;
                default:
                  return -28;
              }
              FS.mknod(path, mode, dev);
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_mknodat.sig = "iipii";
          function ___syscall_newfstatat(dirfd, path, buf, flags2) {
            path >>>= 0;
            buf >>>= 0;
            try {
              path = SYSCALLS.getStr(path);
              var nofollow = flags2 & 256;
              var allowEmpty = flags2 & 4096;
              flags2 = flags2 & ~6400;
              path = SYSCALLS.calculateAt(dirfd, path, allowEmpty);
              return SYSCALLS.doStat(nofollow ? FS.lstat : FS.stat, path, buf);
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_newfstatat.sig = "iippi";
          function ___syscall_openat(dirfd, path, flags2, varargs) {
            path >>>= 0;
            varargs >>>= 0;
            SYSCALLS.varargs = varargs;
            try {
              path = SYSCALLS.getStr(path);
              path = SYSCALLS.calculateAt(dirfd, path);
              var mode = varargs ? SYSCALLS.get() : 0;
              return FS.open(path, flags2, mode).fd;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_openat.sig = "iipip";
          var PIPEFS = {
            BUCKET_BUFFER_SIZE: 8192,
            mount(mount) {
              return FS.createNode(null, "/", 16384 | 511, 0);
            },
            createPipe() {
              var pipe = {
                buckets: [],
                refcnt: 2
              };
              pipe.buckets.push({
                buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
                offset: 0,
                roffset: 0
              });
              var rName = PIPEFS.nextname();
              var wName = PIPEFS.nextname();
              var rNode = FS.createNode(PIPEFS.root, rName, 4096, 0);
              var wNode = FS.createNode(PIPEFS.root, wName, 4096, 0);
              rNode.pipe = pipe;
              wNode.pipe = pipe;
              var readableStream = FS.createStream({
                path: rName,
                node: rNode,
                flags: 0,
                seekable: false,
                stream_ops: PIPEFS.stream_ops
              });
              rNode.stream = readableStream;
              var writableStream = FS.createStream({
                path: wName,
                node: wNode,
                flags: 1,
                seekable: false,
                stream_ops: PIPEFS.stream_ops
              });
              wNode.stream = writableStream;
              return {
                readable_fd: readableStream.fd,
                writable_fd: writableStream.fd
              };
            },
            stream_ops: {
              poll(stream) {
                var pipe = stream.node.pipe;
                if ((stream.flags & 2097155) === 1) {
                  return 256 | 4;
                }
                if (pipe.buckets.length > 0) {
                  for (var i2 = 0; i2 < pipe.buckets.length; i2++) {
                    var bucket = pipe.buckets[i2];
                    if (bucket.offset - bucket.roffset > 0) {
                      return 64 | 1;
                    }
                  }
                }
                return 0;
              },
              ioctl(stream, request, varargs) {
                return 28;
              },
              fsync(stream) {
                return 28;
              },
              read(stream, buffer, offset, length, position) {
                var pipe = stream.node.pipe;
                var currentLength = 0;
                for (var i2 = 0; i2 < pipe.buckets.length; i2++) {
                  var bucket = pipe.buckets[i2];
                  currentLength += bucket.offset - bucket.roffset;
                }
                var data2 = buffer.subarray(offset, offset + length);
                if (length <= 0) {
                  return 0;
                }
                if (currentLength == 0) {
                  throw new FS.ErrnoError(6);
                }
                var toRead = Math.min(currentLength, length);
                var totalRead = toRead;
                var toRemove = 0;
                for (var i2 = 0; i2 < pipe.buckets.length; i2++) {
                  var currBucket = pipe.buckets[i2];
                  var bucketSize = currBucket.offset - currBucket.roffset;
                  if (toRead <= bucketSize) {
                    var tmpSlice = currBucket.buffer.subarray(currBucket.roffset, currBucket.offset);
                    if (toRead < bucketSize) {
                      tmpSlice = tmpSlice.subarray(0, toRead);
                      currBucket.roffset += toRead;
                    } else {
                      toRemove++;
                    }
                    data2.set(tmpSlice);
                    break;
                  } else {
                    var tmpSlice = currBucket.buffer.subarray(currBucket.roffset, currBucket.offset);
                    data2.set(tmpSlice);
                    data2 = data2.subarray(tmpSlice.byteLength);
                    toRead -= tmpSlice.byteLength;
                    toRemove++;
                  }
                }
                if (toRemove && toRemove == pipe.buckets.length) {
                  toRemove--;
                  pipe.buckets[toRemove].offset = 0;
                  pipe.buckets[toRemove].roffset = 0;
                }
                pipe.buckets.splice(0, toRemove);
                return totalRead;
              },
              write(stream, buffer, offset, length, position) {
                var pipe = stream.node.pipe;
                var data2 = buffer.subarray(offset, offset + length);
                var dataLen = data2.byteLength;
                if (dataLen <= 0) {
                  return 0;
                }
                var currBucket = null;
                if (pipe.buckets.length == 0) {
                  currBucket = {
                    buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
                    offset: 0,
                    roffset: 0
                  };
                  pipe.buckets.push(currBucket);
                } else {
                  currBucket = pipe.buckets[pipe.buckets.length - 1];
                }
                assert(currBucket.offset <= PIPEFS.BUCKET_BUFFER_SIZE);
                var freeBytesInCurrBuffer = PIPEFS.BUCKET_BUFFER_SIZE - currBucket.offset;
                if (freeBytesInCurrBuffer >= dataLen) {
                  currBucket.buffer.set(data2, currBucket.offset);
                  currBucket.offset += dataLen;
                  return dataLen;
                } else if (freeBytesInCurrBuffer > 0) {
                  currBucket.buffer.set(data2.subarray(0, freeBytesInCurrBuffer), currBucket.offset);
                  currBucket.offset += freeBytesInCurrBuffer;
                  data2 = data2.subarray(freeBytesInCurrBuffer, data2.byteLength);
                }
                var numBuckets = data2.byteLength / PIPEFS.BUCKET_BUFFER_SIZE | 0;
                var remElements = data2.byteLength % PIPEFS.BUCKET_BUFFER_SIZE;
                for (var i2 = 0; i2 < numBuckets; i2++) {
                  var newBucket = {
                    buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
                    offset: PIPEFS.BUCKET_BUFFER_SIZE,
                    roffset: 0
                  };
                  pipe.buckets.push(newBucket);
                  newBucket.buffer.set(data2.subarray(0, PIPEFS.BUCKET_BUFFER_SIZE));
                  data2 = data2.subarray(PIPEFS.BUCKET_BUFFER_SIZE, data2.byteLength);
                }
                if (remElements > 0) {
                  var newBucket = {
                    buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
                    offset: data2.byteLength,
                    roffset: 0
                  };
                  pipe.buckets.push(newBucket);
                  newBucket.buffer.set(data2);
                }
                return dataLen;
              },
              close(stream) {
                var pipe = stream.node.pipe;
                pipe.refcnt--;
                if (pipe.refcnt === 0) {
                  pipe.buckets = null;
                }
              }
            },
            nextname() {
              if (!PIPEFS.nextname.current) {
                PIPEFS.nextname.current = 0;
              }
              return "pipe[" + PIPEFS.nextname.current++ + "]";
            }
          };
          function ___syscall_pipe(fdPtr) {
            fdPtr >>>= 0;
            try {
              if (fdPtr == 0) {
                throw new FS.ErrnoError(21);
              }
              var res = PIPEFS.createPipe();
              HEAP32[fdPtr >>> 2 >>> 0] = res.readable_fd;
              HEAP32[fdPtr + 4 >>> 2 >>> 0] = res.writable_fd;
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_pipe.sig = "ip";
          function ___syscall_poll(fds, nfds, timeout) {
            fds >>>= 0;
            try {
              var nonzero = 0;
              for (var i2 = 0; i2 < nfds; i2++) {
                var pollfd = fds + 8 * i2;
                var fd = HEAP32[pollfd >>> 2 >>> 0];
                var events = HEAP16[pollfd + 4 >>> 1 >>> 0];
                var mask = 32;
                var stream = FS.getStream(fd);
                if (stream) {
                  mask = SYSCALLS.DEFAULT_POLLMASK;
                  if (stream.stream_ops.poll) {
                    mask = stream.stream_ops.poll(stream, -1);
                  }
                }
                mask &= events | 8 | 16;
                if (mask)
                  nonzero++;
                HEAP16[pollfd + 6 >>> 1 >>> 0] = mask;
              }
              return nonzero;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_poll.sig = "ipii";
          function ___syscall_readlinkat(dirfd, path, buf, bufsize) {
            path >>>= 0;
            buf >>>= 0;
            bufsize >>>= 0;
            try {
              path = SYSCALLS.getStr(path);
              path = SYSCALLS.calculateAt(dirfd, path);
              if (bufsize <= 0)
                return -28;
              var ret = FS.readlink(path);
              var len2 = Math.min(bufsize, lengthBytesUTF8(ret));
              var endChar = HEAP8[buf + len2 >>> 0];
              stringToUTF8(ret, buf, bufsize + 1);
              HEAP8[buf + len2 >>> 0] = endChar;
              return len2;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_readlinkat.sig = "iippp";
          function ___syscall_recvfrom(fd, buf, len2, flags2, addr2, addrlen) {
            buf >>>= 0;
            len2 >>>= 0;
            addr2 >>>= 0;
            addrlen >>>= 0;
            try {
              var sock = getSocketFromFD(fd);
              var msg = sock.sock_ops.recvmsg(sock, len2);
              if (!msg)
                return 0;
              if (addr2) {
                var errno = writeSockaddr(addr2, sock.family, DNS.lookup_name(msg.addr), msg.port, addrlen);
              }
              HEAPU8.set(msg.buffer, buf >>> 0);
              return msg.buffer.byteLength;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_recvfrom.sig = "iippipp";
          function ___syscall_recvmsg(fd, message, flags2, d1, d2, d3) {
            message >>>= 0;
            try {
              var sock = getSocketFromFD(fd);
              var iov = HEAPU32[message + 8 >>> 2 >>> 0];
              var num = HEAP32[message + 12 >>> 2 >>> 0];
              var total = 0;
              for (var i2 = 0; i2 < num; i2++) {
                total += HEAP32[iov + (8 * i2 + 4) >>> 2 >>> 0];
              }
              var msg = sock.sock_ops.recvmsg(sock, total);
              if (!msg)
                return 0;
              var name2 = HEAPU32[message >>> 2 >>> 0];
              if (name2) {
                var errno = writeSockaddr(name2, sock.family, DNS.lookup_name(msg.addr), msg.port);
              }
              var bytesRead = 0;
              var bytesRemaining = msg.buffer.byteLength;
              for (var i2 = 0; bytesRemaining > 0 && i2 < num; i2++) {
                var iovbase = HEAPU32[iov + (8 * i2 + 0) >>> 2 >>> 0];
                var iovlen = HEAP32[iov + (8 * i2 + 4) >>> 2 >>> 0];
                if (!iovlen) {
                  continue;
                }
                var length = Math.min(iovlen, bytesRemaining);
                var buf = msg.buffer.subarray(bytesRead, bytesRead + length);
                HEAPU8.set(buf, iovbase + bytesRead >>> 0);
                bytesRead += length;
                bytesRemaining -= length;
              }
              return bytesRead;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_recvmsg.sig = "iipiiii";
          function ___syscall_renameat(olddirfd, oldpath, newdirfd, newpath) {
            oldpath >>>= 0;
            newpath >>>= 0;
            try {
              oldpath = SYSCALLS.getStr(oldpath);
              newpath = SYSCALLS.getStr(newpath);
              oldpath = SYSCALLS.calculateAt(olddirfd, oldpath);
              newpath = SYSCALLS.calculateAt(newdirfd, newpath);
              FS.rename(oldpath, newpath);
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_renameat.sig = "iipip";
          function ___syscall_rmdir(path) {
            path >>>= 0;
            try {
              path = SYSCALLS.getStr(path);
              FS.rmdir(path);
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_rmdir.sig = "ip";
          function ___syscall_sendmsg(fd, message, flags2, d1, d2, d3) {
            message >>>= 0;
            d1 >>>= 0;
            d2 >>>= 0;
            try {
              var sock = getSocketFromFD(fd);
              var iov = HEAPU32[message + 8 >>> 2 >>> 0];
              var num = HEAP32[message + 12 >>> 2 >>> 0];
              var addr2, port;
              var name2 = HEAPU32[message >>> 2 >>> 0];
              var namelen = HEAP32[message + 4 >>> 2 >>> 0];
              if (name2) {
                var info2 = readSockaddr(name2, namelen);
                if (info2.errno)
                  return -info2.errno;
                port = info2.port;
                addr2 = DNS.lookup_addr(info2.addr) || info2.addr;
              }
              var total = 0;
              for (var i2 = 0; i2 < num; i2++) {
                total += HEAP32[iov + (8 * i2 + 4) >>> 2 >>> 0];
              }
              var view = new Uint8Array(total);
              var offset = 0;
              for (var i2 = 0; i2 < num; i2++) {
                var iovbase = HEAPU32[iov + (8 * i2 + 0) >>> 2 >>> 0];
                var iovlen = HEAP32[iov + (8 * i2 + 4) >>> 2 >>> 0];
                for (var j = 0; j < iovlen; j++) {
                  view[offset++] = HEAP8[iovbase + j >>> 0 >>> 0];
                }
              }
              return sock.sock_ops.sendmsg(sock, view, 0, total, addr2, port);
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_sendmsg.sig = "iipippi";
          function ___syscall_sendto(fd, message, length, flags2, addr2, addr_len) {
            message >>>= 0;
            length >>>= 0;
            addr2 >>>= 0;
            addr_len >>>= 0;
            try {
              var sock = getSocketFromFD(fd);
              var dest = getSocketAddress(addr2, addr_len, true);
              if (!dest) {
                return FS.write(sock.stream, HEAP8, message, length);
              }
              return sock.sock_ops.sendmsg(sock, HEAP8, message, length, dest.addr, dest.port);
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_sendto.sig = "iippipp";
          function ___syscall_socket(domain, type, protocol) {
            try {
              var sock = SOCKFS.createSocket(domain, type, protocol);
              return sock.stream.fd;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_socket.sig = "iiiiiii";
          function ___syscall_stat64(path, buf) {
            path >>>= 0;
            buf >>>= 0;
            try {
              path = SYSCALLS.getStr(path);
              return SYSCALLS.doStat(FS.stat, path, buf);
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_stat64.sig = "ipp";
          function ___syscall_symlink(target, linkpath) {
            target >>>= 0;
            linkpath >>>= 0;
            try {
              target = SYSCALLS.getStr(target);
              linkpath = SYSCALLS.getStr(linkpath);
              FS.symlink(target, linkpath);
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_symlink.sig = "ipp";
          function ___syscall_symlinkat(target, newdirfd, linkpath) {
            target >>>= 0;
            linkpath >>>= 0;
            try {
              linkpath = SYSCALLS.calculateAt(newdirfd, linkpath);
              FS.symlink(target, linkpath);
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_symlinkat.sig = "ipip";
          function ___syscall_truncate64(path, length_low, length_high) {
            path >>>= 0;
            var length = convertI32PairToI53Checked(length_low, length_high);
            try {
              if (isNaN(length))
                return 61;
              path = SYSCALLS.getStr(path);
              FS.truncate(path, length);
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_truncate64.sig = "ipii";
          function ___syscall_unlinkat(dirfd, path, flags2) {
            path >>>= 0;
            try {
              path = SYSCALLS.getStr(path);
              path = SYSCALLS.calculateAt(dirfd, path);
              if (flags2 === 0) {
                FS.unlink(path);
              } else if (flags2 === 512) {
                FS.rmdir(path);
              } else {
                abort("Invalid flags passed to unlinkat");
              }
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_unlinkat.sig = "iipi";
          var readI53FromI64 = (ptr2) => HEAPU32[ptr2 >>> 2 >>> 0] + HEAP32[ptr2 + 4 >>> 2 >>> 0] * 4294967296;
          function ___syscall_utimensat(dirfd, path, times, flags2) {
            path >>>= 0;
            times >>>= 0;
            try {
              path = SYSCALLS.getStr(path);
              path = SYSCALLS.calculateAt(dirfd, path, true);
              if (!times) {
                var atime = Date.now();
                var mtime = atime;
              } else {
                var seconds = readI53FromI64(times);
                var nanoseconds = HEAP32[times + 8 >>> 2 >>> 0];
                atime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
                times += 16;
                seconds = readI53FromI64(times);
                nanoseconds = HEAP32[times + 8 >>> 2 >>> 0];
                mtime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
              }
              FS.utime(path, atime, mtime);
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_utimensat.sig = "iippi";
          var ___table_base = new WebAssembly.Global({
            "value": "i32",
            "mutable": false
          }, 1);
          var ENV = {};
          var stringToUTF8OnStack = (str) => {
            var size = lengthBytesUTF8(str) + 1;
            var ret = stackAlloc(size);
            stringToUTF8(str, ret, size);
            return ret;
          };
          var withStackSave = (f) => {
            var stack = stackSave();
            var ret = f();
            stackRestore(stack);
            return ret;
          };
          var dlSetError = (msg) => {
            withStackSave(() => {
              var cmsg = stringToUTF8OnStack(msg);
              ___dl_seterr(cmsg, 0);
            });
          };
          var dlopenInternal = (handle2, jsflags) => {
            var filename = UTF8ToString(handle2 + 36);
            var flags2 = HEAP32[handle2 + 4 >>> 2 >>> 0];
            filename = PATH.normalize(filename);
            var searchpaths = [];
            var global2 = Boolean(flags2 & 256);
            var localScope2 = global2 ? null : {};
            var combinedFlags = {
              global: global2,
              nodelete: Boolean(flags2 & 4096),
              loadAsync: jsflags.loadAsync
            };
            if (jsflags.loadAsync) {
              return loadDynamicLibrary(filename, combinedFlags, localScope2, handle2);
            }
            try {
              return loadDynamicLibrary(filename, combinedFlags, localScope2, handle2);
            } catch (e) {
              dlSetError(`Could not load dynamic lib: ${filename}
${e}`);
              return 0;
            }
          };
          function __dlopen_js(handle2) {
            handle2 >>>= 0;
            return dlopenInternal(handle2, {
              loadAsync: false
            });
          }
          __dlopen_js.sig = "pp";
          function __dlsym_js(handle2, symbol, symbolIndex) {
            handle2 >>>= 0;
            symbol >>>= 0;
            symbolIndex >>>= 0;
            symbol = UTF8ToString(symbol);
            var result;
            var newSymIndex;
            var lib = LDSO.loadedLibsByHandle[handle2];
            if (!lib.exports.hasOwnProperty(symbol) || lib.exports[symbol].stub) {
              dlSetError(`Tried to lookup unknown symbol "${symbol}" in dynamic lib: ${lib.name}`);
              return 0;
            }
            newSymIndex = Object.keys(lib.exports).indexOf(symbol);
            var origSym = "orig$" + symbol;
            result = lib.exports[origSym];
            if (result) {
              newSymIndex = Object.keys(lib.exports).indexOf(origSym);
            } else
              result = lib.exports[symbol];
            if (typeof result == "function") {
              var addr2 = getFunctionAddress(result);
              if (addr2) {
                result = addr2;
              } else {
                result = addFunction(result, result.sig);
                HEAPU32[symbolIndex >>> 2 >>> 0] = newSymIndex;
              }
            }
            return result;
          }
          __dlsym_js.sig = "pppp";
          function __embind_register_bigint(primitiveType, name2, size, minRange, maxRange) {
            primitiveType >>>= 0;
            name2 >>>= 0;
            size >>>= 0;
          }
          __embind_register_bigint.sig = "vpppiiii";
          var embind_init_charCodes = () => {
            var codes = new Array(256);
            for (var i2 = 0; i2 < 256; ++i2) {
              codes[i2] = String.fromCharCode(i2);
            }
            embind_charCodes = codes;
          };
          var embind_charCodes;
          var readLatin1String = (ptr2) => {
            var ret = "";
            var c = ptr2;
            while (HEAPU8[c >>> 0]) {
              ret += embind_charCodes[HEAPU8[c++ >>> 0]];
            }
            return ret;
          };
          var awaitingDependencies = {};
          var registeredTypes = {};
          var typeDependencies = {};
          var BindingError;
          var throwBindingError = (message) => {
            throw new BindingError(message);
          };
          var InternalError;
          var throwInternalError = (message) => {
            throw new InternalError(message);
          };
          var whenDependentTypesAreResolved = (myTypes, dependentTypes, getTypeConverters) => {
            myTypes.forEach(function(type) {
              typeDependencies[type] = dependentTypes;
            });
            function onComplete(typeConverters2) {
              var myTypeConverters = getTypeConverters(typeConverters2);
              if (myTypeConverters.length !== myTypes.length) {
                throwInternalError("Mismatched type converter count");
              }
              for (var i2 = 0; i2 < myTypes.length; ++i2) {
                registerType(myTypes[i2], myTypeConverters[i2]);
              }
            }
            var typeConverters = new Array(dependentTypes.length);
            var unregisteredTypes = [];
            var registered = 0;
            dependentTypes.forEach((dt, i2) => {
              if (registeredTypes.hasOwnProperty(dt)) {
                typeConverters[i2] = registeredTypes[dt];
              } else {
                unregisteredTypes.push(dt);
                if (!awaitingDependencies.hasOwnProperty(dt)) {
                  awaitingDependencies[dt] = [];
                }
                awaitingDependencies[dt].push(() => {
                  typeConverters[i2] = registeredTypes[dt];
                  ++registered;
                  if (registered === unregisteredTypes.length) {
                    onComplete(typeConverters);
                  }
                });
              }
            });
            if (0 === unregisteredTypes.length) {
              onComplete(typeConverters);
            }
          };
          function sharedRegisterType(rawType, registeredInstance, options = {}) {
            var name2 = registeredInstance.name;
            if (!rawType) {
              throwBindingError(`type "${name2}" must have a positive integer typeid pointer`);
            }
            if (registeredTypes.hasOwnProperty(rawType)) {
              if (options.ignoreDuplicateRegistrations) {
                return;
              } else {
                throwBindingError(`Cannot register type '${name2}' twice`);
              }
            }
            registeredTypes[rawType] = registeredInstance;
            delete typeDependencies[rawType];
            if (awaitingDependencies.hasOwnProperty(rawType)) {
              var callbacks = awaitingDependencies[rawType];
              delete awaitingDependencies[rawType];
              callbacks.forEach((cb) => cb());
            }
          }
          function registerType(rawType, registeredInstance, options = {}) {
            if (!("argPackAdvance" in registeredInstance)) {
              throw new TypeError("registerType registeredInstance requires argPackAdvance");
            }
            return sharedRegisterType(rawType, registeredInstance, options);
          }
          var GenericWireTypeSize = 8;
          function __embind_register_bool(rawType, name2, trueValue, falseValue) {
            rawType >>>= 0;
            name2 >>>= 0;
            name2 = readLatin1String(name2);
            registerType(rawType, {
              name: name2,
              "fromWireType": function(wt) {
                return !!wt;
              },
              "toWireType": function(destructors, o) {
                return o ? trueValue : falseValue;
              },
              "argPackAdvance": GenericWireTypeSize,
              "readValueFromPointer": function(pointer) {
                return this["fromWireType"](HEAPU8[pointer >>> 0]);
              },
              destructorFunction: null
            });
          }
          __embind_register_bool.sig = "vppii";
          class HandleAllocator {
            constructor() {
              this.allocated = [void 0];
              this.freelist = [];
            }
            get(id) {
              return this.allocated[id];
            }
            has(id) {
              return this.allocated[id] !== void 0;
            }
            allocate(handle2) {
              var id = this.freelist.pop() || this.allocated.length;
              this.allocated[id] = handle2;
              return id;
            }
            free(id) {
              this.allocated[id] = void 0;
              this.freelist.push(id);
            }
          }
          var emval_handles = new HandleAllocator();
          function __emval_decref(handle2) {
            handle2 >>>= 0;
            if (handle2 >= emval_handles.reserved && 0 === --emval_handles.get(handle2).refcount) {
              emval_handles.free(handle2);
            }
          }
          __emval_decref.sig = "vp";
          var count_emval_handles = () => {
            var count = 0;
            for (var i2 = emval_handles.reserved; i2 < emval_handles.allocated.length; ++i2) {
              if (emval_handles.allocated[i2] !== void 0) {
                ++count;
              }
            }
            return count;
          };
          var init_emval = () => {
            emval_handles.allocated.push({
              value: void 0
            }, {
              value: null
            }, {
              value: true
            }, {
              value: false
            });
            Object.assign(emval_handles, {
              reserved: emval_handles.allocated.length
            }), Module["count_emval_handles"] = count_emval_handles;
          };
          var Emval = {
            toValue: (handle2) => {
              if (!handle2) {
                throwBindingError("Cannot use deleted val. handle = " + handle2);
              }
              return emval_handles.get(handle2).value;
            },
            toHandle: (value) => {
              switch (value) {
                case void 0:
                  return 1;
                case null:
                  return 2;
                case true:
                  return 3;
                case false:
                  return 4;
                default: {
                  return emval_handles.allocate({
                    refcount: 1,
                    value
                  });
                }
              }
            }
          };
          function simpleReadValueFromPointer(pointer) {
            return this["fromWireType"](HEAP32[pointer >>> 2 >>> 0]);
          }
          var EmValType = {
            name: "emscripten::val",
            "fromWireType": (handle2) => {
              var rv = Emval.toValue(handle2);
              __emval_decref(handle2);
              return rv;
            },
            "toWireType": (destructors, value) => Emval.toHandle(value),
            "argPackAdvance": GenericWireTypeSize,
            "readValueFromPointer": simpleReadValueFromPointer,
            destructorFunction: null
          };
          function __embind_register_emval(rawType) {
            rawType >>>= 0;
            return registerType(rawType, EmValType);
          }
          __embind_register_emval.sig = "vp";
          var embindRepr = (v) => {
            if (v === null) {
              return "null";
            }
            var t = typeof v;
            if (t === "object" || t === "array" || t === "function") {
              return v.toString();
            } else {
              return "" + v;
            }
          };
          var floatReadValueFromPointer = (name2, width) => {
            switch (width) {
              case 4:
                return function(pointer) {
                  return this["fromWireType"](HEAPF32[pointer >>> 2 >>> 0]);
                };
              case 8:
                return function(pointer) {
                  return this["fromWireType"](HEAPF64[pointer >>> 3 >>> 0]);
                };
              default:
                throw new TypeError(`invalid float width (${width}): ${name2}`);
            }
          };
          var __embind_register_float = function(rawType, name2, size) {
            rawType >>>= 0;
            name2 >>>= 0;
            size >>>= 0;
            name2 = readLatin1String(name2);
            registerType(rawType, {
              name: name2,
              "fromWireType": (value) => value,
              "toWireType": (destructors, value) => value,
              "argPackAdvance": GenericWireTypeSize,
              "readValueFromPointer": floatReadValueFromPointer(name2, size),
              destructorFunction: null
            });
          };
          __embind_register_float.sig = "vppp";
          var integerReadValueFromPointer = (name2, width, signed) => {
            switch (width) {
              case 1:
                return signed ? (pointer) => HEAP8[pointer >>> 0 >>> 0] : (pointer) => HEAPU8[pointer >>> 0 >>> 0];
              case 2:
                return signed ? (pointer) => HEAP16[pointer >>> 1 >>> 0] : (pointer) => HEAPU16[pointer >>> 1 >>> 0];
              case 4:
                return signed ? (pointer) => HEAP32[pointer >>> 2 >>> 0] : (pointer) => HEAPU32[pointer >>> 2 >>> 0];
              default:
                throw new TypeError(`invalid integer width (${width}): ${name2}`);
            }
          };
          function __embind_register_integer(primitiveType, name2, size, minRange, maxRange) {
            primitiveType >>>= 0;
            name2 >>>= 0;
            size >>>= 0;
            name2 = readLatin1String(name2);
            if (maxRange === -1) {
              maxRange = 4294967295;
            }
            var fromWireType = (value) => value;
            if (minRange === 0) {
              var bitshift = 32 - 8 * size;
              fromWireType = (value) => value << bitshift >>> bitshift;
            }
            var isUnsignedType = name2.includes("unsigned");
            var checkAssertions = (value, toTypeName) => {
            };
            var toWireType;
            if (isUnsignedType) {
              toWireType = function(destructors, value) {
                checkAssertions(value, this.name);
                return value >>> 0;
              };
            } else {
              toWireType = function(destructors, value) {
                checkAssertions(value, this.name);
                return value;
              };
            }
            registerType(primitiveType, {
              name: name2,
              "fromWireType": fromWireType,
              "toWireType": toWireType,
              "argPackAdvance": GenericWireTypeSize,
              "readValueFromPointer": integerReadValueFromPointer(name2, size, minRange !== 0),
              destructorFunction: null
            });
          }
          __embind_register_integer.sig = "vpppii";
          function __embind_register_memory_view(rawType, dataTypeIndex, name2) {
            rawType >>>= 0;
            name2 >>>= 0;
            var typeMapping = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
            var TA = typeMapping[dataTypeIndex];
            function decodeMemoryView(handle2) {
              var size = HEAPU32[handle2 >>> 2 >>> 0];
              var data2 = HEAPU32[handle2 + 4 >>> 2 >>> 0];
              return new TA(HEAP8.buffer, data2, size);
            }
            name2 = readLatin1String(name2);
            registerType(rawType, {
              name: name2,
              "fromWireType": decodeMemoryView,
              "argPackAdvance": GenericWireTypeSize,
              "readValueFromPointer": decodeMemoryView
            }, {
              ignoreDuplicateRegistrations: true
            });
          }
          __embind_register_memory_view.sig = "vpip";
          function readPointer(pointer) {
            return this["fromWireType"](HEAPU32[pointer >>> 2 >>> 0]);
          }
          function __embind_register_std_string(rawType, name2) {
            rawType >>>= 0;
            name2 >>>= 0;
            name2 = readLatin1String(name2);
            var stdStringIsUTF8 = name2 === "std::string";
            registerType(rawType, {
              name: name2,
              "fromWireType"(value) {
                var length = HEAPU32[value >>> 2 >>> 0];
                var payload = value + 4;
                var str;
                if (stdStringIsUTF8) {
                  var decodeStartPtr = payload;
                  for (var i2 = 0; i2 <= length; ++i2) {
                    var currentBytePtr = payload + i2;
                    if (i2 == length || HEAPU8[currentBytePtr >>> 0] == 0) {
                      var maxRead = currentBytePtr - decodeStartPtr;
                      var stringSegment = UTF8ToString(decodeStartPtr, maxRead);
                      if (str === void 0) {
                        str = stringSegment;
                      } else {
                        str += String.fromCharCode(0);
                        str += stringSegment;
                      }
                      decodeStartPtr = currentBytePtr + 1;
                    }
                  }
                } else {
                  var a = new Array(length);
                  for (var i2 = 0; i2 < length; ++i2) {
                    a[i2] = String.fromCharCode(HEAPU8[payload + i2 >>> 0]);
                  }
                  str = a.join("");
                }
                _free(value);
                return str;
              },
              "toWireType"(destructors, value) {
                if (value instanceof ArrayBuffer) {
                  value = new Uint8Array(value);
                }
                var length;
                var valueIsOfTypeString = typeof value == "string";
                if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) {
                  throwBindingError("Cannot pass non-string to std::string");
                }
                if (stdStringIsUTF8 && valueIsOfTypeString) {
                  length = lengthBytesUTF8(value);
                } else {
                  length = value.length;
                }
                var base = _malloc(4 + length + 1);
                var ptr2 = base + 4;
                HEAPU32[base >>> 2 >>> 0] = length;
                if (stdStringIsUTF8 && valueIsOfTypeString) {
                  stringToUTF8(value, ptr2, length + 1);
                } else {
                  if (valueIsOfTypeString) {
                    for (var i2 = 0; i2 < length; ++i2) {
                      var charCode = value.charCodeAt(i2);
                      if (charCode > 255) {
                        _free(ptr2);
                        throwBindingError("String has UTF-16 code units that do not fit in 8 bits");
                      }
                      HEAPU8[ptr2 + i2 >>> 0] = charCode;
                    }
                  } else {
                    for (var i2 = 0; i2 < length; ++i2) {
                      HEAPU8[ptr2 + i2 >>> 0] = value[i2];
                    }
                  }
                }
                if (destructors !== null) {
                  destructors.push(_free, base);
                }
                return base;
              },
              "argPackAdvance": GenericWireTypeSize,
              "readValueFromPointer": readPointer,
              destructorFunction(ptr2) {
                _free(ptr2);
              }
            });
          }
          __embind_register_std_string.sig = "vpp";
          var UTF16Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf-16le") : void 0;
          var UTF16ToString = (ptr2, maxBytesToRead) => {
            var endPtr = ptr2;
            var idx = endPtr >> 1;
            var maxIdx = idx + maxBytesToRead / 2;
            while (!(idx >= maxIdx) && HEAPU16[idx >>> 0])
              ++idx;
            endPtr = idx << 1;
            if (endPtr - ptr2 > 32 && UTF16Decoder)
              return UTF16Decoder.decode(HEAPU8.subarray(ptr2 >>> 0, endPtr >>> 0));
            var str = "";
            for (var i2 = 0; !(i2 >= maxBytesToRead / 2); ++i2) {
              var codeUnit = HEAP16[ptr2 + i2 * 2 >>> 1 >>> 0];
              if (codeUnit == 0)
                break;
              str += String.fromCharCode(codeUnit);
            }
            return str;
          };
          var stringToUTF16 = (str, outPtr, maxBytesToWrite) => {
            maxBytesToWrite ?? (maxBytesToWrite = 2147483647);
            if (maxBytesToWrite < 2)
              return 0;
            maxBytesToWrite -= 2;
            var startPtr = outPtr;
            var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;
            for (var i2 = 0; i2 < numCharsToWrite; ++i2) {
              var codeUnit = str.charCodeAt(i2);
              HEAP16[outPtr >>> 1 >>> 0] = codeUnit;
              outPtr += 2;
            }
            HEAP16[outPtr >>> 1 >>> 0] = 0;
            return outPtr - startPtr;
          };
          var lengthBytesUTF16 = (str) => str.length * 2;
          var UTF32ToString = (ptr2, maxBytesToRead) => {
            var i2 = 0;
            var str = "";
            while (!(i2 >= maxBytesToRead / 4)) {
              var utf32 = HEAP32[ptr2 + i2 * 4 >>> 2 >>> 0];
              if (utf32 == 0)
                break;
              ++i2;
              if (utf32 >= 65536) {
                var ch = utf32 - 65536;
                str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
              } else {
                str += String.fromCharCode(utf32);
              }
            }
            return str;
          };
          var stringToUTF32 = (str, outPtr, maxBytesToWrite) => {
            outPtr >>>= 0;
            maxBytesToWrite ?? (maxBytesToWrite = 2147483647);
            if (maxBytesToWrite < 4)
              return 0;
            var startPtr = outPtr;
            var endPtr = startPtr + maxBytesToWrite - 4;
            for (var i2 = 0; i2 < str.length; ++i2) {
              var codeUnit = str.charCodeAt(i2);
              if (codeUnit >= 55296 && codeUnit <= 57343) {
                var trailSurrogate = str.charCodeAt(++i2);
                codeUnit = 65536 + ((codeUnit & 1023) << 10) | trailSurrogate & 1023;
              }
              HEAP32[outPtr >>> 2 >>> 0] = codeUnit;
              outPtr += 4;
              if (outPtr + 4 > endPtr)
                break;
            }
            HEAP32[outPtr >>> 2 >>> 0] = 0;
            return outPtr - startPtr;
          };
          var lengthBytesUTF32 = (str) => {
            var len2 = 0;
            for (var i2 = 0; i2 < str.length; ++i2) {
              var codeUnit = str.charCodeAt(i2);
              if (codeUnit >= 55296 && codeUnit <= 57343)
                ++i2;
              len2 += 4;
            }
            return len2;
          };
          var __embind_register_std_wstring = function(rawType, charSize, name2) {
            rawType >>>= 0;
            charSize >>>= 0;
            name2 >>>= 0;
            name2 = readLatin1String(name2);
            var decodeString, encodeString, getHeap, lengthBytesUTF, shift;
            if (charSize === 2) {
              decodeString = UTF16ToString;
              encodeString = stringToUTF16;
              lengthBytesUTF = lengthBytesUTF16;
              getHeap = () => HEAPU16;
              shift = 1;
            } else if (charSize === 4) {
              decodeString = UTF32ToString;
              encodeString = stringToUTF32;
              lengthBytesUTF = lengthBytesUTF32;
              getHeap = () => HEAPU32;
              shift = 2;
            }
            registerType(rawType, {
              name: name2,
              "fromWireType": (value) => {
                var length = HEAPU32[value >>> 2 >>> 0];
                var HEAP2 = getHeap();
                var str;
                var decodeStartPtr = value + 4;
                for (var i2 = 0; i2 <= length; ++i2) {
                  var currentBytePtr = value + 4 + i2 * charSize;
                  if (i2 == length || HEAP2[currentBytePtr >>> shift] == 0) {
                    var maxReadBytes = currentBytePtr - decodeStartPtr;
                    var stringSegment = decodeString(decodeStartPtr, maxReadBytes);
                    if (str === void 0) {
                      str = stringSegment;
                    } else {
                      str += String.fromCharCode(0);
                      str += stringSegment;
                    }
                    decodeStartPtr = currentBytePtr + charSize;
                  }
                }
                _free(value);
                return str;
              },
              "toWireType": (destructors, value) => {
                if (!(typeof value == "string")) {
                  throwBindingError(`Cannot pass non-string to C++ string type ${name2}`);
                }
                var length = lengthBytesUTF(value);
                var ptr2 = _malloc(4 + length + charSize);
                HEAPU32[ptr2 >>> 2 >>> 0] = length >> shift;
                encodeString(value, ptr2 + 4, length + charSize);
                if (destructors !== null) {
                  destructors.push(_free, ptr2);
                }
                return ptr2;
              },
              "argPackAdvance": GenericWireTypeSize,
              "readValueFromPointer": simpleReadValueFromPointer,
              destructorFunction(ptr2) {
                _free(ptr2);
              }
            });
          };
          __embind_register_std_wstring.sig = "vppp";
          var __embind_register_void = function(rawType, name2) {
            rawType >>>= 0;
            name2 >>>= 0;
            name2 = readLatin1String(name2);
            registerType(rawType, {
              isVoid: true,
              name: name2,
              "argPackAdvance": 0,
              "fromWireType": () => void 0,
              "toWireType": (destructors, o) => void 0
            });
          };
          __embind_register_void.sig = "vpp";
          var handleException = (e) => {
            if (e instanceof ExitStatus || e == "unwind") {
              return EXITSTATUS;
            }
            quit_(1, e);
          };
          var runtimeKeepaliveCounter = 0;
          var keepRuntimeAlive = () => noExitRuntime || runtimeKeepaliveCounter > 0;
          var _proc_exit = (code) => {
            EXITSTATUS = code;
            if (!keepRuntimeAlive()) {
              Module["onExit"]?.(code);
              ABORT = true;
            }
            quit_(code, new ExitStatus(code));
          };
          _proc_exit.sig = "vi";
          var exitJS = (status, implicit) => {
            EXITSTATUS = status;
            _proc_exit(status);
          };
          var _exit = exitJS;
          _exit.sig = "vi";
          var maybeExit = () => {
            if (!keepRuntimeAlive()) {
              try {
                _exit(EXITSTATUS);
              } catch (e) {
                handleException(e);
              }
            }
          };
          var callUserCallback = (func2) => {
            if (ABORT) {
              return;
            }
            try {
              func2();
              maybeExit();
            } catch (e) {
              handleException(e);
            }
          };
          function __emscripten_dlopen_js(handle2, onsuccess, onerror2, user_data) {
            handle2 >>>= 0;
            onsuccess >>>= 0;
            onerror2 >>>= 0;
            user_data >>>= 0;
            function errorCallback(e) {
              var filename = UTF8ToString(handle2 + 36);
              dlSetError(`'Could not load dynamic lib: ${filename}
${e}`);
              callUserCallback(() => getWasmTableEntry(onerror2)(handle2, user_data));
            }
            function successCallback() {
              callUserCallback(() => getWasmTableEntry(onsuccess)(handle2, user_data));
            }
            var promise = dlopenInternal(handle2, {
              loadAsync: true
            });
            if (promise) {
              promise.then(successCallback, errorCallback);
            } else {
              errorCallback();
            }
          }
          __emscripten_dlopen_js.sig = "vpppp";
          var nowIsMonotonic = 1;
          var __emscripten_get_now_is_monotonic = () => nowIsMonotonic;
          __emscripten_get_now_is_monotonic.sig = "i";
          function __emscripten_get_progname(str, len2) {
            str >>>= 0;
            stringToUTF8(thisProgram, str, len2);
          }
          __emscripten_get_progname.sig = "vpi";
          function __emscripten_lookup_name(name2) {
            name2 >>>= 0;
            var nameString = UTF8ToString(name2);
            return inetPton4(DNS.lookup_name(nameString));
          }
          __emscripten_lookup_name.sig = "ip";
          var __emscripten_runtime_keepalive_clear = () => {
            noExitRuntime = false;
            runtimeKeepaliveCounter = 0;
          };
          __emscripten_runtime_keepalive_clear.sig = "v";
          function __emscripten_set_offscreencanvas_size(target, width, height) {
            target >>>= 0;
            return -1;
          }
          __emscripten_set_offscreencanvas_size.sig = "ipii";
          function __emscripten_system(command) {
            command >>>= 0;
            if (ENVIRONMENT_IS_NODE) {
              if (!command)
                return 1;
              var cmdstr = UTF8ToString(command);
              if (!cmdstr.length)
                return 0;
              var cp = ["child_process"].map(__require);
              var ret = cp.spawnSync(cmdstr, [], {
                shell: true,
                stdio: "inherit"
              });
              var _W_EXITCODE = (ret2, sig) => ret2 << 8 | sig;
              if (ret.status === null) {
                var signalToNumber = (sig) => {
                  switch (sig) {
                    case "SIGHUP":
                      return 1;
                    case "SIGINT":
                      return 2;
                    case "SIGQUIT":
                      return 3;
                    case "SIGFPE":
                      return 8;
                    case "SIGKILL":
                      return 9;
                    case "SIGALRM":
                      return 14;
                    case "SIGTERM":
                      return 15;
                  }
                  return 2;
                };
                return _W_EXITCODE(0, signalToNumber(ret.signal));
              }
              return _W_EXITCODE(ret.status, 0);
            }
            if (!command)
              return 0;
            return -52;
          }
          __emscripten_system.sig = "ip";
          var __emscripten_throw_longjmp = () => {
            throw Infinity;
          };
          __emscripten_throw_longjmp.sig = "v";
          function __gmtime_js(time_low, time_high, tmPtr) {
            var time = convertI32PairToI53Checked(time_low, time_high);
            tmPtr >>>= 0;
            var date = new Date(time * 1e3);
            HEAP32[tmPtr >>> 2 >>> 0] = date.getUTCSeconds();
            HEAP32[tmPtr + 4 >>> 2 >>> 0] = date.getUTCMinutes();
            HEAP32[tmPtr + 8 >>> 2 >>> 0] = date.getUTCHours();
            HEAP32[tmPtr + 12 >>> 2 >>> 0] = date.getUTCDate();
            HEAP32[tmPtr + 16 >>> 2 >>> 0] = date.getUTCMonth();
            HEAP32[tmPtr + 20 >>> 2 >>> 0] = date.getUTCFullYear() - 1900;
            HEAP32[tmPtr + 24 >>> 2 >>> 0] = date.getUTCDay();
            var start2 = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
            var yday = (date.getTime() - start2) / (1e3 * 60 * 60 * 24) | 0;
            HEAP32[tmPtr + 28 >>> 2 >>> 0] = yday;
          }
          __gmtime_js.sig = "viip";
          var isLeapYear = (year) => year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
          var MONTH_DAYS_LEAP_CUMULATIVE = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
          var MONTH_DAYS_REGULAR_CUMULATIVE = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
          var ydayFromDate = (date) => {
            var leap = isLeapYear(date.getFullYear());
            var monthDaysCumulative = leap ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE;
            var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1;
            return yday;
          };
          function __localtime_js(time_low, time_high, tmPtr) {
            var time = convertI32PairToI53Checked(time_low, time_high);
            tmPtr >>>= 0;
            var date = new Date(time * 1e3);
            HEAP32[tmPtr >>> 2 >>> 0] = date.getSeconds();
            HEAP32[tmPtr + 4 >>> 2 >>> 0] = date.getMinutes();
            HEAP32[tmPtr + 8 >>> 2 >>> 0] = date.getHours();
            HEAP32[tmPtr + 12 >>> 2 >>> 0] = date.getDate();
            HEAP32[tmPtr + 16 >>> 2 >>> 0] = date.getMonth();
            HEAP32[tmPtr + 20 >>> 2 >>> 0] = date.getFullYear() - 1900;
            HEAP32[tmPtr + 24 >>> 2 >>> 0] = date.getDay();
            var yday = ydayFromDate(date) | 0;
            HEAP32[tmPtr + 28 >>> 2 >>> 0] = yday;
            HEAP32[tmPtr + 36 >>> 2 >>> 0] = -(date.getTimezoneOffset() * 60);
            var start2 = new Date(date.getFullYear(), 0, 1);
            var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
            var winterOffset = start2.getTimezoneOffset();
            var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;
            HEAP32[tmPtr + 32 >>> 2 >>> 0] = dst;
          }
          __localtime_js.sig = "viip";
          var __mktime_js = function(tmPtr) {
            tmPtr >>>= 0;
            var ret = (() => {
              var date = new Date(HEAP32[tmPtr + 20 >>> 2 >>> 0] + 1900, HEAP32[tmPtr + 16 >>> 2 >>> 0], HEAP32[tmPtr + 12 >>> 2 >>> 0], HEAP32[tmPtr + 8 >>> 2 >>> 0], HEAP32[tmPtr + 4 >>> 2 >>> 0], HEAP32[tmPtr >>> 2 >>> 0], 0);
              var dst = HEAP32[tmPtr + 32 >>> 2 >>> 0];
              var guessedOffset = date.getTimezoneOffset();
              var start2 = new Date(date.getFullYear(), 0, 1);
              var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
              var winterOffset = start2.getTimezoneOffset();
              var dstOffset = Math.min(winterOffset, summerOffset);
              if (dst < 0) {
                HEAP32[tmPtr + 32 >>> 2 >>> 0] = Number(summerOffset != winterOffset && dstOffset == guessedOffset);
              } else if (dst > 0 != (dstOffset == guessedOffset)) {
                var nonDstOffset = Math.max(winterOffset, summerOffset);
                var trueOffset = dst > 0 ? dstOffset : nonDstOffset;
                date.setTime(date.getTime() + (trueOffset - guessedOffset) * 6e4);
              }
              HEAP32[tmPtr + 24 >>> 2 >>> 0] = date.getDay();
              var yday = ydayFromDate(date) | 0;
              HEAP32[tmPtr + 28 >>> 2 >>> 0] = yday;
              HEAP32[tmPtr >>> 2 >>> 0] = date.getSeconds();
              HEAP32[tmPtr + 4 >>> 2 >>> 0] = date.getMinutes();
              HEAP32[tmPtr + 8 >>> 2 >>> 0] = date.getHours();
              HEAP32[tmPtr + 12 >>> 2 >>> 0] = date.getDate();
              HEAP32[tmPtr + 16 >>> 2 >>> 0] = date.getMonth();
              HEAP32[tmPtr + 20 >>> 2 >>> 0] = date.getYear();
              var timeMs = date.getTime();
              if (isNaN(timeMs)) {
                return -1;
              }
              return timeMs / 1e3;
            })();
            return setTempRet0((tempDouble = ret, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)), ret >>> 0;
          };
          __mktime_js.sig = "ip";
          function __mmap_js(len2, prot, flags2, fd, offset_low, offset_high, allocated, addr2) {
            len2 >>>= 0;
            var offset = convertI32PairToI53Checked(offset_low, offset_high);
            allocated >>>= 0;
            addr2 >>>= 0;
            try {
              if (isNaN(offset))
                return 61;
              var stream = SYSCALLS.getStreamFromFD(fd);
              var res = FS.mmap(stream, len2, offset, prot, flags2);
              var ptr2 = res.ptr;
              HEAP32[allocated >>> 2 >>> 0] = res.allocated;
              HEAPU32[addr2 >>> 2 >>> 0] = ptr2;
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          __mmap_js.sig = "ipiiiiipp";
          function __msync_js(addr2, len2, prot, flags2, fd, offset_low, offset_high) {
            addr2 >>>= 0;
            len2 >>>= 0;
            var offset = convertI32PairToI53Checked(offset_low, offset_high);
            try {
              if (isNaN(offset))
                return 61;
              SYSCALLS.doMsync(addr2, SYSCALLS.getStreamFromFD(fd), len2, flags2, offset);
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          __msync_js.sig = "ippiiiii";
          function __munmap_js(addr2, len2, prot, flags2, fd, offset_low, offset_high) {
            addr2 >>>= 0;
            len2 >>>= 0;
            var offset = convertI32PairToI53Checked(offset_low, offset_high);
            try {
              if (isNaN(offset))
                return 61;
              var stream = SYSCALLS.getStreamFromFD(fd);
              if (prot & 2) {
                SYSCALLS.doMsync(addr2, stream, len2, flags2, offset);
              }
              FS.munmap(stream);
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          __munmap_js.sig = "ippiiiii";
          var timers = {};
          var _emscripten_get_now;
          _emscripten_get_now = () => performance.now();
          _emscripten_get_now.sig = "d";
          var __setitimer_js = (which, timeout_ms) => {
            if (timers[which]) {
              clearTimeout(timers[which].id);
              delete timers[which];
            }
            if (!timeout_ms)
              return 0;
            var id = setTimeout(() => {
              delete timers[which];
              callUserCallback(() => __emscripten_timeout(which, _emscripten_get_now()));
            }, timeout_ms);
            timers[which] = {
              id,
              timeout_ms
            };
            return 0;
          };
          __setitimer_js.sig = "iid";
          var __timegm_js = function(tmPtr) {
            tmPtr >>>= 0;
            var ret = (() => {
              var time = Date.UTC(HEAP32[tmPtr + 20 >>> 2 >>> 0] + 1900, HEAP32[tmPtr + 16 >>> 2 >>> 0], HEAP32[tmPtr + 12 >>> 2 >>> 0], HEAP32[tmPtr + 8 >>> 2 >>> 0], HEAP32[tmPtr + 4 >>> 2 >>> 0], HEAP32[tmPtr >>> 2 >>> 0], 0);
              var date = new Date(time);
              HEAP32[tmPtr + 24 >>> 2 >>> 0] = date.getUTCDay();
              var start2 = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
              var yday = (date.getTime() - start2) / (1e3 * 60 * 60 * 24) | 0;
              HEAP32[tmPtr + 28 >>> 2 >>> 0] = yday;
              return date.getTime() / 1e3;
            })();
            return setTempRet0((tempDouble = ret, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)), ret >>> 0;
          };
          __timegm_js.sig = "ip";
          var stringToNewUTF8 = (str) => {
            var size = lengthBytesUTF8(str) + 1;
            var ret = _malloc(size);
            if (ret)
              stringToUTF8(str, ret, size);
            return ret;
          };
          function __tzset_js(timezone, daylight, tzname) {
            timezone >>>= 0;
            daylight >>>= 0;
            tzname >>>= 0;
            var currentYear = (/* @__PURE__ */ new Date()).getFullYear();
            var winter = new Date(currentYear, 0, 1);
            var summer = new Date(currentYear, 6, 1);
            var winterOffset = winter.getTimezoneOffset();
            var summerOffset = summer.getTimezoneOffset();
            var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
            HEAPU32[timezone >>> 2 >>> 0] = stdTimezoneOffset * 60;
            HEAP32[daylight >>> 2 >>> 0] = Number(winterOffset != summerOffset);
            function extractZone(date) {
              var match = date.toTimeString().match(/\(([A-Za-z ]+)\)$/);
              return match ? match[1] : "GMT";
            }
            var winterName = extractZone(winter);
            var summerName = extractZone(summer);
            var winterNamePtr = stringToNewUTF8(winterName);
            var summerNamePtr = stringToNewUTF8(summerName);
            if (summerOffset < winterOffset) {
              HEAPU32[tzname >>> 2 >>> 0] = winterNamePtr;
              HEAPU32[tzname + 4 >>> 2 >>> 0] = summerNamePtr;
            } else {
              HEAPU32[tzname >>> 2 >>> 0] = summerNamePtr;
              HEAPU32[tzname + 4 >>> 2 >>> 0] = winterNamePtr;
            }
          }
          __tzset_js.sig = "vppp";
          var _abort = () => {
            abort("");
          };
          _abort.sig = "v";
          var _emscripten_set_main_loop_timing = (mode, value) => {
            Browser.mainLoop.timingMode = mode;
            Browser.mainLoop.timingValue = value;
            if (!Browser.mainLoop.func) {
              return 1;
            }
            if (!Browser.mainLoop.running) {
              Browser.mainLoop.running = true;
            }
            if (mode == 0) {
              Browser.mainLoop.scheduler = function Browser_mainLoop_scheduler_setTimeout() {
                var timeUntilNextTick = Math.max(0, Browser.mainLoop.tickStartTime + value - _emscripten_get_now()) | 0;
                setTimeout(Browser.mainLoop.runner, timeUntilNextTick);
              };
              Browser.mainLoop.method = "timeout";
            } else if (mode == 1) {
              Browser.mainLoop.scheduler = function Browser_mainLoop_scheduler_rAF() {
                Browser.requestAnimationFrame(Browser.mainLoop.runner);
              };
              Browser.mainLoop.method = "rAF";
            } else if (mode == 2) {
              if (typeof Browser.setImmediate == "undefined") {
                if (typeof setImmediate == "undefined") {
                  var setImmediates = [];
                  var emscriptenMainLoopMessageId = "setimmediate";
                  var Browser_setImmediate_messageHandler = (event2) => {
                    if (event2.data === emscriptenMainLoopMessageId || event2.data.target === emscriptenMainLoopMessageId) {
                      event2.stopPropagation();
                      setImmediates.shift()();
                    }
                  };
                  addEventListener("message", Browser_setImmediate_messageHandler, true);
                  Browser.setImmediate = function Browser_emulated_setImmediate(func2) {
                    setImmediates.push(func2);
                    if (ENVIRONMENT_IS_WORKER) {
                      if (Module["setImmediates"] === void 0)
                        Module["setImmediates"] = [];
                      Module["setImmediates"].push(func2);
                      postMessage({
                        target: emscriptenMainLoopMessageId
                      });
                    } else
                      postMessage(emscriptenMainLoopMessageId, "*");
                  };
                } else {
                  Browser.setImmediate = setImmediate;
                }
              }
              Browser.mainLoop.scheduler = function Browser_mainLoop_scheduler_setImmediate() {
                Browser.setImmediate(Browser.mainLoop.runner);
              };
              Browser.mainLoop.method = "immediate";
            }
            return 0;
          };
          _emscripten_set_main_loop_timing.sig = "iii";
          var setMainLoop = (browserIterationFunc, fps, simulateInfiniteLoop, arg, noSetTiming) => {
            assert(!Browser.mainLoop.func, "emscripten_set_main_loop: there can only be one main loop function at once: call emscripten_cancel_main_loop to cancel the previous one before setting a new one with different parameters.");
            Browser.mainLoop.func = browserIterationFunc;
            Browser.mainLoop.arg = arg;
            var thisMainLoopId = Browser.mainLoop.currentlyRunningMainloop;
            function checkIsRunning() {
              if (thisMainLoopId < Browser.mainLoop.currentlyRunningMainloop) {
                return false;
              }
              return true;
            }
            Browser.mainLoop.running = false;
            Browser.mainLoop.runner = function Browser_mainLoop_runner() {
              if (ABORT)
                return;
              if (Browser.mainLoop.queue.length > 0) {
                var start2 = Date.now();
                var blocker = Browser.mainLoop.queue.shift();
                blocker.func(blocker.arg);
                if (Browser.mainLoop.remainingBlockers) {
                  var remaining = Browser.mainLoop.remainingBlockers;
                  var next = remaining % 1 == 0 ? remaining - 1 : Math.floor(remaining);
                  if (blocker.counted) {
                    Browser.mainLoop.remainingBlockers = next;
                  } else {
                    next = next + 0.5;
                    Browser.mainLoop.remainingBlockers = (8 * remaining + next) / 9;
                  }
                }
                Browser.mainLoop.updateStatus();
                if (!checkIsRunning())
                  return;
                setTimeout(Browser.mainLoop.runner, 0);
                return;
              }
              if (!checkIsRunning())
                return;
              Browser.mainLoop.currentFrameNumber = Browser.mainLoop.currentFrameNumber + 1 | 0;
              if (Browser.mainLoop.timingMode == 1 && Browser.mainLoop.timingValue > 1 && Browser.mainLoop.currentFrameNumber % Browser.mainLoop.timingValue != 0) {
                Browser.mainLoop.scheduler();
                return;
              } else if (Browser.mainLoop.timingMode == 0) {
                Browser.mainLoop.tickStartTime = _emscripten_get_now();
              }
              Browser.mainLoop.runIter(browserIterationFunc);
              if (!checkIsRunning())
                return;
              if (typeof SDL == "object")
                SDL.audio?.queueNewAudioData?.();
              Browser.mainLoop.scheduler();
            };
            if (!noSetTiming) {
              if (fps && fps > 0) {
                _emscripten_set_main_loop_timing(0, 1e3 / fps);
              } else {
                _emscripten_set_main_loop_timing(1, 1);
              }
              Browser.mainLoop.scheduler();
            }
            if (simulateInfiniteLoop) {
              throw "unwind";
            }
          };
          var safeSetTimeout = (func2, timeout) => setTimeout(() => {
            callUserCallback(func2);
          }, timeout);
          var warnOnce = (text) => {
            warnOnce.shown || (warnOnce.shown = {});
            if (!warnOnce.shown[text]) {
              warnOnce.shown[text] = 1;
              if (ENVIRONMENT_IS_NODE)
                text = "warning: " + text;
              err(text);
            }
          };
          var Browser = {
            mainLoop: {
              running: false,
              scheduler: null,
              method: "",
              currentlyRunningMainloop: 0,
              func: null,
              arg: 0,
              timingMode: 0,
              timingValue: 0,
              currentFrameNumber: 0,
              queue: [],
              pause() {
                Browser.mainLoop.scheduler = null;
                Browser.mainLoop.currentlyRunningMainloop++;
              },
              resume() {
                Browser.mainLoop.currentlyRunningMainloop++;
                var timingMode = Browser.mainLoop.timingMode;
                var timingValue = Browser.mainLoop.timingValue;
                var func2 = Browser.mainLoop.func;
                Browser.mainLoop.func = null;
                setMainLoop(func2, 0, false, Browser.mainLoop.arg, true);
                _emscripten_set_main_loop_timing(timingMode, timingValue);
                Browser.mainLoop.scheduler();
              },
              updateStatus() {
                if (Module["setStatus"]) {
                  var message = Module["statusMessage"] || "Please wait...";
                  var remaining = Browser.mainLoop.remainingBlockers;
                  var expected = Browser.mainLoop.expectedBlockers;
                  if (remaining) {
                    if (remaining < expected) {
                      Module["setStatus"](message + " (" + (expected - remaining) + "/" + expected + ")");
                    } else {
                      Module["setStatus"](message);
                    }
                  } else {
                    Module["setStatus"]("");
                  }
                }
              },
              runIter(func2) {
                if (ABORT)
                  return;
                if (Module["preMainLoop"]) {
                  var preRet = Module["preMainLoop"]();
                  if (preRet === false) {
                    return;
                  }
                }
                callUserCallback(func2);
                Module["postMainLoop"]?.();
              }
            },
            isFullscreen: false,
            pointerLock: false,
            moduleContextCreatedCallbacks: [],
            workers: [],
            init() {
              if (Browser.initted)
                return;
              Browser.initted = true;
              var imagePlugin = {};
              imagePlugin["canHandle"] = function imagePlugin_canHandle(name2) {
                return !Module.noImageDecoding && /\.(jpg|jpeg|png|bmp)$/i.test(name2);
              };
              imagePlugin["handle"] = function imagePlugin_handle(byteArray, name2, onload2, onerror2) {
                var b = new Blob([byteArray], {
                  type: Browser.getMimetype(name2)
                });
                if (b.size !== byteArray.length) {
                  b = new Blob([new Uint8Array(byteArray).buffer], {
                    type: Browser.getMimetype(name2)
                  });
                }
                var url2 = URL.createObjectURL(b);
                var img = new Image();
                img.onload = () => {
                  assert(img.complete, `Image ${name2} could not be decoded`);
                  var canvas2 = document.createElement("canvas");
                  canvas2.width = img.width;
                  canvas2.height = img.height;
                  var ctx = canvas2.getContext("2d");
                  ctx.drawImage(img, 0, 0);
                  preloadedImages[name2] = canvas2;
                  URL.revokeObjectURL(url2);
                  onload2?.(byteArray);
                };
                img.onerror = (event2) => {
                  err(`Image ${url2} could not be decoded`);
                  onerror2?.();
                };
                img.src = url2;
              };
              preloadPlugins.push(imagePlugin);
              var audioPlugin = {};
              audioPlugin["canHandle"] = function audioPlugin_canHandle(name2) {
                return !Module.noAudioDecoding && name2.substr(-4) in {
                  ".ogg": 1,
                  ".wav": 1,
                  ".mp3": 1
                };
              };
              audioPlugin["handle"] = function audioPlugin_handle(byteArray, name2, onload2, onerror2) {
                var done = false;
                function finish(audio2) {
                  if (done)
                    return;
                  done = true;
                  preloadedAudios[name2] = audio2;
                  onload2?.(byteArray);
                }
                function fail() {
                  if (done)
                    return;
                  done = true;
                  preloadedAudios[name2] = new Audio();
                  onerror2?.();
                }
                var b = new Blob([byteArray], {
                  type: Browser.getMimetype(name2)
                });
                var url2 = URL.createObjectURL(b);
                var audio = new Audio();
                audio.addEventListener("canplaythrough", () => finish(audio), false);
                audio.onerror = function audio_onerror(event2) {
                  if (done)
                    return;
                  err(`warning: browser could not fully decode audio ${name2}, trying slower base64 approach`);
                  function encode64(data2) {
                    var BASE = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
                    var PAD = "=";
                    var ret = "";
                    var leftchar = 0;
                    var leftbits = 0;
                    for (var i2 = 0; i2 < data2.length; i2++) {
                      leftchar = leftchar << 8 | data2[i2];
                      leftbits += 8;
                      while (leftbits >= 6) {
                        var curr = leftchar >> leftbits - 6 & 63;
                        leftbits -= 6;
                        ret += BASE[curr];
                      }
                    }
                    if (leftbits == 2) {
                      ret += BASE[(leftchar & 3) << 4];
                      ret += PAD + PAD;
                    } else if (leftbits == 4) {
                      ret += BASE[(leftchar & 15) << 2];
                      ret += PAD;
                    }
                    return ret;
                  }
                  audio.src = "data:audio/x-" + name2.substr(-3) + ";base64," + encode64(byteArray);
                  finish(audio);
                };
                audio.src = url2;
                safeSetTimeout(() => {
                  finish(audio);
                }, 1e4);
              };
              preloadPlugins.push(audioPlugin);
              function pointerLockChange() {
                Browser.pointerLock = document["pointerLockElement"] === Module["canvas"] || document["mozPointerLockElement"] === Module["canvas"] || document["webkitPointerLockElement"] === Module["canvas"] || document["msPointerLockElement"] === Module["canvas"];
              }
              var canvas = Module["canvas"];
              if (canvas) {
                canvas.requestPointerLock = canvas["requestPointerLock"] || canvas["mozRequestPointerLock"] || canvas["webkitRequestPointerLock"] || canvas["msRequestPointerLock"] || (() => {
                });
                canvas.exitPointerLock = document["exitPointerLock"] || document["mozExitPointerLock"] || document["webkitExitPointerLock"] || document["msExitPointerLock"] || (() => {
                });
                canvas.exitPointerLock = canvas.exitPointerLock.bind(document);
                document.addEventListener("pointerlockchange", pointerLockChange, false);
                document.addEventListener("mozpointerlockchange", pointerLockChange, false);
                document.addEventListener("webkitpointerlockchange", pointerLockChange, false);
                document.addEventListener("mspointerlockchange", pointerLockChange, false);
                if (Module["elementPointerLock"]) {
                  canvas.addEventListener("click", (ev) => {
                    if (!Browser.pointerLock && Module["canvas"].requestPointerLock) {
                      Module["canvas"].requestPointerLock();
                      ev.preventDefault();
                    }
                  }, false);
                }
              }
            },
            createContext(canvas, useWebGL, setInModule, webGLContextAttributes) {
              if (useWebGL && Module.ctx && canvas == Module.canvas)
                return Module.ctx;
              var ctx;
              var contextHandle;
              if (useWebGL) {
                var contextAttributes = {
                  antialias: false,
                  alpha: false,
                  majorVersion: 1
                };
                if (webGLContextAttributes) {
                  for (var attribute in webGLContextAttributes) {
                    contextAttributes[attribute] = webGLContextAttributes[attribute];
                  }
                }
                if (typeof GL != "undefined") {
                  contextHandle = GL.createContext(canvas, contextAttributes);
                  if (contextHandle) {
                    ctx = GL.getContext(contextHandle).GLctx;
                  }
                }
              } else {
                ctx = canvas.getContext("2d");
              }
              if (!ctx)
                return null;
              if (setInModule) {
                if (!useWebGL)
                  assert(typeof GLctx == "undefined", "cannot set in module if GLctx is used, but we are a non-GL context that would replace it");
                Module.ctx = ctx;
                if (useWebGL)
                  GL.makeContextCurrent(contextHandle);
                Module.useWebGL = useWebGL;
                Browser.moduleContextCreatedCallbacks.forEach((callback) => callback());
                Browser.init();
              }
              return ctx;
            },
            destroyContext(canvas, useWebGL, setInModule) {
            },
            fullscreenHandlersInstalled: false,
            lockPointer: void 0,
            resizeCanvas: void 0,
            requestFullscreen(lockPointer, resizeCanvas) {
              Browser.lockPointer = lockPointer;
              Browser.resizeCanvas = resizeCanvas;
              if (typeof Browser.lockPointer == "undefined")
                Browser.lockPointer = true;
              if (typeof Browser.resizeCanvas == "undefined")
                Browser.resizeCanvas = false;
              var canvas = Module["canvas"];
              function fullscreenChange() {
                Browser.isFullscreen = false;
                var canvasContainer2 = canvas.parentNode;
                if ((document["fullscreenElement"] || document["mozFullScreenElement"] || document["msFullscreenElement"] || document["webkitFullscreenElement"] || document["webkitCurrentFullScreenElement"]) === canvasContainer2) {
                  canvas.exitFullscreen = Browser.exitFullscreen;
                  if (Browser.lockPointer)
                    canvas.requestPointerLock();
                  Browser.isFullscreen = true;
                  if (Browser.resizeCanvas) {
                    Browser.setFullscreenCanvasSize();
                  } else {
                    Browser.updateCanvasDimensions(canvas);
                  }
                } else {
                  canvasContainer2.parentNode.insertBefore(canvas, canvasContainer2);
                  canvasContainer2.parentNode.removeChild(canvasContainer2);
                  if (Browser.resizeCanvas) {
                    Browser.setWindowedCanvasSize();
                  } else {
                    Browser.updateCanvasDimensions(canvas);
                  }
                }
                Module["onFullScreen"]?.(Browser.isFullscreen);
                Module["onFullscreen"]?.(Browser.isFullscreen);
              }
              if (!Browser.fullscreenHandlersInstalled) {
                Browser.fullscreenHandlersInstalled = true;
                document.addEventListener("fullscreenchange", fullscreenChange, false);
                document.addEventListener("mozfullscreenchange", fullscreenChange, false);
                document.addEventListener("webkitfullscreenchange", fullscreenChange, false);
                document.addEventListener("MSFullscreenChange", fullscreenChange, false);
              }
              var canvasContainer = document.createElement("div");
              canvas.parentNode.insertBefore(canvasContainer, canvas);
              canvasContainer.appendChild(canvas);
              canvasContainer.requestFullscreen = canvasContainer["requestFullscreen"] || canvasContainer["mozRequestFullScreen"] || canvasContainer["msRequestFullscreen"] || (canvasContainer["webkitRequestFullscreen"] ? () => canvasContainer["webkitRequestFullscreen"](Element["ALLOW_KEYBOARD_INPUT"]) : null) || (canvasContainer["webkitRequestFullScreen"] ? () => canvasContainer["webkitRequestFullScreen"](Element["ALLOW_KEYBOARD_INPUT"]) : null);
              canvasContainer.requestFullscreen();
            },
            exitFullscreen() {
              if (!Browser.isFullscreen) {
                return false;
              }
              var CFS = document["exitFullscreen"] || document["cancelFullScreen"] || document["mozCancelFullScreen"] || document["msExitFullscreen"] || document["webkitCancelFullScreen"] || (() => {
              });
              CFS.apply(document, []);
              return true;
            },
            nextRAF: 0,
            fakeRequestAnimationFrame(func2) {
              var now = Date.now();
              if (Browser.nextRAF === 0) {
                Browser.nextRAF = now + 1e3 / 60;
              } else {
                while (now + 2 >= Browser.nextRAF) {
                  Browser.nextRAF += 1e3 / 60;
                }
              }
              var delay = Math.max(Browser.nextRAF - now, 0);
              setTimeout(func2, delay);
            },
            requestAnimationFrame(func2) {
              if (typeof requestAnimationFrame == "function") {
                requestAnimationFrame(func2);
                return;
              }
              var RAF = Browser.fakeRequestAnimationFrame;
              RAF(func2);
            },
            safeSetTimeout(func2, timeout) {
              return safeSetTimeout(func2, timeout);
            },
            safeRequestAnimationFrame(func2) {
              return Browser.requestAnimationFrame(() => {
                callUserCallback(func2);
              });
            },
            getMimetype(name2) {
              return {
                "jpg": "image/jpeg",
                "jpeg": "image/jpeg",
                "png": "image/png",
                "bmp": "image/bmp",
                "ogg": "audio/ogg",
                "wav": "audio/wav",
                "mp3": "audio/mpeg"
              }[name2.substr(name2.lastIndexOf(".") + 1)];
            },
            getUserMedia(func2) {
              window.getUserMedia || (window.getUserMedia = navigator["getUserMedia"] || navigator["mozGetUserMedia"]);
              window.getUserMedia(func2);
            },
            getMovementX(event2) {
              return event2["movementX"] || event2["mozMovementX"] || event2["webkitMovementX"] || 0;
            },
            getMovementY(event2) {
              return event2["movementY"] || event2["mozMovementY"] || event2["webkitMovementY"] || 0;
            },
            getMouseWheelDelta(event2) {
              var delta = 0;
              switch (event2.type) {
                case "DOMMouseScroll":
                  delta = event2.detail / 3;
                  break;
                case "mousewheel":
                  delta = event2.wheelDelta / 120;
                  break;
                case "wheel":
                  delta = event2.deltaY;
                  switch (event2.deltaMode) {
                    case 0:
                      delta /= 100;
                      break;
                    case 1:
                      delta /= 3;
                      break;
                    case 2:
                      delta *= 80;
                      break;
                    default:
                      throw "unrecognized mouse wheel delta mode: " + event2.deltaMode;
                  }
                  break;
                default:
                  throw "unrecognized mouse wheel event: " + event2.type;
              }
              return delta;
            },
            mouseX: 0,
            mouseY: 0,
            mouseMovementX: 0,
            mouseMovementY: 0,
            touches: {},
            lastTouches: {},
            calculateMouseCoords(pageX, pageY) {
              var rect = Module["canvas"].getBoundingClientRect();
              var cw = Module["canvas"].width;
              var ch = Module["canvas"].height;
              var scrollX = typeof window.scrollX != "undefined" ? window.scrollX : window.pageXOffset;
              var scrollY = typeof window.scrollY != "undefined" ? window.scrollY : window.pageYOffset;
              var adjustedX = pageX - (scrollX + rect.left);
              var adjustedY = pageY - (scrollY + rect.top);
              adjustedX = adjustedX * (cw / rect.width);
              adjustedY = adjustedY * (ch / rect.height);
              return {
                x: adjustedX,
                y: adjustedY
              };
            },
            setMouseCoords(pageX, pageY) {
              const {
                x,
                y
              } = Browser.calculateMouseCoords(pageX, pageY);
              Browser.mouseMovementX = x - Browser.mouseX;
              Browser.mouseMovementY = y - Browser.mouseY;
              Browser.mouseX = x;
              Browser.mouseY = y;
            },
            calculateMouseEvent(event2) {
              if (Browser.pointerLock) {
                if (event2.type != "mousemove" && "mozMovementX" in event2) {
                  Browser.mouseMovementX = Browser.mouseMovementY = 0;
                } else {
                  Browser.mouseMovementX = Browser.getMovementX(event2);
                  Browser.mouseMovementY = Browser.getMovementY(event2);
                }
                if (typeof SDL != "undefined") {
                  Browser.mouseX = SDL.mouseX + Browser.mouseMovementX;
                  Browser.mouseY = SDL.mouseY + Browser.mouseMovementY;
                } else {
                  Browser.mouseX += Browser.mouseMovementX;
                  Browser.mouseY += Browser.mouseMovementY;
                }
              } else {
                if (event2.type === "touchstart" || event2.type === "touchend" || event2.type === "touchmove") {
                  var touch = event2.touch;
                  if (touch === void 0) {
                    return;
                  }
                  var coords = Browser.calculateMouseCoords(touch.pageX, touch.pageY);
                  if (event2.type === "touchstart") {
                    Browser.lastTouches[touch.identifier] = coords;
                    Browser.touches[touch.identifier] = coords;
                  } else if (event2.type === "touchend" || event2.type === "touchmove") {
                    var last = Browser.touches[touch.identifier];
                    last || (last = coords);
                    Browser.lastTouches[touch.identifier] = last;
                    Browser.touches[touch.identifier] = coords;
                  }
                  return;
                }
                Browser.setMouseCoords(event2.pageX, event2.pageY);
              }
            },
            resizeListeners: [],
            updateResizeListeners() {
              var canvas = Module["canvas"];
              Browser.resizeListeners.forEach((listener) => listener(canvas.width, canvas.height));
            },
            setCanvasSize(width, height, noUpdates) {
              var canvas = Module["canvas"];
              Browser.updateCanvasDimensions(canvas, width, height);
              if (!noUpdates)
                Browser.updateResizeListeners();
            },
            windowedWidth: 0,
            windowedHeight: 0,
            setFullscreenCanvasSize() {
              if (typeof SDL != "undefined") {
                var flags2 = HEAPU32[SDL.screen >>> 2 >>> 0];
                flags2 = flags2 | 8388608;
                HEAP32[SDL.screen >>> 2 >>> 0] = flags2;
              }
              Browser.updateCanvasDimensions(Module["canvas"]);
              Browser.updateResizeListeners();
            },
            setWindowedCanvasSize() {
              if (typeof SDL != "undefined") {
                var flags2 = HEAPU32[SDL.screen >>> 2 >>> 0];
                flags2 = flags2 & ~8388608;
                HEAP32[SDL.screen >>> 2 >>> 0] = flags2;
              }
              Browser.updateCanvasDimensions(Module["canvas"]);
              Browser.updateResizeListeners();
            },
            updateCanvasDimensions(canvas, wNative, hNative) {
              if (wNative && hNative) {
                canvas.widthNative = wNative;
                canvas.heightNative = hNative;
              } else {
                wNative = canvas.widthNative;
                hNative = canvas.heightNative;
              }
              var w = wNative;
              var h = hNative;
              if (Module["forcedAspectRatio"] && Module["forcedAspectRatio"] > 0) {
                if (w / h < Module["forcedAspectRatio"]) {
                  w = Math.round(h * Module["forcedAspectRatio"]);
                } else {
                  h = Math.round(w / Module["forcedAspectRatio"]);
                }
              }
              if ((document["fullscreenElement"] || document["mozFullScreenElement"] || document["msFullscreenElement"] || document["webkitFullscreenElement"] || document["webkitCurrentFullScreenElement"]) === canvas.parentNode && typeof screen != "undefined") {
                var factor = Math.min(screen.width / w, screen.height / h);
                w = Math.round(w * factor);
                h = Math.round(h * factor);
              }
              if (Browser.resizeCanvas) {
                if (canvas.width != w)
                  canvas.width = w;
                if (canvas.height != h)
                  canvas.height = h;
                if (typeof canvas.style != "undefined") {
                  canvas.style.removeProperty("width");
                  canvas.style.removeProperty("height");
                }
              } else {
                if (canvas.width != wNative)
                  canvas.width = wNative;
                if (canvas.height != hNative)
                  canvas.height = hNative;
                if (typeof canvas.style != "undefined") {
                  if (w != wNative || h != hNative) {
                    canvas.style.setProperty("width", w + "px", "important");
                    canvas.style.setProperty("height", h + "px", "important");
                  } else {
                    canvas.style.removeProperty("width");
                    canvas.style.removeProperty("height");
                  }
                }
              }
            }
          };
          var AL = {
            QUEUE_INTERVAL: 25,
            QUEUE_LOOKAHEAD: 0.1,
            DEVICE_NAME: "Emscripten OpenAL",
            CAPTURE_DEVICE_NAME: "Emscripten OpenAL capture",
            ALC_EXTENSIONS: {
              ALC_SOFT_pause_device: true,
              ALC_SOFT_HRTF: true
            },
            AL_EXTENSIONS: {
              AL_EXT_float32: true,
              AL_SOFT_loop_points: true,
              AL_SOFT_source_length: true,
              AL_EXT_source_distance_model: true,
              AL_SOFT_source_spatialize: true
            },
            _alcErr: 0,
            alcErr: 0,
            deviceRefCounts: {},
            alcStringCache: {},
            paused: false,
            stringCache: {},
            contexts: {},
            currentCtx: null,
            buffers: {
              0: {
                id: 0,
                refCount: 0,
                audioBuf: null,
                frequency: 0,
                bytesPerSample: 2,
                channels: 1,
                length: 0
              }
            },
            paramArray: [],
            _nextId: 1,
            newId: () => AL.freeIds.length > 0 ? AL.freeIds.pop() : AL._nextId++,
            freeIds: [],
            scheduleContextAudio: (ctx) => {
              if (Browser.mainLoop.timingMode === 1 && document["visibilityState"] != "visible") {
                return;
              }
              for (var i2 in ctx.sources) {
                AL.scheduleSourceAudio(ctx.sources[i2]);
              }
            },
            scheduleSourceAudio: (src, lookahead) => {
              if (Browser.mainLoop.timingMode === 1 && document["visibilityState"] != "visible") {
                return;
              }
              if (src.state !== 4114) {
                return;
              }
              var currentTime = AL.updateSourceTime(src);
              var startTime = src.bufStartTime;
              var startOffset = src.bufOffset;
              var bufCursor = src.bufsProcessed;
              for (var i2 = 0; i2 < src.audioQueue.length; i2++) {
                var audioSrc = src.audioQueue[i2];
                startTime = audioSrc._startTime + audioSrc._duration;
                startOffset = 0;
                bufCursor += audioSrc._skipCount + 1;
              }
              if (!lookahead) {
                lookahead = AL.QUEUE_LOOKAHEAD;
              }
              var lookaheadTime = currentTime + lookahead;
              var skipCount = 0;
              while (startTime < lookaheadTime) {
                if (bufCursor >= src.bufQueue.length) {
                  if (src.looping) {
                    bufCursor %= src.bufQueue.length;
                  } else {
                    break;
                  }
                }
                var buf = src.bufQueue[bufCursor % src.bufQueue.length];
                if (buf.length === 0) {
                  skipCount++;
                  if (skipCount === src.bufQueue.length) {
                    break;
                  }
                } else {
                  var audioSrc = src.context.audioCtx.createBufferSource();
                  audioSrc.buffer = buf.audioBuf;
                  audioSrc.playbackRate.value = src.playbackRate;
                  if (buf.audioBuf._loopStart || buf.audioBuf._loopEnd) {
                    audioSrc.loopStart = buf.audioBuf._loopStart;
                    audioSrc.loopEnd = buf.audioBuf._loopEnd;
                  }
                  var duration = 0;
                  if (src.type === 4136 && src.looping) {
                    duration = Number.POSITIVE_INFINITY;
                    audioSrc.loop = true;
                    if (buf.audioBuf._loopStart) {
                      audioSrc.loopStart = buf.audioBuf._loopStart;
                    }
                    if (buf.audioBuf._loopEnd) {
                      audioSrc.loopEnd = buf.audioBuf._loopEnd;
                    }
                  } else {
                    duration = (buf.audioBuf.duration - startOffset) / src.playbackRate;
                  }
                  audioSrc._startOffset = startOffset;
                  audioSrc._duration = duration;
                  audioSrc._skipCount = skipCount;
                  skipCount = 0;
                  audioSrc.connect(src.gain);
                  if (typeof audioSrc.start != "undefined") {
                    startTime = Math.max(startTime, src.context.audioCtx.currentTime);
                    audioSrc.start(startTime, startOffset);
                  } else if (typeof audioSrc.noteOn != "undefined") {
                    startTime = Math.max(startTime, src.context.audioCtx.currentTime);
                    audioSrc.noteOn(startTime);
                  }
                  audioSrc._startTime = startTime;
                  src.audioQueue.push(audioSrc);
                  startTime += duration;
                }
                startOffset = 0;
                bufCursor++;
              }
            },
            updateSourceTime: (src) => {
              var currentTime = src.context.audioCtx.currentTime;
              if (src.state !== 4114) {
                return currentTime;
              }
              if (!isFinite(src.bufStartTime)) {
                src.bufStartTime = currentTime - src.bufOffset / src.playbackRate;
                src.bufOffset = 0;
              }
              var nextStartTime = 0;
              while (src.audioQueue.length) {
                var audioSrc = src.audioQueue[0];
                src.bufsProcessed += audioSrc._skipCount;
                nextStartTime = audioSrc._startTime + audioSrc._duration;
                if (currentTime < nextStartTime) {
                  break;
                }
                src.audioQueue.shift();
                src.bufStartTime = nextStartTime;
                src.bufOffset = 0;
                src.bufsProcessed++;
              }
              if (src.bufsProcessed >= src.bufQueue.length && !src.looping) {
                AL.setSourceState(src, 4116);
              } else if (src.type === 4136 && src.looping) {
                var buf = src.bufQueue[0];
                if (buf.length === 0) {
                  src.bufOffset = 0;
                } else {
                  var delta = (currentTime - src.bufStartTime) * src.playbackRate;
                  var loopStart = buf.audioBuf._loopStart || 0;
                  var loopEnd = buf.audioBuf._loopEnd || buf.audioBuf.duration;
                  if (loopEnd <= loopStart) {
                    loopEnd = buf.audioBuf.duration;
                  }
                  if (delta < loopEnd) {
                    src.bufOffset = delta;
                  } else {
                    src.bufOffset = loopStart + (delta - loopStart) % (loopEnd - loopStart);
                  }
                }
              } else if (src.audioQueue[0]) {
                src.bufOffset = (currentTime - src.audioQueue[0]._startTime) * src.playbackRate;
              } else {
                if (src.type !== 4136 && src.looping) {
                  var srcDuration = AL.sourceDuration(src) / src.playbackRate;
                  if (srcDuration > 0) {
                    src.bufStartTime += Math.floor((currentTime - src.bufStartTime) / srcDuration) * srcDuration;
                  }
                }
                for (var i2 = 0; i2 < src.bufQueue.length; i2++) {
                  if (src.bufsProcessed >= src.bufQueue.length) {
                    if (src.looping) {
                      src.bufsProcessed %= src.bufQueue.length;
                    } else {
                      AL.setSourceState(src, 4116);
                      break;
                    }
                  }
                  var buf = src.bufQueue[src.bufsProcessed];
                  if (buf.length > 0) {
                    nextStartTime = src.bufStartTime + buf.audioBuf.duration / src.playbackRate;
                    if (currentTime < nextStartTime) {
                      src.bufOffset = (currentTime - src.bufStartTime) * src.playbackRate;
                      break;
                    }
                    src.bufStartTime = nextStartTime;
                  }
                  src.bufOffset = 0;
                  src.bufsProcessed++;
                }
              }
              return currentTime;
            },
            cancelPendingSourceAudio: (src) => {
              AL.updateSourceTime(src);
              for (var i2 = 1; i2 < src.audioQueue.length; i2++) {
                var audioSrc = src.audioQueue[i2];
                audioSrc.stop();
              }
              if (src.audioQueue.length > 1) {
                src.audioQueue.length = 1;
              }
            },
            stopSourceAudio: (src) => {
              for (var i2 = 0; i2 < src.audioQueue.length; i2++) {
                src.audioQueue[i2].stop();
              }
              src.audioQueue.length = 0;
            },
            setSourceState: (src, state) => {
              if (state === 4114) {
                if (src.state === 4114 || src.state == 4116) {
                  src.bufsProcessed = 0;
                  src.bufOffset = 0;
                } else {
                }
                AL.stopSourceAudio(src);
                src.state = 4114;
                src.bufStartTime = Number.NEGATIVE_INFINITY;
                AL.scheduleSourceAudio(src);
              } else if (state === 4115) {
                if (src.state === 4114) {
                  AL.updateSourceTime(src);
                  AL.stopSourceAudio(src);
                  src.state = 4115;
                }
              } else if (state === 4116) {
                if (src.state !== 4113) {
                  src.state = 4116;
                  src.bufsProcessed = src.bufQueue.length;
                  src.bufStartTime = Number.NEGATIVE_INFINITY;
                  src.bufOffset = 0;
                  AL.stopSourceAudio(src);
                }
              } else if (state === 4113) {
                if (src.state !== 4113) {
                  src.state = 4113;
                  src.bufsProcessed = 0;
                  src.bufStartTime = Number.NEGATIVE_INFINITY;
                  src.bufOffset = 0;
                  AL.stopSourceAudio(src);
                }
              }
            },
            initSourcePanner: (src) => {
              if (src.type === 4144) {
                return;
              }
              var templateBuf = AL.buffers[0];
              for (var i2 = 0; i2 < src.bufQueue.length; i2++) {
                if (src.bufQueue[i2].id !== 0) {
                  templateBuf = src.bufQueue[i2];
                  break;
                }
              }
              if (src.spatialize === 1 || src.spatialize === 2 && templateBuf.channels === 1) {
                if (src.panner) {
                  return;
                }
                src.panner = src.context.audioCtx.createPanner();
                AL.updateSourceGlobal(src);
                AL.updateSourceSpace(src);
                src.panner.connect(src.context.gain);
                src.gain.disconnect();
                src.gain.connect(src.panner);
              } else {
                if (!src.panner) {
                  return;
                }
                src.panner.disconnect();
                src.gain.disconnect();
                src.gain.connect(src.context.gain);
                src.panner = null;
              }
            },
            updateContextGlobal: (ctx) => {
              for (var i2 in ctx.sources) {
                AL.updateSourceGlobal(ctx.sources[i2]);
              }
            },
            updateSourceGlobal: (src) => {
              var panner = src.panner;
              if (!panner) {
                return;
              }
              panner.refDistance = src.refDistance;
              panner.maxDistance = src.maxDistance;
              panner.rolloffFactor = src.rolloffFactor;
              panner.panningModel = src.context.hrtf ? "HRTF" : "equalpower";
              var distanceModel = src.context.sourceDistanceModel ? src.distanceModel : src.context.distanceModel;
              switch (distanceModel) {
                case 0:
                  panner.distanceModel = "inverse";
                  panner.refDistance = 340282e33;
                  break;
                case 53249:
                case 53250:
                  panner.distanceModel = "inverse";
                  break;
                case 53251:
                case 53252:
                  panner.distanceModel = "linear";
                  break;
                case 53253:
                case 53254:
                  panner.distanceModel = "exponential";
                  break;
              }
            },
            updateListenerSpace: (ctx) => {
              var listener = ctx.audioCtx.listener;
              if (listener.positionX) {
                listener.positionX.value = ctx.listener.position[0];
                listener.positionY.value = ctx.listener.position[1];
                listener.positionZ.value = ctx.listener.position[2];
              } else {
                listener.setPosition(ctx.listener.position[0], ctx.listener.position[1], ctx.listener.position[2]);
              }
              if (listener.forwardX) {
                listener.forwardX.value = ctx.listener.direction[0];
                listener.forwardY.value = ctx.listener.direction[1];
                listener.forwardZ.value = ctx.listener.direction[2];
                listener.upX.value = ctx.listener.up[0];
                listener.upY.value = ctx.listener.up[1];
                listener.upZ.value = ctx.listener.up[2];
              } else {
                listener.setOrientation(ctx.listener.direction[0], ctx.listener.direction[1], ctx.listener.direction[2], ctx.listener.up[0], ctx.listener.up[1], ctx.listener.up[2]);
              }
              for (var i2 in ctx.sources) {
                AL.updateSourceSpace(ctx.sources[i2]);
              }
            },
            updateSourceSpace: (src) => {
              if (!src.panner) {
                return;
              }
              var panner = src.panner;
              var posX = src.position[0];
              var posY = src.position[1];
              var posZ = src.position[2];
              var dirX = src.direction[0];
              var dirY = src.direction[1];
              var dirZ = src.direction[2];
              var listener = src.context.listener;
              var lPosX = listener.position[0];
              var lPosY = listener.position[1];
              var lPosZ = listener.position[2];
              if (src.relative) {
                var lBackX = -listener.direction[0];
                var lBackY = -listener.direction[1];
                var lBackZ = -listener.direction[2];
                var lUpX = listener.up[0];
                var lUpY = listener.up[1];
                var lUpZ = listener.up[2];
                var inverseMagnitude = (x, y, z) => {
                  var length = Math.sqrt(x * x + y * y + z * z);
                  if (length < Number.EPSILON) {
                    return 0;
                  }
                  return 1 / length;
                };
                var invMag = inverseMagnitude(lBackX, lBackY, lBackZ);
                lBackX *= invMag;
                lBackY *= invMag;
                lBackZ *= invMag;
                invMag = inverseMagnitude(lUpX, lUpY, lUpZ);
                lUpX *= invMag;
                lUpY *= invMag;
                lUpZ *= invMag;
                var lRightX = lUpY * lBackZ - lUpZ * lBackY;
                var lRightY = lUpZ * lBackX - lUpX * lBackZ;
                var lRightZ = lUpX * lBackY - lUpY * lBackX;
                invMag = inverseMagnitude(lRightX, lRightY, lRightZ);
                lRightX *= invMag;
                lRightY *= invMag;
                lRightZ *= invMag;
                lUpX = lBackY * lRightZ - lBackZ * lRightY;
                lUpY = lBackZ * lRightX - lBackX * lRightZ;
                lUpZ = lBackX * lRightY - lBackY * lRightX;
                var oldX = dirX;
                var oldY = dirY;
                var oldZ = dirZ;
                dirX = oldX * lRightX + oldY * lUpX + oldZ * lBackX;
                dirY = oldX * lRightY + oldY * lUpY + oldZ * lBackY;
                dirZ = oldX * lRightZ + oldY * lUpZ + oldZ * lBackZ;
                oldX = posX;
                oldY = posY;
                oldZ = posZ;
                posX = oldX * lRightX + oldY * lUpX + oldZ * lBackX;
                posY = oldX * lRightY + oldY * lUpY + oldZ * lBackY;
                posZ = oldX * lRightZ + oldY * lUpZ + oldZ * lBackZ;
                posX += lPosX;
                posY += lPosY;
                posZ += lPosZ;
              }
              if (panner.positionX) {
                if (posX != panner.positionX.value)
                  panner.positionX.value = posX;
                if (posY != panner.positionY.value)
                  panner.positionY.value = posY;
                if (posZ != panner.positionZ.value)
                  panner.positionZ.value = posZ;
              } else {
                panner.setPosition(posX, posY, posZ);
              }
              if (panner.orientationX) {
                if (dirX != panner.orientationX.value)
                  panner.orientationX.value = dirX;
                if (dirY != panner.orientationY.value)
                  panner.orientationY.value = dirY;
                if (dirZ != panner.orientationZ.value)
                  panner.orientationZ.value = dirZ;
              } else {
                panner.setOrientation(dirX, dirY, dirZ);
              }
              var oldShift = src.dopplerShift;
              var velX = src.velocity[0];
              var velY = src.velocity[1];
              var velZ = src.velocity[2];
              var lVelX = listener.velocity[0];
              var lVelY = listener.velocity[1];
              var lVelZ = listener.velocity[2];
              if (posX === lPosX && posY === lPosY && posZ === lPosZ || velX === lVelX && velY === lVelY && velZ === lVelZ) {
                src.dopplerShift = 1;
              } else {
                var speedOfSound = src.context.speedOfSound;
                var dopplerFactor = src.context.dopplerFactor;
                var slX = lPosX - posX;
                var slY = lPosY - posY;
                var slZ = lPosZ - posZ;
                var magSl = Math.sqrt(slX * slX + slY * slY + slZ * slZ);
                var vls = (slX * lVelX + slY * lVelY + slZ * lVelZ) / magSl;
                var vss = (slX * velX + slY * velY + slZ * velZ) / magSl;
                vls = Math.min(vls, speedOfSound / dopplerFactor);
                vss = Math.min(vss, speedOfSound / dopplerFactor);
                src.dopplerShift = (speedOfSound - dopplerFactor * vls) / (speedOfSound - dopplerFactor * vss);
              }
              if (src.dopplerShift !== oldShift) {
                AL.updateSourceRate(src);
              }
            },
            updateSourceRate: (src) => {
              if (src.state === 4114) {
                AL.cancelPendingSourceAudio(src);
                var audioSrc = src.audioQueue[0];
                if (!audioSrc) {
                  return;
                }
                var duration;
                if (src.type === 4136 && src.looping) {
                  duration = Number.POSITIVE_INFINITY;
                } else {
                  duration = (audioSrc.buffer.duration - audioSrc._startOffset) / src.playbackRate;
                }
                audioSrc._duration = duration;
                audioSrc.playbackRate.value = src.playbackRate;
                AL.scheduleSourceAudio(src);
              }
            },
            sourceDuration: (src) => {
              var length = 0;
              for (var i2 = 0; i2 < src.bufQueue.length; i2++) {
                var audioBuf = src.bufQueue[i2].audioBuf;
                length += audioBuf ? audioBuf.duration : 0;
              }
              return length;
            },
            sourceTell: (src) => {
              AL.updateSourceTime(src);
              var offset = 0;
              for (var i2 = 0; i2 < src.bufsProcessed; i2++) {
                if (src.bufQueue[i2].audioBuf) {
                  offset += src.bufQueue[i2].audioBuf.duration;
                }
              }
              offset += src.bufOffset;
              return offset;
            },
            sourceSeek: (src, offset) => {
              var playing = src.state == 4114;
              if (playing) {
                AL.setSourceState(src, 4113);
              }
              if (src.bufQueue[src.bufsProcessed].audioBuf !== null) {
                src.bufsProcessed = 0;
                while (offset > src.bufQueue[src.bufsProcessed].audioBuf.duration) {
                  offset -= src.bufQueue[src.bufsProcessed].audiobuf.duration;
                  src.bufsProcessed++;
                }
                src.bufOffset = offset;
              }
              if (playing) {
                AL.setSourceState(src, 4114);
              }
            },
            getGlobalParam: (funcname, param) => {
              if (!AL.currentCtx) {
                return null;
              }
              switch (param) {
                case 49152:
                  return AL.currentCtx.dopplerFactor;
                case 49155:
                  return AL.currentCtx.speedOfSound;
                case 53248:
                  return AL.currentCtx.distanceModel;
                default:
                  AL.currentCtx.err = 40962;
                  return null;
              }
            },
            setGlobalParam: (funcname, param, value) => {
              if (!AL.currentCtx) {
                return;
              }
              switch (param) {
                case 49152:
                  if (!Number.isFinite(value) || value < 0) {
                    AL.currentCtx.err = 40963;
                    return;
                  }
                  AL.currentCtx.dopplerFactor = value;
                  AL.updateListenerSpace(AL.currentCtx);
                  break;
                case 49155:
                  if (!Number.isFinite(value) || value <= 0) {
                    AL.currentCtx.err = 40963;
                    return;
                  }
                  AL.currentCtx.speedOfSound = value;
                  AL.updateListenerSpace(AL.currentCtx);
                  break;
                case 53248:
                  switch (value) {
                    case 0:
                    case 53249:
                    case 53250:
                    case 53251:
                    case 53252:
                    case 53253:
                    case 53254:
                      AL.currentCtx.distanceModel = value;
                      AL.updateContextGlobal(AL.currentCtx);
                      break;
                    default:
                      AL.currentCtx.err = 40963;
                      return;
                  }
                  break;
                default:
                  AL.currentCtx.err = 40962;
                  return;
              }
            },
            getListenerParam: (funcname, param) => {
              if (!AL.currentCtx) {
                return null;
              }
              switch (param) {
                case 4100:
                  return AL.currentCtx.listener.position;
                case 4102:
                  return AL.currentCtx.listener.velocity;
                case 4111:
                  return AL.currentCtx.listener.direction.concat(AL.currentCtx.listener.up);
                case 4106:
                  return AL.currentCtx.gain.gain.value;
                default:
                  AL.currentCtx.err = 40962;
                  return null;
              }
            },
            setListenerParam: (funcname, param, value) => {
              if (!AL.currentCtx) {
                return;
              }
              if (value === null) {
                AL.currentCtx.err = 40962;
                return;
              }
              var listener = AL.currentCtx.listener;
              switch (param) {
                case 4100:
                  if (!Number.isFinite(value[0]) || !Number.isFinite(value[1]) || !Number.isFinite(value[2])) {
                    AL.currentCtx.err = 40963;
                    return;
                  }
                  listener.position[0] = value[0];
                  listener.position[1] = value[1];
                  listener.position[2] = value[2];
                  AL.updateListenerSpace(AL.currentCtx);
                  break;
                case 4102:
                  if (!Number.isFinite(value[0]) || !Number.isFinite(value[1]) || !Number.isFinite(value[2])) {
                    AL.currentCtx.err = 40963;
                    return;
                  }
                  listener.velocity[0] = value[0];
                  listener.velocity[1] = value[1];
                  listener.velocity[2] = value[2];
                  AL.updateListenerSpace(AL.currentCtx);
                  break;
                case 4106:
                  if (!Number.isFinite(value) || value < 0) {
                    AL.currentCtx.err = 40963;
                    return;
                  }
                  AL.currentCtx.gain.gain.value = value;
                  break;
                case 4111:
                  if (!Number.isFinite(value[0]) || !Number.isFinite(value[1]) || !Number.isFinite(value[2]) || !Number.isFinite(value[3]) || !Number.isFinite(value[4]) || !Number.isFinite(value[5])) {
                    AL.currentCtx.err = 40963;
                    return;
                  }
                  listener.direction[0] = value[0];
                  listener.direction[1] = value[1];
                  listener.direction[2] = value[2];
                  listener.up[0] = value[3];
                  listener.up[1] = value[4];
                  listener.up[2] = value[5];
                  AL.updateListenerSpace(AL.currentCtx);
                  break;
                default:
                  AL.currentCtx.err = 40962;
                  return;
              }
            },
            getBufferParam: (funcname, bufferId, param) => {
              if (!AL.currentCtx) {
                return;
              }
              var buf = AL.buffers[bufferId];
              if (!buf || bufferId === 0) {
                AL.currentCtx.err = 40961;
                return;
              }
              switch (param) {
                case 8193:
                  return buf.frequency;
                case 8194:
                  return buf.bytesPerSample * 8;
                case 8195:
                  return buf.channels;
                case 8196:
                  return buf.length * buf.bytesPerSample * buf.channels;
                case 8213:
                  if (buf.length === 0) {
                    return [0, 0];
                  }
                  return [(buf.audioBuf._loopStart || 0) * buf.frequency, (buf.audioBuf._loopEnd || buf.length) * buf.frequency];
                default:
                  AL.currentCtx.err = 40962;
                  return null;
              }
            },
            setBufferParam: (funcname, bufferId, param, value) => {
              if (!AL.currentCtx) {
                return;
              }
              var buf = AL.buffers[bufferId];
              if (!buf || bufferId === 0) {
                AL.currentCtx.err = 40961;
                return;
              }
              if (value === null) {
                AL.currentCtx.err = 40962;
                return;
              }
              switch (param) {
                case 8196:
                  if (value !== 0) {
                    AL.currentCtx.err = 40963;
                    return;
                  }
                  break;
                case 8213:
                  if (value[0] < 0 || value[0] > buf.length || value[1] < 0 || value[1] > buf.Length || value[0] >= value[1]) {
                    AL.currentCtx.err = 40963;
                    return;
                  }
                  if (buf.refCount > 0) {
                    AL.currentCtx.err = 40964;
                    return;
                  }
                  if (buf.audioBuf) {
                    buf.audioBuf._loopStart = value[0] / buf.frequency;
                    buf.audioBuf._loopEnd = value[1] / buf.frequency;
                  }
                  break;
                default:
                  AL.currentCtx.err = 40962;
                  return;
              }
            },
            getSourceParam: (funcname, sourceId, param) => {
              if (!AL.currentCtx) {
                return null;
              }
              var src = AL.currentCtx.sources[sourceId];
              if (!src) {
                AL.currentCtx.err = 40961;
                return null;
              }
              switch (param) {
                case 514:
                  return src.relative;
                case 4097:
                  return src.coneInnerAngle;
                case 4098:
                  return src.coneOuterAngle;
                case 4099:
                  return src.pitch;
                case 4100:
                  return src.position;
                case 4101:
                  return src.direction;
                case 4102:
                  return src.velocity;
                case 4103:
                  return src.looping;
                case 4105:
                  if (src.type === 4136) {
                    return src.bufQueue[0].id;
                  }
                  return 0;
                case 4106:
                  return src.gain.gain.value;
                case 4109:
                  return src.minGain;
                case 4110:
                  return src.maxGain;
                case 4112:
                  return src.state;
                case 4117:
                  if (src.bufQueue.length === 1 && src.bufQueue[0].id === 0) {
                    return 0;
                  }
                  return src.bufQueue.length;
                case 4118:
                  if (src.bufQueue.length === 1 && src.bufQueue[0].id === 0 || src.looping) {
                    return 0;
                  }
                  return src.bufsProcessed;
                case 4128:
                  return src.refDistance;
                case 4129:
                  return src.rolloffFactor;
                case 4130:
                  return src.coneOuterGain;
                case 4131:
                  return src.maxDistance;
                case 4132:
                  return AL.sourceTell(src);
                case 4133:
                  var offset = AL.sourceTell(src);
                  if (offset > 0) {
                    offset *= src.bufQueue[0].frequency;
                  }
                  return offset;
                case 4134:
                  var offset = AL.sourceTell(src);
                  if (offset > 0) {
                    offset *= src.bufQueue[0].frequency * src.bufQueue[0].bytesPerSample;
                  }
                  return offset;
                case 4135:
                  return src.type;
                case 4628:
                  return src.spatialize;
                case 8201:
                  var length = 0;
                  var bytesPerFrame = 0;
                  for (var i2 = 0; i2 < src.bufQueue.length; i2++) {
                    length += src.bufQueue[i2].length;
                    if (src.bufQueue[i2].id !== 0) {
                      bytesPerFrame = src.bufQueue[i2].bytesPerSample * src.bufQueue[i2].channels;
                    }
                  }
                  return length * bytesPerFrame;
                case 8202:
                  var length = 0;
                  for (var i2 = 0; i2 < src.bufQueue.length; i2++) {
                    length += src.bufQueue[i2].length;
                  }
                  return length;
                case 8203:
                  return AL.sourceDuration(src);
                case 53248:
                  return src.distanceModel;
                default:
                  AL.currentCtx.err = 40962;
                  return null;
              }
            },
            setSourceParam: (funcname, sourceId, param, value) => {
              if (!AL.currentCtx) {
                return;
              }
              var src = AL.currentCtx.sources[sourceId];
              if (!src) {
                AL.currentCtx.err = 40961;
                return;
              }
              if (value === null) {
                AL.currentCtx.err = 40962;
                return;
              }
              switch (param) {
                case 514:
                  if (value === 1) {
                    src.relative = true;
                    AL.updateSourceSpace(src);
                  } else if (value === 0) {
                    src.relative = false;
                    AL.updateSourceSpace(src);
                  } else {
                    AL.currentCtx.err = 40963;
                    return;
                  }
                  break;
                case 4097:
                  if (!Number.isFinite(value)) {
                    AL.currentCtx.err = 40963;
                    return;
                  }
                  src.coneInnerAngle = value;
                  if (src.panner) {
                    src.panner.coneInnerAngle = value % 360;
                  }
                  break;
                case 4098:
                  if (!Number.isFinite(value)) {
                    AL.currentCtx.err = 40963;
                    return;
                  }
                  src.coneOuterAngle = value;
                  if (src.panner) {
                    src.panner.coneOuterAngle = value % 360;
                  }
                  break;
                case 4099:
                  if (!Number.isFinite(value) || value <= 0) {
                    AL.currentCtx.err = 40963;
                    return;
                  }
                  if (src.pitch === value) {
                    break;
                  }
                  src.pitch = value;
                  AL.updateSourceRate(src);
                  break;
                case 4100:
                  if (!Number.isFinite(value[0]) || !Number.isFinite(value[1]) || !Number.isFinite(value[2])) {
                    AL.currentCtx.err = 40963;
                    return;
                  }
                  src.position[0] = value[0];
                  src.position[1] = value[1];
                  src.position[2] = value[2];
                  AL.updateSourceSpace(src);
                  break;
                case 4101:
                  if (!Number.isFinite(value[0]) || !Number.isFinite(value[1]) || !Number.isFinite(value[2])) {
                    AL.currentCtx.err = 40963;
                    return;
                  }
                  src.direction[0] = value[0];
                  src.direction[1] = value[1];
                  src.direction[2] = value[2];
                  AL.updateSourceSpace(src);
                  break;
                case 4102:
                  if (!Number.isFinite(value[0]) || !Number.isFinite(value[1]) || !Number.isFinite(value[2])) {
                    AL.currentCtx.err = 40963;
                    return;
                  }
                  src.velocity[0] = value[0];
                  src.velocity[1] = value[1];
                  src.velocity[2] = value[2];
                  AL.updateSourceSpace(src);
                  break;
                case 4103:
                  if (value === 1) {
                    src.looping = true;
                    AL.updateSourceTime(src);
                    if (src.type === 4136 && src.audioQueue.length > 0) {
                      var audioSrc = src.audioQueue[0];
                      audioSrc.loop = true;
                      audioSrc._duration = Number.POSITIVE_INFINITY;
                    }
                  } else if (value === 0) {
                    src.looping = false;
                    var currentTime = AL.updateSourceTime(src);
                    if (src.type === 4136 && src.audioQueue.length > 0) {
                      var audioSrc = src.audioQueue[0];
                      audioSrc.loop = false;
                      audioSrc._duration = src.bufQueue[0].audioBuf.duration / src.playbackRate;
                      audioSrc._startTime = currentTime - src.bufOffset / src.playbackRate;
                    }
                  } else {
                    AL.currentCtx.err = 40963;
                    return;
                  }
                  break;
                case 4105:
                  if (src.state === 4114 || src.state === 4115) {
                    AL.currentCtx.err = 40964;
                    return;
                  }
                  if (value === 0) {
                    for (var i2 in src.bufQueue) {
                      src.bufQueue[i2].refCount--;
                    }
                    src.bufQueue.length = 1;
                    src.bufQueue[0] = AL.buffers[0];
                    src.bufsProcessed = 0;
                    src.type = 4144;
                  } else {
                    var buf = AL.buffers[value];
                    if (!buf) {
                      AL.currentCtx.err = 40963;
                      return;
                    }
                    for (var i2 in src.bufQueue) {
                      src.bufQueue[i2].refCount--;
                    }
                    src.bufQueue.length = 0;
                    buf.refCount++;
                    src.bufQueue = [buf];
                    src.bufsProcessed = 0;
                    src.type = 4136;
                  }
                  AL.initSourcePanner(src);
                  AL.scheduleSourceAudio(src);
                  break;
                case 4106:
                  if (!Number.isFinite(value) || value < 0) {
                    AL.currentCtx.err = 40963;
                    return;
                  }
                  src.gain.gain.value = value;
                  break;
                case 4109:
                  if (!Number.isFinite(value) || value < 0 || value > Math.min(src.maxGain, 1)) {
                    AL.currentCtx.err = 40963;
                    return;
                  }
                  src.minGain = value;
                  break;
                case 4110:
                  if (!Number.isFinite(value) || value < Math.max(0, src.minGain) || value > 1) {
                    AL.currentCtx.err = 40963;
                    return;
                  }
                  src.maxGain = value;
                  break;
                case 4128:
                  if (!Number.isFinite(value) || value < 0) {
                    AL.currentCtx.err = 40963;
                    return;
                  }
                  src.refDistance = value;
                  if (src.panner) {
                    src.panner.refDistance = value;
                  }
                  break;
                case 4129:
                  if (!Number.isFinite(value) || value < 0) {
                    AL.currentCtx.err = 40963;
                    return;
                  }
                  src.rolloffFactor = value;
                  if (src.panner) {
                    src.panner.rolloffFactor = value;
                  }
                  break;
                case 4130:
                  if (!Number.isFinite(value) || value < 0 || value > 1) {
                    AL.currentCtx.err = 40963;
                    return;
                  }
                  src.coneOuterGain = value;
                  if (src.panner) {
                    src.panner.coneOuterGain = value;
                  }
                  break;
                case 4131:
                  if (!Number.isFinite(value) || value < 0) {
                    AL.currentCtx.err = 40963;
                    return;
                  }
                  src.maxDistance = value;
                  if (src.panner) {
                    src.panner.maxDistance = value;
                  }
                  break;
                case 4132:
                  if (value < 0 || value > AL.sourceDuration(src)) {
                    AL.currentCtx.err = 40963;
                    return;
                  }
                  AL.sourceSeek(src, value);
                  break;
                case 4133:
                  var srcLen = AL.sourceDuration(src);
                  if (srcLen > 0) {
                    var frequency;
                    for (var bufId in src.bufQueue) {
                      if (bufId) {
                        frequency = src.bufQueue[bufId].frequency;
                        break;
                      }
                    }
                    value /= frequency;
                  }
                  if (value < 0 || value > srcLen) {
                    AL.currentCtx.err = 40963;
                    return;
                  }
                  AL.sourceSeek(src, value);
                  break;
                case 4134:
                  var srcLen = AL.sourceDuration(src);
                  if (srcLen > 0) {
                    var bytesPerSec;
                    for (var bufId in src.bufQueue) {
                      if (bufId) {
                        var buf = src.bufQueue[bufId];
                        bytesPerSec = buf.frequency * buf.bytesPerSample * buf.channels;
                        break;
                      }
                    }
                    value /= bytesPerSec;
                  }
                  if (value < 0 || value > srcLen) {
                    AL.currentCtx.err = 40963;
                    return;
                  }
                  AL.sourceSeek(src, value);
                  break;
                case 4628:
                  if (value !== 0 && value !== 1 && value !== 2) {
                    AL.currentCtx.err = 40963;
                    return;
                  }
                  src.spatialize = value;
                  AL.initSourcePanner(src);
                  break;
                case 8201:
                case 8202:
                case 8203:
                  AL.currentCtx.err = 40964;
                  break;
                case 53248:
                  switch (value) {
                    case 0:
                    case 53249:
                    case 53250:
                    case 53251:
                    case 53252:
                    case 53253:
                    case 53254:
                      src.distanceModel = value;
                      if (AL.currentCtx.sourceDistanceModel) {
                        AL.updateContextGlobal(AL.currentCtx);
                      }
                      break;
                    default:
                      AL.currentCtx.err = 40963;
                      return;
                  }
                  break;
                default:
                  AL.currentCtx.err = 40962;
                  return;
              }
            },
            captures: {},
            sharedCaptureAudioCtx: null,
            requireValidCaptureDevice: (deviceId, funcname) => {
              if (deviceId === 0) {
                AL.alcErr = 40961;
                return null;
              }
              var c = AL.captures[deviceId];
              if (!c) {
                AL.alcErr = 40961;
                return null;
              }
              var err2 = c.mediaStreamError;
              if (err2) {
                AL.alcErr = 40961;
                return null;
              }
              return c;
            }
          };
          var _alBuffer3f = (bufferId, param, value0, value1, value2) => {
            AL.setBufferParam("alBuffer3f", bufferId, param, null);
          };
          _alBuffer3f.sig = "viifff";
          var _alBuffer3i = (bufferId, param, value0, value1, value2) => {
            AL.setBufferParam("alBuffer3i", bufferId, param, null);
          };
          _alBuffer3i.sig = "viiiii";
          function _alBufferData(bufferId, format, pData, size, freq) {
            pData >>>= 0;
            if (!AL.currentCtx) {
              return;
            }
            var buf = AL.buffers[bufferId];
            if (!buf) {
              AL.currentCtx.err = 40963;
              return;
            }
            if (freq <= 0) {
              AL.currentCtx.err = 40963;
              return;
            }
            var audioBuf = null;
            try {
              switch (format) {
                case 4352:
                  if (size > 0) {
                    audioBuf = AL.currentCtx.audioCtx.createBuffer(1, size, freq);
                    var channel0 = audioBuf.getChannelData(0);
                    for (var i2 = 0; i2 < size; ++i2) {
                      channel0[i2] = HEAPU8[pData++ >>> 0] * 78125e-7 - 1;
                    }
                  }
                  buf.bytesPerSample = 1;
                  buf.channels = 1;
                  buf.length = size;
                  break;
                case 4353:
                  if (size > 0) {
                    audioBuf = AL.currentCtx.audioCtx.createBuffer(1, size >> 1, freq);
                    var channel0 = audioBuf.getChannelData(0);
                    pData >>= 1;
                    for (var i2 = 0; i2 < size >> 1; ++i2) {
                      channel0[i2] = HEAP16[pData++ >>> 0] * 30517578125e-15;
                    }
                  }
                  buf.bytesPerSample = 2;
                  buf.channels = 1;
                  buf.length = size >> 1;
                  break;
                case 4354:
                  if (size > 0) {
                    audioBuf = AL.currentCtx.audioCtx.createBuffer(2, size >> 1, freq);
                    var channel0 = audioBuf.getChannelData(0);
                    var channel1 = audioBuf.getChannelData(1);
                    for (var i2 = 0; i2 < size >> 1; ++i2) {
                      channel0[i2] = HEAPU8[pData++ >>> 0] * 78125e-7 - 1;
                      channel1[i2] = HEAPU8[pData++ >>> 0] * 78125e-7 - 1;
                    }
                  }
                  buf.bytesPerSample = 1;
                  buf.channels = 2;
                  buf.length = size >> 1;
                  break;
                case 4355:
                  if (size > 0) {
                    audioBuf = AL.currentCtx.audioCtx.createBuffer(2, size >> 2, freq);
                    var channel0 = audioBuf.getChannelData(0);
                    var channel1 = audioBuf.getChannelData(1);
                    pData >>= 1;
                    for (var i2 = 0; i2 < size >> 2; ++i2) {
                      channel0[i2] = HEAP16[pData++ >>> 0] * 30517578125e-15;
                      channel1[i2] = HEAP16[pData++ >>> 0] * 30517578125e-15;
                    }
                  }
                  buf.bytesPerSample = 2;
                  buf.channels = 2;
                  buf.length = size >> 2;
                  break;
                case 65552:
                  if (size > 0) {
                    audioBuf = AL.currentCtx.audioCtx.createBuffer(1, size >> 2, freq);
                    var channel0 = audioBuf.getChannelData(0);
                    pData >>= 2;
                    for (var i2 = 0; i2 < size >> 2; ++i2) {
                      channel0[i2] = HEAPF32[pData++ >>> 0];
                    }
                  }
                  buf.bytesPerSample = 4;
                  buf.channels = 1;
                  buf.length = size >> 2;
                  break;
                case 65553:
                  if (size > 0) {
                    audioBuf = AL.currentCtx.audioCtx.createBuffer(2, size >> 3, freq);
                    var channel0 = audioBuf.getChannelData(0);
                    var channel1 = audioBuf.getChannelData(1);
                    pData >>= 2;
                    for (var i2 = 0; i2 < size >> 3; ++i2) {
                      channel0[i2] = HEAPF32[pData++ >>> 0];
                      channel1[i2] = HEAPF32[pData++ >>> 0];
                    }
                  }
                  buf.bytesPerSample = 4;
                  buf.channels = 2;
                  buf.length = size >> 3;
                  break;
                default:
                  AL.currentCtx.err = 40963;
                  return;
              }
              buf.frequency = freq;
              buf.audioBuf = audioBuf;
            } catch (e) {
              AL.currentCtx.err = 40963;
              return;
            }
          }
          _alBufferData.sig = "viipii";
          var _alBufferf = (bufferId, param, value) => {
            AL.setBufferParam("alBufferf", bufferId, param, null);
          };
          _alBufferf.sig = "viif";
          function _alBufferfv(bufferId, param, pValues) {
            pValues >>>= 0;
            if (!AL.currentCtx) {
              return;
            }
            if (!pValues) {
              AL.currentCtx.err = 40963;
              return;
            }
            AL.setBufferParam("alBufferfv", bufferId, param, null);
          }
          _alBufferfv.sig = "viip";
          var _alBufferi = (bufferId, param, value) => {
            AL.setBufferParam("alBufferi", bufferId, param, null);
          };
          _alBufferi.sig = "viii";
          function _alBufferiv(bufferId, param, pValues) {
            pValues >>>= 0;
            if (!AL.currentCtx) {
              return;
            }
            if (!pValues) {
              AL.currentCtx.err = 40963;
              return;
            }
            switch (param) {
              case 8213:
                AL.paramArray[0] = HEAP32[pValues >>> 2 >>> 0];
                AL.paramArray[1] = HEAP32[pValues + 4 >>> 2 >>> 0];
                AL.setBufferParam("alBufferiv", bufferId, param, AL.paramArray);
                break;
              default:
                AL.setBufferParam("alBufferiv", bufferId, param, null);
                break;
            }
          }
          _alBufferiv.sig = "viip";
          function _alDeleteBuffers(count, pBufferIds) {
            pBufferIds >>>= 0;
            if (!AL.currentCtx) {
              return;
            }
            for (var i2 = 0; i2 < count; ++i2) {
              var bufId = HEAP32[pBufferIds + i2 * 4 >>> 2 >>> 0];
              if (bufId === 0) {
                continue;
              }
              if (!AL.buffers[bufId]) {
                AL.currentCtx.err = 40961;
                return;
              }
              if (AL.buffers[bufId].refCount) {
                AL.currentCtx.err = 40964;
                return;
              }
            }
            for (var i2 = 0; i2 < count; ++i2) {
              var bufId = HEAP32[pBufferIds + i2 * 4 >>> 2 >>> 0];
              if (bufId === 0) {
                continue;
              }
              AL.deviceRefCounts[AL.buffers[bufId].deviceId]--;
              delete AL.buffers[bufId];
              AL.freeIds.push(bufId);
            }
          }
          _alDeleteBuffers.sig = "vip";
          var _alSourcei = (sourceId, param, value) => {
            switch (param) {
              case 514:
              case 4097:
              case 4098:
              case 4103:
              case 4105:
              case 4128:
              case 4129:
              case 4131:
              case 4132:
              case 4133:
              case 4134:
              case 4628:
              case 8201:
              case 8202:
              case 53248:
                AL.setSourceParam("alSourcei", sourceId, param, value);
                break;
              default:
                AL.setSourceParam("alSourcei", sourceId, param, null);
                break;
            }
          };
          _alSourcei.sig = "viii";
          function _alDeleteSources(count, pSourceIds) {
            pSourceIds >>>= 0;
            if (!AL.currentCtx) {
              return;
            }
            for (var i2 = 0; i2 < count; ++i2) {
              var srcId = HEAP32[pSourceIds + i2 * 4 >>> 2 >>> 0];
              if (!AL.currentCtx.sources[srcId]) {
                AL.currentCtx.err = 40961;
                return;
              }
            }
            for (var i2 = 0; i2 < count; ++i2) {
              var srcId = HEAP32[pSourceIds + i2 * 4 >>> 2 >>> 0];
              AL.setSourceState(AL.currentCtx.sources[srcId], 4116);
              _alSourcei(srcId, 4105, 0);
              delete AL.currentCtx.sources[srcId];
              AL.freeIds.push(srcId);
            }
          }
          _alDeleteSources.sig = "vip";
          var _alDisable = (param) => {
            if (!AL.currentCtx) {
              return;
            }
            switch (param) {
              case "AL_SOURCE_DISTANCE_MODEL":
                AL.currentCtx.sourceDistanceModel = false;
                AL.updateContextGlobal(AL.currentCtx);
                break;
              default:
                AL.currentCtx.err = 40962;
                return;
            }
          };
          _alDisable.sig = "vi";
          var _alDistanceModel = (model) => {
            AL.setGlobalParam("alDistanceModel", 53248, model);
          };
          _alDistanceModel.sig = "vi";
          var _alDopplerFactor = (value) => {
            AL.setGlobalParam("alDopplerFactor", 49152, value);
          };
          _alDopplerFactor.sig = "vf";
          var _alDopplerVelocity = (value) => {
            warnOnce("alDopplerVelocity() is deprecated, and only kept for compatibility with OpenAL 1.0. Use alSpeedOfSound() instead.");
            if (!AL.currentCtx) {
              return;
            }
            if (value <= 0) {
              AL.currentCtx.err = 40963;
              return;
            }
          };
          _alDopplerVelocity.sig = "vf";
          var _alEnable = (param) => {
            if (!AL.currentCtx) {
              return;
            }
            switch (param) {
              case "AL_SOURCE_DISTANCE_MODEL":
                AL.currentCtx.sourceDistanceModel = true;
                AL.updateContextGlobal(AL.currentCtx);
                break;
              default:
                AL.currentCtx.err = 40962;
                return;
            }
          };
          _alEnable.sig = "vi";
          function _alGenBuffers(count, pBufferIds) {
            pBufferIds >>>= 0;
            if (!AL.currentCtx) {
              return;
            }
            for (var i2 = 0; i2 < count; ++i2) {
              var buf = {
                deviceId: AL.currentCtx.deviceId,
                id: AL.newId(),
                refCount: 0,
                audioBuf: null,
                frequency: 0,
                bytesPerSample: 2,
                channels: 1,
                length: 0
              };
              AL.deviceRefCounts[buf.deviceId]++;
              AL.buffers[buf.id] = buf;
              HEAP32[pBufferIds + i2 * 4 >>> 2 >>> 0] = buf.id;
            }
          }
          _alGenBuffers.sig = "vip";
          function _alGenSources(count, pSourceIds) {
            pSourceIds >>>= 0;
            if (!AL.currentCtx) {
              return;
            }
            for (var i2 = 0; i2 < count; ++i2) {
              var gain = AL.currentCtx.audioCtx.createGain();
              gain.connect(AL.currentCtx.gain);
              var src = {
                context: AL.currentCtx,
                id: AL.newId(),
                type: 4144,
                state: 4113,
                bufQueue: [AL.buffers[0]],
                audioQueue: [],
                looping: false,
                pitch: 1,
                dopplerShift: 1,
                gain,
                minGain: 0,
                maxGain: 1,
                panner: null,
                bufsProcessed: 0,
                bufStartTime: Number.NEGATIVE_INFINITY,
                bufOffset: 0,
                relative: false,
                refDistance: 1,
                maxDistance: 340282e33,
                rolloffFactor: 1,
                position: [0, 0, 0],
                velocity: [0, 0, 0],
                direction: [0, 0, 0],
                coneOuterGain: 0,
                coneInnerAngle: 360,
                coneOuterAngle: 360,
                distanceModel: 53250,
                spatialize: 2,
                get playbackRate() {
                  return this.pitch * this.dopplerShift;
                }
              };
              AL.currentCtx.sources[src.id] = src;
              HEAP32[pSourceIds + i2 * 4 >>> 2 >>> 0] = src.id;
            }
          }
          _alGenSources.sig = "vip";
          var _alGetBoolean = (param) => {
            var val = AL.getGlobalParam("alGetBoolean", param);
            if (val === null) {
              return 0;
            }
            switch (param) {
              case 49152:
              case 49155:
              case 53248:
                return val !== 0 ? 1 : 0;
              default:
                AL.currentCtx.err = 40962;
                return 0;
            }
          };
          _alGetBoolean.sig = "ii";
          function _alGetBooleanv(param, pValues) {
            pValues >>>= 0;
            var val = AL.getGlobalParam("alGetBooleanv", param);
            if (val === null || !pValues) {
              return;
            }
            switch (param) {
              case 49152:
              case 49155:
              case 53248:
                HEAP8[pValues >>> 0 >>> 0] = val;
                break;
              default:
                AL.currentCtx.err = 40962;
                return;
            }
          }
          _alGetBooleanv.sig = "vip";
          function _alGetBuffer3f(bufferId, param, pValue0, pValue1, pValue2) {
            pValue0 >>>= 0;
            pValue1 >>>= 0;
            pValue2 >>>= 0;
            var val = AL.getBufferParam("alGetBuffer3f", bufferId, param);
            if (val === null) {
              return;
            }
            if (!pValue0 || !pValue1 || !pValue2) {
              AL.currentCtx.err = 40963;
              return;
            }
            AL.currentCtx.err = 40962;
          }
          _alGetBuffer3f.sig = "viippp";
          function _alGetBuffer3i(bufferId, param, pValue0, pValue1, pValue2) {
            pValue0 >>>= 0;
            pValue1 >>>= 0;
            pValue2 >>>= 0;
            var val = AL.getBufferParam("alGetBuffer3i", bufferId, param);
            if (val === null) {
              return;
            }
            if (!pValue0 || !pValue1 || !pValue2) {
              AL.currentCtx.err = 40963;
              return;
            }
            AL.currentCtx.err = 40962;
          }
          _alGetBuffer3i.sig = "viippp";
          function _alGetBufferf(bufferId, param, pValue) {
            pValue >>>= 0;
            var val = AL.getBufferParam("alGetBufferf", bufferId, param);
            if (val === null) {
              return;
            }
            if (!pValue) {
              AL.currentCtx.err = 40963;
              return;
            }
            AL.currentCtx.err = 40962;
          }
          _alGetBufferf.sig = "viip";
          function _alGetBufferfv(bufferId, param, pValues) {
            pValues >>>= 0;
            var val = AL.getBufferParam("alGetBufferfv", bufferId, param);
            if (val === null) {
              return;
            }
            if (!pValues) {
              AL.currentCtx.err = 40963;
              return;
            }
            AL.currentCtx.err = 40962;
          }
          _alGetBufferfv.sig = "viip";
          function _alGetBufferi(bufferId, param, pValue) {
            pValue >>>= 0;
            var val = AL.getBufferParam("alGetBufferi", bufferId, param);
            if (val === null) {
              return;
            }
            if (!pValue) {
              AL.currentCtx.err = 40963;
              return;
            }
            switch (param) {
              case 8193:
              case 8194:
              case 8195:
              case 8196:
                HEAP32[pValue >>> 2 >>> 0] = val;
                break;
              default:
                AL.currentCtx.err = 40962;
                return;
            }
          }
          _alGetBufferi.sig = "viip";
          function _alGetBufferiv(bufferId, param, pValues) {
            pValues >>>= 0;
            var val = AL.getBufferParam("alGetBufferiv", bufferId, param);
            if (val === null) {
              return;
            }
            if (!pValues) {
              AL.currentCtx.err = 40963;
              return;
            }
            switch (param) {
              case 8193:
              case 8194:
              case 8195:
              case 8196:
                HEAP32[pValues >>> 2 >>> 0] = val;
                break;
              case 8213:
                HEAP32[pValues >>> 2 >>> 0] = val[0];
                HEAP32[pValues + 4 >>> 2 >>> 0] = val[1];
                break;
              default:
                AL.currentCtx.err = 40962;
                return;
            }
          }
          _alGetBufferiv.sig = "viip";
          var _alGetDouble = (param) => {
            var val = AL.getGlobalParam("alGetDouble", param);
            if (val === null) {
              return 0;
            }
            switch (param) {
              case 49152:
              case 49155:
              case 53248:
                return val;
              default:
                AL.currentCtx.err = 40962;
                return 0;
            }
          };
          _alGetDouble.sig = "di";
          function _alGetDoublev(param, pValues) {
            pValues >>>= 0;
            var val = AL.getGlobalParam("alGetDoublev", param);
            if (val === null || !pValues) {
              return;
            }
            switch (param) {
              case 49152:
              case 49155:
              case 53248:
                HEAPF64[pValues >>> 3 >>> 0] = val;
                break;
              default:
                AL.currentCtx.err = 40962;
                return;
            }
          }
          _alGetDoublev.sig = "vip";
          function _alGetEnumValue(pEnumName) {
            pEnumName >>>= 0;
            if (!AL.currentCtx) {
              return 0;
            }
            if (!pEnumName) {
              AL.currentCtx.err = 40963;
              return 0;
            }
            var name2 = UTF8ToString(pEnumName);
            switch (name2) {
              case "AL_BITS":
                return 8194;
              case "AL_BUFFER":
                return 4105;
              case "AL_BUFFERS_PROCESSED":
                return 4118;
              case "AL_BUFFERS_QUEUED":
                return 4117;
              case "AL_BYTE_OFFSET":
                return 4134;
              case "AL_CHANNELS":
                return 8195;
              case "AL_CONE_INNER_ANGLE":
                return 4097;
              case "AL_CONE_OUTER_ANGLE":
                return 4098;
              case "AL_CONE_OUTER_GAIN":
                return 4130;
              case "AL_DIRECTION":
                return 4101;
              case "AL_DISTANCE_MODEL":
                return 53248;
              case "AL_DOPPLER_FACTOR":
                return 49152;
              case "AL_DOPPLER_VELOCITY":
                return 49153;
              case "AL_EXPONENT_DISTANCE":
                return 53253;
              case "AL_EXPONENT_DISTANCE_CLAMPED":
                return 53254;
              case "AL_EXTENSIONS":
                return 45060;
              case "AL_FORMAT_MONO16":
                return 4353;
              case "AL_FORMAT_MONO8":
                return 4352;
              case "AL_FORMAT_STEREO16":
                return 4355;
              case "AL_FORMAT_STEREO8":
                return 4354;
              case "AL_FREQUENCY":
                return 8193;
              case "AL_GAIN":
                return 4106;
              case "AL_INITIAL":
                return 4113;
              case "AL_INVALID":
                return -1;
              case "AL_ILLEGAL_ENUM":
              case "AL_INVALID_ENUM":
                return 40962;
              case "AL_INVALID_NAME":
                return 40961;
              case "AL_ILLEGAL_COMMAND":
              case "AL_INVALID_OPERATION":
                return 40964;
              case "AL_INVALID_VALUE":
                return 40963;
              case "AL_INVERSE_DISTANCE":
                return 53249;
              case "AL_INVERSE_DISTANCE_CLAMPED":
                return 53250;
              case "AL_LINEAR_DISTANCE":
                return 53251;
              case "AL_LINEAR_DISTANCE_CLAMPED":
                return 53252;
              case "AL_LOOPING":
                return 4103;
              case "AL_MAX_DISTANCE":
                return 4131;
              case "AL_MAX_GAIN":
                return 4110;
              case "AL_MIN_GAIN":
                return 4109;
              case "AL_NONE":
                return 0;
              case "AL_NO_ERROR":
                return 0;
              case "AL_ORIENTATION":
                return 4111;
              case "AL_OUT_OF_MEMORY":
                return 40965;
              case "AL_PAUSED":
                return 4115;
              case "AL_PENDING":
                return 8209;
              case "AL_PITCH":
                return 4099;
              case "AL_PLAYING":
                return 4114;
              case "AL_POSITION":
                return 4100;
              case "AL_PROCESSED":
                return 8210;
              case "AL_REFERENCE_DISTANCE":
                return 4128;
              case "AL_RENDERER":
                return 45059;
              case "AL_ROLLOFF_FACTOR":
                return 4129;
              case "AL_SAMPLE_OFFSET":
                return 4133;
              case "AL_SEC_OFFSET":
                return 4132;
              case "AL_SIZE":
                return 8196;
              case "AL_SOURCE_RELATIVE":
                return 514;
              case "AL_SOURCE_STATE":
                return 4112;
              case "AL_SOURCE_TYPE":
                return 4135;
              case "AL_SPEED_OF_SOUND":
                return 49155;
              case "AL_STATIC":
                return 4136;
              case "AL_STOPPED":
                return 4116;
              case "AL_STREAMING":
                return 4137;
              case "AL_UNDETERMINED":
                return 4144;
              case "AL_UNUSED":
                return 8208;
              case "AL_VELOCITY":
                return 4102;
              case "AL_VENDOR":
                return 45057;
              case "AL_VERSION":
                return 45058;
              case "AL_AUTO_SOFT":
                return 2;
              case "AL_SOURCE_DISTANCE_MODEL":
                return 512;
              case "AL_SOURCE_SPATIALIZE_SOFT":
                return 4628;
              case "AL_LOOP_POINTS_SOFT":
                return 8213;
              case "AL_BYTE_LENGTH_SOFT":
                return 8201;
              case "AL_SAMPLE_LENGTH_SOFT":
                return 8202;
              case "AL_SEC_LENGTH_SOFT":
                return 8203;
              case "AL_FORMAT_MONO_FLOAT32":
                return 65552;
              case "AL_FORMAT_STEREO_FLOAT32":
                return 65553;
              default:
                AL.currentCtx.err = 40963;
                return 0;
            }
          }
          _alGetEnumValue.sig = "ip";
          var _alGetError = () => {
            if (!AL.currentCtx) {
              return 40964;
            }
            var err2 = AL.currentCtx.err;
            AL.currentCtx.err = 0;
            return err2;
          };
          _alGetError.sig = "i";
          var _alGetFloat = (param) => {
            var val = AL.getGlobalParam("alGetFloat", param);
            if (val === null) {
              return 0;
            }
            switch (param) {
              case 49152:
              case 49155:
              case 53248:
                return val;
              default:
                return 0;
            }
          };
          _alGetFloat.sig = "fi";
          function _alGetFloatv(param, pValues) {
            pValues >>>= 0;
            var val = AL.getGlobalParam("alGetFloatv", param);
            if (val === null || !pValues) {
              return;
            }
            switch (param) {
              case 49152:
              case 49155:
              case 53248:
                HEAPF32[pValues >>> 2 >>> 0] = val;
                break;
              default:
                AL.currentCtx.err = 40962;
                return;
            }
          }
          _alGetFloatv.sig = "vip";
          var _alGetInteger = (param) => {
            var val = AL.getGlobalParam("alGetInteger", param);
            if (val === null) {
              return 0;
            }
            switch (param) {
              case 49152:
              case 49155:
              case 53248:
                return val;
              default:
                AL.currentCtx.err = 40962;
                return 0;
            }
          };
          _alGetInteger.sig = "ii";
          function _alGetIntegerv(param, pValues) {
            pValues >>>= 0;
            var val = AL.getGlobalParam("alGetIntegerv", param);
            if (val === null || !pValues) {
              return;
            }
            switch (param) {
              case 49152:
              case 49155:
              case 53248:
                HEAP32[pValues >>> 2 >>> 0] = val;
                break;
              default:
                AL.currentCtx.err = 40962;
                return;
            }
          }
          _alGetIntegerv.sig = "vip";
          function _alGetListener3f(param, pValue0, pValue1, pValue2) {
            pValue0 >>>= 0;
            pValue1 >>>= 0;
            pValue2 >>>= 0;
            var val = AL.getListenerParam("alGetListener3f", param);
            if (val === null) {
              return;
            }
            if (!pValue0 || !pValue1 || !pValue2) {
              AL.currentCtx.err = 40963;
              return;
            }
            switch (param) {
              case 4100:
              case 4102:
                HEAPF32[pValue0 >>> 2 >>> 0] = val[0];
                HEAPF32[pValue1 >>> 2 >>> 0] = val[1];
                HEAPF32[pValue2 >>> 2 >>> 0] = val[2];
                break;
              default:
                AL.currentCtx.err = 40962;
                return;
            }
          }
          _alGetListener3f.sig = "vippp";
          function _alGetListener3i(param, pValue0, pValue1, pValue2) {
            pValue0 >>>= 0;
            pValue1 >>>= 0;
            pValue2 >>>= 0;
            var val = AL.getListenerParam("alGetListener3i", param);
            if (val === null) {
              return;
            }
            if (!pValue0 || !pValue1 || !pValue2) {
              AL.currentCtx.err = 40963;
              return;
            }
            switch (param) {
              case 4100:
              case 4102:
                HEAP32[pValue0 >>> 2 >>> 0] = val[0];
                HEAP32[pValue1 >>> 2 >>> 0] = val[1];
                HEAP32[pValue2 >>> 2 >>> 0] = val[2];
                break;
              default:
                AL.currentCtx.err = 40962;
                return;
            }
          }
          _alGetListener3i.sig = "vippp";
          function _alGetListenerf(param, pValue) {
            pValue >>>= 0;
            var val = AL.getListenerParam("alGetListenerf", param);
            if (val === null) {
              return;
            }
            if (!pValue) {
              AL.currentCtx.err = 40963;
              return;
            }
            switch (param) {
              case 4106:
                HEAPF32[pValue >>> 2 >>> 0] = val;
                break;
              default:
                AL.currentCtx.err = 40962;
                return;
            }
          }
          _alGetListenerf.sig = "vip";
          function _alGetListenerfv(param, pValues) {
            pValues >>>= 0;
            var val = AL.getListenerParam("alGetListenerfv", param);
            if (val === null) {
              return;
            }
            if (!pValues) {
              AL.currentCtx.err = 40963;
              return;
            }
            switch (param) {
              case 4100:
              case 4102:
                HEAPF32[pValues >>> 2 >>> 0] = val[0];
                HEAPF32[pValues + 4 >>> 2 >>> 0] = val[1];
                HEAPF32[pValues + 8 >>> 2 >>> 0] = val[2];
                break;
              case 4111:
                HEAPF32[pValues >>> 2 >>> 0] = val[0];
                HEAPF32[pValues + 4 >>> 2 >>> 0] = val[1];
                HEAPF32[pValues + 8 >>> 2 >>> 0] = val[2];
                HEAPF32[pValues + 12 >>> 2 >>> 0] = val[3];
                HEAPF32[pValues + 16 >>> 2 >>> 0] = val[4];
                HEAPF32[pValues + 20 >>> 2 >>> 0] = val[5];
                break;
              default:
                AL.currentCtx.err = 40962;
                return;
            }
          }
          _alGetListenerfv.sig = "vip";
          function _alGetListeneri(param, pValue) {
            pValue >>>= 0;
            var val = AL.getListenerParam("alGetListeneri", param);
            if (val === null) {
              return;
            }
            if (!pValue) {
              AL.currentCtx.err = 40963;
              return;
            }
            AL.currentCtx.err = 40962;
          }
          _alGetListeneri.sig = "vip";
          function _alGetListeneriv(param, pValues) {
            pValues >>>= 0;
            var val = AL.getListenerParam("alGetListeneriv", param);
            if (val === null) {
              return;
            }
            if (!pValues) {
              AL.currentCtx.err = 40963;
              return;
            }
            switch (param) {
              case 4100:
              case 4102:
                HEAP32[pValues >>> 2 >>> 0] = val[0];
                HEAP32[pValues + 4 >>> 2 >>> 0] = val[1];
                HEAP32[pValues + 8 >>> 2 >>> 0] = val[2];
                break;
              case 4111:
                HEAP32[pValues >>> 2 >>> 0] = val[0];
                HEAP32[pValues + 4 >>> 2 >>> 0] = val[1];
                HEAP32[pValues + 8 >>> 2 >>> 0] = val[2];
                HEAP32[pValues + 12 >>> 2 >>> 0] = val[3];
                HEAP32[pValues + 16 >>> 2 >>> 0] = val[4];
                HEAP32[pValues + 20 >>> 2 >>> 0] = val[5];
                break;
              default:
                AL.currentCtx.err = 40962;
                return;
            }
          }
          _alGetListeneriv.sig = "vip";
          function _alGetSource3f(sourceId, param, pValue0, pValue1, pValue2) {
            pValue0 >>>= 0;
            pValue1 >>>= 0;
            pValue2 >>>= 0;
            var val = AL.getSourceParam("alGetSource3f", sourceId, param);
            if (val === null) {
              return;
            }
            if (!pValue0 || !pValue1 || !pValue2) {
              AL.currentCtx.err = 40963;
              return;
            }
            switch (param) {
              case 4100:
              case 4101:
              case 4102:
                HEAPF32[pValue0 >>> 2 >>> 0] = val[0];
                HEAPF32[pValue1 >>> 2 >>> 0] = val[1];
                HEAPF32[pValue2 >>> 2 >>> 0] = val[2];
                break;
              default:
                AL.currentCtx.err = 40962;
                return;
            }
          }
          _alGetSource3f.sig = "viippp";
          function _alGetSource3i(sourceId, param, pValue0, pValue1, pValue2) {
            pValue0 >>>= 0;
            pValue1 >>>= 0;
            pValue2 >>>= 0;
            var val = AL.getSourceParam("alGetSource3i", sourceId, param);
            if (val === null) {
              return;
            }
            if (!pValue0 || !pValue1 || !pValue2) {
              AL.currentCtx.err = 40963;
              return;
            }
            switch (param) {
              case 4100:
              case 4101:
              case 4102:
                HEAP32[pValue0 >>> 2 >>> 0] = val[0];
                HEAP32[pValue1 >>> 2 >>> 0] = val[1];
                HEAP32[pValue2 >>> 2 >>> 0] = val[2];
                break;
              default:
                AL.currentCtx.err = 40962;
                return;
            }
          }
          _alGetSource3i.sig = "viippp";
          function _alGetSourcef(sourceId, param, pValue) {
            pValue >>>= 0;
            var val = AL.getSourceParam("alGetSourcef", sourceId, param);
            if (val === null) {
              return;
            }
            if (!pValue) {
              AL.currentCtx.err = 40963;
              return;
            }
            switch (param) {
              case 4097:
              case 4098:
              case 4099:
              case 4106:
              case 4109:
              case 4110:
              case 4128:
              case 4129:
              case 4130:
              case 4131:
              case 4132:
              case 4133:
              case 4134:
              case 8203:
                HEAPF32[pValue >>> 2 >>> 0] = val;
                break;
              default:
                AL.currentCtx.err = 40962;
                return;
            }
          }
          _alGetSourcef.sig = "viip";
          function _alGetSourcefv(sourceId, param, pValues) {
            pValues >>>= 0;
            var val = AL.getSourceParam("alGetSourcefv", sourceId, param);
            if (val === null) {
              return;
            }
            if (!pValues) {
              AL.currentCtx.err = 40963;
              return;
            }
            switch (param) {
              case 4097:
              case 4098:
              case 4099:
              case 4106:
              case 4109:
              case 4110:
              case 4128:
              case 4129:
              case 4130:
              case 4131:
              case 4132:
              case 4133:
              case 4134:
              case 8203:
                HEAPF32[pValues >>> 2 >>> 0] = val[0];
                break;
              case 4100:
              case 4101:
              case 4102:
                HEAPF32[pValues >>> 2 >>> 0] = val[0];
                HEAPF32[pValues + 4 >>> 2 >>> 0] = val[1];
                HEAPF32[pValues + 8 >>> 2 >>> 0] = val[2];
                break;
              default:
                AL.currentCtx.err = 40962;
                return;
            }
          }
          _alGetSourcefv.sig = "viip";
          function _alGetSourcei(sourceId, param, pValue) {
            pValue >>>= 0;
            var val = AL.getSourceParam("alGetSourcei", sourceId, param);
            if (val === null) {
              return;
            }
            if (!pValue) {
              AL.currentCtx.err = 40963;
              return;
            }
            switch (param) {
              case 514:
              case 4097:
              case 4098:
              case 4103:
              case 4105:
              case 4112:
              case 4117:
              case 4118:
              case 4128:
              case 4129:
              case 4131:
              case 4132:
              case 4133:
              case 4134:
              case 4135:
              case 4628:
              case 8201:
              case 8202:
              case 53248:
                HEAP32[pValue >>> 2 >>> 0] = val;
                break;
              default:
                AL.currentCtx.err = 40962;
                return;
            }
          }
          _alGetSourcei.sig = "viip";
          function _alGetSourceiv(sourceId, param, pValues) {
            pValues >>>= 0;
            var val = AL.getSourceParam("alGetSourceiv", sourceId, param);
            if (val === null) {
              return;
            }
            if (!pValues) {
              AL.currentCtx.err = 40963;
              return;
            }
            switch (param) {
              case 514:
              case 4097:
              case 4098:
              case 4103:
              case 4105:
              case 4112:
              case 4117:
              case 4118:
              case 4128:
              case 4129:
              case 4131:
              case 4132:
              case 4133:
              case 4134:
              case 4135:
              case 4628:
              case 8201:
              case 8202:
              case 53248:
                HEAP32[pValues >>> 2 >>> 0] = val;
                break;
              case 4100:
              case 4101:
              case 4102:
                HEAP32[pValues >>> 2 >>> 0] = val[0];
                HEAP32[pValues + 4 >>> 2 >>> 0] = val[1];
                HEAP32[pValues + 8 >>> 2 >>> 0] = val[2];
                break;
              default:
                AL.currentCtx.err = 40962;
                return;
            }
          }
          _alGetSourceiv.sig = "viip";
          function _alGetString(param) {
            if (AL.stringCache[param]) {
              return AL.stringCache[param];
            }
            var ret;
            switch (param) {
              case 0:
                ret = "No Error";
                break;
              case 40961:
                ret = "Invalid Name";
                break;
              case 40962:
                ret = "Invalid Enum";
                break;
              case 40963:
                ret = "Invalid Value";
                break;
              case 40964:
                ret = "Invalid Operation";
                break;
              case 40965:
                ret = "Out of Memory";
                break;
              case 45057:
                ret = "Emscripten";
                break;
              case 45058:
                ret = "1.1";
                break;
              case 45059:
                ret = "WebAudio";
                break;
              case 45060:
                ret = "";
                for (var ext in AL.AL_EXTENSIONS) {
                  ret = ret.concat(ext);
                  ret = ret.concat(" ");
                }
                ret = ret.trim();
                break;
              default:
                if (AL.currentCtx) {
                  AL.currentCtx.err = 40962;
                } else {
                }
                return 0;
            }
            ret = stringToNewUTF8(ret);
            AL.stringCache[param] = ret;
            return ret;
          }
          _alGetString.sig = "pi";
          var _alIsBuffer = (bufferId) => {
            if (!AL.currentCtx) {
              return false;
            }
            if (bufferId > AL.buffers.length) {
              return false;
            }
            if (!AL.buffers[bufferId]) {
              return false;
            }
            return true;
          };
          _alIsBuffer.sig = "ii";
          var _alIsEnabled = (param) => {
            if (!AL.currentCtx) {
              return 0;
            }
            switch (param) {
              case "AL_SOURCE_DISTANCE_MODEL":
                return AL.currentCtx.sourceDistanceModel ? 0 : 1;
              default:
                AL.currentCtx.err = 40962;
                return 0;
            }
          };
          _alIsEnabled.sig = "ii";
          function _alIsExtensionPresent(pExtName) {
            pExtName >>>= 0;
            var name2 = UTF8ToString(pExtName);
            return AL.AL_EXTENSIONS[name2] ? 1 : 0;
          }
          _alIsExtensionPresent.sig = "ip";
          var _alIsSource = (sourceId) => {
            if (!AL.currentCtx) {
              return false;
            }
            if (!AL.currentCtx.sources[sourceId]) {
              return false;
            }
            return true;
          };
          _alIsSource.sig = "ii";
          var _alListener3f = (param, value0, value1, value2) => {
            switch (param) {
              case 4100:
              case 4102:
                AL.paramArray[0] = value0;
                AL.paramArray[1] = value1;
                AL.paramArray[2] = value2;
                AL.setListenerParam("alListener3f", param, AL.paramArray);
                break;
              default:
                AL.setListenerParam("alListener3f", param, null);
                break;
            }
          };
          _alListener3f.sig = "vifff";
          var _alListener3i = (param, value0, value1, value2) => {
            switch (param) {
              case 4100:
              case 4102:
                AL.paramArray[0] = value0;
                AL.paramArray[1] = value1;
                AL.paramArray[2] = value2;
                AL.setListenerParam("alListener3i", param, AL.paramArray);
                break;
              default:
                AL.setListenerParam("alListener3i", param, null);
                break;
            }
          };
          _alListener3i.sig = "viiii";
          var _alListenerf = (param, value) => {
            switch (param) {
              case 4106:
                AL.setListenerParam("alListenerf", param, value);
                break;
              default:
                AL.setListenerParam("alListenerf", param, null);
                break;
            }
          };
          _alListenerf.sig = "vif";
          function _alListenerfv(param, pValues) {
            pValues >>>= 0;
            if (!AL.currentCtx) {
              return;
            }
            if (!pValues) {
              AL.currentCtx.err = 40963;
              return;
            }
            switch (param) {
              case 4100:
              case 4102:
                AL.paramArray[0] = HEAPF32[pValues >>> 2 >>> 0];
                AL.paramArray[1] = HEAPF32[pValues + 4 >>> 2 >>> 0];
                AL.paramArray[2] = HEAPF32[pValues + 8 >>> 2 >>> 0];
                AL.setListenerParam("alListenerfv", param, AL.paramArray);
                break;
              case 4111:
                AL.paramArray[0] = HEAPF32[pValues >>> 2 >>> 0];
                AL.paramArray[1] = HEAPF32[pValues + 4 >>> 2 >>> 0];
                AL.paramArray[2] = HEAPF32[pValues + 8 >>> 2 >>> 0];
                AL.paramArray[3] = HEAPF32[pValues + 12 >>> 2 >>> 0];
                AL.paramArray[4] = HEAPF32[pValues + 16 >>> 2 >>> 0];
                AL.paramArray[5] = HEAPF32[pValues + 20 >>> 2 >>> 0];
                AL.setListenerParam("alListenerfv", param, AL.paramArray);
                break;
              default:
                AL.setListenerParam("alListenerfv", param, null);
                break;
            }
          }
          _alListenerfv.sig = "vip";
          var _alListeneri = (param, value) => {
            AL.setListenerParam("alListeneri", param, null);
          };
          _alListeneri.sig = "vii";
          function _alListeneriv(param, pValues) {
            pValues >>>= 0;
            if (!AL.currentCtx) {
              return;
            }
            if (!pValues) {
              AL.currentCtx.err = 40963;
              return;
            }
            switch (param) {
              case 4100:
              case 4102:
                AL.paramArray[0] = HEAP32[pValues >>> 2 >>> 0];
                AL.paramArray[1] = HEAP32[pValues + 4 >>> 2 >>> 0];
                AL.paramArray[2] = HEAP32[pValues + 8 >>> 2 >>> 0];
                AL.setListenerParam("alListeneriv", param, AL.paramArray);
                break;
              case 4111:
                AL.paramArray[0] = HEAP32[pValues >>> 2 >>> 0];
                AL.paramArray[1] = HEAP32[pValues + 4 >>> 2 >>> 0];
                AL.paramArray[2] = HEAP32[pValues + 8 >>> 2 >>> 0];
                AL.paramArray[3] = HEAP32[pValues + 12 >>> 2 >>> 0];
                AL.paramArray[4] = HEAP32[pValues + 16 >>> 2 >>> 0];
                AL.paramArray[5] = HEAP32[pValues + 20 >>> 2 >>> 0];
                AL.setListenerParam("alListeneriv", param, AL.paramArray);
                break;
              default:
                AL.setListenerParam("alListeneriv", param, null);
                break;
            }
          }
          _alListeneriv.sig = "vip";
          var _alSource3f = (sourceId, param, value0, value1, value2) => {
            switch (param) {
              case 4100:
              case 4101:
              case 4102:
                AL.paramArray[0] = value0;
                AL.paramArray[1] = value1;
                AL.paramArray[2] = value2;
                AL.setSourceParam("alSource3f", sourceId, param, AL.paramArray);
                break;
              default:
                AL.setSourceParam("alSource3f", sourceId, param, null);
                break;
            }
          };
          _alSource3f.sig = "viifff";
          var _alSource3i = (sourceId, param, value0, value1, value2) => {
            switch (param) {
              case 4100:
              case 4101:
              case 4102:
                AL.paramArray[0] = value0;
                AL.paramArray[1] = value1;
                AL.paramArray[2] = value2;
                AL.setSourceParam("alSource3i", sourceId, param, AL.paramArray);
                break;
              default:
                AL.setSourceParam("alSource3i", sourceId, param, null);
                break;
            }
          };
          _alSource3i.sig = "viiiii";
          var _alSourcePause = (sourceId) => {
            if (!AL.currentCtx) {
              return;
            }
            var src = AL.currentCtx.sources[sourceId];
            if (!src) {
              AL.currentCtx.err = 40961;
              return;
            }
            AL.setSourceState(src, 4115);
          };
          _alSourcePause.sig = "vi";
          function _alSourcePausev(count, pSourceIds) {
            pSourceIds >>>= 0;
            if (!AL.currentCtx) {
              return;
            }
            if (!pSourceIds) {
              AL.currentCtx.err = 40963;
            }
            for (var i2 = 0; i2 < count; ++i2) {
              if (!AL.currentCtx.sources[HEAP32[pSourceIds + i2 * 4 >>> 2 >>> 0]]) {
                AL.currentCtx.err = 40961;
                return;
              }
            }
            for (var i2 = 0; i2 < count; ++i2) {
              var srcId = HEAP32[pSourceIds + i2 * 4 >>> 2 >>> 0];
              AL.setSourceState(AL.currentCtx.sources[srcId], 4115);
            }
          }
          _alSourcePausev.sig = "vip";
          var _alSourcePlay = (sourceId) => {
            if (!AL.currentCtx) {
              return;
            }
            var src = AL.currentCtx.sources[sourceId];
            if (!src) {
              AL.currentCtx.err = 40961;
              return;
            }
            AL.setSourceState(src, 4114);
          };
          _alSourcePlay.sig = "vi";
          function _alSourcePlayv(count, pSourceIds) {
            pSourceIds >>>= 0;
            if (!AL.currentCtx) {
              return;
            }
            if (!pSourceIds) {
              AL.currentCtx.err = 40963;
            }
            for (var i2 = 0; i2 < count; ++i2) {
              if (!AL.currentCtx.sources[HEAP32[pSourceIds + i2 * 4 >>> 2 >>> 0]]) {
                AL.currentCtx.err = 40961;
                return;
              }
            }
            for (var i2 = 0; i2 < count; ++i2) {
              var srcId = HEAP32[pSourceIds + i2 * 4 >>> 2 >>> 0];
              AL.setSourceState(AL.currentCtx.sources[srcId], 4114);
            }
          }
          _alSourcePlayv.sig = "vip";
          function _alSourceQueueBuffers(sourceId, count, pBufferIds) {
            pBufferIds >>>= 0;
            if (!AL.currentCtx) {
              return;
            }
            var src = AL.currentCtx.sources[sourceId];
            if (!src) {
              AL.currentCtx.err = 40961;
              return;
            }
            if (src.type === 4136) {
              AL.currentCtx.err = 40964;
              return;
            }
            if (count === 0) {
              return;
            }
            var templateBuf = AL.buffers[0];
            for (var i2 = 0; i2 < src.bufQueue.length; i2++) {
              if (src.bufQueue[i2].id !== 0) {
                templateBuf = src.bufQueue[i2];
                break;
              }
            }
            for (var i2 = 0; i2 < count; ++i2) {
              var bufId = HEAP32[pBufferIds + i2 * 4 >>> 2 >>> 0];
              var buf = AL.buffers[bufId];
              if (!buf) {
                AL.currentCtx.err = 40961;
                return;
              }
              if (templateBuf.id !== 0 && (buf.frequency !== templateBuf.frequency || buf.bytesPerSample !== templateBuf.bytesPerSample || buf.channels !== templateBuf.channels)) {
                AL.currentCtx.err = 40964;
              }
            }
            if (src.bufQueue.length === 1 && src.bufQueue[0].id === 0) {
              src.bufQueue.length = 0;
            }
            src.type = 4137;
            for (var i2 = 0; i2 < count; ++i2) {
              var bufId = HEAP32[pBufferIds + i2 * 4 >>> 2 >>> 0];
              var buf = AL.buffers[bufId];
              buf.refCount++;
              src.bufQueue.push(buf);
            }
            if (src.looping) {
              AL.cancelPendingSourceAudio(src);
            }
            AL.initSourcePanner(src);
            AL.scheduleSourceAudio(src);
          }
          _alSourceQueueBuffers.sig = "viip";
          var _alSourceRewind = (sourceId) => {
            if (!AL.currentCtx) {
              return;
            }
            var src = AL.currentCtx.sources[sourceId];
            if (!src) {
              AL.currentCtx.err = 40961;
              return;
            }
            AL.setSourceState(src, 4116);
            AL.setSourceState(src, 4113);
          };
          _alSourceRewind.sig = "vi";
          function _alSourceRewindv(count, pSourceIds) {
            pSourceIds >>>= 0;
            if (!AL.currentCtx) {
              return;
            }
            if (!pSourceIds) {
              AL.currentCtx.err = 40963;
            }
            for (var i2 = 0; i2 < count; ++i2) {
              if (!AL.currentCtx.sources[HEAP32[pSourceIds + i2 * 4 >>> 2 >>> 0]]) {
                AL.currentCtx.err = 40961;
                return;
              }
            }
            for (var i2 = 0; i2 < count; ++i2) {
              var srcId = HEAP32[pSourceIds + i2 * 4 >>> 2 >>> 0];
              AL.setSourceState(AL.currentCtx.sources[srcId], 4113);
            }
          }
          _alSourceRewindv.sig = "vip";
          var _alSourceStop = (sourceId) => {
            if (!AL.currentCtx) {
              return;
            }
            var src = AL.currentCtx.sources[sourceId];
            if (!src) {
              AL.currentCtx.err = 40961;
              return;
            }
            AL.setSourceState(src, 4116);
          };
          _alSourceStop.sig = "vi";
          function _alSourceStopv(count, pSourceIds) {
            pSourceIds >>>= 0;
            if (!AL.currentCtx) {
              return;
            }
            if (!pSourceIds) {
              AL.currentCtx.err = 40963;
            }
            for (var i2 = 0; i2 < count; ++i2) {
              if (!AL.currentCtx.sources[HEAP32[pSourceIds + i2 * 4 >>> 2 >>> 0]]) {
                AL.currentCtx.err = 40961;
                return;
              }
            }
            for (var i2 = 0; i2 < count; ++i2) {
              var srcId = HEAP32[pSourceIds + i2 * 4 >>> 2 >>> 0];
              AL.setSourceState(AL.currentCtx.sources[srcId], 4116);
            }
          }
          _alSourceStopv.sig = "vip";
          function _alSourceUnqueueBuffers(sourceId, count, pBufferIds) {
            pBufferIds >>>= 0;
            if (!AL.currentCtx) {
              return;
            }
            var src = AL.currentCtx.sources[sourceId];
            if (!src) {
              AL.currentCtx.err = 40961;
              return;
            }
            if (count > (src.bufQueue.length === 1 && src.bufQueue[0].id === 0 ? 0 : src.bufsProcessed)) {
              AL.currentCtx.err = 40963;
              return;
            }
            if (count === 0) {
              return;
            }
            for (var i2 = 0; i2 < count; i2++) {
              var buf = src.bufQueue.shift();
              buf.refCount--;
              HEAP32[pBufferIds + i2 * 4 >>> 2 >>> 0] = buf.id;
              src.bufsProcessed--;
            }
            if (src.bufQueue.length === 0) {
              src.bufQueue.push(AL.buffers[0]);
            }
            AL.initSourcePanner(src);
            AL.scheduleSourceAudio(src);
          }
          _alSourceUnqueueBuffers.sig = "viip";
          var _alSourcef = (sourceId, param, value) => {
            switch (param) {
              case 4097:
              case 4098:
              case 4099:
              case 4106:
              case 4109:
              case 4110:
              case 4128:
              case 4129:
              case 4130:
              case 4131:
              case 4132:
              case 4133:
              case 4134:
              case 8203:
                AL.setSourceParam("alSourcef", sourceId, param, value);
                break;
              default:
                AL.setSourceParam("alSourcef", sourceId, param, null);
                break;
            }
          };
          _alSourcef.sig = "viif";
          function _alSourcefv(sourceId, param, pValues) {
            pValues >>>= 0;
            if (!AL.currentCtx) {
              return;
            }
            if (!pValues) {
              AL.currentCtx.err = 40963;
              return;
            }
            switch (param) {
              case 4097:
              case 4098:
              case 4099:
              case 4106:
              case 4109:
              case 4110:
              case 4128:
              case 4129:
              case 4130:
              case 4131:
              case 4132:
              case 4133:
              case 4134:
              case 8203:
                var val = HEAPF32[pValues >>> 2 >>> 0];
                AL.setSourceParam("alSourcefv", sourceId, param, val);
                break;
              case 4100:
              case 4101:
              case 4102:
                AL.paramArray[0] = HEAPF32[pValues >>> 2 >>> 0];
                AL.paramArray[1] = HEAPF32[pValues + 4 >>> 2 >>> 0];
                AL.paramArray[2] = HEAPF32[pValues + 8 >>> 2 >>> 0];
                AL.setSourceParam("alSourcefv", sourceId, param, AL.paramArray);
                break;
              default:
                AL.setSourceParam("alSourcefv", sourceId, param, null);
                break;
            }
          }
          _alSourcefv.sig = "viip";
          function _alSourceiv(sourceId, param, pValues) {
            pValues >>>= 0;
            if (!AL.currentCtx) {
              return;
            }
            if (!pValues) {
              AL.currentCtx.err = 40963;
              return;
            }
            switch (param) {
              case 514:
              case 4097:
              case 4098:
              case 4103:
              case 4105:
              case 4128:
              case 4129:
              case 4131:
              case 4132:
              case 4133:
              case 4134:
              case 4628:
              case 8201:
              case 8202:
              case 53248:
                var val = HEAP32[pValues >>> 2 >>> 0];
                AL.setSourceParam("alSourceiv", sourceId, param, val);
                break;
              case 4100:
              case 4101:
              case 4102:
                AL.paramArray[0] = HEAP32[pValues >>> 2 >>> 0];
                AL.paramArray[1] = HEAP32[pValues + 4 >>> 2 >>> 0];
                AL.paramArray[2] = HEAP32[pValues + 8 >>> 2 >>> 0];
                AL.setSourceParam("alSourceiv", sourceId, param, AL.paramArray);
                break;
              default:
                AL.setSourceParam("alSourceiv", sourceId, param, null);
                break;
            }
          }
          _alSourceiv.sig = "viip";
          var _alSpeedOfSound = (value) => {
            AL.setGlobalParam("alSpeedOfSound", 49155, value);
          };
          _alSpeedOfSound.sig = "vf";
          var _alcCaptureCloseDevice = function(deviceId) {
            deviceId >>>= 0;
            var c = AL.requireValidCaptureDevice(deviceId, "alcCaptureCloseDevice");
            if (!c)
              return false;
            delete AL.captures[deviceId];
            AL.freeIds.push(deviceId);
            c.mediaStreamSourceNode?.disconnect();
            c.mergerNode?.disconnect();
            c.splitterNode?.disconnect();
            c.scriptProcessorNode?.disconnect();
            if (c.mediaStream) {
              c.mediaStream.getTracks().forEach((track) => track.stop());
            }
            delete c.buffers;
            c.capturedFrameCount = 0;
            c.isCapturing = false;
            return true;
          };
          _alcCaptureCloseDevice.sig = "ip";
          var listenOnce = (object, event2, func2) => {
            object.addEventListener(event2, func2, {
              "once": true
            });
          };
          var autoResumeAudioContext = (ctx, elements) => {
            if (!elements) {
              elements = [document, document.getElementById("canvas")];
            }
            ["keydown", "mousedown", "touchstart"].forEach((event2) => {
              elements.forEach((element) => {
                if (element) {
                  listenOnce(element, event2, () => {
                    if (ctx.state === "suspended")
                      ctx.resume();
                  });
                }
              });
            });
          };
          function _alcCaptureOpenDevice(pDeviceName, requestedSampleRate, format, bufferFrameCapacity) {
            pDeviceName >>>= 0;
            var resolvedDeviceName = AL.CAPTURE_DEVICE_NAME;
            if (pDeviceName !== 0) {
              resolvedDeviceName = UTF8ToString(pDeviceName);
              if (resolvedDeviceName !== AL.CAPTURE_DEVICE_NAME) {
                AL.alcErr = 40965;
                return 0;
              }
            }
            if (bufferFrameCapacity < 0) {
              AL.alcErr = 40964;
              return 0;
            }
            navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;
            var has_getUserMedia = navigator.getUserMedia || navigator.mediaDevices && navigator.mediaDevices.getUserMedia;
            if (!has_getUserMedia) {
              AL.alcErr = 40965;
              return 0;
            }
            var AudioContext2 = window.AudioContext || window.webkitAudioContext;
            if (!AL.sharedCaptureAudioCtx) {
              try {
                AL.sharedCaptureAudioCtx = new AudioContext2();
              } catch (e) {
                AL.alcErr = 40965;
                return 0;
              }
            }
            autoResumeAudioContext(AL.sharedCaptureAudioCtx);
            var outputChannelCount;
            switch (format) {
              case 65552:
              case 4353:
              case 4352:
                outputChannelCount = 1;
                break;
              case 65553:
              case 4355:
              case 4354:
                outputChannelCount = 2;
                break;
              default:
                AL.alcErr = 40964;
                return 0;
            }
            function newF32Array(cap) {
              return new Float32Array(cap);
            }
            function newI16Array(cap) {
              return new Int16Array(cap);
            }
            function newU8Array(cap) {
              return new Uint8Array(cap);
            }
            var requestedSampleType;
            var newSampleArray;
            switch (format) {
              case 65552:
              case 65553:
                requestedSampleType = "f32";
                newSampleArray = newF32Array;
                break;
              case 4353:
              case 4355:
                requestedSampleType = "i16";
                newSampleArray = newI16Array;
                break;
              case 4352:
              case 4354:
                requestedSampleType = "u8";
                newSampleArray = newU8Array;
                break;
            }
            var buffers = [];
            try {
              for (var chan = 0; chan < outputChannelCount; ++chan) {
                buffers[chan] = newSampleArray(bufferFrameCapacity);
              }
            } catch (e) {
              AL.alcErr = 40965;
              return 0;
            }
            var newCapture = {
              audioCtx: AL.sharedCaptureAudioCtx,
              deviceName: resolvedDeviceName,
              requestedSampleRate,
              requestedSampleType,
              outputChannelCount,
              inputChannelCount: null,
              mediaStreamError: null,
              mediaStreamSourceNode: null,
              mediaStream: null,
              mergerNode: null,
              splitterNode: null,
              scriptProcessorNode: null,
              isCapturing: false,
              buffers,
              get bufferFrameCapacity() {
                return buffers[0].length;
              },
              capturePlayhead: 0,
              captureReadhead: 0,
              capturedFrameCount: 0
            };
            var onError = (mediaStreamError) => {
              newCapture.mediaStreamError = mediaStreamError;
            };
            var onSuccess = (mediaStream) => {
              newCapture.mediaStreamSourceNode = newCapture.audioCtx.createMediaStreamSource(mediaStream);
              newCapture.mediaStream = mediaStream;
              var inputChannelCount = 1;
              switch (newCapture.mediaStreamSourceNode.channelCountMode) {
                case "max":
                  inputChannelCount = outputChannelCount;
                  break;
                case "clamped-max":
                  inputChannelCount = Math.min(outputChannelCount, newCapture.mediaStreamSourceNode.channelCount);
                  break;
                case "explicit":
                  inputChannelCount = newCapture.mediaStreamSourceNode.channelCount;
                  break;
              }
              newCapture.inputChannelCount = inputChannelCount;
              var processorFrameCount = 512;
              newCapture.scriptProcessorNode = newCapture.audioCtx.createScriptProcessor(processorFrameCount, inputChannelCount, outputChannelCount);
              if (inputChannelCount > outputChannelCount) {
                newCapture.mergerNode = newCapture.audioCtx.createChannelMerger(inputChannelCount);
                newCapture.mediaStreamSourceNode.connect(newCapture.mergerNode);
                newCapture.mergerNode.connect(newCapture.scriptProcessorNode);
              } else if (inputChannelCount < outputChannelCount) {
                newCapture.splitterNode = newCapture.audioCtx.createChannelSplitter(outputChannelCount);
                newCapture.mediaStreamSourceNode.connect(newCapture.splitterNode);
                newCapture.splitterNode.connect(newCapture.scriptProcessorNode);
              } else {
                newCapture.mediaStreamSourceNode.connect(newCapture.scriptProcessorNode);
              }
              newCapture.scriptProcessorNode.connect(newCapture.audioCtx.destination);
              newCapture.scriptProcessorNode.onaudioprocess = (audioProcessingEvent) => {
                if (!newCapture.isCapturing) {
                  return;
                }
                var c = newCapture;
                var srcBuf = audioProcessingEvent.inputBuffer;
                switch (format) {
                  case 65552:
                    var channel0 = srcBuf.getChannelData(0);
                    for (var i2 = 0; i2 < srcBuf.length; ++i2) {
                      var wi = (c.capturePlayhead + i2) % c.bufferFrameCapacity;
                      c.buffers[0][wi] = channel0[i2];
                    }
                    break;
                  case 65553:
                    var channel0 = srcBuf.getChannelData(0);
                    var channel1 = srcBuf.getChannelData(1);
                    for (var i2 = 0; i2 < srcBuf.length; ++i2) {
                      var wi = (c.capturePlayhead + i2) % c.bufferFrameCapacity;
                      c.buffers[0][wi] = channel0[i2];
                      c.buffers[1][wi] = channel1[i2];
                    }
                    break;
                  case 4353:
                    var channel0 = srcBuf.getChannelData(0);
                    for (var i2 = 0; i2 < srcBuf.length; ++i2) {
                      var wi = (c.capturePlayhead + i2) % c.bufferFrameCapacity;
                      c.buffers[0][wi] = channel0[i2] * 32767;
                    }
                    break;
                  case 4355:
                    var channel0 = srcBuf.getChannelData(0);
                    var channel1 = srcBuf.getChannelData(1);
                    for (var i2 = 0; i2 < srcBuf.length; ++i2) {
                      var wi = (c.capturePlayhead + i2) % c.bufferFrameCapacity;
                      c.buffers[0][wi] = channel0[i2] * 32767;
                      c.buffers[1][wi] = channel1[i2] * 32767;
                    }
                    break;
                  case 4352:
                    var channel0 = srcBuf.getChannelData(0);
                    for (var i2 = 0; i2 < srcBuf.length; ++i2) {
                      var wi = (c.capturePlayhead + i2) % c.bufferFrameCapacity;
                      c.buffers[0][wi] = (channel0[i2] + 1) * 127;
                    }
                    break;
                  case 4354:
                    var channel0 = srcBuf.getChannelData(0);
                    var channel1 = srcBuf.getChannelData(1);
                    for (var i2 = 0; i2 < srcBuf.length; ++i2) {
                      var wi = (c.capturePlayhead + i2) % c.bufferFrameCapacity;
                      c.buffers[0][wi] = (channel0[i2] + 1) * 127;
                      c.buffers[1][wi] = (channel1[i2] + 1) * 127;
                    }
                    break;
                }
                c.capturePlayhead += srcBuf.length;
                c.capturePlayhead %= c.bufferFrameCapacity;
                c.capturedFrameCount += srcBuf.length;
                c.capturedFrameCount = Math.min(c.capturedFrameCount, c.bufferFrameCapacity);
              };
            };
            if (navigator.mediaDevices?.getUserMedia) {
              navigator.mediaDevices.getUserMedia({
                audio: true
              }).then(onSuccess).catch(onError);
            } else {
              navigator.getUserMedia({
                audio: true
              }, onSuccess, onError);
            }
            var id = AL.newId();
            AL.captures[id] = newCapture;
            return id;
          }
          _alcCaptureOpenDevice.sig = "ppiii";
          function _alcCaptureSamples(deviceId, pFrames, requestedFrameCount) {
            deviceId >>>= 0;
            pFrames >>>= 0;
            var c = AL.requireValidCaptureDevice(deviceId, "alcCaptureSamples");
            if (!c)
              return;
            var dstfreq = c.requestedSampleRate;
            var srcfreq = c.audioCtx.sampleRate;
            var fratio = srcfreq / dstfreq;
            if (requestedFrameCount < 0 || requestedFrameCount > c.capturedFrameCount / fratio) {
              AL.alcErr = 40964;
              return;
            }
            function setF32Sample(i3, sample) {
              HEAPF32[pFrames + 4 * i3 >>> 2 >>> 0] = sample;
            }
            function setI16Sample(i3, sample) {
              HEAP16[pFrames + 2 * i3 >>> 1 >>> 0] = sample;
            }
            function setU8Sample(i3, sample) {
              HEAP8[pFrames + i3 >>> 0 >>> 0] = sample;
            }
            var setSample;
            switch (c.requestedSampleType) {
              case "f32":
                setSample = setF32Sample;
                break;
              case "i16":
                setSample = setI16Sample;
                break;
              case "u8":
                setSample = setU8Sample;
                break;
              default:
                return;
            }
            if (Math.floor(fratio) == fratio) {
              for (var i2 = 0, frame_i = 0; frame_i < requestedFrameCount; ++frame_i) {
                for (var chan = 0; chan < c.buffers.length; ++chan, ++i2) {
                  setSample(i2, c.buffers[chan][c.captureReadhead]);
                }
                c.captureReadhead = (fratio + c.captureReadhead) % c.bufferFrameCapacity;
              }
            } else {
              for (var i2 = 0, frame_i = 0; frame_i < requestedFrameCount; ++frame_i) {
                var lefti = Math.floor(c.captureReadhead);
                var righti = Math.ceil(c.captureReadhead);
                var d = c.captureReadhead - lefti;
                for (var chan = 0; chan < c.buffers.length; ++chan, ++i2) {
                  var lefts = c.buffers[chan][lefti];
                  var rights = c.buffers[chan][righti];
                  setSample(i2, (1 - d) * lefts + d * rights);
                }
                c.captureReadhead = (c.captureReadhead + fratio) % c.bufferFrameCapacity;
              }
            }
            c.capturedFrameCount = 0;
          }
          _alcCaptureSamples.sig = "vppi";
          function _alcCaptureStart(deviceId) {
            deviceId >>>= 0;
            var c = AL.requireValidCaptureDevice(deviceId, "alcCaptureStart");
            if (!c)
              return;
            if (c.isCapturing) {
              return;
            }
            c.isCapturing = true;
            c.capturedFrameCount = 0;
            c.capturePlayhead = 0;
          }
          _alcCaptureStart.sig = "vp";
          function _alcCaptureStop(deviceId) {
            deviceId >>>= 0;
            var c = AL.requireValidCaptureDevice(deviceId, "alcCaptureStop");
            if (!c)
              return;
            c.isCapturing = false;
          }
          _alcCaptureStop.sig = "vp";
          function _alcCloseDevice(deviceId) {
            deviceId >>>= 0;
            if (!(deviceId in AL.deviceRefCounts) || AL.deviceRefCounts[deviceId] > 0) {
              return 0;
            }
            delete AL.deviceRefCounts[deviceId];
            AL.freeIds.push(deviceId);
            return 1;
          }
          _alcCloseDevice.sig = "ip";
          function _alcCreateContext(deviceId, pAttrList) {
            deviceId >>>= 0;
            pAttrList >>>= 0;
            if (!(deviceId in AL.deviceRefCounts)) {
              AL.alcErr = 40961;
              return 0;
            }
            var options = null;
            var attrs = [];
            var hrtf = null;
            pAttrList >>= 2;
            if (pAttrList) {
              var attr = 0;
              var val = 0;
              while (true) {
                attr = HEAP32[pAttrList++ >>> 0];
                attrs.push(attr);
                if (attr === 0) {
                  break;
                }
                val = HEAP32[pAttrList++ >>> 0];
                attrs.push(val);
                switch (attr) {
                  case 4103:
                    if (!options) {
                      options = {};
                    }
                    options.sampleRate = val;
                    break;
                  case 4112:
                  case 4113:
                    break;
                  case 6546:
                    switch (val) {
                      case 0:
                        hrtf = false;
                        break;
                      case 1:
                        hrtf = true;
                        break;
                      case 2:
                        break;
                      default:
                        AL.alcErr = 40964;
                        return 0;
                    }
                    break;
                  case 6550:
                    if (val !== 0) {
                      AL.alcErr = 40964;
                      return 0;
                    }
                    break;
                  default:
                    AL.alcErr = 40964;
                    return 0;
                }
              }
            }
            var AudioContext2 = window.AudioContext || window.webkitAudioContext;
            var ac = null;
            try {
              if (options) {
                ac = new AudioContext2(options);
              } else {
                ac = new AudioContext2();
              }
            } catch (e) {
              if (e.name === "NotSupportedError") {
                AL.alcErr = 40964;
              } else {
                AL.alcErr = 40961;
              }
              return 0;
            }
            autoResumeAudioContext(ac);
            if (typeof ac.createGain == "undefined") {
              ac.createGain = ac.createGainNode;
            }
            var gain = ac.createGain();
            gain.connect(ac.destination);
            var ctx = {
              deviceId,
              id: AL.newId(),
              attrs,
              audioCtx: ac,
              listener: {
                position: [0, 0, 0],
                velocity: [0, 0, 0],
                direction: [0, 0, 0],
                up: [0, 0, 0]
              },
              sources: [],
              interval: setInterval(() => AL.scheduleContextAudio(ctx), AL.QUEUE_INTERVAL),
              gain,
              distanceModel: 53250,
              speedOfSound: 343.3,
              dopplerFactor: 1,
              sourceDistanceModel: false,
              hrtf: hrtf || false,
              _err: 0,
              get err() {
                return this._err;
              },
              set err(val2) {
                if (this._err === 0 || val2 === 0) {
                  this._err = val2;
                }
              }
            };
            AL.deviceRefCounts[deviceId]++;
            AL.contexts[ctx.id] = ctx;
            if (hrtf !== null) {
              for (var ctxId in AL.contexts) {
                var c = AL.contexts[ctxId];
                if (c.deviceId === deviceId) {
                  c.hrtf = hrtf;
                  AL.updateContextGlobal(c);
                }
              }
            }
            return ctx.id;
          }
          _alcCreateContext.sig = "ppp";
          function _alcDestroyContext(contextId) {
            contextId >>>= 0;
            var ctx = AL.contexts[contextId];
            if (AL.currentCtx === ctx) {
              AL.alcErr = 40962;
              return;
            }
            if (AL.contexts[contextId].interval) {
              clearInterval(AL.contexts[contextId].interval);
            }
            AL.deviceRefCounts[ctx.deviceId]--;
            delete AL.contexts[contextId];
            AL.freeIds.push(contextId);
          }
          _alcDestroyContext.sig = "vp";
          function _alcGetContextsDevice(contextId) {
            contextId >>>= 0;
            if (contextId in AL.contexts) {
              return AL.contexts[contextId].deviceId;
            }
            return 0;
          }
          _alcGetContextsDevice.sig = "pp";
          function _alcGetCurrentContext() {
            if (AL.currentCtx !== null) {
              return AL.currentCtx.id;
            }
            return 0;
          }
          _alcGetCurrentContext.sig = "p";
          function _alcGetEnumValue(deviceId, pEnumName) {
            deviceId >>>= 0;
            pEnumName >>>= 0;
            if (deviceId !== 0 && !(deviceId in AL.deviceRefCounts)) {
              return 0;
            } else if (!pEnumName) {
              AL.alcErr = 40964;
              return 0;
            }
            var name2 = UTF8ToString(pEnumName);
            switch (name2) {
              case "ALC_NO_ERROR":
                return 0;
              case "ALC_INVALID_DEVICE":
                return 40961;
              case "ALC_INVALID_CONTEXT":
                return 40962;
              case "ALC_INVALID_ENUM":
                return 40963;
              case "ALC_INVALID_VALUE":
                return 40964;
              case "ALC_OUT_OF_MEMORY":
                return 40965;
              case "ALC_MAJOR_VERSION":
                return 4096;
              case "ALC_MINOR_VERSION":
                return 4097;
              case "ALC_ATTRIBUTES_SIZE":
                return 4098;
              case "ALC_ALL_ATTRIBUTES":
                return 4099;
              case "ALC_DEFAULT_DEVICE_SPECIFIER":
                return 4100;
              case "ALC_DEVICE_SPECIFIER":
                return 4101;
              case "ALC_EXTENSIONS":
                return 4102;
              case "ALC_FREQUENCY":
                return 4103;
              case "ALC_REFRESH":
                return 4104;
              case "ALC_SYNC":
                return 4105;
              case "ALC_MONO_SOURCES":
                return 4112;
              case "ALC_STEREO_SOURCES":
                return 4113;
              case "ALC_CAPTURE_DEVICE_SPECIFIER":
                return 784;
              case "ALC_CAPTURE_DEFAULT_DEVICE_SPECIFIER":
                return 785;
              case "ALC_CAPTURE_SAMPLES":
                return 786;
              case "ALC_HRTF_SOFT":
                return 6546;
              case "ALC_HRTF_ID_SOFT":
                return 6550;
              case "ALC_DONT_CARE_SOFT":
                return 2;
              case "ALC_HRTF_STATUS_SOFT":
                return 6547;
              case "ALC_NUM_HRTF_SPECIFIERS_SOFT":
                return 6548;
              case "ALC_HRTF_SPECIFIER_SOFT":
                return 6549;
              case "ALC_HRTF_DISABLED_SOFT":
                return 0;
              case "ALC_HRTF_ENABLED_SOFT":
                return 1;
              case "ALC_HRTF_DENIED_SOFT":
                return 2;
              case "ALC_HRTF_REQUIRED_SOFT":
                return 3;
              case "ALC_HRTF_HEADPHONES_DETECTED_SOFT":
                return 4;
              case "ALC_HRTF_UNSUPPORTED_FORMAT_SOFT":
                return 5;
              default:
                AL.alcErr = 40964;
                return 0;
            }
          }
          _alcGetEnumValue.sig = "ipp";
          function _alcGetError(deviceId) {
            deviceId >>>= 0;
            var err2 = AL.alcErr;
            AL.alcErr = 0;
            return err2;
          }
          _alcGetError.sig = "ip";
          function _alcGetIntegerv(deviceId, param, size, pValues) {
            deviceId >>>= 0;
            pValues >>>= 0;
            if (size === 0 || !pValues) {
              return;
            }
            switch (param) {
              case 4096:
                HEAP32[pValues >>> 2 >>> 0] = 1;
                break;
              case 4097:
                HEAP32[pValues >>> 2 >>> 0] = 1;
                break;
              case 4098:
                if (!(deviceId in AL.deviceRefCounts)) {
                  AL.alcErr = 40961;
                  return;
                }
                if (!AL.currentCtx) {
                  AL.alcErr = 40962;
                  return;
                }
                HEAP32[pValues >>> 2 >>> 0] = AL.currentCtx.attrs.length;
                break;
              case 4099:
                if (!(deviceId in AL.deviceRefCounts)) {
                  AL.alcErr = 40961;
                  return;
                }
                if (!AL.currentCtx) {
                  AL.alcErr = 40962;
                  return;
                }
                for (var i2 = 0; i2 < AL.currentCtx.attrs.length; i2++) {
                  HEAP32[pValues + i2 * 4 >>> 2 >>> 0] = AL.currentCtx.attrs[i2];
                }
                break;
              case 4103:
                if (!(deviceId in AL.deviceRefCounts)) {
                  AL.alcErr = 40961;
                  return;
                }
                if (!AL.currentCtx) {
                  AL.alcErr = 40962;
                  return;
                }
                HEAP32[pValues >>> 2 >>> 0] = AL.currentCtx.audioCtx.sampleRate;
                break;
              case 4112:
              case 4113:
                if (!(deviceId in AL.deviceRefCounts)) {
                  AL.alcErr = 40961;
                  return;
                }
                if (!AL.currentCtx) {
                  AL.alcErr = 40962;
                  return;
                }
                HEAP32[pValues >>> 2 >>> 0] = 2147483647;
                break;
              case 6546:
              case 6547:
                if (!(deviceId in AL.deviceRefCounts)) {
                  AL.alcErr = 40961;
                  return;
                }
                var hrtfStatus = 0;
                for (var ctxId in AL.contexts) {
                  var ctx = AL.contexts[ctxId];
                  if (ctx.deviceId === deviceId) {
                    hrtfStatus = ctx.hrtf ? 1 : 0;
                  }
                }
                HEAP32[pValues >>> 2 >>> 0] = hrtfStatus;
                break;
              case 6548:
                if (!(deviceId in AL.deviceRefCounts)) {
                  AL.alcErr = 40961;
                  return;
                }
                HEAP32[pValues >>> 2 >>> 0] = 1;
                break;
              case 131075:
                if (!(deviceId in AL.deviceRefCounts)) {
                  AL.alcErr = 40961;
                  return;
                }
                if (!AL.currentCtx) {
                  AL.alcErr = 40962;
                  return;
                }
                HEAP32[pValues >>> 2 >>> 0] = 1;
              case 786:
                var c = AL.requireValidCaptureDevice(deviceId, "alcGetIntegerv");
                if (!c) {
                  return;
                }
                var n = c.capturedFrameCount;
                var dstfreq = c.requestedSampleRate;
                var srcfreq = c.audioCtx.sampleRate;
                var nsamples = Math.floor(n * (dstfreq / srcfreq));
                HEAP32[pValues >>> 2 >>> 0] = nsamples;
                break;
              default:
                AL.alcErr = 40963;
                return;
            }
          }
          _alcGetIntegerv.sig = "vpiip";
          function _alcGetString(deviceId, param) {
            deviceId >>>= 0;
            if (AL.alcStringCache[param]) {
              return AL.alcStringCache[param];
            }
            var ret;
            switch (param) {
              case 0:
                ret = "No Error";
                break;
              case 40961:
                ret = "Invalid Device";
                break;
              case 40962:
                ret = "Invalid Context";
                break;
              case 40963:
                ret = "Invalid Enum";
                break;
              case 40964:
                ret = "Invalid Value";
                break;
              case 40965:
                ret = "Out of Memory";
                break;
              case 4100:
                if (typeof AudioContext != "undefined" || typeof webkitAudioContext != "undefined") {
                  ret = AL.DEVICE_NAME;
                } else {
                  return 0;
                }
                break;
              case 4101:
                if (typeof AudioContext != "undefined" || typeof webkitAudioContext != "undefined") {
                  ret = AL.DEVICE_NAME.concat("\0");
                } else {
                  ret = "\0";
                }
                break;
              case 785:
                ret = AL.CAPTURE_DEVICE_NAME;
                break;
              case 784:
                if (deviceId === 0)
                  ret = AL.CAPTURE_DEVICE_NAME.concat("\0");
                else {
                  var c = AL.requireValidCaptureDevice(deviceId, "alcGetString");
                  if (!c) {
                    return 0;
                  }
                  ret = c.deviceName;
                }
                break;
              case 4102:
                if (!deviceId) {
                  AL.alcErr = 40961;
                  return 0;
                }
                ret = "";
                for (var ext in AL.ALC_EXTENSIONS) {
                  ret = ret.concat(ext);
                  ret = ret.concat(" ");
                }
                ret = ret.trim();
                break;
              default:
                AL.alcErr = 40963;
                return 0;
            }
            ret = stringToNewUTF8(ret);
            AL.alcStringCache[param] = ret;
            return ret;
          }
          _alcGetString.sig = "ppi";
          function _alcIsExtensionPresent(deviceId, pExtName) {
            deviceId >>>= 0;
            pExtName >>>= 0;
            var name2 = UTF8ToString(pExtName);
            return AL.ALC_EXTENSIONS[name2] ? 1 : 0;
          }
          _alcIsExtensionPresent.sig = "ipp";
          function _alcMakeContextCurrent(contextId) {
            contextId >>>= 0;
            if (contextId === 0) {
              AL.currentCtx = null;
            } else {
              AL.currentCtx = AL.contexts[contextId];
            }
            return 1;
          }
          _alcMakeContextCurrent.sig = "ip";
          function _alcOpenDevice(pDeviceName) {
            pDeviceName >>>= 0;
            if (pDeviceName) {
              var name2 = UTF8ToString(pDeviceName);
              if (name2 !== AL.DEVICE_NAME) {
                return 0;
              }
            }
            if (typeof AudioContext != "undefined" || typeof webkitAudioContext != "undefined") {
              var deviceId = AL.newId();
              AL.deviceRefCounts[deviceId] = 0;
              return deviceId;
            }
            return 0;
          }
          _alcOpenDevice.sig = "pp";
          function _alcProcessContext(contextId) {
            contextId >>>= 0;
          }
          _alcProcessContext.sig = "vp";
          function _alcSuspendContext(contextId) {
            contextId >>>= 0;
          }
          _alcSuspendContext.sig = "vp";
          function _duckdb_web_fs_directory_create(path, pathLen) {
            path >>>= 0;
            return globalThis.DUCKDB_RUNTIME.createDirectory(Module, path, pathLen);
          }
          _duckdb_web_fs_directory_create.sig = "vpi";
          function _duckdb_web_fs_directory_exists(path, pathLen) {
            path >>>= 0;
            return globalThis.DUCKDB_RUNTIME.checkDirectory(Module, path, pathLen);
          }
          _duckdb_web_fs_directory_exists.sig = "ipi";
          function _duckdb_web_fs_directory_list_files(path, pathLen) {
            path >>>= 0;
            return globalThis.DUCKDB_RUNTIME.listDirectoryEntries(Module, path, pathLen);
          }
          _duckdb_web_fs_directory_list_files.sig = "ipi";
          function _duckdb_web_fs_directory_remove(path, pathLen) {
            path >>>= 0;
            return globalThis.DUCKDB_RUNTIME.removeDirectory(Module, path, pathLen);
          }
          _duckdb_web_fs_directory_remove.sig = "vpi";
          function _duckdb_web_fs_file_close(fileId) {
            return globalThis.DUCKDB_RUNTIME.closeFile(Module, fileId);
          }
          _duckdb_web_fs_file_close.sig = "vi";
          function _duckdb_web_fs_file_exists(path, pathLen) {
            path >>>= 0;
            return globalThis.DUCKDB_RUNTIME.checkFile(Module, path, pathLen);
          }
          _duckdb_web_fs_file_exists.sig = "ipi";
          function _duckdb_web_fs_file_get_last_modified_time(fileId) {
            return globalThis.DUCKDB_RUNTIME.getLastFileModificationTime(Module, fileId);
          }
          _duckdb_web_fs_file_get_last_modified_time.sig = "ii";
          function _duckdb_web_fs_file_move(from, fromLen, to, toLen) {
            from >>>= 0;
            to >>>= 0;
            return globalThis.DUCKDB_RUNTIME.moveFile(Module, from, fromLen, to, toLen);
          }
          _duckdb_web_fs_file_move.sig = "vpipi";
          function _duckdb_web_fs_file_open(fileId, flags2) {
            return globalThis.DUCKDB_RUNTIME.openFile(Module, fileId, flags2);
          }
          _duckdb_web_fs_file_open.sig = "pii";
          function _duckdb_web_fs_file_read(fileId, buf, size, location) {
            buf >>>= 0;
            return globalThis.DUCKDB_RUNTIME.readFile(Module, fileId, buf, size, location);
          }
          _duckdb_web_fs_file_read.sig = "iipid";
          function _duckdb_web_fs_file_truncate(fileId, newSize) {
            return globalThis.DUCKDB_RUNTIME.truncateFile(Module, fileId, newSize);
          }
          _duckdb_web_fs_file_truncate.sig = "vid";
          function _duckdb_web_fs_file_write(fileId, buf, size, location) {
            buf >>>= 0;
            return globalThis.DUCKDB_RUNTIME.writeFile(Module, fileId, buf, size, location);
          }
          _duckdb_web_fs_file_write.sig = "iipid";
          function _duckdb_web_fs_get_default_data_protocol(Module2) {
            return globalThis.DUCKDB_RUNTIME.getDefaultDataProtocol(Module2);
          }
          _duckdb_web_fs_get_default_data_protocol.sig = "i";
          function _duckdb_web_fs_glob(path, pathLen) {
            path >>>= 0;
            return globalThis.DUCKDB_RUNTIME.glob(Module, path, pathLen);
          }
          _duckdb_web_fs_glob.sig = "vpi";
          function _duckdb_web_test_platform_feature(feature) {
            return globalThis.DUCKDB_RUNTIME.testPlatformFeature(Module, feature);
          }
          _duckdb_web_test_platform_feature.sig = "ii";
          function _duckdb_web_udf_scalar_call(funcId, descPtr, descSize, ptrsPtr, ptrsSize, response) {
            funcId >>>= 0;
            descSize >>>= 0;
            ptrsSize >>>= 0;
            return globalThis.DUCKDB_RUNTIME.callScalarUDF(Module, funcId, descPtr, descSize, ptrsPtr, ptrsSize, response);
          }
          _duckdb_web_udf_scalar_call.sig = "vpipipi";
          var _emscripten_alcDevicePauseSOFT = (deviceId) => {
            if (!(deviceId in AL.deviceRefCounts)) {
              AL.alcErr = 40961;
              return;
            }
            if (AL.paused) {
              return;
            }
            AL.paused = true;
            for (var ctxId in AL.contexts) {
              var ctx = AL.contexts[ctxId];
              if (ctx.deviceId !== deviceId) {
                continue;
              }
              ctx.audioCtx.suspend();
              clearInterval(ctx.interval);
              ctx.interval = null;
            }
          };
          _emscripten_alcDevicePauseSOFT.sig = "vi";
          var _emscripten_alcDeviceResumeSOFT = (deviceId) => {
            if (!(deviceId in AL.deviceRefCounts)) {
              AL.alcErr = 40961;
              return;
            }
            if (!AL.paused) {
              return;
            }
            AL.paused = false;
            for (var ctxId in AL.contexts) {
              var ctx = AL.contexts[ctxId];
              if (ctx.deviceId !== deviceId) {
                continue;
              }
              ctx.interval = setInterval(() => AL.scheduleContextAudio(ctx), AL.QUEUE_INTERVAL);
              ctx.audioCtx.resume();
            }
          };
          _emscripten_alcDeviceResumeSOFT.sig = "vi";
          var _emscripten_alcGetStringiSOFT = (deviceId, param, index) => {
            if (!(deviceId in AL.deviceRefCounts)) {
              AL.alcErr = 40961;
              return 0;
            }
            if (AL.alcStringCache[param]) {
              return AL.alcStringCache[param];
            }
            var ret;
            switch (param) {
              case 6549:
                if (index === 0) {
                  ret = "Web Audio HRTF";
                } else {
                  AL.alcErr = 40964;
                  return 0;
                }
                break;
              default:
                if (index !== 0) {
                  AL.alcErr = 40963;
                  return 0;
                }
                return _alcGetString(deviceId, param);
            }
            ret = stringToNewUTF8(ret);
            AL.alcStringCache[param] = ret;
            return ret;
          };
          _emscripten_alcGetStringiSOFT.sig = "iiii";
          var _emscripten_alcResetDeviceSOFT = (deviceId, pAttrList) => {
            if (!(deviceId in AL.deviceRefCounts)) {
              AL.alcErr = 40961;
              return 0;
            }
            var hrtf = null;
            pAttrList >>= 2;
            if (pAttrList) {
              var attr = 0;
              var val = 0;
              while (true) {
                attr = HEAP32[pAttrList++ >>> 0];
                if (attr === 0) {
                  break;
                }
                val = HEAP32[pAttrList++ >>> 0];
                switch (attr) {
                  case 6546:
                    if (val === 1) {
                      hrtf = true;
                    } else if (val === 0) {
                      hrtf = false;
                    }
                    break;
                }
              }
            }
            if (hrtf !== null) {
              for (var ctxId in AL.contexts) {
                var ctx = AL.contexts[ctxId];
                if (ctx.deviceId === deviceId) {
                  ctx.hrtf = hrtf;
                  AL.updateContextGlobal(ctx);
                }
              }
            }
            return 1;
          };
          _emscripten_alcResetDeviceSOFT.sig = "iii";
          var readEmAsmArgsArray = [];
          var readEmAsmArgs = (sigPtr, buf) => {
            readEmAsmArgsArray.length = 0;
            var ch;
            while (ch = HEAPU8[sigPtr++ >>> 0]) {
              var wide = ch != 105;
              wide &= ch != 112;
              buf += wide && buf % 8 ? 4 : 0;
              readEmAsmArgsArray.push(ch == 112 ? HEAPU32[buf >>> 2 >>> 0] : ch == 105 ? HEAP32[buf >>> 2 >>> 0] : HEAPF64[buf >>> 3 >>> 0]);
              buf += wide ? 8 : 4;
            }
            return readEmAsmArgsArray;
          };
          var runEmAsmFunction = (code, sigPtr, argbuf) => {
            var args2 = readEmAsmArgs(sigPtr, argbuf);
            return ASM_CONSTS[code].apply(null, args2);
          };
          function _emscripten_asm_const_int(code, sigPtr, argbuf) {
            code >>>= 0;
            sigPtr >>>= 0;
            argbuf >>>= 0;
            return runEmAsmFunction(code, sigPtr, argbuf);
          }
          _emscripten_asm_const_int.sig = "ippp";
          function _emscripten_asm_const_ptr(code, sigPtr, argbuf) {
            code >>>= 0;
            sigPtr >>>= 0;
            argbuf >>>= 0;
            return runEmAsmFunction(code, sigPtr, argbuf);
          }
          _emscripten_asm_const_ptr.sig = "pppp";
          function _emscripten_console_error(str) {
            str >>>= 0;
            console.error(UTF8ToString(str));
          }
          _emscripten_console_error.sig = "vp";
          function _emscripten_console_log(str) {
            str >>>= 0;
            console.log(UTF8ToString(str));
          }
          _emscripten_console_log.sig = "vp";
          function _emscripten_console_warn(str) {
            str >>>= 0;
            console.warn(UTF8ToString(str));
          }
          _emscripten_console_warn.sig = "vp";
          var _emscripten_date_now = () => Date.now();
          _emscripten_date_now.sig = "d";
          function _emscripten_err(str) {
            str >>>= 0;
            return err(UTF8ToString(str));
          }
          _emscripten_err.sig = "vp";
          var getHeapMax = () => 4294901760;
          function _emscripten_get_heap_max() {
            return getHeapMax();
          }
          _emscripten_get_heap_max.sig = "p";
          var _emscripten_get_now_res = () => {
            if (ENVIRONMENT_IS_NODE) {
              return 1;
            }
            return 1e3;
          };
          _emscripten_get_now_res.sig = "d";
          var webgl_enable_ANGLE_instanced_arrays = (ctx) => {
            var ext = ctx.getExtension("ANGLE_instanced_arrays");
            if (ext) {
              ctx["vertexAttribDivisor"] = (index, divisor) => ext["vertexAttribDivisorANGLE"](index, divisor);
              ctx["drawArraysInstanced"] = (mode, first, count, primcount) => ext["drawArraysInstancedANGLE"](mode, first, count, primcount);
              ctx["drawElementsInstanced"] = (mode, count, type, indices, primcount) => ext["drawElementsInstancedANGLE"](mode, count, type, indices, primcount);
              return 1;
            }
          };
          var webgl_enable_OES_vertex_array_object = (ctx) => {
            var ext = ctx.getExtension("OES_vertex_array_object");
            if (ext) {
              ctx["createVertexArray"] = () => ext["createVertexArrayOES"]();
              ctx["deleteVertexArray"] = (vao) => ext["deleteVertexArrayOES"](vao);
              ctx["bindVertexArray"] = (vao) => ext["bindVertexArrayOES"](vao);
              ctx["isVertexArray"] = (vao) => ext["isVertexArrayOES"](vao);
              return 1;
            }
          };
          var webgl_enable_WEBGL_draw_buffers = (ctx) => {
            var ext = ctx.getExtension("WEBGL_draw_buffers");
            if (ext) {
              ctx["drawBuffers"] = (n, bufs) => ext["drawBuffersWEBGL"](n, bufs);
              return 1;
            }
          };
          var webgl_enable_WEBGL_multi_draw = (ctx) => !!(ctx.multiDrawWebgl = ctx.getExtension("WEBGL_multi_draw"));
          var getEmscriptenSupportedExtensions = function(ctx) {
            var supportedExtensions = ["ANGLE_instanced_arrays", "EXT_blend_minmax", "EXT_disjoint_timer_query", "EXT_frag_depth", "EXT_shader_texture_lod", "EXT_sRGB", "OES_element_index_uint", "OES_fbo_render_mipmap", "OES_standard_derivatives", "OES_texture_float", "OES_texture_half_float", "OES_texture_half_float_linear", "OES_vertex_array_object", "WEBGL_color_buffer_float", "WEBGL_depth_texture", "WEBGL_draw_buffers", "EXT_color_buffer_half_float", "EXT_float_blend", "EXT_texture_compression_bptc", "EXT_texture_compression_rgtc", "EXT_texture_filter_anisotropic", "KHR_parallel_shader_compile", "OES_texture_float_linear", "WEBGL_compressed_texture_s3tc", "WEBGL_compressed_texture_s3tc_srgb", "WEBGL_debug_renderer_info", "WEBGL_debug_shaders", "WEBGL_lose_context", "WEBGL_multi_draw"];
            return (ctx.getSupportedExtensions() || []).filter((ext) => supportedExtensions.includes(ext));
          };
          var GL = {
            counter: 1,
            buffers: [],
            programs: [],
            framebuffers: [],
            renderbuffers: [],
            textures: [],
            shaders: [],
            vaos: [],
            contexts: [],
            offscreenCanvases: {},
            queries: [],
            stringCache: {},
            unpackAlignment: 4,
            recordError: function recordError(errorCode) {
              if (!GL.lastError) {
                GL.lastError = errorCode;
              }
            },
            getNewId: (table) => {
              var ret = GL.counter++;
              for (var i2 = table.length; i2 < ret; i2++) {
                table[i2] = null;
              }
              return ret;
            },
            getSource: (shader, count, string, length) => {
              var source = "";
              for (var i2 = 0; i2 < count; ++i2) {
                var len2 = length ? HEAP32[length + i2 * 4 >>> 2 >>> 0] : -1;
                source += UTF8ToString(HEAP32[string + i2 * 4 >>> 2 >>> 0], len2 < 0 ? void 0 : len2);
              }
              return source;
            },
            createContext: (canvas, webGLContextAttributes) => {
              if (!canvas.getContextSafariWebGL2Fixed) {
                let fixedGetContext2 = function(ver, attrs) {
                  var gl = canvas.getContextSafariWebGL2Fixed(ver, attrs);
                  return ver == "webgl" == gl instanceof WebGLRenderingContext ? gl : null;
                };
                var fixedGetContext = fixedGetContext2;
                canvas.getContextSafariWebGL2Fixed = canvas.getContext;
                canvas.getContext = fixedGetContext2;
              }
              var ctx = canvas.getContext("webgl", webGLContextAttributes);
              if (!ctx)
                return 0;
              var handle2 = GL.registerContext(ctx, webGLContextAttributes);
              return handle2;
            },
            registerContext: (ctx, webGLContextAttributes) => {
              var handle2 = GL.getNewId(GL.contexts);
              var context = {
                handle: handle2,
                attributes: webGLContextAttributes,
                version: webGLContextAttributes.majorVersion,
                GLctx: ctx
              };
              if (ctx.canvas)
                ctx.canvas.GLctxObject = context;
              GL.contexts[handle2] = context;
              if (typeof webGLContextAttributes.enableExtensionsByDefault == "undefined" || webGLContextAttributes.enableExtensionsByDefault) {
                GL.initExtensions(context);
              }
              return handle2;
            },
            makeContextCurrent: (contextHandle) => {
              GL.currentContext = GL.contexts[contextHandle];
              Module.ctx = GLctx = GL.currentContext?.GLctx;
              return !(contextHandle && !GLctx);
            },
            getContext: (contextHandle) => GL.contexts[contextHandle],
            deleteContext: (contextHandle) => {
              if (GL.currentContext === GL.contexts[contextHandle]) {
                GL.currentContext = null;
              }
              if (typeof JSEvents == "object") {
                JSEvents.removeAllHandlersOnTarget(GL.contexts[contextHandle].GLctx.canvas);
              }
              if (GL.contexts[contextHandle] && GL.contexts[contextHandle].GLctx.canvas) {
                GL.contexts[contextHandle].GLctx.canvas.GLctxObject = void 0;
              }
              GL.contexts[contextHandle] = null;
            },
            initExtensions: (context) => {
              context || (context = GL.currentContext);
              if (context.initExtensionsDone)
                return;
              context.initExtensionsDone = true;
              var GLctx2 = context.GLctx;
              webgl_enable_ANGLE_instanced_arrays(GLctx2);
              webgl_enable_OES_vertex_array_object(GLctx2);
              webgl_enable_WEBGL_draw_buffers(GLctx2);
              {
                GLctx2.disjointTimerQueryExt = GLctx2.getExtension("EXT_disjoint_timer_query");
              }
              webgl_enable_WEBGL_multi_draw(GLctx2);
              getEmscriptenSupportedExtensions(GLctx2).forEach((ext) => {
                if (!ext.includes("lose_context") && !ext.includes("debug")) {
                  GLctx2.getExtension(ext);
                }
              });
            }
          };
          function _glActiveTexture(x0) {
            GLctx.activeTexture(x0);
          }
          _glActiveTexture.sig = "vi";
          var _emscripten_glActiveTexture = _glActiveTexture;
          var _glAttachShader = (program, shader) => {
            GLctx.attachShader(GL.programs[program], GL.shaders[shader]);
          };
          _glAttachShader.sig = "vii";
          var _emscripten_glAttachShader = _glAttachShader;
          var _glBeginQueryEXT = (target, id) => {
            GLctx.disjointTimerQueryExt["beginQueryEXT"](target, GL.queries[id]);
          };
          _glBeginQueryEXT.sig = "vii";
          var _emscripten_glBeginQueryEXT = _glBeginQueryEXT;
          function _glBindAttribLocation(program, index, name2) {
            name2 >>>= 0;
            GLctx.bindAttribLocation(GL.programs[program], index, UTF8ToString(name2));
          }
          _glBindAttribLocation.sig = "viip";
          var _emscripten_glBindAttribLocation = _glBindAttribLocation;
          var _glBindBuffer = (target, buffer) => {
            GLctx.bindBuffer(target, GL.buffers[buffer]);
          };
          _glBindBuffer.sig = "vii";
          var _emscripten_glBindBuffer = _glBindBuffer;
          var _glBindFramebuffer = (target, framebuffer) => {
            GLctx.bindFramebuffer(target, GL.framebuffers[framebuffer]);
          };
          _glBindFramebuffer.sig = "vii";
          var _emscripten_glBindFramebuffer = _glBindFramebuffer;
          var _glBindRenderbuffer = (target, renderbuffer) => {
            GLctx.bindRenderbuffer(target, GL.renderbuffers[renderbuffer]);
          };
          _glBindRenderbuffer.sig = "vii";
          var _emscripten_glBindRenderbuffer = _glBindRenderbuffer;
          var _glBindTexture = (target, texture) => {
            GLctx.bindTexture(target, GL.textures[texture]);
          };
          _glBindTexture.sig = "vii";
          var _emscripten_glBindTexture = _glBindTexture;
          var _glBindVertexArray = (vao) => {
            GLctx.bindVertexArray(GL.vaos[vao]);
          };
          _glBindVertexArray.sig = "vi";
          var _glBindVertexArrayOES = _glBindVertexArray;
          _glBindVertexArrayOES.sig = "vi";
          var _emscripten_glBindVertexArrayOES = _glBindVertexArrayOES;
          function _glBlendColor(x0, x1, x2, x3) {
            GLctx.blendColor(x0, x1, x2, x3);
          }
          _glBlendColor.sig = "vffff";
          var _emscripten_glBlendColor = _glBlendColor;
          function _glBlendEquation(x0) {
            GLctx.blendEquation(x0);
          }
          _glBlendEquation.sig = "vi";
          var _emscripten_glBlendEquation = _glBlendEquation;
          function _glBlendEquationSeparate(x0, x1) {
            GLctx.blendEquationSeparate(x0, x1);
          }
          _glBlendEquationSeparate.sig = "vii";
          var _emscripten_glBlendEquationSeparate = _glBlendEquationSeparate;
          function _glBlendFunc(x0, x1) {
            GLctx.blendFunc(x0, x1);
          }
          _glBlendFunc.sig = "vii";
          var _emscripten_glBlendFunc = _glBlendFunc;
          function _glBlendFuncSeparate(x0, x1, x2, x3) {
            GLctx.blendFuncSeparate(x0, x1, x2, x3);
          }
          _glBlendFuncSeparate.sig = "viiii";
          var _emscripten_glBlendFuncSeparate = _glBlendFuncSeparate;
          function _glBufferData(target, size, data2, usage) {
            size >>>= 0;
            data2 >>>= 0;
            GLctx.bufferData(target, data2 ? HEAPU8.subarray(data2 >>> 0, data2 + size >>> 0) : size, usage);
          }
          _glBufferData.sig = "vippi";
          var _emscripten_glBufferData = _glBufferData;
          function _glBufferSubData(target, offset, size, data2) {
            offset >>>= 0;
            size >>>= 0;
            data2 >>>= 0;
            GLctx.bufferSubData(target, offset, HEAPU8.subarray(data2 >>> 0, data2 + size >>> 0));
          }
          _glBufferSubData.sig = "vippp";
          var _emscripten_glBufferSubData = _glBufferSubData;
          function _glCheckFramebufferStatus(x0) {
            return GLctx.checkFramebufferStatus(x0);
          }
          _glCheckFramebufferStatus.sig = "ii";
          var _emscripten_glCheckFramebufferStatus = _glCheckFramebufferStatus;
          function _glClear(x0) {
            GLctx.clear(x0);
          }
          _glClear.sig = "vi";
          var _emscripten_glClear = _glClear;
          function _glClearColor(x0, x1, x2, x3) {
            GLctx.clearColor(x0, x1, x2, x3);
          }
          _glClearColor.sig = "vffff";
          var _emscripten_glClearColor = _glClearColor;
          function _glClearDepthf(x0) {
            GLctx.clearDepth(x0);
          }
          _glClearDepthf.sig = "vf";
          var _emscripten_glClearDepthf = _glClearDepthf;
          function _glClearStencil(x0) {
            GLctx.clearStencil(x0);
          }
          _glClearStencil.sig = "vi";
          var _emscripten_glClearStencil = _glClearStencil;
          var _glColorMask = (red, green, blue, alpha) => {
            GLctx.colorMask(!!red, !!green, !!blue, !!alpha);
          };
          _glColorMask.sig = "viiii";
          var _emscripten_glColorMask = _glColorMask;
          var _glCompileShader = (shader) => {
            GLctx.compileShader(GL.shaders[shader]);
          };
          _glCompileShader.sig = "vi";
          var _emscripten_glCompileShader = _glCompileShader;
          function _glCompressedTexImage2D(target, level, internalFormat, width, height, border, imageSize, data2) {
            data2 >>>= 0;
            GLctx.compressedTexImage2D(target, level, internalFormat, width, height, border, data2 ? HEAPU8.subarray(data2 >>> 0, data2 + imageSize >>> 0) : null);
          }
          _glCompressedTexImage2D.sig = "viiiiiiip";
          var _emscripten_glCompressedTexImage2D = _glCompressedTexImage2D;
          function _glCompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data2) {
            data2 >>>= 0;
            GLctx.compressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, data2 ? HEAPU8.subarray(data2 >>> 0, data2 + imageSize >>> 0) : null);
          }
          _glCompressedTexSubImage2D.sig = "viiiiiiiip";
          var _emscripten_glCompressedTexSubImage2D = _glCompressedTexSubImage2D;
          function _glCopyTexImage2D(x0, x1, x2, x3, x4, x5, x6, x7) {
            GLctx.copyTexImage2D(x0, x1, x2, x3, x4, x5, x6, x7);
          }
          _glCopyTexImage2D.sig = "viiiiiiii";
          var _emscripten_glCopyTexImage2D = _glCopyTexImage2D;
          function _glCopyTexSubImage2D(x0, x1, x2, x3, x4, x5, x6, x7) {
            GLctx.copyTexSubImage2D(x0, x1, x2, x3, x4, x5, x6, x7);
          }
          _glCopyTexSubImage2D.sig = "viiiiiiii";
          var _emscripten_glCopyTexSubImage2D = _glCopyTexSubImage2D;
          var _glCreateProgram = () => {
            var id = GL.getNewId(GL.programs);
            var program = GLctx.createProgram();
            program.name = id;
            program.maxUniformLength = program.maxAttributeLength = program.maxUniformBlockNameLength = 0;
            program.uniformIdCounter = 1;
            GL.programs[id] = program;
            return id;
          };
          _glCreateProgram.sig = "i";
          var _emscripten_glCreateProgram = _glCreateProgram;
          var _glCreateShader = (shaderType) => {
            var id = GL.getNewId(GL.shaders);
            GL.shaders[id] = GLctx.createShader(shaderType);
            return id;
          };
          _glCreateShader.sig = "ii";
          var _emscripten_glCreateShader = _glCreateShader;
          function _glCullFace(x0) {
            GLctx.cullFace(x0);
          }
          _glCullFace.sig = "vi";
          var _emscripten_glCullFace = _glCullFace;
          function _glDeleteBuffers(n, buffers) {
            buffers >>>= 0;
            for (var i2 = 0; i2 < n; i2++) {
              var id = HEAP32[buffers + i2 * 4 >>> 2 >>> 0];
              var buffer = GL.buffers[id];
              if (!buffer)
                continue;
              GLctx.deleteBuffer(buffer);
              buffer.name = 0;
              GL.buffers[id] = null;
            }
          }
          _glDeleteBuffers.sig = "vip";
          var _emscripten_glDeleteBuffers = _glDeleteBuffers;
          function _glDeleteFramebuffers(n, framebuffers) {
            framebuffers >>>= 0;
            for (var i2 = 0; i2 < n; ++i2) {
              var id = HEAP32[framebuffers + i2 * 4 >>> 2 >>> 0];
              var framebuffer = GL.framebuffers[id];
              if (!framebuffer)
                continue;
              GLctx.deleteFramebuffer(framebuffer);
              framebuffer.name = 0;
              GL.framebuffers[id] = null;
            }
          }
          _glDeleteFramebuffers.sig = "vip";
          var _emscripten_glDeleteFramebuffers = _glDeleteFramebuffers;
          var _glDeleteProgram = (id) => {
            if (!id)
              return;
            var program = GL.programs[id];
            if (!program) {
              GL.recordError(1281);
              return;
            }
            GLctx.deleteProgram(program);
            program.name = 0;
            GL.programs[id] = null;
          };
          _glDeleteProgram.sig = "vi";
          var _emscripten_glDeleteProgram = _glDeleteProgram;
          function _glDeleteQueriesEXT(n, ids) {
            ids >>>= 0;
            for (var i2 = 0; i2 < n; i2++) {
              var id = HEAP32[ids + i2 * 4 >>> 2 >>> 0];
              var query = GL.queries[id];
              if (!query)
                continue;
              GLctx.disjointTimerQueryExt["deleteQueryEXT"](query);
              GL.queries[id] = null;
            }
          }
          _glDeleteQueriesEXT.sig = "vip";
          var _emscripten_glDeleteQueriesEXT = _glDeleteQueriesEXT;
          function _glDeleteRenderbuffers(n, renderbuffers) {
            renderbuffers >>>= 0;
            for (var i2 = 0; i2 < n; i2++) {
              var id = HEAP32[renderbuffers + i2 * 4 >>> 2 >>> 0];
              var renderbuffer = GL.renderbuffers[id];
              if (!renderbuffer)
                continue;
              GLctx.deleteRenderbuffer(renderbuffer);
              renderbuffer.name = 0;
              GL.renderbuffers[id] = null;
            }
          }
          _glDeleteRenderbuffers.sig = "vip";
          var _emscripten_glDeleteRenderbuffers = _glDeleteRenderbuffers;
          var _glDeleteShader = (id) => {
            if (!id)
              return;
            var shader = GL.shaders[id];
            if (!shader) {
              GL.recordError(1281);
              return;
            }
            GLctx.deleteShader(shader);
            GL.shaders[id] = null;
          };
          _glDeleteShader.sig = "vi";
          var _emscripten_glDeleteShader = _glDeleteShader;
          function _glDeleteTextures(n, textures) {
            textures >>>= 0;
            for (var i2 = 0; i2 < n; i2++) {
              var id = HEAP32[textures + i2 * 4 >>> 2 >>> 0];
              var texture = GL.textures[id];
              if (!texture)
                continue;
              GLctx.deleteTexture(texture);
              texture.name = 0;
              GL.textures[id] = null;
            }
          }
          _glDeleteTextures.sig = "vip";
          var _emscripten_glDeleteTextures = _glDeleteTextures;
          function _glDeleteVertexArrays(n, vaos) {
            vaos >>>= 0;
            for (var i2 = 0; i2 < n; i2++) {
              var id = HEAP32[vaos + i2 * 4 >>> 2 >>> 0];
              GLctx.deleteVertexArray(GL.vaos[id]);
              GL.vaos[id] = null;
            }
          }
          _glDeleteVertexArrays.sig = "vip";
          var _glDeleteVertexArraysOES = _glDeleteVertexArrays;
          _glDeleteVertexArraysOES.sig = "vip";
          var _emscripten_glDeleteVertexArraysOES = _glDeleteVertexArraysOES;
          function _glDepthFunc(x0) {
            GLctx.depthFunc(x0);
          }
          _glDepthFunc.sig = "vi";
          var _emscripten_glDepthFunc = _glDepthFunc;
          var _glDepthMask = (flag) => {
            GLctx.depthMask(!!flag);
          };
          _glDepthMask.sig = "vi";
          var _emscripten_glDepthMask = _glDepthMask;
          function _glDepthRangef(x0, x1) {
            GLctx.depthRange(x0, x1);
          }
          _glDepthRangef.sig = "vff";
          var _emscripten_glDepthRangef = _glDepthRangef;
          var _glDetachShader = (program, shader) => {
            GLctx.detachShader(GL.programs[program], GL.shaders[shader]);
          };
          _glDetachShader.sig = "vii";
          var _emscripten_glDetachShader = _glDetachShader;
          function _glDisable(x0) {
            GLctx.disable(x0);
          }
          _glDisable.sig = "vi";
          var _emscripten_glDisable = _glDisable;
          var _glDisableVertexAttribArray = (index) => {
            GLctx.disableVertexAttribArray(index);
          };
          _glDisableVertexAttribArray.sig = "vi";
          var _emscripten_glDisableVertexAttribArray = _glDisableVertexAttribArray;
          var _glDrawArrays = (mode, first, count) => {
            GLctx.drawArrays(mode, first, count);
          };
          _glDrawArrays.sig = "viii";
          var _emscripten_glDrawArrays = _glDrawArrays;
          var _glDrawArraysInstanced = (mode, first, count, primcount) => {
            GLctx.drawArraysInstanced(mode, first, count, primcount);
          };
          _glDrawArraysInstanced.sig = "viiii";
          var _glDrawArraysInstancedANGLE = _glDrawArraysInstanced;
          var _emscripten_glDrawArraysInstancedANGLE = _glDrawArraysInstancedANGLE;
          var tempFixedLengthArray = [];
          function _glDrawBuffers(n, bufs) {
            bufs >>>= 0;
            var bufArray = tempFixedLengthArray[n];
            for (var i2 = 0; i2 < n; i2++) {
              bufArray[i2] = HEAP32[bufs + i2 * 4 >>> 2 >>> 0];
            }
            GLctx.drawBuffers(bufArray);
          }
          _glDrawBuffers.sig = "vip";
          var _glDrawBuffersWEBGL = _glDrawBuffers;
          var _emscripten_glDrawBuffersWEBGL = _glDrawBuffersWEBGL;
          function _glDrawElements(mode, count, type, indices) {
            indices >>>= 0;
            GLctx.drawElements(mode, count, type, indices);
          }
          _glDrawElements.sig = "viiip";
          var _emscripten_glDrawElements = _glDrawElements;
          function _glDrawElementsInstanced(mode, count, type, indices, primcount) {
            indices >>>= 0;
            GLctx.drawElementsInstanced(mode, count, type, indices, primcount);
          }
          _glDrawElementsInstanced.sig = "viiipi";
          var _glDrawElementsInstancedANGLE = _glDrawElementsInstanced;
          var _emscripten_glDrawElementsInstancedANGLE = _glDrawElementsInstancedANGLE;
          function _glEnable(x0) {
            GLctx.enable(x0);
          }
          _glEnable.sig = "vi";
          var _emscripten_glEnable = _glEnable;
          var _glEnableVertexAttribArray = (index) => {
            GLctx.enableVertexAttribArray(index);
          };
          _glEnableVertexAttribArray.sig = "vi";
          var _emscripten_glEnableVertexAttribArray = _glEnableVertexAttribArray;
          var _glEndQueryEXT = (target) => {
            GLctx.disjointTimerQueryExt["endQueryEXT"](target);
          };
          _glEndQueryEXT.sig = "vi";
          var _emscripten_glEndQueryEXT = _glEndQueryEXT;
          function _glFinish() {
            GLctx.finish();
          }
          _glFinish.sig = "v";
          var _emscripten_glFinish = _glFinish;
          function _glFlush() {
            GLctx.flush();
          }
          _glFlush.sig = "v";
          var _emscripten_glFlush = _glFlush;
          var _glFramebufferRenderbuffer = (target, attachment, renderbuffertarget, renderbuffer) => {
            GLctx.framebufferRenderbuffer(target, attachment, renderbuffertarget, GL.renderbuffers[renderbuffer]);
          };
          _glFramebufferRenderbuffer.sig = "viiii";
          var _emscripten_glFramebufferRenderbuffer = _glFramebufferRenderbuffer;
          var _glFramebufferTexture2D = (target, attachment, textarget, texture, level) => {
            GLctx.framebufferTexture2D(target, attachment, textarget, GL.textures[texture], level);
          };
          _glFramebufferTexture2D.sig = "viiiii";
          var _emscripten_glFramebufferTexture2D = _glFramebufferTexture2D;
          function _glFrontFace(x0) {
            GLctx.frontFace(x0);
          }
          _glFrontFace.sig = "vi";
          var _emscripten_glFrontFace = _glFrontFace;
          var __glGenObject = (n, buffers, createFunction, objectTable) => {
            for (var i2 = 0; i2 < n; i2++) {
              var buffer = GLctx[createFunction]();
              var id = buffer && GL.getNewId(objectTable);
              if (buffer) {
                buffer.name = id;
                objectTable[id] = buffer;
              } else {
                GL.recordError(1282);
              }
              HEAP32[buffers + i2 * 4 >>> 2 >>> 0] = id;
            }
          };
          function _glGenBuffers(n, buffers) {
            buffers >>>= 0;
            __glGenObject(n, buffers, "createBuffer", GL.buffers);
          }
          _glGenBuffers.sig = "vip";
          var _emscripten_glGenBuffers = _glGenBuffers;
          function _glGenFramebuffers(n, ids) {
            ids >>>= 0;
            __glGenObject(n, ids, "createFramebuffer", GL.framebuffers);
          }
          _glGenFramebuffers.sig = "vip";
          var _emscripten_glGenFramebuffers = _glGenFramebuffers;
          function _glGenQueriesEXT(n, ids) {
            ids >>>= 0;
            for (var i2 = 0; i2 < n; i2++) {
              var query = GLctx.disjointTimerQueryExt["createQueryEXT"]();
              if (!query) {
                GL.recordError(1282);
                while (i2 < n)
                  HEAP32[ids + i2++ * 4 >>> 2 >>> 0] = 0;
                return;
              }
              var id = GL.getNewId(GL.queries);
              query.name = id;
              GL.queries[id] = query;
              HEAP32[ids + i2 * 4 >>> 2 >>> 0] = id;
            }
          }
          _glGenQueriesEXT.sig = "vip";
          var _emscripten_glGenQueriesEXT = _glGenQueriesEXT;
          function _glGenRenderbuffers(n, renderbuffers) {
            renderbuffers >>>= 0;
            __glGenObject(n, renderbuffers, "createRenderbuffer", GL.renderbuffers);
          }
          _glGenRenderbuffers.sig = "vip";
          var _emscripten_glGenRenderbuffers = _glGenRenderbuffers;
          function _glGenTextures(n, textures) {
            textures >>>= 0;
            __glGenObject(n, textures, "createTexture", GL.textures);
          }
          _glGenTextures.sig = "vip";
          var _emscripten_glGenTextures = _glGenTextures;
          function _glGenVertexArrays(n, arrays) {
            arrays >>>= 0;
            __glGenObject(n, arrays, "createVertexArray", GL.vaos);
          }
          _glGenVertexArrays.sig = "vip";
          var _glGenVertexArraysOES = _glGenVertexArrays;
          _glGenVertexArraysOES.sig = "vip";
          var _emscripten_glGenVertexArraysOES = _glGenVertexArraysOES;
          function _glGenerateMipmap(x0) {
            GLctx.generateMipmap(x0);
          }
          _glGenerateMipmap.sig = "vi";
          var _emscripten_glGenerateMipmap = _glGenerateMipmap;
          var __glGetActiveAttribOrUniform = (funcName, program, index, bufSize, length, size, type, name2) => {
            program = GL.programs[program];
            var info2 = GLctx[funcName](program, index);
            if (info2) {
              var numBytesWrittenExclNull = name2 && stringToUTF8(info2.name, name2, bufSize);
              if (length)
                HEAP32[length >>> 2 >>> 0] = numBytesWrittenExclNull;
              if (size)
                HEAP32[size >>> 2 >>> 0] = info2.size;
              if (type)
                HEAP32[type >>> 2 >>> 0] = info2.type;
            }
          };
          function _glGetActiveAttrib(program, index, bufSize, length, size, type, name2) {
            length >>>= 0;
            size >>>= 0;
            type >>>= 0;
            name2 >>>= 0;
            __glGetActiveAttribOrUniform("getActiveAttrib", program, index, bufSize, length, size, type, name2);
          }
          _glGetActiveAttrib.sig = "viiipppp";
          var _emscripten_glGetActiveAttrib = _glGetActiveAttrib;
          function _glGetActiveUniform(program, index, bufSize, length, size, type, name2) {
            length >>>= 0;
            size >>>= 0;
            type >>>= 0;
            name2 >>>= 0;
            __glGetActiveAttribOrUniform("getActiveUniform", program, index, bufSize, length, size, type, name2);
          }
          _glGetActiveUniform.sig = "viiipppp";
          var _emscripten_glGetActiveUniform = _glGetActiveUniform;
          function _glGetAttachedShaders(program, maxCount, count, shaders) {
            count >>>= 0;
            shaders >>>= 0;
            var result = GLctx.getAttachedShaders(GL.programs[program]);
            var len2 = result.length;
            if (len2 > maxCount) {
              len2 = maxCount;
            }
            HEAP32[count >>> 2 >>> 0] = len2;
            for (var i2 = 0; i2 < len2; ++i2) {
              var id = GL.shaders.indexOf(result[i2]);
              HEAP32[shaders + i2 * 4 >>> 2 >>> 0] = id;
            }
          }
          _glGetAttachedShaders.sig = "viipp";
          var _emscripten_glGetAttachedShaders = _glGetAttachedShaders;
          function _glGetAttribLocation(program, name2) {
            name2 >>>= 0;
            return GLctx.getAttribLocation(GL.programs[program], UTF8ToString(name2));
          }
          _glGetAttribLocation.sig = "iip";
          var _emscripten_glGetAttribLocation = _glGetAttribLocation;
          var writeI53ToI64 = (ptr2, num) => {
            HEAPU32[ptr2 >>> 2 >>> 0] = num;
            var lower = HEAPU32[ptr2 >>> 2 >>> 0];
            HEAPU32[ptr2 + 4 >>> 2 >>> 0] = (num - lower) / 4294967296;
          };
          var emscriptenWebGLGet = (name_, p, type) => {
            if (!p) {
              GL.recordError(1281);
              return;
            }
            var ret = void 0;
            switch (name_) {
              case 36346:
                ret = 1;
                break;
              case 36344:
                if (type != 0 && type != 1) {
                  GL.recordError(1280);
                }
                return;
              case 36345:
                ret = 0;
                break;
              case 34466:
                var formats = GLctx.getParameter(34467);
                ret = formats ? formats.length : 0;
                break;
            }
            if (ret === void 0) {
              var result = GLctx.getParameter(name_);
              switch (typeof result) {
                case "number":
                  ret = result;
                  break;
                case "boolean":
                  ret = result ? 1 : 0;
                  break;
                case "string":
                  GL.recordError(1280);
                  return;
                case "object":
                  if (result === null) {
                    switch (name_) {
                      case 34964:
                      case 35725:
                      case 34965:
                      case 36006:
                      case 36007:
                      case 32873:
                      case 34229:
                      case 34068: {
                        ret = 0;
                        break;
                      }
                      default: {
                        GL.recordError(1280);
                        return;
                      }
                    }
                  } else if (result instanceof Float32Array || result instanceof Uint32Array || result instanceof Int32Array || result instanceof Array) {
                    for (var i2 = 0; i2 < result.length; ++i2) {
                      switch (type) {
                        case 0:
                          HEAP32[p + i2 * 4 >>> 2 >>> 0] = result[i2];
                          break;
                        case 2:
                          HEAPF32[p + i2 * 4 >>> 2 >>> 0] = result[i2];
                          break;
                        case 4:
                          HEAP8[p + i2 >>> 0 >>> 0] = result[i2] ? 1 : 0;
                          break;
                      }
                    }
                    return;
                  } else {
                    try {
                      ret = result.name | 0;
                    } catch (e) {
                      GL.recordError(1280);
                      err(`GL_INVALID_ENUM in glGet${type}v: Unknown object returned from WebGL getParameter(${name_})! (error: ${e})`);
                      return;
                    }
                  }
                  break;
                default:
                  GL.recordError(1280);
                  err(`GL_INVALID_ENUM in glGet${type}v: Native code calling glGet${type}v(${name_}) and it returns ${result} of type ${typeof result}!`);
                  return;
              }
            }
            switch (type) {
              case 1:
                writeI53ToI64(p, ret);
                break;
              case 0:
                HEAP32[p >>> 2 >>> 0] = ret;
                break;
              case 2:
                HEAPF32[p >>> 2 >>> 0] = ret;
                break;
              case 4:
                HEAP8[p >>> 0 >>> 0] = ret ? 1 : 0;
                break;
            }
          };
          function _glGetBooleanv(name_, p) {
            p >>>= 0;
            return emscriptenWebGLGet(name_, p, 4);
          }
          _glGetBooleanv.sig = "vip";
          var _emscripten_glGetBooleanv = _glGetBooleanv;
          function _glGetBufferParameteriv(target, value, data2) {
            data2 >>>= 0;
            if (!data2) {
              GL.recordError(1281);
              return;
            }
            HEAP32[data2 >>> 2 >>> 0] = GLctx.getBufferParameter(target, value);
          }
          _glGetBufferParameteriv.sig = "viip";
          var _emscripten_glGetBufferParameteriv = _glGetBufferParameteriv;
          var _glGetError = () => {
            var error = GLctx.getError() || GL.lastError;
            GL.lastError = 0;
            return error;
          };
          _glGetError.sig = "i";
          var _emscripten_glGetError = _glGetError;
          function _glGetFloatv(name_, p) {
            p >>>= 0;
            return emscriptenWebGLGet(name_, p, 2);
          }
          _glGetFloatv.sig = "vip";
          var _emscripten_glGetFloatv = _glGetFloatv;
          function _glGetFramebufferAttachmentParameteriv(target, attachment, pname, params) {
            params >>>= 0;
            var result = GLctx.getFramebufferAttachmentParameter(target, attachment, pname);
            if (result instanceof WebGLRenderbuffer || result instanceof WebGLTexture) {
              result = result.name | 0;
            }
            HEAP32[params >>> 2 >>> 0] = result;
          }
          _glGetFramebufferAttachmentParameteriv.sig = "viiip";
          var _emscripten_glGetFramebufferAttachmentParameteriv = _glGetFramebufferAttachmentParameteriv;
          function _glGetIntegerv(name_, p) {
            p >>>= 0;
            return emscriptenWebGLGet(name_, p, 0);
          }
          _glGetIntegerv.sig = "vip";
          var _emscripten_glGetIntegerv = _glGetIntegerv;
          function _glGetProgramInfoLog(program, maxLength, length, infoLog) {
            length >>>= 0;
            infoLog >>>= 0;
            var log = GLctx.getProgramInfoLog(GL.programs[program]);
            if (log === null)
              log = "(unknown error)";
            var numBytesWrittenExclNull = maxLength > 0 && infoLog ? stringToUTF8(log, infoLog, maxLength) : 0;
            if (length)
              HEAP32[length >>> 2 >>> 0] = numBytesWrittenExclNull;
          }
          _glGetProgramInfoLog.sig = "viipp";
          var _emscripten_glGetProgramInfoLog = _glGetProgramInfoLog;
          function _glGetProgramiv(program, pname, p) {
            p >>>= 0;
            if (!p) {
              GL.recordError(1281);
              return;
            }
            if (program >= GL.counter) {
              GL.recordError(1281);
              return;
            }
            program = GL.programs[program];
            if (pname == 35716) {
              var log = GLctx.getProgramInfoLog(program);
              if (log === null)
                log = "(unknown error)";
              HEAP32[p >>> 2 >>> 0] = log.length + 1;
            } else if (pname == 35719) {
              if (!program.maxUniformLength) {
                for (var i2 = 0; i2 < GLctx.getProgramParameter(program, 35718); ++i2) {
                  program.maxUniformLength = Math.max(program.maxUniformLength, GLctx.getActiveUniform(program, i2).name.length + 1);
                }
              }
              HEAP32[p >>> 2 >>> 0] = program.maxUniformLength;
            } else if (pname == 35722) {
              if (!program.maxAttributeLength) {
                for (var i2 = 0; i2 < GLctx.getProgramParameter(program, 35721); ++i2) {
                  program.maxAttributeLength = Math.max(program.maxAttributeLength, GLctx.getActiveAttrib(program, i2).name.length + 1);
                }
              }
              HEAP32[p >>> 2 >>> 0] = program.maxAttributeLength;
            } else if (pname == 35381) {
              if (!program.maxUniformBlockNameLength) {
                for (var i2 = 0; i2 < GLctx.getProgramParameter(program, 35382); ++i2) {
                  program.maxUniformBlockNameLength = Math.max(program.maxUniformBlockNameLength, GLctx.getActiveUniformBlockName(program, i2).length + 1);
                }
              }
              HEAP32[p >>> 2 >>> 0] = program.maxUniformBlockNameLength;
            } else {
              HEAP32[p >>> 2 >>> 0] = GLctx.getProgramParameter(program, pname);
            }
          }
          _glGetProgramiv.sig = "viip";
          var _emscripten_glGetProgramiv = _glGetProgramiv;
          function _glGetQueryObjecti64vEXT(id, pname, params) {
            params >>>= 0;
            if (!params) {
              GL.recordError(1281);
              return;
            }
            var query = GL.queries[id];
            var param;
            {
              param = GLctx.disjointTimerQueryExt["getQueryObjectEXT"](query, pname);
            }
            var ret;
            if (typeof param == "boolean") {
              ret = param ? 1 : 0;
            } else {
              ret = param;
            }
            writeI53ToI64(params, ret);
          }
          _glGetQueryObjecti64vEXT.sig = "viip";
          var _emscripten_glGetQueryObjecti64vEXT = _glGetQueryObjecti64vEXT;
          function _glGetQueryObjectivEXT(id, pname, params) {
            params >>>= 0;
            if (!params) {
              GL.recordError(1281);
              return;
            }
            var query = GL.queries[id];
            var param = GLctx.disjointTimerQueryExt["getQueryObjectEXT"](query, pname);
            var ret;
            if (typeof param == "boolean") {
              ret = param ? 1 : 0;
            } else {
              ret = param;
            }
            HEAP32[params >>> 2 >>> 0] = ret;
          }
          _glGetQueryObjectivEXT.sig = "viip";
          var _emscripten_glGetQueryObjectivEXT = _glGetQueryObjectivEXT;
          var _glGetQueryObjectui64vEXT = _glGetQueryObjecti64vEXT;
          var _emscripten_glGetQueryObjectui64vEXT = _glGetQueryObjectui64vEXT;
          var _glGetQueryObjectuivEXT = _glGetQueryObjectivEXT;
          var _emscripten_glGetQueryObjectuivEXT = _glGetQueryObjectuivEXT;
          function _glGetQueryivEXT(target, pname, params) {
            params >>>= 0;
            if (!params) {
              GL.recordError(1281);
              return;
            }
            HEAP32[params >>> 2 >>> 0] = GLctx.disjointTimerQueryExt["getQueryEXT"](target, pname);
          }
          _glGetQueryivEXT.sig = "viip";
          var _emscripten_glGetQueryivEXT = _glGetQueryivEXT;
          function _glGetRenderbufferParameteriv(target, pname, params) {
            params >>>= 0;
            if (!params) {
              GL.recordError(1281);
              return;
            }
            HEAP32[params >>> 2 >>> 0] = GLctx.getRenderbufferParameter(target, pname);
          }
          _glGetRenderbufferParameteriv.sig = "viip";
          var _emscripten_glGetRenderbufferParameteriv = _glGetRenderbufferParameteriv;
          function _glGetShaderInfoLog(shader, maxLength, length, infoLog) {
            length >>>= 0;
            infoLog >>>= 0;
            var log = GLctx.getShaderInfoLog(GL.shaders[shader]);
            if (log === null)
              log = "(unknown error)";
            var numBytesWrittenExclNull = maxLength > 0 && infoLog ? stringToUTF8(log, infoLog, maxLength) : 0;
            if (length)
              HEAP32[length >>> 2 >>> 0] = numBytesWrittenExclNull;
          }
          _glGetShaderInfoLog.sig = "viipp";
          var _emscripten_glGetShaderInfoLog = _glGetShaderInfoLog;
          function _glGetShaderPrecisionFormat(shaderType, precisionType, range, precision) {
            range >>>= 0;
            precision >>>= 0;
            var result = GLctx.getShaderPrecisionFormat(shaderType, precisionType);
            HEAP32[range >>> 2 >>> 0] = result.rangeMin;
            HEAP32[range + 4 >>> 2 >>> 0] = result.rangeMax;
            HEAP32[precision >>> 2 >>> 0] = result.precision;
          }
          _glGetShaderPrecisionFormat.sig = "viipp";
          var _emscripten_glGetShaderPrecisionFormat = _glGetShaderPrecisionFormat;
          function _glGetShaderSource(shader, bufSize, length, source) {
            length >>>= 0;
            source >>>= 0;
            var result = GLctx.getShaderSource(GL.shaders[shader]);
            if (!result)
              return;
            var numBytesWrittenExclNull = bufSize > 0 && source ? stringToUTF8(result, source, bufSize) : 0;
            if (length)
              HEAP32[length >>> 2 >>> 0] = numBytesWrittenExclNull;
          }
          _glGetShaderSource.sig = "viipp";
          var _emscripten_glGetShaderSource = _glGetShaderSource;
          function _glGetShaderiv(shader, pname, p) {
            p >>>= 0;
            if (!p) {
              GL.recordError(1281);
              return;
            }
            if (pname == 35716) {
              var log = GLctx.getShaderInfoLog(GL.shaders[shader]);
              if (log === null)
                log = "(unknown error)";
              var logLength = log ? log.length + 1 : 0;
              HEAP32[p >>> 2 >>> 0] = logLength;
            } else if (pname == 35720) {
              var source = GLctx.getShaderSource(GL.shaders[shader]);
              var sourceLength = source ? source.length + 1 : 0;
              HEAP32[p >>> 2 >>> 0] = sourceLength;
            } else {
              HEAP32[p >>> 2 >>> 0] = GLctx.getShaderParameter(GL.shaders[shader], pname);
            }
          }
          _glGetShaderiv.sig = "viip";
          var _emscripten_glGetShaderiv = _glGetShaderiv;
          var webglGetExtensions = function $webglGetExtensions() {
            var exts = getEmscriptenSupportedExtensions(GLctx);
            exts = exts.concat(exts.map((e) => "GL_" + e));
            return exts;
          };
          function _glGetString(name_) {
            var ret = GL.stringCache[name_];
            if (!ret) {
              switch (name_) {
                case 7939:
                  ret = stringToNewUTF8(webglGetExtensions().join(" "));
                  break;
                case 7936:
                case 7937:
                case 37445:
                case 37446:
                  var s2 = GLctx.getParameter(name_);
                  if (!s2) {
                    GL.recordError(1280);
                  }
                  ret = s2 ? stringToNewUTF8(s2) : 0;
                  break;
                case 7938:
                  var glVersion = GLctx.getParameter(7938);
                  {
                    glVersion = `OpenGL ES 2.0 (${glVersion})`;
                  }
                  ret = stringToNewUTF8(glVersion);
                  break;
                case 35724:
                  var glslVersion = GLctx.getParameter(35724);
                  var ver_re = /^WebGL GLSL ES ([0-9]\.[0-9][0-9]?)(?:$| .*)/;
                  var ver_num = glslVersion.match(ver_re);
                  if (ver_num !== null) {
                    if (ver_num[1].length == 3)
                      ver_num[1] = ver_num[1] + "0";
                    glslVersion = `OpenGL ES GLSL ES ${ver_num[1]} (${glslVersion})`;
                  }
                  ret = stringToNewUTF8(glslVersion);
                  break;
                default:
                  GL.recordError(1280);
              }
              GL.stringCache[name_] = ret;
            }
            return ret;
          }
          _glGetString.sig = "pi";
          var _emscripten_glGetString = _glGetString;
          function _glGetTexParameterfv(target, pname, params) {
            params >>>= 0;
            if (!params) {
              GL.recordError(1281);
              return;
            }
            HEAPF32[params >>> 2 >>> 0] = GLctx.getTexParameter(target, pname);
          }
          _glGetTexParameterfv.sig = "viip";
          var _emscripten_glGetTexParameterfv = _glGetTexParameterfv;
          function _glGetTexParameteriv(target, pname, params) {
            params >>>= 0;
            if (!params) {
              GL.recordError(1281);
              return;
            }
            HEAP32[params >>> 2 >>> 0] = GLctx.getTexParameter(target, pname);
          }
          _glGetTexParameteriv.sig = "viip";
          var _emscripten_glGetTexParameteriv = _glGetTexParameteriv;
          var webglGetLeftBracePos = (name2) => name2.slice(-1) == "]" && name2.lastIndexOf("[");
          var webglPrepareUniformLocationsBeforeFirstUse = (program) => {
            var uniformLocsById = program.uniformLocsById, uniformSizeAndIdsByName = program.uniformSizeAndIdsByName, i2, j;
            if (!uniformLocsById) {
              program.uniformLocsById = uniformLocsById = {};
              program.uniformArrayNamesById = {};
              for (i2 = 0; i2 < GLctx.getProgramParameter(program, 35718); ++i2) {
                var u = GLctx.getActiveUniform(program, i2);
                var nm = u.name;
                var sz = u.size;
                var lb = webglGetLeftBracePos(nm);
                var arrayName = lb > 0 ? nm.slice(0, lb) : nm;
                var id = program.uniformIdCounter;
                program.uniformIdCounter += sz;
                uniformSizeAndIdsByName[arrayName] = [sz, id];
                for (j = 0; j < sz; ++j) {
                  uniformLocsById[id] = j;
                  program.uniformArrayNamesById[id++] = arrayName;
                }
              }
            }
          };
          function _glGetUniformLocation(program, name2) {
            name2 >>>= 0;
            name2 = UTF8ToString(name2);
            if (program = GL.programs[program]) {
              webglPrepareUniformLocationsBeforeFirstUse(program);
              var uniformLocsById = program.uniformLocsById;
              var arrayIndex = 0;
              var uniformBaseName = name2;
              var leftBrace = webglGetLeftBracePos(name2);
              if (leftBrace > 0) {
                arrayIndex = jstoi_q(name2.slice(leftBrace + 1)) >>> 0;
                uniformBaseName = name2.slice(0, leftBrace);
              }
              var sizeAndId = program.uniformSizeAndIdsByName[uniformBaseName];
              if (sizeAndId && arrayIndex < sizeAndId[0]) {
                arrayIndex += sizeAndId[1];
                if (uniformLocsById[arrayIndex] = uniformLocsById[arrayIndex] || GLctx.getUniformLocation(program, name2)) {
                  return arrayIndex;
                }
              }
            } else {
              GL.recordError(1281);
            }
            return -1;
          }
          _glGetUniformLocation.sig = "iip";
          var _emscripten_glGetUniformLocation = _glGetUniformLocation;
          var webglGetUniformLocation = (location) => {
            var p = GLctx.currentProgram;
            if (p) {
              var webglLoc = p.uniformLocsById[location];
              if (typeof webglLoc == "number") {
                p.uniformLocsById[location] = webglLoc = GLctx.getUniformLocation(p, p.uniformArrayNamesById[location] + (webglLoc > 0 ? `[${webglLoc}]` : ""));
              }
              return webglLoc;
            } else {
              GL.recordError(1282);
            }
          };
          var emscriptenWebGLGetUniform = (program, location, params, type) => {
            if (!params) {
              GL.recordError(1281);
              return;
            }
            program = GL.programs[program];
            webglPrepareUniformLocationsBeforeFirstUse(program);
            var data2 = GLctx.getUniform(program, webglGetUniformLocation(location));
            if (typeof data2 == "number" || typeof data2 == "boolean") {
              switch (type) {
                case 0:
                  HEAP32[params >>> 2 >>> 0] = data2;
                  break;
                case 2:
                  HEAPF32[params >>> 2 >>> 0] = data2;
                  break;
              }
            } else {
              for (var i2 = 0; i2 < data2.length; i2++) {
                switch (type) {
                  case 0:
                    HEAP32[params + i2 * 4 >>> 2 >>> 0] = data2[i2];
                    break;
                  case 2:
                    HEAPF32[params + i2 * 4 >>> 2 >>> 0] = data2[i2];
                    break;
                }
              }
            }
          };
          function _glGetUniformfv(program, location, params) {
            params >>>= 0;
            emscriptenWebGLGetUniform(program, location, params, 2);
          }
          _glGetUniformfv.sig = "viip";
          var _emscripten_glGetUniformfv = _glGetUniformfv;
          function _glGetUniformiv(program, location, params) {
            params >>>= 0;
            emscriptenWebGLGetUniform(program, location, params, 0);
          }
          _glGetUniformiv.sig = "viip";
          var _emscripten_glGetUniformiv = _glGetUniformiv;
          function _glGetVertexAttribPointerv(index, pname, pointer) {
            pointer >>>= 0;
            if (!pointer) {
              GL.recordError(1281);
              return;
            }
            HEAP32[pointer >>> 2 >>> 0] = GLctx.getVertexAttribOffset(index, pname);
          }
          _glGetVertexAttribPointerv.sig = "viip";
          var _emscripten_glGetVertexAttribPointerv = _glGetVertexAttribPointerv;
          var emscriptenWebGLGetVertexAttrib = (index, pname, params, type) => {
            if (!params) {
              GL.recordError(1281);
              return;
            }
            var data2 = GLctx.getVertexAttrib(index, pname);
            if (pname == 34975) {
              HEAP32[params >>> 2 >>> 0] = data2 && data2["name"];
            } else if (typeof data2 == "number" || typeof data2 == "boolean") {
              switch (type) {
                case 0:
                  HEAP32[params >>> 2 >>> 0] = data2;
                  break;
                case 2:
                  HEAPF32[params >>> 2 >>> 0] = data2;
                  break;
                case 5:
                  HEAP32[params >>> 2 >>> 0] = Math.fround(data2);
                  break;
              }
            } else {
              for (var i2 = 0; i2 < data2.length; i2++) {
                switch (type) {
                  case 0:
                    HEAP32[params + i2 * 4 >>> 2 >>> 0] = data2[i2];
                    break;
                  case 2:
                    HEAPF32[params + i2 * 4 >>> 2 >>> 0] = data2[i2];
                    break;
                  case 5:
                    HEAP32[params + i2 * 4 >>> 2 >>> 0] = Math.fround(data2[i2]);
                    break;
                }
              }
            }
          };
          function _glGetVertexAttribfv(index, pname, params) {
            params >>>= 0;
            emscriptenWebGLGetVertexAttrib(index, pname, params, 2);
          }
          _glGetVertexAttribfv.sig = "viip";
          var _emscripten_glGetVertexAttribfv = _glGetVertexAttribfv;
          function _glGetVertexAttribiv(index, pname, params) {
            params >>>= 0;
            emscriptenWebGLGetVertexAttrib(index, pname, params, 5);
          }
          _glGetVertexAttribiv.sig = "viip";
          var _emscripten_glGetVertexAttribiv = _glGetVertexAttribiv;
          function _glHint(x0, x1) {
            GLctx.hint(x0, x1);
          }
          _glHint.sig = "vii";
          var _emscripten_glHint = _glHint;
          var _glIsBuffer = (buffer) => {
            var b = GL.buffers[buffer];
            if (!b)
              return 0;
            return GLctx.isBuffer(b);
          };
          _glIsBuffer.sig = "ii";
          var _emscripten_glIsBuffer = _glIsBuffer;
          function _glIsEnabled(x0) {
            return GLctx.isEnabled(x0);
          }
          _glIsEnabled.sig = "ii";
          var _emscripten_glIsEnabled = _glIsEnabled;
          var _glIsFramebuffer = (framebuffer) => {
            var fb = GL.framebuffers[framebuffer];
            if (!fb)
              return 0;
            return GLctx.isFramebuffer(fb);
          };
          _glIsFramebuffer.sig = "ii";
          var _emscripten_glIsFramebuffer = _glIsFramebuffer;
          var _glIsProgram = (program) => {
            program = GL.programs[program];
            if (!program)
              return 0;
            return GLctx.isProgram(program);
          };
          _glIsProgram.sig = "ii";
          var _emscripten_glIsProgram = _glIsProgram;
          var _glIsQueryEXT = (id) => {
            var query = GL.queries[id];
            if (!query)
              return 0;
            return GLctx.disjointTimerQueryExt["isQueryEXT"](query);
          };
          _glIsQueryEXT.sig = "ii";
          var _emscripten_glIsQueryEXT = _glIsQueryEXT;
          var _glIsRenderbuffer = (renderbuffer) => {
            var rb = GL.renderbuffers[renderbuffer];
            if (!rb)
              return 0;
            return GLctx.isRenderbuffer(rb);
          };
          _glIsRenderbuffer.sig = "ii";
          var _emscripten_glIsRenderbuffer = _glIsRenderbuffer;
          var _glIsShader = (shader) => {
            var s2 = GL.shaders[shader];
            if (!s2)
              return 0;
            return GLctx.isShader(s2);
          };
          _glIsShader.sig = "ii";
          var _emscripten_glIsShader = _glIsShader;
          var _glIsTexture = (id) => {
            var texture = GL.textures[id];
            if (!texture)
              return 0;
            return GLctx.isTexture(texture);
          };
          _glIsTexture.sig = "ii";
          var _emscripten_glIsTexture = _glIsTexture;
          var _glIsVertexArray = (array) => {
            var vao = GL.vaos[array];
            if (!vao)
              return 0;
            return GLctx.isVertexArray(vao);
          };
          _glIsVertexArray.sig = "ii";
          var _glIsVertexArrayOES = _glIsVertexArray;
          _glIsVertexArrayOES.sig = "ii";
          var _emscripten_glIsVertexArrayOES = _glIsVertexArrayOES;
          function _glLineWidth(x0) {
            GLctx.lineWidth(x0);
          }
          _glLineWidth.sig = "vf";
          var _emscripten_glLineWidth = _glLineWidth;
          var _glLinkProgram = (program) => {
            program = GL.programs[program];
            GLctx.linkProgram(program);
            program.uniformLocsById = 0;
            program.uniformSizeAndIdsByName = {};
          };
          _glLinkProgram.sig = "vi";
          var _emscripten_glLinkProgram = _glLinkProgram;
          var _glPixelStorei = (pname, param) => {
            if (pname == 3317) {
              GL.unpackAlignment = param;
            }
            GLctx.pixelStorei(pname, param);
          };
          _glPixelStorei.sig = "vii";
          var _emscripten_glPixelStorei = _glPixelStorei;
          function _glPolygonOffset(x0, x1) {
            GLctx.polygonOffset(x0, x1);
          }
          _glPolygonOffset.sig = "vff";
          var _emscripten_glPolygonOffset = _glPolygonOffset;
          var _glQueryCounterEXT = (id, target) => {
            GLctx.disjointTimerQueryExt["queryCounterEXT"](GL.queries[id], target);
          };
          _glQueryCounterEXT.sig = "vii";
          var _emscripten_glQueryCounterEXT = _glQueryCounterEXT;
          var computeUnpackAlignedImageSize = (width, height, sizePerPixel, alignment) => {
            function roundedToNextMultipleOf(x, y) {
              return x + y - 1 & -y;
            }
            var plainRowSize = width * sizePerPixel;
            var alignedRowSize = roundedToNextMultipleOf(plainRowSize, alignment);
            return height * alignedRowSize;
          };
          var colorChannelsInGlTextureFormat = (format) => {
            var colorChannels = {
              5: 3,
              6: 4,
              8: 2,
              29502: 3,
              29504: 4
            };
            return colorChannels[format - 6402] || 1;
          };
          var heapObjectForWebGLType = (type) => {
            type -= 5120;
            if (type == 1)
              return HEAPU8;
            if (type == 4)
              return HEAP32;
            if (type == 6)
              return HEAPF32;
            if (type == 5 || type == 28922)
              return HEAPU32;
            return HEAPU16;
          };
          var heapAccessShiftForWebGLHeap = (heap) => 31 - Math.clz32(heap.BYTES_PER_ELEMENT);
          var emscriptenWebGLGetTexPixelData = (type, format, width, height, pixels, internalFormat) => {
            var heap = heapObjectForWebGLType(type);
            var shift = heapAccessShiftForWebGLHeap(heap);
            var byteSize = 1 << shift;
            var sizePerPixel = colorChannelsInGlTextureFormat(format) * byteSize;
            var bytes = computeUnpackAlignedImageSize(width, height, sizePerPixel, GL.unpackAlignment);
            return heap.subarray(pixels >>> shift, pixels + bytes >>> shift);
          };
          function _glReadPixels(x, y, width, height, format, type, pixels) {
            pixels >>>= 0;
            var pixelData = emscriptenWebGLGetTexPixelData(type, format, width, height, pixels, format);
            if (!pixelData) {
              GL.recordError(1280);
              return;
            }
            GLctx.readPixels(x, y, width, height, format, type, pixelData);
          }
          _glReadPixels.sig = "viiiiiip";
          var _emscripten_glReadPixels = _glReadPixels;
          var _glReleaseShaderCompiler = () => {
          };
          _glReleaseShaderCompiler.sig = "v";
          var _emscripten_glReleaseShaderCompiler = _glReleaseShaderCompiler;
          function _glRenderbufferStorage(x0, x1, x2, x3) {
            GLctx.renderbufferStorage(x0, x1, x2, x3);
          }
          _glRenderbufferStorage.sig = "viiii";
          var _emscripten_glRenderbufferStorage = _glRenderbufferStorage;
          var _glSampleCoverage = (value, invert) => {
            GLctx.sampleCoverage(value, !!invert);
          };
          _glSampleCoverage.sig = "vfi";
          var _emscripten_glSampleCoverage = _glSampleCoverage;
          function _glScissor(x0, x1, x2, x3) {
            GLctx.scissor(x0, x1, x2, x3);
          }
          _glScissor.sig = "viiii";
          var _emscripten_glScissor = _glScissor;
          function _glShaderBinary(count, shaders, binaryformat, binary2, length) {
            shaders >>>= 0;
            binary2 >>>= 0;
            GL.recordError(1280);
          }
          _glShaderBinary.sig = "vipipi";
          var _emscripten_glShaderBinary = _glShaderBinary;
          function _glShaderSource(shader, count, string, length) {
            string >>>= 0;
            length >>>= 0;
            var source = GL.getSource(shader, count, string, length);
            GLctx.shaderSource(GL.shaders[shader], source);
          }
          _glShaderSource.sig = "viipp";
          var _emscripten_glShaderSource = _glShaderSource;
          function _glStencilFunc(x0, x1, x2) {
            GLctx.stencilFunc(x0, x1, x2);
          }
          _glStencilFunc.sig = "viii";
          var _emscripten_glStencilFunc = _glStencilFunc;
          function _glStencilFuncSeparate(x0, x1, x2, x3) {
            GLctx.stencilFuncSeparate(x0, x1, x2, x3);
          }
          _glStencilFuncSeparate.sig = "viiii";
          var _emscripten_glStencilFuncSeparate = _glStencilFuncSeparate;
          function _glStencilMask(x0) {
            GLctx.stencilMask(x0);
          }
          _glStencilMask.sig = "vi";
          var _emscripten_glStencilMask = _glStencilMask;
          function _glStencilMaskSeparate(x0, x1) {
            GLctx.stencilMaskSeparate(x0, x1);
          }
          _glStencilMaskSeparate.sig = "vii";
          var _emscripten_glStencilMaskSeparate = _glStencilMaskSeparate;
          function _glStencilOp(x0, x1, x2) {
            GLctx.stencilOp(x0, x1, x2);
          }
          _glStencilOp.sig = "viii";
          var _emscripten_glStencilOp = _glStencilOp;
          function _glStencilOpSeparate(x0, x1, x2, x3) {
            GLctx.stencilOpSeparate(x0, x1, x2, x3);
          }
          _glStencilOpSeparate.sig = "viiii";
          var _emscripten_glStencilOpSeparate = _glStencilOpSeparate;
          function _glTexImage2D(target, level, internalFormat, width, height, border, format, type, pixels) {
            pixels >>>= 0;
            GLctx.texImage2D(target, level, internalFormat, width, height, border, format, type, pixels ? emscriptenWebGLGetTexPixelData(type, format, width, height, pixels, internalFormat) : null);
          }
          _glTexImage2D.sig = "viiiiiiiip";
          var _emscripten_glTexImage2D = _glTexImage2D;
          function _glTexParameterf(x0, x1, x2) {
            GLctx.texParameterf(x0, x1, x2);
          }
          _glTexParameterf.sig = "viif";
          var _emscripten_glTexParameterf = _glTexParameterf;
          function _glTexParameterfv(target, pname, params) {
            params >>>= 0;
            var param = HEAPF32[params >>> 2 >>> 0];
            GLctx.texParameterf(target, pname, param);
          }
          _glTexParameterfv.sig = "viip";
          var _emscripten_glTexParameterfv = _glTexParameterfv;
          function _glTexParameteri(x0, x1, x2) {
            GLctx.texParameteri(x0, x1, x2);
          }
          _glTexParameteri.sig = "viii";
          var _emscripten_glTexParameteri = _glTexParameteri;
          function _glTexParameteriv(target, pname, params) {
            params >>>= 0;
            var param = HEAP32[params >>> 2 >>> 0];
            GLctx.texParameteri(target, pname, param);
          }
          _glTexParameteriv.sig = "viip";
          var _emscripten_glTexParameteriv = _glTexParameteriv;
          function _glTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels) {
            pixels >>>= 0;
            var pixelData = null;
            if (pixels)
              pixelData = emscriptenWebGLGetTexPixelData(type, format, width, height, pixels, 0);
            GLctx.texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixelData);
          }
          _glTexSubImage2D.sig = "viiiiiiiip";
          var _emscripten_glTexSubImage2D = _glTexSubImage2D;
          var _glUniform1f = (location, v0) => {
            GLctx.uniform1f(webglGetUniformLocation(location), v0);
          };
          _glUniform1f.sig = "vif";
          var _emscripten_glUniform1f = _glUniform1f;
          var miniTempWebGLFloatBuffers = [];
          function _glUniform1fv(location, count, value) {
            value >>>= 0;
            if (count <= 288) {
              var view = miniTempWebGLFloatBuffers[count - 1];
              for (var i2 = 0; i2 < count; ++i2) {
                view[i2] = HEAPF32[value + 4 * i2 >>> 2 >>> 0];
              }
            } else {
              var view = HEAPF32.subarray(value >>> 2 >>> 0, value + count * 4 >>> 2 >>> 0);
            }
            GLctx.uniform1fv(webglGetUniformLocation(location), view);
          }
          _glUniform1fv.sig = "viip";
          var _emscripten_glUniform1fv = _glUniform1fv;
          var _glUniform1i = (location, v0) => {
            GLctx.uniform1i(webglGetUniformLocation(location), v0);
          };
          _glUniform1i.sig = "vii";
          var _emscripten_glUniform1i = _glUniform1i;
          var miniTempWebGLIntBuffers = [];
          function _glUniform1iv(location, count, value) {
            value >>>= 0;
            if (count <= 288) {
              var view = miniTempWebGLIntBuffers[count - 1];
              for (var i2 = 0; i2 < count; ++i2) {
                view[i2] = HEAP32[value + 4 * i2 >>> 2 >>> 0];
              }
            } else {
              var view = HEAP32.subarray(value >>> 2 >>> 0, value + count * 4 >>> 2 >>> 0);
            }
            GLctx.uniform1iv(webglGetUniformLocation(location), view);
          }
          _glUniform1iv.sig = "viip";
          var _emscripten_glUniform1iv = _glUniform1iv;
          var _glUniform2f = (location, v0, v1) => {
            GLctx.uniform2f(webglGetUniformLocation(location), v0, v1);
          };
          _glUniform2f.sig = "viff";
          var _emscripten_glUniform2f = _glUniform2f;
          function _glUniform2fv(location, count, value) {
            value >>>= 0;
            if (count <= 144) {
              var view = miniTempWebGLFloatBuffers[2 * count - 1];
              for (var i2 = 0; i2 < 2 * count; i2 += 2) {
                view[i2] = HEAPF32[value + 4 * i2 >>> 2 >>> 0];
                view[i2 + 1] = HEAPF32[value + (4 * i2 + 4) >>> 2 >>> 0];
              }
            } else {
              var view = HEAPF32.subarray(value >>> 2 >>> 0, value + count * 8 >>> 2 >>> 0);
            }
            GLctx.uniform2fv(webglGetUniformLocation(location), view);
          }
          _glUniform2fv.sig = "viip";
          var _emscripten_glUniform2fv = _glUniform2fv;
          var _glUniform2i = (location, v0, v1) => {
            GLctx.uniform2i(webglGetUniformLocation(location), v0, v1);
          };
          _glUniform2i.sig = "viii";
          var _emscripten_glUniform2i = _glUniform2i;
          function _glUniform2iv(location, count, value) {
            value >>>= 0;
            if (count <= 144) {
              var view = miniTempWebGLIntBuffers[2 * count - 1];
              for (var i2 = 0; i2 < 2 * count; i2 += 2) {
                view[i2] = HEAP32[value + 4 * i2 >>> 2 >>> 0];
                view[i2 + 1] = HEAP32[value + (4 * i2 + 4) >>> 2 >>> 0];
              }
            } else {
              var view = HEAP32.subarray(value >>> 2 >>> 0, value + count * 8 >>> 2 >>> 0);
            }
            GLctx.uniform2iv(webglGetUniformLocation(location), view);
          }
          _glUniform2iv.sig = "viip";
          var _emscripten_glUniform2iv = _glUniform2iv;
          var _glUniform3f = (location, v0, v1, v2) => {
            GLctx.uniform3f(webglGetUniformLocation(location), v0, v1, v2);
          };
          _glUniform3f.sig = "vifff";
          var _emscripten_glUniform3f = _glUniform3f;
          function _glUniform3fv(location, count, value) {
            value >>>= 0;
            if (count <= 96) {
              var view = miniTempWebGLFloatBuffers[3 * count - 1];
              for (var i2 = 0; i2 < 3 * count; i2 += 3) {
                view[i2] = HEAPF32[value + 4 * i2 >>> 2 >>> 0];
                view[i2 + 1] = HEAPF32[value + (4 * i2 + 4) >>> 2 >>> 0];
                view[i2 + 2] = HEAPF32[value + (4 * i2 + 8) >>> 2 >>> 0];
              }
            } else {
              var view = HEAPF32.subarray(value >>> 2 >>> 0, value + count * 12 >>> 2 >>> 0);
            }
            GLctx.uniform3fv(webglGetUniformLocation(location), view);
          }
          _glUniform3fv.sig = "viip";
          var _emscripten_glUniform3fv = _glUniform3fv;
          var _glUniform3i = (location, v0, v1, v2) => {
            GLctx.uniform3i(webglGetUniformLocation(location), v0, v1, v2);
          };
          _glUniform3i.sig = "viiii";
          var _emscripten_glUniform3i = _glUniform3i;
          function _glUniform3iv(location, count, value) {
            value >>>= 0;
            if (count <= 96) {
              var view = miniTempWebGLIntBuffers[3 * count - 1];
              for (var i2 = 0; i2 < 3 * count; i2 += 3) {
                view[i2] = HEAP32[value + 4 * i2 >>> 2 >>> 0];
                view[i2 + 1] = HEAP32[value + (4 * i2 + 4) >>> 2 >>> 0];
                view[i2 + 2] = HEAP32[value + (4 * i2 + 8) >>> 2 >>> 0];
              }
            } else {
              var view = HEAP32.subarray(value >>> 2 >>> 0, value + count * 12 >>> 2 >>> 0);
            }
            GLctx.uniform3iv(webglGetUniformLocation(location), view);
          }
          _glUniform3iv.sig = "viip";
          var _emscripten_glUniform3iv = _glUniform3iv;
          var _glUniform4f = (location, v0, v1, v2, v3) => {
            GLctx.uniform4f(webglGetUniformLocation(location), v0, v1, v2, v3);
          };
          _glUniform4f.sig = "viffff";
          var _emscripten_glUniform4f = _glUniform4f;
          function _glUniform4fv(location, count, value) {
            value >>>= 0;
            if (count <= 72) {
              var view = miniTempWebGLFloatBuffers[4 * count - 1];
              var heap = HEAPF32;
              value >>= 2;
              for (var i2 = 0; i2 < 4 * count; i2 += 4) {
                var dst = value + i2;
                view[i2] = heap[dst >>> 0];
                view[i2 + 1] = heap[dst + 1 >>> 0];
                view[i2 + 2] = heap[dst + 2 >>> 0];
                view[i2 + 3] = heap[dst + 3 >>> 0];
              }
            } else {
              var view = HEAPF32.subarray(value >>> 2 >>> 0, value + count * 16 >>> 2 >>> 0);
            }
            GLctx.uniform4fv(webglGetUniformLocation(location), view);
          }
          _glUniform4fv.sig = "viip";
          var _emscripten_glUniform4fv = _glUniform4fv;
          var _glUniform4i = (location, v0, v1, v2, v3) => {
            GLctx.uniform4i(webglGetUniformLocation(location), v0, v1, v2, v3);
          };
          _glUniform4i.sig = "viiiii";
          var _emscripten_glUniform4i = _glUniform4i;
          function _glUniform4iv(location, count, value) {
            value >>>= 0;
            if (count <= 72) {
              var view = miniTempWebGLIntBuffers[4 * count - 1];
              for (var i2 = 0; i2 < 4 * count; i2 += 4) {
                view[i2] = HEAP32[value + 4 * i2 >>> 2 >>> 0];
                view[i2 + 1] = HEAP32[value + (4 * i2 + 4) >>> 2 >>> 0];
                view[i2 + 2] = HEAP32[value + (4 * i2 + 8) >>> 2 >>> 0];
                view[i2 + 3] = HEAP32[value + (4 * i2 + 12) >>> 2 >>> 0];
              }
            } else {
              var view = HEAP32.subarray(value >>> 2 >>> 0, value + count * 16 >>> 2 >>> 0);
            }
            GLctx.uniform4iv(webglGetUniformLocation(location), view);
          }
          _glUniform4iv.sig = "viip";
          var _emscripten_glUniform4iv = _glUniform4iv;
          function _glUniformMatrix2fv(location, count, transpose, value) {
            value >>>= 0;
            if (count <= 72) {
              var view = miniTempWebGLFloatBuffers[4 * count - 1];
              for (var i2 = 0; i2 < 4 * count; i2 += 4) {
                view[i2] = HEAPF32[value + 4 * i2 >>> 2 >>> 0];
                view[i2 + 1] = HEAPF32[value + (4 * i2 + 4) >>> 2 >>> 0];
                view[i2 + 2] = HEAPF32[value + (4 * i2 + 8) >>> 2 >>> 0];
                view[i2 + 3] = HEAPF32[value + (4 * i2 + 12) >>> 2 >>> 0];
              }
            } else {
              var view = HEAPF32.subarray(value >>> 2 >>> 0, value + count * 16 >>> 2 >>> 0);
            }
            GLctx.uniformMatrix2fv(webglGetUniformLocation(location), !!transpose, view);
          }
          _glUniformMatrix2fv.sig = "viiip";
          var _emscripten_glUniformMatrix2fv = _glUniformMatrix2fv;
          function _glUniformMatrix3fv(location, count, transpose, value) {
            value >>>= 0;
            if (count <= 32) {
              var view = miniTempWebGLFloatBuffers[9 * count - 1];
              for (var i2 = 0; i2 < 9 * count; i2 += 9) {
                view[i2] = HEAPF32[value + 4 * i2 >>> 2 >>> 0];
                view[i2 + 1] = HEAPF32[value + (4 * i2 + 4) >>> 2 >>> 0];
                view[i2 + 2] = HEAPF32[value + (4 * i2 + 8) >>> 2 >>> 0];
                view[i2 + 3] = HEAPF32[value + (4 * i2 + 12) >>> 2 >>> 0];
                view[i2 + 4] = HEAPF32[value + (4 * i2 + 16) >>> 2 >>> 0];
                view[i2 + 5] = HEAPF32[value + (4 * i2 + 20) >>> 2 >>> 0];
                view[i2 + 6] = HEAPF32[value + (4 * i2 + 24) >>> 2 >>> 0];
                view[i2 + 7] = HEAPF32[value + (4 * i2 + 28) >>> 2 >>> 0];
                view[i2 + 8] = HEAPF32[value + (4 * i2 + 32) >>> 2 >>> 0];
              }
            } else {
              var view = HEAPF32.subarray(value >>> 2 >>> 0, value + count * 36 >>> 2 >>> 0);
            }
            GLctx.uniformMatrix3fv(webglGetUniformLocation(location), !!transpose, view);
          }
          _glUniformMatrix3fv.sig = "viiip";
          var _emscripten_glUniformMatrix3fv = _glUniformMatrix3fv;
          function _glUniformMatrix4fv(location, count, transpose, value) {
            value >>>= 0;
            if (count <= 18) {
              var view = miniTempWebGLFloatBuffers[16 * count - 1];
              var heap = HEAPF32;
              value >>= 2;
              for (var i2 = 0; i2 < 16 * count; i2 += 16) {
                var dst = value + i2;
                view[i2] = heap[dst >>> 0];
                view[i2 + 1] = heap[dst + 1 >>> 0];
                view[i2 + 2] = heap[dst + 2 >>> 0];
                view[i2 + 3] = heap[dst + 3 >>> 0];
                view[i2 + 4] = heap[dst + 4 >>> 0];
                view[i2 + 5] = heap[dst + 5 >>> 0];
                view[i2 + 6] = heap[dst + 6 >>> 0];
                view[i2 + 7] = heap[dst + 7 >>> 0];
                view[i2 + 8] = heap[dst + 8 >>> 0];
                view[i2 + 9] = heap[dst + 9 >>> 0];
                view[i2 + 10] = heap[dst + 10 >>> 0];
                view[i2 + 11] = heap[dst + 11 >>> 0];
                view[i2 + 12] = heap[dst + 12 >>> 0];
                view[i2 + 13] = heap[dst + 13 >>> 0];
                view[i2 + 14] = heap[dst + 14 >>> 0];
                view[i2 + 15] = heap[dst + 15 >>> 0];
              }
            } else {
              var view = HEAPF32.subarray(value >>> 2 >>> 0, value + count * 64 >>> 2 >>> 0);
            }
            GLctx.uniformMatrix4fv(webglGetUniformLocation(location), !!transpose, view);
          }
          _glUniformMatrix4fv.sig = "viiip";
          var _emscripten_glUniformMatrix4fv = _glUniformMatrix4fv;
          var _glUseProgram = (program) => {
            program = GL.programs[program];
            GLctx.useProgram(program);
            GLctx.currentProgram = program;
          };
          _glUseProgram.sig = "vi";
          var _emscripten_glUseProgram = _glUseProgram;
          var _glValidateProgram = (program) => {
            GLctx.validateProgram(GL.programs[program]);
          };
          _glValidateProgram.sig = "vi";
          var _emscripten_glValidateProgram = _glValidateProgram;
          function _glVertexAttrib1f(x0, x1) {
            GLctx.vertexAttrib1f(x0, x1);
          }
          _glVertexAttrib1f.sig = "vif";
          var _emscripten_glVertexAttrib1f = _glVertexAttrib1f;
          function _glVertexAttrib1fv(index, v) {
            v >>>= 0;
            GLctx.vertexAttrib1f(index, HEAPF32[v >>> 2]);
          }
          _glVertexAttrib1fv.sig = "vip";
          var _emscripten_glVertexAttrib1fv = _glVertexAttrib1fv;
          function _glVertexAttrib2f(x0, x1, x2) {
            GLctx.vertexAttrib2f(x0, x1, x2);
          }
          _glVertexAttrib2f.sig = "viff";
          var _emscripten_glVertexAttrib2f = _glVertexAttrib2f;
          function _glVertexAttrib2fv(index, v) {
            v >>>= 0;
            GLctx.vertexAttrib2f(index, HEAPF32[v >>> 2], HEAPF32[v + 4 >>> 2]);
          }
          _glVertexAttrib2fv.sig = "vip";
          var _emscripten_glVertexAttrib2fv = _glVertexAttrib2fv;
          function _glVertexAttrib3f(x0, x1, x2, x3) {
            GLctx.vertexAttrib3f(x0, x1, x2, x3);
          }
          _glVertexAttrib3f.sig = "vifff";
          var _emscripten_glVertexAttrib3f = _glVertexAttrib3f;
          function _glVertexAttrib3fv(index, v) {
            v >>>= 0;
            GLctx.vertexAttrib3f(index, HEAPF32[v >>> 2], HEAPF32[v + 4 >>> 2], HEAPF32[v + 8 >>> 2]);
          }
          _glVertexAttrib3fv.sig = "vip";
          var _emscripten_glVertexAttrib3fv = _glVertexAttrib3fv;
          function _glVertexAttrib4f(x0, x1, x2, x3, x4) {
            GLctx.vertexAttrib4f(x0, x1, x2, x3, x4);
          }
          _glVertexAttrib4f.sig = "viffff";
          var _emscripten_glVertexAttrib4f = _glVertexAttrib4f;
          function _glVertexAttrib4fv(index, v) {
            v >>>= 0;
            GLctx.vertexAttrib4f(index, HEAPF32[v >>> 2], HEAPF32[v + 4 >>> 2], HEAPF32[v + 8 >>> 2], HEAPF32[v + 12 >>> 2]);
          }
          _glVertexAttrib4fv.sig = "vip";
          var _emscripten_glVertexAttrib4fv = _glVertexAttrib4fv;
          var _glVertexAttribDivisor = (index, divisor) => {
            GLctx.vertexAttribDivisor(index, divisor);
          };
          _glVertexAttribDivisor.sig = "vii";
          var _glVertexAttribDivisorANGLE = _glVertexAttribDivisor;
          var _emscripten_glVertexAttribDivisorANGLE = _glVertexAttribDivisorANGLE;
          function _glVertexAttribPointer(index, size, type, normalized, stride, ptr2) {
            ptr2 >>>= 0;
            GLctx.vertexAttribPointer(index, size, type, !!normalized, stride, ptr2);
          }
          _glVertexAttribPointer.sig = "viiiiip";
          var _emscripten_glVertexAttribPointer = _glVertexAttribPointer;
          function _glViewport(x0, x1, x2, x3) {
            GLctx.viewport(x0, x1, x2, x3);
          }
          _glViewport.sig = "viiii";
          var _emscripten_glViewport = _glViewport;
          function _emscripten_memcpy_js(dest, src, num) {
            dest >>>= 0;
            src >>>= 0;
            num >>>= 0;
            return HEAPU8.copyWithin(dest >>> 0, src >>> 0, src + num >>> 0);
          }
          _emscripten_memcpy_js.sig = "vppp";
          function _emscripten_out(str) {
            str >>>= 0;
            return out(UTF8ToString(str));
          }
          _emscripten_out.sig = "vp";
          var promiseMap = new HandleAllocator();
          var makePromise = () => {
            var promiseInfo = {};
            promiseInfo.promise = new Promise((resolve, reject) => {
              promiseInfo.reject = reject;
              promiseInfo.resolve = resolve;
            });
            promiseInfo.id = promiseMap.allocate(promiseInfo);
            return promiseInfo;
          };
          function _emscripten_promise_create() {
            return makePromise().id;
          }
          _emscripten_promise_create.sig = "p";
          function _emscripten_promise_destroy(id) {
            id >>>= 0;
            promiseMap.free(id);
          }
          _emscripten_promise_destroy.sig = "vp";
          var getPromise = (id) => promiseMap.get(id).promise;
          function _emscripten_promise_resolve(id, result, value) {
            id >>>= 0;
            value >>>= 0;
            var info2 = promiseMap.get(id);
            switch (result) {
              case 0:
                info2.resolve(value);
                return;
              case 1:
                info2.resolve(getPromise(value));
                return;
              case 2:
                info2.resolve(getPromise(value));
                _emscripten_promise_destroy(value);
                return;
              case 3:
                info2.reject(value);
                return;
            }
          }
          _emscripten_promise_resolve.sig = "vpip";
          var growMemory = (size) => {
            var b = wasmMemory.buffer;
            var pages = (size - b.byteLength + 65535) / 65536;
            try {
              wasmMemory.grow(pages);
              updateMemoryViews();
              return 1;
            } catch (e) {
            }
          };
          function _emscripten_resize_heap(requestedSize) {
            requestedSize >>>= 0;
            var oldSize = HEAPU8.length;
            var maxHeapSize = getHeapMax();
            if (requestedSize > maxHeapSize) {
              return false;
            }
            var alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;
            for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
              var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
              overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
              var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
              var replacement = growMemory(newSize);
              if (replacement) {
                return true;
              }
            }
            return false;
          }
          _emscripten_resize_heap.sig = "ip";
          function _emscripten_wget_data(url2, pbuffer, pnum, perror) {
            url2 >>>= 0;
            pbuffer >>>= 0;
            pnum >>>= 0;
            perror >>>= 0;
            throw "Please compile your program with async support in order to use asynchronous operations like emscripten_wget_data";
          }
          _emscripten_wget_data.sig = "vpppp";
          var getExecutableName = () => thisProgram || "./this.program";
          var getEnvStrings = () => {
            if (!getEnvStrings.strings) {
              var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
              var env = {
                "USER": "web_user",
                "LOGNAME": "web_user",
                "PATH": "/",
                "PWD": "/",
                "HOME": "/home/web_user",
                "LANG": lang,
                "_": getExecutableName()
              };
              for (var x in ENV) {
                if (ENV[x] === void 0)
                  delete env[x];
                else
                  env[x] = ENV[x];
              }
              var strings = [];
              for (var x in env) {
                strings.push(`${x}=${env[x]}`);
              }
              getEnvStrings.strings = strings;
            }
            return getEnvStrings.strings;
          };
          var stringToAscii = (str, buffer) => {
            for (var i2 = 0; i2 < str.length; ++i2) {
              HEAP8[buffer++ >>> 0 >>> 0] = str.charCodeAt(i2);
            }
            HEAP8[buffer >>> 0 >>> 0] = 0;
          };
          var _environ_get = function(__environ, environ_buf) {
            __environ >>>= 0;
            environ_buf >>>= 0;
            var bufSize = 0;
            getEnvStrings().forEach((string, i2) => {
              var ptr2 = environ_buf + bufSize;
              HEAPU32[__environ + i2 * 4 >>> 2 >>> 0] = ptr2;
              stringToAscii(string, ptr2);
              bufSize += string.length + 1;
            });
            return 0;
          };
          _environ_get.sig = "ipp";
          var _environ_sizes_get = function(penviron_count, penviron_buf_size) {
            penviron_count >>>= 0;
            penviron_buf_size >>>= 0;
            var strings = getEnvStrings();
            HEAPU32[penviron_count >>> 2 >>> 0] = strings.length;
            var bufSize = 0;
            strings.forEach((string) => bufSize += string.length + 1);
            HEAPU32[penviron_buf_size >>> 2 >>> 0] = bufSize;
            return 0;
          };
          _environ_sizes_get.sig = "ipp";
          function _fd_close(fd) {
            try {
              var stream = SYSCALLS.getStreamFromFD(fd);
              FS.close(stream);
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return e.errno;
            }
          }
          _fd_close.sig = "ii";
          function _fd_fdstat_get(fd, pbuf) {
            pbuf >>>= 0;
            try {
              var rightsBase = 0;
              var rightsInheriting = 0;
              var flags2 = 0;
              {
                var stream = SYSCALLS.getStreamFromFD(fd);
                var type = stream.tty ? 2 : FS.isDir(stream.mode) ? 3 : FS.isLink(stream.mode) ? 7 : 4;
              }
              HEAP8[pbuf >>> 0 >>> 0] = type;
              HEAP16[pbuf + 2 >>> 1 >>> 0] = flags2;
              tempI64 = [rightsBase >>> 0, (tempDouble = rightsBase, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[pbuf + 8 >>> 2 >>> 0] = tempI64[0], HEAP32[pbuf + 12 >>> 2 >>> 0] = tempI64[1];
              tempI64 = [rightsInheriting >>> 0, (tempDouble = rightsInheriting, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[pbuf + 16 >>> 2 >>> 0] = tempI64[0], HEAP32[pbuf + 20 >>> 2 >>> 0] = tempI64[1];
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return e.errno;
            }
          }
          _fd_fdstat_get.sig = "iip";
          var doReadv = (stream, iov, iovcnt, offset) => {
            var ret = 0;
            for (var i2 = 0; i2 < iovcnt; i2++) {
              var ptr2 = HEAPU32[iov >>> 2 >>> 0];
              var len2 = HEAPU32[iov + 4 >>> 2 >>> 0];
              iov += 8;
              var curr = FS.read(stream, HEAP8, ptr2, len2, offset);
              if (curr < 0)
                return -1;
              ret += curr;
              if (curr < len2)
                break;
              if (typeof offset !== "undefined") {
                offset += curr;
              }
            }
            return ret;
          };
          function _fd_pread(fd, iov, iovcnt, offset_low, offset_high, pnum) {
            iov >>>= 0;
            iovcnt >>>= 0;
            var offset = convertI32PairToI53Checked(offset_low, offset_high);
            pnum >>>= 0;
            try {
              if (isNaN(offset))
                return 61;
              var stream = SYSCALLS.getStreamFromFD(fd);
              var num = doReadv(stream, iov, iovcnt, offset);
              HEAPU32[pnum >>> 2 >>> 0] = num;
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return e.errno;
            }
          }
          _fd_pread.sig = "iippiip";
          var doWritev = (stream, iov, iovcnt, offset) => {
            var ret = 0;
            for (var i2 = 0; i2 < iovcnt; i2++) {
              var ptr2 = HEAPU32[iov >>> 2 >>> 0];
              var len2 = HEAPU32[iov + 4 >>> 2 >>> 0];
              iov += 8;
              var curr = FS.write(stream, HEAP8, ptr2, len2, offset);
              if (curr < 0)
                return -1;
              ret += curr;
              if (typeof offset !== "undefined") {
                offset += curr;
              }
            }
            return ret;
          };
          function _fd_pwrite(fd, iov, iovcnt, offset_low, offset_high, pnum) {
            iov >>>= 0;
            iovcnt >>>= 0;
            var offset = convertI32PairToI53Checked(offset_low, offset_high);
            pnum >>>= 0;
            try {
              if (isNaN(offset))
                return 61;
              var stream = SYSCALLS.getStreamFromFD(fd);
              var num = doWritev(stream, iov, iovcnt, offset);
              HEAPU32[pnum >>> 2 >>> 0] = num;
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return e.errno;
            }
          }
          _fd_pwrite.sig = "iippiip";
          function _fd_read(fd, iov, iovcnt, pnum) {
            iov >>>= 0;
            iovcnt >>>= 0;
            pnum >>>= 0;
            try {
              var stream = SYSCALLS.getStreamFromFD(fd);
              var num = doReadv(stream, iov, iovcnt);
              HEAPU32[pnum >>> 2 >>> 0] = num;
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return e.errno;
            }
          }
          _fd_read.sig = "iippp";
          function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
            var offset = convertI32PairToI53Checked(offset_low, offset_high);
            newOffset >>>= 0;
            try {
              if (isNaN(offset))
                return 61;
              var stream = SYSCALLS.getStreamFromFD(fd);
              FS.llseek(stream, offset, whence);
              tempI64 = [stream.position >>> 0, (tempDouble = stream.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[newOffset >>> 2 >>> 0] = tempI64[0], HEAP32[newOffset + 4 >>> 2 >>> 0] = tempI64[1];
              if (stream.getdents && offset === 0 && whence === 0)
                stream.getdents = null;
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return e.errno;
            }
          }
          _fd_seek.sig = "iiiiip";
          function _fd_sync(fd) {
            try {
              var stream = SYSCALLS.getStreamFromFD(fd);
              if (stream.stream_ops?.fsync) {
                return stream.stream_ops.fsync(stream);
              }
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return e.errno;
            }
          }
          _fd_sync.sig = "ii";
          function _fd_write(fd, iov, iovcnt, pnum) {
            iov >>>= 0;
            iovcnt >>>= 0;
            pnum >>>= 0;
            try {
              var stream = SYSCALLS.getStreamFromFD(fd);
              var num = doWritev(stream, iov, iovcnt);
              HEAPU32[pnum >>> 2 >>> 0] = num;
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return e.errno;
            }
          }
          _fd_write.sig = "iippp";
          function _getaddrinfo(node, service, hint, out2) {
            node >>>= 0;
            service >>>= 0;
            hint >>>= 0;
            out2 >>>= 0;
            var addrs = [];
            var canon = null;
            var addr2 = 0;
            var port = 0;
            var flags2 = 0;
            var family = 0;
            var type = 0;
            var proto = 0;
            var ai, last;
            function allocaddrinfo(family2, type2, proto2, canon2, addr3, port2) {
              var sa, salen, ai2;
              var errno;
              salen = family2 === 10 ? 28 : 16;
              addr3 = family2 === 10 ? inetNtop6(addr3) : inetNtop4(addr3);
              sa = _malloc(salen);
              errno = writeSockaddr(sa, family2, addr3, port2);
              assert(!errno);
              ai2 = _malloc(32);
              HEAP32[ai2 + 4 >>> 2 >>> 0] = family2;
              HEAP32[ai2 + 8 >>> 2 >>> 0] = type2;
              HEAP32[ai2 + 12 >>> 2 >>> 0] = proto2;
              HEAPU32[ai2 + 24 >>> 2 >>> 0] = canon2;
              HEAPU32[ai2 + 20 >>> 2 >>> 0] = sa;
              if (family2 === 10) {
                HEAP32[ai2 + 16 >>> 2 >>> 0] = 28;
              } else {
                HEAP32[ai2 + 16 >>> 2 >>> 0] = 16;
              }
              HEAP32[ai2 + 28 >>> 2 >>> 0] = 0;
              return ai2;
            }
            if (hint) {
              flags2 = HEAP32[hint >>> 2 >>> 0];
              family = HEAP32[hint + 4 >>> 2 >>> 0];
              type = HEAP32[hint + 8 >>> 2 >>> 0];
              proto = HEAP32[hint + 12 >>> 2 >>> 0];
            }
            if (type && !proto) {
              proto = type === 2 ? 17 : 6;
            }
            if (!type && proto) {
              type = proto === 17 ? 2 : 1;
            }
            if (proto === 0) {
              proto = 6;
            }
            if (type === 0) {
              type = 1;
            }
            if (!node && !service) {
              return -2;
            }
            if (flags2 & ~(1 | 2 | 4 | 1024 | 8 | 16 | 32)) {
              return -1;
            }
            if (hint !== 0 && HEAP32[hint >>> 2 >>> 0] & 2 && !node) {
              return -1;
            }
            if (flags2 & 32) {
              return -2;
            }
            if (type !== 0 && type !== 1 && type !== 2) {
              return -7;
            }
            if (family !== 0 && family !== 2 && family !== 10) {
              return -6;
            }
            if (service) {
              service = UTF8ToString(service);
              port = parseInt(service, 10);
              if (isNaN(port)) {
                if (flags2 & 1024) {
                  return -2;
                }
                return -8;
              }
            }
            if (!node) {
              if (family === 0) {
                family = 2;
              }
              if ((flags2 & 1) === 0) {
                if (family === 2) {
                  addr2 = _htonl(2130706433);
                } else {
                  addr2 = [0, 0, 0, 1];
                }
              }
              ai = allocaddrinfo(family, type, proto, null, addr2, port);
              HEAPU32[out2 >>> 2 >>> 0] = ai;
              return 0;
            }
            node = UTF8ToString(node);
            addr2 = inetPton4(node);
            if (addr2 !== null) {
              if (family === 0 || family === 2) {
                family = 2;
              } else if (family === 10 && flags2 & 8) {
                addr2 = [0, 0, _htonl(65535), addr2];
                family = 10;
              } else {
                return -2;
              }
            } else {
              addr2 = inetPton6(node);
              if (addr2 !== null) {
                if (family === 0 || family === 10) {
                  family = 10;
                } else {
                  return -2;
                }
              }
            }
            if (addr2 != null) {
              ai = allocaddrinfo(family, type, proto, node, addr2, port);
              HEAPU32[out2 >>> 2 >>> 0] = ai;
              return 0;
            }
            if (flags2 & 4) {
              return -2;
            }
            node = DNS.lookup_name(node);
            addr2 = inetPton4(node);
            if (family === 0) {
              family = 2;
            } else if (family === 10) {
              addr2 = [0, 0, _htonl(65535), addr2];
            }
            ai = allocaddrinfo(family, type, proto, null, addr2, port);
            HEAPU32[out2 >>> 2 >>> 0] = ai;
            return 0;
          }
          _getaddrinfo.sig = "ipppp";
          function _getentropy(buffer, size) {
            buffer >>>= 0;
            size >>>= 0;
            randomFill(HEAPU8.subarray(buffer >>> 0, buffer + size >>> 0));
            return 0;
          }
          _getentropy.sig = "ipp";
          function _getnameinfo(sa, salen, node, nodelen, serv, servlen, flags2) {
            sa >>>= 0;
            node >>>= 0;
            serv >>>= 0;
            var info2 = readSockaddr(sa, salen);
            if (info2.errno) {
              return -6;
            }
            var port = info2.port;
            var addr2 = info2.addr;
            var overflowed = false;
            if (node && nodelen) {
              var lookup;
              if (flags2 & 1 || !(lookup = DNS.lookup_addr(addr2))) {
                if (flags2 & 8) {
                  return -2;
                }
              } else {
                addr2 = lookup;
              }
              var numBytesWrittenExclNull = stringToUTF8(addr2, node, nodelen);
              if (numBytesWrittenExclNull + 1 >= nodelen) {
                overflowed = true;
              }
            }
            if (serv && servlen) {
              port = "" + port;
              var numBytesWrittenExclNull = stringToUTF8(port, serv, servlen);
              if (numBytesWrittenExclNull + 1 >= servlen) {
                overflowed = true;
              }
            }
            if (overflowed) {
              return -12;
            }
            return 0;
          }
          _getnameinfo.sig = "ipipipii";
          function _llvm_eh_typeid_for(type) {
            type >>>= 0;
            return type;
          }
          _llvm_eh_typeid_for.sig = "vp";
          function _pthread_kill() {
            return wasmImports["pthread_kill"].apply(null, arguments);
          }
          _pthread_kill.stub = true;
          var arraySum = (array, index) => {
            var sum2 = 0;
            for (var i2 = 0; i2 <= index; sum2 += array[i2++]) {
            }
            return sum2;
          };
          var MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
          var MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
          var addDays = (date, days) => {
            var newDate = new Date(date.getTime());
            while (days > 0) {
              var leap = isLeapYear(newDate.getFullYear());
              var currentMonth = newDate.getMonth();
              var daysInCurrentMonth = (leap ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[currentMonth];
              if (days > daysInCurrentMonth - newDate.getDate()) {
                days -= daysInCurrentMonth - newDate.getDate() + 1;
                newDate.setDate(1);
                if (currentMonth < 11) {
                  newDate.setMonth(currentMonth + 1);
                } else {
                  newDate.setMonth(0);
                  newDate.setFullYear(newDate.getFullYear() + 1);
                }
              } else {
                newDate.setDate(newDate.getDate() + days);
                return newDate;
              }
            }
            return newDate;
          };
          var writeArrayToMemory = (array, buffer) => {
            HEAP8.set(array, buffer >>> 0);
          };
          function _strftime(s2, maxsize, format, tm) {
            s2 >>>= 0;
            maxsize >>>= 0;
            format >>>= 0;
            tm >>>= 0;
            var tm_zone = HEAPU32[tm + 40 >>> 2 >>> 0];
            var date = {
              tm_sec: HEAP32[tm >>> 2 >>> 0],
              tm_min: HEAP32[tm + 4 >>> 2 >>> 0],
              tm_hour: HEAP32[tm + 8 >>> 2 >>> 0],
              tm_mday: HEAP32[tm + 12 >>> 2 >>> 0],
              tm_mon: HEAP32[tm + 16 >>> 2 >>> 0],
              tm_year: HEAP32[tm + 20 >>> 2 >>> 0],
              tm_wday: HEAP32[tm + 24 >>> 2 >>> 0],
              tm_yday: HEAP32[tm + 28 >>> 2 >>> 0],
              tm_isdst: HEAP32[tm + 32 >>> 2 >>> 0],
              tm_gmtoff: HEAP32[tm + 36 >>> 2 >>> 0],
              tm_zone: tm_zone ? UTF8ToString(tm_zone) : ""
            };
            var pattern = UTF8ToString(format);
            var EXPANSION_RULES_1 = {
              "%c": "%a %b %d %H:%M:%S %Y",
              "%D": "%m/%d/%y",
              "%F": "%Y-%m-%d",
              "%h": "%b",
              "%r": "%I:%M:%S %p",
              "%R": "%H:%M",
              "%T": "%H:%M:%S",
              "%x": "%m/%d/%y",
              "%X": "%H:%M:%S",
              "%Ec": "%c",
              "%EC": "%C",
              "%Ex": "%m/%d/%y",
              "%EX": "%H:%M:%S",
              "%Ey": "%y",
              "%EY": "%Y",
              "%Od": "%d",
              "%Oe": "%e",
              "%OH": "%H",
              "%OI": "%I",
              "%Om": "%m",
              "%OM": "%M",
              "%OS": "%S",
              "%Ou": "%u",
              "%OU": "%U",
              "%OV": "%V",
              "%Ow": "%w",
              "%OW": "%W",
              "%Oy": "%y"
            };
            for (var rule in EXPANSION_RULES_1) {
              pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_1[rule]);
            }
            var WEEKDAYS = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
            var MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
            function leadingSomething(value, digits, character) {
              var str = typeof value == "number" ? value.toString() : value || "";
              while (str.length < digits) {
                str = character[0] + str;
              }
              return str;
            }
            function leadingNulls(value, digits) {
              return leadingSomething(value, digits, "0");
            }
            function compareByDay(date1, date2) {
              function sgn(value) {
                return value < 0 ? -1 : value > 0 ? 1 : 0;
              }
              var compare;
              if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {
                if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {
                  compare = sgn(date1.getDate() - date2.getDate());
                }
              }
              return compare;
            }
            function getFirstWeekStartDate(janFourth) {
              switch (janFourth.getDay()) {
                case 0:
                  return new Date(janFourth.getFullYear() - 1, 11, 29);
                case 1:
                  return janFourth;
                case 2:
                  return new Date(janFourth.getFullYear(), 0, 3);
                case 3:
                  return new Date(janFourth.getFullYear(), 0, 2);
                case 4:
                  return new Date(janFourth.getFullYear(), 0, 1);
                case 5:
                  return new Date(janFourth.getFullYear() - 1, 11, 31);
                case 6:
                  return new Date(janFourth.getFullYear() - 1, 11, 30);
              }
            }
            function getWeekBasedYear(date2) {
              var thisDate = addDays(new Date(date2.tm_year + 1900, 0, 1), date2.tm_yday);
              var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);
              var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);
              var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
              var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
              if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {
                if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {
                  return thisDate.getFullYear() + 1;
                }
                return thisDate.getFullYear();
              }
              return thisDate.getFullYear() - 1;
            }
            var EXPANSION_RULES_2 = {
              "%a": (date2) => WEEKDAYS[date2.tm_wday].substring(0, 3),
              "%A": (date2) => WEEKDAYS[date2.tm_wday],
              "%b": (date2) => MONTHS[date2.tm_mon].substring(0, 3),
              "%B": (date2) => MONTHS[date2.tm_mon],
              "%C": (date2) => {
                var year = date2.tm_year + 1900;
                return leadingNulls(year / 100 | 0, 2);
              },
              "%d": (date2) => leadingNulls(date2.tm_mday, 2),
              "%e": (date2) => leadingSomething(date2.tm_mday, 2, " "),
              "%g": (date2) => getWeekBasedYear(date2).toString().substring(2),
              "%G": getWeekBasedYear,
              "%H": (date2) => leadingNulls(date2.tm_hour, 2),
              "%I": (date2) => {
                var twelveHour = date2.tm_hour;
                if (twelveHour == 0)
                  twelveHour = 12;
                else if (twelveHour > 12)
                  twelveHour -= 12;
                return leadingNulls(twelveHour, 2);
              },
              "%j": (date2) => leadingNulls(date2.tm_mday + arraySum(isLeapYear(date2.tm_year + 1900) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, date2.tm_mon - 1), 3),
              "%m": (date2) => leadingNulls(date2.tm_mon + 1, 2),
              "%M": (date2) => leadingNulls(date2.tm_min, 2),
              "%n": () => "\n",
              "%p": (date2) => {
                if (date2.tm_hour >= 0 && date2.tm_hour < 12) {
                  return "AM";
                }
                return "PM";
              },
              "%S": (date2) => leadingNulls(date2.tm_sec, 2),
              "%t": () => "	",
              "%u": (date2) => date2.tm_wday || 7,
              "%U": (date2) => {
                var days = date2.tm_yday + 7 - date2.tm_wday;
                return leadingNulls(Math.floor(days / 7), 2);
              },
              "%V": (date2) => {
                var val = Math.floor((date2.tm_yday + 7 - (date2.tm_wday + 6) % 7) / 7);
                if ((date2.tm_wday + 371 - date2.tm_yday - 2) % 7 <= 2) {
                  val++;
                }
                if (!val) {
                  val = 52;
                  var dec31 = (date2.tm_wday + 7 - date2.tm_yday - 1) % 7;
                  if (dec31 == 4 || dec31 == 5 && isLeapYear(date2.tm_year % 400 - 1)) {
                    val++;
                  }
                } else if (val == 53) {
                  var jan1 = (date2.tm_wday + 371 - date2.tm_yday) % 7;
                  if (jan1 != 4 && (jan1 != 3 || !isLeapYear(date2.tm_year)))
                    val = 1;
                }
                return leadingNulls(val, 2);
              },
              "%w": (date2) => date2.tm_wday,
              "%W": (date2) => {
                var days = date2.tm_yday + 7 - (date2.tm_wday + 6) % 7;
                return leadingNulls(Math.floor(days / 7), 2);
              },
              "%y": (date2) => (date2.tm_year + 1900).toString().substring(2),
              "%Y": (date2) => date2.tm_year + 1900,
              "%z": (date2) => {
                var off = date2.tm_gmtoff;
                var ahead = off >= 0;
                off = Math.abs(off) / 60;
                off = off / 60 * 100 + off % 60;
                return (ahead ? "+" : "-") + String("0000" + off).slice(-4);
              },
              "%Z": (date2) => date2.tm_zone,
              "%%": () => "%"
            };
            pattern = pattern.replace(/%%/g, "\0\0");
            for (var rule in EXPANSION_RULES_2) {
              if (pattern.includes(rule)) {
                pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_2[rule](date));
              }
            }
            pattern = pattern.replace(/\0\0/g, "%");
            var bytes = intArrayFromString(pattern, false);
            if (bytes.length > maxsize) {
              return 0;
            }
            writeArrayToMemory(bytes, s2);
            return bytes.length - 1;
          }
          _strftime.sig = "ppppp";
          function _strftime_l(s2, maxsize, format, tm, loc) {
            s2 >>>= 0;
            maxsize >>>= 0;
            format >>>= 0;
            tm >>>= 0;
            loc >>>= 0;
            return _strftime(s2, maxsize, format, tm);
          }
          _strftime_l.sig = "pppppp";
          function _strptime(buf, format, tm) {
            buf >>>= 0;
            format >>>= 0;
            tm >>>= 0;
            var pattern = UTF8ToString(format);
            var SPECIAL_CHARS = "\\!@#$^&*()+=-[]/{}|:<>?,.";
            for (var i2 = 0, ii = SPECIAL_CHARS.length; i2 < ii; ++i2) {
              pattern = pattern.replace(new RegExp("\\" + SPECIAL_CHARS[i2], "g"), "\\" + SPECIAL_CHARS[i2]);
            }
            var EQUIVALENT_MATCHERS = {
              "A": "%a",
              "B": "%b",
              "c": "%a %b %d %H:%M:%S %Y",
              "D": "%m\\/%d\\/%y",
              "e": "%d",
              "F": "%Y-%m-%d",
              "h": "%b",
              "R": "%H\\:%M",
              "r": "%I\\:%M\\:%S\\s%p",
              "T": "%H\\:%M\\:%S",
              "x": "%m\\/%d\\/(?:%y|%Y)",
              "X": "%H\\:%M\\:%S"
            };
            var DATE_PATTERNS = {
              "a": "(?:Sun(?:day)?)|(?:Mon(?:day)?)|(?:Tue(?:sday)?)|(?:Wed(?:nesday)?)|(?:Thu(?:rsday)?)|(?:Fri(?:day)?)|(?:Sat(?:urday)?)",
              "b": "(?:Jan(?:uary)?)|(?:Feb(?:ruary)?)|(?:Mar(?:ch)?)|(?:Apr(?:il)?)|May|(?:Jun(?:e)?)|(?:Jul(?:y)?)|(?:Aug(?:ust)?)|(?:Sep(?:tember)?)|(?:Oct(?:ober)?)|(?:Nov(?:ember)?)|(?:Dec(?:ember)?)",
              "C": "\\d\\d",
              "d": "0[1-9]|[1-9](?!\\d)|1\\d|2\\d|30|31",
              "H": "\\d(?!\\d)|[0,1]\\d|20|21|22|23",
              "I": "\\d(?!\\d)|0\\d|10|11|12",
              "j": "00[1-9]|0?[1-9](?!\\d)|0?[1-9]\\d(?!\\d)|[1,2]\\d\\d|3[0-6]\\d",
              "m": "0[1-9]|[1-9](?!\\d)|10|11|12",
              "M": "0\\d|\\d(?!\\d)|[1-5]\\d",
              "n": " ",
              "p": "AM|am|PM|pm|A\\.M\\.|a\\.m\\.|P\\.M\\.|p\\.m\\.",
              "S": "0\\d|\\d(?!\\d)|[1-5]\\d|60",
              "U": "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
              "W": "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
              "w": "[0-6]",
              "y": "\\d\\d",
              "Y": "\\d\\d\\d\\d",
              "t": " ",
              "z": "Z|(?:[\\+\\-]\\d\\d:?(?:\\d\\d)?)"
            };
            var MONTH_NUMBERS = {
              JAN: 0,
              FEB: 1,
              MAR: 2,
              APR: 3,
              MAY: 4,
              JUN: 5,
              JUL: 6,
              AUG: 7,
              SEP: 8,
              OCT: 9,
              NOV: 10,
              DEC: 11
            };
            var DAY_NUMBERS_SUN_FIRST = {
              SUN: 0,
              MON: 1,
              TUE: 2,
              WED: 3,
              THU: 4,
              FRI: 5,
              SAT: 6
            };
            var DAY_NUMBERS_MON_FIRST = {
              MON: 0,
              TUE: 1,
              WED: 2,
              THU: 3,
              FRI: 4,
              SAT: 5,
              SUN: 6
            };
            var capture = [];
            var pattern_out = pattern.replace(/%(.)/g, (m, c) => EQUIVALENT_MATCHERS[c] || m).replace(/%(.)/g, (_, c) => {
              let pat = DATE_PATTERNS[c];
              if (pat) {
                capture.push(c);
                return `(${pat})`;
              } else {
                return c;
              }
            }).replace(/\s+/g, "\\s*");
            var matches = new RegExp("^" + pattern_out, "i").exec(UTF8ToString(buf));
            function initDate() {
              function fixup(value2, min, max) {
                return typeof value2 != "number" || isNaN(value2) ? min : value2 >= min ? value2 <= max ? value2 : max : min;
              }
              return {
                year: fixup(HEAP32[tm + 20 >>> 2 >>> 0] + 1900, 1970, 9999),
                month: fixup(HEAP32[tm + 16 >>> 2 >>> 0], 0, 11),
                day: fixup(HEAP32[tm + 12 >>> 2 >>> 0], 1, 31),
                hour: fixup(HEAP32[tm + 8 >>> 2 >>> 0], 0, 23),
                min: fixup(HEAP32[tm + 4 >>> 2 >>> 0], 0, 59),
                sec: fixup(HEAP32[tm >>> 2 >>> 0], 0, 59),
                gmtoff: 0
              };
            }
            if (matches) {
              var date = initDate();
              var value;
              var getMatch = (symbol) => {
                var pos = capture.indexOf(symbol);
                if (pos >= 0) {
                  return matches[pos + 1];
                }
                return;
              };
              if (value = getMatch("S")) {
                date.sec = jstoi_q(value);
              }
              if (value = getMatch("M")) {
                date.min = jstoi_q(value);
              }
              if (value = getMatch("H")) {
                date.hour = jstoi_q(value);
              } else if (value = getMatch("I")) {
                var hour = jstoi_q(value);
                if (value = getMatch("p")) {
                  hour += value.toUpperCase()[0] === "P" ? 12 : 0;
                }
                date.hour = hour;
              }
              if (value = getMatch("Y")) {
                date.year = jstoi_q(value);
              } else if (value = getMatch("y")) {
                var year = jstoi_q(value);
                if (value = getMatch("C")) {
                  year += jstoi_q(value) * 100;
                } else {
                  year += year < 69 ? 2e3 : 1900;
                }
                date.year = year;
              }
              if (value = getMatch("m")) {
                date.month = jstoi_q(value) - 1;
              } else if (value = getMatch("b")) {
                date.month = MONTH_NUMBERS[value.substring(0, 3).toUpperCase()] || 0;
              }
              if (value = getMatch("d")) {
                date.day = jstoi_q(value);
              } else if (value = getMatch("j")) {
                var day = jstoi_q(value);
                var leapYear = isLeapYear(date.year);
                for (var month = 0; month < 12; ++month) {
                  var daysUntilMonth = arraySum(leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, month - 1);
                  if (day <= daysUntilMonth + (leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[month]) {
                    date.day = day - daysUntilMonth;
                  }
                }
              } else if (value = getMatch("a")) {
                var weekDay = value.substring(0, 3).toUpperCase();
                if (value = getMatch("U")) {
                  var weekDayNumber = DAY_NUMBERS_SUN_FIRST[weekDay];
                  var weekNumber = jstoi_q(value);
                  var janFirst = new Date(date.year, 0, 1);
                  var endDate;
                  if (janFirst.getDay() === 0) {
                    endDate = addDays(janFirst, weekDayNumber + 7 * (weekNumber - 1));
                  } else {
                    endDate = addDays(janFirst, 7 - janFirst.getDay() + weekDayNumber + 7 * (weekNumber - 1));
                  }
                  date.day = endDate.getDate();
                  date.month = endDate.getMonth();
                } else if (value = getMatch("W")) {
                  var weekDayNumber = DAY_NUMBERS_MON_FIRST[weekDay];
                  var weekNumber = jstoi_q(value);
                  var janFirst = new Date(date.year, 0, 1);
                  var endDate;
                  if (janFirst.getDay() === 1) {
                    endDate = addDays(janFirst, weekDayNumber + 7 * (weekNumber - 1));
                  } else {
                    endDate = addDays(janFirst, 7 - janFirst.getDay() + 1 + weekDayNumber + 7 * (weekNumber - 1));
                  }
                  date.day = endDate.getDate();
                  date.month = endDate.getMonth();
                }
              }
              if (value = getMatch("z")) {
                if (value.toLowerCase() === "z") {
                  date.gmtoff = 0;
                } else {
                  var match = value.match(/^((?:\-|\+)\d\d):?(\d\d)?/);
                  date.gmtoff = match[1] * 3600;
                  if (match[2]) {
                    date.gmtoff += date.gmtoff > 0 ? match[2] * 60 : -match[2] * 60;
                  }
                }
              }
              var fullDate = new Date(date.year, date.month, date.day, date.hour, date.min, date.sec, 0);
              HEAP32[tm >>> 2 >>> 0] = fullDate.getSeconds();
              HEAP32[tm + 4 >>> 2 >>> 0] = fullDate.getMinutes();
              HEAP32[tm + 8 >>> 2 >>> 0] = fullDate.getHours();
              HEAP32[tm + 12 >>> 2 >>> 0] = fullDate.getDate();
              HEAP32[tm + 16 >>> 2 >>> 0] = fullDate.getMonth();
              HEAP32[tm + 20 >>> 2 >>> 0] = fullDate.getFullYear() - 1900;
              HEAP32[tm + 24 >>> 2 >>> 0] = fullDate.getDay();
              HEAP32[tm + 28 >>> 2 >>> 0] = arraySum(isLeapYear(fullDate.getFullYear()) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, fullDate.getMonth() - 1) + fullDate.getDate() - 1;
              HEAP32[tm + 32 >>> 2 >>> 0] = 0;
              HEAP32[tm + 36 >>> 2 >>> 0] = date.gmtoff;
              return buf + intArrayFromString(matches[0]).length - 1;
            }
            return 0;
          }
          _strptime.sig = "pppp";
          var getCFunc = (ident) => {
            var func2 = Module["_" + ident];
            return func2;
          };
          var ccall = (ident, returnType, argTypes, args2, opts) => {
            var toC = {
              "string": (str) => {
                var ret2 = 0;
                if (str !== null && str !== void 0 && str !== 0) {
                  ret2 = stringToUTF8OnStack(str);
                }
                return ret2;
              },
              "array": (arr) => {
                var ret2 = stackAlloc(arr.length);
                writeArrayToMemory(arr, ret2);
                return ret2;
              }
            };
            function convertReturnValue(ret2) {
              if (returnType === "string") {
                return UTF8ToString(ret2);
              }
              if (returnType === "boolean")
                return Boolean(ret2);
              return ret2;
            }
            var func2 = getCFunc(ident);
            var cArgs = [];
            var stack = 0;
            if (args2) {
              for (var i2 = 0; i2 < args2.length; i2++) {
                var converter = toC[argTypes[i2]];
                if (converter) {
                  if (stack === 0)
                    stack = stackSave();
                  cArgs[i2] = converter(args2[i2]);
                } else {
                  cArgs[i2] = args2[i2];
                }
              }
            }
            var ret = func2.apply(null, cArgs);
            function onDone(ret2) {
              if (stack !== 0)
                stackRestore(stack);
              return convertReturnValue(ret2);
            }
            ret = onDone(ret);
            return ret;
          };
          var writeI53ToI64Clamped = (ptr2, num) => {
            if (num > 9223372036854776e3) {
              HEAPU32[ptr2 >>> 2 >>> 0] = 4294967295;
              HEAPU32[ptr2 + 4 >>> 2 >>> 0] = 2147483647;
            } else if (num < -9223372036854776e3) {
              HEAPU32[ptr2 >>> 2 >>> 0] = 0;
              HEAPU32[ptr2 + 4 >>> 2 >>> 0] = 2147483648;
            } else {
              writeI53ToI64(ptr2, num);
            }
          };
          var writeI53ToI64Signaling = (ptr2, num) => {
            if (num > 9223372036854776e3 || num < -9223372036854776e3) {
              throw `RangeError: ${num}`;
            }
            writeI53ToI64(ptr2, num);
          };
          var writeI53ToU64Clamped = (ptr2, num) => {
            if (num > 18446744073709552e3) {
              HEAPU32[ptr2 >>> 2 >>> 0] = 4294967295;
              HEAPU32[ptr2 + 4 >>> 2 >>> 0] = 4294967295;
            } else if (num < 0) {
              HEAPU32[ptr2 >>> 2 >>> 0] = 0;
              HEAPU32[ptr2 + 4 >>> 2 >>> 0] = 0;
            } else {
              writeI53ToI64(ptr2, num);
            }
          };
          var writeI53ToU64Signaling = (ptr2, num) => {
            if (num < 0 || num > 18446744073709552e3) {
              throw `RangeError: ${num}`;
            }
            writeI53ToI64(ptr2, num);
          };
          var readI53FromU64 = (ptr2) => HEAPU32[ptr2 >>> 2 >>> 0] + HEAPU32[ptr2 + 4 >>> 2 >>> 0] * 4294967296;
          var convertI32PairToI53 = (lo, hi) => (lo >>> 0) + hi * 4294967296;
          var convertU32PairToI53 = (lo, hi) => (lo >>> 0) + (hi >>> 0) * 4294967296;
          var ptrToString = (ptr2) => "0x" + ptr2.toString(16).padStart(8, "0");
          function _emscripten_notify_memory_growth(memoryIndex) {
            memoryIndex >>>= 0;
            updateMemoryViews();
          }
          _emscripten_notify_memory_growth.sig = "vp";
          function ___asctime_r(tmPtr, buf) {
            tmPtr >>>= 0;
            buf >>>= 0;
            var date = {
              tm_sec: HEAP32[tmPtr >>> 2 >>> 0],
              tm_min: HEAP32[tmPtr + 4 >>> 2 >>> 0],
              tm_hour: HEAP32[tmPtr + 8 >>> 2 >>> 0],
              tm_mday: HEAP32[tmPtr + 12 >>> 2 >>> 0],
              tm_mon: HEAP32[tmPtr + 16 >>> 2 >>> 0],
              tm_year: HEAP32[tmPtr + 20 >>> 2 >>> 0],
              tm_wday: HEAP32[tmPtr + 24 >>> 2 >>> 0]
            };
            var days = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
            var months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
            var s2 = days[date.tm_wday] + " " + months[date.tm_mon] + (date.tm_mday < 10 ? "  " : " ") + date.tm_mday + (date.tm_hour < 10 ? " 0" : " ") + date.tm_hour + (date.tm_min < 10 ? ":0" : ":") + date.tm_min + (date.tm_sec < 10 ? ":0" : ":") + date.tm_sec + " " + (1900 + date.tm_year) + "\n";
            stringToUTF8(s2, buf, 26);
            return buf;
          }
          ___asctime_r.sig = "ppp";
          function _strptime_l(buf, format, tm, locale) {
            buf >>>= 0;
            format >>>= 0;
            tm >>>= 0;
            locale >>>= 0;
            return _strptime(buf, format, tm);
          }
          _strptime_l.sig = "ppppp";
          var ERRNO_CODES = {
            "EPERM": 63,
            "ENOENT": 44,
            "ESRCH": 71,
            "EINTR": 27,
            "EIO": 29,
            "ENXIO": 60,
            "E2BIG": 1,
            "ENOEXEC": 45,
            "EBADF": 8,
            "ECHILD": 12,
            "EAGAIN": 6,
            "EWOULDBLOCK": 6,
            "ENOMEM": 48,
            "EACCES": 2,
            "EFAULT": 21,
            "ENOTBLK": 105,
            "EBUSY": 10,
            "EEXIST": 20,
            "EXDEV": 75,
            "ENODEV": 43,
            "ENOTDIR": 54,
            "EISDIR": 31,
            "EINVAL": 28,
            "ENFILE": 41,
            "EMFILE": 33,
            "ENOTTY": 59,
            "ETXTBSY": 74,
            "EFBIG": 22,
            "ENOSPC": 51,
            "ESPIPE": 70,
            "EROFS": 69,
            "EMLINK": 34,
            "EPIPE": 64,
            "EDOM": 18,
            "ERANGE": 68,
            "ENOMSG": 49,
            "EIDRM": 24,
            "ECHRNG": 106,
            "EL2NSYNC": 156,
            "EL3HLT": 107,
            "EL3RST": 108,
            "ELNRNG": 109,
            "EUNATCH": 110,
            "ENOCSI": 111,
            "EL2HLT": 112,
            "EDEADLK": 16,
            "ENOLCK": 46,
            "EBADE": 113,
            "EBADR": 114,
            "EXFULL": 115,
            "ENOANO": 104,
            "EBADRQC": 103,
            "EBADSLT": 102,
            "EDEADLOCK": 16,
            "EBFONT": 101,
            "ENOSTR": 100,
            "ENODATA": 116,
            "ETIME": 117,
            "ENOSR": 118,
            "ENONET": 119,
            "ENOPKG": 120,
            "EREMOTE": 121,
            "ENOLINK": 47,
            "EADV": 122,
            "ESRMNT": 123,
            "ECOMM": 124,
            "EPROTO": 65,
            "EMULTIHOP": 36,
            "EDOTDOT": 125,
            "EBADMSG": 9,
            "ENOTUNIQ": 126,
            "EBADFD": 127,
            "EREMCHG": 128,
            "ELIBACC": 129,
            "ELIBBAD": 130,
            "ELIBSCN": 131,
            "ELIBMAX": 132,
            "ELIBEXEC": 133,
            "ENOSYS": 52,
            "ENOTEMPTY": 55,
            "ENAMETOOLONG": 37,
            "ELOOP": 32,
            "EOPNOTSUPP": 138,
            "EPFNOSUPPORT": 139,
            "ECONNRESET": 15,
            "ENOBUFS": 42,
            "EAFNOSUPPORT": 5,
            "EPROTOTYPE": 67,
            "ENOTSOCK": 57,
            "ENOPROTOOPT": 50,
            "ESHUTDOWN": 140,
            "ECONNREFUSED": 14,
            "EADDRINUSE": 3,
            "ECONNABORTED": 13,
            "ENETUNREACH": 40,
            "ENETDOWN": 38,
            "ETIMEDOUT": 73,
            "EHOSTDOWN": 142,
            "EHOSTUNREACH": 23,
            "EINPROGRESS": 26,
            "EALREADY": 7,
            "EDESTADDRREQ": 17,
            "EMSGSIZE": 35,
            "EPROTONOSUPPORT": 66,
            "ESOCKTNOSUPPORT": 137,
            "EADDRNOTAVAIL": 4,
            "ENETRESET": 39,
            "EISCONN": 30,
            "ENOTCONN": 53,
            "ETOOMANYREFS": 141,
            "EUSERS": 136,
            "EDQUOT": 19,
            "ESTALE": 72,
            "ENOTSUP": 138,
            "ENOMEDIUM": 148,
            "EILSEQ": 25,
            "EOVERFLOW": 61,
            "ECANCELED": 11,
            "ENOTRECOVERABLE": 56,
            "EOWNERDEAD": 62,
            "ESTRPIPE": 135
          };
          var ERRNO_MESSAGES = {
            0: "Success",
            1: "Arg list too long",
            2: "Permission denied",
            3: "Address already in use",
            4: "Address not available",
            5: "Address family not supported by protocol family",
            6: "No more processes",
            7: "Socket already connected",
            8: "Bad file number",
            9: "Trying to read unreadable message",
            10: "Mount device busy",
            11: "Operation canceled",
            12: "No children",
            13: "Connection aborted",
            14: "Connection refused",
            15: "Connection reset by peer",
            16: "File locking deadlock error",
            17: "Destination address required",
            18: "Math arg out of domain of func",
            19: "Quota exceeded",
            20: "File exists",
            21: "Bad address",
            22: "File too large",
            23: "Host is unreachable",
            24: "Identifier removed",
            25: "Illegal byte sequence",
            26: "Connection already in progress",
            27: "Interrupted system call",
            28: "Invalid argument",
            29: "I/O error",
            30: "Socket is already connected",
            31: "Is a directory",
            32: "Too many symbolic links",
            33: "Too many open files",
            34: "Too many links",
            35: "Message too long",
            36: "Multihop attempted",
            37: "File or path name too long",
            38: "Network interface is not configured",
            39: "Connection reset by network",
            40: "Network is unreachable",
            41: "Too many open files in system",
            42: "No buffer space available",
            43: "No such device",
            44: "No such file or directory",
            45: "Exec format error",
            46: "No record locks available",
            47: "The link has been severed",
            48: "Not enough core",
            49: "No message of desired type",
            50: "Protocol not available",
            51: "No space left on device",
            52: "Function not implemented",
            53: "Socket is not connected",
            54: "Not a directory",
            55: "Directory not empty",
            56: "State not recoverable",
            57: "Socket operation on non-socket",
            59: "Not a typewriter",
            60: "No such device or address",
            61: "Value too large for defined data type",
            62: "Previous owner died",
            63: "Not super-user",
            64: "Broken pipe",
            65: "Protocol error",
            66: "Unknown protocol",
            67: "Protocol wrong type for socket",
            68: "Math result not representable",
            69: "Read only file system",
            70: "Illegal seek",
            71: "No such process",
            72: "Stale file handle",
            73: "Connection timed out",
            74: "Text file busy",
            75: "Cross-device link",
            100: "Device not a stream",
            101: "Bad font file fmt",
            102: "Invalid slot",
            103: "Invalid request code",
            104: "No anode",
            105: "Block device required",
            106: "Channel number out of range",
            107: "Level 3 halted",
            108: "Level 3 reset",
            109: "Link number out of range",
            110: "Protocol driver not attached",
            111: "No CSI structure available",
            112: "Level 2 halted",
            113: "Invalid exchange",
            114: "Invalid request descriptor",
            115: "Exchange full",
            116: "No data (for no delay io)",
            117: "Timer expired",
            118: "Out of streams resources",
            119: "Machine is not on the network",
            120: "Package not installed",
            121: "The object is remote",
            122: "Advertise error",
            123: "Srmount error",
            124: "Communication error on send",
            125: "Cross mount point (not really error)",
            126: "Given log. name not unique",
            127: "f.d. invalid for this operation",
            128: "Remote address changed",
            129: "Can   access a needed shared lib",
            130: "Accessing a corrupted shared lib",
            131: ".lib section in a.out corrupted",
            132: "Attempting to link in too many libs",
            133: "Attempting to exec a shared library",
            135: "Streams pipe error",
            136: "Too many users",
            137: "Socket type not supported",
            138: "Not supported",
            139: "Protocol family not supported",
            140: "Can't send after socket shutdown",
            141: "Too many references",
            142: "Host is down",
            148: "No medium (in tape drive)",
            156: "Level 2 not synchronized"
          };
          var Protocols = {
            list: [],
            map: {}
          };
          var _setprotoent = (stayopen) => {
            function allocprotoent(name2, proto, aliases) {
              var nameBuf = _malloc(name2.length + 1);
              stringToAscii(name2, nameBuf);
              var j = 0;
              var length = aliases.length;
              var aliasListBuf = _malloc((length + 1) * 4);
              for (var i2 = 0; i2 < length; i2++, j += 4) {
                var alias = aliases[i2];
                var aliasBuf = _malloc(alias.length + 1);
                stringToAscii(alias, aliasBuf);
                HEAPU32[aliasListBuf + j >>> 2 >>> 0] = aliasBuf;
              }
              HEAPU32[aliasListBuf + j >>> 2 >>> 0] = 0;
              var pe = _malloc(12);
              HEAPU32[pe >>> 2 >>> 0] = nameBuf;
              HEAPU32[pe + 4 >>> 2 >>> 0] = aliasListBuf;
              HEAP32[pe + 8 >>> 2 >>> 0] = proto;
              return pe;
            }
            var list = Protocols.list;
            var map = Protocols.map;
            if (list.length === 0) {
              var entry = allocprotoent("tcp", 6, ["TCP"]);
              list.push(entry);
              map["tcp"] = map["6"] = entry;
              entry = allocprotoent("udp", 17, ["UDP"]);
              list.push(entry);
              map["udp"] = map["17"] = entry;
            }
            _setprotoent.index = 0;
          };
          _setprotoent.sig = "vi";
          var _endprotoent = () => {
          };
          _endprotoent.sig = "v";
          function _getprotoent(number) {
            if (_setprotoent.index === Protocols.list.length) {
              return 0;
            }
            var result = Protocols.list[_setprotoent.index++];
            return result;
          }
          _getprotoent.sig = "p";
          function _getprotobyname(name2) {
            name2 >>>= 0;
            name2 = UTF8ToString(name2);
            _setprotoent(true);
            var result = Protocols.map[name2];
            return result;
          }
          _getprotobyname.sig = "pp";
          function _getprotobynumber(number) {
            _setprotoent(true);
            var result = Protocols.map[number];
            return result;
          }
          _getprotobynumber.sig = "pi";
          function _emscripten_run_script(ptr) {
            ptr >>>= 0;
            eval(UTF8ToString(ptr));
          }
          _emscripten_run_script.sig = "vp";
          function _emscripten_run_script_int(ptr) {
            ptr >>>= 0;
            return eval(UTF8ToString(ptr)) | 0;
          }
          _emscripten_run_script_int.sig = "ip";
          function _emscripten_run_script_string(ptr) {
            ptr >>>= 0;
            var s = eval(UTF8ToString(ptr));
            if (s == null) {
              return 0;
            }
            s += "";
            var me = _emscripten_run_script_string;
            var len = lengthBytesUTF8(s);
            if (!me.bufferSize || me.bufferSize < len + 1) {
              if (me.bufferSize)
                _free(me.buffer);
              me.bufferSize = len + 1;
              me.buffer = _malloc(me.bufferSize);
            }
            stringToUTF8(s, me.buffer, me.bufferSize);
            return me.buffer;
          }
          _emscripten_run_script_string.sig = "pp";
          var _emscripten_random = () => Math.random();
          _emscripten_random.sig = "f";
          function jsStackTrace() {
            var error = new Error();
            if (!error.stack) {
              try {
                throw new Error();
              } catch (e) {
                error = e;
              }
              if (!error.stack) {
                return "(no stack trace available)";
              }
            }
            return error.stack.toString();
          }
          function getCallstack(flags2) {
            var callstack = jsStackTrace();
            var iThisFunc = callstack.lastIndexOf("_emscripten_log");
            var iThisFunc2 = callstack.lastIndexOf("_emscripten_get_callstack");
            var iNextLine = callstack.indexOf("\n", Math.max(iThisFunc, iThisFunc2)) + 1;
            callstack = callstack.slice(iNextLine);
            if (flags2 & 8 && typeof emscripten_source_map == "undefined") {
              warnOnce('Source map information is not available, emscripten_log with EM_LOG_C_STACK will be ignored. Build with "--pre-js $EMSCRIPTEN/src/emscripten-source-map.min.js" linker flag to add source map loading to code.');
              flags2 ^= 8;
              flags2 |= 16;
            }
            var lines = callstack.split("\n");
            callstack = "";
            var newFirefoxRe = new RegExp("\\s*(.*?)@(.*?):([0-9]+):([0-9]+)");
            var firefoxRe = new RegExp("\\s*(.*?)@(.*):(.*)(:(.*))?");
            var chromeRe = new RegExp("\\s*at (.*?) \\((.*):(.*):(.*)\\)");
            for (var l in lines) {
              var line = lines[l];
              var symbolName = "";
              var file = "";
              var lineno = 0;
              var column = 0;
              var parts2 = chromeRe.exec(line);
              if (parts2 && parts2.length == 5) {
                symbolName = parts2[1];
                file = parts2[2];
                lineno = parts2[3];
                column = parts2[4];
              } else {
                parts2 = newFirefoxRe.exec(line);
                if (!parts2)
                  parts2 = firefoxRe.exec(line);
                if (parts2 && parts2.length >= 4) {
                  symbolName = parts2[1];
                  file = parts2[2];
                  lineno = parts2[3];
                  column = parts2[4] | 0;
                } else {
                  callstack += line + "\n";
                  continue;
                }
              }
              var haveSourceMap = false;
              if (flags2 & 8) {
                var orig = emscripten_source_map.originalPositionFor({
                  line: lineno,
                  column
                });
                haveSourceMap = orig?.source;
                if (haveSourceMap) {
                  if (flags2 & 64) {
                    orig.source = orig.source.substring(orig.source.replace(/\\/g, "/").lastIndexOf("/") + 1);
                  }
                  callstack += `    at ${symbolName} (${orig.source}:${orig.line}:${orig.column})
`;
                }
              }
              if (flags2 & 16 || !haveSourceMap) {
                if (flags2 & 64) {
                  file = file.substring(file.replace(/\\/g, "/").lastIndexOf("/") + 1);
                }
                callstack += (haveSourceMap ? `     = ${symbolName}` : `    at ${symbolName}`) + ` (${file}:${lineno}:${column})
`;
              }
            }
            callstack = callstack.replace(/\s+$/, "");
            return callstack;
          }
          function _emscripten_get_callstack(flags2, str, maxbytes) {
            str >>>= 0;
            var callstack = getCallstack(flags2);
            if (!str || maxbytes <= 0) {
              return lengthBytesUTF8(callstack) + 1;
            }
            var bytesWrittenExcludingNull = stringToUTF8(callstack, str, maxbytes);
            return bytesWrittenExcludingNull + 1;
          }
          _emscripten_get_callstack.sig = "iipi";
          var emscriptenLog = (flags2, str) => {
            if (flags2 & 24) {
              str = str.replace(/\s+$/, "");
              str += (str.length > 0 ? "\n" : "") + getCallstack(flags2);
            }
            if (flags2 & 1) {
              if (flags2 & 4) {
                console.error(str);
              } else if (flags2 & 2) {
                console.warn(str);
              } else if (flags2 & 512) {
                console.info(str);
              } else if (flags2 & 256) {
                console.debug(str);
              } else {
                console.log(str);
              }
            } else if (flags2 & 6) {
              err(str);
            } else {
              out(str);
            }
          };
          var reallyNegative = (x) => x < 0 || x === 0 && 1 / x === -Infinity;
          var reSign = (value, bits) => {
            if (value <= 0) {
              return value;
            }
            var half = bits <= 32 ? Math.abs(1 << bits - 1) : Math.pow(2, bits - 1);
            if (value >= half && (bits <= 32 || value > half)) {
              value = -2 * half + value;
            }
            return value;
          };
          var unSign = (value, bits) => {
            if (value >= 0) {
              return value;
            }
            return bits <= 32 ? 2 * Math.abs(1 << bits - 1) + value : Math.pow(2, bits) + value;
          };
          var strLen = (ptr2) => {
            var end = ptr2;
            while (HEAPU8[end >>> 0])
              ++end;
            return end - ptr2;
          };
          var formatString = (format, varargs) => {
            var textIndex = format;
            var argIndex = varargs;
            function prepVararg(ptr3, type) {
              if (type === "double" || type === "i64") {
                if (ptr3 & 7) {
                  ptr3 += 4;
                }
              } else {
              }
              return ptr3;
            }
            function getNextArg(type) {
              var ret2;
              argIndex = prepVararg(argIndex, type);
              if (type === "double") {
                ret2 = HEAPF64[argIndex >>> 3 >>> 0];
                argIndex += 8;
              } else if (type == "i64") {
                ret2 = [HEAP32[argIndex >>> 2 >>> 0], HEAP32[argIndex + 4 >>> 2 >>> 0]];
                argIndex += 8;
              } else {
                type = "i32";
                ret2 = HEAP32[argIndex >>> 2 >>> 0];
                argIndex += 4;
              }
              return ret2;
            }
            var ret = [];
            var curr, next, currArg;
            while (1) {
              var startTextIndex = textIndex;
              curr = HEAP8[textIndex >>> 0 >>> 0];
              if (curr === 0)
                break;
              next = HEAP8[textIndex + 1 >>> 0 >>> 0];
              if (curr == 37) {
                var flagAlwaysSigned = false;
                var flagLeftAlign = false;
                var flagAlternative = false;
                var flagZeroPad = false;
                var flagPadSign = false;
                flagsLoop:
                  while (1) {
                    switch (next) {
                      case 43:
                        flagAlwaysSigned = true;
                        break;
                      case 45:
                        flagLeftAlign = true;
                        break;
                      case 35:
                        flagAlternative = true;
                        break;
                      case 48:
                        if (flagZeroPad) {
                          break flagsLoop;
                        } else {
                          flagZeroPad = true;
                          break;
                        }
                      case 32:
                        flagPadSign = true;
                        break;
                      default:
                        break flagsLoop;
                    }
                    textIndex++;
                    next = HEAP8[textIndex + 1 >>> 0 >>> 0];
                  }
                var width = 0;
                if (next == 42) {
                  width = getNextArg("i32");
                  textIndex++;
                  next = HEAP8[textIndex + 1 >>> 0 >>> 0];
                } else {
                  while (next >= 48 && next <= 57) {
                    width = width * 10 + (next - 48);
                    textIndex++;
                    next = HEAP8[textIndex + 1 >>> 0 >>> 0];
                  }
                }
                var precisionSet = false, precision = -1;
                if (next == 46) {
                  precision = 0;
                  precisionSet = true;
                  textIndex++;
                  next = HEAP8[textIndex + 1 >>> 0 >>> 0];
                  if (next == 42) {
                    precision = getNextArg("i32");
                    textIndex++;
                  } else {
                    while (1) {
                      var precisionChr = HEAP8[textIndex + 1 >>> 0 >>> 0];
                      if (precisionChr < 48 || precisionChr > 57)
                        break;
                      precision = precision * 10 + (precisionChr - 48);
                      textIndex++;
                    }
                  }
                  next = HEAP8[textIndex + 1 >>> 0 >>> 0];
                }
                if (precision < 0) {
                  precision = 6;
                  precisionSet = false;
                }
                var argSize;
                switch (String.fromCharCode(next)) {
                  case "h":
                    var nextNext = HEAP8[textIndex + 2 >>> 0 >>> 0];
                    if (nextNext == 104) {
                      textIndex++;
                      argSize = 1;
                    } else {
                      argSize = 2;
                    }
                    break;
                  case "l":
                    var nextNext = HEAP8[textIndex + 2 >>> 0 >>> 0];
                    if (nextNext == 108) {
                      textIndex++;
                      argSize = 8;
                    } else {
                      argSize = 4;
                    }
                    break;
                  case "L":
                  case "q":
                  case "j":
                    argSize = 8;
                    break;
                  case "z":
                  case "t":
                  case "I":
                    argSize = 4;
                    break;
                  default:
                    argSize = null;
                }
                if (argSize)
                  textIndex++;
                next = HEAP8[textIndex + 1 >>> 0 >>> 0];
                switch (String.fromCharCode(next)) {
                  case "d":
                  case "i":
                  case "u":
                  case "o":
                  case "x":
                  case "X":
                  case "p": {
                    var signed = next == 100 || next == 105;
                    argSize = argSize || 4;
                    currArg = getNextArg("i" + argSize * 8);
                    var argText;
                    if (argSize == 8) {
                      currArg = next == 117 ? convertU32PairToI53(currArg[0], currArg[1]) : convertI32PairToI53(currArg[0], currArg[1]);
                    }
                    if (argSize <= 4) {
                      var limit = Math.pow(256, argSize) - 1;
                      currArg = (signed ? reSign : unSign)(currArg & limit, argSize * 8);
                    }
                    var currAbsArg = Math.abs(currArg);
                    var prefix = "";
                    if (next == 100 || next == 105) {
                      argText = reSign(currArg, 8 * argSize).toString(10);
                    } else if (next == 117) {
                      argText = unSign(currArg, 8 * argSize).toString(10);
                      currArg = Math.abs(currArg);
                    } else if (next == 111) {
                      argText = (flagAlternative ? "0" : "") + currAbsArg.toString(8);
                    } else if (next == 120 || next == 88) {
                      prefix = flagAlternative && currArg != 0 ? "0x" : "";
                      if (currArg < 0) {
                        currArg = -currArg;
                        argText = (currAbsArg - 1).toString(16);
                        var buffer = [];
                        for (var i2 = 0; i2 < argText.length; i2++) {
                          buffer.push((15 - parseInt(argText[i2], 16)).toString(16));
                        }
                        argText = buffer.join("");
                        while (argText.length < argSize * 2)
                          argText = "f" + argText;
                      } else {
                        argText = currAbsArg.toString(16);
                      }
                      if (next == 88) {
                        prefix = prefix.toUpperCase();
                        argText = argText.toUpperCase();
                      }
                    } else if (next == 112) {
                      if (currAbsArg === 0) {
                        argText = "(nil)";
                      } else {
                        prefix = "0x";
                        argText = currAbsArg.toString(16);
                      }
                    }
                    if (precisionSet) {
                      while (argText.length < precision) {
                        argText = "0" + argText;
                      }
                    }
                    if (currArg >= 0) {
                      if (flagAlwaysSigned) {
                        prefix = "+" + prefix;
                      } else if (flagPadSign) {
                        prefix = " " + prefix;
                      }
                    }
                    if (argText.charAt(0) == "-") {
                      prefix = "-" + prefix;
                      argText = argText.substr(1);
                    }
                    while (prefix.length + argText.length < width) {
                      if (flagLeftAlign) {
                        argText += " ";
                      } else {
                        if (flagZeroPad) {
                          argText = "0" + argText;
                        } else {
                          prefix = " " + prefix;
                        }
                      }
                    }
                    argText = prefix + argText;
                    argText.split("").forEach(function(chr) {
                      ret.push(chr.charCodeAt(0));
                    });
                    break;
                  }
                  case "f":
                  case "F":
                  case "e":
                  case "E":
                  case "g":
                  case "G": {
                    currArg = getNextArg("double");
                    var argText;
                    if (isNaN(currArg)) {
                      argText = "nan";
                      flagZeroPad = false;
                    } else if (!isFinite(currArg)) {
                      argText = (currArg < 0 ? "-" : "") + "inf";
                      flagZeroPad = false;
                    } else {
                      var isGeneral = false;
                      var effectivePrecision = Math.min(precision, 20);
                      if (next == 103 || next == 71) {
                        isGeneral = true;
                        precision = precision || 1;
                        var exponent = parseInt(currArg.toExponential(effectivePrecision).split("e")[1], 10);
                        if (precision > exponent && exponent >= -4) {
                          next = (next == 103 ? "f" : "F").charCodeAt(0);
                          precision -= exponent + 1;
                        } else {
                          next = (next == 103 ? "e" : "E").charCodeAt(0);
                          precision--;
                        }
                        effectivePrecision = Math.min(precision, 20);
                      }
                      if (next == 101 || next == 69) {
                        argText = currArg.toExponential(effectivePrecision);
                        if (/[eE][-+]\d$/.test(argText)) {
                          argText = argText.slice(0, -1) + "0" + argText.slice(-1);
                        }
                      } else if (next == 102 || next == 70) {
                        argText = currArg.toFixed(effectivePrecision);
                        if (currArg === 0 && reallyNegative(currArg)) {
                          argText = "-" + argText;
                        }
                      }
                      var parts2 = argText.split("e");
                      if (isGeneral && !flagAlternative) {
                        while (parts2[0].length > 1 && parts2[0].includes(".") && (parts2[0].slice(-1) == "0" || parts2[0].slice(-1) == ".")) {
                          parts2[0] = parts2[0].slice(0, -1);
                        }
                      } else {
                        if (flagAlternative && argText.indexOf(".") == -1)
                          parts2[0] += ".";
                        while (precision > effectivePrecision++)
                          parts2[0] += "0";
                      }
                      argText = parts2[0] + (parts2.length > 1 ? "e" + parts2[1] : "");
                      if (next == 69)
                        argText = argText.toUpperCase();
                      if (currArg >= 0) {
                        if (flagAlwaysSigned) {
                          argText = "+" + argText;
                        } else if (flagPadSign) {
                          argText = " " + argText;
                        }
                      }
                    }
                    while (argText.length < width) {
                      if (flagLeftAlign) {
                        argText += " ";
                      } else {
                        if (flagZeroPad && (argText[0] == "-" || argText[0] == "+")) {
                          argText = argText[0] + "0" + argText.slice(1);
                        } else {
                          argText = (flagZeroPad ? "0" : " ") + argText;
                        }
                      }
                    }
                    if (next < 97)
                      argText = argText.toUpperCase();
                    argText.split("").forEach(function(chr) {
                      ret.push(chr.charCodeAt(0));
                    });
                    break;
                  }
                  case "s": {
                    var arg = getNextArg("i8*");
                    var argLength = arg ? strLen(arg) : "(null)".length;
                    if (precisionSet)
                      argLength = Math.min(argLength, precision);
                    if (!flagLeftAlign) {
                      while (argLength < width--) {
                        ret.push(32);
                      }
                    }
                    if (arg) {
                      for (var i2 = 0; i2 < argLength; i2++) {
                        ret.push(HEAPU8[arg++ >>> 0 >>> 0]);
                      }
                    } else {
                      ret = ret.concat(intArrayFromString("(null)".substr(0, argLength), true));
                    }
                    if (flagLeftAlign) {
                      while (argLength < width--) {
                        ret.push(32);
                      }
                    }
                    break;
                  }
                  case "c": {
                    if (flagLeftAlign)
                      ret.push(getNextArg("i8"));
                    while (--width > 0) {
                      ret.push(32);
                    }
                    if (!flagLeftAlign)
                      ret.push(getNextArg("i8"));
                    break;
                  }
                  case "n": {
                    var ptr2 = getNextArg("i32*");
                    HEAP32[ptr2 >>> 2 >>> 0] = ret.length;
                    break;
                  }
                  case "%": {
                    ret.push(curr);
                    break;
                  }
                  default: {
                    for (var i2 = startTextIndex; i2 < textIndex + 2; i2++) {
                      ret.push(HEAP8[i2 >>> 0 >>> 0]);
                    }
                  }
                }
                textIndex += 2;
              } else {
                ret.push(curr);
                textIndex += 1;
              }
            }
            return ret;
          };
          function _emscripten_log(flags2, format, varargs) {
            format >>>= 0;
            varargs >>>= 0;
            var result = formatString(format, varargs);
            var str = UTF8ArrayToString(result, 0);
            emscriptenLog(flags2, str);
          }
          _emscripten_log.sig = "vipp";
          function _emscripten_get_compiler_setting(name2) {
            name2 >>>= 0;
            throw "You must build with -sRETAIN_COMPILER_SETTINGS for getCompilerSetting or emscripten_get_compiler_setting to work";
          }
          _emscripten_get_compiler_setting.sig = "pp";
          var _emscripten_has_asyncify = () => 0;
          _emscripten_has_asyncify.sig = "i";
          function _emscripten_debugger() {
            debugger;
          }
          _emscripten_debugger.sig = "v";
          function _emscripten_print_double(x, to, max) {
            to >>>= 0;
            var str = x + "";
            if (to)
              return stringToUTF8(str, to, max);
            else
              return lengthBytesUTF8(str);
          }
          _emscripten_print_double.sig = "idpi";
          var convertFrameToPC = (frame) => {
            abort("Cannot use convertFrameToPC (needed by __builtin_return_address) without -sUSE_OFFSET_CONVERTER");
            return 0;
          };
          function _emscripten_return_address(level) {
            var callstack = jsStackTrace().split("\n");
            if (callstack[0] == "Error") {
              callstack.shift();
            }
            var caller = callstack[level + 3];
            return convertFrameToPC(caller);
          }
          _emscripten_return_address.sig = "pi";
          var UNWIND_CACHE = {};
          var saveInUnwindCache = (callstack) => {
            callstack.forEach((frame) => {
              var pc = convertFrameToPC(frame);
              if (pc) {
                UNWIND_CACHE[pc] = frame;
              }
            });
          };
          function _emscripten_stack_snapshot() {
            var callstack = jsStackTrace().split("\n");
            if (callstack[0] == "Error") {
              callstack.shift();
            }
            saveInUnwindCache(callstack);
            UNWIND_CACHE.last_addr = convertFrameToPC(callstack[3]);
            UNWIND_CACHE.last_stack = callstack;
            return UNWIND_CACHE.last_addr;
          }
          _emscripten_stack_snapshot.sig = "p";
          function _emscripten_stack_unwind_buffer(addr2, buffer, count) {
            addr2 >>>= 0;
            buffer >>>= 0;
            var stack;
            if (UNWIND_CACHE.last_addr == addr2) {
              stack = UNWIND_CACHE.last_stack;
            } else {
              stack = jsStackTrace().split("\n");
              if (stack[0] == "Error") {
                stack.shift();
              }
              saveInUnwindCache(stack);
            }
            var offset = 3;
            while (stack[offset] && convertFrameToPC(stack[offset]) != addr2) {
              ++offset;
            }
            for (var i2 = 0; i2 < count && stack[i2 + offset]; ++i2) {
              HEAP32[buffer + i2 * 4 >>> 2 >>> 0] = convertFrameToPC(stack[i2 + offset]);
            }
            return i2;
          }
          _emscripten_stack_unwind_buffer.sig = "ippi";
          function _emscripten_pc_get_function(pc) {
            pc >>>= 0;
            abort("Cannot use emscripten_pc_get_function without -sUSE_OFFSET_CONVERTER");
            return 0;
          }
          _emscripten_pc_get_function.sig = "pp";
          var convertPCtoSourceLocation = (pc) => {
            if (UNWIND_CACHE.last_get_source_pc == pc)
              return UNWIND_CACHE.last_source;
            var match;
            var source;
            if (!source) {
              var frame = UNWIND_CACHE[pc];
              if (!frame)
                return null;
              if (match = /\((.*):(\d+):(\d+)\)$/.exec(frame)) {
                source = {
                  file: match[1],
                  line: match[2],
                  column: match[3]
                };
              } else if (match = /@(.*):(\d+):(\d+)/.exec(frame)) {
                source = {
                  file: match[1],
                  line: match[2],
                  column: match[3]
                };
              }
            }
            UNWIND_CACHE.last_get_source_pc = pc;
            UNWIND_CACHE.last_source = source;
            return source;
          };
          function _emscripten_pc_get_file(pc) {
            pc >>>= 0;
            var result = convertPCtoSourceLocation(pc);
            if (!result)
              return 0;
            if (_emscripten_pc_get_file.ret)
              _free(_emscripten_pc_get_file.ret);
            _emscripten_pc_get_file.ret = stringToNewUTF8(result.file);
            return _emscripten_pc_get_file.ret;
          }
          _emscripten_pc_get_file.sig = "pp";
          function _emscripten_pc_get_line(pc) {
            pc >>>= 0;
            var result = convertPCtoSourceLocation(pc);
            return result ? result.line : 0;
          }
          _emscripten_pc_get_line.sig = "ip";
          function _emscripten_pc_get_column(pc) {
            pc >>>= 0;
            var result = convertPCtoSourceLocation(pc);
            return result ? result.column || 0 : 0;
          }
          _emscripten_pc_get_column.sig = "ip";
          function _emscripten_get_module_name(buf, length) {
            buf >>>= 0;
            length >>>= 0;
            return stringToUTF8(wasmBinaryFile, buf, length);
          }
          _emscripten_get_module_name.sig = "ppp";
          function _emscripten_asm_const_double(code, sigPtr, argbuf) {
            code >>>= 0;
            sigPtr >>>= 0;
            argbuf >>>= 0;
            return runEmAsmFunction(code, sigPtr, argbuf);
          }
          _emscripten_asm_const_double.sig = "dppp";
          var runMainThreadEmAsm = (code, sigPtr, argbuf, sync) => {
            var args2 = readEmAsmArgs(sigPtr, argbuf);
            return ASM_CONSTS[code].apply(null, args2);
          };
          function _emscripten_asm_const_int_sync_on_main_thread(code, sigPtr, argbuf) {
            code >>>= 0;
            sigPtr >>>= 0;
            argbuf >>>= 0;
            return runMainThreadEmAsm(code, sigPtr, argbuf, 1);
          }
          _emscripten_asm_const_int_sync_on_main_thread.sig = "ippp";
          function _emscripten_asm_const_ptr_sync_on_main_thread(code, sigPtr, argbuf) {
            code >>>= 0;
            sigPtr >>>= 0;
            argbuf >>>= 0;
            return runMainThreadEmAsm(code, sigPtr, argbuf, 1);
          }
          _emscripten_asm_const_ptr_sync_on_main_thread.sig = "pppp";
          var _emscripten_asm_const_double_sync_on_main_thread = _emscripten_asm_const_int_sync_on_main_thread;
          _emscripten_asm_const_double_sync_on_main_thread.sig = "dppp";
          function _emscripten_asm_const_async_on_main_thread(code, sigPtr, argbuf) {
            code >>>= 0;
            sigPtr >>>= 0;
            argbuf >>>= 0;
            return runMainThreadEmAsm(code, sigPtr, argbuf, 0);
          }
          _emscripten_asm_const_async_on_main_thread.sig = "vppp";
          var jstoi_s = Number;
          function __Unwind_Backtrace(func2, arg) {
            func2 >>>= 0;
            arg >>>= 0;
            var trace = getCallstack();
            var parts2 = trace.split("\n");
            for (var i2 = 0; i2 < parts2.length; i2++) {
              var ret = getWasmTableEntry(func2)(0, arg);
              if (ret !== 0)
                return;
            }
          }
          __Unwind_Backtrace.sig = "ipp";
          function __Unwind_GetIPInfo(context, ipBefore) {
            context >>>= 0;
            ipBefore >>>= 0;
            return abort("Unwind_GetIPInfo");
          }
          __Unwind_GetIPInfo.sig = "ppp";
          function __Unwind_FindEnclosingFunction(ip) {
            ip >>>= 0;
            return 0;
          }
          __Unwind_FindEnclosingFunction.sig = "pp";
          function __Unwind_RaiseException(ex) {
            ex >>>= 0;
            err("Warning: _Unwind_RaiseException is not correctly implemented");
            return ___cxa_throw(ex, 0, 0);
          }
          __Unwind_RaiseException.sig = "ip";
          function __Unwind_DeleteException(ex) {
            ex >>>= 0;
            err("TODO: Unwind_DeleteException");
          }
          __Unwind_DeleteException.sig = "vp";
          var getDynCaller = (sig, ptr2) => {
            var argCache = [];
            return function() {
              argCache.length = 0;
              Object.assign(argCache, arguments);
              return dynCall(sig, ptr2, argCache);
            };
          };
          var _emscripten_exit_with_live_runtime = () => {
            throw "unwind";
          };
          _emscripten_exit_with_live_runtime.sig = "v";
          var _emscripten_force_exit = (status) => {
            __emscripten_runtime_keepalive_clear();
            _exit(status);
          };
          _emscripten_force_exit.sig = "vi";
          function _emscripten_outn(str, len2) {
            str >>>= 0;
            len2 >>>= 0;
            return out(UTF8ToString(str, len2));
          }
          _emscripten_outn.sig = "vpp";
          function _emscripten_errn(str, len2) {
            str >>>= 0;
            len2 >>>= 0;
            return err(UTF8ToString(str, len2));
          }
          _emscripten_errn.sig = "vpp";
          var _emscripten_throw_number = (number) => {
            throw number;
          };
          _emscripten_throw_number.sig = "vd";
          function _emscripten_throw_string(str) {
            str >>>= 0;
            throw UTF8ToString(str);
          }
          _emscripten_throw_string.sig = "vp";
          var runtimeKeepalivePush = () => {
            runtimeKeepaliveCounter += 1;
          };
          runtimeKeepalivePush.sig = "v";
          var runtimeKeepalivePop = () => {
            runtimeKeepaliveCounter -= 1;
          };
          runtimeKeepalivePop.sig = "v";
          var _emscripten_runtime_keepalive_push = runtimeKeepalivePush;
          _emscripten_runtime_keepalive_push.sig = "v";
          var _emscripten_runtime_keepalive_pop = runtimeKeepalivePop;
          _emscripten_runtime_keepalive_pop.sig = "v";
          var _emscripten_runtime_keepalive_check = keepRuntimeAlive;
          _emscripten_runtime_keepalive_check.sig = "i";
          var asmjsMangle = (x) => {
            var unmangledSymbols = ["stackAlloc", "stackSave", "stackRestore", "getTempRet0", "setTempRet0"];
            if (x == "__main_argc_argv") {
              x = "main";
            }
            return x.indexOf("dynCall_") == 0 || unmangledSymbols.includes(x) ? x : "_" + x;
          };
          var ___global_base = 1024;
          function __emscripten_fs_load_embedded_files(ptr2) {
            ptr2 >>>= 0;
            do {
              var name_addr = HEAPU32[ptr2 >>> 2 >>> 0];
              ptr2 += 4;
              var len2 = HEAPU32[ptr2 >>> 2 >>> 0];
              ptr2 += 4;
              var content = HEAPU32[ptr2 >>> 2 >>> 0];
              ptr2 += 4;
              var name2 = UTF8ToString(name_addr);
              FS.createPath("/", PATH.dirname(name2), true, true);
              FS.createDataFile(name2, null, HEAP8.subarray(content >>> 0, content + len2 >>> 0), true, true, true);
            } while (HEAPU32[ptr2 >>> 2 >>> 0]);
          }
          __emscripten_fs_load_embedded_files.sig = "vp";
          var POINTER_SIZE = 4;
          function getNativeTypeSize(type) {
            switch (type) {
              case "i1":
              case "i8":
              case "u8":
                return 1;
              case "i16":
              case "u16":
                return 2;
              case "i32":
              case "u32":
                return 4;
              case "i64":
              case "u64":
                return 8;
              case "float":
                return 4;
              case "double":
                return 8;
              default: {
                if (type[type.length - 1] === "*") {
                  return POINTER_SIZE;
                }
                if (type[0] === "i") {
                  const bits = Number(type.substr(1));
                  assert(bits % 8 === 0, `getNativeTypeSize invalid bits ${bits}, ${type} type`);
                  return bits / 8;
                }
                return 0;
              }
            }
          }
          var STACK_SIZE = 65536;
          var STACK_ALIGN = 16;
          var ASSERTIONS = 0;
          var cwrap = (ident, returnType, argTypes, opts) => {
            var numericArgs = !argTypes || argTypes.every((type) => type === "number" || type === "boolean");
            var numericRet = returnType !== "string";
            if (numericRet && numericArgs && !opts) {
              return getCFunc(ident);
            }
            return function() {
              return ccall(ident, returnType, argTypes, arguments, opts);
            };
          };
          var removeFunction = (index) => {
            functionsInTableMap.delete(getWasmTableEntry(index));
            setWasmTableEntry(index, null);
            freeTableIndexes.push(index);
          };
          var _emscripten_math_cbrt = (x) => Math.cbrt(x);
          _emscripten_math_cbrt.sig = "dd";
          var _emscripten_math_pow = (x, y) => Math.pow(x, y);
          _emscripten_math_pow.sig = "ddd";
          var _emscripten_math_random = () => Math.random();
          _emscripten_math_random.sig = "d";
          var _emscripten_math_sign = (x) => Math.sign(x);
          _emscripten_math_sign.sig = "dd";
          var _emscripten_math_sqrt = (x) => Math.sqrt(x);
          _emscripten_math_sqrt.sig = "dd";
          var _emscripten_math_exp = (x) => Math.exp(x);
          _emscripten_math_exp.sig = "dd";
          var _emscripten_math_expm1 = (x) => Math.expm1(x);
          _emscripten_math_expm1.sig = "dd";
          var _emscripten_math_fmod = (x, y) => x % y;
          _emscripten_math_fmod.sig = "ddd";
          var _emscripten_math_log = (x) => Math.log(x);
          _emscripten_math_log.sig = "dd";
          var _emscripten_math_log1p = (x) => Math.log1p(x);
          _emscripten_math_log1p.sig = "dd";
          var _emscripten_math_log10 = (x) => Math.log10(x);
          _emscripten_math_log10.sig = "dd";
          var _emscripten_math_log2 = (x) => Math.log2(x);
          _emscripten_math_log2.sig = "dd";
          var _emscripten_math_round = (x) => Math.round(x);
          _emscripten_math_round.sig = "dd";
          var _emscripten_math_acos = (x) => Math.acos(x);
          _emscripten_math_acos.sig = "dd";
          var _emscripten_math_acosh = (x) => Math.acosh(x);
          _emscripten_math_acosh.sig = "dd";
          var _emscripten_math_asin = (x) => Math.asin(x);
          _emscripten_math_asin.sig = "dd";
          var _emscripten_math_asinh = (x) => Math.asinh(x);
          _emscripten_math_asinh.sig = "dd";
          var _emscripten_math_atan = (x) => Math.atan(x);
          _emscripten_math_atan.sig = "dd";
          var _emscripten_math_atanh = (x) => Math.atanh(x);
          _emscripten_math_atanh.sig = "dd";
          var _emscripten_math_atan2 = (y, x) => Math.atan2(y, x);
          _emscripten_math_atan2.sig = "ddd";
          var _emscripten_math_cos = (x) => Math.cos(x);
          _emscripten_math_cos.sig = "dd";
          var _emscripten_math_cosh = (x) => Math.cosh(x);
          _emscripten_math_cosh.sig = "dd";
          function _emscripten_math_hypot(count, varargs) {
            varargs >>>= 0;
            var args2 = [];
            for (var i2 = 0; i2 < count; ++i2) {
              args2.push(HEAPF64[varargs + i2 * 8 >>> 3 >>> 0]);
            }
            return Math.hypot.apply(null, args2);
          }
          _emscripten_math_hypot.sig = "dip";
          var _emscripten_math_sin = (x) => Math.sin(x);
          _emscripten_math_sin.sig = "dd";
          var _emscripten_math_sinh = (x) => Math.sinh(x);
          _emscripten_math_sinh.sig = "dd";
          var _emscripten_math_tan = (x) => Math.tan(x);
          _emscripten_math_tan.sig = "dd";
          var _emscripten_math_tanh = (x) => Math.tanh(x);
          _emscripten_math_tanh.sig = "dd";
          function intArrayToString(array) {
            var ret = [];
            for (var i2 = 0; i2 < array.length; i2++) {
              var chr = array[i2];
              if (chr > 255) {
                chr &= 255;
              }
              ret.push(String.fromCharCode(chr));
            }
            return ret.join("");
          }
          var AsciiToString = (ptr2) => {
            ptr2 >>>= 0;
            var str = "";
            while (1) {
              var ch = HEAPU8[ptr2++ >>> 0 >>> 0];
              if (!ch)
                return str;
              str += String.fromCharCode(ch);
            }
          };
          var JSEvents = {
            removeAllEventListeners() {
              while (JSEvents.eventHandlers.length) {
                JSEvents._removeHandler(JSEvents.eventHandlers.length - 1);
              }
              JSEvents.deferredCalls = [];
            },
            inEventHandler: 0,
            deferredCalls: [],
            deferCall(targetFunction, precedence, argsList) {
              function arraysHaveEqualContent(arrA, arrB) {
                if (arrA.length != arrB.length)
                  return false;
                for (var i3 in arrA) {
                  if (arrA[i3] != arrB[i3])
                    return false;
                }
                return true;
              }
              for (var i2 in JSEvents.deferredCalls) {
                var call = JSEvents.deferredCalls[i2];
                if (call.targetFunction == targetFunction && arraysHaveEqualContent(call.argsList, argsList)) {
                  return;
                }
              }
              JSEvents.deferredCalls.push({
                targetFunction,
                precedence,
                argsList
              });
              JSEvents.deferredCalls.sort((x, y) => x.precedence < y.precedence);
            },
            removeDeferredCalls(targetFunction) {
              for (var i2 = 0; i2 < JSEvents.deferredCalls.length; ++i2) {
                if (JSEvents.deferredCalls[i2].targetFunction == targetFunction) {
                  JSEvents.deferredCalls.splice(i2, 1);
                  --i2;
                }
              }
            },
            canPerformEventHandlerRequests() {
              if (navigator.userActivation) {
                return navigator.userActivation.isActive;
              }
              return JSEvents.inEventHandler && JSEvents.currentEventHandler.allowsDeferredCalls;
            },
            runDeferredCalls() {
              if (!JSEvents.canPerformEventHandlerRequests()) {
                return;
              }
              for (var i2 = 0; i2 < JSEvents.deferredCalls.length; ++i2) {
                var call = JSEvents.deferredCalls[i2];
                JSEvents.deferredCalls.splice(i2, 1);
                --i2;
                call.targetFunction.apply(null, call.argsList);
              }
            },
            eventHandlers: [],
            removeAllHandlersOnTarget: (target, eventTypeString) => {
              for (var i2 = 0; i2 < JSEvents.eventHandlers.length; ++i2) {
                if (JSEvents.eventHandlers[i2].target == target && (!eventTypeString || eventTypeString == JSEvents.eventHandlers[i2].eventTypeString)) {
                  JSEvents._removeHandler(i2--);
                }
              }
            },
            _removeHandler(i2) {
              var h = JSEvents.eventHandlers[i2];
              h.target.removeEventListener(h.eventTypeString, h.eventListenerFunc, h.useCapture);
              JSEvents.eventHandlers.splice(i2, 1);
            },
            registerOrRemoveHandler(eventHandler) {
              if (!eventHandler.target) {
                return -4;
              }
              if (eventHandler.callbackfunc) {
                eventHandler.eventListenerFunc = function(event2) {
                  ++JSEvents.inEventHandler;
                  JSEvents.currentEventHandler = eventHandler;
                  JSEvents.runDeferredCalls();
                  eventHandler.handlerFunc(event2);
                  JSEvents.runDeferredCalls();
                  --JSEvents.inEventHandler;
                };
                eventHandler.target.addEventListener(eventHandler.eventTypeString, eventHandler.eventListenerFunc, eventHandler.useCapture);
                JSEvents.eventHandlers.push(eventHandler);
              } else {
                for (var i2 = 0; i2 < JSEvents.eventHandlers.length; ++i2) {
                  if (JSEvents.eventHandlers[i2].target == eventHandler.target && JSEvents.eventHandlers[i2].eventTypeString == eventHandler.eventTypeString) {
                    JSEvents._removeHandler(i2--);
                  }
                }
              }
              return 0;
            },
            getNodeNameForTarget(target) {
              if (!target)
                return "";
              if (target == window)
                return "#window";
              if (target == screen)
                return "#screen";
              return target?.nodeName || "";
            },
            fullscreenEnabled() {
              return document.fullscreenEnabled || document.webkitFullscreenEnabled;
            }
          };
          var maybeCStringToJsString = (cString) => cString > 2 ? UTF8ToString(cString) : cString;
          var specialHTMLTargets = [0, typeof document != "undefined" ? document : 0, typeof window != "undefined" ? window : 0];
          var findEventTarget = (target) => {
            target = maybeCStringToJsString(target);
            var domElement = specialHTMLTargets[target] || (typeof document != "undefined" ? document.querySelector(target) : void 0);
            return domElement;
          };
          var registerKeyEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
            if (!JSEvents.keyEvent)
              JSEvents.keyEvent = _malloc(176);
            var keyEventHandlerFunc = (e) => {
              var keyEventData = JSEvents.keyEvent;
              HEAPF64[keyEventData >>> 3 >>> 0] = e.timeStamp;
              var idx = keyEventData >>> 2;
              HEAP32[idx + 2 >>> 0] = e.location;
              HEAP32[idx + 3 >>> 0] = e.ctrlKey;
              HEAP32[idx + 4 >>> 0] = e.shiftKey;
              HEAP32[idx + 5 >>> 0] = e.altKey;
              HEAP32[idx + 6 >>> 0] = e.metaKey;
              HEAP32[idx + 7 >>> 0] = e.repeat;
              HEAP32[idx + 8 >>> 0] = e.charCode;
              HEAP32[idx + 9 >>> 0] = e.keyCode;
              HEAP32[idx + 10 >>> 0] = e.which;
              stringToUTF8(e.key || "", keyEventData + 44, 32);
              stringToUTF8(e.code || "", keyEventData + 76, 32);
              stringToUTF8(e.char || "", keyEventData + 108, 32);
              stringToUTF8(e.locale || "", keyEventData + 140, 32);
              if (getWasmTableEntry(callbackfunc)(eventTypeId, keyEventData, userData))
                e.preventDefault();
            };
            var eventHandler = {
              target: findEventTarget(target),
              eventTypeString,
              callbackfunc,
              handlerFunc: keyEventHandlerFunc,
              useCapture
            };
            return JSEvents.registerOrRemoveHandler(eventHandler);
          };
          var findCanvasEventTarget = findEventTarget;
          function _emscripten_set_keypress_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
            target >>>= 0;
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            return registerKeyEventCallback(target, userData, useCapture, callbackfunc, 1, "keypress", targetThread);
          }
          _emscripten_set_keypress_callback_on_thread.sig = "ippipp";
          function _emscripten_set_keydown_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
            target >>>= 0;
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            return registerKeyEventCallback(target, userData, useCapture, callbackfunc, 2, "keydown", targetThread);
          }
          _emscripten_set_keydown_callback_on_thread.sig = "ippipp";
          function _emscripten_set_keyup_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
            target >>>= 0;
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            return registerKeyEventCallback(target, userData, useCapture, callbackfunc, 3, "keyup", targetThread);
          }
          _emscripten_set_keyup_callback_on_thread.sig = "ippipp";
          var getBoundingClientRect = (e) => specialHTMLTargets.indexOf(e) < 0 ? e.getBoundingClientRect() : {
            "left": 0,
            "top": 0
          };
          var fillMouseEventData = (eventStruct, e, target) => {
            HEAPF64[eventStruct >>> 3 >>> 0] = e.timeStamp;
            var idx = eventStruct >>> 2;
            HEAP32[idx + 2 >>> 0] = e.screenX;
            HEAP32[idx + 3 >>> 0] = e.screenY;
            HEAP32[idx + 4 >>> 0] = e.clientX;
            HEAP32[idx + 5 >>> 0] = e.clientY;
            HEAP32[idx + 6 >>> 0] = e.ctrlKey;
            HEAP32[idx + 7 >>> 0] = e.shiftKey;
            HEAP32[idx + 8 >>> 0] = e.altKey;
            HEAP32[idx + 9 >>> 0] = e.metaKey;
            HEAP16[idx * 2 + 20 >>> 0] = e.button;
            HEAP16[idx * 2 + 21 >>> 0] = e.buttons;
            HEAP32[idx + 11 >>> 0] = e["movementX"];
            HEAP32[idx + 12 >>> 0] = e["movementY"];
            var rect = getBoundingClientRect(target);
            HEAP32[idx + 13 >>> 0] = e.clientX - rect.left;
            HEAP32[idx + 14 >>> 0] = e.clientY - rect.top;
          };
          var registerMouseEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
            if (!JSEvents.mouseEvent)
              JSEvents.mouseEvent = _malloc(72);
            target = findEventTarget(target);
            var mouseEventHandlerFunc = (e = event) => {
              fillMouseEventData(JSEvents.mouseEvent, e, target);
              if (getWasmTableEntry(callbackfunc)(eventTypeId, JSEvents.mouseEvent, userData))
                e.preventDefault();
            };
            var eventHandler = {
              target,
              allowsDeferredCalls: eventTypeString != "mousemove" && eventTypeString != "mouseenter" && eventTypeString != "mouseleave",
              eventTypeString,
              callbackfunc,
              handlerFunc: mouseEventHandlerFunc,
              useCapture
            };
            return JSEvents.registerOrRemoveHandler(eventHandler);
          };
          function _emscripten_set_click_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
            target >>>= 0;
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            return registerMouseEventCallback(target, userData, useCapture, callbackfunc, 4, "click", targetThread);
          }
          _emscripten_set_click_callback_on_thread.sig = "ippipp";
          function _emscripten_set_mousedown_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
            target >>>= 0;
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            return registerMouseEventCallback(target, userData, useCapture, callbackfunc, 5, "mousedown", targetThread);
          }
          _emscripten_set_mousedown_callback_on_thread.sig = "ippipp";
          function _emscripten_set_mouseup_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
            target >>>= 0;
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            return registerMouseEventCallback(target, userData, useCapture, callbackfunc, 6, "mouseup", targetThread);
          }
          _emscripten_set_mouseup_callback_on_thread.sig = "ippipp";
          function _emscripten_set_dblclick_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
            target >>>= 0;
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            return registerMouseEventCallback(target, userData, useCapture, callbackfunc, 7, "dblclick", targetThread);
          }
          _emscripten_set_dblclick_callback_on_thread.sig = "ippipp";
          function _emscripten_set_mousemove_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
            target >>>= 0;
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            return registerMouseEventCallback(target, userData, useCapture, callbackfunc, 8, "mousemove", targetThread);
          }
          _emscripten_set_mousemove_callback_on_thread.sig = "ippipp";
          function _emscripten_set_mouseenter_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
            target >>>= 0;
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            return registerMouseEventCallback(target, userData, useCapture, callbackfunc, 33, "mouseenter", targetThread);
          }
          _emscripten_set_mouseenter_callback_on_thread.sig = "ippipp";
          function _emscripten_set_mouseleave_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
            target >>>= 0;
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            return registerMouseEventCallback(target, userData, useCapture, callbackfunc, 34, "mouseleave", targetThread);
          }
          _emscripten_set_mouseleave_callback_on_thread.sig = "ippipp";
          function _emscripten_set_mouseover_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
            target >>>= 0;
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            return registerMouseEventCallback(target, userData, useCapture, callbackfunc, 35, "mouseover", targetThread);
          }
          _emscripten_set_mouseover_callback_on_thread.sig = "ippipp";
          function _emscripten_set_mouseout_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
            target >>>= 0;
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            return registerMouseEventCallback(target, userData, useCapture, callbackfunc, 36, "mouseout", targetThread);
          }
          _emscripten_set_mouseout_callback_on_thread.sig = "ippipp";
          function _emscripten_get_mouse_status(mouseState) {
            mouseState >>>= 0;
            if (!JSEvents.mouseEvent)
              return -7;
            HEAP8.set(HEAP8.subarray(JSEvents.mouseEvent >>> 0, JSEvents.mouseEvent + 72 >>> 0), mouseState >>> 0);
            return 0;
          }
          _emscripten_get_mouse_status.sig = "ip";
          var registerWheelEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
            if (!JSEvents.wheelEvent)
              JSEvents.wheelEvent = _malloc(104);
            var wheelHandlerFunc = (e = event) => {
              var wheelEvent = JSEvents.wheelEvent;
              fillMouseEventData(wheelEvent, e, target);
              HEAPF64[wheelEvent + 72 >>> 3 >>> 0] = e["deltaX"];
              HEAPF64[wheelEvent + 80 >>> 3 >>> 0] = e["deltaY"];
              HEAPF64[wheelEvent + 88 >>> 3 >>> 0] = e["deltaZ"];
              HEAP32[wheelEvent + 96 >>> 2 >>> 0] = e["deltaMode"];
              if (getWasmTableEntry(callbackfunc)(eventTypeId, wheelEvent, userData))
                e.preventDefault();
            };
            var eventHandler = {
              target,
              allowsDeferredCalls: true,
              eventTypeString,
              callbackfunc,
              handlerFunc: wheelHandlerFunc,
              useCapture
            };
            return JSEvents.registerOrRemoveHandler(eventHandler);
          };
          function _emscripten_set_wheel_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
            target >>>= 0;
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            target = findEventTarget(target);
            if (!target)
              return -4;
            if (typeof target.onwheel != "undefined") {
              return registerWheelEventCallback(target, userData, useCapture, callbackfunc, 9, "wheel", targetThread);
            } else {
              return -1;
            }
          }
          _emscripten_set_wheel_callback_on_thread.sig = "ippipp";
          var registerUiEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
            if (!JSEvents.uiEvent)
              JSEvents.uiEvent = _malloc(36);
            target = findEventTarget(target);
            var uiEventHandlerFunc = (e = event) => {
              if (e.target != target) {
                return;
              }
              var b = document.body;
              if (!b) {
                return;
              }
              var uiEvent = JSEvents.uiEvent;
              HEAP32[uiEvent >>> 2 >>> 0] = e.detail;
              HEAP32[uiEvent + 4 >>> 2 >>> 0] = b.clientWidth;
              HEAP32[uiEvent + 8 >>> 2 >>> 0] = b.clientHeight;
              HEAP32[uiEvent + 12 >>> 2 >>> 0] = innerWidth;
              HEAP32[uiEvent + 16 >>> 2 >>> 0] = innerHeight;
              HEAP32[uiEvent + 20 >>> 2 >>> 0] = outerWidth;
              HEAP32[uiEvent + 24 >>> 2 >>> 0] = outerHeight;
              HEAP32[uiEvent + 28 >>> 2 >>> 0] = pageXOffset;
              HEAP32[uiEvent + 32 >>> 2 >>> 0] = pageYOffset;
              if (getWasmTableEntry(callbackfunc)(eventTypeId, uiEvent, userData))
                e.preventDefault();
            };
            var eventHandler = {
              target,
              eventTypeString,
              callbackfunc,
              handlerFunc: uiEventHandlerFunc,
              useCapture
            };
            return JSEvents.registerOrRemoveHandler(eventHandler);
          };
          function _emscripten_set_resize_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
            target >>>= 0;
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            return registerUiEventCallback(target, userData, useCapture, callbackfunc, 10, "resize", targetThread);
          }
          _emscripten_set_resize_callback_on_thread.sig = "ippipp";
          function _emscripten_set_scroll_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
            target >>>= 0;
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            return registerUiEventCallback(target, userData, useCapture, callbackfunc, 11, "scroll", targetThread);
          }
          _emscripten_set_scroll_callback_on_thread.sig = "ippipp";
          var registerFocusEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
            if (!JSEvents.focusEvent)
              JSEvents.focusEvent = _malloc(256);
            var focusEventHandlerFunc = (e = event) => {
              var nodeName = JSEvents.getNodeNameForTarget(e.target);
              var id = e.target.id ? e.target.id : "";
              var focusEvent = JSEvents.focusEvent;
              stringToUTF8(nodeName, focusEvent + 0, 128);
              stringToUTF8(id, focusEvent + 128, 128);
              if (getWasmTableEntry(callbackfunc)(eventTypeId, focusEvent, userData))
                e.preventDefault();
            };
            var eventHandler = {
              target: findEventTarget(target),
              eventTypeString,
              callbackfunc,
              handlerFunc: focusEventHandlerFunc,
              useCapture
            };
            return JSEvents.registerOrRemoveHandler(eventHandler);
          };
          function _emscripten_set_blur_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
            target >>>= 0;
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            return registerFocusEventCallback(target, userData, useCapture, callbackfunc, 12, "blur", targetThread);
          }
          _emscripten_set_blur_callback_on_thread.sig = "ippipp";
          function _emscripten_set_focus_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
            target >>>= 0;
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            return registerFocusEventCallback(target, userData, useCapture, callbackfunc, 13, "focus", targetThread);
          }
          _emscripten_set_focus_callback_on_thread.sig = "ippipp";
          function _emscripten_set_focusin_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
            target >>>= 0;
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            return registerFocusEventCallback(target, userData, useCapture, callbackfunc, 14, "focusin", targetThread);
          }
          _emscripten_set_focusin_callback_on_thread.sig = "ippipp";
          function _emscripten_set_focusout_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
            target >>>= 0;
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            return registerFocusEventCallback(target, userData, useCapture, callbackfunc, 15, "focusout", targetThread);
          }
          _emscripten_set_focusout_callback_on_thread.sig = "ippipp";
          var fillDeviceOrientationEventData = (eventStruct, e, target) => {
            HEAPF64[eventStruct >>> 3 >>> 0] = e.alpha;
            HEAPF64[eventStruct + 8 >>> 3 >>> 0] = e.beta;
            HEAPF64[eventStruct + 16 >>> 3 >>> 0] = e.gamma;
            HEAP32[eventStruct + 24 >>> 2 >>> 0] = e.absolute;
          };
          var registerDeviceOrientationEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
            if (!JSEvents.deviceOrientationEvent)
              JSEvents.deviceOrientationEvent = _malloc(32);
            var deviceOrientationEventHandlerFunc = (e = event) => {
              fillDeviceOrientationEventData(JSEvents.deviceOrientationEvent, e, target);
              if (getWasmTableEntry(callbackfunc)(eventTypeId, JSEvents.deviceOrientationEvent, userData))
                e.preventDefault();
            };
            var eventHandler = {
              target: findEventTarget(target),
              eventTypeString,
              callbackfunc,
              handlerFunc: deviceOrientationEventHandlerFunc,
              useCapture
            };
            return JSEvents.registerOrRemoveHandler(eventHandler);
          };
          function _emscripten_set_deviceorientation_callback_on_thread(userData, useCapture, callbackfunc, targetThread) {
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            return registerDeviceOrientationEventCallback(2, userData, useCapture, callbackfunc, 16, "deviceorientation", targetThread);
          }
          _emscripten_set_deviceorientation_callback_on_thread.sig = "ipipp";
          function _emscripten_get_deviceorientation_status(orientationState) {
            orientationState >>>= 0;
            if (!JSEvents.deviceOrientationEvent)
              return -7;
            HEAP32.set(HEAP32.subarray(JSEvents.deviceOrientationEvent >>> 0, 32 >>> 0), orientationState >>> 0);
            return 0;
          }
          _emscripten_get_deviceorientation_status.sig = "ip";
          var fillDeviceMotionEventData = (eventStruct, e, target) => {
            var supportedFields = 0;
            var a = e["acceleration"];
            supportedFields |= a && 1;
            var ag = e["accelerationIncludingGravity"];
            supportedFields |= ag && 2;
            var rr = e["rotationRate"];
            supportedFields |= rr && 4;
            a = a || {};
            ag = ag || {};
            rr = rr || {};
            HEAPF64[eventStruct >>> 3 >>> 0] = a["x"];
            HEAPF64[eventStruct + 8 >>> 3 >>> 0] = a["y"];
            HEAPF64[eventStruct + 16 >>> 3 >>> 0] = a["z"];
            HEAPF64[eventStruct + 24 >>> 3 >>> 0] = ag["x"];
            HEAPF64[eventStruct + 32 >>> 3 >>> 0] = ag["y"];
            HEAPF64[eventStruct + 40 >>> 3 >>> 0] = ag["z"];
            HEAPF64[eventStruct + 48 >>> 3 >>> 0] = rr["alpha"];
            HEAPF64[eventStruct + 56 >>> 3 >>> 0] = rr["beta"];
            HEAPF64[eventStruct + 64 >>> 3 >>> 0] = rr["gamma"];
          };
          var registerDeviceMotionEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
            if (!JSEvents.deviceMotionEvent)
              JSEvents.deviceMotionEvent = _malloc(80);
            var deviceMotionEventHandlerFunc = (e = event) => {
              fillDeviceMotionEventData(JSEvents.deviceMotionEvent, e, target);
              if (getWasmTableEntry(callbackfunc)(eventTypeId, JSEvents.deviceMotionEvent, userData))
                e.preventDefault();
            };
            var eventHandler = {
              target: findEventTarget(target),
              eventTypeString,
              callbackfunc,
              handlerFunc: deviceMotionEventHandlerFunc,
              useCapture
            };
            return JSEvents.registerOrRemoveHandler(eventHandler);
          };
          function _emscripten_set_devicemotion_callback_on_thread(userData, useCapture, callbackfunc, targetThread) {
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            return registerDeviceMotionEventCallback(2, userData, useCapture, callbackfunc, 17, "devicemotion", targetThread);
          }
          _emscripten_set_devicemotion_callback_on_thread.sig = "ipipp";
          function _emscripten_get_devicemotion_status(motionState) {
            motionState >>>= 0;
            if (!JSEvents.deviceMotionEvent)
              return -7;
            HEAP32.set(HEAP32.subarray(JSEvents.deviceMotionEvent >>> 0, 80 >>> 0), motionState >>> 0);
            return 0;
          }
          _emscripten_get_devicemotion_status.sig = "ip";
          var screenOrientation = () => {
            if (!screen)
              return void 0;
            return screen.orientation || screen.mozOrientation || screen.webkitOrientation || screen.msOrientation;
          };
          var fillOrientationChangeEventData = (eventStruct) => {
            var orientations = ["portrait-primary", "portrait-secondary", "landscape-primary", "landscape-secondary"];
            var orientations2 = ["portrait", "portrait", "landscape", "landscape"];
            var orientationString = screenOrientation();
            var orientation2 = orientations.indexOf(orientationString);
            if (orientation2 == -1) {
              orientation2 = orientations2.indexOf(orientationString);
            }
            HEAP32[eventStruct >>> 2 >>> 0] = 1 << orientation2;
            HEAP32[eventStruct + 4 >>> 2 >>> 0] = orientation2;
          };
          var registerOrientationChangeEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
            if (!JSEvents.orientationChangeEvent)
              JSEvents.orientationChangeEvent = _malloc(8);
            var orientationChangeEventHandlerFunc = (e = event) => {
              var orientationChangeEvent = JSEvents.orientationChangeEvent;
              fillOrientationChangeEventData(orientationChangeEvent);
              if (getWasmTableEntry(callbackfunc)(eventTypeId, orientationChangeEvent, userData))
                e.preventDefault();
            };
            if (eventTypeId == 18 && screen.mozOrientation !== void 0) {
              eventTypeString = "mozorientationchange";
            }
            var eventHandler = {
              target,
              eventTypeString,
              callbackfunc,
              handlerFunc: orientationChangeEventHandlerFunc,
              useCapture
            };
            return JSEvents.registerOrRemoveHandler(eventHandler);
          };
          function _emscripten_set_orientationchange_callback_on_thread(userData, useCapture, callbackfunc, targetThread) {
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            if (!screen || !screen["addEventListener"])
              return -1;
            return registerOrientationChangeEventCallback(screen, userData, useCapture, callbackfunc, 18, "orientationchange", targetThread);
          }
          _emscripten_set_orientationchange_callback_on_thread.sig = "ipipp";
          function _emscripten_get_orientation_status(orientationChangeEvent) {
            orientationChangeEvent >>>= 0;
            if (!screenOrientation() && typeof orientation == "undefined")
              return -1;
            fillOrientationChangeEventData(orientationChangeEvent);
            return 0;
          }
          _emscripten_get_orientation_status.sig = "ip";
          var _emscripten_lock_orientation = (allowedOrientations) => {
            var orientations = [];
            if (allowedOrientations & 1)
              orientations.push("portrait-primary");
            if (allowedOrientations & 2)
              orientations.push("portrait-secondary");
            if (allowedOrientations & 4)
              orientations.push("landscape-primary");
            if (allowedOrientations & 8)
              orientations.push("landscape-secondary");
            var succeeded;
            if (screen.lockOrientation) {
              succeeded = screen.lockOrientation(orientations);
            } else if (screen.mozLockOrientation) {
              succeeded = screen.mozLockOrientation(orientations);
            } else if (screen.webkitLockOrientation) {
              succeeded = screen.webkitLockOrientation(orientations);
            } else if (screen.msLockOrientation) {
              succeeded = screen.msLockOrientation(orientations);
            } else {
              return -1;
            }
            if (succeeded) {
              return 0;
            }
            return -6;
          };
          _emscripten_lock_orientation.sig = "ii";
          var _emscripten_unlock_orientation = () => {
            if (screen.unlockOrientation) {
              screen.unlockOrientation();
            } else if (screen.mozUnlockOrientation) {
              screen.mozUnlockOrientation();
            } else if (screen.webkitUnlockOrientation) {
              screen.webkitUnlockOrientation();
            } else if (screen.msUnlockOrientation) {
              screen.msUnlockOrientation();
            } else {
              return -1;
            }
            return 0;
          };
          _emscripten_unlock_orientation.sig = "i";
          var fillFullscreenChangeEventData = (eventStruct) => {
            var fullscreenElement = document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement;
            var isFullscreen = !!fullscreenElement;
            HEAP32[eventStruct >>> 2 >>> 0] = isFullscreen;
            HEAP32[eventStruct + 4 >>> 2 >>> 0] = JSEvents.fullscreenEnabled();
            var reportedElement = isFullscreen ? fullscreenElement : JSEvents.previousFullscreenElement;
            var nodeName = JSEvents.getNodeNameForTarget(reportedElement);
            var id = reportedElement?.id || "";
            stringToUTF8(nodeName, eventStruct + 8, 128);
            stringToUTF8(id, eventStruct + 136, 128);
            HEAP32[eventStruct + 264 >>> 2 >>> 0] = reportedElement ? reportedElement.clientWidth : 0;
            HEAP32[eventStruct + 268 >>> 2 >>> 0] = reportedElement ? reportedElement.clientHeight : 0;
            HEAP32[eventStruct + 272 >>> 2 >>> 0] = screen.width;
            HEAP32[eventStruct + 276 >>> 2 >>> 0] = screen.height;
            if (isFullscreen) {
              JSEvents.previousFullscreenElement = fullscreenElement;
            }
          };
          var registerFullscreenChangeEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
            if (!JSEvents.fullscreenChangeEvent)
              JSEvents.fullscreenChangeEvent = _malloc(280);
            var fullscreenChangeEventhandlerFunc = (e = event) => {
              var fullscreenChangeEvent = JSEvents.fullscreenChangeEvent;
              fillFullscreenChangeEventData(fullscreenChangeEvent);
              if (getWasmTableEntry(callbackfunc)(eventTypeId, fullscreenChangeEvent, userData))
                e.preventDefault();
            };
            var eventHandler = {
              target,
              eventTypeString,
              callbackfunc,
              handlerFunc: fullscreenChangeEventhandlerFunc,
              useCapture
            };
            return JSEvents.registerOrRemoveHandler(eventHandler);
          };
          function _emscripten_set_fullscreenchange_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
            target >>>= 0;
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            if (!JSEvents.fullscreenEnabled())
              return -1;
            target = findEventTarget(target);
            if (!target)
              return -4;
            registerFullscreenChangeEventCallback(target, userData, useCapture, callbackfunc, 19, "webkitfullscreenchange", targetThread);
            return registerFullscreenChangeEventCallback(target, userData, useCapture, callbackfunc, 19, "fullscreenchange", targetThread);
          }
          _emscripten_set_fullscreenchange_callback_on_thread.sig = "ippipp";
          function _emscripten_get_fullscreen_status(fullscreenStatus) {
            fullscreenStatus >>>= 0;
            if (!JSEvents.fullscreenEnabled())
              return -1;
            fillFullscreenChangeEventData(fullscreenStatus);
            return 0;
          }
          _emscripten_get_fullscreen_status.sig = "ip";
          function _emscripten_get_canvas_element_size(target, width, height) {
            target >>>= 0;
            width >>>= 0;
            height >>>= 0;
            var canvas = findCanvasEventTarget(target);
            if (!canvas)
              return -4;
            HEAP32[width >>> 2 >>> 0] = canvas.width;
            HEAP32[height >>> 2 >>> 0] = canvas.height;
          }
          _emscripten_get_canvas_element_size.sig = "ippp";
          var getCanvasElementSize = (target) => withStackSave(() => {
            var w = stackAlloc(8);
            var h = w + 4;
            var targetInt = stringToUTF8OnStack(target.id);
            var ret = _emscripten_get_canvas_element_size(targetInt, w, h);
            var size = [HEAP32[w >>> 2 >>> 0], HEAP32[h >>> 2 >>> 0]];
            return size;
          });
          function _emscripten_set_canvas_element_size(target, width, height) {
            target >>>= 0;
            var canvas = findCanvasEventTarget(target);
            if (!canvas)
              return -4;
            canvas.width = width;
            canvas.height = height;
            return 0;
          }
          _emscripten_set_canvas_element_size.sig = "ipii";
          var setCanvasElementSize = (target, width, height) => {
            if (!target.controlTransferredOffscreen) {
              target.width = width;
              target.height = height;
            } else {
              withStackSave(() => {
                var targetInt = stringToUTF8OnStack(target.id);
                _emscripten_set_canvas_element_size(targetInt, width, height);
              });
            }
          };
          var registerRestoreOldStyle = (canvas) => {
            var canvasSize = getCanvasElementSize(canvas);
            var oldWidth = canvasSize[0];
            var oldHeight = canvasSize[1];
            var oldCssWidth = canvas.style.width;
            var oldCssHeight = canvas.style.height;
            var oldBackgroundColor = canvas.style.backgroundColor;
            var oldDocumentBackgroundColor = document.body.style.backgroundColor;
            var oldPaddingLeft = canvas.style.paddingLeft;
            var oldPaddingRight = canvas.style.paddingRight;
            var oldPaddingTop = canvas.style.paddingTop;
            var oldPaddingBottom = canvas.style.paddingBottom;
            var oldMarginLeft = canvas.style.marginLeft;
            var oldMarginRight = canvas.style.marginRight;
            var oldMarginTop = canvas.style.marginTop;
            var oldMarginBottom = canvas.style.marginBottom;
            var oldDocumentBodyMargin = document.body.style.margin;
            var oldDocumentOverflow = document.documentElement.style.overflow;
            var oldDocumentScroll = document.body.scroll;
            var oldImageRendering = canvas.style.imageRendering;
            function restoreOldStyle() {
              var fullscreenElement = document.fullscreenElement || document.webkitFullscreenElement;
              if (!fullscreenElement) {
                document.removeEventListener("fullscreenchange", restoreOldStyle);
                document.removeEventListener("webkitfullscreenchange", restoreOldStyle);
                setCanvasElementSize(canvas, oldWidth, oldHeight);
                canvas.style.width = oldCssWidth;
                canvas.style.height = oldCssHeight;
                canvas.style.backgroundColor = oldBackgroundColor;
                if (!oldDocumentBackgroundColor)
                  document.body.style.backgroundColor = "white";
                document.body.style.backgroundColor = oldDocumentBackgroundColor;
                canvas.style.paddingLeft = oldPaddingLeft;
                canvas.style.paddingRight = oldPaddingRight;
                canvas.style.paddingTop = oldPaddingTop;
                canvas.style.paddingBottom = oldPaddingBottom;
                canvas.style.marginLeft = oldMarginLeft;
                canvas.style.marginRight = oldMarginRight;
                canvas.style.marginTop = oldMarginTop;
                canvas.style.marginBottom = oldMarginBottom;
                document.body.style.margin = oldDocumentBodyMargin;
                document.documentElement.style.overflow = oldDocumentOverflow;
                document.body.scroll = oldDocumentScroll;
                canvas.style.imageRendering = oldImageRendering;
                if (canvas.GLctxObject)
                  canvas.GLctxObject.GLctx.viewport(0, 0, oldWidth, oldHeight);
                if (currentFullscreenStrategy.canvasResizedCallback) {
                  getWasmTableEntry(currentFullscreenStrategy.canvasResizedCallback)(37, 0, currentFullscreenStrategy.canvasResizedCallbackUserData);
                }
              }
            }
            document.addEventListener("fullscreenchange", restoreOldStyle);
            document.addEventListener("webkitfullscreenchange", restoreOldStyle);
            return restoreOldStyle;
          };
          var setLetterbox = (element, topBottom, leftRight) => {
            element.style.paddingLeft = element.style.paddingRight = leftRight + "px";
            element.style.paddingTop = element.style.paddingBottom = topBottom + "px";
          };
          var JSEvents_resizeCanvasForFullscreen = (target, strategy) => {
            var restoreOldStyle = registerRestoreOldStyle(target);
            var cssWidth = strategy.softFullscreen ? innerWidth : screen.width;
            var cssHeight = strategy.softFullscreen ? innerHeight : screen.height;
            var rect = getBoundingClientRect(target);
            var windowedCssWidth = rect.width;
            var windowedCssHeight = rect.height;
            var canvasSize = getCanvasElementSize(target);
            var windowedRttWidth = canvasSize[0];
            var windowedRttHeight = canvasSize[1];
            if (strategy.scaleMode == 3) {
              setLetterbox(target, (cssHeight - windowedCssHeight) / 2, (cssWidth - windowedCssWidth) / 2);
              cssWidth = windowedCssWidth;
              cssHeight = windowedCssHeight;
            } else if (strategy.scaleMode == 2) {
              if (cssWidth * windowedRttHeight < windowedRttWidth * cssHeight) {
                var desiredCssHeight = windowedRttHeight * cssWidth / windowedRttWidth;
                setLetterbox(target, (cssHeight - desiredCssHeight) / 2, 0);
                cssHeight = desiredCssHeight;
              } else {
                var desiredCssWidth = windowedRttWidth * cssHeight / windowedRttHeight;
                setLetterbox(target, 0, (cssWidth - desiredCssWidth) / 2);
                cssWidth = desiredCssWidth;
              }
            }
            if (!target.style.backgroundColor)
              target.style.backgroundColor = "black";
            if (!document.body.style.backgroundColor)
              document.body.style.backgroundColor = "black";
            target.style.width = cssWidth + "px";
            target.style.height = cssHeight + "px";
            if (strategy.filteringMode == 1) {
              target.style.imageRendering = "optimizeSpeed";
              target.style.imageRendering = "-moz-crisp-edges";
              target.style.imageRendering = "-o-crisp-edges";
              target.style.imageRendering = "-webkit-optimize-contrast";
              target.style.imageRendering = "optimize-contrast";
              target.style.imageRendering = "crisp-edges";
              target.style.imageRendering = "pixelated";
            }
            var dpiScale = strategy.canvasResolutionScaleMode == 2 ? devicePixelRatio : 1;
            if (strategy.canvasResolutionScaleMode != 0) {
              var newWidth = cssWidth * dpiScale | 0;
              var newHeight = cssHeight * dpiScale | 0;
              setCanvasElementSize(target, newWidth, newHeight);
              if (target.GLctxObject)
                target.GLctxObject.GLctx.viewport(0, 0, newWidth, newHeight);
            }
            return restoreOldStyle;
          };
          var JSEvents_requestFullscreen = (target, strategy) => {
            if (strategy.scaleMode != 0 || strategy.canvasResolutionScaleMode != 0) {
              JSEvents_resizeCanvasForFullscreen(target, strategy);
            }
            if (target.requestFullscreen) {
              target.requestFullscreen();
            } else if (target.webkitRequestFullscreen) {
              target.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
            } else {
              return JSEvents.fullscreenEnabled() ? -3 : -1;
            }
            currentFullscreenStrategy = strategy;
            if (strategy.canvasResizedCallback) {
              getWasmTableEntry(strategy.canvasResizedCallback)(37, 0, strategy.canvasResizedCallbackUserData);
            }
            return 0;
          };
          var hideEverythingExceptGivenElement = (onlyVisibleElement) => {
            var child = onlyVisibleElement;
            var parent = child.parentNode;
            var hiddenElements = [];
            while (child != document.body) {
              var children = parent.children;
              for (var i2 = 0; i2 < children.length; ++i2) {
                if (children[i2] != child) {
                  hiddenElements.push({
                    node: children[i2],
                    displayState: children[i2].style.display
                  });
                  children[i2].style.display = "none";
                }
              }
              child = parent;
              parent = parent.parentNode;
            }
            return hiddenElements;
          };
          var restoreHiddenElements = (hiddenElements) => {
            for (var i2 = 0; i2 < hiddenElements.length; ++i2) {
              hiddenElements[i2].node.style.display = hiddenElements[i2].displayState;
            }
          };
          var currentFullscreenStrategy = {};
          var restoreOldWindowedStyle = null;
          var softFullscreenResizeWebGLRenderTarget = () => {
            var dpr = devicePixelRatio;
            var inHiDPIFullscreenMode = currentFullscreenStrategy.canvasResolutionScaleMode == 2;
            var inAspectRatioFixedFullscreenMode = currentFullscreenStrategy.scaleMode == 2;
            var inPixelPerfectFullscreenMode = currentFullscreenStrategy.canvasResolutionScaleMode != 0;
            var inCenteredWithoutScalingFullscreenMode = currentFullscreenStrategy.scaleMode == 3;
            var screenWidth = inHiDPIFullscreenMode ? Math.round(innerWidth * dpr) : innerWidth;
            var screenHeight = inHiDPIFullscreenMode ? Math.round(innerHeight * dpr) : innerHeight;
            var w = screenWidth;
            var h = screenHeight;
            var canvas = currentFullscreenStrategy.target;
            var canvasSize = getCanvasElementSize(canvas);
            var x = canvasSize[0];
            var y = canvasSize[1];
            var topMargin;
            if (inAspectRatioFixedFullscreenMode) {
              if (w * y < x * h)
                h = w * y / x | 0;
              else if (w * y > x * h)
                w = h * x / y | 0;
              topMargin = (screenHeight - h) / 2 | 0;
            }
            if (inPixelPerfectFullscreenMode) {
              setCanvasElementSize(canvas, w, h);
              if (canvas.GLctxObject)
                canvas.GLctxObject.GLctx.viewport(0, 0, w, h);
            }
            if (inHiDPIFullscreenMode) {
              topMargin /= dpr;
              w /= dpr;
              h /= dpr;
              w = Math.round(w * 1e4) / 1e4;
              h = Math.round(h * 1e4) / 1e4;
              topMargin = Math.round(topMargin * 1e4) / 1e4;
            }
            if (inCenteredWithoutScalingFullscreenMode) {
              var t = (innerHeight - jstoi_q(canvas.style.height)) / 2;
              var b = (innerWidth - jstoi_q(canvas.style.width)) / 2;
              setLetterbox(canvas, t, b);
            } else {
              canvas.style.width = w + "px";
              canvas.style.height = h + "px";
              var b = (innerWidth - w) / 2;
              setLetterbox(canvas, topMargin, b);
            }
            if (!inCenteredWithoutScalingFullscreenMode && currentFullscreenStrategy.canvasResizedCallback) {
              getWasmTableEntry(currentFullscreenStrategy.canvasResizedCallback)(37, 0, currentFullscreenStrategy.canvasResizedCallbackUserData);
            }
          };
          var doRequestFullscreen = (target, strategy) => {
            if (!JSEvents.fullscreenEnabled())
              return -1;
            target = findEventTarget(target);
            if (!target)
              return -4;
            if (!target.requestFullscreen && !target.webkitRequestFullscreen) {
              return -3;
            }
            var canPerformRequests = JSEvents.canPerformEventHandlerRequests();
            if (!canPerformRequests) {
              if (strategy.deferUntilInEventHandler) {
                JSEvents.deferCall(JSEvents_requestFullscreen, 1, [target, strategy]);
                return 1;
              }
              return -2;
            }
            return JSEvents_requestFullscreen(target, strategy);
          };
          function _emscripten_request_fullscreen(target, deferUntilInEventHandler) {
            target >>>= 0;
            var strategy = {
              scaleMode: 0,
              canvasResolutionScaleMode: 0,
              filteringMode: 0,
              deferUntilInEventHandler,
              canvasResizedCallbackTargetThread: 2
            };
            return doRequestFullscreen(target, strategy);
          }
          _emscripten_request_fullscreen.sig = "ipi";
          function _emscripten_request_fullscreen_strategy(target, deferUntilInEventHandler, fullscreenStrategy) {
            target >>>= 0;
            fullscreenStrategy >>>= 0;
            var strategy = {
              scaleMode: HEAP32[fullscreenStrategy >>> 2 >>> 0],
              canvasResolutionScaleMode: HEAP32[fullscreenStrategy + 4 >>> 2 >>> 0],
              filteringMode: HEAP32[fullscreenStrategy + 8 >>> 2 >>> 0],
              deferUntilInEventHandler,
              canvasResizedCallback: HEAP32[fullscreenStrategy + 12 >>> 2 >>> 0],
              canvasResizedCallbackUserData: HEAP32[fullscreenStrategy + 16 >>> 2 >>> 0]
            };
            return doRequestFullscreen(target, strategy);
          }
          _emscripten_request_fullscreen_strategy.sig = "ipip";
          function _emscripten_enter_soft_fullscreen(target, fullscreenStrategy) {
            target >>>= 0;
            fullscreenStrategy >>>= 0;
            target = findEventTarget(target);
            if (!target)
              return -4;
            var strategy = {
              scaleMode: HEAP32[fullscreenStrategy >>> 2 >>> 0],
              canvasResolutionScaleMode: HEAP32[fullscreenStrategy + 4 >>> 2 >>> 0],
              filteringMode: HEAP32[fullscreenStrategy + 8 >>> 2 >>> 0],
              canvasResizedCallback: HEAP32[fullscreenStrategy + 12 >>> 2 >>> 0],
              canvasResizedCallbackUserData: HEAP32[fullscreenStrategy + 16 >>> 2 >>> 0],
              target,
              softFullscreen: true
            };
            var restoreOldStyle = JSEvents_resizeCanvasForFullscreen(target, strategy);
            document.documentElement.style.overflow = "hidden";
            document.body.scroll = "no";
            document.body.style.margin = "0px";
            var hiddenElements = hideEverythingExceptGivenElement(target);
            function restoreWindowedState() {
              restoreOldStyle();
              restoreHiddenElements(hiddenElements);
              removeEventListener("resize", softFullscreenResizeWebGLRenderTarget);
              if (strategy.canvasResizedCallback) {
                getWasmTableEntry(strategy.canvasResizedCallback)(37, 0, strategy.canvasResizedCallbackUserData);
              }
              currentFullscreenStrategy = 0;
            }
            restoreOldWindowedStyle = restoreWindowedState;
            currentFullscreenStrategy = strategy;
            addEventListener("resize", softFullscreenResizeWebGLRenderTarget);
            if (strategy.canvasResizedCallback) {
              getWasmTableEntry(strategy.canvasResizedCallback)(37, 0, strategy.canvasResizedCallbackUserData);
            }
            return 0;
          }
          _emscripten_enter_soft_fullscreen.sig = "ipp";
          var _emscripten_exit_soft_fullscreen = () => {
            restoreOldWindowedStyle?.();
            restoreOldWindowedStyle = null;
            return 0;
          };
          _emscripten_exit_soft_fullscreen.sig = "i";
          var _emscripten_exit_fullscreen = () => {
            if (!JSEvents.fullscreenEnabled())
              return -1;
            JSEvents.removeDeferredCalls(JSEvents_requestFullscreen);
            var d = specialHTMLTargets[1];
            if (d.exitFullscreen) {
              d.fullscreenElement && d.exitFullscreen();
            } else if (d.webkitExitFullscreen) {
              d.webkitFullscreenElement && d.webkitExitFullscreen();
            } else {
              return -1;
            }
            return 0;
          };
          _emscripten_exit_fullscreen.sig = "i";
          var fillPointerlockChangeEventData = (eventStruct) => {
            var pointerLockElement = document.pointerLockElement || document.mozPointerLockElement || document.webkitPointerLockElement || document.msPointerLockElement;
            var isPointerlocked = !!pointerLockElement;
            HEAP32[eventStruct >>> 2 >>> 0] = isPointerlocked;
            var nodeName = JSEvents.getNodeNameForTarget(pointerLockElement);
            var id = pointerLockElement?.id || "";
            stringToUTF8(nodeName, eventStruct + 4, 128);
            stringToUTF8(id, eventStruct + 132, 128);
          };
          var registerPointerlockChangeEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
            if (!JSEvents.pointerlockChangeEvent)
              JSEvents.pointerlockChangeEvent = _malloc(260);
            var pointerlockChangeEventHandlerFunc = (e = event) => {
              var pointerlockChangeEvent = JSEvents.pointerlockChangeEvent;
              fillPointerlockChangeEventData(pointerlockChangeEvent);
              if (getWasmTableEntry(callbackfunc)(eventTypeId, pointerlockChangeEvent, userData))
                e.preventDefault();
            };
            var eventHandler = {
              target,
              eventTypeString,
              callbackfunc,
              handlerFunc: pointerlockChangeEventHandlerFunc,
              useCapture
            };
            return JSEvents.registerOrRemoveHandler(eventHandler);
          };
          function _emscripten_set_pointerlockchange_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
            target >>>= 0;
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            if (!document || !document.body || !document.body.requestPointerLock && !document.body.mozRequestPointerLock && !document.body.webkitRequestPointerLock && !document.body.msRequestPointerLock) {
              return -1;
            }
            target = findEventTarget(target);
            if (!target)
              return -4;
            registerPointerlockChangeEventCallback(target, userData, useCapture, callbackfunc, 20, "mozpointerlockchange", targetThread);
            registerPointerlockChangeEventCallback(target, userData, useCapture, callbackfunc, 20, "webkitpointerlockchange", targetThread);
            registerPointerlockChangeEventCallback(target, userData, useCapture, callbackfunc, 20, "mspointerlockchange", targetThread);
            return registerPointerlockChangeEventCallback(target, userData, useCapture, callbackfunc, 20, "pointerlockchange", targetThread);
          }
          _emscripten_set_pointerlockchange_callback_on_thread.sig = "ippipp";
          var registerPointerlockErrorEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
            var pointerlockErrorEventHandlerFunc = (e = event) => {
              if (getWasmTableEntry(callbackfunc)(eventTypeId, 0, userData))
                e.preventDefault();
            };
            var eventHandler = {
              target,
              eventTypeString,
              callbackfunc,
              handlerFunc: pointerlockErrorEventHandlerFunc,
              useCapture
            };
            return JSEvents.registerOrRemoveHandler(eventHandler);
          };
          function _emscripten_set_pointerlockerror_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
            target >>>= 0;
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            if (!document || !document.body.requestPointerLock && !document.body.mozRequestPointerLock && !document.body.webkitRequestPointerLock && !document.body.msRequestPointerLock) {
              return -1;
            }
            target = findEventTarget(target);
            if (!target)
              return -4;
            registerPointerlockErrorEventCallback(target, userData, useCapture, callbackfunc, 38, "mozpointerlockerror", targetThread);
            registerPointerlockErrorEventCallback(target, userData, useCapture, callbackfunc, 38, "webkitpointerlockerror", targetThread);
            registerPointerlockErrorEventCallback(target, userData, useCapture, callbackfunc, 38, "mspointerlockerror", targetThread);
            return registerPointerlockErrorEventCallback(target, userData, useCapture, callbackfunc, 38, "pointerlockerror", targetThread);
          }
          _emscripten_set_pointerlockerror_callback_on_thread.sig = "ippipp";
          function _emscripten_get_pointerlock_status(pointerlockStatus) {
            pointerlockStatus >>>= 0;
            if (pointerlockStatus)
              fillPointerlockChangeEventData(pointerlockStatus);
            if (!document.body || !document.body.requestPointerLock && !document.body.mozRequestPointerLock && !document.body.webkitRequestPointerLock && !document.body.msRequestPointerLock) {
              return -1;
            }
            return 0;
          }
          _emscripten_get_pointerlock_status.sig = "ip";
          var requestPointerLock = (target) => {
            if (target.requestPointerLock) {
              target.requestPointerLock();
            } else {
              if (document.body.requestPointerLock) {
                return -3;
              }
              return -1;
            }
            return 0;
          };
          function _emscripten_request_pointerlock(target, deferUntilInEventHandler) {
            target >>>= 0;
            target = findEventTarget(target);
            if (!target)
              return -4;
            if (!target.requestPointerLock) {
              return -1;
            }
            var canPerformRequests = JSEvents.canPerformEventHandlerRequests();
            if (!canPerformRequests) {
              if (deferUntilInEventHandler) {
                JSEvents.deferCall(requestPointerLock, 2, [target]);
                return 1;
              }
              return -2;
            }
            return requestPointerLock(target);
          }
          _emscripten_request_pointerlock.sig = "ipi";
          var _emscripten_exit_pointerlock = () => {
            JSEvents.removeDeferredCalls(requestPointerLock);
            if (document.exitPointerLock) {
              document.exitPointerLock();
            } else {
              return -1;
            }
            return 0;
          };
          _emscripten_exit_pointerlock.sig = "i";
          var _emscripten_vibrate = (msecs) => {
            if (!navigator.vibrate)
              return -1;
            navigator.vibrate(msecs);
            return 0;
          };
          _emscripten_vibrate.sig = "ii";
          function _emscripten_vibrate_pattern(msecsArray, numEntries) {
            msecsArray >>>= 0;
            if (!navigator.vibrate)
              return -1;
            var vibrateList = [];
            for (var i2 = 0; i2 < numEntries; ++i2) {
              var msecs = HEAP32[msecsArray + i2 * 4 >>> 2 >>> 0];
              vibrateList.push(msecs);
            }
            navigator.vibrate(vibrateList);
            return 0;
          }
          _emscripten_vibrate_pattern.sig = "ipi";
          var fillVisibilityChangeEventData = (eventStruct) => {
            var visibilityStates = ["hidden", "visible", "prerender", "unloaded"];
            var visibilityState = visibilityStates.indexOf(document.visibilityState);
            HEAP32[eventStruct >>> 2 >>> 0] = document.hidden;
            HEAP32[eventStruct + 4 >>> 2 >>> 0] = visibilityState;
          };
          var registerVisibilityChangeEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
            if (!JSEvents.visibilityChangeEvent)
              JSEvents.visibilityChangeEvent = _malloc(8);
            var visibilityChangeEventHandlerFunc = (e = event) => {
              var visibilityChangeEvent = JSEvents.visibilityChangeEvent;
              fillVisibilityChangeEventData(visibilityChangeEvent);
              if (getWasmTableEntry(callbackfunc)(eventTypeId, visibilityChangeEvent, userData))
                e.preventDefault();
            };
            var eventHandler = {
              target,
              eventTypeString,
              callbackfunc,
              handlerFunc: visibilityChangeEventHandlerFunc,
              useCapture
            };
            return JSEvents.registerOrRemoveHandler(eventHandler);
          };
          function _emscripten_set_visibilitychange_callback_on_thread(userData, useCapture, callbackfunc, targetThread) {
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            if (!specialHTMLTargets[1]) {
              return -4;
            }
            return registerVisibilityChangeEventCallback(specialHTMLTargets[1], userData, useCapture, callbackfunc, 21, "visibilitychange", targetThread);
          }
          _emscripten_set_visibilitychange_callback_on_thread.sig = "ipipp";
          function _emscripten_get_visibility_status(visibilityStatus) {
            visibilityStatus >>>= 0;
            if (typeof document.visibilityState == "undefined" && typeof document.hidden == "undefined") {
              return -1;
            }
            fillVisibilityChangeEventData(visibilityStatus);
            return 0;
          }
          _emscripten_get_visibility_status.sig = "ip";
          var registerTouchEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
            if (!JSEvents.touchEvent)
              JSEvents.touchEvent = _malloc(1696);
            target = findEventTarget(target);
            var touchEventHandlerFunc = (e) => {
              var t, touches = {}, et = e.touches;
              for (var i2 = 0; i2 < et.length; ++i2) {
                t = et[i2];
                t.isChanged = t.onTarget = 0;
                touches[t.identifier] = t;
              }
              for (var i2 = 0; i2 < e.changedTouches.length; ++i2) {
                t = e.changedTouches[i2];
                t.isChanged = 1;
                touches[t.identifier] = t;
              }
              for (var i2 = 0; i2 < e.targetTouches.length; ++i2) {
                touches[e.targetTouches[i2].identifier].onTarget = 1;
              }
              var touchEvent = JSEvents.touchEvent;
              HEAPF64[touchEvent >>> 3 >>> 0] = e.timeStamp;
              var idx = touchEvent >>> 2;
              HEAP32[idx + 3 >>> 0] = e.ctrlKey;
              HEAP32[idx + 4 >>> 0] = e.shiftKey;
              HEAP32[idx + 5 >>> 0] = e.altKey;
              HEAP32[idx + 6 >>> 0] = e.metaKey;
              idx += 7;
              var targetRect = getBoundingClientRect(target);
              var numTouches = 0;
              for (var i2 in touches) {
                t = touches[i2];
                HEAP32[idx + 0 >>> 0] = t.identifier;
                HEAP32[idx + 1 >>> 0] = t.screenX;
                HEAP32[idx + 2 >>> 0] = t.screenY;
                HEAP32[idx + 3 >>> 0] = t.clientX;
                HEAP32[idx + 4 >>> 0] = t.clientY;
                HEAP32[idx + 5 >>> 0] = t.pageX;
                HEAP32[idx + 6 >>> 0] = t.pageY;
                HEAP32[idx + 7 >>> 0] = t.isChanged;
                HEAP32[idx + 8 >>> 0] = t.onTarget;
                HEAP32[idx + 9 >>> 0] = t.clientX - targetRect.left;
                HEAP32[idx + 10 >>> 0] = t.clientY - targetRect.top;
                idx += 13;
                if (++numTouches > 31) {
                  break;
                }
              }
              HEAP32[touchEvent + 8 >>> 2 >>> 0] = numTouches;
              if (getWasmTableEntry(callbackfunc)(eventTypeId, touchEvent, userData))
                e.preventDefault();
            };
            var eventHandler = {
              target,
              allowsDeferredCalls: eventTypeString == "touchstart" || eventTypeString == "touchend",
              eventTypeString,
              callbackfunc,
              handlerFunc: touchEventHandlerFunc,
              useCapture
            };
            return JSEvents.registerOrRemoveHandler(eventHandler);
          };
          function _emscripten_set_touchstart_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
            target >>>= 0;
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            return registerTouchEventCallback(target, userData, useCapture, callbackfunc, 22, "touchstart", targetThread);
          }
          _emscripten_set_touchstart_callback_on_thread.sig = "ippipp";
          function _emscripten_set_touchend_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
            target >>>= 0;
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            return registerTouchEventCallback(target, userData, useCapture, callbackfunc, 23, "touchend", targetThread);
          }
          _emscripten_set_touchend_callback_on_thread.sig = "ippipp";
          function _emscripten_set_touchmove_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
            target >>>= 0;
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            return registerTouchEventCallback(target, userData, useCapture, callbackfunc, 24, "touchmove", targetThread);
          }
          _emscripten_set_touchmove_callback_on_thread.sig = "ippipp";
          function _emscripten_set_touchcancel_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
            target >>>= 0;
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            return registerTouchEventCallback(target, userData, useCapture, callbackfunc, 25, "touchcancel", targetThread);
          }
          _emscripten_set_touchcancel_callback_on_thread.sig = "ippipp";
          var fillGamepadEventData = (eventStruct, e) => {
            HEAPF64[eventStruct >>> 3 >>> 0] = e.timestamp;
            for (var i2 = 0; i2 < e.axes.length; ++i2) {
              HEAPF64[eventStruct + i2 * 8 + 16 >>> 3 >>> 0] = e.axes[i2];
            }
            for (var i2 = 0; i2 < e.buttons.length; ++i2) {
              if (typeof e.buttons[i2] == "object") {
                HEAPF64[eventStruct + i2 * 8 + 528 >>> 3 >>> 0] = e.buttons[i2].value;
              } else {
                HEAPF64[eventStruct + i2 * 8 + 528 >>> 3 >>> 0] = e.buttons[i2];
              }
            }
            for (var i2 = 0; i2 < e.buttons.length; ++i2) {
              if (typeof e.buttons[i2] == "object") {
                HEAP32[eventStruct + i2 * 4 + 1040 >>> 2 >>> 0] = e.buttons[i2].pressed;
              } else {
                HEAP32[eventStruct + i2 * 4 + 1040 >>> 2 >>> 0] = e.buttons[i2] == 1;
              }
            }
            HEAP32[eventStruct + 1296 >>> 2 >>> 0] = e.connected;
            HEAP32[eventStruct + 1300 >>> 2 >>> 0] = e.index;
            HEAP32[eventStruct + 8 >>> 2 >>> 0] = e.axes.length;
            HEAP32[eventStruct + 12 >>> 2 >>> 0] = e.buttons.length;
            stringToUTF8(e.id, eventStruct + 1304, 64);
            stringToUTF8(e.mapping, eventStruct + 1368, 64);
          };
          var registerGamepadEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
            if (!JSEvents.gamepadEvent)
              JSEvents.gamepadEvent = _malloc(1432);
            var gamepadEventHandlerFunc = (e = event) => {
              var gamepadEvent = JSEvents.gamepadEvent;
              fillGamepadEventData(gamepadEvent, e["gamepad"]);
              if (getWasmTableEntry(callbackfunc)(eventTypeId, gamepadEvent, userData))
                e.preventDefault();
            };
            var eventHandler = {
              target: findEventTarget(target),
              allowsDeferredCalls: true,
              eventTypeString,
              callbackfunc,
              handlerFunc: gamepadEventHandlerFunc,
              useCapture
            };
            return JSEvents.registerOrRemoveHandler(eventHandler);
          };
          var _emscripten_sample_gamepad_data = () => {
            try {
              if (navigator.getGamepads)
                return (JSEvents.lastGamepadState = navigator.getGamepads()) ? 0 : -1;
            } catch (e) {
              navigator.getGamepads = null;
            }
            return -1;
          };
          _emscripten_sample_gamepad_data.sig = "i";
          function _emscripten_set_gamepadconnected_callback_on_thread(userData, useCapture, callbackfunc, targetThread) {
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            if (_emscripten_sample_gamepad_data())
              return -1;
            return registerGamepadEventCallback(2, userData, useCapture, callbackfunc, 26, "gamepadconnected", targetThread);
          }
          _emscripten_set_gamepadconnected_callback_on_thread.sig = "ipipp";
          function _emscripten_set_gamepaddisconnected_callback_on_thread(userData, useCapture, callbackfunc, targetThread) {
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            if (_emscripten_sample_gamepad_data())
              return -1;
            return registerGamepadEventCallback(2, userData, useCapture, callbackfunc, 27, "gamepaddisconnected", targetThread);
          }
          _emscripten_set_gamepaddisconnected_callback_on_thread.sig = "ipipp";
          var _emscripten_get_num_gamepads = () => JSEvents.lastGamepadState.length;
          _emscripten_get_num_gamepads.sig = "i";
          function _emscripten_get_gamepad_status(index, gamepadState) {
            gamepadState >>>= 0;
            if (index < 0 || index >= JSEvents.lastGamepadState.length)
              return -5;
            if (!JSEvents.lastGamepadState[index])
              return -7;
            fillGamepadEventData(gamepadState, JSEvents.lastGamepadState[index]);
            return 0;
          }
          _emscripten_get_gamepad_status.sig = "iip";
          var registerBeforeUnloadEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString) => {
            var beforeUnloadEventHandlerFunc = (e = event) => {
              var confirmationMessage = getWasmTableEntry(callbackfunc)(eventTypeId, 0, userData);
              if (confirmationMessage) {
                confirmationMessage = UTF8ToString(confirmationMessage);
              }
              if (confirmationMessage) {
                e.preventDefault();
                e.returnValue = confirmationMessage;
                return confirmationMessage;
              }
            };
            var eventHandler = {
              target: findEventTarget(target),
              eventTypeString,
              callbackfunc,
              handlerFunc: beforeUnloadEventHandlerFunc,
              useCapture
            };
            return JSEvents.registerOrRemoveHandler(eventHandler);
          };
          function _emscripten_set_beforeunload_callback_on_thread(userData, callbackfunc, targetThread) {
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            if (typeof onbeforeunload == "undefined")
              return -1;
            if (targetThread !== 1)
              return -5;
            return registerBeforeUnloadEventCallback(2, userData, true, callbackfunc, 28, "beforeunload");
          }
          _emscripten_set_beforeunload_callback_on_thread.sig = "ippp";
          var fillBatteryEventData = (eventStruct, e) => {
            HEAPF64[eventStruct >>> 3 >>> 0] = e.chargingTime;
            HEAPF64[eventStruct + 8 >>> 3 >>> 0] = e.dischargingTime;
            HEAPF64[eventStruct + 16 >>> 3 >>> 0] = e.level;
            HEAP32[eventStruct + 24 >>> 2 >>> 0] = e.charging;
          };
          var battery = () => navigator.battery || navigator.mozBattery || navigator.webkitBattery;
          var registerBatteryEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
            if (!JSEvents.batteryEvent)
              JSEvents.batteryEvent = _malloc(32);
            var batteryEventHandlerFunc = (e = event) => {
              var batteryEvent = JSEvents.batteryEvent;
              fillBatteryEventData(batteryEvent, battery());
              if (getWasmTableEntry(callbackfunc)(eventTypeId, batteryEvent, userData))
                e.preventDefault();
            };
            var eventHandler = {
              target: findEventTarget(target),
              eventTypeString,
              callbackfunc,
              handlerFunc: batteryEventHandlerFunc,
              useCapture
            };
            return JSEvents.registerOrRemoveHandler(eventHandler);
          };
          function _emscripten_set_batterychargingchange_callback_on_thread(userData, callbackfunc, targetThread) {
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            if (!battery())
              return -1;
            return registerBatteryEventCallback(battery(), userData, true, callbackfunc, 29, "chargingchange", targetThread);
          }
          _emscripten_set_batterychargingchange_callback_on_thread.sig = "ippp";
          function _emscripten_set_batterylevelchange_callback_on_thread(userData, callbackfunc, targetThread) {
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            if (!battery())
              return -1;
            return registerBatteryEventCallback(battery(), userData, true, callbackfunc, 30, "levelchange", targetThread);
          }
          _emscripten_set_batterylevelchange_callback_on_thread.sig = "ippp";
          function _emscripten_get_battery_status(batteryState) {
            batteryState >>>= 0;
            if (!battery())
              return -1;
            fillBatteryEventData(batteryState, battery());
            return 0;
          }
          _emscripten_get_battery_status.sig = "ip";
          function _emscripten_set_element_css_size(target, width, height) {
            target >>>= 0;
            target = findEventTarget(target);
            if (!target)
              return -4;
            target.style.width = width + "px";
            target.style.height = height + "px";
            return 0;
          }
          _emscripten_set_element_css_size.sig = "ipdd";
          function _emscripten_get_element_css_size(target, width, height) {
            target >>>= 0;
            width >>>= 0;
            height >>>= 0;
            target = findEventTarget(target);
            if (!target)
              return -4;
            var rect = getBoundingClientRect(target);
            HEAPF64[width >>> 3 >>> 0] = rect.width;
            HEAPF64[height >>> 3 >>> 0] = rect.height;
            return 0;
          }
          _emscripten_get_element_css_size.sig = "ippp";
          var _emscripten_html5_remove_all_event_listeners = () => JSEvents.removeAllEventListeners();
          _emscripten_html5_remove_all_event_listeners.sig = "v";
          var _emscripten_request_animation_frame = function(cb, userData) {
            cb >>>= 0;
            userData >>>= 0;
            return requestAnimationFrame((timeStamp) => getWasmTableEntry(cb)(timeStamp, userData));
          };
          _emscripten_request_animation_frame.sig = "ipp";
          var _emscripten_cancel_animation_frame = (id) => cancelAnimationFrame(id);
          _emscripten_cancel_animation_frame.sig = "vi";
          function _emscripten_request_animation_frame_loop(cb, userData) {
            cb >>>= 0;
            userData >>>= 0;
            function tick(timeStamp) {
              if (getWasmTableEntry(cb)(timeStamp, userData)) {
                requestAnimationFrame(tick);
              }
            }
            return requestAnimationFrame(tick);
          }
          _emscripten_request_animation_frame_loop.sig = "vpp";
          var _emscripten_performance_now = () => performance.now();
          _emscripten_performance_now.sig = "d";
          var _emscripten_get_device_pixel_ratio = () => typeof devicePixelRatio == "number" && devicePixelRatio || 1;
          _emscripten_get_device_pixel_ratio.sig = "d";
          var demangle = (func2) => func2;
          var demangleAll = (text) => {
            var regex = /\b_Z[\w\d_]+/g;
            return text.replace(regex, function(x) {
              var y = demangle(x);
              return x === y ? x : y + " [" + x + "]";
            });
          };
          function stackTrace() {
            var js = jsStackTrace();
            if (Module["extraStackTrace"])
              js += "\n" + Module["extraStackTrace"]();
            return demangleAll(js);
          }
          function _random_get(buf, buf_len) {
            buf >>>= 0;
            buf_len >>>= 0;
            try {
              _getentropy(buf, buf_len);
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return e.errno;
            }
          }
          _random_get.sig = "ipp";
          var checkWasiClock = (clock_id) => clock_id == 0 || clock_id == 1 || clock_id == 2 || clock_id == 3;
          function _clock_time_get(clk_id, ignored_precision_low, ignored_precision_high, ptime) {
            var ignored_precision = convertI32PairToI53Checked(ignored_precision_low, ignored_precision_high);
            ptime >>>= 0;
            if (!checkWasiClock(clk_id)) {
              return 28;
            }
            var now;
            if (clk_id === 0) {
              now = Date.now();
            } else if (nowIsMonotonic) {
              now = _emscripten_get_now();
            } else {
              return 52;
            }
            var nsec = Math.round(now * 1e3 * 1e3);
            HEAP32[ptime >>> 2 >>> 0] = nsec >>> 0;
            HEAP32[ptime + 4 >>> 2 >>> 0] = nsec / Math.pow(2, 32) >>> 0;
            return 0;
          }
          _clock_time_get.sig = "iiiip";
          function _clock_res_get(clk_id, pres) {
            pres >>>= 0;
            if (!checkWasiClock(clk_id)) {
              return 28;
            }
            var nsec;
            if (clk_id === 0) {
              nsec = 1e3 * 1e3;
            } else if (nowIsMonotonic) {
              nsec = _emscripten_get_now_res();
            } else {
              return 52;
            }
            HEAP32[pres >>> 2 >>> 0] = nsec >>> 0;
            HEAP32[pres + 4 >>> 2 >>> 0] = nsec / Math.pow(2, 32) >>> 0;
            return 0;
          }
          _clock_res_get.sig = "iip";
          var wasiRightsToMuslOFlags = (rights) => {
            if (rights & 2 && rights & 64) {
              return 2;
            }
            if (rights & 2) {
              return 0;
            }
            if (rights & 64) {
              return 1;
            }
            throw new FS.ErrnoError(28);
          };
          var wasiOFlagsToMuslOFlags = (oflags) => {
            var musl_oflags = 0;
            if (oflags & 1) {
              musl_oflags |= 64;
            }
            if (oflags & 8) {
              musl_oflags |= 512;
            }
            if (oflags & 2) {
              musl_oflags |= 65536;
            }
            if (oflags & 4) {
              musl_oflags |= 128;
            }
            return musl_oflags;
          };
          var _emscripten_unwind_to_js_event_loop = () => {
            throw "unwind";
          };
          _emscripten_unwind_to_js_event_loop.sig = "v";
          var setImmediateWrapped = (func2) => {
            setImmediateWrapped.mapping || (setImmediateWrapped.mapping = []);
            var id = setImmediateWrapped.mapping.length;
            setImmediateWrapped.mapping[id] = setImmediate(() => {
              setImmediateWrapped.mapping[id] = void 0;
              func2();
            });
            return id;
          };
          var clearImmediateWrapped = (id) => {
            clearImmediate(setImmediateWrapped.mapping[id]);
            setImmediateWrapped.mapping[id] = void 0;
          };
          var polyfillSetImmediate = () => {
          };
          var _emscripten_set_immediate = function(cb, userData) {
            cb >>>= 0;
            userData >>>= 0;
            return emSetImmediate(() => {
              callUserCallback(() => getWasmTableEntry(cb)(userData));
            });
          };
          _emscripten_set_immediate.sig = "ipp";
          var _emscripten_clear_immediate = (id) => {
            emClearImmediate(id);
          };
          _emscripten_clear_immediate.sig = "vi";
          var _emscripten_set_immediate_loop = function(cb, userData) {
            cb >>>= 0;
            userData >>>= 0;
            function tick() {
              callUserCallback(() => {
                if (getWasmTableEntry(cb)(userData)) {
                  emSetImmediate(tick);
                } else {
                }
              });
            }
            emSetImmediate(tick);
          };
          _emscripten_set_immediate_loop.sig = "vpp";
          var _emscripten_set_timeout = function(cb, msecs, userData) {
            cb >>>= 0;
            userData >>>= 0;
            return safeSetTimeout(() => getWasmTableEntry(cb)(userData), msecs);
          };
          _emscripten_set_timeout.sig = "ipdp";
          var _emscripten_clear_timeout = clearTimeout;
          _emscripten_clear_timeout.sig = "vi";
          var _emscripten_set_timeout_loop = function(cb, msecs, userData) {
            cb >>>= 0;
            userData >>>= 0;
            function tick() {
              var t = _emscripten_get_now();
              var n = t + msecs;
              callUserCallback(() => {
                if (getWasmTableEntry(cb)(t, userData)) {
                  setTimeout(tick, n - _emscripten_get_now());
                }
              });
            }
            return setTimeout(tick, 0);
          };
          _emscripten_set_timeout_loop.sig = "vpdp";
          var _emscripten_set_interval = function(cb, msecs, userData) {
            cb >>>= 0;
            userData >>>= 0;
            return setInterval(() => {
              callUserCallback(() => getWasmTableEntry(cb)(userData));
            }, msecs);
          };
          _emscripten_set_interval.sig = "ipdp";
          var _emscripten_clear_interval = (id) => {
            clearInterval(id);
          };
          _emscripten_clear_interval.sig = "vi";
          var idsToPromises = (idBuf, size) => {
            var promises = [];
            for (var i2 = 0; i2 < size; i2++) {
              var id = HEAP32[idBuf + i2 * 4 >>> 2 >>> 0];
              promises[i2] = getPromise(id);
            }
            return promises;
          };
          var makePromiseCallback = (callback, userData) => (value) => {
            var stack = stackSave();
            var resultPtr = stackAlloc(POINTER_SIZE);
            HEAPU32[resultPtr >>> 2 >>> 0] = 0;
            try {
              var result = getWasmTableEntry(callback)(resultPtr, userData, value);
              var resultVal = HEAPU32[resultPtr >>> 2 >>> 0];
            } catch (e) {
              if (typeof e !== "number") {
                throw 0;
              }
              throw e;
            } finally {
              stackRestore(stack);
            }
            switch (result) {
              case 0:
                return resultVal;
              case 1:
                return getPromise(resultVal);
              case 2:
                var ret = getPromise(resultVal);
                _emscripten_promise_destroy(resultVal);
                return ret;
              case 3:
                throw resultVal;
            }
          };
          function _emscripten_promise_then(id, onFulfilled, onRejected, userData) {
            id >>>= 0;
            onFulfilled >>>= 0;
            onRejected >>>= 0;
            userData >>>= 0;
            var promise = getPromise(id);
            var newId = promiseMap.allocate({
              promise: promise.then(makePromiseCallback(onFulfilled, userData), makePromiseCallback(onRejected, userData))
            });
            return newId;
          }
          _emscripten_promise_then.sig = "ppppp";
          var _emscripten_promise_all = function(idBuf, resultBuf, size) {
            idBuf >>>= 0;
            resultBuf >>>= 0;
            size >>>= 0;
            var promises = idsToPromises(idBuf, size);
            var id = promiseMap.allocate({
              promise: Promise.all(promises).then((results) => {
                if (resultBuf) {
                  for (var i2 = 0; i2 < size; i2++) {
                    var result = results[i2];
                    HEAPU32[resultBuf + i2 * 4 >>> 2 >>> 0] = result;
                  }
                }
                return resultBuf;
              })
            });
            return id;
          };
          _emscripten_promise_all.sig = "pppp";
          var setPromiseResult = (ptr2, fulfill, value) => {
            var result = fulfill ? 0 : 3;
            HEAP32[ptr2 >>> 2 >>> 0] = result;
            HEAPU32[ptr2 + 4 >>> 2 >>> 0] = value;
          };
          var _emscripten_promise_all_settled = function(idBuf, resultBuf, size) {
            idBuf >>>= 0;
            resultBuf >>>= 0;
            size >>>= 0;
            var promises = idsToPromises(idBuf, size);
            var id = promiseMap.allocate({
              promise: Promise.allSettled(promises).then((results) => {
                if (resultBuf) {
                  var offset = resultBuf;
                  for (var i2 = 0; i2 < size; i2++, offset += 8) {
                    if (results[i2].status === "fulfilled") {
                      setPromiseResult(offset, true, results[i2].value);
                    } else {
                      setPromiseResult(offset, false, results[i2].reason);
                    }
                  }
                }
                return resultBuf;
              })
            });
            return id;
          };
          _emscripten_promise_all_settled.sig = "pppp";
          var _emscripten_promise_any = function(idBuf, errorBuf, size) {
            idBuf >>>= 0;
            errorBuf >>>= 0;
            size >>>= 0;
            var promises = idsToPromises(idBuf, size);
            var id = promiseMap.allocate({
              promise: Promise.any(promises).catch((err2) => {
                if (errorBuf) {
                  for (var i2 = 0; i2 < size; i2++) {
                    HEAPU32[errorBuf + i2 * 4 >>> 2 >>> 0] = err2.errors[i2];
                  }
                }
                throw errorBuf;
              })
            });
            return id;
          };
          _emscripten_promise_any.sig = "pppp";
          function _emscripten_promise_race(idBuf, size) {
            idBuf >>>= 0;
            size >>>= 0;
            var promises = idsToPromises(idBuf, size);
            var id = promiseMap.allocate({
              promise: Promise.race(promises)
            });
            return id;
          }
          _emscripten_promise_race.sig = "ppp";
          function _emscripten_promise_await(returnValuePtr, id) {
            returnValuePtr >>>= 0;
            id >>>= 0;
            abort("emscripten_promise_await is only available with ASYNCIFY");
          }
          _emscripten_promise_await.sig = "vpp";
          function ___cxa_get_exception_ptr(ptr2) {
            ptr2 >>>= 0;
            var rtn = new ExceptionInfo(ptr2).get_exception_ptr();
            return rtn;
          }
          ___cxa_get_exception_ptr.sig = "pp";
          function ___cxa_call_unexpected(exception) {
            exception >>>= 0;
            return abort("Unexpected exception thrown, this is not properly supported - aborting");
          }
          ___cxa_call_unexpected.sig = "vp";
          var getExceptionMessageCommon = (ptr2) => withStackSave(() => {
            var type_addr_addr = stackAlloc(4);
            var message_addr_addr = stackAlloc(4);
            ___get_exception_message(ptr2, type_addr_addr, message_addr_addr);
            var type_addr = HEAPU32[type_addr_addr >>> 2 >>> 0];
            var message_addr = HEAPU32[message_addr_addr >>> 2 >>> 0];
            var type = UTF8ToString(type_addr);
            _free(type_addr);
            var message;
            if (message_addr) {
              message = UTF8ToString(message_addr);
              _free(message_addr);
            }
            return [type, message];
          });
          var incrementExceptionRefcount = (ptr2) => ___cxa_increment_exception_refcount(ptr2);
          var decrementExceptionRefcount = (ptr2) => ___cxa_decrement_exception_refcount(ptr2);
          var getExceptionMessage = (ptr2) => getExceptionMessageCommon(ptr2);
          var _emscripten_run_preload_plugins = function(file, onload2, onerror2) {
            file >>>= 0;
            onload2 >>>= 0;
            onerror2 >>>= 0;
            var _file = UTF8ToString(file);
            var data2 = FS.analyzePath(_file);
            if (!data2.exists)
              return -1;
            FS.createPreloadedFile(PATH.dirname(_file), PATH.basename(_file), new Uint8Array(data2.object.contents), true, true, () => {
              if (onload2)
                getWasmTableEntry(onload2)(file);
            }, () => {
              if (onerror2)
                getWasmTableEntry(onerror2)(file);
            }, true);
            return 0;
          };
          _emscripten_run_preload_plugins.sig = "ippp";
          var Browser_asyncPrepareDataCounter = 0;
          var _emscripten_run_preload_plugins_data = function(data2, size, suffix, arg, onload2, onerror2) {
            data2 >>>= 0;
            suffix >>>= 0;
            arg >>>= 0;
            onload2 >>>= 0;
            onerror2 >>>= 0;
            var _suffix = UTF8ToString(suffix);
            var name2 = "prepare_data_" + Browser_asyncPrepareDataCounter++ + "." + _suffix;
            var cname = stringToNewUTF8(name2);
            FS.createPreloadedFile("/", name2, HEAPU8.subarray(data2 >>> 0, data2 + size >>> 0), true, true, () => {
              if (onload2)
                getWasmTableEntry(onload2)(arg, cname);
            }, () => {
              if (onerror2)
                getWasmTableEntry(onerror2)(arg);
            }, true);
          };
          _emscripten_run_preload_plugins_data.sig = "vpipppp";
          var _emscripten_async_run_script = function(script2, millis) {
            script2 >>>= 0;
            safeSetTimeout(() => _emscripten_run_script(script2), millis);
          };
          _emscripten_async_run_script.sig = "vpi";
          var _emscripten_async_load_script = function(url, onload, onerror) {
            url >>>= 0;
            onload >>>= 0;
            onerror >>>= 0;
            url = UTF8ToString(url);
            onload = getWasmTableEntry(onload);
            onerror = getWasmTableEntry(onerror);
            assert(runDependencies === 0, "async_load_script must be run when no other dependencies are active");
            var loadDone = () => {
              if (onload) {
                if (runDependencies > 0) {
                  dependenciesFulfilled = onload;
                } else {
                  onload();
                }
              }
            };
            var loadError = () => {
              onerror?.();
            };
            if (ENVIRONMENT_IS_NODE) {
              readAsync(url, (data) => {
                eval(data);
                loadDone();
              }, loadError, false);
              return;
            }
            var script = document.createElement("script");
            script.onload = loadDone;
            script.onerror = loadError;
            script.src = url;
            document.body.appendChild(script);
          };
          _emscripten_async_load_script.sig = "vppp";
          function _emscripten_get_main_loop_timing(mode, value) {
            mode >>>= 0;
            value >>>= 0;
            if (mode)
              HEAP32[mode >>> 2 >>> 0] = Browser.mainLoop.timingMode;
            if (value)
              HEAP32[value >>> 2 >>> 0] = Browser.mainLoop.timingValue;
          }
          _emscripten_get_main_loop_timing.sig = "vpp";
          function _emscripten_set_main_loop(func2, fps, simulateInfiniteLoop) {
            func2 >>>= 0;
            var browserIterationFunc = getWasmTableEntry(func2);
            setMainLoop(browserIterationFunc, fps, simulateInfiniteLoop);
          }
          _emscripten_set_main_loop.sig = "vpii";
          var _emscripten_set_main_loop_arg = function(func2, arg, fps, simulateInfiniteLoop) {
            func2 >>>= 0;
            arg >>>= 0;
            var browserIterationFunc = () => getWasmTableEntry(func2)(arg);
            setMainLoop(browserIterationFunc, fps, simulateInfiniteLoop, arg);
          };
          _emscripten_set_main_loop_arg.sig = "vppii";
          var _emscripten_cancel_main_loop = () => {
            Browser.mainLoop.pause();
            Browser.mainLoop.func = null;
          };
          _emscripten_cancel_main_loop.sig = "v";
          var _emscripten_pause_main_loop = () => {
            Browser.mainLoop.pause();
          };
          _emscripten_pause_main_loop.sig = "v";
          var _emscripten_resume_main_loop = () => {
            Browser.mainLoop.resume();
          };
          _emscripten_resume_main_loop.sig = "v";
          var __emscripten_push_main_loop_blocker = function(func2, arg, name2) {
            func2 >>>= 0;
            arg >>>= 0;
            name2 >>>= 0;
            Browser.mainLoop.queue.push({
              func: () => {
                getWasmTableEntry(func2)(arg);
              },
              name: UTF8ToString(name2),
              counted: true
            });
            Browser.mainLoop.updateStatus();
          };
          __emscripten_push_main_loop_blocker.sig = "vppp";
          var __emscripten_push_uncounted_main_loop_blocker = function(func2, arg, name2) {
            func2 >>>= 0;
            arg >>>= 0;
            name2 >>>= 0;
            Browser.mainLoop.queue.push({
              func: () => {
                getWasmTableEntry(func2)(arg);
              },
              name: UTF8ToString(name2),
              counted: false
            });
            Browser.mainLoop.updateStatus();
          };
          __emscripten_push_uncounted_main_loop_blocker.sig = "vppp";
          var _emscripten_set_main_loop_expected_blockers = (num) => {
            Browser.mainLoop.expectedBlockers = num;
            Browser.mainLoop.remainingBlockers = num;
            Browser.mainLoop.updateStatus();
          };
          _emscripten_set_main_loop_expected_blockers.sig = "vi";
          function _emscripten_async_call(func2, arg, millis) {
            func2 >>>= 0;
            arg >>>= 0;
            function wrapper() {
              getWasmTableEntry(func2)(arg);
            }
            if (millis >= 0 || ENVIRONMENT_IS_NODE) {
              safeSetTimeout(wrapper, millis);
            } else {
              Browser.safeRequestAnimationFrame(wrapper);
            }
          }
          _emscripten_async_call.sig = "vppi";
          function _emscripten_get_window_title() {
            var buflen = 256;
            if (!_emscripten_get_window_title.buffer) {
              _emscripten_get_window_title.buffer = _malloc(buflen);
            }
            stringToUTF8(document.title, _emscripten_get_window_title.buffer, buflen);
            return _emscripten_get_window_title.buffer;
          }
          _emscripten_get_window_title.sig = "p";
          function _emscripten_set_window_title(title) {
            title >>>= 0;
            return document.title = UTF8ToString(title);
          }
          _emscripten_set_window_title.sig = "vp";
          function _emscripten_get_screen_size(width, height) {
            width >>>= 0;
            height >>>= 0;
            HEAP32[width >>> 2 >>> 0] = screen.width;
            HEAP32[height >>> 2 >>> 0] = screen.height;
          }
          _emscripten_get_screen_size.sig = "vpp";
          var _emscripten_hide_mouse = () => {
            var styleSheet = document.styleSheets[0];
            var rules = styleSheet.cssRules;
            for (var i2 = 0; i2 < rules.length; i2++) {
              if (rules[i2].cssText.substr(0, 6) == "canvas") {
                styleSheet.deleteRule(i2);
                i2--;
              }
            }
            styleSheet.insertRule("canvas.emscripten { border: 1px solid black; cursor: none; }", 0);
          };
          _emscripten_hide_mouse.sig = "v";
          var _emscripten_set_canvas_size = (width, height) => {
            Browser.setCanvasSize(width, height);
          };
          _emscripten_set_canvas_size.sig = "vii";
          function _emscripten_get_canvas_size(width, height, isFullscreen) {
            width >>>= 0;
            height >>>= 0;
            isFullscreen >>>= 0;
            var canvas = Module["canvas"];
            HEAP32[width >>> 2 >>> 0] = canvas.width;
            HEAP32[height >>> 2 >>> 0] = canvas.height;
            HEAP32[isFullscreen >>> 2 >>> 0] = Browser.isFullscreen ? 1 : 0;
          }
          _emscripten_get_canvas_size.sig = "vppp";
          function _emscripten_create_worker(url2) {
            url2 >>>= 0;
            url2 = UTF8ToString(url2);
            var id = Browser.workers.length;
            var info2 = {
              worker: new Worker(url2),
              callbacks: [],
              awaited: 0,
              buffer: 0,
              bufferSize: 0
            };
            info2.worker.onmessage = function info_worker_onmessage(msg) {
              if (ABORT)
                return;
              var info3 = Browser.workers[id];
              if (!info3)
                return;
              var callbackId = msg.data["callbackId"];
              var callbackInfo = info3.callbacks[callbackId];
              if (!callbackInfo)
                return;
              if (msg.data["finalResponse"]) {
                info3.awaited--;
                info3.callbacks[callbackId] = null;
              }
              var data2 = msg.data["data"];
              if (data2) {
                if (!data2.byteLength)
                  data2 = new Uint8Array(data2);
                if (!info3.buffer || info3.bufferSize < data2.length) {
                  if (info3.buffer)
                    _free(info3.buffer);
                  info3.bufferSize = data2.length;
                  info3.buffer = _malloc(data2.length);
                }
                HEAPU8.set(data2, info3.buffer >>> 0);
                callbackInfo.func(info3.buffer, data2.length, callbackInfo.arg);
              } else {
                callbackInfo.func(0, 0, callbackInfo.arg);
              }
            };
            Browser.workers.push(info2);
            return id;
          }
          _emscripten_create_worker.sig = "ip";
          var _emscripten_destroy_worker = (id) => {
            var info2 = Browser.workers[id];
            info2.worker.terminate();
            if (info2.buffer)
              _free(info2.buffer);
            Browser.workers[id] = null;
          };
          _emscripten_destroy_worker.sig = "vi";
          function _emscripten_call_worker(id, funcName, data2, size, callback, arg) {
            funcName >>>= 0;
            data2 >>>= 0;
            callback >>>= 0;
            arg >>>= 0;
            funcName = UTF8ToString(funcName);
            var info2 = Browser.workers[id];
            var callbackId = -1;
            if (callback) {
              callbackId = info2.callbacks.length;
              info2.callbacks.push({
                func: getWasmTableEntry(callback),
                arg
              });
              info2.awaited++;
            }
            var transferObject = {
              "funcName": funcName,
              "callbackId": callbackId,
              "data": data2 ? new Uint8Array(HEAPU8.subarray(data2 >>> 0, data2 + size >>> 0)) : 0
            };
            if (data2) {
              info2.worker.postMessage(transferObject, [transferObject.data.buffer]);
            } else {
              info2.worker.postMessage(transferObject);
            }
          }
          _emscripten_call_worker.sig = "vippipp";
          var _emscripten_get_worker_queue_size = (id) => {
            var info2 = Browser.workers[id];
            if (!info2)
              return -1;
            return info2.awaited;
          };
          _emscripten_get_worker_queue_size.sig = "ii";
          function _emscripten_get_preloaded_image_data(path, w, h) {
            path >>>= 0;
            w >>>= 0;
            h >>>= 0;
            if ((path | 0) === path)
              path = UTF8ToString(path);
            path = PATH_FS.resolve(path);
            var canvas = preloadedImages[path];
            if (canvas) {
              var ctx = canvas.getContext("2d");
              var image = ctx.getImageData(0, 0, canvas.width, canvas.height);
              var buf = _malloc(canvas.width * canvas.height * 4);
              HEAPU8.set(image.data, buf >>> 0);
              HEAP32[w >>> 2 >>> 0] = canvas.width;
              HEAP32[h >>> 2 >>> 0] = canvas.height;
              return buf;
            }
            return 0;
          }
          _emscripten_get_preloaded_image_data.sig = "pppp";
          function _emscripten_get_preloaded_image_data_from_FILE(file, w, h) {
            file >>>= 0;
            w >>>= 0;
            h >>>= 0;
            var fd = _fileno(file);
            var stream = FS.getStream(fd);
            if (stream) {
              return _emscripten_get_preloaded_image_data(stream.path, w, h);
            }
            return 0;
          }
          _emscripten_get_preloaded_image_data_from_FILE.sig = "pppp";
          var wget = {
            wgetRequests: {},
            nextWgetRequestHandle: 0,
            getNextWgetRequestHandle() {
              var handle2 = wget.nextWgetRequestHandle;
              wget.nextWgetRequestHandle++;
              return handle2;
            }
          };
          var FS_mkdirTree = (path, mode) => FS.mkdirTree(path, mode);
          var FS_unlink = (path) => FS.unlink(path);
          var _emscripten_async_wget = function(url2, file, onload2, onerror2) {
            url2 >>>= 0;
            file >>>= 0;
            onload2 >>>= 0;
            onerror2 >>>= 0;
            var _url = UTF8ToString(url2);
            var _file = UTF8ToString(file);
            _file = PATH_FS.resolve(_file);
            function doCallback(callback) {
              if (callback) {
                callUserCallback(() => {
                  withStackSave(() => {
                    getWasmTableEntry(callback)(stringToUTF8OnStack(_file));
                  });
                });
              }
            }
            var destinationDirectory = PATH.dirname(_file);
            FS_createPreloadedFile(destinationDirectory, PATH.basename(_file), _url, true, true, () => doCallback(onload2), () => doCallback(onerror2), false, false, () => {
              try {
                FS_unlink(_file);
              } catch (e) {
              }
              FS_mkdirTree(destinationDirectory);
            });
          };
          _emscripten_async_wget.sig = "vpppp";
          var _emscripten_async_wget_data = function(url2, userdata, onload2, onerror2) {
            url2 >>>= 0;
            userdata >>>= 0;
            onload2 >>>= 0;
            onerror2 >>>= 0;
            asyncLoad(UTF8ToString(url2), (byteArray) => {
              callUserCallback(() => {
                var buffer = _malloc(byteArray.length);
                HEAPU8.set(byteArray, buffer >>> 0);
                getWasmTableEntry(onload2)(userdata, buffer, byteArray.length);
                _free(buffer);
              });
            }, () => {
              if (onerror2) {
                callUserCallback(() => {
                  getWasmTableEntry(onerror2)(userdata);
                });
              }
            }, true);
          };
          _emscripten_async_wget_data.sig = "vpppp";
          var _emscripten_async_wget2 = function(url2, file, request, param, userdata, onload2, onerror2, onprogress) {
            url2 >>>= 0;
            file >>>= 0;
            request >>>= 0;
            param >>>= 0;
            userdata >>>= 0;
            onload2 >>>= 0;
            onerror2 >>>= 0;
            onprogress >>>= 0;
            var _url = UTF8ToString(url2);
            var _file = UTF8ToString(file);
            _file = PATH_FS.resolve(_file);
            var _request = UTF8ToString(request);
            var _param = UTF8ToString(param);
            var index = _file.lastIndexOf("/");
            var http = new XMLHttpRequest();
            http.open(_request, _url, true);
            http.responseType = "arraybuffer";
            var handle2 = wget.getNextWgetRequestHandle();
            var destinationDirectory = PATH.dirname(_file);
            http.onload = (e) => {
              if (http.status >= 200 && http.status < 300) {
                try {
                  FS.unlink(_file);
                } catch (e2) {
                }
                FS.mkdirTree(destinationDirectory);
                FS.createDataFile(_file.substr(0, index), _file.substr(index + 1), new Uint8Array(http.response), true, true, false);
                if (onload2) {
                  withStackSave(() => {
                    getWasmTableEntry(onload2)(handle2, userdata, stringToUTF8OnStack(_file));
                  });
                }
              } else {
                if (onerror2)
                  getWasmTableEntry(onerror2)(handle2, userdata, http.status);
              }
              delete wget.wgetRequests[handle2];
            };
            http.onerror = (e) => {
              if (onerror2)
                getWasmTableEntry(onerror2)(handle2, userdata, http.status);
              delete wget.wgetRequests[handle2];
            };
            http.onprogress = (e) => {
              if (e.lengthComputable || e.lengthComputable === void 0 && e.total != 0) {
                var percentComplete = e.loaded / e.total * 100;
                if (onprogress)
                  getWasmTableEntry(onprogress)(handle2, userdata, percentComplete);
              }
            };
            http.onabort = (e) => {
              delete wget.wgetRequests[handle2];
            };
            if (_request == "POST") {
              http.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
              http.send(_param);
            } else {
              http.send(null);
            }
            wget.wgetRequests[handle2] = http;
            return handle2;
          };
          _emscripten_async_wget2.sig = "ipppppppp";
          var _emscripten_async_wget2_data = function(url2, request, param, userdata, free, onload2, onerror2, onprogress) {
            url2 >>>= 0;
            request >>>= 0;
            param >>>= 0;
            userdata >>>= 0;
            onload2 >>>= 0;
            onerror2 >>>= 0;
            onprogress >>>= 0;
            var _url = UTF8ToString(url2);
            var _request = UTF8ToString(request);
            var _param = UTF8ToString(param);
            var http = new XMLHttpRequest();
            http.open(_request, _url, true);
            http.responseType = "arraybuffer";
            var handle2 = wget.getNextWgetRequestHandle();
            function onerrorjs() {
              if (onerror2) {
                withStackSave(() => {
                  var statusText = 0;
                  if (http.statusText) {
                    statusText = stringToUTF8OnStack(http.statusText);
                  }
                  getWasmTableEntry(onerror2)(handle2, userdata, http.status, statusText);
                });
              }
            }
            http.onload = (e) => {
              if (http.status >= 200 && http.status < 300 || http.status === 0 && _url.substr(0, 4).toLowerCase() != "http") {
                var byteArray = new Uint8Array(http.response);
                var buffer = _malloc(byteArray.length);
                HEAPU8.set(byteArray, buffer >>> 0);
                if (onload2)
                  getWasmTableEntry(onload2)(handle2, userdata, buffer, byteArray.length);
                if (free)
                  _free(buffer);
              } else {
                onerrorjs();
              }
              delete wget.wgetRequests[handle2];
            };
            http.onerror = (e) => {
              onerrorjs();
              delete wget.wgetRequests[handle2];
            };
            http.onprogress = (e) => {
              if (onprogress)
                getWasmTableEntry(onprogress)(handle2, userdata, e.loaded, e.lengthComputable || e.lengthComputable === void 0 ? e.total : 0);
            };
            http.onabort = (e) => {
              delete wget.wgetRequests[handle2];
            };
            if (_request == "POST") {
              http.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
              http.send(_param);
            } else {
              http.send(null);
            }
            wget.wgetRequests[handle2] = http;
            return handle2;
          };
          _emscripten_async_wget2_data.sig = "ippppippp";
          var _emscripten_async_wget2_abort = (handle2) => {
            var http = wget.wgetRequests[handle2];
            http?.abort();
          };
          _emscripten_async_wget2_abort.sig = "vi";
          function __dlsym_catchup_js(handle2, symbolIndex) {
            handle2 >>>= 0;
            var lib = LDSO.loadedLibsByHandle[handle2];
            var symDict = lib.exports;
            var symName = Object.keys(symDict)[symbolIndex];
            var sym = symDict[symName];
            var result = addFunction(sym, sym.sig);
            return result;
          }
          __dlsym_catchup_js.sig = "ppi";
          var _setNetworkCallback = (event2, userData, callback) => {
            function _callback(data2) {
              try {
                if (event2 === "error") {
                  withStackSave(function() {
                    var msg = stringToUTF8OnStack(data2[2]);
                    getWasmTableEntry(callback)(data2[0], data2[1], msg, userData);
                  });
                } else {
                  getWasmTableEntry(callback)(data2, userData);
                }
              } catch (e) {
                if (!(e instanceof ExitStatus)) {
                  if (e && typeof e == "object" && e.stack)
                    err("exception thrown: " + [e, e.stack]);
                  throw e;
                }
              }
            }
            Module["websocket"]["on"](event2, callback ? _callback : null);
          };
          function _emscripten_set_socket_error_callback(userData, callback) {
            userData >>>= 0;
            callback >>>= 0;
            _setNetworkCallback("error", userData, callback);
          }
          _emscripten_set_socket_error_callback.sig = "vpp";
          function _emscripten_set_socket_open_callback(userData, callback) {
            userData >>>= 0;
            callback >>>= 0;
            _setNetworkCallback("open", userData, callback);
          }
          _emscripten_set_socket_open_callback.sig = "vpp";
          function _emscripten_set_socket_listen_callback(userData, callback) {
            userData >>>= 0;
            callback >>>= 0;
            _setNetworkCallback("listen", userData, callback);
          }
          _emscripten_set_socket_listen_callback.sig = "vpp";
          function _emscripten_set_socket_connection_callback(userData, callback) {
            userData >>>= 0;
            callback >>>= 0;
            _setNetworkCallback("connection", userData, callback);
          }
          _emscripten_set_socket_connection_callback.sig = "vpp";
          function _emscripten_set_socket_message_callback(userData, callback) {
            userData >>>= 0;
            callback >>>= 0;
            _setNetworkCallback("message", userData, callback);
          }
          _emscripten_set_socket_message_callback.sig = "vpp";
          function _emscripten_set_socket_close_callback(userData, callback) {
            userData >>>= 0;
            callback >>>= 0;
            _setNetworkCallback("close", userData, callback);
          }
          _emscripten_set_socket_close_callback.sig = "vpp";
          function _emscripten_webgl_enable_ANGLE_instanced_arrays(ctx) {
            ctx >>>= 0;
            return webgl_enable_ANGLE_instanced_arrays(GL.contexts[ctx].GLctx);
          }
          _emscripten_webgl_enable_ANGLE_instanced_arrays.sig = "ip";
          function _emscripten_webgl_enable_OES_vertex_array_object(ctx) {
            ctx >>>= 0;
            return webgl_enable_OES_vertex_array_object(GL.contexts[ctx].GLctx);
          }
          _emscripten_webgl_enable_OES_vertex_array_object.sig = "ip";
          function _emscripten_webgl_enable_WEBGL_draw_buffers(ctx) {
            ctx >>>= 0;
            return webgl_enable_WEBGL_draw_buffers(GL.contexts[ctx].GLctx);
          }
          _emscripten_webgl_enable_WEBGL_draw_buffers.sig = "ip";
          function _emscripten_webgl_enable_WEBGL_multi_draw(ctx) {
            ctx >>>= 0;
            return webgl_enable_WEBGL_multi_draw(GL.contexts[ctx].GLctx);
          }
          _emscripten_webgl_enable_WEBGL_multi_draw.sig = "ip";
          function _glVertexPointer(size, type, stride, ptr2) {
            ptr2 >>>= 0;
            throw "Legacy GL function (glVertexPointer) called. If you want legacy GL emulation, you need to compile with -sLEGACY_GL_EMULATION to enable legacy GL emulation.";
          }
          _glVertexPointer.sig = "viiip";
          var _glMatrixMode = () => {
            throw "Legacy GL function (glMatrixMode) called. If you want legacy GL emulation, you need to compile with -sLEGACY_GL_EMULATION to enable legacy GL emulation.";
          };
          _glMatrixMode.sig = "vi";
          var _glBegin = () => {
            throw "Legacy GL function (glBegin) called. If you want legacy GL emulation, you need to compile with -sLEGACY_GL_EMULATION to enable legacy GL emulation.";
          };
          _glBegin.sig = "vi";
          var _glLoadIdentity = () => {
            throw "Legacy GL function (glLoadIdentity) called. If you want legacy GL emulation, you need to compile with -sLEGACY_GL_EMULATION to enable legacy GL emulation.";
          };
          _glLoadIdentity.sig = "v";
          var _glVertexAttribDivisorNV = _glVertexAttribDivisor;
          var _glDrawArraysInstancedNV = _glDrawArraysInstanced;
          var _glDrawElementsInstancedNV = _glDrawElementsInstanced;
          var _glVertexAttribDivisorEXT = _glVertexAttribDivisor;
          var _glDrawArraysInstancedEXT = _glDrawArraysInstanced;
          var _glDrawElementsInstancedEXT = _glDrawElementsInstanced;
          var _glVertexAttribDivisorARB = _glVertexAttribDivisor;
          var _glDrawArraysInstancedARB = _glDrawArraysInstanced;
          var _glDrawElementsInstancedARB = _glDrawElementsInstanced;
          var _glDrawBuffersEXT = _glDrawBuffers;
          function _glMultiDrawArraysWEBGL(mode, firsts, counts, drawcount) {
            firsts >>>= 0;
            counts >>>= 0;
            GLctx.multiDrawWebgl["multiDrawArraysWEBGL"](mode, HEAP32, firsts >> 2, HEAP32, counts >> 2, drawcount);
          }
          _glMultiDrawArraysWEBGL.sig = "vippi";
          var _glMultiDrawArrays = _glMultiDrawArraysWEBGL;
          _glMultiDrawArrays.sig = "vippi";
          var _glMultiDrawArraysANGLE = _glMultiDrawArraysWEBGL;
          function _glMultiDrawArraysInstancedWEBGL(mode, firsts, counts, instanceCounts, drawcount) {
            firsts >>>= 0;
            counts >>>= 0;
            instanceCounts >>>= 0;
            GLctx.multiDrawWebgl["multiDrawArraysInstancedWEBGL"](mode, HEAP32, firsts >> 2, HEAP32, counts >> 2, HEAP32, instanceCounts >> 2, drawcount);
          }
          _glMultiDrawArraysInstancedWEBGL.sig = "vipppi";
          var _glMultiDrawArraysInstancedANGLE = _glMultiDrawArraysInstancedWEBGL;
          function _glMultiDrawElementsWEBGL(mode, counts, type, offsets, drawcount) {
            counts >>>= 0;
            offsets >>>= 0;
            GLctx.multiDrawWebgl["multiDrawElementsWEBGL"](mode, HEAP32, counts >> 2, type, HEAP32, offsets >> 2, drawcount);
          }
          _glMultiDrawElementsWEBGL.sig = "vipipi";
          var _glMultiDrawElements = _glMultiDrawElementsWEBGL;
          _glMultiDrawElements.sig = "vipipi";
          var _glMultiDrawElementsANGLE = _glMultiDrawElementsWEBGL;
          function _glMultiDrawElementsInstancedWEBGL(mode, counts, type, offsets, instanceCounts, drawcount) {
            counts >>>= 0;
            offsets >>>= 0;
            instanceCounts >>>= 0;
            GLctx.multiDrawWebgl["multiDrawElementsInstancedWEBGL"](mode, HEAP32, counts >> 2, type, HEAP32, offsets >> 2, HEAP32, instanceCounts >> 2, drawcount);
          }
          _glMultiDrawElementsInstancedWEBGL.sig = "vipippi";
          var _glMultiDrawElementsInstancedANGLE = _glMultiDrawElementsInstancedWEBGL;
          function _glClearDepth(x0) {
            GLctx.clearDepth(x0);
          }
          _glClearDepth.sig = "vd";
          function _glDepthRange(x0, x1) {
            GLctx.depthRange(x0, x1);
          }
          _glDepthRange.sig = "vdd";
          var _emscripten_glGenVertexArrays = _glGenVertexArrays;
          var _emscripten_glDeleteVertexArrays = _glDeleteVertexArrays;
          var _emscripten_glBindVertexArray = _glBindVertexArray;
          var _emscripten_glIsVertexArray = _glIsVertexArray;
          var _emscripten_glVertexPointer = _glVertexPointer;
          var _emscripten_glMatrixMode = _glMatrixMode;
          var _emscripten_glBegin = _glBegin;
          var _emscripten_glLoadIdentity = _glLoadIdentity;
          var _emscripten_glVertexAttribDivisor = _glVertexAttribDivisor;
          var _emscripten_glDrawArraysInstanced = _glDrawArraysInstanced;
          var _emscripten_glDrawElementsInstanced = _glDrawElementsInstanced;
          var _emscripten_glVertexAttribDivisorNV = _glVertexAttribDivisorNV;
          var _emscripten_glDrawArraysInstancedNV = _glDrawArraysInstancedNV;
          var _emscripten_glDrawElementsInstancedNV = _glDrawElementsInstancedNV;
          var _emscripten_glVertexAttribDivisorEXT = _glVertexAttribDivisorEXT;
          var _emscripten_glDrawArraysInstancedEXT = _glDrawArraysInstancedEXT;
          var _emscripten_glDrawElementsInstancedEXT = _glDrawElementsInstancedEXT;
          var _emscripten_glVertexAttribDivisorARB = _glVertexAttribDivisorARB;
          var _emscripten_glDrawArraysInstancedARB = _glDrawArraysInstancedARB;
          var _emscripten_glDrawElementsInstancedARB = _glDrawElementsInstancedARB;
          var _emscripten_glDrawBuffers = _glDrawBuffers;
          var _emscripten_glDrawBuffersEXT = _glDrawBuffersEXT;
          var _emscripten_glMultiDrawArrays = _glMultiDrawArrays;
          var _emscripten_glMultiDrawArraysANGLE = _glMultiDrawArraysANGLE;
          var _emscripten_glMultiDrawArraysWEBGL = _glMultiDrawArraysWEBGL;
          var _emscripten_glMultiDrawArraysInstancedANGLE = _glMultiDrawArraysInstancedANGLE;
          var _emscripten_glMultiDrawArraysInstancedWEBGL = _glMultiDrawArraysInstancedWEBGL;
          var _emscripten_glMultiDrawElements = _glMultiDrawElements;
          var _emscripten_glMultiDrawElementsANGLE = _glMultiDrawElementsANGLE;
          var _emscripten_glMultiDrawElementsWEBGL = _glMultiDrawElementsWEBGL;
          var _emscripten_glMultiDrawElementsInstancedANGLE = _glMultiDrawElementsInstancedANGLE;
          var _emscripten_glMultiDrawElementsInstancedWEBGL = _glMultiDrawElementsInstancedWEBGL;
          var _emscripten_glClearDepth = _glClearDepth;
          var _emscripten_glDepthRange = _glDepthRange;
          var writeGLArray = (arr, dst, dstLength, heapType) => {
            var len2 = arr.length;
            var writeLength = dstLength < len2 ? dstLength : len2;
            var heap = heapType ? HEAPF32 : HEAP32;
            for (var i2 = 0; i2 < writeLength; ++i2) {
              heap[(dst >> 2) + i2 >>> 0] = arr[i2];
            }
            return len2;
          };
          function _emscripten_webgl_init_context_attributes(attributes) {
            attributes >>>= 0;
            var a = attributes >> 2;
            for (var i2 = 0; i2 < 56 >> 2; ++i2) {
              HEAP32[a + i2 >>> 0] = 0;
            }
            HEAP32[a + (0 >> 2) >>> 0] = HEAP32[a + (4 >> 2) >>> 0] = HEAP32[a + (12 >> 2) >>> 0] = HEAP32[a + (16 >> 2) >>> 0] = HEAP32[a + (32 >> 2) >>> 0] = HEAP32[a + (40 >> 2) >>> 0] = 1;
          }
          _emscripten_webgl_init_context_attributes.sig = "vp";
          var emscripten_webgl_power_preferences = ["default", "low-power", "high-performance"];
          function _emscripten_webgl_do_create_context(target, attributes) {
            target >>>= 0;
            attributes >>>= 0;
            var a = attributes >> 2;
            var powerPreference = HEAP32[a + (24 >> 2) >>> 0];
            var contextAttributes = {
              "alpha": !!HEAP32[a + (0 >> 2) >>> 0],
              "depth": !!HEAP32[a + (4 >> 2) >>> 0],
              "stencil": !!HEAP32[a + (8 >> 2) >>> 0],
              "antialias": !!HEAP32[a + (12 >> 2) >>> 0],
              "premultipliedAlpha": !!HEAP32[a + (16 >> 2) >>> 0],
              "preserveDrawingBuffer": !!HEAP32[a + (20 >> 2) >>> 0],
              "powerPreference": emscripten_webgl_power_preferences[powerPreference],
              "failIfMajorPerformanceCaveat": !!HEAP32[a + (28 >> 2) >>> 0],
              majorVersion: HEAP32[a + (32 >> 2) >>> 0],
              minorVersion: HEAP32[a + (36 >> 2) >>> 0],
              enableExtensionsByDefault: HEAP32[a + (40 >> 2) >>> 0],
              explicitSwapControl: HEAP32[a + (44 >> 2) >>> 0],
              proxyContextToMainThread: HEAP32[a + (48 >> 2) >>> 0],
              renderViaOffscreenBackBuffer: HEAP32[a + (52 >> 2) >>> 0]
            };
            var canvas = findCanvasEventTarget(target);
            if (!canvas) {
              return 0;
            }
            if (contextAttributes.explicitSwapControl) {
              return 0;
            }
            var contextHandle = GL.createContext(canvas, contextAttributes);
            return contextHandle;
          }
          _emscripten_webgl_do_create_context.sig = "ppp";
          var _emscripten_webgl_create_context = _emscripten_webgl_do_create_context;
          _emscripten_webgl_create_context.sig = "ppp";
          function _emscripten_webgl_do_get_current_context() {
            return GL.currentContext ? GL.currentContext.handle : 0;
          }
          _emscripten_webgl_do_get_current_context.sig = "p";
          var _emscripten_webgl_get_current_context = _emscripten_webgl_do_get_current_context;
          _emscripten_webgl_get_current_context.sig = "p";
          var _emscripten_webgl_do_commit_frame = () => {
            if (!GL.currentContext || !GL.currentContext.GLctx) {
              return -3;
            }
            if (!GL.currentContext.attributes.explicitSwapControl) {
              return -3;
            }
            return 0;
          };
          _emscripten_webgl_do_commit_frame.sig = "i";
          var _emscripten_webgl_commit_frame = _emscripten_webgl_do_commit_frame;
          _emscripten_webgl_commit_frame.sig = "i";
          function _emscripten_webgl_make_context_current(contextHandle) {
            contextHandle >>>= 0;
            var success = GL.makeContextCurrent(contextHandle);
            return success ? 0 : -5;
          }
          _emscripten_webgl_make_context_current.sig = "ip";
          function _emscripten_webgl_get_drawing_buffer_size(contextHandle, width, height) {
            contextHandle >>>= 0;
            width >>>= 0;
            height >>>= 0;
            var GLContext = GL.getContext(contextHandle);
            if (!GLContext || !GLContext.GLctx || !width || !height) {
              return -5;
            }
            HEAP32[width >>> 2 >>> 0] = GLContext.GLctx.drawingBufferWidth;
            HEAP32[height >>> 2 >>> 0] = GLContext.GLctx.drawingBufferHeight;
            return 0;
          }
          _emscripten_webgl_get_drawing_buffer_size.sig = "ippp";
          function _emscripten_webgl_get_context_attributes(c, a) {
            c >>>= 0;
            a >>>= 0;
            if (!a)
              return -5;
            c = GL.contexts[c];
            if (!c)
              return -3;
            var t = c.GLctx;
            if (!t)
              return -3;
            t = t.getContextAttributes();
            HEAP32[a >>> 2 >>> 0] = t.alpha;
            HEAP32[a + 4 >>> 2 >>> 0] = t.depth;
            HEAP32[a + 8 >>> 2 >>> 0] = t.stencil;
            HEAP32[a + 12 >>> 2 >>> 0] = t.antialias;
            HEAP32[a + 16 >>> 2 >>> 0] = t.premultipliedAlpha;
            HEAP32[a + 20 >>> 2 >>> 0] = t.preserveDrawingBuffer;
            var power = t["powerPreference"] && emscripten_webgl_power_preferences.indexOf(t["powerPreference"]);
            HEAP32[a + 24 >>> 2 >>> 0] = power;
            HEAP32[a + 28 >>> 2 >>> 0] = t.failIfMajorPerformanceCaveat;
            HEAP32[a + 32 >>> 2 >>> 0] = c.version;
            HEAP32[a + 36 >>> 2 >>> 0] = 0;
            HEAP32[a + 40 >>> 2 >>> 0] = c.attributes.enableExtensionsByDefault;
            return 0;
          }
          _emscripten_webgl_get_context_attributes.sig = "ipp";
          function _emscripten_webgl_destroy_context(contextHandle) {
            contextHandle >>>= 0;
            if (GL.currentContext == contextHandle)
              GL.currentContext = 0;
            GL.deleteContext(contextHandle);
          }
          _emscripten_webgl_destroy_context.sig = "ip";
          function _emscripten_webgl_enable_extension(contextHandle, extension) {
            contextHandle >>>= 0;
            extension >>>= 0;
            var context = GL.getContext(contextHandle);
            var extString = UTF8ToString(extension);
            if (extString.startsWith("GL_"))
              extString = extString.substr(3);
            if (extString == "ANGLE_instanced_arrays")
              webgl_enable_ANGLE_instanced_arrays(GLctx);
            if (extString == "OES_vertex_array_object")
              webgl_enable_OES_vertex_array_object(GLctx);
            if (extString == "WEBGL_draw_buffers")
              webgl_enable_WEBGL_draw_buffers(GLctx);
            if (extString == "WEBGL_multi_draw")
              webgl_enable_WEBGL_multi_draw(GLctx);
            var ext = context.GLctx.getExtension(extString);
            return !!ext;
          }
          _emscripten_webgl_enable_extension.sig = "ipp";
          var _emscripten_supports_offscreencanvas = () => 0;
          _emscripten_supports_offscreencanvas.sig = "i";
          var registerWebGlEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
            var webGlEventHandlerFunc = (e = event) => {
              if (getWasmTableEntry(callbackfunc)(eventTypeId, 0, userData))
                e.preventDefault();
            };
            var eventHandler = {
              target: findEventTarget(target),
              eventTypeString,
              callbackfunc,
              handlerFunc: webGlEventHandlerFunc,
              useCapture
            };
            JSEvents.registerOrRemoveHandler(eventHandler);
          };
          function _emscripten_set_webglcontextlost_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
            target >>>= 0;
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            registerWebGlEventCallback(target, userData, useCapture, callbackfunc, 31, "webglcontextlost", targetThread);
            return 0;
          }
          _emscripten_set_webglcontextlost_callback_on_thread.sig = "ippipp";
          function _emscripten_set_webglcontextrestored_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
            target >>>= 0;
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            registerWebGlEventCallback(target, userData, useCapture, callbackfunc, 32, "webglcontextrestored", targetThread);
            return 0;
          }
          _emscripten_set_webglcontextrestored_callback_on_thread.sig = "ippipp";
          function _emscripten_is_webgl_context_lost(contextHandle) {
            contextHandle >>>= 0;
            return !GL.contexts[contextHandle] || GL.contexts[contextHandle].GLctx.isContextLost();
          }
          _emscripten_is_webgl_context_lost.sig = "ip";
          function _emscripten_webgl_get_supported_extensions() {
            return stringToNewUTF8(GLctx.getSupportedExtensions().join(" "));
          }
          _emscripten_webgl_get_supported_extensions.sig = "p";
          var _emscripten_webgl_get_program_parameter_d = (program, param) => GLctx.getProgramParameter(GL.programs[program], param);
          _emscripten_webgl_get_program_parameter_d.sig = "dii";
          function _emscripten_webgl_get_program_info_log_utf8(program) {
            return stringToNewUTF8(GLctx.getProgramInfoLog(GL.programs[program]));
          }
          _emscripten_webgl_get_program_info_log_utf8.sig = "pi";
          var _emscripten_webgl_get_shader_parameter_d = (shader, param) => GLctx.getShaderParameter(GL.shaders[shader], param);
          _emscripten_webgl_get_shader_parameter_d.sig = "dii";
          function _emscripten_webgl_get_shader_info_log_utf8(shader) {
            return stringToNewUTF8(GLctx.getShaderInfoLog(GL.shaders[shader]));
          }
          _emscripten_webgl_get_shader_info_log_utf8.sig = "pi";
          function _emscripten_webgl_get_shader_source_utf8(shader) {
            return stringToNewUTF8(GLctx.getShaderSource(GL.shaders[shader]));
          }
          _emscripten_webgl_get_shader_source_utf8.sig = "pi";
          var _emscripten_webgl_get_vertex_attrib_d = (index, param) => GLctx.getVertexAttrib(index, param);
          _emscripten_webgl_get_vertex_attrib_d.sig = "dii";
          var _emscripten_webgl_get_vertex_attrib_o = (index, param) => {
            var obj = GLctx.getVertexAttrib(index, param);
            return obj?.name;
          };
          _emscripten_webgl_get_vertex_attrib_o.sig = "iii";
          function _emscripten_webgl_get_vertex_attrib_v(index, param, dst, dstLength, dstType) {
            dst >>>= 0;
            return writeGLArray(GLctx.getVertexAttrib(index, param), dst, dstLength, dstType);
          }
          _emscripten_webgl_get_vertex_attrib_v.sig = "iiipii";
          var _emscripten_webgl_get_uniform_d = (program, location) => GLctx.getUniform(GL.programs[program], webglGetUniformLocation(location));
          _emscripten_webgl_get_uniform_d.sig = "dii";
          function _emscripten_webgl_get_uniform_v(program, location, dst, dstLength, dstType) {
            dst >>>= 0;
            return writeGLArray(GLctx.getUniform(GL.programs[program], webglGetUniformLocation(location)), dst, dstLength, dstType);
          }
          _emscripten_webgl_get_uniform_v.sig = "iiipii";
          function _emscripten_webgl_get_parameter_v(param, dst, dstLength, dstType) {
            dst >>>= 0;
            return writeGLArray(GLctx.getParameter(param), dst, dstLength, dstType);
          }
          _emscripten_webgl_get_parameter_v.sig = "iipii";
          var _emscripten_webgl_get_parameter_d = (param) => GLctx.getParameter(param);
          _emscripten_webgl_get_parameter_d.sig = "di";
          var _emscripten_webgl_get_parameter_o = (param) => {
            var obj = GLctx.getParameter(param);
            return obj?.name;
          };
          _emscripten_webgl_get_parameter_o.sig = "ii";
          function _emscripten_webgl_get_parameter_utf8(param) {
            return stringToNewUTF8(GLctx.getParameter(param));
          }
          _emscripten_webgl_get_parameter_utf8.sig = "pi";
          function _emscripten_webgl_get_parameter_i64v(param, dst) {
            dst >>>= 0;
            return writeI53ToI64(dst, GLctx.getParameter(param));
          }
          _emscripten_webgl_get_parameter_i64v.sig = "vip";
          var _glutPostRedisplay = () => {
            if (GLUT.displayFunc && !GLUT.requestedAnimationFrame) {
              GLUT.requestedAnimationFrame = true;
              Browser.requestAnimationFrame(function() {
                GLUT.requestedAnimationFrame = false;
                Browser.mainLoop.runIter(function() {
                  getWasmTableEntry(GLUT.displayFunc)();
                });
              });
            }
          };
          _glutPostRedisplay.sig = "v";
          var GLUT = {
            initTime: null,
            idleFunc: null,
            displayFunc: null,
            keyboardFunc: null,
            keyboardUpFunc: null,
            specialFunc: null,
            specialUpFunc: null,
            reshapeFunc: null,
            motionFunc: null,
            passiveMotionFunc: null,
            mouseFunc: null,
            buttons: 0,
            modifiers: 0,
            initWindowWidth: 256,
            initWindowHeight: 256,
            initDisplayMode: 18,
            windowX: 0,
            windowY: 0,
            windowWidth: 0,
            windowHeight: 0,
            requestedAnimationFrame: false,
            saveModifiers: (event2) => {
              GLUT.modifiers = 0;
              if (event2["shiftKey"])
                GLUT.modifiers += 1;
              if (event2["ctrlKey"])
                GLUT.modifiers += 2;
              if (event2["altKey"])
                GLUT.modifiers += 4;
            },
            onMousemove: (event2) => {
              var lastX = Browser.mouseX;
              var lastY = Browser.mouseY;
              Browser.calculateMouseEvent(event2);
              var newX = Browser.mouseX;
              var newY = Browser.mouseY;
              if (newX == lastX && newY == lastY)
                return;
              if (GLUT.buttons == 0 && event2.target == Module["canvas"] && GLUT.passiveMotionFunc) {
                event2.preventDefault();
                GLUT.saveModifiers(event2);
                getWasmTableEntry(GLUT.passiveMotionFunc)(lastX, lastY);
              } else if (GLUT.buttons != 0 && GLUT.motionFunc) {
                event2.preventDefault();
                GLUT.saveModifiers(event2);
                getWasmTableEntry(GLUT.motionFunc)(lastX, lastY);
              }
            },
            getSpecialKey: (keycode) => {
              var key = null;
              switch (keycode) {
                case 8:
                  key = 120;
                  break;
                case 46:
                  key = 111;
                  break;
                case 112:
                  key = 1;
                  break;
                case 113:
                  key = 2;
                  break;
                case 114:
                  key = 3;
                  break;
                case 115:
                  key = 4;
                  break;
                case 116:
                  key = 5;
                  break;
                case 117:
                  key = 6;
                  break;
                case 118:
                  key = 7;
                  break;
                case 119:
                  key = 8;
                  break;
                case 120:
                  key = 9;
                  break;
                case 121:
                  key = 10;
                  break;
                case 122:
                  key = 11;
                  break;
                case 123:
                  key = 12;
                  break;
                case 37:
                  key = 100;
                  break;
                case 38:
                  key = 101;
                  break;
                case 39:
                  key = 102;
                  break;
                case 40:
                  key = 103;
                  break;
                case 33:
                  key = 104;
                  break;
                case 34:
                  key = 105;
                  break;
                case 36:
                  key = 106;
                  break;
                case 35:
                  key = 107;
                  break;
                case 45:
                  key = 108;
                  break;
                case 16:
                case 5:
                  key = 112;
                  break;
                case 6:
                  key = 113;
                  break;
                case 17:
                case 3:
                  key = 114;
                  break;
                case 4:
                  key = 115;
                  break;
                case 18:
                case 2:
                  key = 116;
                  break;
                case 1:
                  key = 117;
                  break;
              }
              return key;
            },
            getASCIIKey: (event2) => {
              if (event2["ctrlKey"] || event2["altKey"] || event2["metaKey"])
                return null;
              var keycode = event2["keyCode"];
              if (48 <= keycode && keycode <= 57)
                return keycode;
              if (65 <= keycode && keycode <= 90)
                return event2["shiftKey"] ? keycode : keycode + 32;
              if (96 <= keycode && keycode <= 105)
                return keycode - 48;
              if (106 <= keycode && keycode <= 111)
                return keycode - 106 + 42;
              switch (keycode) {
                case 9:
                case 13:
                case 27:
                case 32:
                case 61:
                  return keycode;
              }
              var s2 = event2["shiftKey"];
              switch (keycode) {
                case 186:
                  return s2 ? 58 : 59;
                case 187:
                  return s2 ? 43 : 61;
                case 188:
                  return s2 ? 60 : 44;
                case 189:
                  return s2 ? 95 : 45;
                case 190:
                  return s2 ? 62 : 46;
                case 191:
                  return s2 ? 63 : 47;
                case 219:
                  return s2 ? 123 : 91;
                case 220:
                  return s2 ? 124 : 47;
                case 221:
                  return s2 ? 125 : 93;
                case 222:
                  return s2 ? 34 : 39;
              }
              return null;
            },
            onKeydown: (event2) => {
              if (GLUT.specialFunc || GLUT.keyboardFunc) {
                var key = GLUT.getSpecialKey(event2["keyCode"]);
                if (key !== null) {
                  if (GLUT.specialFunc) {
                    event2.preventDefault();
                    GLUT.saveModifiers(event2);
                    getWasmTableEntry(GLUT.specialFunc)(key, Browser.mouseX, Browser.mouseY);
                  }
                } else {
                  key = GLUT.getASCIIKey(event2);
                  if (key !== null && GLUT.keyboardFunc) {
                    event2.preventDefault();
                    GLUT.saveModifiers(event2);
                    getWasmTableEntry(GLUT.keyboardFunc)(key, Browser.mouseX, Browser.mouseY);
                  }
                }
              }
            },
            onKeyup: (event2) => {
              if (GLUT.specialUpFunc || GLUT.keyboardUpFunc) {
                var key = GLUT.getSpecialKey(event2["keyCode"]);
                if (key !== null) {
                  if (GLUT.specialUpFunc) {
                    event2.preventDefault();
                    GLUT.saveModifiers(event2);
                    getWasmTableEntry(GLUT.specialUpFunc)(key, Browser.mouseX, Browser.mouseY);
                  }
                } else {
                  key = GLUT.getASCIIKey(event2);
                  if (key !== null && GLUT.keyboardUpFunc) {
                    event2.preventDefault();
                    GLUT.saveModifiers(event2);
                    getWasmTableEntry(GLUT.keyboardUpFunc)(key, Browser.mouseX, Browser.mouseY);
                  }
                }
              }
            },
            touchHandler: (event2) => {
              if (event2.target != Module["canvas"]) {
                return;
              }
              var touches = event2.changedTouches, main = touches[0], type = "";
              switch (event2.type) {
                case "touchstart":
                  type = "mousedown";
                  break;
                case "touchmove":
                  type = "mousemove";
                  break;
                case "touchend":
                  type = "mouseup";
                  break;
                default:
                  return;
              }
              var simulatedEvent = document.createEvent("MouseEvent");
              simulatedEvent.initMouseEvent(type, true, true, window, 1, main.screenX, main.screenY, main.clientX, main.clientY, false, false, false, false, 0, null);
              main.target.dispatchEvent(simulatedEvent);
              event2.preventDefault();
            },
            onMouseButtonDown: (event2) => {
              Browser.calculateMouseEvent(event2);
              GLUT.buttons |= 1 << event2["button"];
              if (event2.target == Module["canvas"] && GLUT.mouseFunc) {
                try {
                  event2.target.setCapture();
                } catch (e) {
                }
                event2.preventDefault();
                GLUT.saveModifiers(event2);
                getWasmTableEntry(GLUT.mouseFunc)(event2["button"], 0, Browser.mouseX, Browser.mouseY);
              }
            },
            onMouseButtonUp: (event2) => {
              Browser.calculateMouseEvent(event2);
              GLUT.buttons &= ~(1 << event2["button"]);
              if (GLUT.mouseFunc) {
                event2.preventDefault();
                GLUT.saveModifiers(event2);
                getWasmTableEntry(GLUT.mouseFunc)(event2["button"], 1, Browser.mouseX, Browser.mouseY);
              }
            },
            onMouseWheel: (event2) => {
              Browser.calculateMouseEvent(event2);
              var e = window.event || event2;
              var delta = -Browser.getMouseWheelDelta(event2);
              delta = delta == 0 ? 0 : delta > 0 ? Math.max(delta, 1) : Math.min(delta, -1);
              var button = 3;
              if (delta < 0) {
                button = 4;
              }
              if (GLUT.mouseFunc) {
                event2.preventDefault();
                GLUT.saveModifiers(event2);
                getWasmTableEntry(GLUT.mouseFunc)(button, 0, Browser.mouseX, Browser.mouseY);
              }
            },
            onFullscreenEventChange: (event2) => {
              var width;
              var height;
              if (document["fullscreen"] || document["fullScreen"] || document["mozFullScreen"] || document["webkitIsFullScreen"]) {
                width = screen["width"];
                height = screen["height"];
              } else {
                width = GLUT.windowWidth;
                height = GLUT.windowHeight;
                document.removeEventListener("fullscreenchange", GLUT.onFullscreenEventChange, true);
                document.removeEventListener("mozfullscreenchange", GLUT.onFullscreenEventChange, true);
                document.removeEventListener("webkitfullscreenchange", GLUT.onFullscreenEventChange, true);
              }
              Browser.setCanvasSize(width, height, true);
              if (GLUT.reshapeFunc) {
                getWasmTableEntry(GLUT.reshapeFunc)(width, height);
              }
              _glutPostRedisplay();
            }
          };
          var _glutGetModifiers = () => GLUT.modifiers;
          _glutGetModifiers.sig = "i";
          function _glutInit(argcp, argv) {
            argcp >>>= 0;
            argv >>>= 0;
            GLUT.initTime = Date.now();
            var isTouchDevice = "ontouchstart" in document.documentElement;
            if (isTouchDevice) {
              window.addEventListener("touchmove", GLUT.touchHandler, true);
              window.addEventListener("touchstart", GLUT.touchHandler, true);
              window.addEventListener("touchend", GLUT.touchHandler, true);
            }
            window.addEventListener("keydown", GLUT.onKeydown, true);
            window.addEventListener("keyup", GLUT.onKeyup, true);
            window.addEventListener("mousemove", GLUT.onMousemove, true);
            window.addEventListener("mousedown", GLUT.onMouseButtonDown, true);
            window.addEventListener("mouseup", GLUT.onMouseButtonUp, true);
            window.addEventListener("mousewheel", GLUT.onMouseWheel, true);
            window.addEventListener("DOMMouseScroll", GLUT.onMouseWheel, true);
            Browser.resizeListeners.push(function(width, height) {
              if (GLUT.reshapeFunc) {
                getWasmTableEntry(GLUT.reshapeFunc)(width, height);
              }
            });
            __ATEXIT__.push(function() {
              if (isTouchDevice) {
                window.removeEventListener("touchmove", GLUT.touchHandler, true);
                window.removeEventListener("touchstart", GLUT.touchHandler, true);
                window.removeEventListener("touchend", GLUT.touchHandler, true);
              }
              window.removeEventListener("keydown", GLUT.onKeydown, true);
              window.removeEventListener("keyup", GLUT.onKeyup, true);
              window.removeEventListener("mousemove", GLUT.onMousemove, true);
              window.removeEventListener("mousedown", GLUT.onMouseButtonDown, true);
              window.removeEventListener("mouseup", GLUT.onMouseButtonUp, true);
              window.removeEventListener("mousewheel", GLUT.onMouseWheel, true);
              window.removeEventListener("DOMMouseScroll", GLUT.onMouseWheel, true);
              Module["canvas"].width = Module["canvas"].height = 1;
            });
          }
          _glutInit.sig = "vpp";
          var _glutInitWindowSize = (width, height) => {
            Browser.setCanvasSize(GLUT.initWindowWidth = width, GLUT.initWindowHeight = height);
          };
          _glutInitWindowSize.sig = "vii";
          var _glutInitWindowPosition = (x, y) => {
          };
          _glutInitWindowPosition.sig = "vii";
          var _glutGet = (type) => {
            switch (type) {
              case 100:
                return 0;
              case 101:
                return 0;
              case 102:
                return Module["canvas"].width;
              case 103:
                return Module["canvas"].height;
              case 200:
                return Module["canvas"].width;
              case 201:
                return Module["canvas"].height;
              case 500:
                return 0;
              case 501:
                return 0;
              case 502:
                return GLUT.initWindowWidth;
              case 503:
                return GLUT.initWindowHeight;
              case 700:
                var now = Date.now();
                return now - GLUT.initTime;
              case 105:
                return Module.ctx.getContextAttributes().stencil ? 8 : 0;
              case 106:
                return Module.ctx.getContextAttributes().depth ? 8 : 0;
              case 110:
                return Module.ctx.getContextAttributes().alpha ? 8 : 0;
              case 120:
                return Module.ctx.getContextAttributes().antialias ? 1 : 0;
              default:
                throw "glutGet(" + type + ") not implemented yet";
            }
          };
          _glutGet.sig = "ii";
          function _glutIdleFunc(func2) {
            func2 >>>= 0;
            function callback() {
              if (GLUT.idleFunc) {
                getWasmTableEntry(GLUT.idleFunc)();
                safeSetTimeout(callback, 4);
              }
            }
            if (!GLUT.idleFunc) {
              safeSetTimeout(callback, 0);
            }
            GLUT.idleFunc = func2;
          }
          _glutIdleFunc.sig = "vp";
          var _glutTimerFunc = function(msec, func2, value) {
            func2 >>>= 0;
            return safeSetTimeout(() => getWasmTableEntry(func2)(value), msec);
          };
          _glutTimerFunc.sig = "vipi";
          function _glutDisplayFunc(func2) {
            func2 >>>= 0;
            GLUT.displayFunc = func2;
          }
          _glutDisplayFunc.sig = "vp";
          function _glutKeyboardFunc(func2) {
            func2 >>>= 0;
            GLUT.keyboardFunc = func2;
          }
          _glutKeyboardFunc.sig = "vp";
          function _glutKeyboardUpFunc(func2) {
            func2 >>>= 0;
            GLUT.keyboardUpFunc = func2;
          }
          _glutKeyboardUpFunc.sig = "vp";
          function _glutSpecialFunc(func2) {
            func2 >>>= 0;
            GLUT.specialFunc = func2;
          }
          _glutSpecialFunc.sig = "vp";
          function _glutSpecialUpFunc(func2) {
            func2 >>>= 0;
            GLUT.specialUpFunc = func2;
          }
          _glutSpecialUpFunc.sig = "vp";
          function _glutReshapeFunc(func2) {
            func2 >>>= 0;
            GLUT.reshapeFunc = func2;
          }
          _glutReshapeFunc.sig = "vp";
          function _glutMotionFunc(func2) {
            func2 >>>= 0;
            GLUT.motionFunc = func2;
          }
          _glutMotionFunc.sig = "vp";
          function _glutPassiveMotionFunc(func2) {
            func2 >>>= 0;
            GLUT.passiveMotionFunc = func2;
          }
          _glutPassiveMotionFunc.sig = "vp";
          function _glutMouseFunc(func2) {
            func2 >>>= 0;
            GLUT.mouseFunc = func2;
          }
          _glutMouseFunc.sig = "vp";
          var _glutSetCursor = (cursor) => {
            var cursorStyle = "auto";
            switch (cursor) {
              case 0:
                break;
              case 1:
                break;
              case 2:
                cursorStyle = "pointer";
                break;
              case 3:
                break;
              case 4:
                cursorStyle = "help";
                break;
              case 5:
                break;
              case 6:
                break;
              case 7:
                cursorStyle = "wait";
                break;
              case 8:
                cursorStyle = "text";
                break;
              case 9:
              case 102:
                cursorStyle = "crosshair";
                break;
              case 10:
                cursorStyle = "ns-resize";
                break;
              case 11:
                cursorStyle = "ew-resize";
                break;
              case 12:
                cursorStyle = "n-resize";
                break;
              case 13:
                cursorStyle = "s-resize";
                break;
              case 14:
                cursorStyle = "w-resize";
                break;
              case 15:
                cursorStyle = "e-resize";
                break;
              case 16:
                cursorStyle = "nw-resize";
                break;
              case 17:
                cursorStyle = "ne-resize";
                break;
              case 18:
                cursorStyle = "se-resize";
                break;
              case 19:
                cursorStyle = "sw-resize";
                break;
              case 100:
                break;
              case 101:
                cursorStyle = "none";
                break;
              default:
                throw "glutSetCursor: Unknown cursor type: " + cursor;
            }
            Module["canvas"].style.cursor = cursorStyle;
          };
          _glutSetCursor.sig = "vi";
          function _glutCreateWindow(name2) {
            name2 >>>= 0;
            var contextAttributes = {
              antialias: (GLUT.initDisplayMode & 128) != 0,
              depth: (GLUT.initDisplayMode & 16) != 0,
              stencil: (GLUT.initDisplayMode & 32) != 0,
              alpha: (GLUT.initDisplayMode & 8) != 0
            };
            Module.ctx = Browser.createContext(Module["canvas"], true, true, contextAttributes);
            return Module.ctx ? 1 : 0;
          }
          _glutCreateWindow.sig = "ip";
          var _glutDestroyWindow = (name2) => {
            Module.ctx = Browser.destroyContext(Module["canvas"], true, true);
            return 1;
          };
          _glutDestroyWindow.sig = "vi";
          var _glutReshapeWindow = (width, height) => {
            Browser.exitFullscreen();
            Browser.setCanvasSize(width, height, true);
            if (GLUT.reshapeFunc) {
              getWasmTableEntry(GLUT.reshapeFunc)(width, height);
            }
            _glutPostRedisplay();
          };
          _glutReshapeWindow.sig = "vii";
          var _glutPositionWindow = (x, y) => {
            Browser.exitFullscreen();
            _glutPostRedisplay();
          };
          _glutPositionWindow.sig = "vii";
          var _glutFullScreen = () => {
            GLUT.windowX = 0;
            GLUT.windowY = 0;
            GLUT.windowWidth = Module["canvas"].width;
            GLUT.windowHeight = Module["canvas"].height;
            document.addEventListener("fullscreenchange", GLUT.onFullscreenEventChange, true);
            document.addEventListener("mozfullscreenchange", GLUT.onFullscreenEventChange, true);
            document.addEventListener("webkitfullscreenchange", GLUT.onFullscreenEventChange, true);
            Browser.requestFullscreen(false, false);
          };
          _glutFullScreen.sig = "v";
          var _glutInitDisplayMode = (mode) => GLUT.initDisplayMode = mode;
          _glutInitDisplayMode.sig = "vi";
          var _glutSwapBuffers = () => {
          };
          _glutSwapBuffers.sig = "v";
          var _glutMainLoop = () => {
            _glutReshapeWindow(Module["canvas"].width, Module["canvas"].height);
            _glutPostRedisplay();
            throw "unwind";
          };
          _glutMainLoop.sig = "v";
          function _XOpenDisplay(name2) {
            name2 >>>= 0;
            return 1;
          }
          _XOpenDisplay.sig = "pp";
          function _XCreateWindow(display, parent, x, y, width, height, border_width, depth, class_, visual, valuemask, attributes) {
            display >>>= 0;
            parent >>>= 0;
            visual >>>= 0;
            valuemask >>>= 0;
            attributes >>>= 0;
            Browser.setCanvasSize(width, height);
            return 2;
          }
          _XCreateWindow.sig = "pppiiiiiiippp";
          function _XChangeWindowAttributes(display, window2, valuemask, attributes) {
            display >>>= 0;
            window2 >>>= 0;
            valuemask >>>= 0;
            attributes >>>= 0;
          }
          _XChangeWindowAttributes.sig = "ipppp";
          function _XSetWMHints(display, win, hints) {
            display >>>= 0;
            win >>>= 0;
            hints >>>= 0;
          }
          _XSetWMHints.sig = "ippp";
          function _XMapWindow(display, win) {
            display >>>= 0;
            win >>>= 0;
          }
          _XMapWindow.sig = "ipp";
          function _XStoreName(display, win, name2) {
            display >>>= 0;
            win >>>= 0;
            name2 >>>= 0;
          }
          _XStoreName.sig = "ippp";
          function _XInternAtom(display, name_, hmm) {
            display >>>= 0;
            name_ >>>= 0;
            return 0;
          }
          _XInternAtom.sig = "pppi";
          function _XSendEvent(display, win, propagate, event_mask, even_send) {
            display >>>= 0;
            win >>>= 0;
            event_mask >>>= 0;
            even_send >>>= 0;
          }
          _XSendEvent.sig = "ippipp";
          function _XPending(display) {
            display >>>= 0;
            return 0;
          }
          _XPending.sig = "ip";
          var EGL = {
            errorCode: 12288,
            defaultDisplayInitialized: false,
            currentContext: 0,
            currentReadSurface: 0,
            currentDrawSurface: 0,
            contextAttributes: {
              alpha: false,
              depth: false,
              stencil: false,
              antialias: false
            },
            stringCache: {},
            setErrorCode(code) {
              EGL.errorCode = code;
            },
            chooseConfig(display, attribList, config, config_size, numConfigs) {
              if (display != 62e3) {
                EGL.setErrorCode(12296);
                return 0;
              }
              if (attribList) {
                for (; ; ) {
                  var param = HEAP32[attribList >>> 2 >>> 0];
                  if (param == 12321) {
                    var alphaSize = HEAP32[attribList + 4 >>> 2 >>> 0];
                    EGL.contextAttributes.alpha = alphaSize > 0;
                  } else if (param == 12325) {
                    var depthSize = HEAP32[attribList + 4 >>> 2 >>> 0];
                    EGL.contextAttributes.depth = depthSize > 0;
                  } else if (param == 12326) {
                    var stencilSize = HEAP32[attribList + 4 >>> 2 >>> 0];
                    EGL.contextAttributes.stencil = stencilSize > 0;
                  } else if (param == 12337) {
                    var samples = HEAP32[attribList + 4 >>> 2 >>> 0];
                    EGL.contextAttributes.antialias = samples > 0;
                  } else if (param == 12338) {
                    var samples = HEAP32[attribList + 4 >>> 2 >>> 0];
                    EGL.contextAttributes.antialias = samples == 1;
                  } else if (param == 12544) {
                    var requestedPriority = HEAP32[attribList + 4 >>> 2 >>> 0];
                    EGL.contextAttributes.lowLatency = requestedPriority != 12547;
                  } else if (param == 12344) {
                    break;
                  }
                  attribList += 8;
                }
              }
              if ((!config || !config_size) && !numConfigs) {
                EGL.setErrorCode(12300);
                return 0;
              }
              if (numConfigs) {
                HEAP32[numConfigs >>> 2 >>> 0] = 1;
              }
              if (config && config_size > 0) {
                HEAPU32[config >>> 2 >>> 0] = 62002;
              }
              EGL.setErrorCode(12288);
              return 1;
            }
          };
          function _eglGetDisplay(nativeDisplayType) {
            nativeDisplayType >>>= 0;
            EGL.setErrorCode(12288);
            if (nativeDisplayType != 0 && nativeDisplayType != 1) {
              return 0;
            }
            return 62e3;
          }
          _eglGetDisplay.sig = "pp";
          function _eglInitialize(display, majorVersion, minorVersion) {
            display >>>= 0;
            majorVersion >>>= 0;
            minorVersion >>>= 0;
            if (display != 62e3) {
              EGL.setErrorCode(12296);
              return 0;
            }
            if (majorVersion) {
              HEAP32[majorVersion >>> 2 >>> 0] = 1;
            }
            if (minorVersion) {
              HEAP32[minorVersion >>> 2 >>> 0] = 4;
            }
            EGL.defaultDisplayInitialized = true;
            EGL.setErrorCode(12288);
            return 1;
          }
          _eglInitialize.sig = "ippp";
          function _eglTerminate(display) {
            display >>>= 0;
            if (display != 62e3) {
              EGL.setErrorCode(12296);
              return 0;
            }
            EGL.currentContext = 0;
            EGL.currentReadSurface = 0;
            EGL.currentDrawSurface = 0;
            EGL.defaultDisplayInitialized = false;
            EGL.setErrorCode(12288);
            return 1;
          }
          _eglTerminate.sig = "ip";
          function _eglGetConfigs(display, configs, config_size, numConfigs) {
            display >>>= 0;
            configs >>>= 0;
            numConfigs >>>= 0;
            return EGL.chooseConfig(display, 0, configs, config_size, numConfigs);
          }
          _eglGetConfigs.sig = "ippip";
          function _eglChooseConfig(display, attrib_list, configs, config_size, numConfigs) {
            display >>>= 0;
            attrib_list >>>= 0;
            configs >>>= 0;
            numConfigs >>>= 0;
            return EGL.chooseConfig(display, attrib_list, configs, config_size, numConfigs);
          }
          _eglChooseConfig.sig = "ipppip";
          function _eglGetConfigAttrib(display, config, attribute, value) {
            display >>>= 0;
            config >>>= 0;
            value >>>= 0;
            if (display != 62e3) {
              EGL.setErrorCode(12296);
              return 0;
            }
            if (config != 62002) {
              EGL.setErrorCode(12293);
              return 0;
            }
            if (!value) {
              EGL.setErrorCode(12300);
              return 0;
            }
            EGL.setErrorCode(12288);
            switch (attribute) {
              case 12320:
                HEAP32[value >>> 2 >>> 0] = EGL.contextAttributes.alpha ? 32 : 24;
                return 1;
              case 12321:
                HEAP32[value >>> 2 >>> 0] = EGL.contextAttributes.alpha ? 8 : 0;
                return 1;
              case 12322:
                HEAP32[value >>> 2 >>> 0] = 8;
                return 1;
              case 12323:
                HEAP32[value >>> 2 >>> 0] = 8;
                return 1;
              case 12324:
                HEAP32[value >>> 2 >>> 0] = 8;
                return 1;
              case 12325:
                HEAP32[value >>> 2 >>> 0] = EGL.contextAttributes.depth ? 24 : 0;
                return 1;
              case 12326:
                HEAP32[value >>> 2 >>> 0] = EGL.contextAttributes.stencil ? 8 : 0;
                return 1;
              case 12327:
                HEAP32[value >>> 2 >>> 0] = 12344;
                return 1;
              case 12328:
                HEAP32[value >>> 2 >>> 0] = 62002;
                return 1;
              case 12329:
                HEAP32[value >>> 2 >>> 0] = 0;
                return 1;
              case 12330:
                HEAP32[value >>> 2 >>> 0] = 4096;
                return 1;
              case 12331:
                HEAP32[value >>> 2 >>> 0] = 16777216;
                return 1;
              case 12332:
                HEAP32[value >>> 2 >>> 0] = 4096;
                return 1;
              case 12333:
                HEAP32[value >>> 2 >>> 0] = 0;
                return 1;
              case 12334:
                HEAP32[value >>> 2 >>> 0] = 0;
                return 1;
              case 12335:
                HEAP32[value >>> 2 >>> 0] = 12344;
                return 1;
              case 12337:
                HEAP32[value >>> 2 >>> 0] = EGL.contextAttributes.antialias ? 4 : 0;
                return 1;
              case 12338:
                HEAP32[value >>> 2 >>> 0] = EGL.contextAttributes.antialias ? 1 : 0;
                return 1;
              case 12339:
                HEAP32[value >>> 2 >>> 0] = 4;
                return 1;
              case 12340:
                HEAP32[value >>> 2 >>> 0] = 12344;
                return 1;
              case 12341:
              case 12342:
              case 12343:
                HEAP32[value >>> 2 >>> 0] = -1;
                return 1;
              case 12345:
              case 12346:
                HEAP32[value >>> 2 >>> 0] = 0;
                return 1;
              case 12347:
                HEAP32[value >>> 2 >>> 0] = 0;
                return 1;
              case 12348:
                HEAP32[value >>> 2 >>> 0] = 1;
                return 1;
              case 12349:
              case 12350:
                HEAP32[value >>> 2 >>> 0] = 0;
                return 1;
              case 12351:
                HEAP32[value >>> 2 >>> 0] = 12430;
                return 1;
              case 12352:
                HEAP32[value >>> 2 >>> 0] = 4;
                return 1;
              case 12354:
                HEAP32[value >>> 2 >>> 0] = 0;
                return 1;
              default:
                EGL.setErrorCode(12292);
                return 0;
            }
          }
          _eglGetConfigAttrib.sig = "ippip";
          function _eglCreateWindowSurface(display, config, win, attrib_list) {
            display >>>= 0;
            config >>>= 0;
            attrib_list >>>= 0;
            if (display != 62e3) {
              EGL.setErrorCode(12296);
              return 0;
            }
            if (config != 62002) {
              EGL.setErrorCode(12293);
              return 0;
            }
            EGL.setErrorCode(12288);
            return 62006;
          }
          _eglCreateWindowSurface.sig = "pppip";
          function _eglDestroySurface(display, surface) {
            display >>>= 0;
            surface >>>= 0;
            if (display != 62e3) {
              EGL.setErrorCode(12296);
              return 0;
            }
            if (surface != 62006) {
              EGL.setErrorCode(12301);
              return 1;
            }
            if (EGL.currentReadSurface == surface) {
              EGL.currentReadSurface = 0;
            }
            if (EGL.currentDrawSurface == surface) {
              EGL.currentDrawSurface = 0;
            }
            EGL.setErrorCode(12288);
            return 1;
          }
          _eglDestroySurface.sig = "ipp";
          function _eglCreateContext(display, config, hmm, contextAttribs) {
            display >>>= 0;
            config >>>= 0;
            hmm >>>= 0;
            contextAttribs >>>= 0;
            if (display != 62e3) {
              EGL.setErrorCode(12296);
              return 0;
            }
            var glesContextVersion = 1;
            for (; ; ) {
              var param = HEAP32[contextAttribs >>> 2 >>> 0];
              if (param == 12440) {
                glesContextVersion = HEAP32[contextAttribs + 4 >>> 2 >>> 0];
              } else if (param == 12344) {
                break;
              } else {
                EGL.setErrorCode(12292);
                return 0;
              }
              contextAttribs += 8;
            }
            if (glesContextVersion != 2) {
              EGL.setErrorCode(12293);
              return 0;
            }
            EGL.contextAttributes.majorVersion = glesContextVersion - 1;
            EGL.contextAttributes.minorVersion = 0;
            EGL.context = GL.createContext(Module["canvas"], EGL.contextAttributes);
            if (EGL.context != 0) {
              EGL.setErrorCode(12288);
              GL.makeContextCurrent(EGL.context);
              Module.useWebGL = true;
              Browser.moduleContextCreatedCallbacks.forEach(function(callback) {
                callback();
              });
              GL.makeContextCurrent(null);
              return 62004;
            } else {
              EGL.setErrorCode(12297);
              return 0;
            }
          }
          _eglCreateContext.sig = "ppppp";
          function _eglDestroyContext(display, context) {
            display >>>= 0;
            context >>>= 0;
            if (display != 62e3) {
              EGL.setErrorCode(12296);
              return 0;
            }
            if (context != 62004) {
              EGL.setErrorCode(12294);
              return 0;
            }
            GL.deleteContext(EGL.context);
            EGL.setErrorCode(12288);
            if (EGL.currentContext == context) {
              EGL.currentContext = 0;
            }
            return 1;
          }
          _eglDestroyContext.sig = "ipp";
          function _eglQuerySurface(display, surface, attribute, value) {
            display >>>= 0;
            surface >>>= 0;
            value >>>= 0;
            if (display != 62e3) {
              EGL.setErrorCode(12296);
              return 0;
            }
            if (surface != 62006) {
              EGL.setErrorCode(12301);
              return 0;
            }
            if (!value) {
              EGL.setErrorCode(12300);
              return 0;
            }
            EGL.setErrorCode(12288);
            switch (attribute) {
              case 12328:
                HEAP32[value >>> 2 >>> 0] = 62002;
                return 1;
              case 12376:
                return 1;
              case 12375:
                HEAP32[value >>> 2 >>> 0] = Module["canvas"].width;
                return 1;
              case 12374:
                HEAP32[value >>> 2 >>> 0] = Module["canvas"].height;
                return 1;
              case 12432:
                HEAP32[value >>> 2 >>> 0] = -1;
                return 1;
              case 12433:
                HEAP32[value >>> 2 >>> 0] = -1;
                return 1;
              case 12434:
                HEAP32[value >>> 2 >>> 0] = -1;
                return 1;
              case 12422:
                HEAP32[value >>> 2 >>> 0] = 12420;
                return 1;
              case 12441:
                HEAP32[value >>> 2 >>> 0] = 12442;
                return 1;
              case 12435:
                HEAP32[value >>> 2 >>> 0] = 12437;
                return 1;
              case 12416:
              case 12417:
              case 12418:
              case 12419:
                return 1;
              default:
                EGL.setErrorCode(12292);
                return 0;
            }
          }
          _eglQuerySurface.sig = "ippip";
          function _eglQueryContext(display, context, attribute, value) {
            display >>>= 0;
            context >>>= 0;
            value >>>= 0;
            if (display != 62e3) {
              EGL.setErrorCode(12296);
              return 0;
            }
            if (context != 62004) {
              EGL.setErrorCode(12294);
              return 0;
            }
            if (!value) {
              EGL.setErrorCode(12300);
              return 0;
            }
            EGL.setErrorCode(12288);
            switch (attribute) {
              case 12328:
                HEAP32[value >>> 2 >>> 0] = 62002;
                return 1;
              case 12439:
                HEAP32[value >>> 2 >>> 0] = 12448;
                return 1;
              case 12440:
                HEAP32[value >>> 2 >>> 0] = EGL.contextAttributes.majorVersion + 1;
                return 1;
              case 12422:
                HEAP32[value >>> 2 >>> 0] = 12420;
                return 1;
              default:
                EGL.setErrorCode(12292);
                return 0;
            }
          }
          _eglQueryContext.sig = "ippip";
          var _eglGetError = () => EGL.errorCode;
          _eglGetError.sig = "i";
          function _eglQueryString(display, name2) {
            display >>>= 0;
            if (display != 62e3) {
              EGL.setErrorCode(12296);
              return 0;
            }
            EGL.setErrorCode(12288);
            if (EGL.stringCache[name2])
              return EGL.stringCache[name2];
            var ret;
            switch (name2) {
              case 12371:
                ret = stringToNewUTF8("Emscripten");
                break;
              case 12372:
                ret = stringToNewUTF8("1.4 Emscripten EGL");
                break;
              case 12373:
                ret = stringToNewUTF8("");
                break;
              case 12429:
                ret = stringToNewUTF8("OpenGL_ES");
                break;
              default:
                EGL.setErrorCode(12300);
                return 0;
            }
            EGL.stringCache[name2] = ret;
            return ret;
          }
          _eglQueryString.sig = "ppi";
          var _eglBindAPI = (api) => {
            if (api == 12448) {
              EGL.setErrorCode(12288);
              return 1;
            }
            EGL.setErrorCode(12300);
            return 0;
          };
          _eglBindAPI.sig = "ii";
          var _eglQueryAPI = () => {
            EGL.setErrorCode(12288);
            return 12448;
          };
          _eglQueryAPI.sig = "i";
          var _eglWaitClient = () => {
            EGL.setErrorCode(12288);
            return 1;
          };
          _eglWaitClient.sig = "i";
          var _eglWaitNative = (nativeEngineId) => {
            EGL.setErrorCode(12288);
            return 1;
          };
          _eglWaitNative.sig = "ii";
          var _eglWaitGL = _eglWaitClient;
          _eglWaitGL.sig = "i";
          function _eglSwapInterval(display, interval) {
            display >>>= 0;
            if (display != 62e3) {
              EGL.setErrorCode(12296);
              return 0;
            }
            if (interval == 0)
              _emscripten_set_main_loop_timing(0, 0);
            else
              _emscripten_set_main_loop_timing(1, interval);
            EGL.setErrorCode(12288);
            return 1;
          }
          _eglSwapInterval.sig = "ipi";
          function _eglMakeCurrent(display, draw, read, context) {
            display >>>= 0;
            draw >>>= 0;
            read >>>= 0;
            context >>>= 0;
            if (display != 62e3) {
              EGL.setErrorCode(12296);
              return 0;
            }
            if (context != 0 && context != 62004) {
              EGL.setErrorCode(12294);
              return 0;
            }
            if (read != 0 && read != 62006 || draw != 0 && draw != 62006) {
              EGL.setErrorCode(12301);
              return 0;
            }
            GL.makeContextCurrent(context ? EGL.context : null);
            EGL.currentContext = context;
            EGL.currentDrawSurface = draw;
            EGL.currentReadSurface = read;
            EGL.setErrorCode(12288);
            return 1;
          }
          _eglMakeCurrent.sig = "ipppp";
          function _eglGetCurrentContext() {
            return EGL.currentContext;
          }
          _eglGetCurrentContext.sig = "p";
          function _eglGetCurrentSurface(readdraw) {
            if (readdraw == 12378) {
              return EGL.currentReadSurface;
            } else if (readdraw == 12377) {
              return EGL.currentDrawSurface;
            } else {
              EGL.setErrorCode(12300);
              return 0;
            }
          }
          _eglGetCurrentSurface.sig = "pi";
          function _eglGetCurrentDisplay() {
            return EGL.currentContext ? 62e3 : 0;
          }
          _eglGetCurrentDisplay.sig = "p";
          function _eglSwapBuffers(dpy, surface) {
            dpy >>>= 0;
            surface >>>= 0;
            if (!EGL.defaultDisplayInitialized) {
              EGL.setErrorCode(12289);
            } else if (!Module.ctx) {
              EGL.setErrorCode(12290);
            } else if (Module.ctx.isContextLost()) {
              EGL.setErrorCode(12302);
            } else {
              EGL.setErrorCode(12288);
              return 1;
            }
            return 0;
          }
          _eglSwapBuffers.sig = "ipp";
          var _eglReleaseThread = () => {
            EGL.currentContext = 0;
            EGL.currentReadSurface = 0;
            EGL.currentDrawSurface = 0;
            EGL.setErrorCode(12288);
            return 1;
          };
          _eglReleaseThread.sig = "i";
          function _uuid_clear(uu) {
            uu >>>= 0;
            return zeroMemory(uu, 16);
          }
          _uuid_clear.sig = "vp";
          function _uuid_compare(uu1, uu2) {
            uu1 >>>= 0;
            uu2 >>>= 0;
            return _memcmp(uu1, uu2, 16);
          }
          _uuid_compare.sig = "ipp";
          function _uuid_copy(dst, src) {
            dst >>>= 0;
            src >>>= 0;
            return _memcpy(dst, src, 16);
          }
          _uuid_copy.sig = "vpp";
          function _uuid_generate(out2) {
            out2 >>>= 0;
            var uuid = null;
            if (ENVIRONMENT_IS_NODE) {
              try {
                var rb = __require("crypto")["randomBytes"];
                uuid = rb(16);
              } catch (e) {
              }
            } else if (ENVIRONMENT_IS_WEB && typeof window.crypto != "undefined" && typeof window.crypto.getRandomValues != "undefined") {
              uuid = new Uint8Array(16);
              window.crypto.getRandomValues(uuid);
            }
            if (!uuid) {
              uuid = new Array(16);
              var d = (/* @__PURE__ */ new Date()).getTime();
              for (var i2 = 0; i2 < 16; i2++) {
                var r = (d + Math.random() * 256) % 256 | 0;
                d = d / 256 | 0;
                uuid[i2] = r;
              }
            }
            uuid[6] = uuid[6] & 15 | 64;
            uuid[8] = uuid[8] & 63 | 128;
            writeArrayToMemory(uuid, out2);
          }
          _uuid_generate.sig = "vp";
          function _uuid_is_null(uu) {
            uu >>>= 0;
            for (var i2 = 0; i2 < 4; i2++, uu = uu + 4 | 0) {
              var val = HEAP32[uu >>> 2 >>> 0];
              if (val) {
                return 0;
              }
            }
            return 1;
          }
          _uuid_is_null.sig = "ip";
          function _uuid_parse(inp, uu) {
            inp >>>= 0;
            uu >>>= 0;
            inp = UTF8ToString(inp);
            if (inp.length === 36) {
              var i2 = 0;
              var uuid = new Array(16);
              inp.toLowerCase().replace(/[0-9a-f]{2}/g, function(byte) {
                if (i2 < 16) {
                  uuid[i2++] = parseInt(byte, 16);
                }
              });
              if (i2 < 16) {
                return -1;
              }
              writeArrayToMemory(uuid, uu);
              return 0;
            }
            return -1;
          }
          _uuid_parse.sig = "ipp";
          function _uuid_unparse(uu, out2, upper) {
            uu >>>= 0;
            out2 >>>= 0;
            var i2 = 0;
            var uuid = "xxxx-xx-xx-xx-xxxxxx".replace(/[x]/g, function(c) {
              var r = upper ? HEAPU8[uu + i2 >>> 0 >>> 0].toString(16).toUpperCase() : HEAPU8[uu + i2 >>> 0 >>> 0].toString(16);
              r = r.length === 1 ? "0" + r : r;
              i2++;
              return r;
            });
            stringToUTF8(uuid, out2, 37);
          }
          _uuid_unparse.sig = "vpp";
          function _uuid_unparse_lower(uu, out2) {
            uu >>>= 0;
            out2 >>>= 0;
            _uuid_unparse(uu, out2);
          }
          _uuid_unparse_lower.sig = "vpp";
          function _uuid_unparse_upper(uu, out2) {
            uu >>>= 0;
            out2 >>>= 0;
            _uuid_unparse(uu, out2, true);
          }
          _uuid_unparse_upper.sig = "vpp";
          function _uuid_type(uu) {
            uu >>>= 0;
            return 4;
          }
          _uuid_type.sig = "ip";
          function _uuid_variant(uu) {
            uu >>>= 0;
            return 1;
          }
          _uuid_variant.sig = "ip";
          var GLEW = {
            isLinaroFork: 1,
            extensions: null,
            error: {
              0: null,
              1: null,
              2: null,
              3: null,
              4: null,
              5: null,
              6: null,
              7: null,
              8: null
            },
            version: {
              1: null,
              2: null,
              3: null,
              4: null
            },
            errorStringConstantFromCode(error) {
              if (GLEW.isLinaroFork) {
                switch (error) {
                  case 4:
                    return "OpenGL ES lib expected, found OpenGL lib";
                  case 5:
                    return "OpenGL lib expected, found OpenGL ES lib";
                  case 6:
                    return "Missing EGL version";
                  case 7:
                    return "EGL 1.1 and up are supported";
                  default:
                    break;
                }
              }
              switch (error) {
                case 0:
                  return "No error";
                case 1:
                  return "Missing GL version";
                case 2:
                  return "GL 1.1 and up are supported";
                case 3:
                  return "GLX 1.2 and up are supported";
                default:
                  return null;
              }
            },
            errorString(error) {
              if (!GLEW.error[error]) {
                var string = GLEW.errorStringConstantFromCode(error);
                if (!string) {
                  string = "Unknown error";
                  error = 8;
                }
                GLEW.error[error] = stringToNewUTF8(string);
              }
              return GLEW.error[error];
            },
            versionStringConstantFromCode(name2) {
              switch (name2) {
                case 1:
                  return "1.10.0";
                case 2:
                  return "1";
                case 3:
                  return "10";
                case 4:
                  return "0";
                default:
                  return null;
              }
            },
            versionString(name2) {
              if (!GLEW.version[name2]) {
                var string = GLEW.versionStringConstantFromCode(name2);
                if (!string)
                  return 0;
                GLEW.version[name2] = stringToNewUTF8(string);
              }
              return GLEW.version[name2];
            },
            extensionIsSupported(name2) {
              GLEW.extensions || (GLEW.extensions = webglGetExtensions());
              if (GLEW.extensions.includes(name2))
                return 1;
              return GLEW.extensions.includes("GL_" + name2);
            }
          };
          var _glewInit = () => 0;
          _glewInit.sig = "i";
          function _glewIsSupported(name2) {
            name2 >>>= 0;
            var exts = UTF8ToString(name2).split(" ");
            for (var i2 = 0; i2 < exts.length; ++i2) {
              if (!GLEW.extensionIsSupported(exts[i2]))
                return 0;
            }
            return 1;
          }
          _glewIsSupported.sig = "ip";
          function _glewGetExtension(name2) {
            name2 >>>= 0;
            return GLEW.extensionIsSupported(UTF8ToString(name2));
          }
          _glewGetExtension.sig = "ip";
          function _glewGetErrorString(error) {
            return GLEW.errorString(error);
          }
          _glewGetErrorString.sig = "pi";
          function _glewGetString(name2) {
            return GLEW.versionString(name2);
          }
          _glewGetString.sig = "pi";
          var IDBStore = {
            indexedDB() {
              if (typeof indexedDB != "undefined")
                return indexedDB;
              var ret = null;
              if (typeof window == "object")
                ret = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
              assert(ret, "IDBStore used, but indexedDB not supported");
              return ret;
            },
            DB_VERSION: 22,
            DB_STORE_NAME: "FILE_DATA",
            dbs: {},
            blobs: [0],
            getDB(name2, callback) {
              var db2 = IDBStore.dbs[name2];
              if (db2) {
                return callback(null, db2);
              }
              var req;
              try {
                req = IDBStore.indexedDB().open(name2, IDBStore.DB_VERSION);
              } catch (e) {
                return callback(e);
              }
              req.onupgradeneeded = (e) => {
                var db3 = e.target.result;
                var transaction = e.target.transaction;
                var fileStore;
                if (db3.objectStoreNames.contains(IDBStore.DB_STORE_NAME)) {
                  fileStore = transaction.objectStore(IDBStore.DB_STORE_NAME);
                } else {
                  fileStore = db3.createObjectStore(IDBStore.DB_STORE_NAME);
                }
              };
              req.onsuccess = () => {
                db2 = req.result;
                IDBStore.dbs[name2] = db2;
                callback(null, db2);
              };
              req.onerror = function(event2) {
                callback(event2.target.error || "unknown error");
                event2.preventDefault();
              };
            },
            getStore(dbName, type, callback) {
              IDBStore.getDB(dbName, (error, db2) => {
                if (error)
                  return callback(error);
                var transaction = db2.transaction([IDBStore.DB_STORE_NAME], type);
                transaction.onerror = (event2) => {
                  callback(event2.target.error || "unknown error");
                  event2.preventDefault();
                };
                var store = transaction.objectStore(IDBStore.DB_STORE_NAME);
                callback(null, store);
              });
            },
            getFile(dbName, id, callback) {
              IDBStore.getStore(dbName, "readonly", (err2, store) => {
                if (err2)
                  return callback(err2);
                var req = store.get(id);
                req.onsuccess = (event2) => {
                  var result = event2.target.result;
                  if (!result) {
                    return callback(`file ${id} not found`);
                  }
                  return callback(null, result);
                };
                req.onerror = callback;
              });
            },
            setFile(dbName, id, data2, callback) {
              IDBStore.getStore(dbName, "readwrite", (err2, store) => {
                if (err2)
                  return callback(err2);
                var req = store.put(data2, id);
                req.onsuccess = (event2) => callback();
                req.onerror = callback;
              });
            },
            deleteFile(dbName, id, callback) {
              IDBStore.getStore(dbName, "readwrite", (err2, store) => {
                if (err2)
                  return callback(err2);
                var req = store.delete(id);
                req.onsuccess = (event2) => callback();
                req.onerror = callback;
              });
            },
            existsFile(dbName, id, callback) {
              IDBStore.getStore(dbName, "readonly", (err2, store) => {
                if (err2)
                  return callback(err2);
                var req = store.count(id);
                req.onsuccess = (event2) => callback(null, event2.target.result > 0);
                req.onerror = callback;
              });
            },
            clearStore(dbName, callback) {
              IDBStore.getStore(dbName, "readwrite", (err2, store) => {
                if (err2)
                  return callback(err2);
                var req = store.clear();
                req.onsuccess = (event2) => callback();
                req.onerror = callback;
              });
            }
          };
          var _emscripten_idb_async_load = function(db2, id, arg, onload2, onerror2) {
            db2 >>>= 0;
            id >>>= 0;
            arg >>>= 0;
            onload2 >>>= 0;
            onerror2 >>>= 0;
            IDBStore.getFile(UTF8ToString(db2), UTF8ToString(id), (error, byteArray) => {
              callUserCallback(() => {
                if (error) {
                  if (onerror2)
                    getWasmTableEntry(onerror2)(arg);
                  return;
                }
                var buffer = _malloc(byteArray.length);
                HEAPU8.set(byteArray, buffer >>> 0);
                getWasmTableEntry(onload2)(arg, buffer, byteArray.length);
                _free(buffer);
              });
            });
          };
          _emscripten_idb_async_load.sig = "vppppp";
          var _emscripten_idb_async_store = function(db2, id, ptr2, num, arg, onstore, onerror2) {
            db2 >>>= 0;
            id >>>= 0;
            ptr2 >>>= 0;
            arg >>>= 0;
            onstore >>>= 0;
            onerror2 >>>= 0;
            IDBStore.setFile(UTF8ToString(db2), UTF8ToString(id), new Uint8Array(HEAPU8.subarray(ptr2 >>> 0, ptr2 + num >>> 0)), (error) => {
              callUserCallback(() => {
                if (error) {
                  if (onerror2)
                    getWasmTableEntry(onerror2)(arg);
                  return;
                }
                if (onstore)
                  getWasmTableEntry(onstore)(arg);
              });
            });
          };
          _emscripten_idb_async_store.sig = "vpppippp";
          var _emscripten_idb_async_delete = function(db2, id, arg, ondelete, onerror2) {
            db2 >>>= 0;
            id >>>= 0;
            arg >>>= 0;
            ondelete >>>= 0;
            onerror2 >>>= 0;
            IDBStore.deleteFile(UTF8ToString(db2), UTF8ToString(id), (error) => {
              callUserCallback(() => {
                if (error) {
                  if (onerror2)
                    getWasmTableEntry(onerror2)(arg);
                  return;
                }
                if (ondelete)
                  getWasmTableEntry(ondelete)(arg);
              });
            });
          };
          _emscripten_idb_async_delete.sig = "vppppp";
          var _emscripten_idb_async_exists = function(db2, id, arg, oncheck, onerror2) {
            db2 >>>= 0;
            id >>>= 0;
            arg >>>= 0;
            oncheck >>>= 0;
            onerror2 >>>= 0;
            IDBStore.existsFile(UTF8ToString(db2), UTF8ToString(id), (error, exists) => {
              callUserCallback(() => {
                if (error) {
                  if (onerror2)
                    getWasmTableEntry(onerror2)(arg);
                  return;
                }
                if (oncheck)
                  getWasmTableEntry(oncheck)(arg, exists);
              });
            });
          };
          _emscripten_idb_async_exists.sig = "vppppp";
          var _emscripten_idb_async_clear = function(db2, arg, onclear, onerror2) {
            db2 >>>= 0;
            arg >>>= 0;
            onclear >>>= 0;
            onerror2 >>>= 0;
            IDBStore.clearStore(UTF8ToString(db2), (error) => {
              callUserCallback(() => {
                if (error) {
                  if (onerror2)
                    getWasmTableEntry(onerror2)(arg);
                  return;
                }
                if (onclear)
                  getWasmTableEntry(onclear)(arg);
              });
            });
          };
          _emscripten_idb_async_clear.sig = "vpppp";
          function _emscripten_idb_load(db2, id, pbuffer, pnum, perror) {
            db2 >>>= 0;
            id >>>= 0;
            pbuffer >>>= 0;
            pnum >>>= 0;
            perror >>>= 0;
            throw "Please compile your program with async support in order to use synchronous operations like emscripten_idb_load, etc.";
          }
          _emscripten_idb_load.sig = "vppppp";
          function _emscripten_idb_store(db2, id, ptr2, num, perror) {
            db2 >>>= 0;
            id >>>= 0;
            ptr2 >>>= 0;
            perror >>>= 0;
            throw "Please compile your program with async support in order to use synchronous operations like emscripten_idb_store, etc.";
          }
          _emscripten_idb_store.sig = "vpppip";
          function _emscripten_idb_delete(db2, id, perror) {
            db2 >>>= 0;
            id >>>= 0;
            perror >>>= 0;
            throw "Please compile your program with async support in order to use synchronous operations like emscripten_idb_delete, etc.";
          }
          _emscripten_idb_delete.sig = "vppp";
          function _emscripten_idb_exists(db2, id, pexists, perror) {
            db2 >>>= 0;
            id >>>= 0;
            pexists >>>= 0;
            perror >>>= 0;
            throw "Please compile your program with async support in order to use synchronous operations like emscripten_idb_exists, etc.";
          }
          _emscripten_idb_exists.sig = "vpppp";
          function _emscripten_idb_clear(db2, perror) {
            db2 >>>= 0;
            perror >>>= 0;
            throw "Please compile your program with async support in order to use synchronous operations like emscripten_idb_clear, etc.";
          }
          _emscripten_idb_clear.sig = "vpp";
          var runAndAbortIfError = (func2) => {
            try {
              return func2();
            } catch (e) {
              abort(e);
            }
          };
          var _emscripten_sleep = () => {
            throw "Please compile your program with async support in order to use asynchronous operations like emscripten_sleep";
          };
          _emscripten_sleep.sig = "vi";
          function _emscripten_scan_registers(func2) {
            func2 >>>= 0;
            throw "Please compile your program with async support in order to use asynchronous operations like emscripten_scan_registers";
          }
          _emscripten_scan_registers.sig = "vp";
          function _emscripten_fiber_swap(oldFiber, newFiber) {
            oldFiber >>>= 0;
            newFiber >>>= 0;
            throw "Please compile your program with async support in order to use asynchronous operations like emscripten_fiber_swap";
          }
          _emscripten_fiber_swap.sig = "vpp";
          var _SDL_GetTicks = () => Date.now() - SDL.startTime | 0;
          _SDL_GetTicks.sig = "i";
          function _SDL_LockSurface(surf) {
            surf >>>= 0;
            var surfData = SDL.surfaces[surf];
            surfData.locked++;
            if (surfData.locked > 1)
              return 0;
            if (!surfData.buffer) {
              surfData.buffer = _malloc(surfData.width * surfData.height * 4);
              HEAPU32[surf + 20 >>> 2 >>> 0] = surfData.buffer;
            }
            HEAPU32[surf + 20 >>> 2 >>> 0] = surfData.buffer;
            if (surf == SDL.screen && Module.screenIsReadOnly && surfData.image)
              return 0;
            if (SDL.defaults.discardOnLock) {
              if (!surfData.image) {
                surfData.image = surfData.ctx.createImageData(surfData.width, surfData.height);
              }
              if (!SDL.defaults.opaqueFrontBuffer)
                return;
            } else {
              surfData.image = surfData.ctx.getImageData(0, 0, surfData.width, surfData.height);
            }
            if (surf == SDL.screen && SDL.defaults.opaqueFrontBuffer) {
              var data2 = surfData.image.data;
              var num = data2.length;
              for (var i2 = 0; i2 < num / 4; i2++) {
                data2[i2 * 4 + 3] = 255;
              }
            }
            if (SDL.defaults.copyOnLock && !SDL.defaults.discardOnLock) {
              if (surfData.isFlagSet(2097152)) {
                throw "CopyOnLock is not supported for SDL_LockSurface with SDL_HWPALETTE flag set" + new Error().stack;
              } else {
                HEAPU8.set(surfData.image.data, surfData.buffer >>> 0);
              }
            }
            return 0;
          }
          _SDL_LockSurface.sig = "ip";
          var SDL_ttfContext = () => SDL.ttfContext;
          var SDL_audio = () => SDL.audio;
          var SDL = {
            defaults: {
              width: 320,
              height: 200,
              copyOnLock: true,
              discardOnLock: false,
              opaqueFrontBuffer: true
            },
            version: null,
            surfaces: {},
            canvasPool: [],
            events: [],
            fonts: [null],
            audios: [null],
            rwops: [null],
            music: {
              audio: null,
              volume: 1
            },
            mixerFrequency: 22050,
            mixerFormat: 32784,
            mixerNumChannels: 2,
            mixerChunkSize: 1024,
            channelMinimumNumber: 0,
            GL: false,
            glAttributes: {
              0: 3,
              1: 3,
              2: 2,
              3: 0,
              4: 0,
              5: 1,
              6: 16,
              7: 0,
              8: 0,
              9: 0,
              10: 0,
              11: 0,
              12: 0,
              13: 0,
              14: 0,
              15: 1,
              16: 0,
              17: 0,
              18: 0
            },
            keyboardState: null,
            keyboardMap: {},
            canRequestFullscreen: false,
            isRequestingFullscreen: false,
            textInput: false,
            startTime: null,
            initFlags: 0,
            buttonState: 0,
            modState: 0,
            DOMButtons: [0, 0, 0],
            DOMEventToSDLEvent: {},
            TOUCH_DEFAULT_ID: 0,
            eventHandler: null,
            eventHandlerContext: null,
            eventHandlerTemp: 0,
            keyCodes: {
              16: 1249,
              17: 1248,
              18: 1250,
              20: 1081,
              33: 1099,
              34: 1102,
              35: 1101,
              36: 1098,
              37: 1104,
              38: 1106,
              39: 1103,
              40: 1105,
              44: 316,
              45: 1097,
              46: 127,
              91: 1251,
              93: 1125,
              96: 1122,
              97: 1113,
              98: 1114,
              99: 1115,
              100: 1116,
              101: 1117,
              102: 1118,
              103: 1119,
              104: 1120,
              105: 1121,
              106: 1109,
              107: 1111,
              109: 1110,
              110: 1123,
              111: 1108,
              112: 1082,
              113: 1083,
              114: 1084,
              115: 1085,
              116: 1086,
              117: 1087,
              118: 1088,
              119: 1089,
              120: 1090,
              121: 1091,
              122: 1092,
              123: 1093,
              124: 1128,
              125: 1129,
              126: 1130,
              127: 1131,
              128: 1132,
              129: 1133,
              130: 1134,
              131: 1135,
              132: 1136,
              133: 1137,
              134: 1138,
              135: 1139,
              144: 1107,
              160: 94,
              161: 33,
              162: 34,
              163: 35,
              164: 36,
              165: 37,
              166: 38,
              167: 95,
              168: 40,
              169: 41,
              170: 42,
              171: 43,
              172: 124,
              173: 45,
              174: 123,
              175: 125,
              176: 126,
              181: 127,
              182: 129,
              183: 128,
              188: 44,
              190: 46,
              191: 47,
              192: 96,
              219: 91,
              220: 92,
              221: 93,
              222: 39,
              224: 1251
            },
            scanCodes: {
              8: 42,
              9: 43,
              13: 40,
              27: 41,
              32: 44,
              35: 204,
              39: 53,
              44: 54,
              46: 55,
              47: 56,
              48: 39,
              49: 30,
              50: 31,
              51: 32,
              52: 33,
              53: 34,
              54: 35,
              55: 36,
              56: 37,
              57: 38,
              58: 203,
              59: 51,
              61: 46,
              91: 47,
              92: 49,
              93: 48,
              96: 52,
              97: 4,
              98: 5,
              99: 6,
              100: 7,
              101: 8,
              102: 9,
              103: 10,
              104: 11,
              105: 12,
              106: 13,
              107: 14,
              108: 15,
              109: 16,
              110: 17,
              111: 18,
              112: 19,
              113: 20,
              114: 21,
              115: 22,
              116: 23,
              117: 24,
              118: 25,
              119: 26,
              120: 27,
              121: 28,
              122: 29,
              127: 76,
              305: 224,
              308: 226,
              316: 70
            },
            loadRect: (rect) => ({
              x: HEAP32[rect + 0 >>> 2 >>> 0],
              y: HEAP32[rect + 4 >>> 2 >>> 0],
              w: HEAP32[rect + 8 >>> 2 >>> 0],
              h: HEAP32[rect + 12 >>> 2 >>> 0]
            }),
            updateRect: (rect, r) => {
              HEAP32[rect >>> 2 >>> 0] = r.x;
              HEAP32[rect + 4 >>> 2 >>> 0] = r.y;
              HEAP32[rect + 8 >>> 2 >>> 0] = r.w;
              HEAP32[rect + 12 >>> 2 >>> 0] = r.h;
            },
            intersectionOfRects: (first, second) => {
              var leftX = Math.max(first.x, second.x);
              var leftY = Math.max(first.y, second.y);
              var rightX = Math.min(first.x + first.w, second.x + second.w);
              var rightY = Math.min(first.y + first.h, second.y + second.h);
              return {
                x: leftX,
                y: leftY,
                w: Math.max(leftX, rightX) - leftX,
                h: Math.max(leftY, rightY) - leftY
              };
            },
            checkPixelFormat: (fmt) => {
            },
            loadColorToCSSRGB: (color) => {
              var rgba = HEAP32[color >>> 2 >>> 0];
              return "rgb(" + (rgba & 255) + "," + (rgba >> 8 & 255) + "," + (rgba >> 16 & 255) + ")";
            },
            loadColorToCSSRGBA: (color) => {
              var rgba = HEAP32[color >>> 2 >>> 0];
              return "rgba(" + (rgba & 255) + "," + (rgba >> 8 & 255) + "," + (rgba >> 16 & 255) + "," + (rgba >> 24 & 255) / 255 + ")";
            },
            translateColorToCSSRGBA: (rgba) => "rgba(" + (rgba & 255) + "," + (rgba >> 8 & 255) + "," + (rgba >> 16 & 255) + "," + (rgba >>> 24) / 255 + ")",
            translateRGBAToCSSRGBA: (r, g, b, a) => "rgba(" + (r & 255) + "," + (g & 255) + "," + (b & 255) + "," + (a & 255) / 255 + ")",
            translateRGBAToColor: (r, g, b, a) => r | g << 8 | b << 16 | a << 24,
            makeSurface: (width, height, flags2, usePageCanvas, source, rmask, gmask, bmask, amask) => {
              var is_SDL_HWSURFACE = flags2 & 1;
              var is_SDL_HWPALETTE = flags2 & 2097152;
              var is_SDL_OPENGL = flags2 & 67108864;
              var surf = _malloc(60);
              var pixelFormat = _malloc(44);
              var bpp = is_SDL_HWPALETTE ? 1 : 4;
              var buffer = 0;
              if (!is_SDL_HWSURFACE && !is_SDL_OPENGL) {
                buffer = _malloc(width * height * 4);
              }
              HEAP32[surf >>> 2 >>> 0] = flags2;
              HEAPU32[surf + 4 >>> 2 >>> 0] = pixelFormat;
              HEAP32[surf + 8 >>> 2 >>> 0] = width;
              HEAP32[surf + 12 >>> 2 >>> 0] = height;
              HEAP32[surf + 16 >>> 2 >>> 0] = width * bpp;
              HEAPU32[surf + 20 >>> 2 >>> 0] = buffer;
              HEAP32[surf + 36 >>> 2 >>> 0] = 0;
              HEAP32[surf + 40 >>> 2 >>> 0] = 0;
              HEAP32[surf + 44 >>> 2 >>> 0] = Module["canvas"].width;
              HEAP32[surf + 48 >>> 2 >>> 0] = Module["canvas"].height;
              HEAP32[surf + 56 >>> 2 >>> 0] = 1;
              HEAP32[pixelFormat >>> 2 >>> 0] = -2042224636;
              HEAP32[pixelFormat + 4 >>> 2 >>> 0] = 0;
              HEAP8[pixelFormat + 8 >>> 0 >>> 0] = bpp * 8;
              HEAP8[pixelFormat + 9 >>> 0 >>> 0] = bpp;
              HEAP32[pixelFormat + 12 >>> 2 >>> 0] = rmask || 255;
              HEAP32[pixelFormat + 16 >>> 2 >>> 0] = gmask || 65280;
              HEAP32[pixelFormat + 20 >>> 2 >>> 0] = bmask || 16711680;
              HEAP32[pixelFormat + 24 >>> 2 >>> 0] = amask || 4278190080;
              SDL.GL = SDL.GL || is_SDL_OPENGL;
              var canvas;
              if (!usePageCanvas) {
                if (SDL.canvasPool.length > 0) {
                  canvas = SDL.canvasPool.pop();
                } else {
                  canvas = document.createElement("canvas");
                }
                canvas.width = width;
                canvas.height = height;
              } else {
                canvas = Module["canvas"];
              }
              var webGLContextAttributes = {
                antialias: SDL.glAttributes[13] != 0 && SDL.glAttributes[14] > 1,
                depth: SDL.glAttributes[6] > 0,
                stencil: SDL.glAttributes[7] > 0,
                alpha: SDL.glAttributes[3] > 0
              };
              var ctx = Browser.createContext(canvas, is_SDL_OPENGL, usePageCanvas, webGLContextAttributes);
              SDL.surfaces[surf] = {
                width,
                height,
                canvas,
                ctx,
                surf,
                buffer,
                pixelFormat,
                alpha: 255,
                flags: flags2,
                locked: 0,
                usePageCanvas,
                source,
                isFlagSet: (flag) => flags2 & flag
              };
              return surf;
            },
            copyIndexedColorData: (surfData, rX, rY, rW, rH) => {
              if (!surfData.colors) {
                return;
              }
              var fullWidth = Module["canvas"].width;
              var fullHeight = Module["canvas"].height;
              var startX = rX || 0;
              var startY = rY || 0;
              var endX = (rW || fullWidth - startX) + startX;
              var endY = (rH || fullHeight - startY) + startY;
              var buffer = surfData.buffer;
              if (!surfData.image.data32) {
                surfData.image.data32 = new Uint32Array(surfData.image.data.buffer);
              }
              var data32 = surfData.image.data32;
              var colors32 = surfData.colors32;
              for (var y = startY; y < endY; ++y) {
                var base = y * fullWidth;
                for (var x = startX; x < endX; ++x) {
                  data32[base + x] = colors32[HEAPU8[buffer + base + x >>> 0 >>> 0]];
                }
              }
            },
            freeSurface: (surf) => {
              var refcountPointer = surf + 56;
              var refcount = HEAP32[refcountPointer >>> 2 >>> 0];
              if (refcount > 1) {
                HEAP32[refcountPointer >>> 2 >>> 0] = refcount - 1;
                return;
              }
              var info2 = SDL.surfaces[surf];
              if (!info2.usePageCanvas && info2.canvas)
                SDL.canvasPool.push(info2.canvas);
              if (info2.buffer)
                _free(info2.buffer);
              _free(info2.pixelFormat);
              _free(surf);
              SDL.surfaces[surf] = null;
              if (surf === SDL.screen) {
                SDL.screen = null;
              }
            },
            blitSurface: (src, srcrect, dst, dstrect, scale) => {
              var srcData = SDL.surfaces[src];
              var dstData = SDL.surfaces[dst];
              var sr, dr;
              if (srcrect) {
                sr = SDL.loadRect(srcrect);
              } else {
                sr = {
                  x: 0,
                  y: 0,
                  w: srcData.width,
                  h: srcData.height
                };
              }
              if (dstrect) {
                dr = SDL.loadRect(dstrect);
              } else {
                dr = {
                  x: 0,
                  y: 0,
                  w: srcData.width,
                  h: srcData.height
                };
              }
              if (dstData.clipRect) {
                var widthScale = !scale || sr.w === 0 ? 1 : sr.w / dr.w;
                var heightScale = !scale || sr.h === 0 ? 1 : sr.h / dr.h;
                dr = SDL.intersectionOfRects(dstData.clipRect, dr);
                sr.w = dr.w * widthScale;
                sr.h = dr.h * heightScale;
                if (dstrect) {
                  SDL.updateRect(dstrect, dr);
                }
              }
              var blitw, blith;
              if (scale) {
                blitw = dr.w;
                blith = dr.h;
              } else {
                blitw = sr.w;
                blith = sr.h;
              }
              if (sr.w === 0 || sr.h === 0 || blitw === 0 || blith === 0) {
                return 0;
              }
              var oldAlpha = dstData.ctx.globalAlpha;
              dstData.ctx.globalAlpha = srcData.alpha / 255;
              dstData.ctx.drawImage(srcData.canvas, sr.x, sr.y, sr.w, sr.h, dr.x, dr.y, blitw, blith);
              dstData.ctx.globalAlpha = oldAlpha;
              if (dst != SDL.screen) {
                warnOnce("WARNING: copying canvas data to memory for compatibility");
                _SDL_LockSurface(dst);
                dstData.locked--;
              }
              return 0;
            },
            downFingers: {},
            savedKeydown: null,
            receiveEvent: (event2) => {
              function unpressAllPressedKeys() {
                for (var code in SDL.keyboardMap) {
                  SDL.events.push({
                    type: "keyup",
                    keyCode: SDL.keyboardMap[code]
                  });
                }
              }
              switch (event2.type) {
                case "touchstart":
                case "touchmove": {
                  event2.preventDefault();
                  var touches = [];
                  if (event2.type === "touchstart") {
                    for (var i2 = 0; i2 < event2.touches.length; i2++) {
                      var touch = event2.touches[i2];
                      if (SDL.downFingers[touch.identifier] != true) {
                        SDL.downFingers[touch.identifier] = true;
                        touches.push(touch);
                      }
                    }
                  } else {
                    touches = event2.touches;
                  }
                  var firstTouch = touches[0];
                  if (firstTouch) {
                    if (event2.type == "touchstart") {
                      SDL.DOMButtons[0] = 1;
                    }
                    var mouseEventType;
                    switch (event2.type) {
                      case "touchstart":
                        mouseEventType = "mousedown";
                        break;
                      case "touchmove":
                        mouseEventType = "mousemove";
                        break;
                    }
                    var mouseEvent = {
                      type: mouseEventType,
                      button: 0,
                      pageX: firstTouch.clientX,
                      pageY: firstTouch.clientY
                    };
                    SDL.events.push(mouseEvent);
                  }
                  for (var i2 = 0; i2 < touches.length; i2++) {
                    var touch = touches[i2];
                    SDL.events.push({
                      type: event2.type,
                      touch
                    });
                  }
                  break;
                }
                case "touchend": {
                  event2.preventDefault();
                  for (var i2 = 0; i2 < event2.changedTouches.length; i2++) {
                    var touch = event2.changedTouches[i2];
                    if (SDL.downFingers[touch.identifier] === true) {
                      delete SDL.downFingers[touch.identifier];
                    }
                  }
                  var mouseEvent = {
                    type: "mouseup",
                    button: 0,
                    pageX: event2.changedTouches[0].clientX,
                    pageY: event2.changedTouches[0].clientY
                  };
                  SDL.DOMButtons[0] = 0;
                  SDL.events.push(mouseEvent);
                  for (var i2 = 0; i2 < event2.changedTouches.length; i2++) {
                    var touch = event2.changedTouches[i2];
                    SDL.events.push({
                      type: "touchend",
                      touch
                    });
                  }
                  break;
                }
                case "DOMMouseScroll":
                case "mousewheel":
                case "wheel":
                  var delta = -Browser.getMouseWheelDelta(event2);
                  delta = delta == 0 ? 0 : delta > 0 ? Math.max(delta, 1) : Math.min(delta, -1);
                  var button = delta > 0 ? 3 : 4;
                  SDL.events.push({
                    type: "mousedown",
                    button,
                    pageX: event2.pageX,
                    pageY: event2.pageY
                  });
                  SDL.events.push({
                    type: "mouseup",
                    button,
                    pageX: event2.pageX,
                    pageY: event2.pageY
                  });
                  SDL.events.push({
                    type: "wheel",
                    deltaX: 0,
                    deltaY: delta
                  });
                  event2.preventDefault();
                  break;
                case "mousemove":
                  if (SDL.DOMButtons[0] === 1) {
                    SDL.events.push({
                      type: "touchmove",
                      touch: {
                        identifier: 0,
                        deviceID: -1,
                        pageX: event2.pageX,
                        pageY: event2.pageY
                      }
                    });
                  }
                  if (Browser.pointerLock) {
                    if ("mozMovementX" in event2) {
                      event2["movementX"] = event2["mozMovementX"];
                      event2["movementY"] = event2["mozMovementY"];
                    }
                    if (event2["movementX"] == 0 && event2["movementY"] == 0) {
                      event2.preventDefault();
                      return;
                    }
                  }
                case "keydown":
                case "keyup":
                case "keypress":
                case "mousedown":
                case "mouseup":
                  if (event2.type !== "keydown" || !SDL_unicode() && !SDL.textInput || (event2.keyCode === 8 || event2.keyCode === 9)) {
                    event2.preventDefault();
                  }
                  if (event2.type == "mousedown") {
                    SDL.DOMButtons[event2.button] = 1;
                    SDL.events.push({
                      type: "touchstart",
                      touch: {
                        identifier: 0,
                        deviceID: -1,
                        pageX: event2.pageX,
                        pageY: event2.pageY
                      }
                    });
                  } else if (event2.type == "mouseup") {
                    if (!SDL.DOMButtons[event2.button]) {
                      return;
                    }
                    SDL.events.push({
                      type: "touchend",
                      touch: {
                        identifier: 0,
                        deviceID: -1,
                        pageX: event2.pageX,
                        pageY: event2.pageY
                      }
                    });
                    SDL.DOMButtons[event2.button] = 0;
                  }
                  if (event2.type === "keydown" || event2.type === "mousedown") {
                    SDL.canRequestFullscreen = true;
                  } else if (event2.type === "keyup" || event2.type === "mouseup") {
                    if (SDL.isRequestingFullscreen) {
                      Module["requestFullscreen"](true, true);
                      SDL.isRequestingFullscreen = false;
                    }
                    SDL.canRequestFullscreen = false;
                  }
                  if (event2.type === "keypress" && SDL.savedKeydown) {
                    SDL.savedKeydown.keypressCharCode = event2.charCode;
                    SDL.savedKeydown = null;
                  } else if (event2.type === "keydown") {
                    SDL.savedKeydown = event2;
                  }
                  if (event2.type !== "keypress" || SDL.textInput) {
                    SDL.events.push(event2);
                  }
                  break;
                case "mouseout":
                  for (var i2 = 0; i2 < 3; i2++) {
                    if (SDL.DOMButtons[i2]) {
                      SDL.events.push({
                        type: "mouseup",
                        button: i2,
                        pageX: event2.pageX,
                        pageY: event2.pageY
                      });
                      SDL.DOMButtons[i2] = 0;
                    }
                  }
                  event2.preventDefault();
                  break;
                case "focus":
                  SDL.events.push(event2);
                  event2.preventDefault();
                  break;
                case "blur":
                  SDL.events.push(event2);
                  unpressAllPressedKeys();
                  event2.preventDefault();
                  break;
                case "visibilitychange":
                  SDL.events.push({
                    type: "visibilitychange",
                    visible: !document.hidden
                  });
                  unpressAllPressedKeys();
                  event2.preventDefault();
                  break;
                case "unload":
                  if (Browser.mainLoop.runner) {
                    SDL.events.push(event2);
                    Browser.mainLoop.runner();
                  }
                  return;
                case "resize":
                  SDL.events.push(event2);
                  if (event2.preventDefault) {
                    event2.preventDefault();
                  }
                  break;
              }
              if (SDL.events.length >= 1e4) {
                err("SDL event queue full, dropping events");
                SDL.events = SDL.events.slice(0, 1e4);
              }
              SDL.flushEventsToHandler();
              return;
            },
            lookupKeyCodeForEvent: (event2) => {
              var code = event2.keyCode;
              if (code >= 65 && code <= 90) {
                code += 32;
              } else {
                code = SDL.keyCodes[event2.keyCode] || event2.keyCode;
                if (event2.location === 2 && code >= (224 | 1 << 10) && code <= (227 | 1 << 10)) {
                  code += 4;
                }
              }
              return code;
            },
            handleEvent: (event2) => {
              if (event2.handled)
                return;
              event2.handled = true;
              switch (event2.type) {
                case "touchstart":
                case "touchend":
                case "touchmove": {
                  Browser.calculateMouseEvent(event2);
                  break;
                }
                case "keydown":
                case "keyup": {
                  var down = event2.type === "keydown";
                  var code = SDL.lookupKeyCodeForEvent(event2);
                  HEAP8[SDL.keyboardState + code >>> 0 >>> 0] = down;
                  SDL.modState = (HEAP8[SDL.keyboardState + 1248 >>> 0 >>> 0] ? 64 : 0) | (HEAP8[SDL.keyboardState + 1249 >>> 0 >>> 0] ? 1 : 0) | (HEAP8[SDL.keyboardState + 1250 >>> 0 >>> 0] ? 256 : 0) | (HEAP8[SDL.keyboardState + 1252 >>> 0 >>> 0] ? 128 : 0) | (HEAP8[SDL.keyboardState + 1253 >>> 0 >>> 0] ? 2 : 0) | (HEAP8[SDL.keyboardState + 1254 >>> 0 >>> 0] ? 512 : 0);
                  if (down) {
                    SDL.keyboardMap[code] = event2.keyCode;
                  } else {
                    delete SDL.keyboardMap[code];
                  }
                  break;
                }
                case "mousedown":
                case "mouseup":
                  if (event2.type == "mousedown") {
                    SDL.buttonState |= 1 << event2.button;
                  } else if (event2.type == "mouseup") {
                    SDL.buttonState &= ~(1 << event2.button);
                  }
                case "mousemove": {
                  Browser.calculateMouseEvent(event2);
                  break;
                }
              }
            },
            flushEventsToHandler: () => {
              if (!SDL.eventHandler)
                return;
              while (SDL.pollEvent(SDL.eventHandlerTemp)) {
                getWasmTableEntry(SDL.eventHandler)(SDL.eventHandlerContext, SDL.eventHandlerTemp);
              }
            },
            pollEvent: (ptr2) => {
              if (SDL.initFlags & 512 && SDL.joystickEventState) {
                SDL.queryJoysticks();
              }
              if (ptr2) {
                while (SDL.events.length > 0) {
                  if (SDL.makeCEvent(SDL.events.shift(), ptr2) !== false)
                    return 1;
                }
                return 0;
              }
              return SDL.events.length > 0;
            },
            makeCEvent: (event2, ptr2) => {
              if (typeof event2 == "number") {
                _memcpy(ptr2, event2, 28);
                _free(event2);
                return;
              }
              SDL.handleEvent(event2);
              switch (event2.type) {
                case "keydown":
                case "keyup": {
                  var down = event2.type === "keydown";
                  var key = SDL.lookupKeyCodeForEvent(event2);
                  var scan;
                  if (key >= 1024) {
                    scan = key - 1024;
                  } else {
                    scan = SDL.scanCodes[key] || key;
                  }
                  HEAP32[ptr2 >>> 2 >>> 0] = SDL.DOMEventToSDLEvent[event2.type];
                  HEAP8[ptr2 + 8 >>> 0 >>> 0] = down ? 1 : 0;
                  HEAP8[ptr2 + 9 >>> 0 >>> 0] = 0;
                  HEAP32[ptr2 + 12 >>> 2 >>> 0] = scan;
                  HEAP32[ptr2 + 16 >>> 2 >>> 0] = key;
                  HEAP16[ptr2 + 20 >>> 1 >>> 0] = SDL.modState;
                  HEAP32[ptr2 + 24 >>> 2 >>> 0] = event2.keypressCharCode || key;
                  break;
                }
                case "keypress": {
                  HEAP32[ptr2 >>> 2 >>> 0] = SDL.DOMEventToSDLEvent[event2.type];
                  var cStr = intArrayFromString(String.fromCharCode(event2.charCode));
                  for (var i2 = 0; i2 < cStr.length; ++i2) {
                    HEAP8[ptr2 + (8 + i2) >>> 0 >>> 0] = cStr[i2];
                  }
                  break;
                }
                case "mousedown":
                case "mouseup":
                case "mousemove": {
                  if (event2.type != "mousemove") {
                    var down = event2.type === "mousedown";
                    HEAP32[ptr2 >>> 2 >>> 0] = SDL.DOMEventToSDLEvent[event2.type];
                    HEAP32[ptr2 + 4 >>> 2 >>> 0] = 0;
                    HEAP32[ptr2 + 8 >>> 2 >>> 0] = 0;
                    HEAP32[ptr2 + 12 >>> 2 >>> 0] = 0;
                    HEAP8[ptr2 + 16 >>> 0 >>> 0] = event2.button + 1;
                    HEAP8[ptr2 + 17 >>> 0 >>> 0] = down ? 1 : 0;
                    HEAP32[ptr2 + 20 >>> 2 >>> 0] = Browser.mouseX;
                    HEAP32[ptr2 + 24 >>> 2 >>> 0] = Browser.mouseY;
                  } else {
                    HEAP32[ptr2 >>> 2 >>> 0] = SDL.DOMEventToSDLEvent[event2.type];
                    HEAP32[ptr2 + 4 >>> 2 >>> 0] = 0;
                    HEAP32[ptr2 + 8 >>> 2 >>> 0] = 0;
                    HEAP32[ptr2 + 12 >>> 2 >>> 0] = 0;
                    HEAP32[ptr2 + 16 >>> 2 >>> 0] = SDL.buttonState;
                    HEAP32[ptr2 + 20 >>> 2 >>> 0] = Browser.mouseX;
                    HEAP32[ptr2 + 24 >>> 2 >>> 0] = Browser.mouseY;
                    HEAP32[ptr2 + 28 >>> 2 >>> 0] = Browser.mouseMovementX;
                    HEAP32[ptr2 + 32 >>> 2 >>> 0] = Browser.mouseMovementY;
                  }
                  break;
                }
                case "wheel": {
                  HEAP32[ptr2 >>> 2 >>> 0] = SDL.DOMEventToSDLEvent[event2.type];
                  HEAP32[ptr2 + 16 >>> 2 >>> 0] = event2.deltaX;
                  HEAP32[ptr2 + 20 >>> 2 >>> 0] = event2.deltaY;
                  break;
                }
                case "touchstart":
                case "touchend":
                case "touchmove": {
                  var touch = event2.touch;
                  if (!Browser.touches[touch.identifier])
                    break;
                  var w = Module["canvas"].width;
                  var h = Module["canvas"].height;
                  var x = Browser.touches[touch.identifier].x / w;
                  var y = Browser.touches[touch.identifier].y / h;
                  var lx = Browser.lastTouches[touch.identifier].x / w;
                  var ly = Browser.lastTouches[touch.identifier].y / h;
                  var dx = x - lx;
                  var dy = y - ly;
                  if (touch["deviceID"] === void 0)
                    touch.deviceID = SDL.TOUCH_DEFAULT_ID;
                  if (dx === 0 && dy === 0 && event2.type === "touchmove")
                    return false;
                  HEAP32[ptr2 >>> 2 >>> 0] = SDL.DOMEventToSDLEvent[event2.type];
                  HEAP32[ptr2 + 4 >>> 2 >>> 0] = _SDL_GetTicks();
                  tempI64 = [touch.deviceID >>> 0, (tempDouble = touch.deviceID, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[ptr2 + 8 >>> 2 >>> 0] = tempI64[0], HEAP32[ptr2 + 12 >>> 2 >>> 0] = tempI64[1];
                  tempI64 = [touch.identifier >>> 0, (tempDouble = touch.identifier, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[ptr2 + 16 >>> 2 >>> 0] = tempI64[0], HEAP32[ptr2 + 20 >>> 2 >>> 0] = tempI64[1];
                  HEAPF32[ptr2 + 24 >>> 2 >>> 0] = x;
                  HEAPF32[ptr2 + 28 >>> 2 >>> 0] = y;
                  HEAPF32[ptr2 + 32 >>> 2 >>> 0] = dx;
                  HEAPF32[ptr2 + 36 >>> 2 >>> 0] = dy;
                  if (touch.force !== void 0) {
                    HEAPF32[ptr2 + 40 >>> 2 >>> 0] = touch.force;
                  } else {
                    HEAPF32[ptr2 + 40 >>> 2 >>> 0] = event2.type == "touchend" ? 0 : 1;
                  }
                  break;
                }
                case "unload": {
                  HEAP32[ptr2 >>> 2 >>> 0] = SDL.DOMEventToSDLEvent[event2.type];
                  break;
                }
                case "resize": {
                  HEAP32[ptr2 >>> 2 >>> 0] = SDL.DOMEventToSDLEvent[event2.type];
                  HEAP32[ptr2 + 4 >>> 2 >>> 0] = event2.w;
                  HEAP32[ptr2 + 8 >>> 2 >>> 0] = event2.h;
                  break;
                }
                case "joystick_button_up":
                case "joystick_button_down": {
                  var state = event2.type === "joystick_button_up" ? 0 : 1;
                  HEAP32[ptr2 >>> 2 >>> 0] = SDL.DOMEventToSDLEvent[event2.type];
                  HEAP8[ptr2 + 4 >>> 0 >>> 0] = event2.index;
                  HEAP8[ptr2 + 5 >>> 0 >>> 0] = event2.button;
                  HEAP8[ptr2 + 6 >>> 0 >>> 0] = state;
                  break;
                }
                case "joystick_axis_motion": {
                  HEAP32[ptr2 >>> 2 >>> 0] = SDL.DOMEventToSDLEvent[event2.type];
                  HEAP8[ptr2 + 4 >>> 0 >>> 0] = event2.index;
                  HEAP8[ptr2 + 5 >>> 0 >>> 0] = event2.axis;
                  HEAP32[ptr2 + 8 >>> 2 >>> 0] = SDL.joystickAxisValueConversion(event2.value);
                  break;
                }
                case "focus": {
                  var SDL_WINDOWEVENT_FOCUS_GAINED = 12;
                  HEAP32[ptr2 >>> 2 >>> 0] = SDL.DOMEventToSDLEvent[event2.type];
                  HEAP32[ptr2 + 4 >>> 2 >>> 0] = 0;
                  HEAP8[ptr2 + 8 >>> 0 >>> 0] = SDL_WINDOWEVENT_FOCUS_GAINED;
                  break;
                }
                case "blur": {
                  var SDL_WINDOWEVENT_FOCUS_LOST = 13;
                  HEAP32[ptr2 >>> 2 >>> 0] = SDL.DOMEventToSDLEvent[event2.type];
                  HEAP32[ptr2 + 4 >>> 2 >>> 0] = 0;
                  HEAP8[ptr2 + 8 >>> 0 >>> 0] = SDL_WINDOWEVENT_FOCUS_LOST;
                  break;
                }
                case "visibilitychange": {
                  var SDL_WINDOWEVENT_SHOWN = 1;
                  var SDL_WINDOWEVENT_HIDDEN = 2;
                  var visibilityEventID = event2.visible ? SDL_WINDOWEVENT_SHOWN : SDL_WINDOWEVENT_HIDDEN;
                  HEAP32[ptr2 >>> 2 >>> 0] = SDL.DOMEventToSDLEvent[event2.type];
                  HEAP32[ptr2 + 4 >>> 2 >>> 0] = 0;
                  HEAP8[ptr2 + 8 >>> 0 >>> 0] = visibilityEventID;
                  break;
                }
                default:
                  throw "Unhandled SDL event: " + event2.type;
              }
            },
            makeFontString: (height, fontName) => {
              if (fontName.charAt(0) != "'" && fontName.charAt(0) != '"') {
                fontName = '"' + fontName + '"';
              }
              return height + "px " + fontName + ", serif";
            },
            estimateTextWidth: (fontData, text) => {
              var h = fontData.size;
              var fontString = SDL.makeFontString(h, fontData.name);
              var tempCtx = SDL_ttfContext();
              tempCtx.font = fontString;
              var ret = tempCtx.measureText(text).width | 0;
              return ret;
            },
            allocateChannels: (num) => {
              if (SDL.numChannels && SDL.numChannels >= num && num != 0)
                return;
              SDL.numChannels = num;
              SDL.channels = [];
              for (var i2 = 0; i2 < num; i2++) {
                SDL.channels[i2] = {
                  audio: null,
                  volume: 1
                };
              }
            },
            setGetVolume: (info2, volume) => {
              if (!info2)
                return 0;
              var ret = info2.volume * 128;
              if (volume != -1) {
                info2.volume = Math.min(Math.max(volume, 0), 128) / 128;
                if (info2.audio) {
                  try {
                    info2.audio.volume = info2.volume;
                    if (info2.audio.webAudioGainNode)
                      info2.audio.webAudioGainNode["gain"]["value"] = info2.volume;
                  } catch (e) {
                    err(`setGetVolume failed to set audio volume: ${e}`);
                  }
                }
              }
              return ret;
            },
            setPannerPosition: (info2, x, y, z) => {
              if (!info2)
                return;
              if (info2.audio) {
                if (info2.audio.webAudioPannerNode) {
                  info2.audio.webAudioPannerNode["setPosition"](x, y, z);
                }
              }
            },
            playWebAudio: (audio) => {
              if (!audio)
                return;
              if (audio.webAudioNode)
                return;
              if (!SDL.webAudioAvailable())
                return;
              try {
                var webAudio = audio.resource.webAudio;
                audio.paused = false;
                if (!webAudio.decodedBuffer) {
                  if (webAudio.onDecodeComplete === void 0)
                    abort("Cannot play back audio object that was not loaded");
                  webAudio.onDecodeComplete.push(() => {
                    if (!audio.paused)
                      SDL.playWebAudio(audio);
                  });
                  return;
                }
                audio.webAudioNode = SDL.audioContext["createBufferSource"]();
                audio.webAudioNode["buffer"] = webAudio.decodedBuffer;
                audio.webAudioNode["loop"] = audio.loop;
                audio.webAudioNode["onended"] = audio["onended"];
                audio.webAudioPannerNode = SDL.audioContext["createPanner"]();
                audio.webAudioPannerNode["setPosition"](0, 0, -0.5);
                audio.webAudioPannerNode["panningModel"] = "equalpower";
                audio.webAudioGainNode = SDL.audioContext["createGain"]();
                audio.webAudioGainNode["gain"]["value"] = audio.volume;
                audio.webAudioNode["connect"](audio.webAudioPannerNode);
                audio.webAudioPannerNode["connect"](audio.webAudioGainNode);
                audio.webAudioGainNode["connect"](SDL.audioContext["destination"]);
                audio.webAudioNode["start"](0, audio.currentPosition);
                audio.startTime = SDL.audioContext["currentTime"] - audio.currentPosition;
              } catch (e) {
                err(`playWebAudio failed: ${e}`);
              }
            },
            pauseWebAudio: (audio) => {
              if (!audio)
                return;
              if (audio.webAudioNode) {
                try {
                  audio.currentPosition = (SDL.audioContext["currentTime"] - audio.startTime) % audio.resource.webAudio.decodedBuffer.duration;
                  audio.webAudioNode["onended"] = void 0;
                  audio.webAudioNode.stop(0);
                  audio.webAudioNode = void 0;
                } catch (e) {
                  err(`pauseWebAudio failed: ${e}`);
                }
              }
              audio.paused = true;
            },
            openAudioContext: () => {
              if (!SDL.audioContext) {
                if (typeof AudioContext != "undefined")
                  SDL.audioContext = new AudioContext();
                else if (typeof webkitAudioContext != "undefined")
                  SDL.audioContext = new webkitAudioContext();
              }
            },
            webAudioAvailable: () => !!SDL.audioContext,
            fillWebAudioBufferFromHeap: (heapPtr, sizeSamplesPerChannel, dstAudioBuffer) => {
              var audio = SDL_audio();
              var numChannels = audio.channels;
              for (var c = 0; c < numChannels; ++c) {
                var channelData = dstAudioBuffer["getChannelData"](c);
                if (channelData.length != sizeSamplesPerChannel) {
                  throw "Web Audio output buffer length mismatch! Destination size: " + channelData.length + " samples vs expected " + sizeSamplesPerChannel + " samples!";
                }
                if (audio.format == 32784) {
                  for (var j = 0; j < sizeSamplesPerChannel; ++j) {
                    channelData[j] = HEAP16[heapPtr + (j * numChannels + c) * 2 >>> 1 >>> 0] / 32768;
                  }
                } else if (audio.format == 8) {
                  for (var j = 0; j < sizeSamplesPerChannel; ++j) {
                    var v = HEAP8[heapPtr + (j * numChannels + c) >>> 0 >>> 0];
                    channelData[j] = (v >= 0 ? v - 128 : v + 128) / 128;
                  }
                } else if (audio.format == 33056) {
                  for (var j = 0; j < sizeSamplesPerChannel; ++j) {
                    channelData[j] = HEAPF32[heapPtr + (j * numChannels + c) * 4 >>> 2 >>> 0];
                  }
                } else {
                  throw "Invalid SDL audio format " + audio.format + "!";
                }
              }
            },
            joystickEventState: 1,
            lastJoystickState: {},
            joystickNamePool: {},
            recordJoystickState: (joystick, state) => {
              var buttons = new Array(state.buttons.length);
              for (var i2 = 0; i2 < state.buttons.length; i2++) {
                buttons[i2] = SDL.getJoystickButtonState(state.buttons[i2]);
              }
              SDL.lastJoystickState[joystick] = {
                buttons,
                axes: state.axes.slice(0),
                timestamp: state.timestamp,
                index: state.index,
                id: state.id
              };
            },
            getJoystickButtonState: (button) => {
              if (typeof button == "object") {
                return button["pressed"];
              }
              return button > 0;
            },
            queryJoysticks: () => {
              for (var joystick in SDL.lastJoystickState) {
                var state = SDL.getGamepad(joystick - 1);
                var prevState = SDL.lastJoystickState[joystick];
                if (typeof state == "undefined")
                  return;
                if (state === null)
                  return;
                if (typeof state.timestamp != "number" || state.timestamp != prevState.timestamp || !state.timestamp) {
                  var i2;
                  for (i2 = 0; i2 < state.buttons.length; i2++) {
                    var buttonState = SDL.getJoystickButtonState(state.buttons[i2]);
                    if (buttonState !== prevState.buttons[i2]) {
                      SDL.events.push({
                        type: buttonState ? "joystick_button_down" : "joystick_button_up",
                        joystick,
                        index: joystick - 1,
                        button: i2
                      });
                    }
                  }
                  for (i2 = 0; i2 < state.axes.length; i2++) {
                    if (state.axes[i2] !== prevState.axes[i2]) {
                      SDL.events.push({
                        type: "joystick_axis_motion",
                        joystick,
                        index: joystick - 1,
                        axis: i2,
                        value: state.axes[i2]
                      });
                    }
                  }
                  SDL.recordJoystickState(joystick, state);
                }
              }
            },
            joystickAxisValueConversion: (value) => {
              value = Math.min(1, Math.max(value, -1));
              return Math.ceil((value + 1) * 32767.5 - 32768);
            },
            getGamepads: () => {
              var fcn = navigator.getGamepads || navigator.webkitGamepads || navigator.mozGamepads || navigator.gamepads || navigator.webkitGetGamepads;
              if (fcn !== void 0) {
                return fcn.apply(navigator);
              }
              return [];
            },
            getGamepad: (deviceIndex) => {
              var gamepads = SDL.getGamepads();
              if (gamepads.length > deviceIndex && deviceIndex >= 0) {
                return gamepads[deviceIndex];
              }
              return null;
            }
          };
          var SDL_unicode = () => SDL.unicode;
          function _SDL_Linked_Version() {
            if (SDL.version === null) {
              SDL.version = _malloc(3);
              HEAP8[SDL.version + 0 >>> 0 >>> 0] = 1;
              HEAP8[SDL.version + 1 >>> 0 >>> 0] = 3;
              HEAP8[SDL.version + 2 >>> 0 >>> 0] = 0;
            }
            return SDL.version;
          }
          _SDL_Linked_Version.sig = "p";
          var _SDL_Init = (initFlags) => {
            SDL.startTime = Date.now();
            SDL.initFlags = initFlags;
            if (!Module["doNotCaptureKeyboard"]) {
              var keyboardListeningElement = Module["keyboardListeningElement"] || document;
              keyboardListeningElement.addEventListener("keydown", SDL.receiveEvent);
              keyboardListeningElement.addEventListener("keyup", SDL.receiveEvent);
              keyboardListeningElement.addEventListener("keypress", SDL.receiveEvent);
              window.addEventListener("focus", SDL.receiveEvent);
              window.addEventListener("blur", SDL.receiveEvent);
              document.addEventListener("visibilitychange", SDL.receiveEvent);
            }
            window.addEventListener("unload", SDL.receiveEvent);
            SDL.keyboardState = _malloc(65536);
            zeroMemory(SDL.keyboardState, 65536);
            SDL.DOMEventToSDLEvent["keydown"] = 768;
            SDL.DOMEventToSDLEvent["keyup"] = 769;
            SDL.DOMEventToSDLEvent["keypress"] = 771;
            SDL.DOMEventToSDLEvent["mousedown"] = 1025;
            SDL.DOMEventToSDLEvent["mouseup"] = 1026;
            SDL.DOMEventToSDLEvent["mousemove"] = 1024;
            SDL.DOMEventToSDLEvent["wheel"] = 1027;
            SDL.DOMEventToSDLEvent["touchstart"] = 1792;
            SDL.DOMEventToSDLEvent["touchend"] = 1793;
            SDL.DOMEventToSDLEvent["touchmove"] = 1794;
            SDL.DOMEventToSDLEvent["unload"] = 256;
            SDL.DOMEventToSDLEvent["resize"] = 28673;
            SDL.DOMEventToSDLEvent["visibilitychange"] = 512;
            SDL.DOMEventToSDLEvent["focus"] = 512;
            SDL.DOMEventToSDLEvent["blur"] = 512;
            SDL.DOMEventToSDLEvent["joystick_axis_motion"] = 1536;
            SDL.DOMEventToSDLEvent["joystick_button_down"] = 1539;
            SDL.DOMEventToSDLEvent["joystick_button_up"] = 1540;
            return 0;
          };
          _SDL_Init.sig = "ii";
          var _SDL_WasInit = (flags2) => {
            if (SDL.startTime === null) {
              _SDL_Init(0);
            }
            return 1;
          };
          _SDL_WasInit.sig = "ii";
          function _SDL_GetVideoInfo() {
            var ret = _malloc(20);
            zeroMemory(ret, 3);
            HEAP32[ret + 12 >>> 2 >>> 0] = Module["canvas"].width;
            HEAP32[ret + 16 >>> 2 >>> 0] = Module["canvas"].height;
            return ret;
          }
          _SDL_GetVideoInfo.sig = "p";
          function _SDL_ListModes(format, flags2) {
            format >>>= 0;
            return -1;
          }
          _SDL_ListModes.sig = "ppi";
          var _SDL_VideoModeOK = (width, height, depth, flags2) => depth;
          _SDL_VideoModeOK.sig = "iiiii";
          function _SDL_VideoDriverName(buf, max_size) {
            buf >>>= 0;
            if (SDL.startTime === null) {
              return 0;
            }
            var driverName = [101, 109, 115, 99, 114, 105, 112, 116, 101, 110, 95, 115, 100, 108, 95, 100, 114, 105, 118, 101, 114];
            var index = 0;
            var size = driverName.length;
            if (max_size <= size) {
              size = max_size - 1;
            }
            while (index < size) {
              var value = driverName[index];
              HEAP8[buf + index >>> 0 >>> 0] = value;
              index++;
            }
            HEAP8[buf + index >>> 0 >>> 0] = 0;
            return buf;
          }
          _SDL_VideoDriverName.sig = "ppi";
          var _SDL_AudioDriverName = _SDL_VideoDriverName;
          _SDL_AudioDriverName.sig = "ppi";
          var _SDL_SetVideoMode = function(width, height, depth, flags2) {
            ["touchstart", "touchend", "touchmove", "mousedown", "mouseup", "mousemove", "mousewheel", "wheel", "mouseout", "DOMMouseScroll"].forEach((e) => Module["canvas"].addEventListener(e, SDL.receiveEvent, true));
            var canvas = Module["canvas"];
            if (width == 0 && height == 0) {
              width = canvas.width;
              height = canvas.height;
            }
            if (!SDL.addedResizeListener) {
              SDL.addedResizeListener = true;
              Browser.resizeListeners.push((w, h) => {
                if (!SDL.settingVideoMode) {
                  SDL.receiveEvent({
                    type: "resize",
                    w,
                    h
                  });
                }
              });
            }
            SDL.settingVideoMode = true;
            Browser.setCanvasSize(width, height);
            SDL.settingVideoMode = false;
            if (SDL.screen) {
              SDL.freeSurface(SDL.screen);
              assert(!SDL.screen);
            }
            if (SDL.GL)
              flags2 = flags2 | 67108864;
            SDL.screen = SDL.makeSurface(width, height, flags2, true, "screen");
            return SDL.screen;
          };
          _SDL_SetVideoMode.sig = "piiii";
          function _SDL_GetVideoSurface() {
            return SDL.screen;
          }
          _SDL_GetVideoSurface.sig = "p";
          var _SDL_AudioQuit = () => {
            for (var i2 = 0; i2 < SDL.numChannels; ++i2) {
              var chan = SDL.channels[i2];
              if (chan.audio) {
                chan.audio.pause();
                chan.audio = void 0;
              }
            }
            var audio = SDL.music.audio;
            audio?.pause();
            SDL.music.audio = void 0;
          };
          _SDL_AudioQuit.sig = "v";
          var _SDL_VideoQuit = () => out("SDL_VideoQuit called (and ignored)");
          _SDL_VideoQuit.sig = "v";
          var _SDL_QuitSubSystem = (flags2) => out("SDL_QuitSubSystem called (and ignored)");
          _SDL_QuitSubSystem.sig = "vi";
          var _SDL_Quit = () => {
            _SDL_AudioQuit();
            out("SDL_Quit called (and ignored)");
          };
          _SDL_Quit.sig = "v";
          function _SDL_UnlockSurface(surf) {
            surf >>>= 0;
            assert(!SDL.GL);
            var surfData = SDL.surfaces[surf];
            if (!surfData.locked || --surfData.locked > 0) {
              return;
            }
            if (surfData.isFlagSet(2097152)) {
              SDL.copyIndexedColorData(surfData);
            } else if (!surfData.colors) {
              var data2 = surfData.image.data;
              var buffer = surfData.buffer;
              assert(buffer % 4 == 0, "Invalid buffer offset: " + buffer);
              var src = buffer >> 2;
              var dst = 0;
              var isScreen = surf == SDL.screen;
              var num;
              if (typeof CanvasPixelArray != "undefined" && data2 instanceof CanvasPixelArray) {
                num = data2.length;
                while (dst < num) {
                  var val = HEAP32[src >>> 0];
                  data2[dst] = val & 255;
                  data2[dst + 1] = val >> 8 & 255;
                  data2[dst + 2] = val >> 16 & 255;
                  data2[dst + 3] = isScreen ? 255 : val >> 24 & 255;
                  src++;
                  dst += 4;
                }
              } else {
                var data32 = new Uint32Array(data2.buffer);
                if (isScreen && SDL.defaults.opaqueFrontBuffer) {
                  num = data32.length;
                  data32.set(HEAP32.subarray(src >>> 0, src + num >>> 0));
                  var data8 = new Uint8Array(data2.buffer);
                  var i2 = 3;
                  var j = i2 + 4 * num;
                  if (num % 8 == 0) {
                    while (i2 < j) {
                      data8[i2] = 255;
                      i2 = i2 + 4 | 0;
                      data8[i2] = 255;
                      i2 = i2 + 4 | 0;
                      data8[i2] = 255;
                      i2 = i2 + 4 | 0;
                      data8[i2] = 255;
                      i2 = i2 + 4 | 0;
                      data8[i2] = 255;
                      i2 = i2 + 4 | 0;
                      data8[i2] = 255;
                      i2 = i2 + 4 | 0;
                      data8[i2] = 255;
                      i2 = i2 + 4 | 0;
                      data8[i2] = 255;
                      i2 = i2 + 4 | 0;
                    }
                  } else {
                    while (i2 < j) {
                      data8[i2] = 255;
                      i2 = i2 + 4 | 0;
                    }
                  }
                } else {
                  data32.set(HEAP32.subarray(src >>> 0, src + data32.length >>> 0));
                }
              }
            } else {
              var width = Module["canvas"].width;
              var height = Module["canvas"].height;
              var s2 = surfData.buffer;
              var data2 = surfData.image.data;
              var colors = surfData.colors;
              for (var y = 0; y < height; y++) {
                var base = y * width * 4;
                for (var x = 0; x < width; x++) {
                  var val = HEAPU8[s2++ >>> 0 >>> 0] * 4;
                  var start2 = base + x * 4;
                  data2[start2] = colors[val];
                  data2[start2 + 1] = colors[val + 1];
                  data2[start2 + 2] = colors[val + 2];
                }
                s2 += width * 3;
              }
            }
            surfData.ctx.putImageData(surfData.image, 0, 0);
          }
          _SDL_UnlockSurface.sig = "vp";
          function _SDL_Flip(surf) {
            surf >>>= 0;
          }
          _SDL_Flip.sig = "ip";
          function _SDL_UpdateRect(surf, x, y, w, h) {
            surf >>>= 0;
          }
          _SDL_UpdateRect.sig = "vpiiii";
          function _SDL_UpdateRects(surf, numrects, rects) {
            surf >>>= 0;
            rects >>>= 0;
          }
          _SDL_UpdateRects.sig = "vpip";
          var _SDL_Delay = (delay) => {
            if (!ENVIRONMENT_IS_WORKER)
              abort("SDL_Delay called on the main thread! Potential infinite loop, quitting. (consider building with async support like ASYNCIFY)");
            var now = Date.now();
            while (Date.now() - now < delay) {
            }
          };
          _SDL_Delay.sig = "vi";
          function _SDL_WM_SetCaption(title, icon) {
            title >>>= 0;
            icon >>>= 0;
            if (title) {
              _emscripten_set_window_title(title);
            }
            icon && (icon = UTF8ToString(icon));
          }
          _SDL_WM_SetCaption.sig = "vpp";
          var _SDL_EnableKeyRepeat = (delay, interval) => {
          };
          _SDL_EnableKeyRepeat.sig = "iii";
          function _SDL_GetKeyboardState(numKeys) {
            numKeys >>>= 0;
            if (numKeys) {
              HEAP32[numKeys >>> 2 >>> 0] = 65536;
            }
            return SDL.keyboardState;
          }
          _SDL_GetKeyboardState.sig = "pp";
          var _SDL_GetKeyState = () => _SDL_GetKeyboardState(0);
          function _SDL_GetKeyName(key) {
            SDL.keyName || (SDL.keyName = stringToNewUTF8("unknown key"));
            return SDL.keyName;
          }
          _SDL_GetKeyName.sig = "pi";
          var _SDL_GetModState = () => SDL.modState;
          _SDL_GetModState.sig = "i";
          function _SDL_GetMouseState(x, y) {
            x >>>= 0;
            y >>>= 0;
            if (x)
              HEAP32[x >>> 2 >>> 0] = Browser.mouseX;
            if (y)
              HEAP32[y >>> 2 >>> 0] = Browser.mouseY;
            return SDL.buttonState;
          }
          _SDL_GetMouseState.sig = "ipp";
          var _SDL_WarpMouse = (x, y) => {
          };
          _SDL_WarpMouse.sig = "vii";
          var _SDL_ShowCursor = (toggle) => {
            switch (toggle) {
              case 0:
                if (Browser.isFullscreen) {
                  Module["canvas"].requestPointerLock();
                  return 0;
                }
                return 1;
              case 1:
                Module["canvas"].exitPointerLock();
                return 1;
              case -1:
                return !Browser.pointerLock;
              default:
                err(`SDL_ShowCursor called with unknown toggle parameter value: ${toggle}`);
                break;
            }
          };
          _SDL_ShowCursor.sig = "ii";
          function _SDL_GetError() {
            SDL.errorMessage || (SDL.errorMessage = stringToNewUTF8("unknown SDL-emscripten error"));
            return SDL.errorMessage;
          }
          _SDL_GetError.sig = "p";
          function _SDL_SetError(fmt, varargs) {
            fmt >>>= 0;
            varargs >>>= 0;
          }
          _SDL_SetError.sig = "vpp";
          function _SDL_CreateRGBSurface(flags2, width, height, depth, rmask, gmask, bmask, amask) {
            return SDL.makeSurface(width, height, flags2, false, "CreateRGBSurface", rmask, gmask, bmask, amask);
          }
          _SDL_CreateRGBSurface.sig = "piiiiiiii";
          function _SDL_CreateRGBSurfaceFrom(pixels, width, height, depth, pitch, rmask, gmask, bmask, amask) {
            pixels >>>= 0;
            var surf = SDL.makeSurface(width, height, 0, false, "CreateRGBSurfaceFrom", rmask, gmask, bmask, amask);
            if (depth !== 32) {
              err("TODO: Partially unimplemented SDL_CreateRGBSurfaceFrom called!");
              return surf;
            }
            var data2 = SDL.surfaces[surf];
            var image = data2.ctx.createImageData(width, height);
            var pitchOfDst = width * 4;
            for (var row = 0; row < height; ++row) {
              var baseOfSrc = row * pitch;
              var baseOfDst = row * pitchOfDst;
              for (var col = 0; col < width * 4; ++col) {
                image.data[baseOfDst + col] = HEAPU8[pixels + (baseOfDst + col) >>> 0 >>> 0];
              }
            }
            data2.ctx.putImageData(image, 0, 0);
            return surf;
          }
          _SDL_CreateRGBSurfaceFrom.sig = "ppiiiiiiii";
          function _SDL_ConvertSurface(surf, format, flags2) {
            surf >>>= 0;
            format >>>= 0;
            if (format) {
              SDL.checkPixelFormat(format);
            }
            var oldData = SDL.surfaces[surf];
            var ret = SDL.makeSurface(oldData.width, oldData.height, oldData.flags, false, "copy:" + oldData.source);
            var newData = SDL.surfaces[ret];
            newData.ctx.globalCompositeOperation = "copy";
            newData.ctx.drawImage(oldData.canvas, 0, 0);
            newData.ctx.globalCompositeOperation = oldData.ctx.globalCompositeOperation;
            return ret;
          }
          _SDL_ConvertSurface.sig = "pppi";
          function _SDL_DisplayFormatAlpha(surf) {
            surf >>>= 0;
            return _SDL_ConvertSurface(surf, 0, 0);
          }
          _SDL_DisplayFormatAlpha.sig = "pp";
          function _SDL_FreeSurface(surf) {
            surf >>>= 0;
            if (surf)
              SDL.freeSurface(surf);
          }
          _SDL_FreeSurface.sig = "vp";
          function _SDL_UpperBlit(src, srcrect, dst, dstrect) {
            src >>>= 0;
            srcrect >>>= 0;
            dst >>>= 0;
            dstrect >>>= 0;
            return SDL.blitSurface(src, srcrect, dst, dstrect, false);
          }
          _SDL_UpperBlit.sig = "ipppp";
          function _SDL_UpperBlitScaled(src, srcrect, dst, dstrect) {
            src >>>= 0;
            srcrect >>>= 0;
            dst >>>= 0;
            dstrect >>>= 0;
            return SDL.blitSurface(src, srcrect, dst, dstrect, true);
          }
          _SDL_UpperBlitScaled.sig = "ipppp";
          var _SDL_LowerBlit = _SDL_UpperBlit;
          _SDL_LowerBlit.sig = "ipppp";
          var _SDL_LowerBlitScaled = _SDL_UpperBlitScaled;
          _SDL_LowerBlitScaled.sig = "ipppp";
          function _SDL_GetClipRect(surf, rect) {
            surf >>>= 0;
            rect >>>= 0;
            assert(rect);
            var surfData = SDL.surfaces[surf];
            var r = surfData.clipRect || {
              x: 0,
              y: 0,
              w: surfData.width,
              h: surfData.height
            };
            SDL.updateRect(rect, r);
          }
          _SDL_GetClipRect.sig = "vpp";
          function _SDL_SetClipRect(surf, rect) {
            surf >>>= 0;
            rect >>>= 0;
            var surfData = SDL.surfaces[surf];
            if (rect) {
              surfData.clipRect = SDL.intersectionOfRects({
                x: 0,
                y: 0,
                w: surfData.width,
                h: surfData.height
              }, SDL.loadRect(rect));
            } else {
              delete surfData.clipRect;
            }
          }
          _SDL_SetClipRect.sig = "ipp";
          function _SDL_FillRect(surf, rect, color) {
            surf >>>= 0;
            rect >>>= 0;
            var surfData = SDL.surfaces[surf];
            assert(!surfData.locked);
            if (surfData.isFlagSet(2097152)) {
              color = surfData.colors32[color];
            }
            var r = rect ? SDL.loadRect(rect) : {
              x: 0,
              y: 0,
              w: surfData.width,
              h: surfData.height
            };
            if (surfData.clipRect) {
              r = SDL.intersectionOfRects(surfData.clipRect, r);
              if (rect) {
                SDL.updateRect(rect, r);
              }
            }
            surfData.ctx.save();
            surfData.ctx.fillStyle = SDL.translateColorToCSSRGBA(color);
            surfData.ctx.fillRect(r.x, r.y, r.w, r.h);
            surfData.ctx.restore();
            return 0;
          }
          _SDL_FillRect.sig = "ippi";
          function _zoomSurface(src, x, y, smooth) {
            src >>>= 0;
            var srcData = SDL.surfaces[src];
            var w = srcData.width * x;
            var h = srcData.height * y;
            var ret = SDL.makeSurface(Math.abs(w), Math.abs(h), srcData.flags, false, "zoomSurface");
            var dstData = SDL.surfaces[ret];
            if (x >= 0 && y >= 0)
              dstData.ctx.drawImage(srcData.canvas, 0, 0, w, h);
            else {
              dstData.ctx.save();
              dstData.ctx.scale(x < 0 ? -1 : 1, y < 0 ? -1 : 1);
              dstData.ctx.drawImage(srcData.canvas, w < 0 ? w : 0, h < 0 ? h : 0, Math.abs(w), Math.abs(h));
              dstData.ctx.restore();
            }
            return ret;
          }
          _zoomSurface.sig = "ppddi";
          function _rotozoomSurface(src, angle, zoom, smooth) {
            src >>>= 0;
            if (angle % 360 === 0) {
              return _zoomSurface(src, zoom, zoom, smooth);
            }
            var srcData = SDL.surfaces[src];
            var w = srcData.width * zoom;
            var h = srcData.height * zoom;
            var diagonal = Math.ceil(Math.sqrt(Math.pow(w, 2) + Math.pow(h, 2)));
            var ret = SDL.makeSurface(diagonal, diagonal, srcData.flags, false, "rotozoomSurface");
            var dstData = SDL.surfaces[ret];
            dstData.ctx.translate(diagonal / 2, diagonal / 2);
            dstData.ctx.rotate(-angle * Math.PI / 180);
            dstData.ctx.drawImage(srcData.canvas, -w / 2, -h / 2, w, h);
            return ret;
          }
          _rotozoomSurface.sig = "ppddi";
          function _SDL_SetAlpha(surf, flag, alpha) {
            surf >>>= 0;
            var surfData = SDL.surfaces[surf];
            surfData.alpha = alpha;
            if (!(flag & 65536)) {
              surfData.alpha = 255;
            }
          }
          _SDL_SetAlpha.sig = "ipii";
          function _SDL_SetColorKey(surf, flag, key) {
            surf >>>= 0;
            warnOnce("SDL_SetColorKey is a no-op for performance reasons");
            return 0;
          }
          _SDL_SetColorKey.sig = "ipii";
          function _SDL_PollEvent(ptr2) {
            ptr2 >>>= 0;
            return SDL.pollEvent(ptr2);
          }
          _SDL_PollEvent.sig = "ip";
          function _SDL_PushEvent(ptr2) {
            ptr2 >>>= 0;
            var copy = _malloc(28);
            _memcpy(copy, ptr2, 28);
            SDL.events.push(copy);
            return 0;
          }
          _SDL_PushEvent.sig = "ip";
          function _SDL_PeepEvents(events, requestedEventCount, action, from, to) {
            events >>>= 0;
            switch (action) {
              case 2: {
                assert(requestedEventCount == 1);
                var index = 0;
                var retrievedEventCount = 0;
                while (index < SDL.events.length && retrievedEventCount < requestedEventCount) {
                  var event2 = SDL.events[index];
                  var type = SDL.DOMEventToSDLEvent[event2.type];
                  if (from <= type && type <= to) {
                    if (SDL.makeCEvent(event2, events) === false) {
                      index++;
                    } else {
                      SDL.events.splice(index, 1);
                      retrievedEventCount++;
                    }
                  } else {
                    index++;
                  }
                }
                return retrievedEventCount;
              }
              default:
                throw "SDL_PeepEvents does not yet support that action: " + action;
            }
          }
          _SDL_PeepEvents.sig = "ipiiii";
          var _SDL_PumpEvents = () => SDL.events.forEach(SDL.handleEvent);
          _SDL_PumpEvents.sig = "v";
          function _emscripten_SDL_SetEventHandler(handler, userdata) {
            handler >>>= 0;
            userdata >>>= 0;
            SDL.eventHandler = handler;
            SDL.eventHandlerContext = userdata;
            if (!SDL.eventHandlerTemp)
              SDL.eventHandlerTemp = _malloc(28);
          }
          _emscripten_SDL_SetEventHandler.sig = "vpp";
          function _SDL_SetColors(surf, colors, firstColor, nColors) {
            surf >>>= 0;
            colors >>>= 0;
            var surfData = SDL.surfaces[surf];
            if (!surfData.colors) {
              var buffer = new ArrayBuffer(256 * 4);
              surfData.colors = new Uint8Array(buffer);
              surfData.colors32 = new Uint32Array(buffer);
            }
            for (var i2 = 0; i2 < nColors; ++i2) {
              var index = (firstColor + i2) * 4;
              surfData.colors[index] = HEAPU8[colors + i2 * 4 >>> 0 >>> 0];
              surfData.colors[index + 1] = HEAPU8[colors + (i2 * 4 + 1) >>> 0 >>> 0];
              surfData.colors[index + 2] = HEAPU8[colors + (i2 * 4 + 2) >>> 0 >>> 0];
              surfData.colors[index + 3] = 255;
            }
            return 1;
          }
          _SDL_SetColors.sig = "ippii";
          function _SDL_SetPalette(surf, flags2, colors, firstColor, nColors) {
            surf >>>= 0;
            colors >>>= 0;
            return _SDL_SetColors(surf, colors, firstColor, nColors);
          }
          _SDL_SetPalette.sig = "ipipii";
          function _SDL_MapRGB(fmt, r, g, b) {
            fmt >>>= 0;
            SDL.checkPixelFormat(fmt);
            return r & 255 | (g & 255) << 8 | (b & 255) << 16 | 4278190080;
          }
          _SDL_MapRGB.sig = "ipiii";
          function _SDL_MapRGBA(fmt, r, g, b, a) {
            fmt >>>= 0;
            SDL.checkPixelFormat(fmt);
            return r & 255 | (g & 255) << 8 | (b & 255) << 16 | (a & 255) << 24;
          }
          _SDL_MapRGBA.sig = "ipiiii";
          function _SDL_GetRGB(pixel, fmt, r, g, b) {
            fmt >>>= 0;
            r >>>= 0;
            g >>>= 0;
            b >>>= 0;
            SDL.checkPixelFormat(fmt);
            if (r) {
              HEAP8[r >>> 0 >>> 0] = pixel & 255;
            }
            if (g) {
              HEAP8[g >>> 0 >>> 0] = pixel >> 8 & 255;
            }
            if (b) {
              HEAP8[b >>> 0 >>> 0] = pixel >> 16 & 255;
            }
          }
          _SDL_GetRGB.sig = "vipppp";
          function _SDL_GetRGBA(pixel, fmt, r, g, b, a) {
            fmt >>>= 0;
            r >>>= 0;
            g >>>= 0;
            b >>>= 0;
            a >>>= 0;
            SDL.checkPixelFormat(fmt);
            if (r) {
              HEAP8[r >>> 0 >>> 0] = pixel & 255;
            }
            if (g) {
              HEAP8[g >>> 0 >>> 0] = pixel >> 8 & 255;
            }
            if (b) {
              HEAP8[b >>> 0 >>> 0] = pixel >> 16 & 255;
            }
            if (a) {
              HEAP8[a >>> 0 >>> 0] = pixel >> 24 & 255;
            }
          }
          _SDL_GetRGBA.sig = "vippppp";
          var _SDL_GetAppState = () => {
            var state = 0;
            if (Browser.pointerLock) {
              state |= 1;
            }
            if (document.hasFocus()) {
              state |= 2;
            }
            state |= 4;
            return state;
          };
          _SDL_GetAppState.sig = "i";
          var _SDL_WM_GrabInput = () => {
          };
          _SDL_WM_GrabInput.sig = "ii";
          function _SDL_WM_ToggleFullScreen(surf) {
            surf >>>= 0;
            if (Browser.exitFullscreen()) {
              return 1;
            }
            if (!SDL.canRequestFullscreen) {
              return 0;
            }
            SDL.isRequestingFullscreen = true;
            return 1;
          }
          _SDL_WM_ToggleFullScreen.sig = "ip";
          var _IMG_Init = (flags2) => flags2;
          _IMG_Init.sig = "ii";
          function _SDL_FreeRW(rwopsID) {
            rwopsID >>>= 0;
            SDL.rwops[rwopsID] = null;
            while (SDL.rwops.length > 0 && SDL.rwops[SDL.rwops.length - 1] === null) {
              SDL.rwops.pop();
            }
          }
          _SDL_FreeRW.sig = "vp";
          var _IMG_Load_RW = function(rwopsID, freeSrc) {
            rwopsID >>>= 0;
            try {
              var cleanup = () => {
                if (rwops && freeSrc)
                  _SDL_FreeRW(rwopsID);
              };
              var addCleanup = (func2) => {
                var old = cleanup;
                cleanup = () => {
                  old();
                  func2();
                };
              };
              var callStbImage = (func2, params) => withStackSave(() => {
                var x = stackAlloc(4);
                var y = stackAlloc(4);
                var comp = stackAlloc(4);
                var data3 = Module["_" + func2].apply(null, params.concat([x, y, comp, 0]));
                if (!data3)
                  return null;
                addCleanup(() => Module["_stbi_image_free"](data3));
                return {
                  rawData: true,
                  data: data3,
                  width: HEAP32[x >>> 2 >>> 0],
                  height: HEAP32[y >>> 2 >>> 0],
                  size: HEAP32[x >>> 2 >>> 0] * HEAP32[y >>> 2 >>> 0] * HEAP32[comp >>> 2 >>> 0],
                  bpp: HEAP32[comp >>> 2 >>> 0]
                };
              });
              var rwops = SDL.rwops[rwopsID];
              if (rwops === void 0) {
                return 0;
              }
              var raw;
              var filename = rwops.filename;
              if (filename === void 0) {
                warnOnce("Only file names that have been preloaded are supported for IMG_Load_RW. Consider using STB_IMAGE=1 if you want synchronous image decoding (see settings.js), or package files with --use-preload-plugins");
                return 0;
              }
              if (!raw) {
                filename = PATH_FS.resolve(filename);
                raw = preloadedImages[filename];
                if (!raw) {
                  if (raw === null)
                    err("Trying to reuse preloaded image, but freePreloadedMediaOnUse is set!");
                  warnOnce("Cannot find preloaded image " + filename);
                  warnOnce("Cannot find preloaded image " + filename + ". Consider using STB_IMAGE=1 if you want synchronous image decoding (see settings.js), or package files with --use-preload-plugins");
                  return 0;
                } else if (Module["freePreloadedMediaOnUse"]) {
                  preloadedImages[filename] = null;
                }
              }
              var surf = SDL.makeSurface(raw.width, raw.height, 0, false, "load:" + filename);
              var surfData = SDL.surfaces[surf];
              surfData.ctx.globalCompositeOperation = "copy";
              if (!raw.rawData) {
                surfData.ctx.drawImage(raw, 0, 0, raw.width, raw.height, 0, 0, raw.width, raw.height);
              } else {
                var imageData = surfData.ctx.getImageData(0, 0, surfData.width, surfData.height);
                if (raw.bpp == 4) {
                  imageData.data.set(HEAPU8.subarray(raw.data >>> 0, raw.data + raw.size >>> 0));
                } else if (raw.bpp == 3) {
                  var pixels = raw.size / 3;
                  var data2 = imageData.data;
                  var sourcePtr = raw.data;
                  var destPtr = 0;
                  for (var i2 = 0; i2 < pixels; i2++) {
                    data2[destPtr++] = HEAPU8[sourcePtr++ >>> 0 >>> 0];
                    data2[destPtr++] = HEAPU8[sourcePtr++ >>> 0 >>> 0];
                    data2[destPtr++] = HEAPU8[sourcePtr++ >>> 0 >>> 0];
                    data2[destPtr++] = 255;
                  }
                } else if (raw.bpp == 2) {
                  var pixels = raw.size;
                  var data2 = imageData.data;
                  var sourcePtr = raw.data;
                  var destPtr = 0;
                  for (var i2 = 0; i2 < pixels; i2++) {
                    var gray = HEAPU8[sourcePtr++ >>> 0 >>> 0];
                    var alpha = HEAPU8[sourcePtr++ >>> 0 >>> 0];
                    data2[destPtr++] = gray;
                    data2[destPtr++] = gray;
                    data2[destPtr++] = gray;
                    data2[destPtr++] = alpha;
                  }
                } else if (raw.bpp == 1) {
                  var pixels = raw.size;
                  var data2 = imageData.data;
                  var sourcePtr = raw.data;
                  var destPtr = 0;
                  for (var i2 = 0; i2 < pixels; i2++) {
                    var value = HEAPU8[sourcePtr++ >>> 0 >>> 0];
                    data2[destPtr++] = value;
                    data2[destPtr++] = value;
                    data2[destPtr++] = value;
                    data2[destPtr++] = 255;
                  }
                } else {
                  err(`cannot handle bpp ${raw.bpp}`);
                  return 0;
                }
                surfData.ctx.putImageData(imageData, 0, 0);
              }
              surfData.ctx.globalCompositeOperation = "source-over";
              _SDL_LockSurface(surf);
              surfData.locked--;
              if (SDL.GL) {
                surfData.canvas = surfData.ctx = null;
              }
              return surf;
            } finally {
              cleanup();
            }
          };
          _IMG_Load_RW.sig = "ppi";
          var _SDL_LoadBMP_RW = _IMG_Load_RW;
          _SDL_LoadBMP_RW.sig = "ppi";
          function _SDL_RWFromFile(_name, mode) {
            _name >>>= 0;
            mode >>>= 0;
            var id = SDL.rwops.length;
            var filename = UTF8ToString(_name);
            SDL.rwops.push({
              filename,
              mimetype: Browser.getMimetype(filename)
            });
            return id;
          }
          _SDL_RWFromFile.sig = "ppp";
          function _IMG_Load(filename) {
            filename >>>= 0;
            var rwops = _SDL_RWFromFile(filename, 0);
            var result = _IMG_Load_RW(rwops, 1);
            return result;
          }
          _IMG_Load.sig = "pp";
          var _IMG_Quit = () => out("IMG_Quit called (and ignored)");
          _IMG_Quit.sig = "v";
          function _SDL_OpenAudio(desired, obtained) {
            desired >>>= 0;
            obtained >>>= 0;
            try {
              SDL.audio = {
                freq: HEAPU32[desired >>> 2 >>> 0],
                format: HEAPU16[desired + 4 >>> 1 >>> 0],
                channels: HEAPU8[desired + 6 >>> 0 >>> 0],
                samples: HEAPU16[desired + 8 >>> 1 >>> 0],
                callback: HEAPU32[desired + 16 >>> 2 >>> 0],
                userdata: HEAPU32[desired + 20 >>> 2 >>> 0],
                paused: true,
                timer: null
              };
              if (SDL.audio.format == 8) {
                SDL.audio.silence = 128;
              } else if (SDL.audio.format == 32784) {
                SDL.audio.silence = 0;
              } else if (SDL.audio.format == 33056) {
                SDL.audio.silence = 0;
              } else {
                throw "Invalid SDL audio format " + SDL.audio.format + "!";
              }
              if (SDL.audio.freq <= 0) {
                throw "Unsupported sound frequency " + SDL.audio.freq + "!";
              } else if (SDL.audio.freq <= 22050) {
                SDL.audio.freq = 22050;
              } else if (SDL.audio.freq <= 32e3) {
                SDL.audio.freq = 32e3;
              } else if (SDL.audio.freq <= 44100) {
                SDL.audio.freq = 44100;
              } else if (SDL.audio.freq <= 48e3) {
                SDL.audio.freq = 48e3;
              } else if (SDL.audio.freq <= 96e3) {
                SDL.audio.freq = 96e3;
              } else {
                throw `Unsupported sound frequency ${SDL.audio.freq}!`;
              }
              if (SDL.audio.channels == 0) {
                SDL.audio.channels = 1;
              } else if (SDL.audio.channels < 0 || SDL.audio.channels > 32) {
                throw `Unsupported number of audio channels for SDL audio: ${SDL.audio.channels}!`;
              } else if (SDL.audio.channels != 1 && SDL.audio.channels != 2) {
                out(`Warning: Using untested number of audio channels ${SDL.audio.channels}`);
              }
              if (SDL.audio.samples < 128 || SDL.audio.samples > 524288) {
                throw `Unsupported audio callback buffer size ${SDL.audio.samples}!`;
              } else if ((SDL.audio.samples & SDL.audio.samples - 1) != 0) {
                throw `Audio callback buffer size ${SDL.audio.samples} must be a power-of-two!`;
              }
              var totalSamples = SDL.audio.samples * SDL.audio.channels;
              if (SDL.audio.format == 8) {
                SDL.audio.bytesPerSample = 1;
              } else if (SDL.audio.format == 32784) {
                SDL.audio.bytesPerSample = 2;
              } else if (SDL.audio.format == 33056) {
                SDL.audio.bytesPerSample = 4;
              } else {
                throw `Invalid SDL audio format ${SDL.audio.format}!`;
              }
              SDL.audio.bufferSize = totalSamples * SDL.audio.bytesPerSample;
              SDL.audio.bufferDurationSecs = SDL.audio.bufferSize / SDL.audio.bytesPerSample / SDL.audio.channels / SDL.audio.freq;
              SDL.audio.bufferingDelay = 50 / 1e3;
              SDL.audio.buffer = _malloc(SDL.audio.bufferSize);
              SDL.audio.numSimultaneouslyQueuedBuffers = Module["SDL_numSimultaneouslyQueuedBuffers"] || 5;
              SDL.audio.queueNewAudioData = () => {
                if (!SDL.audio)
                  return;
                for (var i2 = 0; i2 < SDL.audio.numSimultaneouslyQueuedBuffers; ++i2) {
                  var secsUntilNextPlayStart = SDL.audio.nextPlayTime - SDL.audioContext["currentTime"];
                  if (secsUntilNextPlayStart >= SDL.audio.bufferingDelay + SDL.audio.bufferDurationSecs * SDL.audio.numSimultaneouslyQueuedBuffers)
                    return;
                  getWasmTableEntry(SDL.audio.callback)(SDL.audio.userdata, SDL.audio.buffer, SDL.audio.bufferSize);
                  SDL.audio.pushAudio(SDL.audio.buffer, SDL.audio.bufferSize);
                }
              };
              SDL.audio.caller = () => {
                if (!SDL.audio)
                  return;
                --SDL.audio.numAudioTimersPending;
                SDL.audio.queueNewAudioData();
                var secsUntilNextPlayStart = SDL.audio.nextPlayTime - SDL.audioContext["currentTime"];
                var preemptBufferFeedSecs = SDL.audio.bufferDurationSecs / 2;
                if (SDL.audio.numAudioTimersPending < SDL.audio.numSimultaneouslyQueuedBuffers) {
                  ++SDL.audio.numAudioTimersPending;
                  SDL.audio.timer = safeSetTimeout(SDL.audio.caller, Math.max(0, 1e3 * (secsUntilNextPlayStart - preemptBufferFeedSecs)));
                  if (SDL.audio.numAudioTimersPending < SDL.audio.numSimultaneouslyQueuedBuffers) {
                    ++SDL.audio.numAudioTimersPending;
                    safeSetTimeout(SDL.audio.caller, 1);
                  }
                }
              };
              SDL.audio.audioOutput = new Audio();
              SDL.openAudioContext();
              if (!SDL.audioContext)
                throw "Web Audio API is not available!";
              autoResumeAudioContext(SDL.audioContext);
              SDL.audio.nextPlayTime = 0;
              SDL.audio.pushAudio = function(ptr2, sizeBytes) {
                try {
                  if (SDL.audio.paused)
                    return;
                  var sizeSamples = sizeBytes / SDL.audio.bytesPerSample;
                  var sizeSamplesPerChannel = sizeSamples / SDL.audio.channels;
                  if (sizeSamplesPerChannel != SDL.audio.samples) {
                    throw "Received mismatching audio buffer size!";
                  }
                  var source = SDL.audioContext["createBufferSource"]();
                  var soundBuffer = SDL.audioContext["createBuffer"](SDL.audio.channels, sizeSamplesPerChannel, SDL.audio.freq);
                  source["connect"](SDL.audioContext["destination"]);
                  SDL.fillWebAudioBufferFromHeap(ptr2, sizeSamplesPerChannel, soundBuffer);
                  source["buffer"] = soundBuffer;
                  var curtime = SDL.audioContext["currentTime"];
                  var playtime = Math.max(curtime + SDL.audio.bufferingDelay, SDL.audio.nextPlayTime);
                  if (typeof source["start"] != "undefined") {
                    source["start"](playtime);
                  } else if (typeof source["noteOn"] != "undefined") {
                    source["noteOn"](playtime);
                  }
                  SDL.audio.nextPlayTime = playtime + SDL.audio.bufferDurationSecs;
                } catch (e) {
                  err(`Web Audio API error playing back audio: ${e.toString()}`);
                }
              };
              if (obtained) {
                HEAP32[obtained >>> 2 >>> 0] = SDL.audio.freq;
                HEAP16[obtained + 4 >>> 1 >>> 0] = SDL.audio.format;
                HEAP8[obtained + 6 >>> 0 >>> 0] = SDL.audio.channels;
                HEAP8[obtained + 7 >>> 0 >>> 0] = SDL.audio.silence;
                HEAP16[obtained + 8 >>> 1 >>> 0] = SDL.audio.samples;
                HEAPU32[obtained + 16 >>> 2 >>> 0] = SDL.audio.callback;
                HEAPU32[obtained + 20 >>> 2 >>> 0] = SDL.audio.userdata;
              }
              SDL.allocateChannels(32);
            } catch (e) {
              err(`Initializing SDL audio threw an exception: "${e.toString()}"! Continuing without audio`);
              SDL.audio = null;
              SDL.allocateChannels(0);
              if (obtained) {
                HEAP32[obtained >>> 2 >>> 0] = 0;
                HEAP16[obtained + 4 >>> 1 >>> 0] = 0;
                HEAP8[obtained + 6 >>> 0 >>> 0] = 0;
                HEAP8[obtained + 7 >>> 0 >>> 0] = 0;
                HEAP16[obtained + 8 >>> 1 >>> 0] = 0;
                HEAPU32[obtained + 16 >>> 2 >>> 0] = 0;
                HEAPU32[obtained + 20 >>> 2 >>> 0] = 0;
              }
            }
            if (!SDL.audio) {
              return -1;
            }
            return 0;
          }
          _SDL_OpenAudio.sig = "ipp";
          var _SDL_PauseAudio = (pauseOn) => {
            if (!SDL.audio) {
              return;
            }
            if (pauseOn) {
              if (SDL.audio.timer !== void 0) {
                clearTimeout(SDL.audio.timer);
                SDL.audio.numAudioTimersPending = 0;
                SDL.audio.timer = void 0;
              }
            } else if (!SDL.audio.timer) {
              SDL.audio.numAudioTimersPending = 1;
              SDL.audio.timer = safeSetTimeout(SDL.audio.caller, 1);
            }
            SDL.audio.paused = pauseOn;
          };
          _SDL_PauseAudio.sig = "vi";
          var _SDL_CloseAudio = () => {
            if (SDL.audio) {
              if (SDL.audio.callbackRemover) {
                SDL.audio.callbackRemover();
                SDL.audio.callbackRemover = null;
              }
              _SDL_PauseAudio(1);
              _free(SDL.audio.buffer);
              SDL.audio = null;
              SDL.allocateChannels(0);
            }
          };
          _SDL_CloseAudio.sig = "v";
          var _SDL_LockAudio = () => {
          };
          _SDL_LockAudio.sig = "v";
          var _SDL_UnlockAudio = () => {
          };
          _SDL_UnlockAudio.sig = "v";
          function _SDL_CreateMutex() {
            return 0;
          }
          _SDL_CreateMutex.sig = "p";
          function _SDL_mutexP(mutex) {
            mutex >>>= 0;
            return 0;
          }
          _SDL_mutexP.sig = "ip";
          function _SDL_mutexV(mutex) {
            mutex >>>= 0;
            return 0;
          }
          _SDL_mutexV.sig = "ip";
          function _SDL_DestroyMutex(mutex) {
            mutex >>>= 0;
          }
          _SDL_DestroyMutex.sig = "vp";
          function _SDL_CreateCond() {
            return 0;
          }
          _SDL_CreateCond.sig = "p";
          function _SDL_CondSignal(cond) {
            cond >>>= 0;
          }
          _SDL_CondSignal.sig = "ip";
          function _SDL_CondWait(cond, mutex) {
            cond >>>= 0;
            mutex >>>= 0;
          }
          _SDL_CondWait.sig = "ipp";
          function _SDL_DestroyCond(cond) {
            cond >>>= 0;
          }
          _SDL_DestroyCond.sig = "vp";
          var _SDL_StartTextInput = () => {
            SDL.textInput = true;
          };
          _SDL_StartTextInput.sig = "v";
          var _SDL_StopTextInput = () => {
            SDL.textInput = false;
          };
          _SDL_StopTextInput.sig = "v";
          var _Mix_Init = (flags2) => {
            if (!flags2)
              return 0;
            return 8;
          };
          _Mix_Init.sig = "ii";
          var _Mix_Quit = () => {
          };
          _Mix_Quit.sig = "v";
          var _Mix_OpenAudio = (frequency, format, channels, chunksize) => {
            SDL.openAudioContext();
            autoResumeAudioContext(SDL.audioContext);
            SDL.allocateChannels(32);
            SDL.mixerFrequency = frequency;
            SDL.mixerFormat = format;
            SDL.mixerNumChannels = channels;
            SDL.mixerChunkSize = chunksize;
            return 0;
          };
          _Mix_OpenAudio.sig = "iiiii";
          var _Mix_CloseAudio = _SDL_CloseAudio;
          _Mix_CloseAudio.sig = "v";
          var _Mix_AllocateChannels = (num) => {
            SDL.allocateChannels(num);
            return num;
          };
          _Mix_AllocateChannels.sig = "ii";
          function _Mix_ChannelFinished(func2) {
            func2 >>>= 0;
            SDL.channelFinished = func2;
          }
          _Mix_ChannelFinished.sig = "vp";
          var _Mix_Volume = (channel, volume) => {
            if (channel == -1) {
              for (var i2 = 0; i2 < SDL.numChannels - 1; i2++) {
                _Mix_Volume(i2, volume);
              }
              return _Mix_Volume(SDL.numChannels - 1, volume);
            }
            return SDL.setGetVolume(SDL.channels[channel], volume);
          };
          _Mix_Volume.sig = "iii";
          var _Mix_SetPanning = (channel, left, right) => {
            left /= 255;
            right /= 255;
            SDL.setPannerPosition(SDL.channels[channel], right - left, 0, 0.1);
            return 1;
          };
          _Mix_SetPanning.sig = "iiii";
          function _Mix_LoadWAV_RW(rwopsID, freesrc) {
            rwopsID >>>= 0;
            var rwops = SDL.rwops[rwopsID];
            if (rwops === void 0)
              return 0;
            var filename = "";
            var audio;
            var webAudio;
            var bytes;
            if (rwops.filename !== void 0) {
              filename = PATH_FS.resolve(rwops.filename);
              var raw = preloadedAudios[filename];
              if (!raw) {
                if (raw === null)
                  err("Trying to reuse preloaded audio, but freePreloadedMediaOnUse is set!");
                if (!Module.noAudioDecoding)
                  warnOnce("Cannot find preloaded audio " + filename);
                try {
                  bytes = FS.readFile(filename);
                } catch (e) {
                  err(`Couldn't find file for: ${filename}`);
                  return 0;
                }
              }
              if (Module["freePreloadedMediaOnUse"]) {
                preloadedAudios[filename] = null;
              }
              audio = raw;
            } else if (rwops.bytes !== void 0) {
              if (SDL.webAudioAvailable())
                bytes = HEAPU8.buffer.slice(rwops.bytes, rwops.bytes + rwops.count);
              else
                bytes = HEAPU8.subarray(rwops.bytes >>> 0, rwops.bytes + rwops.count >>> 0);
            } else {
              return 0;
            }
            var arrayBuffer = bytes ? bytes.buffer || bytes : bytes;
            var canPlayWithWebAudio = Module["SDL_canPlayWithWebAudio"] === void 0 || Module["SDL_canPlayWithWebAudio"](filename, arrayBuffer);
            if (bytes !== void 0 && SDL.webAudioAvailable() && canPlayWithWebAudio) {
              audio = void 0;
              webAudio = {};
              webAudio.onDecodeComplete = [];
              var onDecodeComplete = (data2) => {
                webAudio.decodedBuffer = data2;
                webAudio.onDecodeComplete.forEach((e) => e());
                webAudio.onDecodeComplete = void 0;
              };
              SDL.audioContext["decodeAudioData"](arrayBuffer, onDecodeComplete);
            } else if (audio === void 0 && bytes) {
              var blob = new Blob([bytes], {
                type: rwops.mimetype
              });
              var url2 = URL.createObjectURL(blob);
              audio = new Audio();
              audio.src = url2;
              audio.mozAudioChannelType = "content";
            }
            var id = SDL.audios.length;
            SDL.audios.push({
              source: filename,
              audio,
              webAudio
            });
            return id;
          }
          _Mix_LoadWAV_RW.sig = "ppi";
          function _Mix_LoadWAV(filename) {
            filename >>>= 0;
            var rwops = _SDL_RWFromFile(filename, 0);
            var result = _Mix_LoadWAV_RW(rwops, 0);
            _SDL_FreeRW(rwops);
            return result;
          }
          _Mix_LoadWAV.sig = "pp";
          function _Mix_QuickLoad_RAW(mem, len2) {
            mem >>>= 0;
            var audio;
            var webAudio;
            var numSamples = len2 >> 1;
            var buffer = new Float32Array(numSamples);
            for (var i2 = 0; i2 < numSamples; ++i2) {
              buffer[i2] = HEAP16[mem + i2 * 2 >>> 1 >>> 0] / 32768;
            }
            if (SDL.webAudioAvailable()) {
              webAudio = {};
              webAudio.decodedBuffer = buffer;
            } else {
              audio = new Audio();
              audio.mozAudioChannelType = "content";
              audio.numChannels = SDL.mixerNumChannels;
              audio.frequency = SDL.mixerFrequency;
            }
            var id = SDL.audios.length;
            SDL.audios.push({
              source: "",
              audio,
              webAudio,
              buffer
            });
            return id;
          }
          _Mix_QuickLoad_RAW.sig = "ppi";
          function _Mix_FreeChunk(id) {
            id >>>= 0;
            SDL.audios[id] = null;
          }
          _Mix_FreeChunk.sig = "vp";
          var _Mix_ReserveChannels = (num) => {
            SDL.channelMinimumNumber = num;
          };
          _Mix_ReserveChannels.sig = "ii";
          function _Mix_PlayChannelTimed(channel, id, loops, ticks) {
            id >>>= 0;
            assert(ticks == -1);
            var info2 = SDL.audios[id];
            if (!info2)
              return -1;
            if (!info2.audio && !info2.webAudio)
              return -1;
            if (channel == -1) {
              for (var i2 = SDL.channelMinimumNumber; i2 < SDL.numChannels; i2++) {
                if (!SDL.channels[i2].audio) {
                  channel = i2;
                  break;
                }
              }
              if (channel == -1) {
                err(`All ${SDL.numChannels}  channels in use!`);
                return -1;
              }
            }
            var channelInfo = SDL.channels[channel];
            var audio;
            if (info2.webAudio) {
              audio = {};
              audio.resource = info2;
              audio.paused = false;
              audio.currentPosition = 0;
              audio.play = function() {
                SDL.playWebAudio(this);
              };
              audio.pause = function() {
                SDL.pauseWebAudio(this);
              };
            } else {
              audio = info2.audio.cloneNode(true);
              audio.numChannels = info2.audio.numChannels;
              audio.frequency = info2.audio.frequency;
            }
            audio["onended"] = function() {
              if (channelInfo.audio == this) {
                channelInfo.audio.paused = true;
                channelInfo.audio = null;
              }
              if (SDL.channelFinished)
                getWasmTableEntry(SDL.channelFinished)(channel);
            };
            channelInfo.audio = audio;
            audio.loop = loops != 0;
            audio.volume = channelInfo.volume;
            audio.play();
            return channel;
          }
          _Mix_PlayChannelTimed.sig = "iipii";
          var _Mix_FadingChannel = (channel) => 0;
          _Mix_FadingChannel.sig = "ii";
          var _Mix_HaltChannel = (channel) => {
            function halt(channel2) {
              var info2 = SDL.channels[channel2];
              if (info2.audio) {
                info2.audio.pause();
                info2.audio = null;
              }
              if (SDL.channelFinished) {
                getWasmTableEntry(SDL.channelFinished)(channel2);
              }
            }
            if (channel != -1) {
              halt(channel);
            } else {
              for (var i2 = 0; i2 < SDL.channels.length; ++i2)
                halt(i2);
            }
            return 0;
          };
          _Mix_HaltChannel.sig = "ii";
          var _Mix_HaltMusic = () => {
            var audio = SDL.music.audio;
            if (audio) {
              audio.src = audio.src;
              audio.currentPosition = 0;
              audio.pause();
            }
            SDL.music.audio = null;
            if (SDL.hookMusicFinished) {
              getWasmTableEntry(SDL.hookMusicFinished)();
            }
            return 0;
          };
          _Mix_HaltMusic.sig = "i";
          function _Mix_HookMusicFinished(func2) {
            func2 >>>= 0;
            SDL.hookMusicFinished = func2;
            if (SDL.music.audio) {
              SDL.music.audio["onended"] = _Mix_HaltMusic;
            }
          }
          _Mix_HookMusicFinished.sig = "vp";
          var _Mix_VolumeMusic = (volume) => SDL.setGetVolume(SDL.music, volume);
          _Mix_VolumeMusic.sig = "ii";
          var _Mix_LoadMUS_RW = _Mix_LoadWAV_RW;
          _Mix_LoadMUS_RW.sig = "pp";
          function _Mix_LoadMUS(filename) {
            filename >>>= 0;
            var rwops = _SDL_RWFromFile(filename, 0);
            var result = _Mix_LoadMUS_RW(rwops, 0);
            _SDL_FreeRW(rwops);
            return result;
          }
          _Mix_LoadMUS.sig = "pp";
          var _Mix_FreeMusic = _Mix_FreeChunk;
          _Mix_FreeMusic.sig = "vp";
          function _Mix_PlayMusic(id, loops) {
            id >>>= 0;
            if (SDL.music.audio) {
              if (!SDL.music.audio.paused)
                err(`Music is already playing. ${SDL.music.source}`);
              SDL.music.audio.pause();
            }
            var info2 = SDL.audios[id];
            var audio;
            if (info2.webAudio) {
              audio = {};
              audio.resource = info2;
              audio.paused = false;
              audio.currentPosition = 0;
              audio.play = function() {
                SDL.playWebAudio(this);
              };
              audio.pause = function() {
                SDL.pauseWebAudio(this);
              };
            } else if (info2.audio) {
              audio = info2.audio;
            }
            audio["onended"] = function() {
              if (SDL.music.audio == this)
                _Mix_HaltMusic();
            };
            audio.loop = loops != 0 && loops != 1;
            audio.volume = SDL.music.volume;
            SDL.music.audio = audio;
            audio.play();
            return 0;
          }
          _Mix_PlayMusic.sig = "ipi";
          var _Mix_PauseMusic = () => {
            var audio = SDL.music.audio;
            audio?.pause();
          };
          _Mix_PauseMusic.sig = "v";
          var _Mix_ResumeMusic = () => {
            var audio = SDL.music.audio;
            audio?.play();
          };
          _Mix_ResumeMusic.sig = "v";
          var _Mix_FadeInMusicPos = _Mix_PlayMusic;
          _Mix_FadeInMusicPos.sig = "ipiid";
          var _Mix_FadeOutMusic = _Mix_HaltMusic;
          _Mix_FadeOutMusic.sig = "ii";
          var _Mix_PlayingMusic = () => SDL.music.audio && !SDL.music.audio.paused ? 1 : 0;
          _Mix_PlayingMusic.sig = "i";
          var _Mix_Playing = (channel) => {
            if (channel === -1) {
              var count = 0;
              for (var i2 = 0; i2 < SDL.channels.length; i2++) {
                count += _Mix_Playing(i2);
              }
              return count;
            }
            var info2 = SDL.channels[channel];
            if (info2?.audio && !info2.audio.paused) {
              return 1;
            }
            return 0;
          };
          _Mix_Playing.sig = "ii";
          var _Mix_Pause = (channel) => {
            if (channel === -1) {
              for (var i2 = 0; i2 < SDL.channels.length; i2++) {
                _Mix_Pause(i2);
              }
              return;
            }
            var info2 = SDL.channels[channel];
            if (info2?.audio) {
              info2.audio.pause();
            } else {
            }
          };
          _Mix_Pause.sig = "vi";
          var _Mix_Paused = (channel) => {
            if (channel === -1) {
              var pausedCount = 0;
              for (var i2 = 0; i2 < SDL.channels.length; i2++) {
                pausedCount += _Mix_Paused(i2);
              }
              return pausedCount;
            }
            var info2 = SDL.channels[channel];
            if (info2?.audio?.paused) {
              return 1;
            }
            return 0;
          };
          _Mix_Paused.sig = "ii";
          var _Mix_PausedMusic = () => SDL.music.audio?.paused ? 1 : 0;
          _Mix_PausedMusic.sig = "i";
          var _Mix_Resume = (channel) => {
            if (channel === -1) {
              for (var i2 = 0; i2 < SDL.channels.length; i2++) {
                _Mix_Resume(i2);
              }
              return;
            }
            var info2 = SDL.channels[channel];
            if (info2?.audio)
              info2.audio.play();
          };
          _Mix_Resume.sig = "vi";
          var _TTF_Init = () => {
            try {
              var offscreenCanvas = new OffscreenCanvas(0, 0);
              SDL.ttfContext = offscreenCanvas.getContext("2d");
              if (typeof SDL.ttfContext.measureText != "function") {
                throw "bad context";
              }
            } catch (ex) {
              var canvas = document.createElement("canvas");
              SDL.ttfContext = canvas.getContext("2d");
            }
            return 0;
          };
          _TTF_Init.sig = "i";
          function _TTF_OpenFont(name2, size) {
            name2 >>>= 0;
            name2 = PATH.normalize(UTF8ToString(name2));
            var id = SDL.fonts.length;
            SDL.fonts.push({
              name: name2,
              size
            });
            return id;
          }
          _TTF_OpenFont.sig = "ppi";
          function _TTF_CloseFont(font) {
            font >>>= 0;
            SDL.fonts[font] = null;
          }
          _TTF_CloseFont.sig = "vp";
          function _TTF_RenderText_Solid(font, text, color) {
            font >>>= 0;
            text >>>= 0;
            color >>>= 0;
            text = UTF8ToString(text) || " ";
            var fontData = SDL.fonts[font];
            var w = SDL.estimateTextWidth(fontData, text);
            var h = fontData.size;
            color = SDL.loadColorToCSSRGB(color);
            var fontString = SDL.makeFontString(h, fontData.name);
            var surf = SDL.makeSurface(w, h, 0, false, "text:" + text);
            var surfData = SDL.surfaces[surf];
            surfData.ctx.save();
            surfData.ctx.fillStyle = color;
            surfData.ctx.font = fontString;
            surfData.ctx.textBaseline = "bottom";
            surfData.ctx.fillText(text, 0, h | 0);
            surfData.ctx.restore();
            return surf;
          }
          _TTF_RenderText_Solid.sig = "pppp";
          var _TTF_RenderText_Blended = _TTF_RenderText_Solid;
          _TTF_RenderText_Blended.sig = "pppp";
          var _TTF_RenderText_Shaded = _TTF_RenderText_Solid;
          _TTF_RenderText_Shaded.sig = "ppppp";
          var _TTF_RenderUTF8_Solid = _TTF_RenderText_Solid;
          _TTF_RenderUTF8_Solid.sig = "pppp";
          function _TTF_SizeText(font, text, w, h) {
            font >>>= 0;
            text >>>= 0;
            w >>>= 0;
            h >>>= 0;
            var fontData = SDL.fonts[font];
            if (w) {
              HEAP32[w >>> 2 >>> 0] = SDL.estimateTextWidth(fontData, UTF8ToString(text));
            }
            if (h) {
              HEAP32[h >>> 2 >>> 0] = fontData.size;
            }
            return 0;
          }
          _TTF_SizeText.sig = "ipppp";
          var _TTF_SizeUTF8 = _TTF_SizeText;
          _TTF_SizeUTF8.sig = "ipppp";
          function _TTF_GlyphMetrics(font, ch, minx, maxx, miny, maxy, advance) {
            font >>>= 0;
            minx >>>= 0;
            maxx >>>= 0;
            miny >>>= 0;
            maxy >>>= 0;
            advance >>>= 0;
            var fontData = SDL.fonts[font];
            var width = SDL.estimateTextWidth(fontData, String.fromCharCode(ch));
            if (advance) {
              HEAP32[advance >>> 2 >>> 0] = width;
            }
            if (minx) {
              HEAP32[minx >>> 2 >>> 0] = 0;
            }
            if (maxx) {
              HEAP32[maxx >>> 2 >>> 0] = width;
            }
            if (miny) {
              HEAP32[miny >>> 2 >>> 0] = 0;
            }
            if (maxy) {
              HEAP32[maxy >>> 2 >>> 0] = fontData.size;
            }
          }
          _TTF_GlyphMetrics.sig = "ipippppp";
          function _TTF_FontAscent(font) {
            font >>>= 0;
            var fontData = SDL.fonts[font];
            return fontData.size * 0.98 | 0;
          }
          _TTF_FontAscent.sig = "ip";
          function _TTF_FontDescent(font) {
            font >>>= 0;
            var fontData = SDL.fonts[font];
            return fontData.size * 0.02 | 0;
          }
          _TTF_FontDescent.sig = "ip";
          function _TTF_FontHeight(font) {
            font >>>= 0;
            var fontData = SDL.fonts[font];
            return fontData.size;
          }
          _TTF_FontHeight.sig = "ip";
          var _TTF_FontLineSkip = _TTF_FontHeight;
          _TTF_FontLineSkip.sig = "ip";
          var _TTF_Quit = () => out("TTF_Quit called (and ignored)");
          _TTF_Quit.sig = "v";
          var SDL_gfx = {
            drawRectangle: (surf, x1, y1, x2, y2, action, cssColor) => {
              x1 = x1 << 16 >> 16;
              y1 = y1 << 16 >> 16;
              x2 = x2 << 16 >> 16;
              y2 = y2 << 16 >> 16;
              var surfData = SDL.surfaces[surf];
              assert(!surfData.locked);
              var x = x1 < x2 ? x1 : x2;
              var y = y1 < y2 ? y1 : y2;
              var w = Math.abs(x2 - x1);
              var h = Math.abs(y2 - y1);
              surfData.ctx.save();
              surfData.ctx[action + "Style"] = cssColor;
              surfData.ctx[action + "Rect"](x, y, w, h);
              surfData.ctx.restore();
            },
            drawLine: (surf, x1, y1, x2, y2, cssColor) => {
              x1 = x1 << 16 >> 16;
              y1 = y1 << 16 >> 16;
              x2 = x2 << 16 >> 16;
              y2 = y2 << 16 >> 16;
              var surfData = SDL.surfaces[surf];
              assert(!surfData.locked);
              surfData.ctx.save();
              surfData.ctx.strokeStyle = cssColor;
              surfData.ctx.beginPath();
              surfData.ctx.moveTo(x1, y1);
              surfData.ctx.lineTo(x2, y2);
              surfData.ctx.stroke();
              surfData.ctx.restore();
            },
            drawEllipse: (surf, x, y, rx, ry, action, cssColor) => {
              x = x << 16 >> 16;
              y = y << 16 >> 16;
              rx = rx << 16 >> 16;
              ry = ry << 16 >> 16;
              var surfData = SDL.surfaces[surf];
              assert(!surfData.locked);
              surfData.ctx.save();
              surfData.ctx.beginPath();
              surfData.ctx.translate(x, y);
              surfData.ctx.scale(rx, ry);
              surfData.ctx.arc(0, 0, 1, 0, 2 * Math.PI);
              surfData.ctx.restore();
              surfData.ctx.save();
              surfData.ctx[action + "Style"] = cssColor;
              surfData.ctx[action]();
              surfData.ctx.restore();
            },
            translateColorToCSSRGBA: (rgba) => `rgba(${rgba >>> 24},${rgba >> 16 & 255},${rgba >> 8 & 255},${rgba & 255})`
          };
          function _boxColor(surf, x1, y1, x2, y2, color) {
            surf >>>= 0;
            return SDL_gfx.drawRectangle(surf, x1, y1, x2, y2, "fill", SDL_gfx.translateColorToCSSRGBA(color));
          }
          _boxColor.sig = "ipiiiii";
          function _boxRGBA(surf, x1, y1, x2, y2, r, g, b, a) {
            surf >>>= 0;
            return SDL_gfx.drawRectangle(surf, x1, y1, x2, y2, "fill", SDL.translateRGBAToCSSRGBA(r, g, b, a));
          }
          _boxRGBA.sig = "ipiiiiiiii";
          function _rectangleColor(surf, x1, y1, x2, y2, color) {
            surf >>>= 0;
            return SDL_gfx.drawRectangle(surf, x1, y1, x2, y2, "stroke", SDL_gfx.translateColorToCSSRGBA(color));
          }
          _rectangleColor.sig = "ipiiiii";
          function _rectangleRGBA(surf, x1, y1, x2, y2, r, g, b, a) {
            surf >>>= 0;
            return SDL_gfx.drawRectangle(surf, x1, y1, x2, y2, "stroke", SDL.translateRGBAToCSSRGBA(r, g, b, a));
          }
          _rectangleRGBA.sig = "ipiiiiiiii";
          function _ellipseColor(surf, x, y, rx, ry, color) {
            surf >>>= 0;
            return SDL_gfx.drawEllipse(surf, x, y, rx, ry, "stroke", SDL_gfx.translateColorToCSSRGBA(color));
          }
          _ellipseColor.sig = "ipiiiii";
          function _ellipseRGBA(surf, x, y, rx, ry, r, g, b, a) {
            surf >>>= 0;
            return SDL_gfx.drawEllipse(surf, x, y, rx, ry, "stroke", SDL.translateRGBAToCSSRGBA(r, g, b, a));
          }
          _ellipseRGBA.sig = "ipiiiiiiii";
          function _filledEllipseColor(surf, x, y, rx, ry, color) {
            surf >>>= 0;
            return SDL_gfx.drawEllipse(surf, x, y, rx, ry, "fill", SDL_gfx.translateColorToCSSRGBA(color));
          }
          _filledEllipseColor.sig = "ipiiiii";
          function _filledEllipseRGBA(surf, x, y, rx, ry, r, g, b, a) {
            surf >>>= 0;
            return SDL_gfx.drawEllipse(surf, x, y, rx, ry, "fill", SDL.translateRGBAToCSSRGBA(r, g, b, a));
          }
          _filledEllipseRGBA.sig = "ipiiiiiiii";
          function _lineColor(surf, x1, y1, x2, y2, color) {
            surf >>>= 0;
            return SDL_gfx.drawLine(surf, x1, y1, x2, y2, SDL_gfx.translateColorToCSSRGBA(color));
          }
          _lineColor.sig = "ipiiiii";
          function _lineRGBA(surf, x1, y1, x2, y2, r, g, b, a) {
            surf >>>= 0;
            return SDL_gfx.drawLine(surf, x1, y1, x2, y2, SDL.translateRGBAToCSSRGBA(r, g, b, a));
          }
          _lineRGBA.sig = "ipiiiiiiii";
          function _pixelRGBA(surf, x1, y1, r, g, b, a) {
            surf >>>= 0;
            return _boxRGBA(surf, x1, y1, x1, y1, r, g, b, a);
          }
          _pixelRGBA.sig = "ipiiiiii";
          var _SDL_GL_SetAttribute = (attr, value) => {
            if (!(attr in SDL.glAttributes)) {
              abort("Unknown SDL GL attribute (" + attr + "). Please check if your SDL version is supported.");
            }
            SDL.glAttributes[attr] = value;
          };
          _SDL_GL_SetAttribute.sig = "iii";
          function _SDL_GL_GetAttribute(attr, value) {
            value >>>= 0;
            if (!(attr in SDL.glAttributes)) {
              abort("Unknown SDL GL attribute (" + attr + "). Please check if your SDL version is supported.");
            }
            if (value)
              HEAP32[value >>> 2 >>> 0] = SDL.glAttributes[attr];
            return 0;
          }
          _SDL_GL_GetAttribute.sig = "iip";
          var _SDL_GL_SwapBuffers = () => {
            Browser.doSwapBuffers?.();
          };
          _SDL_GL_SwapBuffers.sig = "v";
          function _SDL_GL_ExtensionSupported(extension) {
            extension >>>= 0;
            return Module.ctx.getExtension(extension) | 0;
          }
          _SDL_GL_ExtensionSupported.sig = "ip";
          function _SDL_DestroyWindow(window2) {
            window2 >>>= 0;
          }
          _SDL_DestroyWindow.sig = "vp";
          function _SDL_DestroyRenderer(renderer) {
            renderer >>>= 0;
          }
          _SDL_DestroyRenderer.sig = "vp";
          function _SDL_GetWindowFlags(window2) {
            window2 >>>= 0;
            if (Browser.isFullscreen) {
              return 1;
            }
            return 0;
          }
          _SDL_GetWindowFlags.sig = "ip";
          function _SDL_GL_SwapWindow(window2) {
            window2 >>>= 0;
          }
          _SDL_GL_SwapWindow.sig = "vp";
          function _SDL_GL_MakeCurrent(window2, context) {
            window2 >>>= 0;
            context >>>= 0;
          }
          _SDL_GL_MakeCurrent.sig = "ipp";
          function _SDL_GL_DeleteContext(context) {
            context >>>= 0;
          }
          _SDL_GL_DeleteContext.sig = "vp";
          var _SDL_GL_GetSwapInterval = () => {
            if (Browser.mainLoop.timingMode == 1)
              return Browser.mainLoop.timingValue;
            else
              return 0;
          };
          _SDL_GL_GetSwapInterval.sig = "i";
          var _SDL_GL_SetSwapInterval = (state) => {
            _emscripten_set_main_loop_timing(1, state);
          };
          _SDL_GL_SetSwapInterval.sig = "ii";
          function _SDL_SetWindowTitle(window2, title) {
            window2 >>>= 0;
            title >>>= 0;
            if (title)
              document.title = UTF8ToString(title);
          }
          _SDL_SetWindowTitle.sig = "vpp";
          function _SDL_GetWindowSize(window2, width, height) {
            window2 >>>= 0;
            width >>>= 0;
            height >>>= 0;
            var w = Module["canvas"].width;
            var h = Module["canvas"].height;
            if (width)
              HEAP32[width >>> 2 >>> 0] = w;
            if (height)
              HEAP32[height >>> 2 >>> 0] = h;
          }
          _SDL_GetWindowSize.sig = "vppp";
          function _SDL_LogSetOutputFunction(callback, userdata) {
            callback >>>= 0;
            userdata >>>= 0;
          }
          _SDL_LogSetOutputFunction.sig = "vpp";
          function _SDL_SetWindowFullscreen(window2, fullscreen) {
            window2 >>>= 0;
            if (Browser.isFullscreen) {
              Module["canvas"].exitFullscreen();
              return 1;
            }
            return 0;
          }
          _SDL_SetWindowFullscreen.sig = "ipi";
          var _SDL_ClearError = () => {
          };
          _SDL_ClearError.sig = "v";
          var _SDL_SetGamma = (r, g, b) => -1;
          _SDL_SetGamma.sig = "ifff";
          function _SDL_SetGammaRamp(redTable, greenTable, blueTable) {
            redTable >>>= 0;
            greenTable >>>= 0;
            blueTable >>>= 0;
            return -1;
          }
          _SDL_SetGammaRamp.sig = "ippp";
          var _SDL_NumJoysticks = () => {
            var count = 0;
            var gamepads = SDL.getGamepads();
            for (var i2 = 0; i2 < gamepads.length; i2++) {
              if (gamepads[i2] !== void 0)
                count++;
            }
            return count;
          };
          _SDL_NumJoysticks.sig = "i";
          function _SDL_JoystickName(deviceIndex) {
            var gamepad = SDL.getGamepad(deviceIndex);
            if (gamepad) {
              var name2 = gamepad.id;
              if (SDL.joystickNamePool.hasOwnProperty(name2)) {
                return SDL.joystickNamePool[name2];
              }
              return SDL.joystickNamePool[name2] = stringToNewUTF8(name2);
            }
            return 0;
          }
          _SDL_JoystickName.sig = "pi";
          function _SDL_JoystickOpen(deviceIndex) {
            var gamepad = SDL.getGamepad(deviceIndex);
            if (gamepad) {
              var joystick = deviceIndex + 1;
              SDL.recordJoystickState(joystick, gamepad);
              return joystick;
            }
            return 0;
          }
          _SDL_JoystickOpen.sig = "pi";
          var _SDL_JoystickOpened = (deviceIndex) => SDL.lastJoystickState.hasOwnProperty(deviceIndex + 1) ? 1 : 0;
          _SDL_JoystickOpened.sig = "ii";
          function _SDL_JoystickIndex(joystick) {
            joystick >>>= 0;
            return joystick - 1;
          }
          _SDL_JoystickIndex.sig = "ip";
          function _SDL_JoystickNumAxes(joystick) {
            joystick >>>= 0;
            var gamepad = SDL.getGamepad(joystick - 1);
            if (gamepad) {
              return gamepad.axes.length;
            }
            return 0;
          }
          _SDL_JoystickNumAxes.sig = "ip";
          function _SDL_JoystickNumBalls(joystick) {
            joystick >>>= 0;
            return 0;
          }
          _SDL_JoystickNumBalls.sig = "ip";
          function _SDL_JoystickNumHats(joystick) {
            joystick >>>= 0;
            return 0;
          }
          _SDL_JoystickNumHats.sig = "ip";
          function _SDL_JoystickNumButtons(joystick) {
            joystick >>>= 0;
            var gamepad = SDL.getGamepad(joystick - 1);
            if (gamepad) {
              return gamepad.buttons.length;
            }
            return 0;
          }
          _SDL_JoystickNumButtons.sig = "ip";
          var _SDL_JoystickUpdate = () => SDL.queryJoysticks();
          _SDL_JoystickUpdate.sig = "v";
          var _SDL_JoystickEventState = (state) => {
            if (state < 0) {
              return SDL.joystickEventState;
            }
            return SDL.joystickEventState = state;
          };
          _SDL_JoystickEventState.sig = "ii";
          function _SDL_JoystickGetAxis(joystick, axis) {
            joystick >>>= 0;
            var gamepad = SDL.getGamepad(joystick - 1);
            if (gamepad && gamepad.axes.length > axis) {
              return SDL.joystickAxisValueConversion(gamepad.axes[axis]);
            }
            return 0;
          }
          _SDL_JoystickGetAxis.sig = "ipi";
          function _SDL_JoystickGetHat(joystick, hat) {
            joystick >>>= 0;
            return 0;
          }
          _SDL_JoystickGetHat.sig = "ipi";
          function _SDL_JoystickGetBall(joystick, ball, dxptr, dyptr) {
            joystick >>>= 0;
            dxptr >>>= 0;
            dyptr >>>= 0;
            return -1;
          }
          _SDL_JoystickGetBall.sig = "ipipp";
          function _SDL_JoystickGetButton(joystick, button) {
            joystick >>>= 0;
            var gamepad = SDL.getGamepad(joystick - 1);
            if (gamepad && gamepad.buttons.length > button) {
              return SDL.getJoystickButtonState(gamepad.buttons[button]) ? 1 : 0;
            }
            return 0;
          }
          _SDL_JoystickGetButton.sig = "ipi";
          function _SDL_JoystickClose(joystick) {
            joystick >>>= 0;
            delete SDL.lastJoystickState[joystick];
          }
          _SDL_JoystickClose.sig = "vp";
          var _SDL_InitSubSystem = (flags2) => 0;
          _SDL_InitSubSystem.sig = "ii";
          function _SDL_RWFromConstMem(mem, size) {
            mem >>>= 0;
            var id = SDL.rwops.length;
            SDL.rwops.push({
              bytes: mem,
              count: size
            });
            return id;
          }
          _SDL_RWFromConstMem.sig = "ppi";
          var _SDL_RWFromMem = _SDL_RWFromConstMem;
          _SDL_RWFromMem.sig = "ppi";
          var _SDL_GetNumAudioDrivers = () => 1;
          _SDL_GetNumAudioDrivers.sig = "i";
          function _SDL_GetCurrentAudioDriver() {
            return stringToNewUTF8("Emscripten Audio");
          }
          _SDL_GetCurrentAudioDriver.sig = "p";
          var _SDL_GetScancodeFromKey = (key) => SDL.scanCodes[key];
          _SDL_GetScancodeFromKey.sig = "ii";
          function _SDL_GetAudioDriver(index) {
            return _SDL_GetCurrentAudioDriver();
          }
          _SDL_GetAudioDriver.sig = "pi";
          var _SDL_EnableUNICODE = (on) => {
            var ret = SDL.unicode || 0;
            SDL.unicode = on;
            return ret;
          };
          _SDL_EnableUNICODE.sig = "ii";
          var _SDL_AddTimer = function(interval, callback, param) {
            callback >>>= 0;
            param >>>= 0;
            return safeSetTimeout(() => getWasmTableEntry(callback)(interval, param), interval);
          };
          _SDL_AddTimer.sig = "iipp";
          var _SDL_RemoveTimer = (id) => {
            clearTimeout(id);
            return true;
          };
          _SDL_RemoveTimer.sig = "ii";
          function _SDL_CreateThread(fs2, data2, pfnBeginThread, pfnEndThread) {
            fs2 >>>= 0;
            data2 >>>= 0;
            throw "SDL threads cannot be supported in the web platform because they assume shared state. See emscripten_create_worker etc. for a message-passing concurrency model that does let you run code in another thread.";
          }
          _SDL_CreateThread.sig = "ppp";
          function _SDL_WaitThread(thread, status) {
            thread >>>= 0;
            status >>>= 0;
            throw "SDL_WaitThread";
          }
          _SDL_WaitThread.sig = "vpp";
          function _SDL_GetThreadID(thread) {
            thread >>>= 0;
            throw "SDL_GetThreadID";
          }
          _SDL_GetThreadID.sig = "pp";
          function _SDL_ThreadID() {
            return 0;
          }
          _SDL_ThreadID.sig = "p";
          function _SDL_AllocRW() {
            throw "SDL_AllocRW: TODO";
          }
          _SDL_AllocRW.sig = "p";
          function _SDL_CondBroadcast(cond) {
            cond >>>= 0;
            throw "SDL_CondBroadcast: TODO";
          }
          _SDL_CondBroadcast.sig = "ip";
          function _SDL_CondWaitTimeout(cond, mutex, ms) {
            cond >>>= 0;
            mutex >>>= 0;
            throw "SDL_CondWaitTimeout: TODO";
          }
          _SDL_CondWaitTimeout.sig = "ippi";
          var _SDL_WM_IconifyWindow = () => {
            throw "SDL_WM_IconifyWindow TODO";
          };
          _SDL_WM_IconifyWindow.sig = "i";
          function _Mix_SetPostMix(func2, arg) {
            func2 >>>= 0;
            arg >>>= 0;
            return warnOnce("Mix_SetPostMix: TODO");
          }
          _Mix_SetPostMix.sig = "vpp";
          function _Mix_VolumeChunk(chunk, volume) {
            chunk >>>= 0;
            throw "Mix_VolumeChunk: TODO";
          }
          _Mix_VolumeChunk.sig = "ipi";
          var _Mix_SetPosition = (channel, angle, distance) => {
            throw "Mix_SetPosition: TODO";
          };
          _Mix_SetPosition.sig = "iiii";
          function _Mix_QuerySpec(frequency, format, channels) {
            frequency >>>= 0;
            format >>>= 0;
            channels >>>= 0;
            throw "Mix_QuerySpec: TODO";
          }
          _Mix_QuerySpec.sig = "ippp";
          function _Mix_FadeInChannelTimed(channel, chunk, loop, ms, ticks) {
            chunk >>>= 0;
            throw "Mix_FadeInChannelTimed";
          }
          _Mix_FadeInChannelTimed.sig = "iipiii";
          var _Mix_FadeOutChannel = () => {
            throw "Mix_FadeOutChannel";
          };
          _Mix_FadeOutChannel.sig = "iii";
          function _Mix_Linked_Version() {
            throw "Mix_Linked_Version: TODO";
          }
          _Mix_Linked_Version.sig = "p";
          function _SDL_SaveBMP_RW(surface, dst, freedst) {
            surface >>>= 0;
            dst >>>= 0;
            throw "SDL_SaveBMP_RW: TODO";
          }
          _SDL_SaveBMP_RW.sig = "ippi";
          function _SDL_WM_SetIcon(icon, mask) {
            icon >>>= 0;
            mask >>>= 0;
          }
          _SDL_WM_SetIcon.sig = "vpp";
          var _SDL_HasRDTSC = () => 0;
          _SDL_HasRDTSC.sig = "i";
          var _SDL_HasMMX = () => 0;
          _SDL_HasMMX.sig = "i";
          var _SDL_HasMMXExt = () => 0;
          _SDL_HasMMXExt.sig = "i";
          var _SDL_Has3DNow = () => 0;
          _SDL_Has3DNow.sig = "i";
          var _SDL_Has3DNowExt = () => 0;
          _SDL_Has3DNowExt.sig = "i";
          var _SDL_HasSSE = () => 0;
          _SDL_HasSSE.sig = "i";
          var _SDL_HasSSE2 = () => 0;
          _SDL_HasSSE2.sig = "i";
          var _SDL_HasAltiVec = () => 0;
          _SDL_HasAltiVec.sig = "i";
          var ALLOC_NORMAL = 0;
          var ALLOC_STACK = 1;
          var allocate = (slab, allocator) => {
            var ret;
            if (allocator == ALLOC_STACK) {
              ret = stackAlloc(slab.length);
            } else {
              ret = _malloc(slab.length);
            }
            if (!slab.subarray && !slab.slice) {
              slab = new Uint8Array(slab);
            }
            HEAPU8.set(slab, ret >>> 0);
            return ret;
          };
          var writeStringToMemory = (string, buffer, dontAddNull) => {
            warnOnce("writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!");
            var lastChar, end;
            if (dontAddNull) {
              end = buffer + lengthBytesUTF8(string);
              lastChar = HEAP8[end >>> 0];
            }
            stringToUTF8(string, buffer, Infinity);
            if (dontAddNull)
              HEAP8[end >>> 0] = lastChar;
          };
          var writeAsciiToMemory = (str, buffer, dontAddNull) => {
            for (var i2 = 0; i2 < str.length; ++i2) {
              HEAP8[buffer++ >>> 0 >>> 0] = str.charCodeAt(i2);
            }
            if (!dontAddNull)
              HEAP8[buffer >>> 0 >>> 0] = 0;
          };
          var allocateUTF8 = stringToNewUTF8;
          var allocateUTF8OnStack = stringToUTF8OnStack;
          var setErrNo = (value) => {
            HEAP32[___errno_location() >>> 2 >>> 0] = value;
            return value;
          };
          var _emscripten_is_main_browser_thread = () => !ENVIRONMENT_IS_WORKER;
          var tupleRegistrations = {};
          var structRegistrations = {};
          var getTypeName = (type) => {
            var ptr2 = ___getTypeName(type);
            var rv = readLatin1String(ptr2);
            _free(ptr2);
            return rv;
          };
          var getFunctionName = (signature) => {
            signature = signature.trim();
            const argsIndex = signature.indexOf("(");
            if (argsIndex !== -1) {
              return signature.substr(0, argsIndex);
            } else {
              return signature;
            }
          };
          var getFunctionArgsName = (signature) => {
            signature = signature.trim();
            const argsIndex = signature.indexOf("(") + 1;
            if (argsIndex !== 0) {
              return signature.substr(argsIndex, signature.length - argsIndex - 1).replaceAll(" ", "").split(",").filter((n) => n.length);
            } else {
              return [];
            }
          };
          var heap32VectorToArray = (count, firstElement) => {
            var array = [];
            for (var i2 = 0; i2 < count; i2++) {
              array.push(HEAPU32[firstElement + i2 * 4 >>> 2 >>> 0]);
            }
            return array;
          };
          var requireRegisteredType = (rawType, humanName) => {
            var impl = registeredTypes[rawType];
            if (void 0 === impl) {
              throwBindingError(humanName + " has unknown type " + getTypeName(rawType));
            }
            return impl;
          };
          function usesDestructorStack(argTypes) {
            for (var i2 = 1; i2 < argTypes.length; ++i2) {
              if (argTypes[i2] !== null && argTypes[i2].destructorFunction === void 0) {
                return true;
              }
            }
            return false;
          }
          function createJsInvoker(humanName, argTypes, isClassMethodFunc, returns, isAsync) {
            var needsDestructorStack = usesDestructorStack(argTypes);
            var argCount = argTypes.length;
            var argsList = "";
            var argsListWired = "";
            for (var i2 = 0; i2 < argCount - 2; ++i2) {
              argsList += (i2 !== 0 ? ", " : "") + "arg" + i2;
              argsListWired += (i2 !== 0 ? ", " : "") + "arg" + i2 + "Wired";
            }
            var invokerFnBody = `
        return function (${argsList}) {
        if (arguments.length !== ${argCount - 2}) {
          throwBindingError('function ${humanName} called with ' + arguments.length + ' arguments, expected ${argCount - 2}');
        }`;
            if (needsDestructorStack) {
              invokerFnBody += "var destructors = [];\n";
            }
            var dtorStack = needsDestructorStack ? "destructors" : "null";
            var args1 = ["throwBindingError", "invoker", "fn", "runDestructors", "retType", "classParam"];
            if (isClassMethodFunc) {
              invokerFnBody += "var thisWired = classParam['toWireType'](" + dtorStack + ", this);\n";
            }
            for (var i2 = 0; i2 < argCount - 2; ++i2) {
              invokerFnBody += "var arg" + i2 + "Wired = argType" + i2 + "['toWireType'](" + dtorStack + ", arg" + i2 + "); // " + argTypes[i2 + 2].name + "\n";
              args1.push("argType" + i2);
            }
            if (isClassMethodFunc) {
              argsListWired = "thisWired" + (argsListWired.length > 0 ? ", " : "") + argsListWired;
            }
            invokerFnBody += (returns || isAsync ? "var rv = " : "") + "invoker(fn" + (argsListWired.length > 0 ? ", " : "") + argsListWired + ");\n";
            if (needsDestructorStack) {
              invokerFnBody += "runDestructors(destructors);\n";
            } else {
              for (var i2 = isClassMethodFunc ? 1 : 2; i2 < argTypes.length; ++i2) {
                var paramName = i2 === 1 ? "thisWired" : "arg" + (i2 - 2) + "Wired";
                if (argTypes[i2].destructorFunction !== null) {
                  invokerFnBody += paramName + "_dtor(" + paramName + "); // " + argTypes[i2].name + "\n";
                  args1.push(paramName + "_dtor");
                }
              }
            }
            if (returns) {
              invokerFnBody += "var ret = retType['fromWireType'](rv);\nreturn ret;\n";
            } else {
            }
            invokerFnBody += "}\n";
            return [args1, invokerFnBody];
          }
          var createNamedFunction = (name2, body2) => Object.defineProperty(body2, "name", {
            value: name2
          });
          var extendError = (baseErrorType, errorName) => {
            var errorClass = createNamedFunction(errorName, function(message) {
              this.name = errorName;
              this.message = message;
              var stack = new Error(message).stack;
              if (stack !== void 0) {
                this.stack = this.toString() + "\n" + stack.replace(/^Error(:[^\n]*)?\n/, "");
              }
            });
            errorClass.prototype = Object.create(baseErrorType.prototype);
            errorClass.prototype.constructor = errorClass;
            errorClass.prototype.toString = function() {
              if (this.message === void 0) {
                return this.name;
              } else {
                return `${this.name}: ${this.message}`;
              }
            };
            return errorClass;
          };
          var UnboundTypeError;
          var PureVirtualError;
          var registeredInstances = {};
          var getInheritedInstanceCount = () => Object.keys(registeredInstances).length;
          var getLiveInheritedInstances = () => {
            var rv = [];
            for (var k in registeredInstances) {
              if (registeredInstances.hasOwnProperty(k)) {
                rv.push(registeredInstances[k]);
              }
            }
            return rv;
          };
          var deletionQueue = [];
          var flushPendingDeletes = () => {
            while (deletionQueue.length) {
              var obj = deletionQueue.pop();
              obj.$$.deleteScheduled = false;
              obj["delete"]();
            }
          };
          var delayFunction;
          var setDelayFunction = (fn) => {
            delayFunction = fn;
            if (deletionQueue.length && delayFunction) {
              delayFunction(flushPendingDeletes);
            }
          };
          var init_embind = () => {
            Module["getInheritedInstanceCount"] = getInheritedInstanceCount;
            Module["getLiveInheritedInstances"] = getLiveInheritedInstances;
            Module["flushPendingDeletes"] = flushPendingDeletes;
            Module["setDelayFunction"] = setDelayFunction;
          };
          var throwUnboundTypeError = (message, types) => {
            var unboundTypes = [];
            var seen = {};
            function visit(type) {
              if (seen[type]) {
                return;
              }
              if (registeredTypes[type]) {
                return;
              }
              if (typeDependencies[type]) {
                typeDependencies[type].forEach(visit);
                return;
              }
              unboundTypes.push(type);
              seen[type] = true;
            }
            types.forEach(visit);
            throw new UnboundTypeError(`${message}: ` + unboundTypes.map(getTypeName).join([", "]));
          };
          var ensureOverloadTable = (proto, methodName, humanName) => {
            if (void 0 === proto[methodName].overloadTable) {
              var prevFunc = proto[methodName];
              proto[methodName] = function() {
                if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {
                  throwBindingError(`Function '${humanName}' called with an invalid number of arguments (${arguments.length}) - expects one of (${proto[methodName].overloadTable})!`);
                }
                return proto[methodName].overloadTable[arguments.length].apply(this, arguments);
              };
              proto[methodName].overloadTable = [];
              proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;
            }
          };
          var exposePublicSymbol = (name2, value, numArguments) => {
            if (Module.hasOwnProperty(name2)) {
              if (void 0 === numArguments || void 0 !== Module[name2].overloadTable && void 0 !== Module[name2].overloadTable[numArguments]) {
                throwBindingError(`Cannot register public name '${name2}' twice`);
              }
              ensureOverloadTable(Module, name2, name2);
              if (Module.hasOwnProperty(numArguments)) {
                throwBindingError(`Cannot register multiple overloads of a function with the same number of arguments (${numArguments})!`);
              }
              Module[name2].overloadTable[numArguments] = value;
            } else {
              Module[name2] = value;
              if (void 0 !== numArguments) {
                Module[name2].numArguments = numArguments;
              }
            }
          };
          var replacePublicSymbol = (name2, value, numArguments) => {
            if (!Module.hasOwnProperty(name2)) {
              throwInternalError("Replacing nonexistant public symbol");
            }
            if (void 0 !== Module[name2].overloadTable && void 0 !== numArguments) {
              Module[name2].overloadTable[numArguments] = value;
            } else {
              Module[name2] = value;
              Module[name2].argCount = numArguments;
            }
          };
          var getBasestPointer = (class_, ptr2) => {
            if (ptr2 === void 0) {
              throwBindingError("ptr should not be undefined");
            }
            while (class_.baseClass) {
              ptr2 = class_.upcast(ptr2);
              class_ = class_.baseClass;
            }
            return ptr2;
          };
          var registerInheritedInstance = (class_, ptr2, instance10) => {
            ptr2 = getBasestPointer(class_, ptr2);
            if (registeredInstances.hasOwnProperty(ptr2)) {
              throwBindingError(`Tried to register registered instance: ${ptr2}`);
            } else {
              registeredInstances[ptr2] = instance10;
            }
          };
          var unregisterInheritedInstance = (class_, ptr2) => {
            ptr2 = getBasestPointer(class_, ptr2);
            if (registeredInstances.hasOwnProperty(ptr2)) {
              delete registeredInstances[ptr2];
            } else {
              throwBindingError(`Tried to unregister unregistered instance: ${ptr2}`);
            }
          };
          var getInheritedInstance = (class_, ptr2) => {
            ptr2 = getBasestPointer(class_, ptr2);
            return registeredInstances[ptr2];
          };
          var registeredPointers = {};
          var enumReadValueFromPointer = (name2, width, signed) => {
            switch (width) {
              case 1:
                return signed ? function(pointer) {
                  return this["fromWireType"](HEAP8[pointer >>> 0 >>> 0]);
                } : function(pointer) {
                  return this["fromWireType"](HEAPU8[pointer >>> 0 >>> 0]);
                };
              case 2:
                return signed ? function(pointer) {
                  return this["fromWireType"](HEAP16[pointer >>> 1 >>> 0]);
                } : function(pointer) {
                  return this["fromWireType"](HEAPU16[pointer >>> 1 >>> 0]);
                };
              case 4:
                return signed ? function(pointer) {
                  return this["fromWireType"](HEAP32[pointer >>> 2 >>> 0]);
                } : function(pointer) {
                  return this["fromWireType"](HEAPU32[pointer >>> 2 >>> 0]);
                };
              default:
                throw new TypeError(`invalid integer width (${width}): ${name2}`);
            }
          };
          function __embind_register_user_type(rawType, name2) {
            rawType >>>= 0;
            name2 >>>= 0;
            __embind_register_emval(rawType);
          }
          __embind_register_user_type.sig = "vpp";
          function __embind_register_optional(rawOptionalType, rawType) {
            rawOptionalType >>>= 0;
            rawType >>>= 0;
            __embind_register_emval(rawOptionalType);
          }
          __embind_register_optional.sig = "vpp";
          var runDestructors = (destructors) => {
            while (destructors.length) {
              var ptr2 = destructors.pop();
              var del = destructors.pop();
              del(ptr2);
            }
          };
          function newFunc(constructor, argumentList) {
            if (!(constructor instanceof Function)) {
              throw new TypeError(`new_ called with constructor type ${typeof constructor} which is not a function`);
            }
            var dummy = createNamedFunction(constructor.name || "unknownFunctionName", function() {
            });
            dummy.prototype = constructor.prototype;
            var obj = new dummy();
            var r = constructor.apply(obj, argumentList);
            return r instanceof Object ? r : obj;
          }
          function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc, isAsync) {
            var argCount = argTypes.length;
            if (argCount < 2) {
              throwBindingError("argTypes array size mismatch! Must at least get return value and 'this' types!");
            }
            var isClassMethodFunc = argTypes[1] !== null && classType !== null;
            var needsDestructorStack = usesDestructorStack(argTypes);
            var returns = argTypes[0].name !== "void";
            var closureArgs = [throwBindingError, cppInvokerFunc, cppTargetFunc, runDestructors, argTypes[0], argTypes[1]];
            for (var i2 = 0; i2 < argCount - 2; ++i2) {
              closureArgs.push(argTypes[i2 + 2]);
            }
            if (!needsDestructorStack) {
              for (var i2 = isClassMethodFunc ? 1 : 2; i2 < argTypes.length; ++i2) {
                if (argTypes[i2].destructorFunction !== null) {
                  closureArgs.push(argTypes[i2].destructorFunction);
                }
              }
            }
            let [args2, invokerFnBody] = createJsInvoker(humanName, argTypes, isClassMethodFunc, returns, isAsync);
            args2.push(invokerFnBody);
            var invokerFn = newFunc(Function, args2).apply(null, closureArgs);
            return createNamedFunction(humanName, invokerFn);
          }
          var embind__requireFunction = (signature, rawFunction) => {
            signature = readLatin1String(signature);
            function makeDynCaller() {
              if (signature.includes("j")) {
                return getDynCaller(signature, rawFunction);
              }
              return getWasmTableEntry(rawFunction);
            }
            var fp = makeDynCaller();
            if (typeof fp != "function") {
              throwBindingError(`unknown function pointer with signature ${signature}: ${rawFunction}`);
            }
            return fp;
          };
          function __embind_register_function(name2, argCount, rawArgTypesAddr, signature, rawInvoker, fn, isAsync) {
            name2 >>>= 0;
            rawArgTypesAddr >>>= 0;
            signature >>>= 0;
            rawInvoker >>>= 0;
            fn >>>= 0;
            var argTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
            name2 = readLatin1String(name2);
            name2 = getFunctionName(name2);
            rawInvoker = embind__requireFunction(signature, rawInvoker);
            exposePublicSymbol(name2, function() {
              throwUnboundTypeError(`Cannot call ${name2} due to unbound types`, argTypes);
            }, argCount - 1);
            whenDependentTypesAreResolved([], argTypes, function(argTypes2) {
              var invokerArgsArray = [argTypes2[0], null].concat(argTypes2.slice(1));
              replacePublicSymbol(name2, craftInvokerFunction(name2, invokerArgsArray, null, rawInvoker, fn, isAsync), argCount - 1);
              return [];
            });
          }
          __embind_register_function.sig = "vpippppi";
          function __embind_register_value_array(rawType, name2, constructorSignature, rawConstructor, destructorSignature, rawDestructor) {
            rawType >>>= 0;
            name2 >>>= 0;
            constructorSignature >>>= 0;
            rawConstructor >>>= 0;
            destructorSignature >>>= 0;
            rawDestructor >>>= 0;
            tupleRegistrations[rawType] = {
              name: readLatin1String(name2),
              rawConstructor: embind__requireFunction(constructorSignature, rawConstructor),
              rawDestructor: embind__requireFunction(destructorSignature, rawDestructor),
              elements: []
            };
          }
          __embind_register_value_array.sig = "vpppppp";
          function __embind_register_value_array_element(rawTupleType, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {
            rawTupleType >>>= 0;
            getterReturnType >>>= 0;
            getterSignature >>>= 0;
            getter >>>= 0;
            getterContext >>>= 0;
            setterArgumentType >>>= 0;
            setterSignature >>>= 0;
            setter >>>= 0;
            setterContext >>>= 0;
            tupleRegistrations[rawTupleType].elements.push({
              getterReturnType,
              getter: embind__requireFunction(getterSignature, getter),
              getterContext,
              setterArgumentType,
              setter: embind__requireFunction(setterSignature, setter),
              setterContext
            });
          }
          __embind_register_value_array_element.sig = "vppppppppp";
          var __embind_finalize_value_array = function(rawTupleType) {
            rawTupleType >>>= 0;
            var reg = tupleRegistrations[rawTupleType];
            delete tupleRegistrations[rawTupleType];
            var elements = reg.elements;
            var elementsLength = elements.length;
            var elementTypes = elements.map((elt) => elt.getterReturnType).concat(elements.map((elt) => elt.setterArgumentType));
            var rawConstructor = reg.rawConstructor;
            var rawDestructor = reg.rawDestructor;
            whenDependentTypesAreResolved([rawTupleType], elementTypes, function(elementTypes2) {
              elements.forEach((elt, i2) => {
                var getterReturnType = elementTypes2[i2];
                var getter = elt.getter;
                var getterContext = elt.getterContext;
                var setterArgumentType = elementTypes2[i2 + elementsLength];
                var setter = elt.setter;
                var setterContext = elt.setterContext;
                elt.read = (ptr2) => getterReturnType["fromWireType"](getter(getterContext, ptr2));
                elt.write = (ptr2, o) => {
                  var destructors = [];
                  setter(setterContext, ptr2, setterArgumentType["toWireType"](destructors, o));
                  runDestructors(destructors);
                };
              });
              return [{
                name: reg.name,
                "fromWireType": (ptr2) => {
                  var rv = new Array(elementsLength);
                  for (var i2 = 0; i2 < elementsLength; ++i2) {
                    rv[i2] = elements[i2].read(ptr2);
                  }
                  rawDestructor(ptr2);
                  return rv;
                },
                "toWireType": (destructors, o) => {
                  if (elementsLength !== o.length) {
                    throw new TypeError(`Incorrect number of tuple elements for ${reg.name}: expected=${elementsLength}, actual=${o.length}`);
                  }
                  var ptr2 = rawConstructor();
                  for (var i2 = 0; i2 < elementsLength; ++i2) {
                    elements[i2].write(ptr2, o[i2]);
                  }
                  if (destructors !== null) {
                    destructors.push(rawDestructor, ptr2);
                  }
                  return ptr2;
                },
                "argPackAdvance": GenericWireTypeSize,
                "readValueFromPointer": simpleReadValueFromPointer,
                destructorFunction: rawDestructor
              }];
            });
          };
          __embind_finalize_value_array.sig = "vp";
          function __embind_register_value_object(rawType, name2, constructorSignature, rawConstructor, destructorSignature, rawDestructor) {
            rawType >>>= 0;
            name2 >>>= 0;
            constructorSignature >>>= 0;
            rawConstructor >>>= 0;
            destructorSignature >>>= 0;
            rawDestructor >>>= 0;
            structRegistrations[rawType] = {
              name: readLatin1String(name2),
              rawConstructor: embind__requireFunction(constructorSignature, rawConstructor),
              rawDestructor: embind__requireFunction(destructorSignature, rawDestructor),
              fields: []
            };
          }
          __embind_register_value_object.sig = "vpppppp";
          function __embind_register_value_object_field(structType, fieldName, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {
            structType >>>= 0;
            fieldName >>>= 0;
            getterReturnType >>>= 0;
            getterSignature >>>= 0;
            getter >>>= 0;
            getterContext >>>= 0;
            setterArgumentType >>>= 0;
            setterSignature >>>= 0;
            setter >>>= 0;
            setterContext >>>= 0;
            structRegistrations[structType].fields.push({
              fieldName: readLatin1String(fieldName),
              getterReturnType,
              getter: embind__requireFunction(getterSignature, getter),
              getterContext,
              setterArgumentType,
              setter: embind__requireFunction(setterSignature, setter),
              setterContext
            });
          }
          __embind_register_value_object_field.sig = "vpppppppppp";
          var __embind_finalize_value_object = function(structType) {
            structType >>>= 0;
            var reg = structRegistrations[structType];
            delete structRegistrations[structType];
            var rawConstructor = reg.rawConstructor;
            var rawDestructor = reg.rawDestructor;
            var fieldRecords = reg.fields;
            var fieldTypes = fieldRecords.map((field) => field.getterReturnType).concat(fieldRecords.map((field) => field.setterArgumentType));
            whenDependentTypesAreResolved([structType], fieldTypes, (fieldTypes2) => {
              var fields = {};
              fieldRecords.forEach((field, i2) => {
                var fieldName = field.fieldName;
                var getterReturnType = fieldTypes2[i2];
                var getter = field.getter;
                var getterContext = field.getterContext;
                var setterArgumentType = fieldTypes2[i2 + fieldRecords.length];
                var setter = field.setter;
                var setterContext = field.setterContext;
                fields[fieldName] = {
                  read: (ptr2) => getterReturnType["fromWireType"](getter(getterContext, ptr2)),
                  write: (ptr2, o) => {
                    var destructors = [];
                    setter(setterContext, ptr2, setterArgumentType["toWireType"](destructors, o));
                    runDestructors(destructors);
                  }
                };
              });
              return [{
                name: reg.name,
                "fromWireType": (ptr2) => {
                  var rv = {};
                  for (var i2 in fields) {
                    rv[i2] = fields[i2].read(ptr2);
                  }
                  rawDestructor(ptr2);
                  return rv;
                },
                "toWireType": (destructors, o) => {
                  for (var fieldName in fields) {
                    if (!(fieldName in o)) {
                      throw new TypeError(`Missing field: "${fieldName}"`);
                    }
                  }
                  var ptr2 = rawConstructor();
                  for (fieldName in fields) {
                    fields[fieldName].write(ptr2, o[fieldName]);
                  }
                  if (destructors !== null) {
                    destructors.push(rawDestructor, ptr2);
                  }
                  return ptr2;
                },
                "argPackAdvance": GenericWireTypeSize,
                "readValueFromPointer": simpleReadValueFromPointer,
                destructorFunction: rawDestructor
              }];
            });
          };
          __embind_finalize_value_object.sig = "vp";
          var upcastPointer = (ptr2, ptrClass, desiredClass) => {
            while (ptrClass !== desiredClass) {
              if (!ptrClass.upcast) {
                throwBindingError(`Expected null or instance of ${desiredClass.name}, got an instance of ${ptrClass.name}`);
              }
              ptr2 = ptrClass.upcast(ptr2);
              ptrClass = ptrClass.baseClass;
            }
            return ptr2;
          };
          function genericPointerToWireType(destructors, handle2) {
            var ptr2;
            if (handle2 === null) {
              if (this.isReference) {
                throwBindingError(`null is not a valid ${this.name}`);
              }
              if (this.isSmartPointer) {
                ptr2 = this.rawConstructor();
                if (destructors !== null) {
                  destructors.push(this.rawDestructor, ptr2);
                }
                return ptr2;
              } else {
                return 0;
              }
            }
            if (!handle2 || !handle2.$$) {
              throwBindingError(`Cannot pass "${embindRepr(handle2)}" as a ${this.name}`);
            }
            if (!handle2.$$.ptr) {
              throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);
            }
            if (!this.isConst && handle2.$$.ptrType.isConst) {
              throwBindingError(`Cannot convert argument of type ${handle2.$$.smartPtrType ? handle2.$$.smartPtrType.name : handle2.$$.ptrType.name} to parameter type ${this.name}`);
            }
            var handleClass = handle2.$$.ptrType.registeredClass;
            ptr2 = upcastPointer(handle2.$$.ptr, handleClass, this.registeredClass);
            if (this.isSmartPointer) {
              if (void 0 === handle2.$$.smartPtr) {
                throwBindingError("Passing raw pointer to smart pointer is illegal");
              }
              switch (this.sharingPolicy) {
                case 0:
                  if (handle2.$$.smartPtrType === this) {
                    ptr2 = handle2.$$.smartPtr;
                  } else {
                    throwBindingError(`Cannot convert argument of type ${handle2.$$.smartPtrType ? handle2.$$.smartPtrType.name : handle2.$$.ptrType.name} to parameter type ${this.name}`);
                  }
                  break;
                case 1:
                  ptr2 = handle2.$$.smartPtr;
                  break;
                case 2:
                  if (handle2.$$.smartPtrType === this) {
                    ptr2 = handle2.$$.smartPtr;
                  } else {
                    var clonedHandle = handle2["clone"]();
                    ptr2 = this.rawShare(ptr2, Emval.toHandle(() => clonedHandle["delete"]()));
                    if (destructors !== null) {
                      destructors.push(this.rawDestructor, ptr2);
                    }
                  }
                  break;
                default:
                  throwBindingError("Unsupporting sharing policy");
              }
            }
            return ptr2;
          }
          function constNoSmartPtrRawPointerToWireType(destructors, handle2) {
            if (handle2 === null) {
              if (this.isReference) {
                throwBindingError(`null is not a valid ${this.name}`);
              }
              return 0;
            }
            if (!handle2.$$) {
              throwBindingError(`Cannot pass "${embindRepr(handle2)}" as a ${this.name}`);
            }
            if (!handle2.$$.ptr) {
              throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);
            }
            var handleClass = handle2.$$.ptrType.registeredClass;
            var ptr2 = upcastPointer(handle2.$$.ptr, handleClass, this.registeredClass);
            return ptr2;
          }
          function nonConstNoSmartPtrRawPointerToWireType(destructors, handle2) {
            if (handle2 === null) {
              if (this.isReference) {
                throwBindingError(`null is not a valid ${this.name}`);
              }
              return 0;
            }
            if (!handle2.$$) {
              throwBindingError(`Cannot pass "${embindRepr(handle2)}" as a ${this.name}`);
            }
            if (!handle2.$$.ptr) {
              throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);
            }
            if (handle2.$$.ptrType.isConst) {
              throwBindingError(`Cannot convert argument of type ${handle2.$$.ptrType.name} to parameter type ${this.name}`);
            }
            var handleClass = handle2.$$.ptrType.registeredClass;
            var ptr2 = upcastPointer(handle2.$$.ptr, handleClass, this.registeredClass);
            return ptr2;
          }
          function RegisteredPointer(name2, registeredClass, isReference, isConst, isSmartPointer, pointeeType, sharingPolicy, rawGetPointee, rawConstructor, rawShare, rawDestructor) {
            this.name = name2;
            this.registeredClass = registeredClass;
            this.isReference = isReference;
            this.isConst = isConst;
            this.isSmartPointer = isSmartPointer;
            this.pointeeType = pointeeType;
            this.sharingPolicy = sharingPolicy;
            this.rawGetPointee = rawGetPointee;
            this.rawConstructor = rawConstructor;
            this.rawShare = rawShare;
            this.rawDestructor = rawDestructor;
            if (!isSmartPointer && registeredClass.baseClass === void 0) {
              if (isConst) {
                this["toWireType"] = constNoSmartPtrRawPointerToWireType;
                this.destructorFunction = null;
              } else {
                this["toWireType"] = nonConstNoSmartPtrRawPointerToWireType;
                this.destructorFunction = null;
              }
            } else {
              this["toWireType"] = genericPointerToWireType;
            }
          }
          var downcastPointer = (ptr2, ptrClass, desiredClass) => {
            if (ptrClass === desiredClass) {
              return ptr2;
            }
            if (void 0 === desiredClass.baseClass) {
              return null;
            }
            var rv = downcastPointer(ptr2, ptrClass, desiredClass.baseClass);
            if (rv === null) {
              return null;
            }
            return desiredClass.downcast(rv);
          };
          var finalizationRegistry = false;
          var detachFinalizer = (handle2) => {
          };
          var runDestructor = ($$) => {
            if ($$.smartPtr) {
              $$.smartPtrType.rawDestructor($$.smartPtr);
            } else {
              $$.ptrType.registeredClass.rawDestructor($$.ptr);
            }
          };
          var releaseClassHandle = ($$) => {
            $$.count.value -= 1;
            var toDelete = 0 === $$.count.value;
            if (toDelete) {
              runDestructor($$);
            }
          };
          var attachFinalizer = (handle2) => {
            if ("undefined" === typeof FinalizationRegistry) {
              attachFinalizer = (handle3) => handle3;
              return handle2;
            }
            finalizationRegistry = new FinalizationRegistry((info2) => {
              releaseClassHandle(info2.$$);
            });
            attachFinalizer = (handle3) => {
              var $$ = handle3.$$;
              var hasSmartPtr = !!$$.smartPtr;
              if (hasSmartPtr) {
                var info2 = {
                  $$
                };
                finalizationRegistry.register(handle3, info2, handle3);
              }
              return handle3;
            };
            detachFinalizer = (handle3) => finalizationRegistry.unregister(handle3);
            return attachFinalizer(handle2);
          };
          var makeClassHandle = (prototype, record) => {
            if (!record.ptrType || !record.ptr) {
              throwInternalError("makeClassHandle requires ptr and ptrType");
            }
            var hasSmartPtrType = !!record.smartPtrType;
            var hasSmartPtr = !!record.smartPtr;
            if (hasSmartPtrType !== hasSmartPtr) {
              throwInternalError("Both smartPtrType and smartPtr must be specified");
            }
            record.count = {
              value: 1
            };
            return attachFinalizer(Object.create(prototype, {
              $$: {
                value: record,
                writable: true
              }
            }));
          };
          function RegisteredPointer_fromWireType(ptr2) {
            var rawPointer = this.getPointee(ptr2);
            if (!rawPointer) {
              this.destructor(ptr2);
              return null;
            }
            var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);
            if (void 0 !== registeredInstance) {
              if (0 === registeredInstance.$$.count.value) {
                registeredInstance.$$.ptr = rawPointer;
                registeredInstance.$$.smartPtr = ptr2;
                return registeredInstance["clone"]();
              } else {
                var rv = registeredInstance["clone"]();
                this.destructor(ptr2);
                return rv;
              }
            }
            function makeDefaultHandle() {
              if (this.isSmartPointer) {
                return makeClassHandle(this.registeredClass.instancePrototype, {
                  ptrType: this.pointeeType,
                  ptr: rawPointer,
                  smartPtrType: this,
                  smartPtr: ptr2
                });
              } else {
                return makeClassHandle(this.registeredClass.instancePrototype, {
                  ptrType: this,
                  ptr: ptr2
                });
              }
            }
            var actualType = this.registeredClass.getActualType(rawPointer);
            var registeredPointerRecord = registeredPointers[actualType];
            if (!registeredPointerRecord) {
              return makeDefaultHandle.call(this);
            }
            var toType;
            if (this.isConst) {
              toType = registeredPointerRecord.constPointerType;
            } else {
              toType = registeredPointerRecord.pointerType;
            }
            var dp = downcastPointer(rawPointer, this.registeredClass, toType.registeredClass);
            if (dp === null) {
              return makeDefaultHandle.call(this);
            }
            if (this.isSmartPointer) {
              return makeClassHandle(toType.registeredClass.instancePrototype, {
                ptrType: toType,
                ptr: dp,
                smartPtrType: this,
                smartPtr: ptr2
              });
            } else {
              return makeClassHandle(toType.registeredClass.instancePrototype, {
                ptrType: toType,
                ptr: dp
              });
            }
          }
          var init_RegisteredPointer = () => {
            Object.assign(RegisteredPointer.prototype, {
              getPointee(ptr2) {
                if (this.rawGetPointee) {
                  ptr2 = this.rawGetPointee(ptr2);
                }
                return ptr2;
              },
              destructor(ptr2) {
                this.rawDestructor?.(ptr2);
              },
              "argPackAdvance": GenericWireTypeSize,
              "readValueFromPointer": readPointer,
              "fromWireType": RegisteredPointer_fromWireType
            });
          };
          var detachFinalizer_deps = ["$finalizationRegistry"];
          function ClassHandle() {
          }
          var shallowCopyInternalPointer = (o) => ({
            count: o.count,
            deleteScheduled: o.deleteScheduled,
            preservePointerOnDelete: o.preservePointerOnDelete,
            ptr: o.ptr,
            ptrType: o.ptrType,
            smartPtr: o.smartPtr,
            smartPtrType: o.smartPtrType
          });
          var throwInstanceAlreadyDeleted = (obj) => {
            function getInstanceTypeName(handle2) {
              return handle2.$$.ptrType.registeredClass.name;
            }
            throwBindingError(getInstanceTypeName(obj) + " instance already deleted");
          };
          var init_ClassHandle = () => {
            Object.assign(ClassHandle.prototype, {
              "isAliasOf"(other) {
                if (!(this instanceof ClassHandle)) {
                  return false;
                }
                if (!(other instanceof ClassHandle)) {
                  return false;
                }
                var leftClass = this.$$.ptrType.registeredClass;
                var left = this.$$.ptr;
                other.$$ = other.$$;
                var rightClass = other.$$.ptrType.registeredClass;
                var right = other.$$.ptr;
                while (leftClass.baseClass) {
                  left = leftClass.upcast(left);
                  leftClass = leftClass.baseClass;
                }
                while (rightClass.baseClass) {
                  right = rightClass.upcast(right);
                  rightClass = rightClass.baseClass;
                }
                return leftClass === rightClass && left === right;
              },
              "clone"() {
                if (!this.$$.ptr) {
                  throwInstanceAlreadyDeleted(this);
                }
                if (this.$$.preservePointerOnDelete) {
                  this.$$.count.value += 1;
                  return this;
                } else {
                  var clone = attachFinalizer(Object.create(Object.getPrototypeOf(this), {
                    $$: {
                      value: shallowCopyInternalPointer(this.$$)
                    }
                  }));
                  clone.$$.count.value += 1;
                  clone.$$.deleteScheduled = false;
                  return clone;
                }
              },
              "delete"() {
                if (!this.$$.ptr) {
                  throwInstanceAlreadyDeleted(this);
                }
                if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
                  throwBindingError("Object already scheduled for deletion");
                }
                detachFinalizer(this);
                releaseClassHandle(this.$$);
                if (!this.$$.preservePointerOnDelete) {
                  this.$$.smartPtr = void 0;
                  this.$$.ptr = void 0;
                }
              },
              "isDeleted"() {
                return !this.$$.ptr;
              },
              "deleteLater"() {
                if (!this.$$.ptr) {
                  throwInstanceAlreadyDeleted(this);
                }
                if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
                  throwBindingError("Object already scheduled for deletion");
                }
                deletionQueue.push(this);
                if (deletionQueue.length === 1 && delayFunction) {
                  delayFunction(flushPendingDeletes);
                }
                this.$$.deleteScheduled = true;
                return this;
              }
            });
          };
          function RegisteredClass(name2, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast) {
            this.name = name2;
            this.constructor = constructor;
            this.instancePrototype = instancePrototype;
            this.rawDestructor = rawDestructor;
            this.baseClass = baseClass;
            this.getActualType = getActualType;
            this.upcast = upcast;
            this.downcast = downcast;
            this.pureVirtualFunctions = [];
          }
          var char_0 = 48;
          var char_9 = 57;
          var makeLegalFunctionName = (name2) => {
            if (void 0 === name2) {
              return "_unknown";
            }
            name2 = name2.replace(/[^a-zA-Z0-9_]/g, "$");
            var f = name2.charCodeAt(0);
            if (f >= char_0 && f <= char_9) {
              return `_${name2}`;
            }
            return name2;
          };
          function __embind_register_class(rawType, rawPointerType, rawConstPointerType, baseClassRawType, getActualTypeSignature, getActualType, upcastSignature, upcast, downcastSignature, downcast, name2, destructorSignature, rawDestructor) {
            rawType >>>= 0;
            rawPointerType >>>= 0;
            rawConstPointerType >>>= 0;
            baseClassRawType >>>= 0;
            getActualTypeSignature >>>= 0;
            getActualType >>>= 0;
            upcastSignature >>>= 0;
            upcast >>>= 0;
            downcastSignature >>>= 0;
            downcast >>>= 0;
            name2 >>>= 0;
            destructorSignature >>>= 0;
            rawDestructor >>>= 0;
            name2 = readLatin1String(name2);
            getActualType = embind__requireFunction(getActualTypeSignature, getActualType);
            upcast && (upcast = embind__requireFunction(upcastSignature, upcast));
            downcast && (downcast = embind__requireFunction(downcastSignature, downcast));
            rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);
            var legalFunctionName = makeLegalFunctionName(name2);
            exposePublicSymbol(legalFunctionName, function() {
              throwUnboundTypeError(`Cannot construct ${name2} due to unbound types`, [baseClassRawType]);
            });
            whenDependentTypesAreResolved([rawType, rawPointerType, rawConstPointerType], baseClassRawType ? [baseClassRawType] : [], function(base) {
              var _a5;
              base = base[0];
              var baseClass;
              var basePrototype;
              if (baseClassRawType) {
                baseClass = base.registeredClass;
                basePrototype = baseClass.instancePrototype;
              } else {
                basePrototype = ClassHandle.prototype;
              }
              var constructor = createNamedFunction(name2, function() {
                if (Object.getPrototypeOf(this) !== instancePrototype) {
                  throw new BindingError("Use 'new' to construct " + name2);
                }
                if (void 0 === registeredClass.constructor_body) {
                  throw new BindingError(name2 + " has no accessible constructor");
                }
                var body2 = registeredClass.constructor_body[arguments.length];
                if (void 0 === body2) {
                  throw new BindingError(`Tried to invoke ctor of ${name2} with invalid number of parameters (${arguments.length}) - expected (${Object.keys(registeredClass.constructor_body).toString()}) parameters instead!`);
                }
                return body2.apply(this, arguments);
              });
              var instancePrototype = Object.create(basePrototype, {
                constructor: {
                  value: constructor
                }
              });
              constructor.prototype = instancePrototype;
              var registeredClass = new RegisteredClass(name2, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast);
              if (registeredClass.baseClass) {
                (_a5 = registeredClass.baseClass).__derivedClasses ?? (_a5.__derivedClasses = []);
                registeredClass.baseClass.__derivedClasses.push(registeredClass);
              }
              var referenceConverter = new RegisteredPointer(name2, registeredClass, true, false, false);
              var pointerConverter = new RegisteredPointer(name2 + "*", registeredClass, false, false, false);
              var constPointerConverter = new RegisteredPointer(name2 + " const*", registeredClass, false, true, false);
              registeredPointers[rawType] = {
                pointerType: pointerConverter,
                constPointerType: constPointerConverter
              };
              replacePublicSymbol(legalFunctionName, constructor);
              return [referenceConverter, pointerConverter, constPointerConverter];
            });
          }
          __embind_register_class.sig = "vppppppppppppp";
          function __embind_register_class_constructor(rawClassType, argCount, rawArgTypesAddr, invokerSignature, invoker, rawConstructor) {
            rawClassType >>>= 0;
            rawArgTypesAddr >>>= 0;
            invokerSignature >>>= 0;
            invoker >>>= 0;
            rawConstructor >>>= 0;
            var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
            invoker = embind__requireFunction(invokerSignature, invoker);
            var args2 = [rawConstructor];
            var destructors = [];
            whenDependentTypesAreResolved([], [rawClassType], function(classType) {
              classType = classType[0];
              var humanName = `constructor ${classType.name}`;
              if (void 0 === classType.registeredClass.constructor_body) {
                classType.registeredClass.constructor_body = [];
              }
              if (void 0 !== classType.registeredClass.constructor_body[argCount - 1]) {
                throw new BindingError(`Cannot register multiple constructors with identical number of parameters (${argCount - 1}) for class '${classType.name}'! Overload resolution is currently only performed using the parameter count, not actual type info!`);
              }
              classType.registeredClass.constructor_body[argCount - 1] = () => {
                throwUnboundTypeError(`Cannot construct ${classType.name} due to unbound types`, rawArgTypes);
              };
              whenDependentTypesAreResolved([], rawArgTypes, (argTypes) => {
                argTypes.splice(1, 0, null);
                classType.registeredClass.constructor_body[argCount - 1] = craftInvokerFunction(humanName, argTypes, null, invoker, rawConstructor);
                return [];
              });
              return [];
            });
          }
          __embind_register_class_constructor.sig = "vpipppp";
          var validateThis = (this_, classType, humanName) => {
            if (!(this_ instanceof Object)) {
              throwBindingError(`${humanName} with invalid "this": ${this_}`);
            }
            if (!(this_ instanceof classType.registeredClass.constructor)) {
              throwBindingError(`${humanName} incompatible with "this" of type ${this_.constructor.name}`);
            }
            if (!this_.$$.ptr) {
              throwBindingError(`cannot call emscripten binding method ${humanName} on deleted object`);
            }
            return upcastPointer(this_.$$.ptr, this_.$$.ptrType.registeredClass, classType.registeredClass);
          };
          function __embind_register_class_function(rawClassType, methodName, argCount, rawArgTypesAddr, invokerSignature, rawInvoker, context, isPureVirtual, isAsync) {
            rawClassType >>>= 0;
            methodName >>>= 0;
            rawArgTypesAddr >>>= 0;
            invokerSignature >>>= 0;
            rawInvoker >>>= 0;
            context >>>= 0;
            var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
            methodName = readLatin1String(methodName);
            methodName = getFunctionName(methodName);
            rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);
            whenDependentTypesAreResolved([], [rawClassType], function(classType) {
              classType = classType[0];
              var humanName = `${classType.name}.${methodName}`;
              if (methodName.startsWith("@@")) {
                methodName = Symbol[methodName.substring(2)];
              }
              if (isPureVirtual) {
                classType.registeredClass.pureVirtualFunctions.push(methodName);
              }
              function unboundTypesHandler() {
                throwUnboundTypeError(`Cannot call ${humanName} due to unbound types`, rawArgTypes);
              }
              var proto = classType.registeredClass.instancePrototype;
              var method = proto[methodName];
              if (void 0 === method || void 0 === method.overloadTable && method.className !== classType.name && method.argCount === argCount - 2) {
                unboundTypesHandler.argCount = argCount - 2;
                unboundTypesHandler.className = classType.name;
                proto[methodName] = unboundTypesHandler;
              } else {
                ensureOverloadTable(proto, methodName, humanName);
                proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;
              }
              whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
                var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context, isAsync);
                if (void 0 === proto[methodName].overloadTable) {
                  memberFunction.argCount = argCount - 2;
                  proto[methodName] = memberFunction;
                } else {
                  proto[methodName].overloadTable[argCount - 2] = memberFunction;
                }
                return [];
              });
              return [];
            });
          }
          __embind_register_class_function.sig = "vppippppii";
          function __embind_register_class_property(classType, fieldName, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {
            classType >>>= 0;
            fieldName >>>= 0;
            getterReturnType >>>= 0;
            getterSignature >>>= 0;
            getter >>>= 0;
            getterContext >>>= 0;
            setterArgumentType >>>= 0;
            setterSignature >>>= 0;
            setter >>>= 0;
            setterContext >>>= 0;
            fieldName = readLatin1String(fieldName);
            getter = embind__requireFunction(getterSignature, getter);
            whenDependentTypesAreResolved([], [classType], function(classType2) {
              classType2 = classType2[0];
              var humanName = `${classType2.name}.${fieldName}`;
              var desc = {
                get() {
                  throwUnboundTypeError(`Cannot access ${humanName} due to unbound types`, [getterReturnType, setterArgumentType]);
                },
                enumerable: true,
                configurable: true
              };
              if (setter) {
                desc.set = () => throwUnboundTypeError(`Cannot access ${humanName} due to unbound types`, [getterReturnType, setterArgumentType]);
              } else {
                desc.set = (v) => throwBindingError(humanName + " is a read-only property");
              }
              Object.defineProperty(classType2.registeredClass.instancePrototype, fieldName, desc);
              whenDependentTypesAreResolved([], setter ? [getterReturnType, setterArgumentType] : [getterReturnType], function(types) {
                var getterReturnType2 = types[0];
                var desc2 = {
                  get() {
                    var ptr2 = validateThis(this, classType2, humanName + " getter");
                    return getterReturnType2["fromWireType"](getter(getterContext, ptr2));
                  },
                  enumerable: true
                };
                if (setter) {
                  setter = embind__requireFunction(setterSignature, setter);
                  var setterArgumentType2 = types[1];
                  desc2.set = function(v) {
                    var ptr2 = validateThis(this, classType2, humanName + " setter");
                    var destructors = [];
                    setter(setterContext, ptr2, setterArgumentType2["toWireType"](destructors, v));
                    runDestructors(destructors);
                  };
                }
                Object.defineProperty(classType2.registeredClass.instancePrototype, fieldName, desc2);
                return [];
              });
              return [];
            });
          }
          __embind_register_class_property.sig = "vpppppppppp";
          function __embind_register_class_class_function(rawClassType, methodName, argCount, rawArgTypesAddr, invokerSignature, rawInvoker, fn, isAsync) {
            rawClassType >>>= 0;
            methodName >>>= 0;
            rawArgTypesAddr >>>= 0;
            invokerSignature >>>= 0;
            rawInvoker >>>= 0;
            fn >>>= 0;
            var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
            methodName = readLatin1String(methodName);
            methodName = getFunctionName(methodName);
            rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);
            whenDependentTypesAreResolved([], [rawClassType], function(classType) {
              classType = classType[0];
              var humanName = `${classType.name}.${methodName}`;
              function unboundTypesHandler() {
                throwUnboundTypeError(`Cannot call ${humanName} due to unbound types`, rawArgTypes);
              }
              if (methodName.startsWith("@@")) {
                methodName = Symbol[methodName.substring(2)];
              }
              var proto = classType.registeredClass.constructor;
              if (void 0 === proto[methodName]) {
                unboundTypesHandler.argCount = argCount - 1;
                proto[methodName] = unboundTypesHandler;
              } else {
                ensureOverloadTable(proto, methodName, humanName);
                proto[methodName].overloadTable[argCount - 1] = unboundTypesHandler;
              }
              whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
                var invokerArgsArray = [argTypes[0], null].concat(argTypes.slice(1));
                var func2 = craftInvokerFunction(humanName, invokerArgsArray, null, rawInvoker, fn, isAsync);
                if (void 0 === proto[methodName].overloadTable) {
                  func2.argCount = argCount - 1;
                  proto[methodName] = func2;
                } else {
                  proto[methodName].overloadTable[argCount - 1] = func2;
                }
                if (classType.registeredClass.__derivedClasses) {
                  for (const derivedClass of classType.registeredClass.__derivedClasses) {
                    if (!derivedClass.constructor.hasOwnProperty(methodName)) {
                      derivedClass.constructor[methodName] = func2;
                    }
                  }
                }
                return [];
              });
              return [];
            });
          }
          __embind_register_class_class_function.sig = "vppippppi";
          function __embind_register_class_class_property(rawClassType, fieldName, rawFieldType, rawFieldPtr, getterSignature, getter, setterSignature, setter) {
            rawClassType >>>= 0;
            fieldName >>>= 0;
            rawFieldType >>>= 0;
            rawFieldPtr >>>= 0;
            getterSignature >>>= 0;
            getter >>>= 0;
            setterSignature >>>= 0;
            setter >>>= 0;
            fieldName = readLatin1String(fieldName);
            getter = embind__requireFunction(getterSignature, getter);
            whenDependentTypesAreResolved([], [rawClassType], function(classType) {
              classType = classType[0];
              var humanName = `${classType.name}.${fieldName}`;
              var desc = {
                get() {
                  throwUnboundTypeError(`Cannot access ${humanName} due to unbound types`, [rawFieldType]);
                },
                enumerable: true,
                configurable: true
              };
              if (setter) {
                desc.set = () => {
                  throwUnboundTypeError(`Cannot access ${humanName} due to unbound types`, [rawFieldType]);
                };
              } else {
                desc.set = (v) => {
                  throwBindingError(`${humanName} is a read-only property`);
                };
              }
              Object.defineProperty(classType.registeredClass.constructor, fieldName, desc);
              whenDependentTypesAreResolved([], [rawFieldType], function(fieldType) {
                fieldType = fieldType[0];
                var desc2 = {
                  get() {
                    return fieldType["fromWireType"](getter(rawFieldPtr));
                  },
                  enumerable: true
                };
                if (setter) {
                  setter = embind__requireFunction(setterSignature, setter);
                  desc2.set = (v) => {
                    var destructors = [];
                    setter(rawFieldPtr, fieldType["toWireType"](destructors, v));
                    runDestructors(destructors);
                  };
                }
                Object.defineProperty(classType.registeredClass.constructor, fieldName, desc2);
                return [];
              });
              return [];
            });
          }
          __embind_register_class_class_property.sig = "vpppppppp";
          function __embind_create_inheriting_constructor(constructorName, wrapperType, properties) {
            constructorName >>>= 0;
            wrapperType >>>= 0;
            properties >>>= 0;
            constructorName = readLatin1String(constructorName);
            wrapperType = requireRegisteredType(wrapperType, "wrapper");
            properties = Emval.toValue(properties);
            var arraySlice = [].slice;
            var registeredClass = wrapperType.registeredClass;
            var wrapperPrototype = registeredClass.instancePrototype;
            var baseClass = registeredClass.baseClass;
            var baseClassPrototype = baseClass.instancePrototype;
            var baseConstructor = registeredClass.baseClass.constructor;
            var ctor = createNamedFunction(constructorName, function() {
              registeredClass.baseClass.pureVirtualFunctions.forEach(function(name2) {
                if (this[name2] === baseClassPrototype[name2]) {
                  throw new PureVirtualError(`Pure virtual function ${name2} must be implemented in JavaScript`);
                }
              }.bind(this));
              Object.defineProperty(this, "__parent", {
                value: wrapperPrototype
              });
              this["__construct"].apply(this, arraySlice.call(arguments));
            });
            wrapperPrototype["__construct"] = function __construct() {
              if (this === wrapperPrototype) {
                throwBindingError("Pass correct 'this' to __construct");
              }
              var inner = baseConstructor["implement"].apply(void 0, [this].concat(arraySlice.call(arguments)));
              detachFinalizer(inner);
              var $$ = inner.$$;
              inner["notifyOnDestruction"]();
              $$.preservePointerOnDelete = true;
              Object.defineProperties(this, {
                $$: {
                  value: $$
                }
              });
              attachFinalizer(this);
              registerInheritedInstance(registeredClass, $$.ptr, this);
            };
            wrapperPrototype["__destruct"] = function __destruct() {
              if (this === wrapperPrototype) {
                throwBindingError("Pass correct 'this' to __destruct");
              }
              detachFinalizer(this);
              unregisterInheritedInstance(registeredClass, this.$$.ptr);
            };
            ctor.prototype = Object.create(wrapperPrototype);
            Object.assign(ctor.prototype, properties);
            return Emval.toHandle(ctor);
          }
          __embind_create_inheriting_constructor.sig = "pppp";
          function __embind_register_smart_ptr(rawType, rawPointeeType, name2, sharingPolicy, getPointeeSignature, rawGetPointee, constructorSignature, rawConstructor, shareSignature, rawShare, destructorSignature, rawDestructor) {
            rawType >>>= 0;
            rawPointeeType >>>= 0;
            name2 >>>= 0;
            getPointeeSignature >>>= 0;
            rawGetPointee >>>= 0;
            constructorSignature >>>= 0;
            rawConstructor >>>= 0;
            shareSignature >>>= 0;
            rawShare >>>= 0;
            destructorSignature >>>= 0;
            rawDestructor >>>= 0;
            name2 = readLatin1String(name2);
            rawGetPointee = embind__requireFunction(getPointeeSignature, rawGetPointee);
            rawConstructor = embind__requireFunction(constructorSignature, rawConstructor);
            rawShare = embind__requireFunction(shareSignature, rawShare);
            rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);
            whenDependentTypesAreResolved([rawType], [rawPointeeType], function(pointeeType) {
              pointeeType = pointeeType[0];
              var registeredPointer = new RegisteredPointer(name2, pointeeType.registeredClass, false, false, true, pointeeType, sharingPolicy, rawGetPointee, rawConstructor, rawShare, rawDestructor);
              return [registeredPointer];
            });
          }
          __embind_register_smart_ptr.sig = "vpppipppppppp";
          function __embind_register_enum(rawType, name2, size, isSigned) {
            rawType >>>= 0;
            name2 >>>= 0;
            size >>>= 0;
            name2 = readLatin1String(name2);
            function ctor() {
            }
            ctor.values = {};
            registerType(rawType, {
              name: name2,
              constructor: ctor,
              "fromWireType": function(c) {
                return this.constructor.values[c];
              },
              "toWireType": (destructors, c) => c.value,
              "argPackAdvance": GenericWireTypeSize,
              "readValueFromPointer": enumReadValueFromPointer(name2, size, isSigned),
              destructorFunction: null
            });
            exposePublicSymbol(name2, ctor);
          }
          __embind_register_enum.sig = "vpppi";
          function __embind_register_enum_value(rawEnumType, name2, enumValue) {
            rawEnumType >>>= 0;
            name2 >>>= 0;
            var enumType = requireRegisteredType(rawEnumType, "enum");
            name2 = readLatin1String(name2);
            var Enum = enumType.constructor;
            var Value = Object.create(enumType.constructor.prototype, {
              value: {
                value: enumValue
              },
              constructor: {
                value: createNamedFunction(`${enumType.name}_${name2}`, function() {
                })
              }
            });
            Enum.values[enumValue] = Value;
            Enum[name2] = Value;
          }
          __embind_register_enum_value.sig = "vppi";
          function __embind_register_constant(name2, type, value) {
            name2 >>>= 0;
            type >>>= 0;
            name2 = readLatin1String(name2);
            whenDependentTypesAreResolved([], [type], function(type2) {
              type2 = type2[0];
              Module[name2] = type2["fromWireType"](value);
              return [];
            });
          }
          __embind_register_constant.sig = "vppd";
          var emval_symbols = {};
          function __emval_register_symbol(address) {
            address >>>= 0;
            emval_symbols[address] = readLatin1String(address);
          }
          __emval_register_symbol.sig = "vp";
          var getStringOrSymbol = (address) => {
            var symbol = emval_symbols[address];
            if (symbol === void 0) {
              return readLatin1String(address);
            }
            return symbol;
          };
          function __emval_incref(handle2) {
            handle2 >>>= 0;
            if (handle2 > 4) {
              emval_handles.get(handle2).refcount += 1;
            }
          }
          __emval_incref.sig = "vp";
          function __emval_run_destructors(handle2) {
            handle2 >>>= 0;
            var destructors = Emval.toValue(handle2);
            runDestructors(destructors);
            __emval_decref(handle2);
          }
          __emval_run_destructors.sig = "vp";
          function __emval_new_array() {
            return Emval.toHandle([]);
          }
          __emval_new_array.sig = "p";
          function __emval_new_array_from_memory_view(view) {
            view >>>= 0;
            view = Emval.toValue(view);
            var a = new Array(view.length);
            for (var i2 = 0; i2 < view.length; i2++)
              a[i2] = view[i2];
            return Emval.toHandle(a);
          }
          __emval_new_array_from_memory_view.sig = "pp";
          function __emval_new_object() {
            return Emval.toHandle({});
          }
          __emval_new_object.sig = "p";
          function __emval_new_cstring(v) {
            v >>>= 0;
            return Emval.toHandle(getStringOrSymbol(v));
          }
          __emval_new_cstring.sig = "pp";
          function __emval_new_u8string(v) {
            v >>>= 0;
            return Emval.toHandle(UTF8ToString(v));
          }
          __emval_new_u8string.sig = "pp";
          function __emval_new_u16string(v) {
            v >>>= 0;
            return Emval.toHandle(UTF16ToString(v));
          }
          __emval_new_u16string.sig = "pp";
          function __emval_take_value(type, arg) {
            type >>>= 0;
            arg >>>= 0;
            type = requireRegisteredType(type, "_emval_take_value");
            var v = type["readValueFromPointer"](arg);
            return Emval.toHandle(v);
          }
          __emval_take_value.sig = "ppp";
          var emval_get_global = () => {
            if (typeof globalThis == "object") {
              return globalThis;
            }
            return (/* @__PURE__ */ function() {
              return Function;
            }())("return this")();
          };
          function __emval_get_global(name2) {
            name2 >>>= 0;
            if (name2 === 0) {
              return Emval.toHandle(emval_get_global());
            } else {
              name2 = getStringOrSymbol(name2);
              return Emval.toHandle(emval_get_global()[name2]);
            }
          }
          __emval_get_global.sig = "pp";
          function __emval_get_module_property(name2) {
            name2 >>>= 0;
            name2 = getStringOrSymbol(name2);
            return Emval.toHandle(Module[name2]);
          }
          __emval_get_module_property.sig = "pp";
          function __emval_get_property(handle2, key) {
            handle2 >>>= 0;
            key >>>= 0;
            handle2 = Emval.toValue(handle2);
            key = Emval.toValue(key);
            return Emval.toHandle(handle2[key]);
          }
          __emval_get_property.sig = "ppp";
          function __emval_set_property(handle2, key, value) {
            handle2 >>>= 0;
            key >>>= 0;
            value >>>= 0;
            handle2 = Emval.toValue(handle2);
            key = Emval.toValue(key);
            value = Emval.toValue(value);
            handle2[key] = value;
          }
          __emval_set_property.sig = "vppp";
          var emval_returnValue = (returnType, destructorsRef, handle2) => {
            var destructors = [];
            var result = returnType["toWireType"](destructors, handle2);
            if (destructors.length) {
              HEAPU32[destructorsRef >>> 2 >>> 0] = Emval.toHandle(destructors);
            }
            return result;
          };
          function __emval_as(handle2, returnType, destructorsRef) {
            handle2 >>>= 0;
            returnType >>>= 0;
            destructorsRef >>>= 0;
            handle2 = Emval.toValue(handle2);
            returnType = requireRegisteredType(returnType, "emval::as");
            return emval_returnValue(returnType, destructorsRef, handle2);
          }
          __emval_as.sig = "dppp";
          function __emval_as_int64(handle2, returnType) {
            handle2 >>>= 0;
            returnType >>>= 0;
            handle2 = Emval.toValue(handle2);
            returnType = requireRegisteredType(returnType, "emval::as");
            return returnType["toWireType"](null, handle2);
          }
          __emval_as_int64.sig = "ipp";
          function __emval_as_uint64(handle2, returnType) {
            handle2 >>>= 0;
            returnType >>>= 0;
            handle2 = Emval.toValue(handle2);
            returnType = requireRegisteredType(returnType, "emval::as");
            return returnType["toWireType"](null, handle2);
          }
          __emval_as_uint64.sig = "ipp";
          function __emval_equals(first, second) {
            first >>>= 0;
            second >>>= 0;
            first = Emval.toValue(first);
            second = Emval.toValue(second);
            return first == second;
          }
          __emval_equals.sig = "ipp";
          function __emval_strictly_equals(first, second) {
            first >>>= 0;
            second >>>= 0;
            first = Emval.toValue(first);
            second = Emval.toValue(second);
            return first === second;
          }
          __emval_strictly_equals.sig = "ipp";
          function __emval_greater_than(first, second) {
            first >>>= 0;
            second >>>= 0;
            first = Emval.toValue(first);
            second = Emval.toValue(second);
            return first > second;
          }
          __emval_greater_than.sig = "ipp";
          function __emval_less_than(first, second) {
            first >>>= 0;
            second >>>= 0;
            first = Emval.toValue(first);
            second = Emval.toValue(second);
            return first < second;
          }
          __emval_less_than.sig = "ipp";
          function __emval_not(object) {
            object >>>= 0;
            object = Emval.toValue(object);
            return !object;
          }
          __emval_not.sig = "ip";
          var emval_methodCallers = [];
          function __emval_call(caller, handle2, destructorsRef, args2) {
            caller >>>= 0;
            handle2 >>>= 0;
            destructorsRef >>>= 0;
            args2 >>>= 0;
            caller = emval_methodCallers[caller];
            handle2 = Emval.toValue(handle2);
            return caller(null, handle2, destructorsRef, args2);
          }
          __emval_call.sig = "dpppp";
          var emval_lookupTypes = (argCount, argTypes) => {
            var a = new Array(argCount);
            for (var i2 = 0; i2 < argCount; ++i2) {
              a[i2] = requireRegisteredType(HEAPU32[argTypes + i2 * 4 >>> 2 >>> 0], "parameter " + i2);
            }
            return a;
          };
          var emval_addMethodCaller = (caller) => {
            var id = emval_methodCallers.length;
            emval_methodCallers.push(caller);
            return id;
          };
          var reflectConstruct = Reflect.construct;
          function __emval_get_method_caller(argCount, argTypes, kind) {
            argTypes >>>= 0;
            var types = emval_lookupTypes(argCount, argTypes);
            var retType = types.shift();
            argCount--;
            var functionBody = `return function (obj, func, destructorsRef, args) {
`;
            var offset = 0;
            var argsList = [];
            if (kind === 0) {
              argsList.push("obj");
            }
            var params = ["retType"];
            var args2 = [retType];
            for (var i2 = 0; i2 < argCount; ++i2) {
              argsList.push("arg" + i2);
              params.push("argType" + i2);
              args2.push(types[i2]);
              functionBody += `  var arg${i2} = argType${i2}.readValueFromPointer(args${offset ? "+" + offset : ""});
`;
              offset += types[i2]["argPackAdvance"];
            }
            var invoker = kind === 1 ? "new func" : "func.call";
            functionBody += `  var rv = ${invoker}(${argsList.join(", ")});
`;
            if (!retType.isVoid) {
              params.push("emval_returnValue");
              args2.push(emval_returnValue);
              functionBody += "  return emval_returnValue(retType, destructorsRef, rv);\n";
            }
            functionBody += "};\n";
            params.push(functionBody);
            var invokerFunction = newFunc(Function, params).apply(null, args2);
            var functionName = `methodCaller<(${types.map((t) => t.name).join(", ")}) => ${retType.name}>`;
            return emval_addMethodCaller(createNamedFunction(functionName, invokerFunction));
          }
          __emval_get_method_caller.sig = "pipi";
          function __emval_call_method(caller, objHandle, methodName, destructorsRef, args2) {
            caller >>>= 0;
            objHandle >>>= 0;
            methodName >>>= 0;
            destructorsRef >>>= 0;
            args2 >>>= 0;
            caller = emval_methodCallers[caller];
            objHandle = Emval.toValue(objHandle);
            methodName = getStringOrSymbol(methodName);
            return caller(objHandle, objHandle[methodName], destructorsRef, args2);
          }
          __emval_call_method.sig = "dppppp";
          function __emval_typeof(handle2) {
            handle2 >>>= 0;
            handle2 = Emval.toValue(handle2);
            return Emval.toHandle(typeof handle2);
          }
          __emval_typeof.sig = "pp";
          function __emval_instanceof(object, constructor) {
            object >>>= 0;
            constructor >>>= 0;
            object = Emval.toValue(object);
            constructor = Emval.toValue(constructor);
            return object instanceof constructor;
          }
          __emval_instanceof.sig = "ipp";
          function __emval_is_number(handle2) {
            handle2 >>>= 0;
            handle2 = Emval.toValue(handle2);
            return typeof handle2 == "number";
          }
          __emval_is_number.sig = "ip";
          function __emval_is_string(handle2) {
            handle2 >>>= 0;
            handle2 = Emval.toValue(handle2);
            return typeof handle2 == "string";
          }
          __emval_is_string.sig = "ip";
          function __emval_in(item, object) {
            item >>>= 0;
            object >>>= 0;
            item = Emval.toValue(item);
            object = Emval.toValue(object);
            return item in object;
          }
          __emval_in.sig = "ipp";
          function __emval_delete(object, property) {
            object >>>= 0;
            property >>>= 0;
            object = Emval.toValue(object);
            property = Emval.toValue(property);
            return delete object[property];
          }
          __emval_delete.sig = "ipp";
          function __emval_throw(object) {
            object >>>= 0;
            object = Emval.toValue(object);
            throw object;
          }
          __emval_throw.sig = "ip";
          function __emval_iter_begin(iterable) {
            iterable >>>= 0;
            iterable = Emval.toValue(iterable);
            return Emval.toHandle(iterable[Symbol.iterator]());
          }
          __emval_iter_begin.sig = "pp";
          function __emval_iter_next(iterator) {
            iterator >>>= 0;
            iterator = Emval.toValue(iterator);
            var result = iterator.next();
            return result.done ? 0 : Emval.toHandle(result.value);
          }
          __emval_iter_next.sig = "pp";
          var __emval_coro_suspend = function(promiseHandle, awaiterPtr) {
            promiseHandle >>>= 0;
            awaiterPtr >>>= 0;
            Emval.toValue(promiseHandle).then((result) => {
              __emval_coro_resume(awaiterPtr, Emval.toHandle(result));
            });
          };
          __emval_coro_suspend.sig = "vpp";
          var __emval_coro_make_promise = function(resolveHandlePtr, rejectHandlePtr) {
            resolveHandlePtr >>>= 0;
            rejectHandlePtr >>>= 0;
            return Emval.toHandle(new Promise((resolve, reject) => {
              const rejectWithCurrentException = () => {
                try {
                  ___cxa_rethrow();
                } catch (e) {
                  reject(e);
                }
              };
              HEAPU32[resolveHandlePtr >>> 2 >>> 0] = Emval.toHandle(resolve);
              HEAPU32[rejectHandlePtr >>> 2 >>> 0] = Emval.toHandle(rejectWithCurrentException);
            }));
          };
          __emval_coro_make_promise.sig = "ppp";
          function _duckdb_web_fs_file_sync(fileId) {
            return globalThis.DUCKDB_RUNTIME.syncFile(Module, fileId);
          }
          _duckdb_web_fs_file_sync.sig = "vi";
          function _duckdb_web_fs_file_remove(path, pathLen) {
            return globalThis.DUCKDB_RUNTIME.removeFile(Module, path, pathLen);
          }
          registerWasmPlugin();
          var FSNode = function(parent, name2, mode, rdev) {
            if (!parent) {
              parent = this;
            }
            this.parent = parent;
            this.mount = parent.mount;
            this.mounted = null;
            this.id = FS.nextInode++;
            this.name = name2;
            this.mode = mode;
            this.node_ops = {};
            this.stream_ops = {};
            this.rdev = rdev;
          };
          var readMode = 292 | 73;
          var writeMode = 146;
          Object.defineProperties(FSNode.prototype, {
            read: {
              get: function() {
                return (this.mode & readMode) === readMode;
              },
              set: function(val) {
                val ? this.mode |= readMode : this.mode &= ~readMode;
              }
            },
            write: {
              get: function() {
                return (this.mode & writeMode) === writeMode;
              },
              set: function(val) {
                val ? this.mode |= writeMode : this.mode &= ~writeMode;
              }
            },
            isFolder: {
              get: function() {
                return FS.isDir(this.mode);
              }
            },
            isDevice: {
              get: function() {
                return FS.isChrdev(this.mode);
              }
            }
          });
          FS.FSNode = FSNode;
          FS.createPreloadedFile = FS_createPreloadedFile;
          FS.staticInit();
          embind_init_charCodes();
          BindingError = Module["BindingError"] = class BindingError extends Error {
            constructor(message) {
              super(message);
              this.name = "BindingError";
            }
          };
          InternalError = Module["InternalError"] = class InternalError extends Error {
            constructor(message) {
              super(message);
              this.name = "InternalError";
            }
          };
          init_emval();
          Module["requestFullscreen"] = Browser.requestFullscreen;
          Module["requestAnimationFrame"] = Browser.requestAnimationFrame;
          Module["setCanvasSize"] = Browser.setCanvasSize;
          Module["pauseMainLoop"] = Browser.mainLoop.pause;
          Module["resumeMainLoop"] = Browser.mainLoop.resume;
          Module["getUserMedia"] = Browser.getUserMedia;
          Module["createContext"] = Browser.createContext;
          var preloadedImages = {};
          var preloadedAudios = {};
          var GLctx;
          for (var i = 0; i < 32; ++i)
            tempFixedLengthArray.push(new Array(i));
          var miniTempWebGLFloatBuffersStorage = new Float32Array(288);
          for (var i = 0; i < 288; ++i) {
            miniTempWebGLFloatBuffers[i] = miniTempWebGLFloatBuffersStorage.subarray(0, i + 1);
          }
          var miniTempWebGLIntBuffersStorage = new Int32Array(288);
          for (var i = 0; i < 288; ++i) {
            miniTempWebGLIntBuffers[i] = miniTempWebGLIntBuffersStorage.subarray(0, i + 1);
          }
          var emSetImmediate;
          var emClearImmediate;
          if (typeof setImmediate != "undefined") {
            emSetImmediate = setImmediateWrapped;
            emClearImmediate = clearImmediateWrapped;
          } else if (typeof addEventListener == "function") {
            var __setImmediate_id_counter = 0;
            var __setImmediate_queue = [];
            var __setImmediate_message_id = "_si";
            var __setImmediate_cb = (e) => {
              if (e.data === __setImmediate_message_id) {
                e.stopPropagation();
                __setImmediate_queue.shift()();
                ++__setImmediate_id_counter;
              }
            };
            addEventListener("message", __setImmediate_cb, true);
            emSetImmediate = (func2) => {
              postMessage(__setImmediate_message_id, "*");
              return __setImmediate_id_counter + __setImmediate_queue.push(func2) - 1;
            };
            emClearImmediate = (id) => {
              var index = id - __setImmediate_id_counter;
              if (index >= 0 && index < __setImmediate_queue.length)
                __setImmediate_queue[index] = () => {
                };
            };
          }
          UnboundTypeError = Module["UnboundTypeError"] = extendError(Error, "UnboundTypeError");
          PureVirtualError = Module["PureVirtualError"] = extendError(Error, "PureVirtualError");
          init_embind();
          init_RegisteredPointer();
          init_ClassHandle();
          var wasmImports = {
            IMG_Init: _IMG_Init,
            IMG_Load: _IMG_Load,
            IMG_Load_RW: _IMG_Load_RW,
            IMG_Quit: _IMG_Quit,
            Mix_AllocateChannels: _Mix_AllocateChannels,
            Mix_ChannelFinished: _Mix_ChannelFinished,
            Mix_CloseAudio: _Mix_CloseAudio,
            Mix_FadeInChannelTimed: _Mix_FadeInChannelTimed,
            Mix_FadeInMusicPos: _Mix_FadeInMusicPos,
            Mix_FadeOutChannel: _Mix_FadeOutChannel,
            Mix_FadeOutMusic: _Mix_FadeOutMusic,
            Mix_FadingChannel: _Mix_FadingChannel,
            Mix_FreeChunk: _Mix_FreeChunk,
            Mix_FreeMusic: _Mix_FreeMusic,
            Mix_HaltChannel: _Mix_HaltChannel,
            Mix_HaltMusic: _Mix_HaltMusic,
            Mix_HookMusicFinished: _Mix_HookMusicFinished,
            Mix_Init: _Mix_Init,
            Mix_Linked_Version: _Mix_Linked_Version,
            Mix_LoadMUS: _Mix_LoadMUS,
            Mix_LoadMUS_RW: _Mix_LoadMUS_RW,
            Mix_LoadWAV: _Mix_LoadWAV,
            Mix_LoadWAV_RW: _Mix_LoadWAV_RW,
            Mix_OpenAudio: _Mix_OpenAudio,
            Mix_Pause: _Mix_Pause,
            Mix_PauseMusic: _Mix_PauseMusic,
            Mix_Paused: _Mix_Paused,
            Mix_PausedMusic: _Mix_PausedMusic,
            Mix_PlayChannelTimed: _Mix_PlayChannelTimed,
            Mix_PlayMusic: _Mix_PlayMusic,
            Mix_Playing: _Mix_Playing,
            Mix_PlayingMusic: _Mix_PlayingMusic,
            Mix_QuerySpec: _Mix_QuerySpec,
            Mix_QuickLoad_RAW: _Mix_QuickLoad_RAW,
            Mix_Quit: _Mix_Quit,
            Mix_ReserveChannels: _Mix_ReserveChannels,
            Mix_Resume: _Mix_Resume,
            Mix_ResumeMusic: _Mix_ResumeMusic,
            Mix_SetPanning: _Mix_SetPanning,
            Mix_SetPosition: _Mix_SetPosition,
            Mix_SetPostMix: _Mix_SetPostMix,
            Mix_Volume: _Mix_Volume,
            Mix_VolumeChunk: _Mix_VolumeChunk,
            Mix_VolumeMusic: _Mix_VolumeMusic,
            SDL_AddTimer: _SDL_AddTimer,
            SDL_AllocRW: _SDL_AllocRW,
            SDL_AudioDriverName: _SDL_AudioDriverName,
            SDL_AudioQuit: _SDL_AudioQuit,
            SDL_ClearError: _SDL_ClearError,
            SDL_CloseAudio: _SDL_CloseAudio,
            SDL_CondBroadcast: _SDL_CondBroadcast,
            SDL_CondSignal: _SDL_CondSignal,
            SDL_CondWait: _SDL_CondWait,
            SDL_CondWaitTimeout: _SDL_CondWaitTimeout,
            SDL_ConvertSurface: _SDL_ConvertSurface,
            SDL_CreateCond: _SDL_CreateCond,
            SDL_CreateMutex: _SDL_CreateMutex,
            SDL_CreateRGBSurface: _SDL_CreateRGBSurface,
            SDL_CreateRGBSurfaceFrom: _SDL_CreateRGBSurfaceFrom,
            SDL_CreateThread: _SDL_CreateThread,
            SDL_Delay: _SDL_Delay,
            SDL_DestroyCond: _SDL_DestroyCond,
            SDL_DestroyMutex: _SDL_DestroyMutex,
            SDL_DestroyRenderer: _SDL_DestroyRenderer,
            SDL_DestroyWindow: _SDL_DestroyWindow,
            SDL_DisplayFormatAlpha: _SDL_DisplayFormatAlpha,
            SDL_EnableKeyRepeat: _SDL_EnableKeyRepeat,
            SDL_EnableUNICODE: _SDL_EnableUNICODE,
            SDL_FillRect: _SDL_FillRect,
            SDL_Flip: _SDL_Flip,
            SDL_FreeRW: _SDL_FreeRW,
            SDL_FreeSurface: _SDL_FreeSurface,
            SDL_GL_DeleteContext: _SDL_GL_DeleteContext,
            SDL_GL_ExtensionSupported: _SDL_GL_ExtensionSupported,
            SDL_GL_GetAttribute: _SDL_GL_GetAttribute,
            SDL_GL_GetSwapInterval: _SDL_GL_GetSwapInterval,
            SDL_GL_MakeCurrent: _SDL_GL_MakeCurrent,
            SDL_GL_SetAttribute: _SDL_GL_SetAttribute,
            SDL_GL_SetSwapInterval: _SDL_GL_SetSwapInterval,
            SDL_GL_SwapBuffers: _SDL_GL_SwapBuffers,
            SDL_GL_SwapWindow: _SDL_GL_SwapWindow,
            SDL_GetAppState: _SDL_GetAppState,
            SDL_GetAudioDriver: _SDL_GetAudioDriver,
            SDL_GetClipRect: _SDL_GetClipRect,
            SDL_GetCurrentAudioDriver: _SDL_GetCurrentAudioDriver,
            SDL_GetError: _SDL_GetError,
            SDL_GetKeyName: _SDL_GetKeyName,
            SDL_GetKeyState: _SDL_GetKeyState,
            SDL_GetKeyboardState: _SDL_GetKeyboardState,
            SDL_GetModState: _SDL_GetModState,
            SDL_GetMouseState: _SDL_GetMouseState,
            SDL_GetNumAudioDrivers: _SDL_GetNumAudioDrivers,
            SDL_GetRGB: _SDL_GetRGB,
            SDL_GetRGBA: _SDL_GetRGBA,
            SDL_GetScancodeFromKey: _SDL_GetScancodeFromKey,
            SDL_GetThreadID: _SDL_GetThreadID,
            SDL_GetTicks: _SDL_GetTicks,
            SDL_GetVideoInfo: _SDL_GetVideoInfo,
            SDL_GetVideoSurface: _SDL_GetVideoSurface,
            SDL_GetWindowFlags: _SDL_GetWindowFlags,
            SDL_GetWindowSize: _SDL_GetWindowSize,
            SDL_Has3DNow: _SDL_Has3DNow,
            SDL_Has3DNowExt: _SDL_Has3DNowExt,
            SDL_HasAltiVec: _SDL_HasAltiVec,
            SDL_HasMMX: _SDL_HasMMX,
            SDL_HasMMXExt: _SDL_HasMMXExt,
            SDL_HasRDTSC: _SDL_HasRDTSC,
            SDL_HasSSE: _SDL_HasSSE,
            SDL_HasSSE2: _SDL_HasSSE2,
            SDL_Init: _SDL_Init,
            SDL_InitSubSystem: _SDL_InitSubSystem,
            SDL_JoystickClose: _SDL_JoystickClose,
            SDL_JoystickEventState: _SDL_JoystickEventState,
            SDL_JoystickGetAxis: _SDL_JoystickGetAxis,
            SDL_JoystickGetBall: _SDL_JoystickGetBall,
            SDL_JoystickGetButton: _SDL_JoystickGetButton,
            SDL_JoystickGetHat: _SDL_JoystickGetHat,
            SDL_JoystickIndex: _SDL_JoystickIndex,
            SDL_JoystickName: _SDL_JoystickName,
            SDL_JoystickNumAxes: _SDL_JoystickNumAxes,
            SDL_JoystickNumBalls: _SDL_JoystickNumBalls,
            SDL_JoystickNumButtons: _SDL_JoystickNumButtons,
            SDL_JoystickNumHats: _SDL_JoystickNumHats,
            SDL_JoystickOpen: _SDL_JoystickOpen,
            SDL_JoystickOpened: _SDL_JoystickOpened,
            SDL_JoystickUpdate: _SDL_JoystickUpdate,
            SDL_Linked_Version: _SDL_Linked_Version,
            SDL_ListModes: _SDL_ListModes,
            SDL_LoadBMP_RW: _SDL_LoadBMP_RW,
            SDL_LockAudio: _SDL_LockAudio,
            SDL_LockSurface: _SDL_LockSurface,
            SDL_LogSetOutputFunction: _SDL_LogSetOutputFunction,
            SDL_LowerBlit: _SDL_LowerBlit,
            SDL_LowerBlitScaled: _SDL_LowerBlitScaled,
            SDL_MapRGB: _SDL_MapRGB,
            SDL_MapRGBA: _SDL_MapRGBA,
            SDL_NumJoysticks: _SDL_NumJoysticks,
            SDL_OpenAudio: _SDL_OpenAudio,
            SDL_PauseAudio: _SDL_PauseAudio,
            SDL_PeepEvents: _SDL_PeepEvents,
            SDL_PollEvent: _SDL_PollEvent,
            SDL_PumpEvents: _SDL_PumpEvents,
            SDL_PushEvent: _SDL_PushEvent,
            SDL_Quit: _SDL_Quit,
            SDL_QuitSubSystem: _SDL_QuitSubSystem,
            SDL_RWFromConstMem: _SDL_RWFromConstMem,
            SDL_RWFromFile: _SDL_RWFromFile,
            SDL_RWFromMem: _SDL_RWFromMem,
            SDL_RemoveTimer: _SDL_RemoveTimer,
            SDL_SaveBMP_RW: _SDL_SaveBMP_RW,
            SDL_SetAlpha: _SDL_SetAlpha,
            SDL_SetClipRect: _SDL_SetClipRect,
            SDL_SetColorKey: _SDL_SetColorKey,
            SDL_SetColors: _SDL_SetColors,
            SDL_SetError: _SDL_SetError,
            SDL_SetGamma: _SDL_SetGamma,
            SDL_SetGammaRamp: _SDL_SetGammaRamp,
            SDL_SetPalette: _SDL_SetPalette,
            SDL_SetVideoMode: _SDL_SetVideoMode,
            SDL_SetWindowFullscreen: _SDL_SetWindowFullscreen,
            SDL_SetWindowTitle: _SDL_SetWindowTitle,
            SDL_ShowCursor: _SDL_ShowCursor,
            SDL_StartTextInput: _SDL_StartTextInput,
            SDL_StopTextInput: _SDL_StopTextInput,
            SDL_ThreadID: _SDL_ThreadID,
            SDL_UnlockAudio: _SDL_UnlockAudio,
            SDL_UnlockSurface: _SDL_UnlockSurface,
            SDL_UpdateRect: _SDL_UpdateRect,
            SDL_UpdateRects: _SDL_UpdateRects,
            SDL_UpperBlit: _SDL_UpperBlit,
            SDL_UpperBlitScaled: _SDL_UpperBlitScaled,
            SDL_VideoDriverName: _SDL_VideoDriverName,
            SDL_VideoModeOK: _SDL_VideoModeOK,
            SDL_VideoQuit: _SDL_VideoQuit,
            SDL_WM_GrabInput: _SDL_WM_GrabInput,
            SDL_WM_IconifyWindow: _SDL_WM_IconifyWindow,
            SDL_WM_SetCaption: _SDL_WM_SetCaption,
            SDL_WM_SetIcon: _SDL_WM_SetIcon,
            SDL_WM_ToggleFullScreen: _SDL_WM_ToggleFullScreen,
            SDL_WaitThread: _SDL_WaitThread,
            SDL_WarpMouse: _SDL_WarpMouse,
            SDL_WasInit: _SDL_WasInit,
            SDL_mutexP: _SDL_mutexP,
            SDL_mutexV: _SDL_mutexV,
            TTF_CloseFont: _TTF_CloseFont,
            TTF_FontAscent: _TTF_FontAscent,
            TTF_FontDescent: _TTF_FontDescent,
            TTF_FontHeight: _TTF_FontHeight,
            TTF_FontLineSkip: _TTF_FontLineSkip,
            TTF_GlyphMetrics: _TTF_GlyphMetrics,
            TTF_Init: _TTF_Init,
            TTF_OpenFont: _TTF_OpenFont,
            TTF_Quit: _TTF_Quit,
            TTF_RenderText_Blended: _TTF_RenderText_Blended,
            TTF_RenderText_Shaded: _TTF_RenderText_Shaded,
            TTF_RenderText_Solid: _TTF_RenderText_Solid,
            TTF_RenderUTF8_Solid: _TTF_RenderUTF8_Solid,
            TTF_SizeText: _TTF_SizeText,
            TTF_SizeUTF8: _TTF_SizeUTF8,
            XChangeWindowAttributes: _XChangeWindowAttributes,
            XCreateWindow: _XCreateWindow,
            XInternAtom: _XInternAtom,
            XMapWindow: _XMapWindow,
            XOpenDisplay: _XOpenDisplay,
            XPending: _XPending,
            XSendEvent: _XSendEvent,
            XSetWMHints: _XSetWMHints,
            XStoreName: _XStoreName,
            _Unwind_Backtrace: __Unwind_Backtrace,
            _Unwind_DeleteException: __Unwind_DeleteException,
            _Unwind_FindEnclosingFunction: __Unwind_FindEnclosingFunction,
            _Unwind_GetIPInfo: __Unwind_GetIPInfo,
            _Unwind_RaiseException: __Unwind_RaiseException,
            __asctime_r: ___asctime_r,
            __assert_fail: ___assert_fail,
            __call_sighandler: ___call_sighandler,
            __cxa_begin_catch: ___cxa_begin_catch,
            __cxa_call_unexpected: ___cxa_call_unexpected,
            __cxa_current_primary_exception: ___cxa_current_primary_exception,
            __cxa_end_catch: ___cxa_end_catch,
            __cxa_find_matching_catch_2: ___cxa_find_matching_catch_2,
            __cxa_find_matching_catch_3: ___cxa_find_matching_catch_3,
            __cxa_find_matching_catch_4: ___cxa_find_matching_catch_4,
            __cxa_find_matching_catch_5: ___cxa_find_matching_catch_5,
            __cxa_find_matching_catch_6: ___cxa_find_matching_catch_6,
            __cxa_find_matching_catch_7: ___cxa_find_matching_catch_7,
            __cxa_get_exception_ptr: ___cxa_get_exception_ptr,
            __cxa_rethrow: ___cxa_rethrow,
            __cxa_rethrow_primary_exception: ___cxa_rethrow_primary_exception,
            __cxa_throw: ___cxa_throw,
            __cxa_uncaught_exceptions: ___cxa_uncaught_exceptions,
            __global_base: ___global_base,
            __heap_base: ___heap_base,
            __indirect_function_table: wasmTable,
            __memory_base: ___memory_base,
            __resumeException: ___resumeException,
            __stack_high: ___stack_high,
            __stack_low: ___stack_low,
            __stack_pointer: ___stack_pointer,
            __syscall__newselect: ___syscall__newselect,
            __syscall_accept4: ___syscall_accept4,
            __syscall_bind: ___syscall_bind,
            __syscall_chdir: ___syscall_chdir,
            __syscall_chmod: ___syscall_chmod,
            __syscall_connect: ___syscall_connect,
            __syscall_dup: ___syscall_dup,
            __syscall_dup3: ___syscall_dup3,
            __syscall_faccessat: ___syscall_faccessat,
            __syscall_fadvise64: ___syscall_fadvise64,
            __syscall_fallocate: ___syscall_fallocate,
            __syscall_fchdir: ___syscall_fchdir,
            __syscall_fchmod: ___syscall_fchmod,
            __syscall_fchmodat: ___syscall_fchmodat,
            __syscall_fchown32: ___syscall_fchown32,
            __syscall_fchownat: ___syscall_fchownat,
            __syscall_fcntl64: ___syscall_fcntl64,
            __syscall_fdatasync: ___syscall_fdatasync,
            __syscall_fstat64: ___syscall_fstat64,
            __syscall_fstatfs64: ___syscall_fstatfs64,
            __syscall_ftruncate64: ___syscall_ftruncate64,
            __syscall_getcwd: ___syscall_getcwd,
            __syscall_getdents64: ___syscall_getdents64,
            __syscall_getpeername: ___syscall_getpeername,
            __syscall_getsockname: ___syscall_getsockname,
            __syscall_getsockopt: ___syscall_getsockopt,
            __syscall_ioctl: ___syscall_ioctl,
            __syscall_listen: ___syscall_listen,
            __syscall_lstat64: ___syscall_lstat64,
            __syscall_mkdirat: ___syscall_mkdirat,
            __syscall_mknodat: ___syscall_mknodat,
            __syscall_newfstatat: ___syscall_newfstatat,
            __syscall_openat: ___syscall_openat,
            __syscall_pipe: ___syscall_pipe,
            __syscall_poll: ___syscall_poll,
            __syscall_readlinkat: ___syscall_readlinkat,
            __syscall_recvfrom: ___syscall_recvfrom,
            __syscall_recvmsg: ___syscall_recvmsg,
            __syscall_renameat: ___syscall_renameat,
            __syscall_rmdir: ___syscall_rmdir,
            __syscall_sendmsg: ___syscall_sendmsg,
            __syscall_sendto: ___syscall_sendto,
            __syscall_socket: ___syscall_socket,
            __syscall_stat64: ___syscall_stat64,
            __syscall_statfs64: ___syscall_statfs64,
            __syscall_symlink: ___syscall_symlink,
            __syscall_symlinkat: ___syscall_symlinkat,
            __syscall_truncate64: ___syscall_truncate64,
            __syscall_unlinkat: ___syscall_unlinkat,
            __syscall_utimensat: ___syscall_utimensat,
            __table_base: ___table_base,
            _dlopen_js: __dlopen_js,
            _dlsym_catchup_js: __dlsym_catchup_js,
            _dlsym_js: __dlsym_js,
            _embind_create_inheriting_constructor: __embind_create_inheriting_constructor,
            _embind_finalize_value_array: __embind_finalize_value_array,
            _embind_finalize_value_object: __embind_finalize_value_object,
            _embind_register_bigint: __embind_register_bigint,
            _embind_register_bool: __embind_register_bool,
            _embind_register_class: __embind_register_class,
            _embind_register_class_class_function: __embind_register_class_class_function,
            _embind_register_class_class_property: __embind_register_class_class_property,
            _embind_register_class_constructor: __embind_register_class_constructor,
            _embind_register_class_function: __embind_register_class_function,
            _embind_register_class_property: __embind_register_class_property,
            _embind_register_constant: __embind_register_constant,
            _embind_register_emval: __embind_register_emval,
            _embind_register_enum: __embind_register_enum,
            _embind_register_enum_value: __embind_register_enum_value,
            _embind_register_float: __embind_register_float,
            _embind_register_function: __embind_register_function,
            _embind_register_integer: __embind_register_integer,
            _embind_register_memory_view: __embind_register_memory_view,
            _embind_register_optional: __embind_register_optional,
            _embind_register_smart_ptr: __embind_register_smart_ptr,
            _embind_register_std_string: __embind_register_std_string,
            _embind_register_std_wstring: __embind_register_std_wstring,
            _embind_register_user_type: __embind_register_user_type,
            _embind_register_value_array: __embind_register_value_array,
            _embind_register_value_array_element: __embind_register_value_array_element,
            _embind_register_value_object: __embind_register_value_object,
            _embind_register_value_object_field: __embind_register_value_object_field,
            _embind_register_void: __embind_register_void,
            _emscripten_dlopen_js: __emscripten_dlopen_js,
            _emscripten_fs_load_embedded_files: __emscripten_fs_load_embedded_files,
            _emscripten_get_now_is_monotonic: __emscripten_get_now_is_monotonic,
            _emscripten_get_progname: __emscripten_get_progname,
            _emscripten_lookup_name: __emscripten_lookup_name,
            _emscripten_push_main_loop_blocker: __emscripten_push_main_loop_blocker,
            _emscripten_push_uncounted_main_loop_blocker: __emscripten_push_uncounted_main_loop_blocker,
            _emscripten_runtime_keepalive_clear: __emscripten_runtime_keepalive_clear,
            _emscripten_set_offscreencanvas_size: __emscripten_set_offscreencanvas_size,
            _emscripten_system: __emscripten_system,
            _emscripten_throw_longjmp: __emscripten_throw_longjmp,
            _emval_as: __emval_as,
            _emval_as_int64: __emval_as_int64,
            _emval_as_uint64: __emval_as_uint64,
            _emval_call: __emval_call,
            _emval_call_method: __emval_call_method,
            _emval_coro_make_promise: __emval_coro_make_promise,
            _emval_coro_suspend: __emval_coro_suspend,
            _emval_decref: __emval_decref,
            _emval_delete: __emval_delete,
            _emval_equals: __emval_equals,
            _emval_get_global: __emval_get_global,
            _emval_get_method_caller: __emval_get_method_caller,
            _emval_get_module_property: __emval_get_module_property,
            _emval_get_property: __emval_get_property,
            _emval_greater_than: __emval_greater_than,
            _emval_in: __emval_in,
            _emval_incref: __emval_incref,
            _emval_instanceof: __emval_instanceof,
            _emval_is_number: __emval_is_number,
            _emval_is_string: __emval_is_string,
            _emval_iter_begin: __emval_iter_begin,
            _emval_iter_next: __emval_iter_next,
            _emval_less_than: __emval_less_than,
            _emval_new_array: __emval_new_array,
            _emval_new_array_from_memory_view: __emval_new_array_from_memory_view,
            _emval_new_cstring: __emval_new_cstring,
            _emval_new_object: __emval_new_object,
            _emval_new_u16string: __emval_new_u16string,
            _emval_new_u8string: __emval_new_u8string,
            _emval_not: __emval_not,
            _emval_register_symbol: __emval_register_symbol,
            _emval_run_destructors: __emval_run_destructors,
            _emval_set_property: __emval_set_property,
            _emval_strictly_equals: __emval_strictly_equals,
            _emval_take_value: __emval_take_value,
            _emval_throw: __emval_throw,
            _emval_typeof: __emval_typeof,
            _glGenObject: __glGenObject,
            _glGetActiveAttribOrUniform: __glGetActiveAttribOrUniform,
            _gmtime_js: __gmtime_js,
            _localtime_js: __localtime_js,
            _mktime_js: __mktime_js,
            _mmap_js: __mmap_js,
            _msync_js: __msync_js,
            _munmap_js: __munmap_js,
            _setitimer_js: __setitimer_js,
            _timegm_js: __timegm_js,
            _tzset_js: __tzset_js,
            abort: _abort,
            alBuffer3f: _alBuffer3f,
            alBuffer3i: _alBuffer3i,
            alBufferData: _alBufferData,
            alBufferf: _alBufferf,
            alBufferfv: _alBufferfv,
            alBufferi: _alBufferi,
            alBufferiv: _alBufferiv,
            alDeleteBuffers: _alDeleteBuffers,
            alDeleteSources: _alDeleteSources,
            alDisable: _alDisable,
            alDistanceModel: _alDistanceModel,
            alDopplerFactor: _alDopplerFactor,
            alDopplerVelocity: _alDopplerVelocity,
            alEnable: _alEnable,
            alGenBuffers: _alGenBuffers,
            alGenSources: _alGenSources,
            alGetBoolean: _alGetBoolean,
            alGetBooleanv: _alGetBooleanv,
            alGetBuffer3f: _alGetBuffer3f,
            alGetBuffer3i: _alGetBuffer3i,
            alGetBufferf: _alGetBufferf,
            alGetBufferfv: _alGetBufferfv,
            alGetBufferi: _alGetBufferi,
            alGetBufferiv: _alGetBufferiv,
            alGetDouble: _alGetDouble,
            alGetDoublev: _alGetDoublev,
            alGetEnumValue: _alGetEnumValue,
            alGetError: _alGetError,
            alGetFloat: _alGetFloat,
            alGetFloatv: _alGetFloatv,
            alGetInteger: _alGetInteger,
            alGetIntegerv: _alGetIntegerv,
            alGetListener3f: _alGetListener3f,
            alGetListener3i: _alGetListener3i,
            alGetListenerf: _alGetListenerf,
            alGetListenerfv: _alGetListenerfv,
            alGetListeneri: _alGetListeneri,
            alGetListeneriv: _alGetListeneriv,
            alGetSource3f: _alGetSource3f,
            alGetSource3i: _alGetSource3i,
            alGetSourcef: _alGetSourcef,
            alGetSourcefv: _alGetSourcefv,
            alGetSourcei: _alGetSourcei,
            alGetSourceiv: _alGetSourceiv,
            alGetString: _alGetString,
            alIsBuffer: _alIsBuffer,
            alIsEnabled: _alIsEnabled,
            alIsExtensionPresent: _alIsExtensionPresent,
            alIsSource: _alIsSource,
            alListener3f: _alListener3f,
            alListener3i: _alListener3i,
            alListenerf: _alListenerf,
            alListenerfv: _alListenerfv,
            alListeneri: _alListeneri,
            alListeneriv: _alListeneriv,
            alSource3f: _alSource3f,
            alSource3i: _alSource3i,
            alSourcePause: _alSourcePause,
            alSourcePausev: _alSourcePausev,
            alSourcePlay: _alSourcePlay,
            alSourcePlayv: _alSourcePlayv,
            alSourceQueueBuffers: _alSourceQueueBuffers,
            alSourceRewind: _alSourceRewind,
            alSourceRewindv: _alSourceRewindv,
            alSourceStop: _alSourceStop,
            alSourceStopv: _alSourceStopv,
            alSourceUnqueueBuffers: _alSourceUnqueueBuffers,
            alSourcef: _alSourcef,
            alSourcefv: _alSourcefv,
            alSourcei: _alSourcei,
            alSourceiv: _alSourceiv,
            alSpeedOfSound: _alSpeedOfSound,
            alcCaptureCloseDevice: _alcCaptureCloseDevice,
            alcCaptureOpenDevice: _alcCaptureOpenDevice,
            alcCaptureSamples: _alcCaptureSamples,
            alcCaptureStart: _alcCaptureStart,
            alcCaptureStop: _alcCaptureStop,
            alcCloseDevice: _alcCloseDevice,
            alcCreateContext: _alcCreateContext,
            alcDestroyContext: _alcDestroyContext,
            alcGetContextsDevice: _alcGetContextsDevice,
            alcGetCurrentContext: _alcGetCurrentContext,
            alcGetEnumValue: _alcGetEnumValue,
            alcGetError: _alcGetError,
            alcGetIntegerv: _alcGetIntegerv,
            alcGetString: _alcGetString,
            alcIsExtensionPresent: _alcIsExtensionPresent,
            alcMakeContextCurrent: _alcMakeContextCurrent,
            alcOpenDevice: _alcOpenDevice,
            alcProcessContext: _alcProcessContext,
            alcSuspendContext: _alcSuspendContext,
            boxColor: _boxColor,
            boxRGBA: _boxRGBA,
            clock_res_get: _clock_res_get,
            clock_time_get: _clock_time_get,
            duckdb_web_fs_directory_create: _duckdb_web_fs_directory_create,
            duckdb_web_fs_directory_exists: _duckdb_web_fs_directory_exists,
            duckdb_web_fs_directory_list_files: _duckdb_web_fs_directory_list_files,
            duckdb_web_fs_directory_remove: _duckdb_web_fs_directory_remove,
            duckdb_web_fs_file_close: _duckdb_web_fs_file_close,
            duckdb_web_fs_file_exists: _duckdb_web_fs_file_exists,
            duckdb_web_fs_file_get_last_modified_time: _duckdb_web_fs_file_get_last_modified_time,
            duckdb_web_fs_file_move: _duckdb_web_fs_file_move,
            duckdb_web_fs_file_open: _duckdb_web_fs_file_open,
            duckdb_web_fs_file_read: _duckdb_web_fs_file_read,
            duckdb_web_fs_file_remove: _duckdb_web_fs_file_remove,
            duckdb_web_fs_file_sync: _duckdb_web_fs_file_sync,
            duckdb_web_fs_file_truncate: _duckdb_web_fs_file_truncate,
            duckdb_web_fs_file_write: _duckdb_web_fs_file_write,
            duckdb_web_fs_get_default_data_protocol: _duckdb_web_fs_get_default_data_protocol,
            duckdb_web_fs_glob: _duckdb_web_fs_glob,
            duckdb_web_test_platform_feature: _duckdb_web_test_platform_feature,
            duckdb_web_udf_scalar_call: _duckdb_web_udf_scalar_call,
            eglBindAPI: _eglBindAPI,
            eglChooseConfig: _eglChooseConfig,
            eglCreateContext: _eglCreateContext,
            eglCreateWindowSurface: _eglCreateWindowSurface,
            eglDestroyContext: _eglDestroyContext,
            eglDestroySurface: _eglDestroySurface,
            eglGetConfigAttrib: _eglGetConfigAttrib,
            eglGetConfigs: _eglGetConfigs,
            eglGetCurrentContext: _eglGetCurrentContext,
            eglGetCurrentDisplay: _eglGetCurrentDisplay,
            eglGetCurrentSurface: _eglGetCurrentSurface,
            eglGetDisplay: _eglGetDisplay,
            eglGetError: _eglGetError,
            eglInitialize: _eglInitialize,
            eglMakeCurrent: _eglMakeCurrent,
            eglQueryAPI: _eglQueryAPI,
            eglQueryContext: _eglQueryContext,
            eglQueryString: _eglQueryString,
            eglQuerySurface: _eglQuerySurface,
            eglReleaseThread: _eglReleaseThread,
            eglSwapBuffers: _eglSwapBuffers,
            eglSwapInterval: _eglSwapInterval,
            eglTerminate: _eglTerminate,
            eglWaitClient: _eglWaitClient,
            eglWaitGL: _eglWaitGL,
            eglWaitNative: _eglWaitNative,
            ellipseColor: _ellipseColor,
            ellipseRGBA: _ellipseRGBA,
            emscripten_SDL_SetEventHandler: _emscripten_SDL_SetEventHandler,
            emscripten_alcDevicePauseSOFT: _emscripten_alcDevicePauseSOFT,
            emscripten_alcDeviceResumeSOFT: _emscripten_alcDeviceResumeSOFT,
            emscripten_alcGetStringiSOFT: _emscripten_alcGetStringiSOFT,
            emscripten_alcResetDeviceSOFT: _emscripten_alcResetDeviceSOFT,
            emscripten_asm_const_async_on_main_thread: _emscripten_asm_const_async_on_main_thread,
            emscripten_asm_const_double: _emscripten_asm_const_double,
            emscripten_asm_const_double_sync_on_main_thread: _emscripten_asm_const_double_sync_on_main_thread,
            emscripten_asm_const_int: _emscripten_asm_const_int,
            emscripten_asm_const_int_sync_on_main_thread: _emscripten_asm_const_int_sync_on_main_thread,
            emscripten_asm_const_ptr: _emscripten_asm_const_ptr,
            emscripten_asm_const_ptr_sync_on_main_thread: _emscripten_asm_const_ptr_sync_on_main_thread,
            emscripten_async_call: _emscripten_async_call,
            emscripten_async_load_script: _emscripten_async_load_script,
            emscripten_async_run_script: _emscripten_async_run_script,
            emscripten_async_wget: _emscripten_async_wget,
            emscripten_async_wget2: _emscripten_async_wget2,
            emscripten_async_wget2_abort: _emscripten_async_wget2_abort,
            emscripten_async_wget2_data: _emscripten_async_wget2_data,
            emscripten_async_wget_data: _emscripten_async_wget_data,
            emscripten_call_worker: _emscripten_call_worker,
            emscripten_cancel_animation_frame: _emscripten_cancel_animation_frame,
            emscripten_cancel_main_loop: _emscripten_cancel_main_loop,
            emscripten_clear_immediate: _emscripten_clear_immediate,
            emscripten_clear_interval: _emscripten_clear_interval,
            emscripten_clear_timeout: _emscripten_clear_timeout,
            emscripten_console_error: _emscripten_console_error,
            emscripten_console_log: _emscripten_console_log,
            emscripten_console_warn: _emscripten_console_warn,
            emscripten_create_worker: _emscripten_create_worker,
            emscripten_date_now: _emscripten_date_now,
            emscripten_debugger: _emscripten_debugger,
            emscripten_destroy_worker: _emscripten_destroy_worker,
            emscripten_enter_soft_fullscreen: _emscripten_enter_soft_fullscreen,
            emscripten_err: _emscripten_err,
            emscripten_errn: _emscripten_errn,
            emscripten_exit_fullscreen: _emscripten_exit_fullscreen,
            emscripten_exit_pointerlock: _emscripten_exit_pointerlock,
            emscripten_exit_soft_fullscreen: _emscripten_exit_soft_fullscreen,
            emscripten_exit_with_live_runtime: _emscripten_exit_with_live_runtime,
            emscripten_fiber_swap: _emscripten_fiber_swap,
            emscripten_force_exit: _emscripten_force_exit,
            emscripten_get_battery_status: _emscripten_get_battery_status,
            emscripten_get_callstack: _emscripten_get_callstack,
            emscripten_get_canvas_element_size: _emscripten_get_canvas_element_size,
            emscripten_get_canvas_size: _emscripten_get_canvas_size,
            emscripten_get_compiler_setting: _emscripten_get_compiler_setting,
            emscripten_get_device_pixel_ratio: _emscripten_get_device_pixel_ratio,
            emscripten_get_devicemotion_status: _emscripten_get_devicemotion_status,
            emscripten_get_deviceorientation_status: _emscripten_get_deviceorientation_status,
            emscripten_get_element_css_size: _emscripten_get_element_css_size,
            emscripten_get_fullscreen_status: _emscripten_get_fullscreen_status,
            emscripten_get_gamepad_status: _emscripten_get_gamepad_status,
            emscripten_get_heap_max: _emscripten_get_heap_max,
            emscripten_get_main_loop_timing: _emscripten_get_main_loop_timing,
            emscripten_get_module_name: _emscripten_get_module_name,
            emscripten_get_mouse_status: _emscripten_get_mouse_status,
            emscripten_get_now: _emscripten_get_now,
            emscripten_get_now_res: _emscripten_get_now_res,
            emscripten_get_num_gamepads: _emscripten_get_num_gamepads,
            emscripten_get_orientation_status: _emscripten_get_orientation_status,
            emscripten_get_pointerlock_status: _emscripten_get_pointerlock_status,
            emscripten_get_preloaded_image_data: _emscripten_get_preloaded_image_data,
            emscripten_get_preloaded_image_data_from_FILE: _emscripten_get_preloaded_image_data_from_FILE,
            emscripten_get_screen_size: _emscripten_get_screen_size,
            emscripten_get_visibility_status: _emscripten_get_visibility_status,
            emscripten_get_window_title: _emscripten_get_window_title,
            emscripten_get_worker_queue_size: _emscripten_get_worker_queue_size,
            emscripten_glActiveTexture: _emscripten_glActiveTexture,
            emscripten_glAttachShader: _emscripten_glAttachShader,
            emscripten_glBegin: _emscripten_glBegin,
            emscripten_glBeginQueryEXT: _emscripten_glBeginQueryEXT,
            emscripten_glBindAttribLocation: _emscripten_glBindAttribLocation,
            emscripten_glBindBuffer: _emscripten_glBindBuffer,
            emscripten_glBindFramebuffer: _emscripten_glBindFramebuffer,
            emscripten_glBindRenderbuffer: _emscripten_glBindRenderbuffer,
            emscripten_glBindTexture: _emscripten_glBindTexture,
            emscripten_glBindVertexArray: _emscripten_glBindVertexArray,
            emscripten_glBindVertexArrayOES: _emscripten_glBindVertexArrayOES,
            emscripten_glBlendColor: _emscripten_glBlendColor,
            emscripten_glBlendEquation: _emscripten_glBlendEquation,
            emscripten_glBlendEquationSeparate: _emscripten_glBlendEquationSeparate,
            emscripten_glBlendFunc: _emscripten_glBlendFunc,
            emscripten_glBlendFuncSeparate: _emscripten_glBlendFuncSeparate,
            emscripten_glBufferData: _emscripten_glBufferData,
            emscripten_glBufferSubData: _emscripten_glBufferSubData,
            emscripten_glCheckFramebufferStatus: _emscripten_glCheckFramebufferStatus,
            emscripten_glClear: _emscripten_glClear,
            emscripten_glClearColor: _emscripten_glClearColor,
            emscripten_glClearDepth: _emscripten_glClearDepth,
            emscripten_glClearDepthf: _emscripten_glClearDepthf,
            emscripten_glClearStencil: _emscripten_glClearStencil,
            emscripten_glColorMask: _emscripten_glColorMask,
            emscripten_glCompileShader: _emscripten_glCompileShader,
            emscripten_glCompressedTexImage2D: _emscripten_glCompressedTexImage2D,
            emscripten_glCompressedTexSubImage2D: _emscripten_glCompressedTexSubImage2D,
            emscripten_glCopyTexImage2D: _emscripten_glCopyTexImage2D,
            emscripten_glCopyTexSubImage2D: _emscripten_glCopyTexSubImage2D,
            emscripten_glCreateProgram: _emscripten_glCreateProgram,
            emscripten_glCreateShader: _emscripten_glCreateShader,
            emscripten_glCullFace: _emscripten_glCullFace,
            emscripten_glDeleteBuffers: _emscripten_glDeleteBuffers,
            emscripten_glDeleteFramebuffers: _emscripten_glDeleteFramebuffers,
            emscripten_glDeleteProgram: _emscripten_glDeleteProgram,
            emscripten_glDeleteQueriesEXT: _emscripten_glDeleteQueriesEXT,
            emscripten_glDeleteRenderbuffers: _emscripten_glDeleteRenderbuffers,
            emscripten_glDeleteShader: _emscripten_glDeleteShader,
            emscripten_glDeleteTextures: _emscripten_glDeleteTextures,
            emscripten_glDeleteVertexArrays: _emscripten_glDeleteVertexArrays,
            emscripten_glDeleteVertexArraysOES: _emscripten_glDeleteVertexArraysOES,
            emscripten_glDepthFunc: _emscripten_glDepthFunc,
            emscripten_glDepthMask: _emscripten_glDepthMask,
            emscripten_glDepthRange: _emscripten_glDepthRange,
            emscripten_glDepthRangef: _emscripten_glDepthRangef,
            emscripten_glDetachShader: _emscripten_glDetachShader,
            emscripten_glDisable: _emscripten_glDisable,
            emscripten_glDisableVertexAttribArray: _emscripten_glDisableVertexAttribArray,
            emscripten_glDrawArrays: _emscripten_glDrawArrays,
            emscripten_glDrawArraysInstanced: _emscripten_glDrawArraysInstanced,
            emscripten_glDrawArraysInstancedANGLE: _emscripten_glDrawArraysInstancedANGLE,
            emscripten_glDrawArraysInstancedARB: _emscripten_glDrawArraysInstancedARB,
            emscripten_glDrawArraysInstancedEXT: _emscripten_glDrawArraysInstancedEXT,
            emscripten_glDrawArraysInstancedNV: _emscripten_glDrawArraysInstancedNV,
            emscripten_glDrawBuffers: _emscripten_glDrawBuffers,
            emscripten_glDrawBuffersEXT: _emscripten_glDrawBuffersEXT,
            emscripten_glDrawBuffersWEBGL: _emscripten_glDrawBuffersWEBGL,
            emscripten_glDrawElements: _emscripten_glDrawElements,
            emscripten_glDrawElementsInstanced: _emscripten_glDrawElementsInstanced,
            emscripten_glDrawElementsInstancedANGLE: _emscripten_glDrawElementsInstancedANGLE,
            emscripten_glDrawElementsInstancedARB: _emscripten_glDrawElementsInstancedARB,
            emscripten_glDrawElementsInstancedEXT: _emscripten_glDrawElementsInstancedEXT,
            emscripten_glDrawElementsInstancedNV: _emscripten_glDrawElementsInstancedNV,
            emscripten_glEnable: _emscripten_glEnable,
            emscripten_glEnableVertexAttribArray: _emscripten_glEnableVertexAttribArray,
            emscripten_glEndQueryEXT: _emscripten_glEndQueryEXT,
            emscripten_glFinish: _emscripten_glFinish,
            emscripten_glFlush: _emscripten_glFlush,
            emscripten_glFramebufferRenderbuffer: _emscripten_glFramebufferRenderbuffer,
            emscripten_glFramebufferTexture2D: _emscripten_glFramebufferTexture2D,
            emscripten_glFrontFace: _emscripten_glFrontFace,
            emscripten_glGenBuffers: _emscripten_glGenBuffers,
            emscripten_glGenFramebuffers: _emscripten_glGenFramebuffers,
            emscripten_glGenQueriesEXT: _emscripten_glGenQueriesEXT,
            emscripten_glGenRenderbuffers: _emscripten_glGenRenderbuffers,
            emscripten_glGenTextures: _emscripten_glGenTextures,
            emscripten_glGenVertexArrays: _emscripten_glGenVertexArrays,
            emscripten_glGenVertexArraysOES: _emscripten_glGenVertexArraysOES,
            emscripten_glGenerateMipmap: _emscripten_glGenerateMipmap,
            emscripten_glGetActiveAttrib: _emscripten_glGetActiveAttrib,
            emscripten_glGetActiveUniform: _emscripten_glGetActiveUniform,
            emscripten_glGetAttachedShaders: _emscripten_glGetAttachedShaders,
            emscripten_glGetAttribLocation: _emscripten_glGetAttribLocation,
            emscripten_glGetBooleanv: _emscripten_glGetBooleanv,
            emscripten_glGetBufferParameteriv: _emscripten_glGetBufferParameteriv,
            emscripten_glGetError: _emscripten_glGetError,
            emscripten_glGetFloatv: _emscripten_glGetFloatv,
            emscripten_glGetFramebufferAttachmentParameteriv: _emscripten_glGetFramebufferAttachmentParameteriv,
            emscripten_glGetIntegerv: _emscripten_glGetIntegerv,
            emscripten_glGetProgramInfoLog: _emscripten_glGetProgramInfoLog,
            emscripten_glGetProgramiv: _emscripten_glGetProgramiv,
            emscripten_glGetQueryObjecti64vEXT: _emscripten_glGetQueryObjecti64vEXT,
            emscripten_glGetQueryObjectivEXT: _emscripten_glGetQueryObjectivEXT,
            emscripten_glGetQueryObjectui64vEXT: _emscripten_glGetQueryObjectui64vEXT,
            emscripten_glGetQueryObjectuivEXT: _emscripten_glGetQueryObjectuivEXT,
            emscripten_glGetQueryivEXT: _emscripten_glGetQueryivEXT,
            emscripten_glGetRenderbufferParameteriv: _emscripten_glGetRenderbufferParameteriv,
            emscripten_glGetShaderInfoLog: _emscripten_glGetShaderInfoLog,
            emscripten_glGetShaderPrecisionFormat: _emscripten_glGetShaderPrecisionFormat,
            emscripten_glGetShaderSource: _emscripten_glGetShaderSource,
            emscripten_glGetShaderiv: _emscripten_glGetShaderiv,
            emscripten_glGetString: _emscripten_glGetString,
            emscripten_glGetTexParameterfv: _emscripten_glGetTexParameterfv,
            emscripten_glGetTexParameteriv: _emscripten_glGetTexParameteriv,
            emscripten_glGetUniformLocation: _emscripten_glGetUniformLocation,
            emscripten_glGetUniformfv: _emscripten_glGetUniformfv,
            emscripten_glGetUniformiv: _emscripten_glGetUniformiv,
            emscripten_glGetVertexAttribPointerv: _emscripten_glGetVertexAttribPointerv,
            emscripten_glGetVertexAttribfv: _emscripten_glGetVertexAttribfv,
            emscripten_glGetVertexAttribiv: _emscripten_glGetVertexAttribiv,
            emscripten_glHint: _emscripten_glHint,
            emscripten_glIsBuffer: _emscripten_glIsBuffer,
            emscripten_glIsEnabled: _emscripten_glIsEnabled,
            emscripten_glIsFramebuffer: _emscripten_glIsFramebuffer,
            emscripten_glIsProgram: _emscripten_glIsProgram,
            emscripten_glIsQueryEXT: _emscripten_glIsQueryEXT,
            emscripten_glIsRenderbuffer: _emscripten_glIsRenderbuffer,
            emscripten_glIsShader: _emscripten_glIsShader,
            emscripten_glIsTexture: _emscripten_glIsTexture,
            emscripten_glIsVertexArray: _emscripten_glIsVertexArray,
            emscripten_glIsVertexArrayOES: _emscripten_glIsVertexArrayOES,
            emscripten_glLineWidth: _emscripten_glLineWidth,
            emscripten_glLinkProgram: _emscripten_glLinkProgram,
            emscripten_glLoadIdentity: _emscripten_glLoadIdentity,
            emscripten_glMatrixMode: _emscripten_glMatrixMode,
            emscripten_glMultiDrawArrays: _emscripten_glMultiDrawArrays,
            emscripten_glMultiDrawArraysANGLE: _emscripten_glMultiDrawArraysANGLE,
            emscripten_glMultiDrawArraysInstancedANGLE: _emscripten_glMultiDrawArraysInstancedANGLE,
            emscripten_glMultiDrawArraysInstancedWEBGL: _emscripten_glMultiDrawArraysInstancedWEBGL,
            emscripten_glMultiDrawArraysWEBGL: _emscripten_glMultiDrawArraysWEBGL,
            emscripten_glMultiDrawElements: _emscripten_glMultiDrawElements,
            emscripten_glMultiDrawElementsANGLE: _emscripten_glMultiDrawElementsANGLE,
            emscripten_glMultiDrawElementsInstancedANGLE: _emscripten_glMultiDrawElementsInstancedANGLE,
            emscripten_glMultiDrawElementsInstancedWEBGL: _emscripten_glMultiDrawElementsInstancedWEBGL,
            emscripten_glMultiDrawElementsWEBGL: _emscripten_glMultiDrawElementsWEBGL,
            emscripten_glPixelStorei: _emscripten_glPixelStorei,
            emscripten_glPolygonOffset: _emscripten_glPolygonOffset,
            emscripten_glQueryCounterEXT: _emscripten_glQueryCounterEXT,
            emscripten_glReadPixels: _emscripten_glReadPixels,
            emscripten_glReleaseShaderCompiler: _emscripten_glReleaseShaderCompiler,
            emscripten_glRenderbufferStorage: _emscripten_glRenderbufferStorage,
            emscripten_glSampleCoverage: _emscripten_glSampleCoverage,
            emscripten_glScissor: _emscripten_glScissor,
            emscripten_glShaderBinary: _emscripten_glShaderBinary,
            emscripten_glShaderSource: _emscripten_glShaderSource,
            emscripten_glStencilFunc: _emscripten_glStencilFunc,
            emscripten_glStencilFuncSeparate: _emscripten_glStencilFuncSeparate,
            emscripten_glStencilMask: _emscripten_glStencilMask,
            emscripten_glStencilMaskSeparate: _emscripten_glStencilMaskSeparate,
            emscripten_glStencilOp: _emscripten_glStencilOp,
            emscripten_glStencilOpSeparate: _emscripten_glStencilOpSeparate,
            emscripten_glTexImage2D: _emscripten_glTexImage2D,
            emscripten_glTexParameterf: _emscripten_glTexParameterf,
            emscripten_glTexParameterfv: _emscripten_glTexParameterfv,
            emscripten_glTexParameteri: _emscripten_glTexParameteri,
            emscripten_glTexParameteriv: _emscripten_glTexParameteriv,
            emscripten_glTexSubImage2D: _emscripten_glTexSubImage2D,
            emscripten_glUniform1f: _emscripten_glUniform1f,
            emscripten_glUniform1fv: _emscripten_glUniform1fv,
            emscripten_glUniform1i: _emscripten_glUniform1i,
            emscripten_glUniform1iv: _emscripten_glUniform1iv,
            emscripten_glUniform2f: _emscripten_glUniform2f,
            emscripten_glUniform2fv: _emscripten_glUniform2fv,
            emscripten_glUniform2i: _emscripten_glUniform2i,
            emscripten_glUniform2iv: _emscripten_glUniform2iv,
            emscripten_glUniform3f: _emscripten_glUniform3f,
            emscripten_glUniform3fv: _emscripten_glUniform3fv,
            emscripten_glUniform3i: _emscripten_glUniform3i,
            emscripten_glUniform3iv: _emscripten_glUniform3iv,
            emscripten_glUniform4f: _emscripten_glUniform4f,
            emscripten_glUniform4fv: _emscripten_glUniform4fv,
            emscripten_glUniform4i: _emscripten_glUniform4i,
            emscripten_glUniform4iv: _emscripten_glUniform4iv,
            emscripten_glUniformMatrix2fv: _emscripten_glUniformMatrix2fv,
            emscripten_glUniformMatrix3fv: _emscripten_glUniformMatrix3fv,
            emscripten_glUniformMatrix4fv: _emscripten_glUniformMatrix4fv,
            emscripten_glUseProgram: _emscripten_glUseProgram,
            emscripten_glValidateProgram: _emscripten_glValidateProgram,
            emscripten_glVertexAttrib1f: _emscripten_glVertexAttrib1f,
            emscripten_glVertexAttrib1fv: _emscripten_glVertexAttrib1fv,
            emscripten_glVertexAttrib2f: _emscripten_glVertexAttrib2f,
            emscripten_glVertexAttrib2fv: _emscripten_glVertexAttrib2fv,
            emscripten_glVertexAttrib3f: _emscripten_glVertexAttrib3f,
            emscripten_glVertexAttrib3fv: _emscripten_glVertexAttrib3fv,
            emscripten_glVertexAttrib4f: _emscripten_glVertexAttrib4f,
            emscripten_glVertexAttrib4fv: _emscripten_glVertexAttrib4fv,
            emscripten_glVertexAttribDivisor: _emscripten_glVertexAttribDivisor,
            emscripten_glVertexAttribDivisorANGLE: _emscripten_glVertexAttribDivisorANGLE,
            emscripten_glVertexAttribDivisorARB: _emscripten_glVertexAttribDivisorARB,
            emscripten_glVertexAttribDivisorEXT: _emscripten_glVertexAttribDivisorEXT,
            emscripten_glVertexAttribDivisorNV: _emscripten_glVertexAttribDivisorNV,
            emscripten_glVertexAttribPointer: _emscripten_glVertexAttribPointer,
            emscripten_glVertexPointer: _emscripten_glVertexPointer,
            emscripten_glViewport: _emscripten_glViewport,
            emscripten_has_asyncify: _emscripten_has_asyncify,
            emscripten_hide_mouse: _emscripten_hide_mouse,
            emscripten_html5_remove_all_event_listeners: _emscripten_html5_remove_all_event_listeners,
            emscripten_idb_async_clear: _emscripten_idb_async_clear,
            emscripten_idb_async_delete: _emscripten_idb_async_delete,
            emscripten_idb_async_exists: _emscripten_idb_async_exists,
            emscripten_idb_async_load: _emscripten_idb_async_load,
            emscripten_idb_async_store: _emscripten_idb_async_store,
            emscripten_idb_clear: _emscripten_idb_clear,
            emscripten_idb_delete: _emscripten_idb_delete,
            emscripten_idb_exists: _emscripten_idb_exists,
            emscripten_idb_load: _emscripten_idb_load,
            emscripten_idb_store: _emscripten_idb_store,
            emscripten_is_main_browser_thread: _emscripten_is_main_browser_thread,
            emscripten_is_webgl_context_lost: _emscripten_is_webgl_context_lost,
            emscripten_lock_orientation: _emscripten_lock_orientation,
            emscripten_log: _emscripten_log,
            emscripten_math_acos: _emscripten_math_acos,
            emscripten_math_acosh: _emscripten_math_acosh,
            emscripten_math_asin: _emscripten_math_asin,
            emscripten_math_asinh: _emscripten_math_asinh,
            emscripten_math_atan: _emscripten_math_atan,
            emscripten_math_atan2: _emscripten_math_atan2,
            emscripten_math_atanh: _emscripten_math_atanh,
            emscripten_math_cbrt: _emscripten_math_cbrt,
            emscripten_math_cos: _emscripten_math_cos,
            emscripten_math_cosh: _emscripten_math_cosh,
            emscripten_math_exp: _emscripten_math_exp,
            emscripten_math_expm1: _emscripten_math_expm1,
            emscripten_math_fmod: _emscripten_math_fmod,
            emscripten_math_hypot: _emscripten_math_hypot,
            emscripten_math_log: _emscripten_math_log,
            emscripten_math_log10: _emscripten_math_log10,
            emscripten_math_log1p: _emscripten_math_log1p,
            emscripten_math_log2: _emscripten_math_log2,
            emscripten_math_pow: _emscripten_math_pow,
            emscripten_math_random: _emscripten_math_random,
            emscripten_math_round: _emscripten_math_round,
            emscripten_math_sign: _emscripten_math_sign,
            emscripten_math_sin: _emscripten_math_sin,
            emscripten_math_sinh: _emscripten_math_sinh,
            emscripten_math_sqrt: _emscripten_math_sqrt,
            emscripten_math_tan: _emscripten_math_tan,
            emscripten_math_tanh: _emscripten_math_tanh,
            emscripten_memcpy_js: _emscripten_memcpy_js,
            emscripten_notify_memory_growth: _emscripten_notify_memory_growth,
            emscripten_out: _emscripten_out,
            emscripten_outn: _emscripten_outn,
            emscripten_pause_main_loop: _emscripten_pause_main_loop,
            emscripten_pc_get_column: _emscripten_pc_get_column,
            emscripten_pc_get_file: _emscripten_pc_get_file,
            emscripten_pc_get_function: _emscripten_pc_get_function,
            emscripten_pc_get_line: _emscripten_pc_get_line,
            emscripten_performance_now: _emscripten_performance_now,
            emscripten_print_double: _emscripten_print_double,
            emscripten_promise_all: _emscripten_promise_all,
            emscripten_promise_all_settled: _emscripten_promise_all_settled,
            emscripten_promise_any: _emscripten_promise_any,
            emscripten_promise_await: _emscripten_promise_await,
            emscripten_promise_create: _emscripten_promise_create,
            emscripten_promise_destroy: _emscripten_promise_destroy,
            emscripten_promise_race: _emscripten_promise_race,
            emscripten_promise_resolve: _emscripten_promise_resolve,
            emscripten_promise_then: _emscripten_promise_then,
            emscripten_random: _emscripten_random,
            emscripten_request_animation_frame: _emscripten_request_animation_frame,
            emscripten_request_animation_frame_loop: _emscripten_request_animation_frame_loop,
            emscripten_request_fullscreen: _emscripten_request_fullscreen,
            emscripten_request_fullscreen_strategy: _emscripten_request_fullscreen_strategy,
            emscripten_request_pointerlock: _emscripten_request_pointerlock,
            emscripten_resize_heap: _emscripten_resize_heap,
            emscripten_resume_main_loop: _emscripten_resume_main_loop,
            emscripten_return_address: _emscripten_return_address,
            emscripten_run_preload_plugins: _emscripten_run_preload_plugins,
            emscripten_run_preload_plugins_data: _emscripten_run_preload_plugins_data,
            emscripten_run_script: _emscripten_run_script,
            emscripten_run_script_int: _emscripten_run_script_int,
            emscripten_run_script_string: _emscripten_run_script_string,
            emscripten_runtime_keepalive_check: _emscripten_runtime_keepalive_check,
            emscripten_runtime_keepalive_pop: _emscripten_runtime_keepalive_pop,
            emscripten_runtime_keepalive_push: _emscripten_runtime_keepalive_push,
            emscripten_sample_gamepad_data: _emscripten_sample_gamepad_data,
            emscripten_scan_registers: _emscripten_scan_registers,
            emscripten_set_batterychargingchange_callback_on_thread: _emscripten_set_batterychargingchange_callback_on_thread,
            emscripten_set_batterylevelchange_callback_on_thread: _emscripten_set_batterylevelchange_callback_on_thread,
            emscripten_set_beforeunload_callback_on_thread: _emscripten_set_beforeunload_callback_on_thread,
            emscripten_set_blur_callback_on_thread: _emscripten_set_blur_callback_on_thread,
            emscripten_set_canvas_element_size: _emscripten_set_canvas_element_size,
            emscripten_set_canvas_size: _emscripten_set_canvas_size,
            emscripten_set_click_callback_on_thread: _emscripten_set_click_callback_on_thread,
            emscripten_set_dblclick_callback_on_thread: _emscripten_set_dblclick_callback_on_thread,
            emscripten_set_devicemotion_callback_on_thread: _emscripten_set_devicemotion_callback_on_thread,
            emscripten_set_deviceorientation_callback_on_thread: _emscripten_set_deviceorientation_callback_on_thread,
            emscripten_set_element_css_size: _emscripten_set_element_css_size,
            emscripten_set_focus_callback_on_thread: _emscripten_set_focus_callback_on_thread,
            emscripten_set_focusin_callback_on_thread: _emscripten_set_focusin_callback_on_thread,
            emscripten_set_focusout_callback_on_thread: _emscripten_set_focusout_callback_on_thread,
            emscripten_set_fullscreenchange_callback_on_thread: _emscripten_set_fullscreenchange_callback_on_thread,
            emscripten_set_gamepadconnected_callback_on_thread: _emscripten_set_gamepadconnected_callback_on_thread,
            emscripten_set_gamepaddisconnected_callback_on_thread: _emscripten_set_gamepaddisconnected_callback_on_thread,
            emscripten_set_immediate: _emscripten_set_immediate,
            emscripten_set_immediate_loop: _emscripten_set_immediate_loop,
            emscripten_set_interval: _emscripten_set_interval,
            emscripten_set_keydown_callback_on_thread: _emscripten_set_keydown_callback_on_thread,
            emscripten_set_keypress_callback_on_thread: _emscripten_set_keypress_callback_on_thread,
            emscripten_set_keyup_callback_on_thread: _emscripten_set_keyup_callback_on_thread,
            emscripten_set_main_loop: _emscripten_set_main_loop,
            emscripten_set_main_loop_arg: _emscripten_set_main_loop_arg,
            emscripten_set_main_loop_expected_blockers: _emscripten_set_main_loop_expected_blockers,
            emscripten_set_main_loop_timing: _emscripten_set_main_loop_timing,
            emscripten_set_mousedown_callback_on_thread: _emscripten_set_mousedown_callback_on_thread,
            emscripten_set_mouseenter_callback_on_thread: _emscripten_set_mouseenter_callback_on_thread,
            emscripten_set_mouseleave_callback_on_thread: _emscripten_set_mouseleave_callback_on_thread,
            emscripten_set_mousemove_callback_on_thread: _emscripten_set_mousemove_callback_on_thread,
            emscripten_set_mouseout_callback_on_thread: _emscripten_set_mouseout_callback_on_thread,
            emscripten_set_mouseover_callback_on_thread: _emscripten_set_mouseover_callback_on_thread,
            emscripten_set_mouseup_callback_on_thread: _emscripten_set_mouseup_callback_on_thread,
            emscripten_set_orientationchange_callback_on_thread: _emscripten_set_orientationchange_callback_on_thread,
            emscripten_set_pointerlockchange_callback_on_thread: _emscripten_set_pointerlockchange_callback_on_thread,
            emscripten_set_pointerlockerror_callback_on_thread: _emscripten_set_pointerlockerror_callback_on_thread,
            emscripten_set_resize_callback_on_thread: _emscripten_set_resize_callback_on_thread,
            emscripten_set_scroll_callback_on_thread: _emscripten_set_scroll_callback_on_thread,
            emscripten_set_socket_close_callback: _emscripten_set_socket_close_callback,
            emscripten_set_socket_connection_callback: _emscripten_set_socket_connection_callback,
            emscripten_set_socket_error_callback: _emscripten_set_socket_error_callback,
            emscripten_set_socket_listen_callback: _emscripten_set_socket_listen_callback,
            emscripten_set_socket_message_callback: _emscripten_set_socket_message_callback,
            emscripten_set_socket_open_callback: _emscripten_set_socket_open_callback,
            emscripten_set_timeout: _emscripten_set_timeout,
            emscripten_set_timeout_loop: _emscripten_set_timeout_loop,
            emscripten_set_touchcancel_callback_on_thread: _emscripten_set_touchcancel_callback_on_thread,
            emscripten_set_touchend_callback_on_thread: _emscripten_set_touchend_callback_on_thread,
            emscripten_set_touchmove_callback_on_thread: _emscripten_set_touchmove_callback_on_thread,
            emscripten_set_touchstart_callback_on_thread: _emscripten_set_touchstart_callback_on_thread,
            emscripten_set_visibilitychange_callback_on_thread: _emscripten_set_visibilitychange_callback_on_thread,
            emscripten_set_webglcontextlost_callback_on_thread: _emscripten_set_webglcontextlost_callback_on_thread,
            emscripten_set_webglcontextrestored_callback_on_thread: _emscripten_set_webglcontextrestored_callback_on_thread,
            emscripten_set_wheel_callback_on_thread: _emscripten_set_wheel_callback_on_thread,
            emscripten_set_window_title: _emscripten_set_window_title,
            emscripten_sleep: _emscripten_sleep,
            emscripten_stack_snapshot: _emscripten_stack_snapshot,
            emscripten_stack_unwind_buffer: _emscripten_stack_unwind_buffer,
            emscripten_supports_offscreencanvas: _emscripten_supports_offscreencanvas,
            emscripten_throw_number: _emscripten_throw_number,
            emscripten_throw_string: _emscripten_throw_string,
            emscripten_unlock_orientation: _emscripten_unlock_orientation,
            emscripten_unwind_to_js_event_loop: _emscripten_unwind_to_js_event_loop,
            emscripten_vibrate: _emscripten_vibrate,
            emscripten_vibrate_pattern: _emscripten_vibrate_pattern,
            emscripten_webgl_commit_frame: _emscripten_webgl_commit_frame,
            emscripten_webgl_create_context: _emscripten_webgl_create_context,
            emscripten_webgl_destroy_context: _emscripten_webgl_destroy_context,
            emscripten_webgl_do_commit_frame: _emscripten_webgl_do_commit_frame,
            emscripten_webgl_do_create_context: _emscripten_webgl_do_create_context,
            emscripten_webgl_do_get_current_context: _emscripten_webgl_do_get_current_context,
            emscripten_webgl_enable_ANGLE_instanced_arrays: _emscripten_webgl_enable_ANGLE_instanced_arrays,
            emscripten_webgl_enable_OES_vertex_array_object: _emscripten_webgl_enable_OES_vertex_array_object,
            emscripten_webgl_enable_WEBGL_draw_buffers: _emscripten_webgl_enable_WEBGL_draw_buffers,
            emscripten_webgl_enable_WEBGL_multi_draw: _emscripten_webgl_enable_WEBGL_multi_draw,
            emscripten_webgl_enable_extension: _emscripten_webgl_enable_extension,
            emscripten_webgl_get_context_attributes: _emscripten_webgl_get_context_attributes,
            emscripten_webgl_get_current_context: _emscripten_webgl_get_current_context,
            emscripten_webgl_get_drawing_buffer_size: _emscripten_webgl_get_drawing_buffer_size,
            emscripten_webgl_get_parameter_d: _emscripten_webgl_get_parameter_d,
            emscripten_webgl_get_parameter_i64v: _emscripten_webgl_get_parameter_i64v,
            emscripten_webgl_get_parameter_o: _emscripten_webgl_get_parameter_o,
            emscripten_webgl_get_parameter_utf8: _emscripten_webgl_get_parameter_utf8,
            emscripten_webgl_get_parameter_v: _emscripten_webgl_get_parameter_v,
            emscripten_webgl_get_program_info_log_utf8: _emscripten_webgl_get_program_info_log_utf8,
            emscripten_webgl_get_program_parameter_d: _emscripten_webgl_get_program_parameter_d,
            emscripten_webgl_get_shader_info_log_utf8: _emscripten_webgl_get_shader_info_log_utf8,
            emscripten_webgl_get_shader_parameter_d: _emscripten_webgl_get_shader_parameter_d,
            emscripten_webgl_get_shader_source_utf8: _emscripten_webgl_get_shader_source_utf8,
            emscripten_webgl_get_supported_extensions: _emscripten_webgl_get_supported_extensions,
            emscripten_webgl_get_uniform_d: _emscripten_webgl_get_uniform_d,
            emscripten_webgl_get_uniform_v: _emscripten_webgl_get_uniform_v,
            emscripten_webgl_get_vertex_attrib_d: _emscripten_webgl_get_vertex_attrib_d,
            emscripten_webgl_get_vertex_attrib_o: _emscripten_webgl_get_vertex_attrib_o,
            emscripten_webgl_get_vertex_attrib_v: _emscripten_webgl_get_vertex_attrib_v,
            emscripten_webgl_init_context_attributes: _emscripten_webgl_init_context_attributes,
            emscripten_webgl_make_context_current: _emscripten_webgl_make_context_current,
            emscripten_wget_data: _emscripten_wget_data,
            endprotoent: _endprotoent,
            environ_get: _environ_get,
            environ_sizes_get: _environ_sizes_get,
            exit: _exit,
            fd_close: _fd_close,
            fd_fdstat_get: _fd_fdstat_get,
            fd_pread: _fd_pread,
            fd_pwrite: _fd_pwrite,
            fd_read: _fd_read,
            fd_seek: _fd_seek,
            fd_sync: _fd_sync,
            fd_write: _fd_write,
            filledEllipseColor: _filledEllipseColor,
            filledEllipseRGBA: _filledEllipseRGBA,
            getaddrinfo: _getaddrinfo,
            getentropy: _getentropy,
            getnameinfo: _getnameinfo,
            getprotobyname: _getprotobyname,
            getprotobynumber: _getprotobynumber,
            getprotoent: _getprotoent,
            glActiveTexture: _glActiveTexture,
            glAttachShader: _glAttachShader,
            glBegin: _glBegin,
            glBeginQueryEXT: _glBeginQueryEXT,
            glBindAttribLocation: _glBindAttribLocation,
            glBindBuffer: _glBindBuffer,
            glBindFramebuffer: _glBindFramebuffer,
            glBindRenderbuffer: _glBindRenderbuffer,
            glBindTexture: _glBindTexture,
            glBindVertexArray: _glBindVertexArray,
            glBindVertexArrayOES: _glBindVertexArrayOES,
            glBlendColor: _glBlendColor,
            glBlendEquation: _glBlendEquation,
            glBlendEquationSeparate: _glBlendEquationSeparate,
            glBlendFunc: _glBlendFunc,
            glBlendFuncSeparate: _glBlendFuncSeparate,
            glBufferData: _glBufferData,
            glBufferSubData: _glBufferSubData,
            glCheckFramebufferStatus: _glCheckFramebufferStatus,
            glClear: _glClear,
            glClearColor: _glClearColor,
            glClearDepth: _glClearDepth,
            glClearDepthf: _glClearDepthf,
            glClearStencil: _glClearStencil,
            glColorMask: _glColorMask,
            glCompileShader: _glCompileShader,
            glCompressedTexImage2D: _glCompressedTexImage2D,
            glCompressedTexSubImage2D: _glCompressedTexSubImage2D,
            glCopyTexImage2D: _glCopyTexImage2D,
            glCopyTexSubImage2D: _glCopyTexSubImage2D,
            glCreateProgram: _glCreateProgram,
            glCreateShader: _glCreateShader,
            glCullFace: _glCullFace,
            glDeleteBuffers: _glDeleteBuffers,
            glDeleteFramebuffers: _glDeleteFramebuffers,
            glDeleteProgram: _glDeleteProgram,
            glDeleteQueriesEXT: _glDeleteQueriesEXT,
            glDeleteRenderbuffers: _glDeleteRenderbuffers,
            glDeleteShader: _glDeleteShader,
            glDeleteTextures: _glDeleteTextures,
            glDeleteVertexArrays: _glDeleteVertexArrays,
            glDeleteVertexArraysOES: _glDeleteVertexArraysOES,
            glDepthFunc: _glDepthFunc,
            glDepthMask: _glDepthMask,
            glDepthRange: _glDepthRange,
            glDepthRangef: _glDepthRangef,
            glDetachShader: _glDetachShader,
            glDisable: _glDisable,
            glDisableVertexAttribArray: _glDisableVertexAttribArray,
            glDrawArrays: _glDrawArrays,
            glDrawArraysInstanced: _glDrawArraysInstanced,
            glDrawArraysInstancedANGLE: _glDrawArraysInstancedANGLE,
            glDrawArraysInstancedARB: _glDrawArraysInstancedARB,
            glDrawArraysInstancedEXT: _glDrawArraysInstancedEXT,
            glDrawArraysInstancedNV: _glDrawArraysInstancedNV,
            glDrawBuffers: _glDrawBuffers,
            glDrawBuffersEXT: _glDrawBuffersEXT,
            glDrawBuffersWEBGL: _glDrawBuffersWEBGL,
            glDrawElements: _glDrawElements,
            glDrawElementsInstanced: _glDrawElementsInstanced,
            glDrawElementsInstancedANGLE: _glDrawElementsInstancedANGLE,
            glDrawElementsInstancedARB: _glDrawElementsInstancedARB,
            glDrawElementsInstancedEXT: _glDrawElementsInstancedEXT,
            glDrawElementsInstancedNV: _glDrawElementsInstancedNV,
            glEnable: _glEnable,
            glEnableVertexAttribArray: _glEnableVertexAttribArray,
            glEndQueryEXT: _glEndQueryEXT,
            glFinish: _glFinish,
            glFlush: _glFlush,
            glFramebufferRenderbuffer: _glFramebufferRenderbuffer,
            glFramebufferTexture2D: _glFramebufferTexture2D,
            glFrontFace: _glFrontFace,
            glGenBuffers: _glGenBuffers,
            glGenFramebuffers: _glGenFramebuffers,
            glGenQueriesEXT: _glGenQueriesEXT,
            glGenRenderbuffers: _glGenRenderbuffers,
            glGenTextures: _glGenTextures,
            glGenVertexArrays: _glGenVertexArrays,
            glGenVertexArraysOES: _glGenVertexArraysOES,
            glGenerateMipmap: _glGenerateMipmap,
            glGetActiveAttrib: _glGetActiveAttrib,
            glGetActiveUniform: _glGetActiveUniform,
            glGetAttachedShaders: _glGetAttachedShaders,
            glGetAttribLocation: _glGetAttribLocation,
            glGetBooleanv: _glGetBooleanv,
            glGetBufferParameteriv: _glGetBufferParameteriv,
            glGetError: _glGetError,
            glGetFloatv: _glGetFloatv,
            glGetFramebufferAttachmentParameteriv: _glGetFramebufferAttachmentParameteriv,
            glGetIntegerv: _glGetIntegerv,
            glGetProgramInfoLog: _glGetProgramInfoLog,
            glGetProgramiv: _glGetProgramiv,
            glGetQueryObjecti64vEXT: _glGetQueryObjecti64vEXT,
            glGetQueryObjectivEXT: _glGetQueryObjectivEXT,
            glGetQueryObjectui64vEXT: _glGetQueryObjectui64vEXT,
            glGetQueryObjectuivEXT: _glGetQueryObjectuivEXT,
            glGetQueryivEXT: _glGetQueryivEXT,
            glGetRenderbufferParameteriv: _glGetRenderbufferParameteriv,
            glGetShaderInfoLog: _glGetShaderInfoLog,
            glGetShaderPrecisionFormat: _glGetShaderPrecisionFormat,
            glGetShaderSource: _glGetShaderSource,
            glGetShaderiv: _glGetShaderiv,
            glGetString: _glGetString,
            glGetTexParameterfv: _glGetTexParameterfv,
            glGetTexParameteriv: _glGetTexParameteriv,
            glGetUniformLocation: _glGetUniformLocation,
            glGetUniformfv: _glGetUniformfv,
            glGetUniformiv: _glGetUniformiv,
            glGetVertexAttribPointerv: _glGetVertexAttribPointerv,
            glGetVertexAttribfv: _glGetVertexAttribfv,
            glGetVertexAttribiv: _glGetVertexAttribiv,
            glHint: _glHint,
            glIsBuffer: _glIsBuffer,
            glIsEnabled: _glIsEnabled,
            glIsFramebuffer: _glIsFramebuffer,
            glIsProgram: _glIsProgram,
            glIsQueryEXT: _glIsQueryEXT,
            glIsRenderbuffer: _glIsRenderbuffer,
            glIsShader: _glIsShader,
            glIsTexture: _glIsTexture,
            glIsVertexArray: _glIsVertexArray,
            glIsVertexArrayOES: _glIsVertexArrayOES,
            glLineWidth: _glLineWidth,
            glLinkProgram: _glLinkProgram,
            glLoadIdentity: _glLoadIdentity,
            glMatrixMode: _glMatrixMode,
            glMultiDrawArrays: _glMultiDrawArrays,
            glMultiDrawArraysANGLE: _glMultiDrawArraysANGLE,
            glMultiDrawArraysInstancedANGLE: _glMultiDrawArraysInstancedANGLE,
            glMultiDrawArraysInstancedWEBGL: _glMultiDrawArraysInstancedWEBGL,
            glMultiDrawArraysWEBGL: _glMultiDrawArraysWEBGL,
            glMultiDrawElements: _glMultiDrawElements,
            glMultiDrawElementsANGLE: _glMultiDrawElementsANGLE,
            glMultiDrawElementsInstancedANGLE: _glMultiDrawElementsInstancedANGLE,
            glMultiDrawElementsInstancedWEBGL: _glMultiDrawElementsInstancedWEBGL,
            glMultiDrawElementsWEBGL: _glMultiDrawElementsWEBGL,
            glPixelStorei: _glPixelStorei,
            glPolygonOffset: _glPolygonOffset,
            glQueryCounterEXT: _glQueryCounterEXT,
            glReadPixels: _glReadPixels,
            glReleaseShaderCompiler: _glReleaseShaderCompiler,
            glRenderbufferStorage: _glRenderbufferStorage,
            glSampleCoverage: _glSampleCoverage,
            glScissor: _glScissor,
            glShaderBinary: _glShaderBinary,
            glShaderSource: _glShaderSource,
            glStencilFunc: _glStencilFunc,
            glStencilFuncSeparate: _glStencilFuncSeparate,
            glStencilMask: _glStencilMask,
            glStencilMaskSeparate: _glStencilMaskSeparate,
            glStencilOp: _glStencilOp,
            glStencilOpSeparate: _glStencilOpSeparate,
            glTexImage2D: _glTexImage2D,
            glTexParameterf: _glTexParameterf,
            glTexParameterfv: _glTexParameterfv,
            glTexParameteri: _glTexParameteri,
            glTexParameteriv: _glTexParameteriv,
            glTexSubImage2D: _glTexSubImage2D,
            glUniform1f: _glUniform1f,
            glUniform1fv: _glUniform1fv,
            glUniform1i: _glUniform1i,
            glUniform1iv: _glUniform1iv,
            glUniform2f: _glUniform2f,
            glUniform2fv: _glUniform2fv,
            glUniform2i: _glUniform2i,
            glUniform2iv: _glUniform2iv,
            glUniform3f: _glUniform3f,
            glUniform3fv: _glUniform3fv,
            glUniform3i: _glUniform3i,
            glUniform3iv: _glUniform3iv,
            glUniform4f: _glUniform4f,
            glUniform4fv: _glUniform4fv,
            glUniform4i: _glUniform4i,
            glUniform4iv: _glUniform4iv,
            glUniformMatrix2fv: _glUniformMatrix2fv,
            glUniformMatrix3fv: _glUniformMatrix3fv,
            glUniformMatrix4fv: _glUniformMatrix4fv,
            glUseProgram: _glUseProgram,
            glValidateProgram: _glValidateProgram,
            glVertexAttrib1f: _glVertexAttrib1f,
            glVertexAttrib1fv: _glVertexAttrib1fv,
            glVertexAttrib2f: _glVertexAttrib2f,
            glVertexAttrib2fv: _glVertexAttrib2fv,
            glVertexAttrib3f: _glVertexAttrib3f,
            glVertexAttrib3fv: _glVertexAttrib3fv,
            glVertexAttrib4f: _glVertexAttrib4f,
            glVertexAttrib4fv: _glVertexAttrib4fv,
            glVertexAttribDivisor: _glVertexAttribDivisor,
            glVertexAttribDivisorANGLE: _glVertexAttribDivisorANGLE,
            glVertexAttribDivisorARB: _glVertexAttribDivisorARB,
            glVertexAttribDivisorEXT: _glVertexAttribDivisorEXT,
            glVertexAttribDivisorNV: _glVertexAttribDivisorNV,
            glVertexAttribPointer: _glVertexAttribPointer,
            glVertexPointer: _glVertexPointer,
            glViewport: _glViewport,
            glewGetErrorString: _glewGetErrorString,
            glewGetExtension: _glewGetExtension,
            glewGetString: _glewGetString,
            glewInit: _glewInit,
            glewIsSupported: _glewIsSupported,
            glutCreateWindow: _glutCreateWindow,
            glutDestroyWindow: _glutDestroyWindow,
            glutDisplayFunc: _glutDisplayFunc,
            glutFullScreen: _glutFullScreen,
            glutGet: _glutGet,
            glutGetModifiers: _glutGetModifiers,
            glutIdleFunc: _glutIdleFunc,
            glutInit: _glutInit,
            glutInitDisplayMode: _glutInitDisplayMode,
            glutInitWindowPosition: _glutInitWindowPosition,
            glutInitWindowSize: _glutInitWindowSize,
            glutKeyboardFunc: _glutKeyboardFunc,
            glutKeyboardUpFunc: _glutKeyboardUpFunc,
            glutMainLoop: _glutMainLoop,
            glutMotionFunc: _glutMotionFunc,
            glutMouseFunc: _glutMouseFunc,
            glutPassiveMotionFunc: _glutPassiveMotionFunc,
            glutPositionWindow: _glutPositionWindow,
            glutPostRedisplay: _glutPostRedisplay,
            glutReshapeFunc: _glutReshapeFunc,
            glutReshapeWindow: _glutReshapeWindow,
            glutSetCursor: _glutSetCursor,
            glutSpecialFunc: _glutSpecialFunc,
            glutSpecialUpFunc: _glutSpecialUpFunc,
            glutSwapBuffers: _glutSwapBuffers,
            glutTimerFunc: _glutTimerFunc,
            invoke_di,
            invoke_dii,
            invoke_diii,
            invoke_diiii,
            invoke_diiiiid,
            invoke_diijii,
            invoke_fi,
            invoke_fiii,
            invoke_fiiii,
            invoke_fiijii,
            invoke_i,
            invoke_id,
            invoke_idd,
            invoke_idi,
            invoke_idii,
            invoke_idiii,
            invoke_idiiii,
            invoke_if,
            invoke_iff,
            invoke_ifi,
            invoke_ifii,
            invoke_ii,
            invoke_iid,
            invoke_iidi,
            invoke_iidii,
            invoke_iidiii,
            invoke_iidiiii,
            invoke_iif,
            invoke_iifii,
            invoke_iii,
            invoke_iiid,
            invoke_iiidj,
            invoke_iiii,
            invoke_iiiid,
            invoke_iiiidjj,
            invoke_iiiii,
            invoke_iiiiid,
            invoke_iiiiii,
            invoke_iiiiiid,
            invoke_iiiiiii,
            invoke_iiiiiiii,
            invoke_iiiiiiiii,
            invoke_iiiiiiiiii,
            invoke_iiiiiiiiiii,
            invoke_iiiiiiiiiiii,
            invoke_iiiiiiiiiiiii,
            invoke_iiiiiiiiiiiiiiii,
            invoke_iiiiiiiiiiiiiiiii,
            invoke_iiiiiiiiiiiiiiiiii,
            invoke_iiiiiiiiiiiij,
            invoke_iiiiiiiiiiji,
            invoke_iiiiiiiiijiiiiiii,
            invoke_iiiiiiiij,
            invoke_iiiiiiiiji,
            invoke_iiiiiiij,
            invoke_iiiiiiiji,
            invoke_iiiiiiijii,
            invoke_iiiiiiijj,
            invoke_iiiiiiijji,
            invoke_iiiiiij,
            invoke_iiiiiiji,
            invoke_iiiiiijjiijjji,
            invoke_iiiiij,
            invoke_iiiiiji,
            invoke_iiiiijii,
            invoke_iiiiijiii,
            invoke_iiiiijij,
            invoke_iiiiijj,
            invoke_iiiiijjj,
            invoke_iiiiijjji,
            invoke_iiiij,
            invoke_iiiiji,
            invoke_iiiijii,
            invoke_iiiijiii,
            invoke_iiiijj,
            invoke_iiiijji,
            invoke_iiiijjii,
            invoke_iiiijjiii,
            invoke_iiiijjj,
            invoke_iiiijjjj,
            invoke_iiij,
            invoke_iiiji,
            invoke_iiijii,
            invoke_iiijiii,
            invoke_iiijiiiii,
            invoke_iiijiiiij,
            invoke_iiijiiiijj,
            invoke_iiijiiij,
            invoke_iiijiiijj,
            invoke_iiijiij,
            invoke_iiijiiji,
            invoke_iiijiijj,
            invoke_iiijij,
            invoke_iiijj,
            invoke_iiijji,
            invoke_iiijjii,
            invoke_iiijjiii,
            invoke_iiijjiij,
            invoke_iiijjiiji,
            invoke_iiijjijjiii,
            invoke_iiijjj,
            invoke_iiijjji,
            invoke_iiijjjj,
            invoke_iij,
            invoke_iiji,
            invoke_iijii,
            invoke_iijiii,
            invoke_iijiiii,
            invoke_iijiiijj,
            invoke_iijiij,
            invoke_iijiijj,
            invoke_iijiji,
            invoke_iijj,
            invoke_iijji,
            invoke_iijjii,
            invoke_iijjiii,
            invoke_iijjijj,
            invoke_iijjj,
            invoke_iijjjii,
            invoke_ij,
            invoke_iji,
            invoke_ijii,
            invoke_ijji,
            invoke_ijjiii,
            invoke_ijjji,
            invoke_j,
            invoke_jd,
            invoke_jf,
            invoke_ji,
            invoke_jii,
            invoke_jiii,
            invoke_jiiii,
            invoke_jiiiii,
            invoke_jiiiiii,
            invoke_jiiiiiii,
            invoke_jiiiiijiiii,
            invoke_jiiiij,
            invoke_jiiiiji,
            invoke_jiiiijii,
            invoke_jiiiijiiii,
            invoke_jiiij,
            invoke_jiiiji,
            invoke_jiiijii,
            invoke_jiiijiii,
            invoke_jiiijiijiii,
            invoke_jiiijj,
            invoke_jiiijjj,
            invoke_jiij,
            invoke_jiiji,
            invoke_jiijii,
            invoke_jiijiii,
            invoke_jiijj,
            invoke_jiijjjii,
            invoke_jij,
            invoke_jiji,
            invoke_jijiii,
            invoke_jijiiii,
            invoke_jijij,
            invoke_jijj,
            invoke_jijji,
            invoke_jijjij,
            invoke_jijjjjii,
            invoke_jj,
            invoke_jji,
            invoke_jjiji,
            invoke_jjj,
            invoke_jjjd,
            invoke_jjjii,
            invoke_jjjji,
            invoke_v,
            invoke_vdii,
            invoke_vfii,
            invoke_vi,
            invoke_vid,
            invoke_viddddi,
            invoke_vidi,
            invoke_vidii,
            invoke_vif,
            invoke_vifi,
            invoke_vifii,
            invoke_vii,
            invoke_viid,
            invoke_viidii,
            invoke_viif,
            invoke_viii,
            invoke_viiidi,
            invoke_viiifi,
            invoke_viiii,
            invoke_viiiidiiii,
            invoke_viiiii,
            invoke_viiiiii,
            invoke_viiiiiidiii,
            invoke_viiiiiii,
            invoke_viiiiiiii,
            invoke_viiiiiiiii,
            invoke_viiiiiiiiii,
            invoke_viiiiiiiiiii,
            invoke_viiiiiiiiiiii,
            invoke_viiiiiiiiiiiiiii,
            invoke_viiiiiiijjjji,
            invoke_viiiiiij,
            invoke_viiiiiiji,
            invoke_viiiiiijii,
            invoke_viiiiij,
            invoke_viiiiiji,
            invoke_viiiiijii,
            invoke_viiiiijiii,
            invoke_viiiiijiiii,
            invoke_viiiiijiijii,
            invoke_viiiiijj,
            invoke_viiiiijjii,
            invoke_viiiiijjji,
            invoke_viiiij,
            invoke_viiiiji,
            invoke_viiiijii,
            invoke_viiiijiii,
            invoke_viiiijiiii,
            invoke_viiiijiiiii,
            invoke_viiiijiiiiiiii,
            invoke_viiiijijji,
            invoke_viiiijj,
            invoke_viiiijji,
            invoke_viiiijjij,
            invoke_viiij,
            invoke_viiiji,
            invoke_viiijii,
            invoke_viiijiii,
            invoke_viiijiiii,
            invoke_viiijiiiijjj,
            invoke_viiijiiijii,
            invoke_viiijij,
            invoke_viiijiji,
            invoke_viiijijij,
            invoke_viiijijj,
            invoke_viiijijjj,
            invoke_viiijj,
            invoke_viiijji,
            invoke_viiijjii,
            invoke_viiijjiii,
            invoke_viiijjiij,
            invoke_viiijjij,
            invoke_viiijjj,
            invoke_viiijjjj,
            invoke_viiijjjji,
            invoke_viij,
            invoke_viiji,
            invoke_viijii,
            invoke_viijiii,
            invoke_viijiiii,
            invoke_viijiiiii,
            invoke_viijiiiiii,
            invoke_viijiiiij,
            invoke_viijiiij,
            invoke_viijiiijj,
            invoke_viijiij,
            invoke_viijiiji,
            invoke_viijiijj,
            invoke_viijij,
            invoke_viijiji,
            invoke_viijijiiii,
            invoke_viijijiiiijjj,
            invoke_viijijj,
            invoke_viijj,
            invoke_viijji,
            invoke_viijjii,
            invoke_viijjj,
            invoke_viijjji,
            invoke_vij,
            invoke_viji,
            invoke_vijii,
            invoke_vijiii,
            invoke_vijiiii,
            invoke_vijiiiii,
            invoke_vijiiiiii,
            invoke_vijiiiiji,
            invoke_vijiiiji,
            invoke_vijiij,
            invoke_vijiji,
            invoke_vijijiiiijjj,
            invoke_vijijj,
            invoke_vijijjiij,
            invoke_vijijjji,
            invoke_vijj,
            invoke_vijji,
            invoke_vijjiii,
            invoke_vijjij,
            invoke_vijjj,
            invoke_vijjji,
            invoke_vijjjiiji,
            invoke_vijjjj,
            invoke_vj,
            invoke_vjii,
            invoke_vjiii,
            invoke_vjiiii,
            invoke_vjiiiji,
            invoke_vjjii,
            invoke_vjjijij,
            lineColor: _lineColor,
            lineRGBA: _lineRGBA,
            llvm_eh_typeid_for: _llvm_eh_typeid_for,
            memory: wasmMemory,
            pixelRGBA: _pixelRGBA,
            proc_exit: _proc_exit,
            pthread_kill: _pthread_kill,
            random_get: _random_get,
            rectangleColor: _rectangleColor,
            rectangleRGBA: _rectangleRGBA,
            rotozoomSurface: _rotozoomSurface,
            setNetworkCallback: _setNetworkCallback,
            setprotoent: _setprotoent,
            strftime: _strftime,
            strftime_l: _strftime_l,
            strptime: _strptime,
            strptime_l: _strptime_l,
            uuid_clear: _uuid_clear,
            uuid_compare: _uuid_compare,
            uuid_copy: _uuid_copy,
            uuid_generate: _uuid_generate,
            uuid_is_null: _uuid_is_null,
            uuid_parse: _uuid_parse,
            uuid_type: _uuid_type,
            uuid_unparse: _uuid_unparse,
            uuid_unparse_lower: _uuid_unparse_lower,
            uuid_unparse_upper: _uuid_unparse_upper,
            uuid_variant: _uuid_variant,
            zoomSurface: _zoomSurface
          };
          var wasmExports = createWasm();
          var _main = Module["_main"] = (a0, a1) => (_main = Module["_main"] = wasmExports["main"])(a0, a1);
          var _malloc = Module["_malloc"] = (a0) => (_malloc = Module["_malloc"] = wasmExports["malloc"])(a0);
          var _free = Module["_free"] = (a0) => (_free = Module["_free"] = wasmExports["free"])(a0);
          var _duckdb_web_fs_glob_add_path = Module["_duckdb_web_fs_glob_add_path"] = (a0) => (_duckdb_web_fs_glob_add_path = Module["_duckdb_web_fs_glob_add_path"] = wasmExports["duckdb_web_fs_glob_add_path"])(a0);
          var _duckdb_web_clear_response = Module["_duckdb_web_clear_response"] = () => (_duckdb_web_clear_response = Module["_duckdb_web_clear_response"] = wasmExports["duckdb_web_clear_response"])();
          var _duckdb_web_fail_with = Module["_duckdb_web_fail_with"] = (a0) => (_duckdb_web_fail_with = Module["_duckdb_web_fail_with"] = wasmExports["duckdb_web_fail_with"])(a0);
          var _duckdb_web_reset = Module["_duckdb_web_reset"] = (a0) => (_duckdb_web_reset = Module["_duckdb_web_reset"] = wasmExports["duckdb_web_reset"])(a0);
          var _duckdb_web_connect = Module["_duckdb_web_connect"] = () => (_duckdb_web_connect = Module["_duckdb_web_connect"] = wasmExports["duckdb_web_connect"])();
          var _duckdb_web_disconnect = Module["_duckdb_web_disconnect"] = (a0) => (_duckdb_web_disconnect = Module["_duckdb_web_disconnect"] = wasmExports["duckdb_web_disconnect"])(a0);
          var _duckdb_web_access_buffer = Module["_duckdb_web_access_buffer"] = (a0, a1) => (_duckdb_web_access_buffer = Module["_duckdb_web_access_buffer"] = wasmExports["duckdb_web_access_buffer"])(a0, a1);
          var _duckdb_web_flush_files = Module["_duckdb_web_flush_files"] = () => (_duckdb_web_flush_files = Module["_duckdb_web_flush_files"] = wasmExports["duckdb_web_flush_files"])();
          var _duckdb_web_flush_file = Module["_duckdb_web_flush_file"] = (a0) => (_duckdb_web_flush_file = Module["_duckdb_web_flush_file"] = wasmExports["duckdb_web_flush_file"])(a0);
          var _duckdb_web_open = Module["_duckdb_web_open"] = (a0, a1) => (_duckdb_web_open = Module["_duckdb_web_open"] = wasmExports["duckdb_web_open"])(a0, a1);
          var _duckdb_web_get_global_file_info = Module["_duckdb_web_get_global_file_info"] = (a0, a1) => (_duckdb_web_get_global_file_info = Module["_duckdb_web_get_global_file_info"] = wasmExports["duckdb_web_get_global_file_info"])(a0, a1);
          var _duckdb_web_collect_file_stats = Module["_duckdb_web_collect_file_stats"] = (a0, a1, a2) => (_duckdb_web_collect_file_stats = Module["_duckdb_web_collect_file_stats"] = wasmExports["duckdb_web_collect_file_stats"])(a0, a1, a2);
          var _duckdb_web_export_file_stats = Module["_duckdb_web_export_file_stats"] = (a0, a1) => (_duckdb_web_export_file_stats = Module["_duckdb_web_export_file_stats"] = wasmExports["duckdb_web_export_file_stats"])(a0, a1);
          var _duckdb_web_fs_drop_file = Module["_duckdb_web_fs_drop_file"] = (a0, a1) => (_duckdb_web_fs_drop_file = Module["_duckdb_web_fs_drop_file"] = wasmExports["duckdb_web_fs_drop_file"])(a0, a1);
          var _duckdb_web_fs_drop_files = Module["_duckdb_web_fs_drop_files"] = (a0) => (_duckdb_web_fs_drop_files = Module["_duckdb_web_fs_drop_files"] = wasmExports["duckdb_web_fs_drop_files"])(a0);
          var _duckdb_web_fs_glob_file_infos = Module["_duckdb_web_fs_glob_file_infos"] = (a0, a1) => (_duckdb_web_fs_glob_file_infos = Module["_duckdb_web_fs_glob_file_infos"] = wasmExports["duckdb_web_fs_glob_file_infos"])(a0, a1);
          var _duckdb_web_fs_get_file_info_by_id = Module["_duckdb_web_fs_get_file_info_by_id"] = (a0, a1, a2) => (_duckdb_web_fs_get_file_info_by_id = Module["_duckdb_web_fs_get_file_info_by_id"] = wasmExports["duckdb_web_fs_get_file_info_by_id"])(a0, a1, a2);
          var _duckdb_web_fs_get_file_info_by_name = Module["_duckdb_web_fs_get_file_info_by_name"] = (a0, a1, a2) => (_duckdb_web_fs_get_file_info_by_name = Module["_duckdb_web_fs_get_file_info_by_name"] = wasmExports["duckdb_web_fs_get_file_info_by_name"])(a0, a1, a2);
          var _duckdb_web_fs_register_file_url = Module["_duckdb_web_fs_register_file_url"] = (a0, a1, a2, a3, a4) => (_duckdb_web_fs_register_file_url = Module["_duckdb_web_fs_register_file_url"] = wasmExports["duckdb_web_fs_register_file_url"])(a0, a1, a2, a3, a4);
          var _duckdb_web_fs_register_file_buffer = Module["_duckdb_web_fs_register_file_buffer"] = (a0, a1, a2, a3) => (_duckdb_web_fs_register_file_buffer = Module["_duckdb_web_fs_register_file_buffer"] = wasmExports["duckdb_web_fs_register_file_buffer"])(a0, a1, a2, a3);
          var _duckdb_web_copy_file_to_buffer = Module["_duckdb_web_copy_file_to_buffer"] = (a0, a1) => (_duckdb_web_copy_file_to_buffer = Module["_duckdb_web_copy_file_to_buffer"] = wasmExports["duckdb_web_copy_file_to_buffer"])(a0, a1);
          var _duckdb_web_copy_file_to_path = Module["_duckdb_web_copy_file_to_path"] = (a0, a1, a2) => (_duckdb_web_copy_file_to_path = Module["_duckdb_web_copy_file_to_path"] = wasmExports["duckdb_web_copy_file_to_path"])(a0, a1, a2);
          var _duckdb_web_get_version = Module["_duckdb_web_get_version"] = (a0) => (_duckdb_web_get_version = Module["_duckdb_web_get_version"] = wasmExports["duckdb_web_get_version"])(a0);
          var _duckdb_web_get_feature_flags = Module["_duckdb_web_get_feature_flags"] = () => (_duckdb_web_get_feature_flags = Module["_duckdb_web_get_feature_flags"] = wasmExports["duckdb_web_get_feature_flags"])();
          var _duckdb_web_tokenize = Module["_duckdb_web_tokenize"] = (a0, a1) => (_duckdb_web_tokenize = Module["_duckdb_web_tokenize"] = wasmExports["duckdb_web_tokenize"])(a0, a1);
          var _duckdb_web_udf_scalar_create = Module["_duckdb_web_udf_scalar_create"] = (a0, a1, a2) => (_duckdb_web_udf_scalar_create = Module["_duckdb_web_udf_scalar_create"] = wasmExports["duckdb_web_udf_scalar_create"])(a0, a1, a2);
          var _duckdb_web_prepared_create = Module["_duckdb_web_prepared_create"] = (a0, a1, a2) => (_duckdb_web_prepared_create = Module["_duckdb_web_prepared_create"] = wasmExports["duckdb_web_prepared_create"])(a0, a1, a2);
          var _duckdb_web_prepared_close = Module["_duckdb_web_prepared_close"] = (a0, a1, a2) => (_duckdb_web_prepared_close = Module["_duckdb_web_prepared_close"] = wasmExports["duckdb_web_prepared_close"])(a0, a1, a2);
          var _duckdb_web_prepared_run = Module["_duckdb_web_prepared_run"] = (a0, a1, a2, a3) => (_duckdb_web_prepared_run = Module["_duckdb_web_prepared_run"] = wasmExports["duckdb_web_prepared_run"])(a0, a1, a2, a3);
          var _duckdb_web_prepared_send = Module["_duckdb_web_prepared_send"] = (a0, a1, a2, a3) => (_duckdb_web_prepared_send = Module["_duckdb_web_prepared_send"] = wasmExports["duckdb_web_prepared_send"])(a0, a1, a2, a3);
          var _duckdb_web_query_run = Module["_duckdb_web_query_run"] = (a0, a1, a2) => (_duckdb_web_query_run = Module["_duckdb_web_query_run"] = wasmExports["duckdb_web_query_run"])(a0, a1, a2);
          var _duckdb_web_pending_query_start = Module["_duckdb_web_pending_query_start"] = (a0, a1, a2) => (_duckdb_web_pending_query_start = Module["_duckdb_web_pending_query_start"] = wasmExports["duckdb_web_pending_query_start"])(a0, a1, a2);
          var _duckdb_web_pending_query_poll = Module["_duckdb_web_pending_query_poll"] = (a0, a1, a2) => (_duckdb_web_pending_query_poll = Module["_duckdb_web_pending_query_poll"] = wasmExports["duckdb_web_pending_query_poll"])(a0, a1, a2);
          var _duckdb_web_pending_query_cancel = Module["_duckdb_web_pending_query_cancel"] = (a0, a1) => (_duckdb_web_pending_query_cancel = Module["_duckdb_web_pending_query_cancel"] = wasmExports["duckdb_web_pending_query_cancel"])(a0, a1);
          var _duckdb_web_query_fetch_results = Module["_duckdb_web_query_fetch_results"] = (a0, a1) => (_duckdb_web_query_fetch_results = Module["_duckdb_web_query_fetch_results"] = wasmExports["duckdb_web_query_fetch_results"])(a0, a1);
          var _duckdb_web_get_tablenames = Module["_duckdb_web_get_tablenames"] = (a0, a1, a2) => (_duckdb_web_get_tablenames = Module["_duckdb_web_get_tablenames"] = wasmExports["duckdb_web_get_tablenames"])(a0, a1, a2);
          var _duckdb_web_insert_arrow_from_ipc_stream = Module["_duckdb_web_insert_arrow_from_ipc_stream"] = (a0, a1, a2, a3, a4) => (_duckdb_web_insert_arrow_from_ipc_stream = Module["_duckdb_web_insert_arrow_from_ipc_stream"] = wasmExports["duckdb_web_insert_arrow_from_ipc_stream"])(a0, a1, a2, a3, a4);
          var _duckdb_web_insert_csv_from_path = Module["_duckdb_web_insert_csv_from_path"] = (a0, a1, a2, a3) => (_duckdb_web_insert_csv_from_path = Module["_duckdb_web_insert_csv_from_path"] = wasmExports["duckdb_web_insert_csv_from_path"])(a0, a1, a2, a3);
          var _duckdb_web_insert_json_from_path = Module["_duckdb_web_insert_json_from_path"] = (a0, a1, a2, a3) => (_duckdb_web_insert_json_from_path = Module["_duckdb_web_insert_json_from_path"] = wasmExports["duckdb_web_insert_json_from_path"])(a0, a1, a2, a3);
          var _duckdb_web_fts_init = Module["_duckdb_web_fts_init"] = (a0) => (_duckdb_web_fts_init = Module["_duckdb_web_fts_init"] = wasmExports["duckdb_web_fts_init"])(a0);
          var _duckdb_web_parquet_init = Module["_duckdb_web_parquet_init"] = (a0) => (_duckdb_web_parquet_init = Module["_duckdb_web_parquet_init"] = wasmExports["duckdb_web_parquet_init"])(a0);
          var _freeaddrinfo = Module["_freeaddrinfo"] = (a0) => (_freeaddrinfo = Module["_freeaddrinfo"] = wasmExports["freeaddrinfo"])(a0);
          var _freeifaddrs = Module["_freeifaddrs"] = (a0) => (_freeifaddrs = Module["_freeifaddrs"] = wasmExports["freeifaddrs"])(a0);
          var _freelocale = Module["_freelocale"] = (a0) => (_freelocale = Module["_freelocale"] = wasmExports["freelocale"])(a0);
          var _malloc_trim = Module["_malloc_trim"] = (a0) => (_malloc_trim = Module["_malloc_trim"] = wasmExports["malloc_trim"])(a0);
          var _malloc_usable_size = Module["_malloc_usable_size"] = (a0) => (_malloc_usable_size = Module["_malloc_usable_size"] = wasmExports["malloc_usable_size"])(a0);
          var _malloc_footprint = Module["_malloc_footprint"] = () => (_malloc_footprint = Module["_malloc_footprint"] = wasmExports["malloc_footprint"])();
          var _malloc_max_footprint = Module["_malloc_max_footprint"] = () => (_malloc_max_footprint = Module["_malloc_max_footprint"] = wasmExports["malloc_max_footprint"])();
          var _malloc_footprint_limit = Module["_malloc_footprint_limit"] = () => (_malloc_footprint_limit = Module["_malloc_footprint_limit"] = wasmExports["malloc_footprint_limit"])();
          var _malloc_set_footprint_limit = Module["_malloc_set_footprint_limit"] = (a0) => (_malloc_set_footprint_limit = Module["_malloc_set_footprint_limit"] = wasmExports["malloc_set_footprint_limit"])(a0);
          var stackSave = () => (stackSave = wasmExports["stackSave"])();
          var stackRestore = (a0) => (stackRestore = wasmExports["stackRestore"])(a0);
          var stackAlloc = (a0) => (stackAlloc = wasmExports["stackAlloc"])(a0);
          var __ZTVN5arrow15BaseListBuilderINS_8ListTypeEEE = Module["__ZTVN5arrow15BaseListBuilderINS_8ListTypeEEE"] = 1762e3;
          var __ZTSN6duckdb15SetseedBindDataE = Module["__ZTSN6duckdb15SetseedBindDataE"] = 461e3;
          var __ZTIN6duckdb18DuckDBSettingsDataE = Module["__ZTIN6duckdb18DuckDBSettingsDataE"] = 1958e3;
          var __ZN6duckdb11BoxRenderer12SPLIT_COLUMNE = Module["__ZN6duckdb11BoxRenderer12SPLIT_COLUMNE"] = 534e3;
          var __ZTIN6duckdb11PhysicalSetE = Module["__ZTIN6duckdb11PhysicalSetE"] = 1985e3;
          var __ZTIN6duckdb21BatchCopyToLocalStateE = Module["__ZTIN6duckdb21BatchCopyToLocalStateE"] = 1992e3;
          var __ZTIN6duckdb17UpdateGlobalStateE = Module["__ZTIN6duckdb17UpdateGlobalStateE"] = 1993e3;
          var __ZTVNSt3__220__shared_ptr_emplaceIN6duckdb16SubqueryRelationENS_9allocatorIS2_EEEE = Module["__ZTVNSt3__220__shared_ptr_emplaceIN6duckdb16SubqueryRelationENS_9allocatorIS2_EEEE"] = 2008e3;
          var __ZTVN6duckdb16RLECompressStateIxLb1EEE = Module["__ZTVN6duckdb16RLECompressStateIxLb1EEE"] = 201e4;
          var __ZTINSt3__220__shared_ptr_emplaceIN6duckdb16ColumnStatisticsENS_9allocatorIS2_EEEE = Module["__ZTINSt3__220__shared_ptr_emplaceIN6duckdb16ColumnStatisticsENS_9allocatorIS2_EEEE"] = 2015e3;
          var __ZTIN6duckdb15DuckTransactionE = Module["__ZTIN6duckdb15DuckTransactionE"] = 2019e3;
          var __ZTVN5arrow9ListArrayE = Module["__ZTVN5arrow9ListArrayE"] = 2052e3;
          var __ZTIZN5arrow22ValueComparatorVisitor5VisitINS_14DenseUnionTypeEEENS_6StatusERKT_EUlRKNS_5ArrayExS9_xE_ = Module["__ZTIZN5arrow22ValueComparatorVisitor5VisitINS_14DenseUnionTypeEEENS_6StatusERKT_EUlRKNS_5ArrayExS9_xE_"] = 2057e3;
          var __ZTIZN5arrow17MakeFormatterImpl5VisitINS_10BinaryTypeEEENSt3__29enable_ifIXsr19is_binary_like_typeIT_EE5valueENS_6StatusEE4typeERKS5_EUlRKNS_5ArrayExPNS3_13basic_ostreamIcNS3_11char_traitsIcEEEEE_ = Module["__ZTIZN5arrow17MakeFormatterImpl5VisitINS_10BinaryTypeEEENSt3__29enable_ifIXsr19is_binary_like_typeIT_EE5valueENS_6StatusEE4typeERKS5_EUlRKNS_5ArrayExPNS3_13basic_ostreamIcNS3_11char_traitsIcEEEEE_"] = 2058e3;
          var __ZTIN5arrow8internal21DictionaryBuilderBaseINS_20TypeErasedIntBuilderENS_17MonthIntervalTypeEEE = Module["__ZTIN5arrow8internal21DictionaryBuilderBaseINS_20TypeErasedIntBuilderENS_17MonthIntervalTypeEEE"] = 2067e3;
          var __ZTVNSt3__220__shared_ptr_emplaceIN5arrow14SparseCSFIndexENS_9allocatorIS2_EEEE = Module["__ZTVNSt3__220__shared_ptr_emplaceIN5arrow14SparseCSFIndexENS_9allocatorIS2_EEEE"] = 2071e3;
          var __ZTVN5arrow10UInt32TypeE = Module["__ZTVN5arrow10UInt32TypeE"] = 2075e3;
          var __ZTVNSt3__220__shared_ptr_emplaceIN5arrow10StringTypeENS_9allocatorIS2_EEEE = Module["__ZTVNSt3__220__shared_ptr_emplaceIN5arrow10StringTypeENS_9allocatorIS2_EEEE"] = 2076e3;
          var __ZN5arrow7compute27ElementWiseAggregateOptions9kTypeNameE = Module["__ZN5arrow7compute27ElementWiseAggregateOptions9kTypeNameE"] = 1372e3;
          var __ZTIZN5arrow7compute8internal22GetFunctionOptionsTypeINS0_16MapLookupOptionsEJNS_8internal18DataMemberPropertyIS3_NS3_10OccurrenceEEENS5_IS3_NSt3__210shared_ptrINS_6ScalarEEEEEEEEPKNS0_19FunctionOptionsTypeEDpRKT0_E11OptionsType = Module["__ZTIZN5arrow7compute8internal22GetFunctionOptionsTypeINS0_16MapLookupOptionsEJNS_8internal18DataMemberPropertyIS3_NS3_10OccurrenceEEENS5_IS3_NSt3__210shared_ptrINS_6ScalarEEEEEEEEPKNS0_19FunctionOptionsTypeEDpRKT0_E11OptionsType"] = 2099e3;
          var __ZTVN5arrow7compute11SortOptionsE = Module["__ZTVN5arrow7compute11SortOptionsE"] = 2101e3;
          var __ZTVNSt3__220__shared_ptr_emplaceIN5arrow7compute11CastOptionsENS_9allocatorIS3_EEEE = Module["__ZTVNSt3__220__shared_ptr_emplaceIN5arrow7compute11CastOptionsENS_9allocatorIS3_EEEE"] = 2103e3;
          var __ZTVNSt3__210__stdinbufIcEE = Module["__ZTVNSt3__210__stdinbufIcEE"] = 2117e3;
          var __ZTVNSt3__27codecvtIDsc11__mbstate_tEE = Module["__ZTVNSt3__27codecvtIDsc11__mbstate_tEE"] = 2118e3;
          var __ZTINSt3__215__codecvt_utf16IDsLb1EEE = Module["__ZTINSt3__215__codecvt_utf16IDsLb1EEE"] = 2119e3;
          var __ZNSt3__212__rs_default4__c_E = Module["__ZNSt3__212__rs_default4__c_E"] = 2209e3;
          function invoke_ii(index, a1) {
            var sp = stackSave();
            try {
              return getWasmTableEntry(index)(a1);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_vii(index, a1, a2) {
            var sp = stackSave();
            try {
              getWasmTableEntry(index)(a1, a2);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viii(index, a1, a2, a3) {
            var sp = stackSave();
            try {
              getWasmTableEntry(index)(a1, a2, a3);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viiii(index, a1, a2, a3, a4) {
            var sp = stackSave();
            try {
              getWasmTableEntry(index)(a1, a2, a3, a4);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iii(index, a1, a2) {
            var sp = stackSave();
            try {
              return getWasmTableEntry(index)(a1, a2);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viiiiii(index, a1, a2, a3, a4, a5, a6) {
            var sp = stackSave();
            try {
              getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_dii(index, a1, a2) {
            var sp = stackSave();
            try {
              return getWasmTableEntry(index)(a1, a2);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {
            var sp = stackSave();
            try {
              getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_vi(index, a1) {
            var sp = stackSave();
            try {
              getWasmTableEntry(index)(a1);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiiii(index, a1, a2, a3, a4) {
            var sp = stackSave();
            try {
              return getWasmTableEntry(index)(a1, a2, a3, a4);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiiiiii(index, a1, a2, a3, a4, a5, a6) {
            var sp = stackSave();
            try {
              return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {
            var sp = stackSave();
            try {
              return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiii(index, a1, a2, a3) {
            var sp = stackSave();
            try {
              return getWasmTableEntry(index)(a1, a2, a3);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_v(index) {
            var sp = stackSave();
            try {
              getWasmTableEntry(index)();
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_i(index) {
            var sp = stackSave();
            try {
              return getWasmTableEntry(index)();
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8) {
            var sp = stackSave();
            try {
              return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiiiii(index, a1, a2, a3, a4, a5) {
            var sp = stackSave();
            try {
              return getWasmTableEntry(index)(a1, a2, a3, a4, a5);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viiiii(index, a1, a2, a3, a4, a5) {
            var sp = stackSave();
            try {
              getWasmTableEntry(index)(a1, a2, a3, a4, a5);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viif(index, a1, a2, a3) {
            var sp = stackSave();
            try {
              getWasmTableEntry(index)(a1, a2, a3);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viid(index, a1, a2, a3) {
            var sp = stackSave();
            try {
              getWasmTableEntry(index)(a1, a2, a3);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iid(index, a1, a2) {
            var sp = stackSave();
            try {
              return getWasmTableEntry(index)(a1, a2);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiiiiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) {
            var sp = stackSave();
            try {
              return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_vid(index, a1, a2) {
            var sp = stackSave();
            try {
              getWasmTableEntry(index)(a1, a2);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiiiiid(index, a1, a2, a3, a4, a5, a6) {
            var sp = stackSave();
            try {
              return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
            var sp = stackSave();
            try {
              getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
            var sp = stackSave();
            try {
              getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_di(index, a1) {
            var sp = stackSave();
            try {
              return getWasmTableEntry(index)(a1);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_vif(index, a1, a2) {
            var sp = stackSave();
            try {
              getWasmTableEntry(index)(a1, a2);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
            var sp = stackSave();
            try {
              return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8) {
            var sp = stackSave();
            try {
              getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
            var sp = stackSave();
            try {
              return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiid(index, a1, a2, a3) {
            var sp = stackSave();
            try {
              return getWasmTableEntry(index)(a1, a2, a3);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiiiiiiiiiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17) {
            var sp = stackSave();
            try {
              return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iidii(index, a1, a2, a3, a4) {
            var sp = stackSave();
            try {
              return getWasmTableEntry(index)(a1, a2, a3, a4);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_fi(index, a1) {
            var sp = stackSave();
            try {
              return getWasmTableEntry(index)(a1);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiiiiiiiiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16) {
            var sp = stackSave();
            try {
              return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiiiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {
            var sp = stackSave();
            try {
              return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_fiiii(index, a1, a2, a3, a4) {
            var sp = stackSave();
            try {
              return getWasmTableEntry(index)(a1, a2, a3, a4);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_diiii(index, a1, a2, a3, a4) {
            var sp = stackSave();
            try {
              return getWasmTableEntry(index)(a1, a2, a3, a4);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viddddi(index, a1, a2, a3, a4, a5, a6) {
            var sp = stackSave();
            try {
              getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_diiiiid(index, a1, a2, a3, a4, a5, a6) {
            var sp = stackSave();
            try {
              return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiiid(index, a1, a2, a3, a4) {
            var sp = stackSave();
            try {
              return getWasmTableEntry(index)(a1, a2, a3, a4);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_idiii(index, a1, a2, a3, a4) {
            var sp = stackSave();
            try {
              return getWasmTableEntry(index)(a1, a2, a3, a4);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viiiiiidiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
            var sp = stackSave();
            try {
              getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viidii(index, a1, a2, a3, a4, a5) {
            var sp = stackSave();
            try {
              getWasmTableEntry(index)(a1, a2, a3, a4, a5);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iff(index, a1, a2) {
            var sp = stackSave();
            try {
              return getWasmTableEntry(index)(a1, a2);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_idd(index, a1, a2) {
            var sp = stackSave();
            try {
              return getWasmTableEntry(index)(a1, a2);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiiiiiiiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) {
            var sp = stackSave();
            try {
              return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_if(index, a1) {
            var sp = stackSave();
            try {
              return getWasmTableEntry(index)(a1);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_id(index, a1) {
            var sp = stackSave();
            try {
              return getWasmTableEntry(index)(a1);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_idiiii(index, a1, a2, a3, a4, a5) {
            var sp = stackSave();
            try {
              return getWasmTableEntry(index)(a1, a2, a3, a4, a5);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_ifii(index, a1, a2, a3) {
            var sp = stackSave();
            try {
              return getWasmTableEntry(index)(a1, a2, a3);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_idii(index, a1, a2, a3) {
            var sp = stackSave();
            try {
              return getWasmTableEntry(index)(a1, a2, a3);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_ifi(index, a1, a2) {
            var sp = stackSave();
            try {
              return getWasmTableEntry(index)(a1, a2);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_idi(index, a1, a2) {
            var sp = stackSave();
            try {
              return getWasmTableEntry(index)(a1, a2);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_vifi(index, a1, a2, a3) {
            var sp = stackSave();
            try {
              getWasmTableEntry(index)(a1, a2, a3);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_vidi(index, a1, a2, a3) {
            var sp = stackSave();
            try {
              getWasmTableEntry(index)(a1, a2, a3);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viiiidiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
            var sp = stackSave();
            try {
              getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_diii(index, a1, a2, a3) {
            var sp = stackSave();
            try {
              return getWasmTableEntry(index)(a1, a2, a3);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_vfii(index, a1, a2, a3) {
            var sp = stackSave();
            try {
              getWasmTableEntry(index)(a1, a2, a3);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_vdii(index, a1, a2, a3) {
            var sp = stackSave();
            try {
              getWasmTableEntry(index)(a1, a2, a3);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viiiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {
            var sp = stackSave();
            try {
              getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iifii(index, a1, a2, a3, a4) {
            var sp = stackSave();
            try {
              return getWasmTableEntry(index)(a1, a2, a3, a4);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iif(index, a1, a2) {
            var sp = stackSave();
            try {
              return getWasmTableEntry(index)(a1, a2);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iidiii(index, a1, a2, a3, a4, a5) {
            var sp = stackSave();
            try {
              return getWasmTableEntry(index)(a1, a2, a3, a4, a5);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iidiiii(index, a1, a2, a3, a4, a5, a6) {
            var sp = stackSave();
            try {
              return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iidi(index, a1, a2, a3) {
            var sp = stackSave();
            try {
              return getWasmTableEntry(index)(a1, a2, a3);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viiiiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) {
            var sp = stackSave();
            try {
              getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_vifii(index, a1, a2, a3, a4) {
            var sp = stackSave();
            try {
              getWasmTableEntry(index)(a1, a2, a3, a4);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_vidii(index, a1, a2, a3, a4) {
            var sp = stackSave();
            try {
              getWasmTableEntry(index)(a1, a2, a3, a4);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viiifi(index, a1, a2, a3, a4, a5) {
            var sp = stackSave();
            try {
              getWasmTableEntry(index)(a1, a2, a3, a4, a5);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viiidi(index, a1, a2, a3, a4, a5) {
            var sp = stackSave();
            try {
              getWasmTableEntry(index)(a1, a2, a3, a4, a5);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiiiid(index, a1, a2, a3, a4, a5) {
            var sp = stackSave();
            try {
              return getWasmTableEntry(index)(a1, a2, a3, a4, a5);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_fiii(index, a1, a2, a3) {
            var sp = stackSave();
            try {
              return getWasmTableEntry(index)(a1, a2, a3);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viiiiiiiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) {
            var sp = stackSave();
            try {
              getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viji(index, a1, a2, a3, a4) {
            var sp = stackSave();
            try {
              Module["dynCall_viji"](index, a1, a2, a3, a4);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_ji(index, a1) {
            var sp = stackSave();
            try {
              return Module["dynCall_ji"](index, a1);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viiji(index, a1, a2, a3, a4, a5) {
            var sp = stackSave();
            try {
              Module["dynCall_viiji"](index, a1, a2, a3, a4, a5);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iij(index, a1, a2, a3) {
            var sp = stackSave();
            try {
              return Module["dynCall_iij"](index, a1, a2, a3);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iijiijj(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
            var sp = stackSave();
            try {
              return Module["dynCall_iijiijj"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiijiijj(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
            var sp = stackSave();
            try {
              return Module["dynCall_iiijiijj"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viij(index, a1, a2, a3, a4) {
            var sp = stackSave();
            try {
              Module["dynCall_viij"](index, a1, a2, a3, a4);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiijj(index, a1, a2, a3, a4, a5, a6) {
            var sp = stackSave();
            try {
              return Module["dynCall_iiijj"](index, a1, a2, a3, a4, a5, a6);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viiijj(index, a1, a2, a3, a4, a5, a6, a7) {
            var sp = stackSave();
            try {
              Module["dynCall_viiijj"](index, a1, a2, a3, a4, a5, a6, a7);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_jii(index, a1, a2) {
            var sp = stackSave();
            try {
              return Module["dynCall_jii"](index, a1, a2);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_vij(index, a1, a2, a3) {
            var sp = stackSave();
            try {
              Module["dynCall_vij"](index, a1, a2, a3);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiijii(index, a1, a2, a3, a4, a5, a6) {
            var sp = stackSave();
            try {
              return Module["dynCall_iiijii"](index, a1, a2, a3, a4, a5, a6);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viijii(index, a1, a2, a3, a4, a5, a6) {
            var sp = stackSave();
            try {
              Module["dynCall_viijii"](index, a1, a2, a3, a4, a5, a6);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiij(index, a1, a2, a3, a4) {
            var sp = stackSave();
            try {
              return Module["dynCall_iiij"](index, a1, a2, a3, a4);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viiij(index, a1, a2, a3, a4, a5) {
            var sp = stackSave();
            try {
              Module["dynCall_viiij"](index, a1, a2, a3, a4, a5);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiiij(index, a1, a2, a3, a4, a5) {
            var sp = stackSave();
            try {
              return Module["dynCall_iiiij"](index, a1, a2, a3, a4, a5);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viijijj(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
            var sp = stackSave();
            try {
              Module["dynCall_viijijj"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiiiij(index, a1, a2, a3, a4, a5, a6) {
            var sp = stackSave();
            try {
              return Module["dynCall_iiiiij"](index, a1, a2, a3, a4, a5, a6);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viijiijj(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
            var sp = stackSave();
            try {
              Module["dynCall_viijiijj"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiiji(index, a1, a2, a3, a4, a5) {
            var sp = stackSave();
            try {
              return Module["dynCall_iiiji"](index, a1, a2, a3, a4, a5);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiji(index, a1, a2, a3, a4) {
            var sp = stackSave();
            try {
              return Module["dynCall_iiji"](index, a1, a2, a3, a4);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_jiiij(index, a1, a2, a3, a4, a5) {
            var sp = stackSave();
            try {
              return Module["dynCall_jiiij"](index, a1, a2, a3, a4, a5);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viiiji(index, a1, a2, a3, a4, a5, a6) {
            var sp = stackSave();
            try {
              Module["dynCall_viiiji"](index, a1, a2, a3, a4, a5, a6);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_jj(index, a1, a2) {
            var sp = stackSave();
            try {
              return Module["dynCall_jj"](index, a1, a2);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iijjii(index, a1, a2, a3, a4, a5, a6, a7) {
            var sp = stackSave();
            try {
              return Module["dynCall_iijjii"](index, a1, a2, a3, a4, a5, a6, a7);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_vijji(index, a1, a2, a3, a4, a5, a6) {
            var sp = stackSave();
            try {
              Module["dynCall_vijji"](index, a1, a2, a3, a4, a5, a6);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iijii(index, a1, a2, a3, a4, a5) {
            var sp = stackSave();
            try {
              return Module["dynCall_iijii"](index, a1, a2, a3, a4, a5);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiiiijj(index, a1, a2, a3, a4, a5, a6, a7, a8) {
            var sp = stackSave();
            try {
              return Module["dynCall_iiiiijj"](index, a1, a2, a3, a4, a5, a6, a7, a8);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_jiiiii(index, a1, a2, a3, a4, a5) {
            var sp = stackSave();
            try {
              return Module["dynCall_jiiiii"](index, a1, a2, a3, a4, a5);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viiijii(index, a1, a2, a3, a4, a5, a6, a7) {
            var sp = stackSave();
            try {
              Module["dynCall_viiijii"](index, a1, a2, a3, a4, a5, a6, a7);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiiijii(index, a1, a2, a3, a4, a5, a6, a7) {
            var sp = stackSave();
            try {
              return Module["dynCall_iiiijii"](index, a1, a2, a3, a4, a5, a6, a7);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viiiijii(index, a1, a2, a3, a4, a5, a6, a7, a8) {
            var sp = stackSave();
            try {
              Module["dynCall_viiiijii"](index, a1, a2, a3, a4, a5, a6, a7, a8);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiijiii(index, a1, a2, a3, a4, a5, a6, a7) {
            var sp = stackSave();
            try {
              return Module["dynCall_iiijiii"](index, a1, a2, a3, a4, a5, a6, a7);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiiiijii(index, a1, a2, a3, a4, a5, a6, a7, a8) {
            var sp = stackSave();
            try {
              return Module["dynCall_iiiiijii"](index, a1, a2, a3, a4, a5, a6, a7, a8);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viijiiii(index, a1, a2, a3, a4, a5, a6, a7, a8) {
            var sp = stackSave();
            try {
              Module["dynCall_viijiiii"](index, a1, a2, a3, a4, a5, a6, a7, a8);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viijiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
            var sp = stackSave();
            try {
              Module["dynCall_viijiiiii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiijiij(index, a1, a2, a3, a4, a5, a6, a7, a8) {
            var sp = stackSave();
            try {
              return Module["dynCall_iiijiij"](index, a1, a2, a3, a4, a5, a6, a7, a8);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_vijiii(index, a1, a2, a3, a4, a5, a6) {
            var sp = stackSave();
            try {
              Module["dynCall_vijiii"](index, a1, a2, a3, a4, a5, a6);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iijjiii(index, a1, a2, a3, a4, a5, a6, a7, a8) {
            var sp = stackSave();
            try {
              return Module["dynCall_iijjiii"](index, a1, a2, a3, a4, a5, a6, a7, a8);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiijjiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
            var sp = stackSave();
            try {
              return Module["dynCall_iiijjiii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiijjii(index, a1, a2, a3, a4, a5, a6, a7, a8) {
            var sp = stackSave();
            try {
              return Module["dynCall_iiijjii"](index, a1, a2, a3, a4, a5, a6, a7, a8);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iijji(index, a1, a2, a3, a4, a5, a6) {
            var sp = stackSave();
            try {
              return Module["dynCall_iijji"](index, a1, a2, a3, a4, a5, a6);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viijiii(index, a1, a2, a3, a4, a5, a6, a7) {
            var sp = stackSave();
            try {
              Module["dynCall_viijiii"](index, a1, a2, a3, a4, a5, a6, a7);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viiiij(index, a1, a2, a3, a4, a5, a6) {
            var sp = stackSave();
            try {
              Module["dynCall_viiiij"](index, a1, a2, a3, a4, a5, a6);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_jiii(index, a1, a2, a3) {
            var sp = stackSave();
            try {
              return Module["dynCall_jiii"](index, a1, a2, a3);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_vjjii(index, a1, a2, a3, a4, a5, a6) {
            var sp = stackSave();
            try {
              Module["dynCall_vjjii"](index, a1, a2, a3, a4, a5, a6);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viiiiijii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
            var sp = stackSave();
            try {
              Module["dynCall_viiiiijii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iijiiii(index, a1, a2, a3, a4, a5, a6, a7) {
            var sp = stackSave();
            try {
              return Module["dynCall_iijiiii"](index, a1, a2, a3, a4, a5, a6, a7);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_jij(index, a1, a2, a3) {
            var sp = stackSave();
            try {
              return Module["dynCall_jij"](index, a1, a2, a3);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_vijiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
            var sp = stackSave();
            try {
              Module["dynCall_vijiiiiii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_vijiiii(index, a1, a2, a3, a4, a5, a6, a7) {
            var sp = stackSave();
            try {
              Module["dynCall_vijiiii"](index, a1, a2, a3, a4, a5, a6, a7);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_vijiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8) {
            var sp = stackSave();
            try {
              Module["dynCall_vijiiiii"](index, a1, a2, a3, a4, a5, a6, a7, a8);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viiiiji(index, a1, a2, a3, a4, a5, a6, a7) {
            var sp = stackSave();
            try {
              Module["dynCall_viiiiji"](index, a1, a2, a3, a4, a5, a6, a7);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_vijj(index, a1, a2, a3, a4, a5) {
            var sp = stackSave();
            try {
              Module["dynCall_vijj"](index, a1, a2, a3, a4, a5);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiiiji(index, a1, a2, a3, a4, a5, a6) {
            var sp = stackSave();
            try {
              return Module["dynCall_iiiiji"](index, a1, a2, a3, a4, a5, a6);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_ijji(index, a1, a2, a3, a4, a5) {
            var sp = stackSave();
            try {
              return Module["dynCall_ijji"](index, a1, a2, a3, a4, a5);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiiiiij(index, a1, a2, a3, a4, a5, a6, a7) {
            var sp = stackSave();
            try {
              return Module["dynCall_iiiiiij"](index, a1, a2, a3, a4, a5, a6, a7);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viijj(index, a1, a2, a3, a4, a5, a6) {
            var sp = stackSave();
            try {
              Module["dynCall_viijj"](index, a1, a2, a3, a4, a5, a6);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiiiiiiji(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
            var sp = stackSave();
            try {
              return Module["dynCall_iiiiiiiji"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiiiiji(index, a1, a2, a3, a4, a5, a6, a7) {
            var sp = stackSave();
            try {
              return Module["dynCall_iiiiiji"](index, a1, a2, a3, a4, a5, a6, a7);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_vj(index, a1, a2) {
            var sp = stackSave();
            try {
              Module["dynCall_vj"](index, a1, a2);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viiiiiij(index, a1, a2, a3, a4, a5, a6, a7, a8) {
            var sp = stackSave();
            try {
              Module["dynCall_viiiiiij"](index, a1, a2, a3, a4, a5, a6, a7, a8);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viiiijiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {
            var sp = stackSave();
            try {
              Module["dynCall_viiiijiiiii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viiiijiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
            var sp = stackSave();
            try {
              Module["dynCall_viiiijiiii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viiijjj(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
            var sp = stackSave();
            try {
              Module["dynCall_viiijjj"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iijjijj(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
            var sp = stackSave();
            try {
              return Module["dynCall_iijjijj"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viiiiijiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {
            var sp = stackSave();
            try {
              Module["dynCall_viiiiijiiii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_vijiji(index, a1, a2, a3, a4, a5, a6, a7) {
            var sp = stackSave();
            try {
              Module["dynCall_vijiji"](index, a1, a2, a3, a4, a5, a6, a7);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_vijjij(index, a1, a2, a3, a4, a5, a6, a7, a8) {
            var sp = stackSave();
            try {
              Module["dynCall_vijjij"](index, a1, a2, a3, a4, a5, a6, a7, a8);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_jiiji(index, a1, a2, a3, a4, a5) {
            var sp = stackSave();
            try {
              return Module["dynCall_jiiji"](index, a1, a2, a3, a4, a5);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_jjiji(index, a1, a2, a3, a4, a5, a6) {
            var sp = stackSave();
            try {
              return Module["dynCall_jjiji"](index, a1, a2, a3, a4, a5, a6);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_jijij(index, a1, a2, a3, a4, a5, a6) {
            var sp = stackSave();
            try {
              return Module["dynCall_jijij"](index, a1, a2, a3, a4, a5, a6);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_jjjd(index, a1, a2, a3, a4, a5) {
            var sp = stackSave();
            try {
              return Module["dynCall_jjjd"](index, a1, a2, a3, a4, a5);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_ij(index, a1, a2) {
            var sp = stackSave();
            try {
              return Module["dynCall_ij"](index, a1, a2);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_ijii(index, a1, a2, a3, a4) {
            var sp = stackSave();
            try {
              return Module["dynCall_ijii"](index, a1, a2, a3, a4);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_vjii(index, a1, a2, a3, a4) {
            var sp = stackSave();
            try {
              Module["dynCall_vjii"](index, a1, a2, a3, a4);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_vjiiii(index, a1, a2, a3, a4, a5, a6) {
            var sp = stackSave();
            try {
              Module["dynCall_vjiiii"](index, a1, a2, a3, a4, a5, a6);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_jiiii(index, a1, a2, a3, a4) {
            var sp = stackSave();
            try {
              return Module["dynCall_jiiii"](index, a1, a2, a3, a4);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viiiiijiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
            var sp = stackSave();
            try {
              Module["dynCall_viiiiijiii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viiiijiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14) {
            var sp = stackSave();
            try {
              Module["dynCall_viiiijiiiiiiii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_jjj(index, a1, a2, a3, a4) {
            var sp = stackSave();
            try {
              return Module["dynCall_jjj"](index, a1, a2, a3, a4);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiijjjj(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
            var sp = stackSave();
            try {
              return Module["dynCall_iiijjjj"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viiijjjj(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {
            var sp = stackSave();
            try {
              Module["dynCall_viiijjjj"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_ijjji(index, a1, a2, a3, a4, a5, a6, a7) {
            var sp = stackSave();
            try {
              return Module["dynCall_ijjji"](index, a1, a2, a3, a4, a5, a6, a7);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_j(index) {
            var sp = stackSave();
            try {
              return Module["dynCall_j"](index);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viijij(index, a1, a2, a3, a4, a5, a6, a7) {
            var sp = stackSave();
            try {
              Module["dynCall_viijij"](index, a1, a2, a3, a4, a5, a6, a7);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viijjj(index, a1, a2, a3, a4, a5, a6, a7, a8) {
            var sp = stackSave();
            try {
              Module["dynCall_viijjj"](index, a1, a2, a3, a4, a5, a6, a7, a8);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viijiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
            var sp = stackSave();
            try {
              Module["dynCall_viijiiiiii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_jjjji(index, a1, a2, a3, a4, a5, a6, a7) {
            var sp = stackSave();
            try {
              return Module["dynCall_jjjji"](index, a1, a2, a3, a4, a5, a6, a7);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_jjjii(index, a1, a2, a3, a4, a5, a6) {
            var sp = stackSave();
            try {
              return Module["dynCall_jjjii"](index, a1, a2, a3, a4, a5, a6);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_jji(index, a1, a2, a3) {
            var sp = stackSave();
            try {
              return Module["dynCall_jji"](index, a1, a2, a3);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_ijjiii(index, a1, a2, a3, a4, a5, a6, a7) {
            var sp = stackSave();
            try {
              return Module["dynCall_ijjiii"](index, a1, a2, a3, a4, a5, a6, a7);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiiiiiijii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
            var sp = stackSave();
            try {
              return Module["dynCall_iiiiiiijii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_jiijii(index, a1, a2, a3, a4, a5, a6) {
            var sp = stackSave();
            try {
              return Module["dynCall_jiijii"](index, a1, a2, a3, a4, a5, a6);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_fiijii(index, a1, a2, a3, a4, a5, a6) {
            var sp = stackSave();
            try {
              return Module["dynCall_fiijii"](index, a1, a2, a3, a4, a5, a6);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_diijii(index, a1, a2, a3, a4, a5, a6) {
            var sp = stackSave();
            try {
              return Module["dynCall_diijii"](index, a1, a2, a3, a4, a5, a6);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_vijii(index, a1, a2, a3, a4, a5) {
            var sp = stackSave();
            try {
              Module["dynCall_vijii"](index, a1, a2, a3, a4, a5);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_vjiiiji(index, a1, a2, a3, a4, a5, a6, a7, a8) {
            var sp = stackSave();
            try {
              Module["dynCall_vjiiiji"](index, a1, a2, a3, a4, a5, a6, a7, a8);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viiiiij(index, a1, a2, a3, a4, a5, a6, a7) {
            var sp = stackSave();
            try {
              Module["dynCall_viiiiij"](index, a1, a2, a3, a4, a5, a6, a7);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iijiji(index, a1, a2, a3, a4, a5, a6, a7) {
            var sp = stackSave();
            try {
              return Module["dynCall_iijiji"](index, a1, a2, a3, a4, a5, a6, a7);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiijjj(index, a1, a2, a3, a4, a5, a6, a7, a8) {
            var sp = stackSave();
            try {
              return Module["dynCall_iiijjj"](index, a1, a2, a3, a4, a5, a6, a7, a8);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_vijjji(index, a1, a2, a3, a4, a5, a6, a7, a8) {
            var sp = stackSave();
            try {
              Module["dynCall_vijjji"](index, a1, a2, a3, a4, a5, a6, a7, a8);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viijjji(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
            var sp = stackSave();
            try {
              Module["dynCall_viijjji"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viiijijij(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {
            var sp = stackSave();
            try {
              Module["dynCall_viiijijij"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viiijij(index, a1, a2, a3, a4, a5, a6, a7, a8) {
            var sp = stackSave();
            try {
              Module["dynCall_viiijij"](index, a1, a2, a3, a4, a5, a6, a7, a8);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_jiij(index, a1, a2, a3, a4) {
            var sp = stackSave();
            try {
              return Module["dynCall_jiij"](index, a1, a2, a3, a4);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_jijjjjii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {
            var sp = stackSave();
            try {
              return Module["dynCall_jijjjjii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_vijjj(index, a1, a2, a3, a4, a5, a6, a7) {
            var sp = stackSave();
            try {
              Module["dynCall_vijjj"](index, a1, a2, a3, a4, a5, a6, a7);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiiiijij(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
            var sp = stackSave();
            try {
              return Module["dynCall_iiiiijij"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiiiijiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
            var sp = stackSave();
            try {
              return Module["dynCall_iiiiijiii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_jiiiiii(index, a1, a2, a3, a4, a5, a6) {
            var sp = stackSave();
            try {
              return Module["dynCall_jiiiiii"](index, a1, a2, a3, a4, a5, a6);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiiijiii(index, a1, a2, a3, a4, a5, a6, a7, a8) {
            var sp = stackSave();
            try {
              return Module["dynCall_iiiijiii"](index, a1, a2, a3, a4, a5, a6, a7, a8);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viijji(index, a1, a2, a3, a4, a5, a6, a7) {
            var sp = stackSave();
            try {
              Module["dynCall_viijji"](index, a1, a2, a3, a4, a5, a6, a7);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viiijjij(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
            var sp = stackSave();
            try {
              Module["dynCall_viiijjij"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_vijijjiij(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) {
            var sp = stackSave();
            try {
              Module["dynCall_vijijjiij"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viijiiiij(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
            var sp = stackSave();
            try {
              Module["dynCall_viijiiiij"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viiijiiiijjj(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) {
            var sp = stackSave();
            try {
              Module["dynCall_viiijiiiijjj"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viijijiiiijjj(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17) {
            var sp = stackSave();
            try {
              Module["dynCall_viijijiiiijjj"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viiijjiij(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {
            var sp = stackSave();
            try {
              Module["dynCall_viiijjiij"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_jiiijiijiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) {
            var sp = stackSave();
            try {
              return Module["dynCall_jiiijiijiii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viijijiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {
            var sp = stackSave();
            try {
              Module["dynCall_viijijiiii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_jiiijii(index, a1, a2, a3, a4, a5, a6, a7) {
            var sp = stackSave();
            try {
              return Module["dynCall_jiiijii"](index, a1, a2, a3, a4, a5, a6, a7);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iijjj(index, a1, a2, a3, a4, a5, a6, a7) {
            var sp = stackSave();
            try {
              return Module["dynCall_iijjj"](index, a1, a2, a3, a4, a5, a6, a7);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiiijj(index, a1, a2, a3, a4, a5, a6, a7) {
            var sp = stackSave();
            try {
              return Module["dynCall_iiiijj"](index, a1, a2, a3, a4, a5, a6, a7);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiijji(index, a1, a2, a3, a4, a5, a6, a7) {
            var sp = stackSave();
            try {
              return Module["dynCall_iiijji"](index, a1, a2, a3, a4, a5, a6, a7);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_vijijiiiijjj(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16) {
            var sp = stackSave();
            try {
              Module["dynCall_vijijiiiijjj"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_jiiiij(index, a1, a2, a3, a4, a5, a6) {
            var sp = stackSave();
            try {
              return Module["dynCall_jiiiij"](index, a1, a2, a3, a4, a5, a6);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viiiijj(index, a1, a2, a3, a4, a5, a6, a7, a8) {
            var sp = stackSave();
            try {
              Module["dynCall_viiiijj"](index, a1, a2, a3, a4, a5, a6, a7, a8);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viiiiijj(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
            var sp = stackSave();
            try {
              Module["dynCall_viiiiijj"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_jiiiiji(index, a1, a2, a3, a4, a5, a6, a7) {
            var sp = stackSave();
            try {
              return Module["dynCall_jiiiiji"](index, a1, a2, a3, a4, a5, a6, a7);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viiiijijji(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) {
            var sp = stackSave();
            try {
              Module["dynCall_viiiijijji"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viiiijjij(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {
            var sp = stackSave();
            try {
              Module["dynCall_viiiijjij"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viiijiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
            var sp = stackSave();
            try {
              Module["dynCall_viiijiiii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viiijiiijii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) {
            var sp = stackSave();
            try {
              Module["dynCall_viiijiiijii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iijiii(index, a1, a2, a3, a4, a5, a6) {
            var sp = stackSave();
            try {
              return Module["dynCall_iijiii"](index, a1, a2, a3, a4, a5, a6);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iji(index, a1, a2, a3) {
            var sp = stackSave();
            try {
              return Module["dynCall_iji"](index, a1, a2, a3);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_vijijj(index, a1, a2, a3, a4, a5, a6, a7, a8) {
            var sp = stackSave();
            try {
              Module["dynCall_vijijj"](index, a1, a2, a3, a4, a5, a6, a7, a8);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_jd(index, a1) {
            var sp = stackSave();
            try {
              return Module["dynCall_jd"](index, a1);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_jf(index, a1) {
            var sp = stackSave();
            try {
              return Module["dynCall_jf"](index, a1);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_jiijiii(index, a1, a2, a3, a4, a5, a6, a7) {
            var sp = stackSave();
            try {
              return Module["dynCall_jiijiii"](index, a1, a2, a3, a4, a5, a6, a7);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viiiiijjii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {
            var sp = stackSave();
            try {
              Module["dynCall_viiiiijjii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viiiiiijii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
            var sp = stackSave();
            try {
              Module["dynCall_viiiiiijii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viiiiiiijjjji(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16) {
            var sp = stackSave();
            try {
              Module["dynCall_viiiiiiijjjji"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viiijjii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
            var sp = stackSave();
            try {
              Module["dynCall_viiijjii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_vjiii(index, a1, a2, a3, a4, a5) {
            var sp = stackSave();
            try {
              Module["dynCall_vjiii"](index, a1, a2, a3, a4, a5);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iijj(index, a1, a2, a3, a4, a5) {
            var sp = stackSave();
            try {
              return Module["dynCall_iijj"](index, a1, a2, a3, a4, a5);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_jiiijj(index, a1, a2, a3, a4, a5, a6, a7) {
            var sp = stackSave();
            try {
              return Module["dynCall_jiiijj"](index, a1, a2, a3, a4, a5, a6, a7);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_jiiijiii(index, a1, a2, a3, a4, a5, a6, a7, a8) {
            var sp = stackSave();
            try {
              return Module["dynCall_jiiijiii"](index, a1, a2, a3, a4, a5, a6, a7, a8);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_jiiiiijiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {
            var sp = stackSave();
            try {
              return Module["dynCall_jiiiiijiiii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_jiiiijii(index, a1, a2, a3, a4, a5, a6, a7, a8) {
            var sp = stackSave();
            try {
              return Module["dynCall_jiiiijii"](index, a1, a2, a3, a4, a5, a6, a7, a8);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viijjii(index, a1, a2, a3, a4, a5, a6, a7, a8) {
            var sp = stackSave();
            try {
              Module["dynCall_viijjii"](index, a1, a2, a3, a4, a5, a6, a7, a8);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiiijjiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
            var sp = stackSave();
            try {
              return Module["dynCall_iiiijjiii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiiiiiiij(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
            var sp = stackSave();
            try {
              return Module["dynCall_iiiiiiiij"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiiiiiji(index, a1, a2, a3, a4, a5, a6, a7, a8) {
            var sp = stackSave();
            try {
              return Module["dynCall_iiiiiiji"](index, a1, a2, a3, a4, a5, a6, a7, a8);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiiiiiij(index, a1, a2, a3, a4, a5, a6, a7, a8) {
            var sp = stackSave();
            try {
              return Module["dynCall_iiiiiiij"](index, a1, a2, a3, a4, a5, a6, a7, a8);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_jijji(index, a1, a2, a3, a4, a5, a6) {
            var sp = stackSave();
            try {
              return Module["dynCall_jijji"](index, a1, a2, a3, a4, a5, a6);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viiiiiji(index, a1, a2, a3, a4, a5, a6, a7, a8) {
            var sp = stackSave();
            try {
              Module["dynCall_viiiiiji"](index, a1, a2, a3, a4, a5, a6, a7, a8);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viiijiii(index, a1, a2, a3, a4, a5, a6, a7, a8) {
            var sp = stackSave();
            try {
              Module["dynCall_viiijiii"](index, a1, a2, a3, a4, a5, a6, a7, a8);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiiijjj(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
            var sp = stackSave();
            try {
              return Module["dynCall_iiiijjj"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viiiiiiji(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
            var sp = stackSave();
            try {
              Module["dynCall_viiiiiiji"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viiiijiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
            var sp = stackSave();
            try {
              Module["dynCall_viiiijiii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiidj(index, a1, a2, a3, a4, a5) {
            var sp = stackSave();
            try {
              return Module["dynCall_iiidj"](index, a1, a2, a3, a4, a5);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiiiiiiiiiji(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) {
            var sp = stackSave();
            try {
              return Module["dynCall_iiiiiiiiiiji"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiiiiiijj(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
            var sp = stackSave();
            try {
              return Module["dynCall_iiiiiiijj"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiiijji(index, a1, a2, a3, a4, a5, a6, a7, a8) {
            var sp = stackSave();
            try {
              return Module["dynCall_iiiijji"](index, a1, a2, a3, a4, a5, a6, a7, a8);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_jiiijjj(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
            var sp = stackSave();
            try {
              return Module["dynCall_jiiijjj"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viiijijj(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
            var sp = stackSave();
            try {
              Module["dynCall_viiijijj"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_jiiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {
            var sp = stackSave();
            try {
              return Module["dynCall_jiiiiiii"](index, a1, a2, a3, a4, a5, a6, a7);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_jiijj(index, a1, a2, a3, a4, a5, a6) {
            var sp = stackSave();
            try {
              return Module["dynCall_jiijj"](index, a1, a2, a3, a4, a5, a6);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiiiiiiiijiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17) {
            var sp = stackSave();
            try {
              return Module["dynCall_iiiiiiiiijiiiiiii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiijjiiji(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {
            var sp = stackSave();
            try {
              return Module["dynCall_iiijjiiji"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiijjiij(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
            var sp = stackSave();
            try {
              return Module["dynCall_iiijjiij"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiiidjj(index, a1, a2, a3, a4, a5, a6, a7, a8) {
            var sp = stackSave();
            try {
              return Module["dynCall_iiiidjj"](index, a1, a2, a3, a4, a5, a6, a7, a8);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiiiiiiiji(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
            var sp = stackSave();
            try {
              return Module["dynCall_iiiiiiiiji"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiijiiiij(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
            var sp = stackSave();
            try {
              return Module["dynCall_iiijiiiij"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiijiiij(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
            var sp = stackSave();
            try {
              return Module["dynCall_iiijiiij"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiiiiiiiiiiij(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13) {
            var sp = stackSave();
            try {
              return Module["dynCall_iiiiiiiiiiiij"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viiijji(index, a1, a2, a3, a4, a5, a6, a7, a8) {
            var sp = stackSave();
            try {
              Module["dynCall_viiijji"](index, a1, a2, a3, a4, a5, a6, a7, a8);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_jiiiijiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
            var sp = stackSave();
            try {
              return Module["dynCall_jiiiijiiii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_jiijjjii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
            var sp = stackSave();
            try {
              return Module["dynCall_jiijjjii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viiiijji(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
            var sp = stackSave();
            try {
              Module["dynCall_viiiijji"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiijij(index, a1, a2, a3, a4, a5, a6, a7) {
            var sp = stackSave();
            try {
              return Module["dynCall_iiijij"](index, a1, a2, a3, a4, a5, a6, a7);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_jiiiji(index, a1, a2, a3, a4, a5, a6) {
            var sp = stackSave();
            try {
              return Module["dynCall_jiiiji"](index, a1, a2, a3, a4, a5, a6);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_vjjijij(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
            var sp = stackSave();
            try {
              Module["dynCall_vjjijij"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viijiiji(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
            var sp = stackSave();
            try {
              Module["dynCall_viijiiji"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiijjijjiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14) {
            var sp = stackSave();
            try {
              return Module["dynCall_iiijjijjiii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiiijjii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
            var sp = stackSave();
            try {
              return Module["dynCall_iiiijjii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiiiiijjiijjji(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18) {
            var sp = stackSave();
            try {
              return Module["dynCall_iiiiiijjiijjji"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viiijjiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
            var sp = stackSave();
            try {
              Module["dynCall_viiijjiii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viijiiij(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
            var sp = stackSave();
            try {
              Module["dynCall_viijiiij"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_vijiiiji(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
            var sp = stackSave();
            try {
              Module["dynCall_vijiiiji"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_jijiii(index, a1, a2, a3, a4, a5, a6) {
            var sp = stackSave();
            try {
              return Module["dynCall_jijiii"](index, a1, a2, a3, a4, a5, a6);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_jijjij(index, a1, a2, a3, a4, a5, a6, a7, a8) {
            var sp = stackSave();
            try {
              return Module["dynCall_jijjij"](index, a1, a2, a3, a4, a5, a6, a7, a8);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viijiij(index, a1, a2, a3, a4, a5, a6, a7, a8) {
            var sp = stackSave();
            try {
              Module["dynCall_viijiij"](index, a1, a2, a3, a4, a5, a6, a7, a8);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiijiiji(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
            var sp = stackSave();
            try {
              return Module["dynCall_iiijiiji"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iijiij(index, a1, a2, a3, a4, a5, a6, a7) {
            var sp = stackSave();
            try {
              return Module["dynCall_iijiij"](index, a1, a2, a3, a4, a5, a6, a7);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiiiiiijji(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {
            var sp = stackSave();
            try {
              return Module["dynCall_iiiiiiijji"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iijjjii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
            var sp = stackSave();
            try {
              return Module["dynCall_iijjjii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiiiijjji(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {
            var sp = stackSave();
            try {
              return Module["dynCall_iiiiijjji"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiiiijjj(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
            var sp = stackSave();
            try {
              return Module["dynCall_iiiiijjj"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_jijiiii(index, a1, a2, a3, a4, a5, a6, a7) {
            var sp = stackSave();
            try {
              return Module["dynCall_jijiiii"](index, a1, a2, a3, a4, a5, a6, a7);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viiijiji(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
            var sp = stackSave();
            try {
              Module["dynCall_viiijiji"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_jijj(index, a1, a2, a3, a4, a5) {
            var sp = stackSave();
            try {
              return Module["dynCall_jijj"](index, a1, a2, a3, a4, a5);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiijjji(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
            var sp = stackSave();
            try {
              return Module["dynCall_iiijjji"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viiiiijjji(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) {
            var sp = stackSave();
            try {
              Module["dynCall_viiiiijjji"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiijiiiijj(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) {
            var sp = stackSave();
            try {
              return Module["dynCall_iiijiiiijj"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viiijijjj(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) {
            var sp = stackSave();
            try {
              Module["dynCall_viiijijjj"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_vijijjji(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {
            var sp = stackSave();
            try {
              Module["dynCall_vijijjji"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_vijiij(index, a1, a2, a3, a4, a5, a6, a7) {
            var sp = stackSave();
            try {
              Module["dynCall_vijiij"](index, a1, a2, a3, a4, a5, a6, a7);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iijiiijj(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
            var sp = stackSave();
            try {
              return Module["dynCall_iijiiijj"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiijiiijj(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {
            var sp = stackSave();
            try {
              return Module["dynCall_iiijiiijj"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viiijjjji(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) {
            var sp = stackSave();
            try {
              Module["dynCall_viiijjjji"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_vijjjj(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
            var sp = stackSave();
            try {
              Module["dynCall_vijjjj"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viiiiijiijii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13) {
            var sp = stackSave();
            try {
              Module["dynCall_viiiiijiijii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viijiji(index, a1, a2, a3, a4, a5, a6, a7, a8) {
            var sp = stackSave();
            try {
              Module["dynCall_viijiji"](index, a1, a2, a3, a4, a5, a6, a7, a8);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_viijiiijj(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {
            var sp = stackSave();
            try {
              Module["dynCall_viijiiijj"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_jiji(index, a1, a2, a3, a4) {
            var sp = stackSave();
            try {
              return Module["dynCall_jiji"](index, a1, a2, a3, a4);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiijiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
            var sp = stackSave();
            try {
              return Module["dynCall_iiijiiiii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_vijjjiiji(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) {
            var sp = stackSave();
            try {
              Module["dynCall_vijjjiiji"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_iiiijjjj(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {
            var sp = stackSave();
            try {
              return Module["dynCall_iiiijjjj"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_vijiiiiji(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
            var sp = stackSave();
            try {
              Module["dynCall_vijiiiiji"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function invoke_vijjiii(index, a1, a2, a3, a4, a5, a6, a7, a8) {
            var sp = stackSave();
            try {
              Module["dynCall_vijjiii"](index, a1, a2, a3, a4, a5, a6, a7, a8);
            } catch (e) {
              stackRestore(sp);
              if (e !== e + 0)
                throw e;
              _setThrew(1, 0);
            }
          }
          function applySignatureConversions(wasmExports2) {
            wasmExports2 = Object.assign({}, wasmExports2);
            var makeWrapper_pppp = (f) => (a0, a1, a2) => f(a0, a1, a2) >>> 0;
            var makeWrapper_pp = (f) => (a0) => f(a0) >>> 0;
            var makeWrapper_p = (f) => () => f() >>> 0;
            var makeWrapper_ppp = (f) => (a0, a1) => f(a0, a1) >>> 0;
            var makeWrapper_pP = (f) => (a0) => f(a0) >>> 0;
            wasmExports2["memcpy"] = makeWrapper_pppp(wasmExports2["memcpy"]);
            wasmExports2["malloc"] = makeWrapper_pp(wasmExports2["malloc"]);
            wasmExports2["__errno_location"] = makeWrapper_p(wasmExports2["__errno_location"]);
            wasmExports2["pthread_self"] = makeWrapper_p(wasmExports2["pthread_self"]);
            wasmExports2["__getTypeName"] = makeWrapper_pp(wasmExports2["__getTypeName"]);
            wasmExports2["emscripten_builtin_malloc"] = makeWrapper_pp(wasmExports2["emscripten_builtin_malloc"]);
            wasmExports2["emscripten_stack_get_base"] = makeWrapper_p(wasmExports2["emscripten_stack_get_base"]);
            wasmExports2["emscripten_stack_get_end"] = makeWrapper_p(wasmExports2["emscripten_stack_get_end"]);
            wasmExports2["emscripten_builtin_memalign"] = makeWrapper_ppp(wasmExports2["emscripten_builtin_memalign"]);
            wasmExports2["emscripten_stack_get_current"] = makeWrapper_p(wasmExports2["emscripten_stack_get_current"]);
            wasmExports2["emscripten_main_runtime_thread_id"] = makeWrapper_p(wasmExports2["emscripten_main_runtime_thread_id"]);
            wasmExports2["sbrk"] = makeWrapper_pP(wasmExports2["sbrk"]);
            wasmExports2["memalign"] = makeWrapper_ppp(wasmExports2["memalign"]);
            wasmExports2["stackSave"] = makeWrapper_p(wasmExports2["stackSave"]);
            wasmExports2["stackAlloc"] = makeWrapper_pp(wasmExports2["stackAlloc"]);
            return wasmExports2;
          }
          Module["stackAlloc"] = stackAlloc;
          Module["stackSave"] = stackSave;
          Module["stackRestore"] = stackRestore;
          Module["ccall"] = ccall;
          var calledRun;
          dependenciesFulfilled = function runCaller() {
            if (!calledRun)
              run();
            if (!calledRun)
              dependenciesFulfilled = runCaller;
          };
          function callMain(args2 = []) {
            var entryFunction = resolveGlobalSymbol("main").sym;
            if (!entryFunction)
              return;
            args2.unshift(thisProgram);
            var argc = args2.length;
            var argv = stackAlloc((argc + 1) * 4);
            var argv_ptr = argv;
            args2.forEach((arg) => {
              HEAPU32[argv_ptr >>> 2 >>> 0] = stringToUTF8OnStack(arg);
              argv_ptr += 4;
            });
            HEAPU32[argv_ptr >>> 2 >>> 0] = 0;
            try {
              var ret = entryFunction(argc, argv);
              exitJS(ret, true);
              return ret;
            } catch (e) {
              return handleException(e);
            }
          }
          function run(args2 = arguments_) {
            if (runDependencies > 0) {
              return;
            }
            preRun();
            if (runDependencies > 0) {
              return;
            }
            function doRun() {
              if (calledRun)
                return;
              calledRun = true;
              Module["calledRun"] = true;
              if (ABORT)
                return;
              initRuntime();
              preMain();
              readyPromiseResolve(Module);
              if (Module["onRuntimeInitialized"])
                Module["onRuntimeInitialized"]();
              if (shouldRunNow)
                callMain(args2);
              postRun();
            }
            if (Module["setStatus"]) {
              Module["setStatus"]("Running...");
              setTimeout(function() {
                setTimeout(function() {
                  Module["setStatus"]("");
                }, 1);
                doRun();
              }, 1);
            } else {
              doRun();
            }
          }
          if (Module["preInit"]) {
            if (typeof Module["preInit"] == "function")
              Module["preInit"] = [Module["preInit"]];
            while (Module["preInit"].length > 0) {
              Module["preInit"].pop()();
            }
          }
          var shouldRunNow = true;
          if (Module["noInitialRun"])
            shouldRunNow = false;
          run();
          return moduleArg.ready;
        };
      })();
      if (typeof exports === "object" && typeof module === "object")
        module.exports = DuckDB;
      else if (typeof define === "function" && define["amd"])
        define([], () => DuckDB);
    }
  });

  // src/bindings/duckdb-eh.js
  var require_duckdb_eh = __commonJS({
    "src/bindings/duckdb-eh.js"(exports, module) {
      "use strict";
      var DuckDB = (() => {
        var _scriptDir = typeof document !== "undefined" && document.currentScript ? document.currentScript.src : void 0;
        if (typeof __filename !== "undefined")
          _scriptDir || (_scriptDir = __filename);
        return function(moduleArg = {}) {
          var Module = moduleArg;
          var readyPromiseResolve, readyPromiseReject;
          Module["ready"] = new Promise((resolve, reject) => {
            readyPromiseResolve = resolve;
            readyPromiseReject = reject;
          });
          var moduleOverrides = Object.assign({}, Module);
          var arguments_ = [];
          var thisProgram = "./this.program";
          var quit_ = (status, toThrow) => {
            throw toThrow;
          };
          var ENVIRONMENT_IS_WEB = typeof window == "object";
          var ENVIRONMENT_IS_WORKER = typeof importScripts == "function";
          var ENVIRONMENT_IS_NODE = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string";
          var ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;
          var scriptDirectory = "";
          function locateFile(path) {
            if (Module["locateFile"]) {
              return Module["locateFile"](path, scriptDirectory);
            }
            return scriptDirectory + path;
          }
          var read_, readAsync, readBinary;
          if (ENVIRONMENT_IS_NODE) {
            var fs = require_fs();
            var nodePath = require_path();
            if (ENVIRONMENT_IS_WORKER) {
              scriptDirectory = nodePath.dirname(scriptDirectory) + "/";
            } else {
              scriptDirectory = __dirname + "/";
            }
            read_ = (filename, binary2) => {
              filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
              return fs.readFileSync(filename, binary2 ? void 0 : "utf8");
            };
            readBinary = (filename) => {
              var ret = read_(filename, true);
              if (!ret.buffer) {
                ret = new Uint8Array(ret);
              }
              return ret;
            };
            readAsync = (filename, onload2, onerror2, binary2 = true) => {
              filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
              fs.readFile(filename, binary2 ? void 0 : "utf8", (err2, data2) => {
                if (err2)
                  onerror2(err2);
                else
                  onload2(binary2 ? data2.buffer : data2);
              });
            };
            if (!Module["thisProgram"] && process.argv.length > 1) {
              thisProgram = process.argv[1].replace(/\\/g, "/");
            }
            arguments_ = process.argv.slice(2);
            quit_ = (status, toThrow) => {
              process.exitCode = status;
              throw toThrow;
            };
          } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
            if (ENVIRONMENT_IS_WORKER) {
              scriptDirectory = self.location.href;
            } else if (typeof document != "undefined" && document.currentScript) {
              scriptDirectory = document.currentScript.src;
            }
            if (_scriptDir) {
              scriptDirectory = _scriptDir;
            }
            if (scriptDirectory.indexOf("blob:") !== 0) {
              scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, "").lastIndexOf("/") + 1);
            } else {
              scriptDirectory = "";
            }
            {
              read_ = (url2) => {
                var xhr = new XMLHttpRequest();
                xhr.open("GET", url2, false);
                xhr.send(null);
                return xhr.responseText;
              };
              if (ENVIRONMENT_IS_WORKER) {
                readBinary = (url2) => {
                  var xhr = new XMLHttpRequest();
                  xhr.open("GET", url2, false);
                  xhr.responseType = "arraybuffer";
                  xhr.send(null);
                  return new Uint8Array(xhr.response);
                };
              }
              readAsync = (url2, onload2, onerror2) => {
                var xhr = new XMLHttpRequest();
                xhr.open("GET", url2, true);
                xhr.responseType = "arraybuffer";
                xhr.onload = () => {
                  if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
                    onload2(xhr.response);
                    return;
                  }
                  onerror2();
                };
                xhr.onerror = onerror2;
                xhr.send(null);
              };
            }
          } else {
          }
          var out = Module["print"] || console.log.bind(console);
          var err = Module["printErr"] || console.error.bind(console);
          Object.assign(Module, moduleOverrides);
          moduleOverrides = null;
          if (Module["arguments"])
            arguments_ = Module["arguments"];
          if (Module["thisProgram"])
            thisProgram = Module["thisProgram"];
          if (Module["quit"])
            quit_ = Module["quit"];
          var dynamicLibraries = Module["dynamicLibraries"] || [];
          var wasmBinary;
          if (Module["wasmBinary"])
            wasmBinary = Module["wasmBinary"];
          if (typeof WebAssembly != "object") {
            abort("no native wasm support detected");
          }
          var wasmMemory;
          var ABORT = false;
          var EXITSTATUS;
          function assert(condition, text) {
            if (!condition) {
              abort(text);
            }
          }
          var HEAP, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
          function updateMemoryViews() {
            var b = wasmMemory.buffer;
            Module["HEAP8"] = HEAP8 = new Int8Array(b);
            Module["HEAP16"] = HEAP16 = new Int16Array(b);
            Module["HEAPU8"] = HEAPU8 = new Uint8Array(b);
            Module["HEAPU16"] = HEAPU16 = new Uint16Array(b);
            Module["HEAP32"] = HEAP32 = new Int32Array(b);
            Module["HEAPU32"] = HEAPU32 = new Uint32Array(b);
            Module["HEAPF32"] = HEAPF32 = new Float32Array(b);
            Module["HEAPF64"] = HEAPF64 = new Float64Array(b);
          }
          var INITIAL_MEMORY = Module["INITIAL_MEMORY"] || 16777216;
          if (Module["wasmMemory"]) {
            wasmMemory = Module["wasmMemory"];
          } else {
            wasmMemory = new WebAssembly.Memory({
              "initial": INITIAL_MEMORY / 65536,
              "maximum": 4294967296 / 65536
            });
          }
          updateMemoryViews();
          INITIAL_MEMORY = wasmMemory.buffer.byteLength;
          var __ATPRERUN__ = [];
          var __ATINIT__ = [];
          var __ATMAIN__ = [];
          var __ATEXIT__ = [];
          var __ATPOSTRUN__ = [];
          var __RELOC_FUNCS__ = [];
          var runtimeInitialized = false;
          function preRun() {
            if (Module["preRun"]) {
              if (typeof Module["preRun"] == "function")
                Module["preRun"] = [Module["preRun"]];
              while (Module["preRun"].length) {
                addOnPreRun(Module["preRun"].shift());
              }
            }
            callRuntimeCallbacks(__ATPRERUN__);
          }
          function initRuntime() {
            runtimeInitialized = true;
            callRuntimeCallbacks(__RELOC_FUNCS__);
            if (!Module["noFSInit"] && !FS.init.initialized)
              FS.init();
            FS.ignorePermissions = false;
            TTY.init();
            SOCKFS.root = FS.mount(SOCKFS, {}, null);
            PIPEFS.root = FS.mount(PIPEFS, {}, null);
            callRuntimeCallbacks(__ATINIT__);
          }
          function preMain() {
            callRuntimeCallbacks(__ATMAIN__);
          }
          function postRun() {
            if (Module["postRun"]) {
              if (typeof Module["postRun"] == "function")
                Module["postRun"] = [Module["postRun"]];
              while (Module["postRun"].length) {
                addOnPostRun(Module["postRun"].shift());
              }
            }
            callRuntimeCallbacks(__ATPOSTRUN__);
          }
          function addOnPreRun(cb) {
            __ATPRERUN__.unshift(cb);
          }
          function addOnInit(cb) {
            __ATINIT__.unshift(cb);
          }
          function addOnPreMain(cb) {
            __ATMAIN__.unshift(cb);
          }
          function addOnExit(cb) {
          }
          function addOnPostRun(cb) {
            __ATPOSTRUN__.unshift(cb);
          }
          var runDependencies = 0;
          var runDependencyWatcher = null;
          var dependenciesFulfilled = null;
          function getUniqueRunDependency(id) {
            return id;
          }
          function addRunDependency(id) {
            runDependencies++;
            Module["monitorRunDependencies"]?.(runDependencies);
          }
          function removeRunDependency(id) {
            runDependencies--;
            Module["monitorRunDependencies"]?.(runDependencies);
            if (runDependencies == 0) {
              if (runDependencyWatcher !== null) {
                clearInterval(runDependencyWatcher);
                runDependencyWatcher = null;
              }
              if (dependenciesFulfilled) {
                var callback = dependenciesFulfilled;
                dependenciesFulfilled = null;
                callback();
              }
            }
          }
          function abort(what) {
            Module["onAbort"]?.(what);
            what = "Aborted(" + what + ")";
            err(what);
            ABORT = true;
            EXITSTATUS = 1;
            what += ". Build with -sASSERTIONS for more info.";
            if (runtimeInitialized) {
              ___trap();
            }
            var e = new WebAssembly.RuntimeError(what);
            readyPromiseReject(e);
            throw e;
          }
          var dataURIPrefix = "data:application/octet-stream;base64,";
          var isDataURI = (filename) => filename.startsWith(dataURIPrefix);
          var isFileURI = (filename) => filename.startsWith("file://");
          var wasmBinaryFile;
          wasmBinaryFile = "./duckdb-eh.wasm";
          if (!isDataURI(wasmBinaryFile)) {
            wasmBinaryFile = locateFile(wasmBinaryFile);
          }
          function getBinarySync(file) {
            if (file == wasmBinaryFile && wasmBinary) {
              return new Uint8Array(wasmBinary);
            }
            if (readBinary) {
              return readBinary(file);
            }
            throw "both async and sync fetching of the wasm failed";
          }
          function getBinaryPromise(binaryFile) {
            if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
              if (typeof fetch == "function") {
                return fetch(binaryFile, {
                  credentials: "same-origin"
                }).then((response) => {
                  if (!response["ok"]) {
                    throw "failed to load wasm binary file at '" + binaryFile + "'";
                  }
                  return response["arrayBuffer"]();
                }).catch(() => getBinarySync(binaryFile));
              }
            }
            return Promise.resolve().then(() => getBinarySync(binaryFile));
          }
          function instantiateArrayBuffer(binaryFile, imports, receiver) {
            return getBinaryPromise(binaryFile).then((binary2) => WebAssembly.instantiate(binary2, imports)).then((instance10) => instance10).then(receiver, (reason) => {
              err(`failed to asynchronously prepare wasm: ${reason}`);
              abort(reason);
            });
          }
          function instantiateAsync(binary2, binaryFile, imports, callback) {
            if (!binary2 && typeof WebAssembly.instantiateStreaming == "function" && !isDataURI(binaryFile) && !ENVIRONMENT_IS_NODE && typeof fetch == "function") {
              return fetch(binaryFile, {
                credentials: "same-origin"
              }).then((response) => {
                var result = WebAssembly.instantiateStreaming(response, imports);
                return result.then(callback, function(reason) {
                  err(`wasm streaming compile failed: ${reason}`);
                  err("falling back to ArrayBuffer instantiation");
                  return instantiateArrayBuffer(binaryFile, imports, callback);
                });
              });
            }
            return instantiateArrayBuffer(binaryFile, imports, callback);
          }
          function createWasm() {
            var info2 = {
              "env": wasmImports,
              "wasi_snapshot_preview1": wasmImports,
              "GOT.mem": new Proxy(wasmImports, GOTHandler),
              "GOT.func": new Proxy(wasmImports, GOTHandler)
            };
            function receiveInstance(instance10, module2) {
              wasmExports = instance10.exports;
              wasmExports = relocateExports(wasmExports, 1024);
              var metadata2 = getDylinkMetadata(module2);
              if (metadata2.neededDynlibs) {
                dynamicLibraries = metadata2.neededDynlibs.concat(dynamicLibraries);
              }
              mergeLibSymbols(wasmExports, "main");
              LDSO.init();
              loadDylibs();
              wasmExports = applySignatureConversions(wasmExports);
              addOnInit(wasmExports["__wasm_call_ctors"]);
              __RELOC_FUNCS__.push(wasmExports["__wasm_apply_data_relocs"]);
              removeRunDependency("wasm-instantiate");
              return wasmExports;
            }
            addRunDependency("wasm-instantiate");
            function receiveInstantiationResult(result) {
              receiveInstance(result["instance"], result["module"]);
            }
            if (Module["instantiateWasm"]) {
              try {
                return Module["instantiateWasm"](info2, receiveInstance);
              } catch (e) {
                err(`Module.instantiateWasm callback failed with error: ${e}`);
                readyPromiseReject(e);
              }
            }
            instantiateAsync(wasmBinary, wasmBinaryFile, info2, receiveInstantiationResult).catch(readyPromiseReject);
            return {};
          }
          var tempDouble;
          var tempI64;
          var ASM_CONSTS = {
            2134048: ($0, $1) => {
              var jsString2 = typeof runtime == "object" && runtime && typeof runtime.whereToLoad == "function" && runtime.whereToLoad ? runtime.whereToLoad(UTF8ToString($0)) : UTF8ToString($1);
              var lengthBytes = lengthBytesUTF8(jsString2) + 1;
              var stringOnWasmHeap = _malloc(lengthBytes);
              stringToUTF8(jsString2, stringOnWasmHeap, lengthBytes);
              return stringOnWasmHeap;
            },
            2134414: ($0, $1) => {
              var url2 = UTF8ToString($0);
              if (typeof XMLHttpRequest === "undefined") {
                const os = require_os();
                const path = require_path();
                const fs2 = require_fs();
                var array = url2.split("/");
                var l = array.length;
                var folder = path.join(os.homedir(), ".duckdb/extensions/" + array[l - 4] + "/" + array[l - 3] + "/" + array[l - 2] + "/");
                var filePath = path.join(folder, array[l - 1]);
                try {
                  if (!fs2.existsSync(folder)) {
                    fs2.mkdirSync(folder, {
                      recursive: true
                    });
                  }
                  if (!fs2.existsSync(filePath)) {
                    const int322 = new Int32Array(new SharedArrayBuffer(8));
                    var Worker3 = __require("node:worker_threads").Worker;
                    var worker2 = new Worker3("const {Worker,isMainThread,parentPort,workerData,} = require('node:worker_threads');var times = 0;var SAB = 23;var Z = 0;async function ZZZ(e) {var x = await fetch(e);var res = await x.arrayBuffer();Atomics.store(SAB, 1, res.byteLength);Atomics.store(SAB, 0, 1);Atomics.notify(SAB, 1);Atomics.notify(SAB, 0);Z = res;};parentPort.on('message', function(event) {if (times == 0) {times++;SAB = event;} else if (times == 1) {times++;ZZZ(event);} else {const a = new Uint8Array(Z);const b = new Uint8Array(event.buffer);var K = Z.byteLength;for (var i = 0; i < K; i++) {b[i] = a[i];}Atomics.notify(event, 0);Atomics.store(SAB, 0, 2);Atomics.notify(SAB, 0);}});", {
                      eval: true
                    });
                    var uInt8Array;
                    int322[0] = 0;
                    int322[2] = 4;
                    worker2.postMessage(int322);
                    worker2.postMessage(url2);
                    Atomics.wait(int322, 0, 0);
                    const int32_2 = new Int32Array(new SharedArrayBuffer(int322[1] + 3 - (int322[1] + 3) % 4));
                    worker2.postMessage(int32_2);
                    Atomics.wait(int322, 0, 1);
                    var x = new Uint8Array(int32_2.buffer, 0, int322[1]);
                    uInt8Array = x;
                    worker2.terminate();
                    fs2.writeFileSync(filePath, uInt8Array);
                  } else {
                    uInt8Array = fs2.readFileSync(filePath);
                  }
                } catch (e) {
                  console.log("Error fetching module", e);
                  return 0;
                }
              } else {
                const xhr = new XMLHttpRequest();
                xhr.open("GET", url2, false);
                xhr.responseType = "arraybuffer";
                xhr.send(null);
                if (xhr.status != 200)
                  return 0;
                uInt8Array = xhr.response;
              }
              var valid = WebAssembly.validate(uInt8Array);
              var len2 = uInt8Array.byteLength;
              var fileOnWasmHeap = _malloc(len2 + 4);
              var properArray = new Uint8Array(uInt8Array);
              for (var iii = 0; iii < len2; iii++) {
                Module.HEAPU8[iii + fileOnWasmHeap + 4] = properArray[iii];
              }
              var LEN123 = new Uint8Array(4);
              LEN123[0] = len2 % 256;
              len2 -= LEN123[0];
              len2 /= 256;
              LEN123[1] = len2 % 256;
              len2 -= LEN123[1];
              len2 /= 256;
              LEN123[2] = len2 % 256;
              len2 -= LEN123[2];
              len2 /= 256;
              LEN123[3] = len2 % 256;
              len2 -= LEN123[3];
              len2 /= 256;
              Module.HEAPU8.set(LEN123, fileOnWasmHeap);
              FS.writeFile(UTF8ToString($1), new Uint8Array(uInt8Array));
              return fileOnWasmHeap;
            },
            2137053: ($0) => {
              if (!$0) {
                AL.alcErr = 40964;
                return 1;
              }
            },
            2137101: ($0) => {
              if (!AL.currentCtx) {
                err("alGetProcAddress() called without a valid context");
                return 1;
              }
              if (!$0) {
                AL.currentCtx.err = 40963;
                return 1;
              }
            }
          };
          function ExitStatus(status) {
            this.name = "ExitStatus";
            this.message = `Program terminated with exit(${status})`;
            this.status = status;
          }
          var GOT = {};
          var currentModuleWeakSymbols = /* @__PURE__ */ new Set([]);
          var GOTHandler = {
            get(obj, symName) {
              var rtn = GOT[symName];
              if (!rtn) {
                rtn = GOT[symName] = new WebAssembly.Global({
                  "value": "i32",
                  "mutable": true
                });
              }
              if (!currentModuleWeakSymbols.has(symName)) {
                rtn.required = true;
              }
              return rtn;
            }
          };
          var callRuntimeCallbacks = (callbacks) => {
            while (callbacks.length > 0) {
              callbacks.shift()(Module);
            }
          };
          var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : void 0;
          var UTF8ArrayToString = (heapOrArray, idx, maxBytesToRead) => {
            idx >>>= 0;
            var endIdx = idx + maxBytesToRead;
            var endPtr = idx;
            while (heapOrArray[endPtr] && !(endPtr >= endIdx))
              ++endPtr;
            if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
              return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
            }
            var str = "";
            while (idx < endPtr) {
              var u0 = heapOrArray[idx++];
              if (!(u0 & 128)) {
                str += String.fromCharCode(u0);
                continue;
              }
              var u1 = heapOrArray[idx++] & 63;
              if ((u0 & 224) == 192) {
                str += String.fromCharCode((u0 & 31) << 6 | u1);
                continue;
              }
              var u2 = heapOrArray[idx++] & 63;
              if ((u0 & 240) == 224) {
                u0 = (u0 & 15) << 12 | u1 << 6 | u2;
              } else {
                u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
              }
              if (u0 < 65536) {
                str += String.fromCharCode(u0);
              } else {
                var ch = u0 - 65536;
                str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
              }
            }
            return str;
          };
          var getDylinkMetadata = (binary2) => {
            var offset = 0;
            var end = 0;
            function getU8() {
              return binary2[offset++];
            }
            function getLEB() {
              var ret = 0;
              var mul = 1;
              while (1) {
                var byte = binary2[offset++];
                ret += (byte & 127) * mul;
                mul *= 128;
                if (!(byte & 128))
                  break;
              }
              return ret;
            }
            function getString() {
              var len2 = getLEB();
              offset += len2;
              return UTF8ArrayToString(binary2, offset - len2, len2);
            }
            function failIf(condition, message) {
              if (condition)
                throw new Error(message);
            }
            var name2 = "dylink.0";
            if (binary2 instanceof WebAssembly.Module) {
              var dylinkSection = WebAssembly.Module.customSections(binary2, name2);
              if (dylinkSection.length === 0) {
                name2 = "dylink";
                dylinkSection = WebAssembly.Module.customSections(binary2, name2);
              }
              failIf(dylinkSection.length === 0, "need dylink section");
              binary2 = new Uint8Array(dylinkSection[0]);
              end = binary2.length;
            } else {
              var int32View = new Uint32Array(new Uint8Array(binary2.subarray(0, 24)).buffer);
              var magicNumberFound = int32View[0] == 1836278016;
              failIf(!magicNumberFound, "need to see wasm magic number");
              failIf(binary2[8] !== 0, "need the dylink section to be first");
              offset = 9;
              var section_size = getLEB();
              end = offset + section_size;
              name2 = getString();
            }
            var customSection = {
              neededDynlibs: [],
              tlsExports: /* @__PURE__ */ new Set(),
              weakImports: /* @__PURE__ */ new Set()
            };
            if (name2 == "dylink") {
              customSection.memorySize = getLEB();
              customSection.memoryAlign = getLEB();
              customSection.tableSize = getLEB();
              customSection.tableAlign = getLEB();
              var neededDynlibsCount = getLEB();
              for (var i2 = 0; i2 < neededDynlibsCount; ++i2) {
                var libname = getString();
                customSection.neededDynlibs.push(libname);
              }
            } else {
              failIf(name2 !== "dylink.0");
              var WASM_DYLINK_MEM_INFO = 1;
              var WASM_DYLINK_NEEDED = 2;
              var WASM_DYLINK_EXPORT_INFO = 3;
              var WASM_DYLINK_IMPORT_INFO = 4;
              var WASM_SYMBOL_TLS = 256;
              var WASM_SYMBOL_BINDING_MASK = 3;
              var WASM_SYMBOL_BINDING_WEAK = 1;
              while (offset < end) {
                var subsectionType = getU8();
                var subsectionSize = getLEB();
                if (subsectionType === WASM_DYLINK_MEM_INFO) {
                  customSection.memorySize = getLEB();
                  customSection.memoryAlign = getLEB();
                  customSection.tableSize = getLEB();
                  customSection.tableAlign = getLEB();
                } else if (subsectionType === WASM_DYLINK_NEEDED) {
                  var neededDynlibsCount = getLEB();
                  for (var i2 = 0; i2 < neededDynlibsCount; ++i2) {
                    libname = getString();
                    customSection.neededDynlibs.push(libname);
                  }
                } else if (subsectionType === WASM_DYLINK_EXPORT_INFO) {
                  var count = getLEB();
                  while (count--) {
                    var symname = getString();
                    var flags2 = getLEB();
                    if (flags2 & WASM_SYMBOL_TLS) {
                      customSection.tlsExports.add(symname);
                    }
                  }
                } else if (subsectionType === WASM_DYLINK_IMPORT_INFO) {
                  var count = getLEB();
                  while (count--) {
                    var modname = getString();
                    var symname = getString();
                    var flags2 = getLEB();
                    if ((flags2 & WASM_SYMBOL_BINDING_MASK) == WASM_SYMBOL_BINDING_WEAK) {
                      customSection.weakImports.add(symname);
                    }
                  }
                } else {
                  offset += subsectionSize;
                }
              }
            }
            return customSection;
          };
          function getValue(ptr2, type = "i8") {
            if (type.endsWith("*"))
              type = "*";
            switch (type) {
              case "i1":
                return HEAP8[ptr2 >>> 0 >>> 0];
              case "i8":
                return HEAP8[ptr2 >>> 0 >>> 0];
              case "i16":
                return HEAP16[ptr2 >>> 1 >>> 0];
              case "i32":
                return HEAP32[ptr2 >>> 2 >>> 0];
              case "i64":
                abort("to do getValue(i64) use WASM_BIGINT");
              case "float":
                return HEAPF32[ptr2 >>> 2 >>> 0];
              case "double":
                return HEAPF64[ptr2 >>> 3 >>> 0];
              case "*":
                return HEAPU32[ptr2 >>> 2 >>> 0];
              default:
                abort(`invalid type for getValue: ${type}`);
            }
          }
          var newDSO = (name2, handle2, syms) => {
            var dso = {
              refcount: Infinity,
              name: name2,
              exports: syms,
              global: true
            };
            LDSO.loadedLibsByName[name2] = dso;
            if (handle2 != void 0) {
              LDSO.loadedLibsByHandle[handle2] = dso;
            }
            return dso;
          };
          var LDSO = {
            loadedLibsByName: {},
            loadedLibsByHandle: {},
            init() {
              newDSO("__main__", 0, wasmImports);
            }
          };
          var ___heap_base = 2279648;
          var zeroMemory = (address, size) => {
            HEAPU8.fill(0, address, address + size);
            return address;
          };
          var alignMemory = (size, alignment) => Math.ceil(size / alignment) * alignment;
          var getMemory = (size) => {
            if (runtimeInitialized) {
              return zeroMemory(_malloc(size), size);
            }
            var ret = ___heap_base;
            var end = ret + alignMemory(size, 16);
            ___heap_base = end;
            GOT["__heap_base"].value = end;
            return ret;
          };
          var isInternalSym = (symName) => ["__cpp_exception", "__c_longjmp", "__wasm_apply_data_relocs", "__dso_handle", "__tls_size", "__tls_align", "__set_stack_limits", "_emscripten_tls_init", "__wasm_init_tls", "__wasm_call_ctors", "__start_em_asm", "__stop_em_asm", "__start_em_js", "__stop_em_js"].includes(symName) || symName.startsWith("__em_js__");
          var uleb128Encode = (n, target) => {
            if (n < 128) {
              target.push(n);
            } else {
              target.push(n % 128 | 128, n >> 7);
            }
          };
          var sigToWasmTypes = (sig) => {
            var typeNames = {
              "i": "i32",
              "j": "i64",
              "f": "f32",
              "d": "f64",
              "e": "externref",
              "p": "i32"
            };
            var type = {
              parameters: [],
              results: sig[0] == "v" ? [] : [typeNames[sig[0]]]
            };
            for (var i2 = 1; i2 < sig.length; ++i2) {
              type.parameters.push(typeNames[sig[i2]]);
            }
            return type;
          };
          var generateFuncType = (sig, target) => {
            var sigRet = sig.slice(0, 1);
            var sigParam = sig.slice(1);
            var typeCodes = {
              "i": 127,
              "p": 127,
              "j": 126,
              "f": 125,
              "d": 124,
              "e": 111
            };
            target.push(96);
            uleb128Encode(sigParam.length, target);
            for (var i2 = 0; i2 < sigParam.length; ++i2) {
              target.push(typeCodes[sigParam[i2]]);
            }
            if (sigRet == "v") {
              target.push(0);
            } else {
              target.push(1, typeCodes[sigRet]);
            }
          };
          var convertJsFunctionToWasm = (func2, sig) => {
            if (typeof WebAssembly.Function == "function") {
              return new WebAssembly.Function(sigToWasmTypes(sig), func2);
            }
            var typeSectionBody = [1];
            generateFuncType(sig, typeSectionBody);
            var bytes = [0, 97, 115, 109, 1, 0, 0, 0, 1];
            uleb128Encode(typeSectionBody.length, bytes);
            bytes.push.apply(bytes, typeSectionBody);
            bytes.push(2, 7, 1, 1, 101, 1, 102, 0, 0, 7, 5, 1, 1, 102, 0, 0);
            var module2 = new WebAssembly.Module(new Uint8Array(bytes));
            var instance10 = new WebAssembly.Instance(module2, {
              "e": {
                "f": func2
              }
            });
            var wrappedFunc = instance10.exports["f"];
            return wrappedFunc;
          };
          var wasmTable = new WebAssembly.Table({
            "initial": 21341,
            "element": "anyfunc"
          });
          var getWasmTableEntry = (funcPtr) => wasmTable.get(funcPtr);
          var updateTableMap = (offset, count) => {
            if (functionsInTableMap) {
              for (var i2 = offset; i2 < offset + count; i2++) {
                var item = getWasmTableEntry(i2);
                if (item) {
                  functionsInTableMap.set(item, i2);
                }
              }
            }
          };
          var functionsInTableMap;
          var getFunctionAddress = (func2) => {
            if (!functionsInTableMap) {
              functionsInTableMap = /* @__PURE__ */ new WeakMap();
              updateTableMap(0, wasmTable.length);
            }
            return functionsInTableMap.get(func2) || 0;
          };
          var freeTableIndexes = [];
          var getEmptyTableSlot = () => {
            if (freeTableIndexes.length) {
              return freeTableIndexes.pop();
            }
            try {
              wasmTable.grow(1);
            } catch (err2) {
              if (!(err2 instanceof RangeError)) {
                throw err2;
              }
              throw "Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.";
            }
            return wasmTable.length - 1;
          };
          var setWasmTableEntry = (idx, func2) => wasmTable.set(idx, func2);
          var addFunction = (func2, sig) => {
            var rtn = getFunctionAddress(func2);
            if (rtn) {
              return rtn;
            }
            var ret = getEmptyTableSlot();
            try {
              setWasmTableEntry(ret, func2);
            } catch (err2) {
              if (!(err2 instanceof TypeError)) {
                throw err2;
              }
              var wrapped = convertJsFunctionToWasm(func2, sig);
              setWasmTableEntry(ret, wrapped);
            }
            functionsInTableMap.set(func2, ret);
            return ret;
          };
          var updateGOT = (exports2, replace) => {
            for (var symName in exports2) {
              if (isInternalSym(symName)) {
                continue;
              }
              var value = exports2[symName];
              if (symName.startsWith("orig$")) {
                symName = symName.split("$")[1];
                replace = true;
              }
              GOT[symName] || (GOT[symName] = new WebAssembly.Global({
                "value": "i32",
                "mutable": true
              }));
              if (replace || GOT[symName].value == 0) {
                if (typeof value == "function") {
                  GOT[symName].value = addFunction(value);
                } else if (typeof value == "number") {
                  GOT[symName].value = value;
                } else {
                  err(`unhandled export type for '${symName}': ${typeof value}`);
                }
              }
            }
          };
          var relocateExports = (exports2, memoryBase2, replace) => {
            var relocated = {};
            for (var e in exports2) {
              var value = exports2[e];
              if (typeof value == "object") {
                value = value.value;
              }
              if (typeof value == "number") {
                value += memoryBase2;
              }
              relocated[e] = value;
            }
            updateGOT(relocated, replace);
            return relocated;
          };
          var isSymbolDefined = (symName) => {
            var existing = wasmImports[symName];
            if (!existing || existing.stub) {
              return false;
            }
            return true;
          };
          var resolveGlobalSymbol = (symName, direct = false) => {
            var sym;
            if (direct && "orig$" + symName in wasmImports) {
              symName = "orig$" + symName;
            }
            if (isSymbolDefined(symName)) {
              sym = wasmImports[symName];
            }
            return {
              sym,
              name: symName
            };
          };
          var UTF8ToString = (ptr2, maxBytesToRead) => {
            ptr2 >>>= 0;
            return ptr2 ? UTF8ArrayToString(HEAPU8, ptr2, maxBytesToRead) : "";
          };
          var loadWebAssemblyModule = (binary, flags, libName, localScope, handle) => {
            var metadata = getDylinkMetadata(binary);
            currentModuleWeakSymbols = metadata.weakImports;
            function loadModule() {
              var firstLoad = !handle || !HEAP8[handle + 8 >>> 0 >>> 0];
              if (firstLoad) {
                var memAlign = Math.pow(2, metadata.memoryAlign);
                var memoryBase = metadata.memorySize ? alignMemory(getMemory(metadata.memorySize + memAlign), memAlign) : 0;
                var tableBase = metadata.tableSize ? wasmTable.length : 0;
                if (handle) {
                  HEAP8[handle + 8 >>> 0 >>> 0] = 1;
                  HEAPU32[handle + 12 >>> 2 >>> 0] = memoryBase;
                  HEAP32[handle + 16 >>> 2 >>> 0] = metadata.memorySize;
                  HEAPU32[handle + 20 >>> 2 >>> 0] = tableBase;
                  HEAP32[handle + 24 >>> 2 >>> 0] = metadata.tableSize;
                }
              } else {
                memoryBase = HEAPU32[handle + 12 >>> 2 >>> 0];
                tableBase = HEAPU32[handle + 20 >>> 2 >>> 0];
              }
              var tableGrowthNeeded = tableBase + metadata.tableSize - wasmTable.length;
              if (tableGrowthNeeded > 0) {
                wasmTable.grow(tableGrowthNeeded);
              }
              var moduleExports;
              function resolveSymbol(sym) {
                var resolved = resolveGlobalSymbol(sym).sym;
                if (!resolved && localScope) {
                  resolved = localScope[sym];
                }
                if (!resolved) {
                  resolved = moduleExports[sym];
                }
                return resolved;
              }
              var proxyHandler = {
                get(stubs, prop) {
                  switch (prop) {
                    case "__memory_base":
                      return memoryBase;
                    case "__table_base":
                      return tableBase;
                  }
                  if (prop in wasmImports && !wasmImports[prop].stub) {
                    return wasmImports[prop];
                  }
                  if (!(prop in stubs)) {
                    var resolved;
                    stubs[prop] = function() {
                      resolved || (resolved = resolveSymbol(prop));
                      return resolved.apply(null, arguments);
                    };
                  }
                  return stubs[prop];
                }
              };
              var proxy = new Proxy({}, proxyHandler);
              var info = {
                "GOT.mem": new Proxy({}, GOTHandler),
                "GOT.func": new Proxy({}, GOTHandler),
                "env": proxy,
                "wasi_snapshot_preview1": proxy
              };
              function postInstantiation(module, instance) {
                updateTableMap(tableBase, metadata.tableSize);
                moduleExports = relocateExports(instance.exports, memoryBase);
                if (!flags.allowUndefined) {
                  reportUndefinedSymbols();
                }
                function addEmAsm(addr, body) {
                  var args = [];
                  var arity = 0;
                  for (; arity < 16; arity++) {
                    if (body.indexOf("$" + arity) != -1) {
                      args.push("$" + arity);
                    } else {
                      break;
                    }
                  }
                  args = args.join(",");
                  var func = `(${args}) => { ${body} };`;
                  ASM_CONSTS[start] = eval(func);
                }
                if ("__start_em_asm" in moduleExports) {
                  var start = moduleExports["__start_em_asm"];
                  var stop = moduleExports["__stop_em_asm"];
                  while (start < stop) {
                    var jsString = UTF8ToString(start);
                    addEmAsm(start, jsString);
                    start = HEAPU8.indexOf(0, start) + 1;
                  }
                }
                function addEmJs(name, cSig, body) {
                  var jsArgs = [];
                  cSig = cSig.slice(1, -1);
                  if (cSig != "void") {
                    cSig = cSig.split(",");
                    for (var i in cSig) {
                      var jsArg = cSig[i].split(" ").pop();
                      jsArgs.push(jsArg.replace("*", ""));
                    }
                  }
                  var func = `(${jsArgs}) => ${body};`;
                  moduleExports[name] = eval(func);
                }
                for (var name in moduleExports) {
                  if (name.startsWith("__em_js__")) {
                    var start = moduleExports[name];
                    var jsString = UTF8ToString(start);
                    var parts = jsString.split("<::>");
                    addEmJs(name.replace("__em_js__", ""), parts[0], parts[1]);
                    delete moduleExports[name];
                  }
                }
                var applyRelocs = moduleExports["__wasm_apply_data_relocs"];
                if (applyRelocs) {
                  if (runtimeInitialized) {
                    applyRelocs();
                  } else {
                    __RELOC_FUNCS__.push(applyRelocs);
                  }
                }
                var init = moduleExports["__wasm_call_ctors"];
                if (init) {
                  if (runtimeInitialized) {
                    init();
                  } else {
                    __ATINIT__.push(init);
                  }
                }
                return moduleExports;
              }
              if (flags.loadAsync) {
                if (binary instanceof WebAssembly.Module) {
                  var instance = new WebAssembly.Instance(binary, info);
                  return Promise.resolve(postInstantiation(binary, instance));
                }
                return WebAssembly.instantiate(binary, info).then((result) => postInstantiation(result.module, result.instance));
              }
              var module = binary instanceof WebAssembly.Module ? binary : new WebAssembly.Module(binary);
              var instance = new WebAssembly.Instance(module, info);
              return postInstantiation(module, instance);
            }
            if (flags.loadAsync) {
              return metadata.neededDynlibs.reduce((chain, dynNeeded) => chain.then(() => loadDynamicLibrary(dynNeeded, flags)), Promise.resolve()).then(loadModule);
            }
            metadata.neededDynlibs.forEach((needed) => loadDynamicLibrary(needed, flags, localScope));
            return loadModule();
          };
          var mergeLibSymbols = (exports2, libName2) => {
            for (var [sym, exp] of Object.entries(exports2)) {
              const setImport = (target) => {
                if (!isSymbolDefined(target)) {
                  wasmImports[target] = exp;
                }
              };
              setImport(sym);
              if (sym.startsWith("dynCall_") && !Module.hasOwnProperty(sym)) {
                Module[sym] = exp;
              }
            }
          };
          var asyncLoad = (url2, onload2, onerror2, noRunDep) => {
            var dep = !noRunDep ? getUniqueRunDependency(`al ${url2}`) : "";
            readAsync(url2, (arrayBuffer) => {
              onload2(new Uint8Array(arrayBuffer));
              if (dep)
                removeRunDependency(dep);
            }, (event2) => {
              if (onerror2) {
                onerror2();
              } else {
                throw `Loading data file "${url2}" failed.`;
              }
            });
            if (dep)
              addRunDependency(dep);
          };
          var preloadPlugins = Module["preloadPlugins"] || [];
          var registerWasmPlugin = () => {
            var wasmPlugin = {
              "promiseChainEnd": Promise.resolve(),
              "canHandle": (name2) => !Module.noWasmDecoding && name2.endsWith(".so"),
              "handle": (byteArray, name2, onload2, onerror2) => {
                wasmPlugin["promiseChainEnd"] = wasmPlugin["promiseChainEnd"].then(() => loadWebAssemblyModule(byteArray, {
                  loadAsync: true,
                  nodelete: true
                }, name2)).then((exports2) => {
                  preloadedWasm[name2] = exports2;
                  onload2(byteArray);
                }, (error) => {
                  err(`failed to instantiate wasm: ${name2}: ${error}`);
                  onerror2();
                });
              }
            };
            preloadPlugins.push(wasmPlugin);
          };
          var preloadedWasm = {};
          function loadDynamicLibrary(libName2, flags2 = {
            global: true,
            nodelete: true
          }, localScope2, handle2) {
            var dso = LDSO.loadedLibsByName[libName2];
            if (dso) {
              if (!flags2.global) {
                if (localScope2) {
                  Object.assign(localScope2, dso.exports);
                }
              } else if (!dso.global) {
                dso.global = true;
                mergeLibSymbols(dso.exports, libName2);
              }
              if (flags2.nodelete && dso.refcount !== Infinity) {
                dso.refcount = Infinity;
              }
              dso.refcount++;
              if (handle2) {
                LDSO.loadedLibsByHandle[handle2] = dso;
              }
              return flags2.loadAsync ? Promise.resolve(true) : true;
            }
            dso = newDSO(libName2, handle2, "loading");
            dso.refcount = flags2.nodelete ? Infinity : 1;
            dso.global = flags2.global;
            function loadLibData() {
              if (handle2) {
                var data2 = HEAPU32[handle2 + 28 >>> 2 >>> 0];
                var dataSize = HEAPU32[handle2 + 32 >>> 2 >>> 0];
                if (data2 && dataSize) {
                  var libData = HEAP8.slice(data2, data2 + dataSize);
                  return flags2.loadAsync ? Promise.resolve(libData) : libData;
                }
              }
              var libFile = locateFile(libName2);
              if (flags2.loadAsync) {
                return new Promise(function(resolve, reject) {
                  asyncLoad(libFile, resolve, reject);
                });
              }
              if (!readBinary) {
                throw new Error(`${libFile}: file not found, and synchronous loading of external files is not available`);
              }
              return readBinary(libFile);
            }
            function getExports() {
              var preloaded = preloadedWasm[libName2];
              if (preloaded) {
                return flags2.loadAsync ? Promise.resolve(preloaded) : preloaded;
              }
              if (flags2.loadAsync) {
                return loadLibData().then((libData) => loadWebAssemblyModule(libData, flags2, libName2, localScope2, handle2));
              }
              return loadWebAssemblyModule(loadLibData(), flags2, libName2, localScope2, handle2);
            }
            function moduleLoaded(exports2) {
              if (dso.global) {
                mergeLibSymbols(exports2, libName2);
              } else if (localScope2) {
                Object.assign(localScope2, exports2);
              }
              dso.exports = exports2;
            }
            if (flags2.loadAsync) {
              return getExports().then((exports2) => {
                moduleLoaded(exports2);
                return true;
              });
            }
            moduleLoaded(getExports());
            return true;
          }
          var reportUndefinedSymbols = () => {
            for (var [symName, entry] of Object.entries(GOT)) {
              if (entry.value == 0) {
                var value = resolveGlobalSymbol(symName, true).sym;
                if (!value && !entry.required) {
                  continue;
                }
                if (typeof value == "function") {
                  entry.value = addFunction(value, value.sig);
                } else if (typeof value == "number") {
                  entry.value = value;
                } else {
                  throw new Error(`bad export type for '${symName}': ${typeof value}`);
                }
              }
            }
          };
          var loadDylibs = () => {
            if (!dynamicLibraries.length) {
              reportUndefinedSymbols();
              return;
            }
            addRunDependency("loadDylibs");
            dynamicLibraries.reduce((chain, lib) => chain.then(() => loadDynamicLibrary(lib, {
              loadAsync: true,
              global: true,
              nodelete: true,
              allowUndefined: true
            })), Promise.resolve()).then(() => {
              reportUndefinedSymbols();
              removeRunDependency("loadDylibs");
            });
          };
          var noExitRuntime = Module["noExitRuntime"] || true;
          function setValue(ptr2, value, type = "i8") {
            if (type.endsWith("*"))
              type = "*";
            switch (type) {
              case "i1":
                HEAP8[ptr2 >>> 0 >>> 0] = value;
                break;
              case "i8":
                HEAP8[ptr2 >>> 0 >>> 0] = value;
                break;
              case "i16":
                HEAP16[ptr2 >>> 1 >>> 0] = value;
                break;
              case "i32":
                HEAP32[ptr2 >>> 2 >>> 0] = value;
                break;
              case "i64":
                abort("to do setValue(i64) use WASM_BIGINT");
              case "float":
                HEAPF32[ptr2 >>> 2 >>> 0] = value;
                break;
              case "double":
                HEAPF64[ptr2 >>> 3 >>> 0] = value;
                break;
              case "*":
                HEAPU32[ptr2 >>> 2 >>> 0] = value;
                break;
              default:
                abort(`invalid type for setValue: ${type}`);
            }
          }
          var convertI32PairToI53Checked = (lo, hi) => hi + 2097152 >>> 0 < 4194305 - !!lo ? (lo >>> 0) + hi * 4294967296 : NaN;
          function ___assert_fail(condition, filename, line, func2) {
            condition >>>= 0;
            filename >>>= 0;
            func2 >>>= 0;
            abort(`Assertion failed: ${UTF8ToString(condition)}, at: ` + [filename ? UTF8ToString(filename) : "unknown filename", line, func2 ? UTF8ToString(func2) : "unknown function"]);
          }
          ___assert_fail.sig = "vppip";
          var ___c_longjmp = new WebAssembly.Tag({
            "parameters": ["i32"]
          });
          function ___call_sighandler(fp, sig) {
            fp >>>= 0;
            return getWasmTableEntry(fp)(sig);
          }
          ___call_sighandler.sig = "vpi";
          var ___cpp_exception = new WebAssembly.Tag({
            "parameters": ["i32"]
          });
          var ___memory_base = new WebAssembly.Global({
            "value": "i32",
            "mutable": false
          }, 1024);
          var ___stack_high = 2279648;
          var ___stack_low = 2214112;
          var ___stack_pointer = new WebAssembly.Global({
            "value": "i32",
            "mutable": true
          }, 2279648);
          var PATH = {
            isAbs: (path) => path.charAt(0) === "/",
            splitPath: (filename) => {
              var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
              return splitPathRe.exec(filename).slice(1);
            },
            normalizeArray: (parts2, allowAboveRoot) => {
              var up = 0;
              for (var i2 = parts2.length - 1; i2 >= 0; i2--) {
                var last = parts2[i2];
                if (last === ".") {
                  parts2.splice(i2, 1);
                } else if (last === "..") {
                  parts2.splice(i2, 1);
                  up++;
                } else if (up) {
                  parts2.splice(i2, 1);
                  up--;
                }
              }
              if (allowAboveRoot) {
                for (; up; up--) {
                  parts2.unshift("..");
                }
              }
              return parts2;
            },
            normalize: (path) => {
              var isAbsolute = PATH.isAbs(path), trailingSlash = path.substr(-1) === "/";
              path = PATH.normalizeArray(path.split("/").filter((p) => !!p), !isAbsolute).join("/");
              if (!path && !isAbsolute) {
                path = ".";
              }
              if (path && trailingSlash) {
                path += "/";
              }
              return (isAbsolute ? "/" : "") + path;
            },
            dirname: (path) => {
              var result = PATH.splitPath(path), root = result[0], dir = result[1];
              if (!root && !dir) {
                return ".";
              }
              if (dir) {
                dir = dir.substr(0, dir.length - 1);
              }
              return root + dir;
            },
            basename: (path) => {
              if (path === "/")
                return "/";
              path = PATH.normalize(path);
              path = path.replace(/\/$/, "");
              var lastSlash = path.lastIndexOf("/");
              if (lastSlash === -1)
                return path;
              return path.substr(lastSlash + 1);
            },
            join: function() {
              var paths = Array.prototype.slice.call(arguments);
              return PATH.normalize(paths.join("/"));
            },
            join2: (l, r) => PATH.normalize(l + "/" + r)
          };
          var initRandomFill = () => {
            if (typeof crypto == "object" && typeof crypto["getRandomValues"] == "function") {
              return (view) => crypto.getRandomValues(view);
            } else if (ENVIRONMENT_IS_NODE) {
              try {
                var crypto_module = __require("crypto");
                var randomFillSync = crypto_module["randomFillSync"];
                if (randomFillSync) {
                  return (view) => crypto_module["randomFillSync"](view);
                }
                var randomBytes = crypto_module["randomBytes"];
                return (view) => (view.set(randomBytes(view.byteLength)), view);
              } catch (e) {
              }
            }
            abort("initRandomDevice");
          };
          var randomFill = (view) => (randomFill = initRandomFill())(view);
          var PATH_FS = {
            resolve: function() {
              var resolvedPath = "", resolvedAbsolute = false;
              for (var i2 = arguments.length - 1; i2 >= -1 && !resolvedAbsolute; i2--) {
                var path = i2 >= 0 ? arguments[i2] : FS.cwd();
                if (typeof path != "string") {
                  throw new TypeError("Arguments to path.resolve must be strings");
                } else if (!path) {
                  return "";
                }
                resolvedPath = path + "/" + resolvedPath;
                resolvedAbsolute = PATH.isAbs(path);
              }
              resolvedPath = PATH.normalizeArray(resolvedPath.split("/").filter((p) => !!p), !resolvedAbsolute).join("/");
              return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
            },
            relative: (from, to) => {
              from = PATH_FS.resolve(from).substr(1);
              to = PATH_FS.resolve(to).substr(1);
              function trim(arr) {
                var start2 = 0;
                for (; start2 < arr.length; start2++) {
                  if (arr[start2] !== "")
                    break;
                }
                var end = arr.length - 1;
                for (; end >= 0; end--) {
                  if (arr[end] !== "")
                    break;
                }
                if (start2 > end)
                  return [];
                return arr.slice(start2, end - start2 + 1);
              }
              var fromParts = trim(from.split("/"));
              var toParts = trim(to.split("/"));
              var length = Math.min(fromParts.length, toParts.length);
              var samePartsLength = length;
              for (var i2 = 0; i2 < length; i2++) {
                if (fromParts[i2] !== toParts[i2]) {
                  samePartsLength = i2;
                  break;
                }
              }
              var outputParts = [];
              for (var i2 = samePartsLength; i2 < fromParts.length; i2++) {
                outputParts.push("..");
              }
              outputParts = outputParts.concat(toParts.slice(samePartsLength));
              return outputParts.join("/");
            }
          };
          var FS_stdin_getChar_buffer = [];
          var lengthBytesUTF8 = (str) => {
            var len2 = 0;
            for (var i2 = 0; i2 < str.length; ++i2) {
              var c = str.charCodeAt(i2);
              if (c <= 127) {
                len2++;
              } else if (c <= 2047) {
                len2 += 2;
              } else if (c >= 55296 && c <= 57343) {
                len2 += 4;
                ++i2;
              } else {
                len2 += 3;
              }
            }
            return len2;
          };
          var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {
            outIdx >>>= 0;
            if (!(maxBytesToWrite > 0))
              return 0;
            var startIdx = outIdx;
            var endIdx = outIdx + maxBytesToWrite - 1;
            for (var i2 = 0; i2 < str.length; ++i2) {
              var u = str.charCodeAt(i2);
              if (u >= 55296 && u <= 57343) {
                var u1 = str.charCodeAt(++i2);
                u = 65536 + ((u & 1023) << 10) | u1 & 1023;
              }
              if (u <= 127) {
                if (outIdx >= endIdx)
                  break;
                heap[outIdx++ >>> 0] = u;
              } else if (u <= 2047) {
                if (outIdx + 1 >= endIdx)
                  break;
                heap[outIdx++ >>> 0] = 192 | u >> 6;
                heap[outIdx++ >>> 0] = 128 | u & 63;
              } else if (u <= 65535) {
                if (outIdx + 2 >= endIdx)
                  break;
                heap[outIdx++ >>> 0] = 224 | u >> 12;
                heap[outIdx++ >>> 0] = 128 | u >> 6 & 63;
                heap[outIdx++ >>> 0] = 128 | u & 63;
              } else {
                if (outIdx + 3 >= endIdx)
                  break;
                heap[outIdx++ >>> 0] = 240 | u >> 18;
                heap[outIdx++ >>> 0] = 128 | u >> 12 & 63;
                heap[outIdx++ >>> 0] = 128 | u >> 6 & 63;
                heap[outIdx++ >>> 0] = 128 | u & 63;
              }
            }
            heap[outIdx >>> 0] = 0;
            return outIdx - startIdx;
          };
          function intArrayFromString(stringy, dontAddNull, length) {
            var len2 = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
            var u8array = new Array(len2);
            var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
            if (dontAddNull)
              u8array.length = numBytesWritten;
            return u8array;
          }
          var FS_stdin_getChar = () => {
            if (!FS_stdin_getChar_buffer.length) {
              var result = null;
              if (ENVIRONMENT_IS_NODE) {
                var BUFSIZE = 256;
                var buf = Buffer.alloc(BUFSIZE);
                var bytesRead = 0;
                var fd = process.stdin.fd;
                try {
                  bytesRead = fs.readSync(fd, buf);
                } catch (e) {
                  if (e.toString().includes("EOF"))
                    bytesRead = 0;
                  else
                    throw e;
                }
                if (bytesRead > 0) {
                  result = buf.slice(0, bytesRead).toString("utf-8");
                } else {
                  result = null;
                }
              } else if (typeof window != "undefined" && typeof window.prompt == "function") {
                result = window.prompt("Input: ");
                if (result !== null) {
                  result += "\n";
                }
              } else if (typeof readline == "function") {
                result = readline();
                if (result !== null) {
                  result += "\n";
                }
              }
              if (!result) {
                return null;
              }
              FS_stdin_getChar_buffer = intArrayFromString(result, true);
            }
            return FS_stdin_getChar_buffer.shift();
          };
          var TTY = {
            ttys: [],
            init() {
            },
            shutdown() {
            },
            register(dev, ops) {
              TTY.ttys[dev] = {
                input: [],
                output: [],
                ops
              };
              FS.registerDevice(dev, TTY.stream_ops);
            },
            stream_ops: {
              open(stream) {
                var tty = TTY.ttys[stream.node.rdev];
                if (!tty) {
                  throw new FS.ErrnoError(43);
                }
                stream.tty = tty;
                stream.seekable = false;
              },
              close(stream) {
                stream.tty.ops.fsync(stream.tty);
              },
              fsync(stream) {
                stream.tty.ops.fsync(stream.tty);
              },
              read(stream, buffer, offset, length, pos) {
                if (!stream.tty || !stream.tty.ops.get_char) {
                  throw new FS.ErrnoError(60);
                }
                var bytesRead = 0;
                for (var i2 = 0; i2 < length; i2++) {
                  var result;
                  try {
                    result = stream.tty.ops.get_char(stream.tty);
                  } catch (e) {
                    throw new FS.ErrnoError(29);
                  }
                  if (result === void 0 && bytesRead === 0) {
                    throw new FS.ErrnoError(6);
                  }
                  if (result === null || result === void 0)
                    break;
                  bytesRead++;
                  buffer[offset + i2] = result;
                }
                if (bytesRead) {
                  stream.node.timestamp = Date.now();
                }
                return bytesRead;
              },
              write(stream, buffer, offset, length, pos) {
                if (!stream.tty || !stream.tty.ops.put_char) {
                  throw new FS.ErrnoError(60);
                }
                try {
                  for (var i2 = 0; i2 < length; i2++) {
                    stream.tty.ops.put_char(stream.tty, buffer[offset + i2]);
                  }
                } catch (e) {
                  throw new FS.ErrnoError(29);
                }
                if (length) {
                  stream.node.timestamp = Date.now();
                }
                return i2;
              }
            },
            default_tty_ops: {
              get_char(tty) {
                return FS_stdin_getChar();
              },
              put_char(tty, val) {
                if (val === null || val === 10) {
                  out(UTF8ArrayToString(tty.output, 0));
                  tty.output = [];
                } else {
                  if (val != 0)
                    tty.output.push(val);
                }
              },
              fsync(tty) {
                if (tty.output && tty.output.length > 0) {
                  out(UTF8ArrayToString(tty.output, 0));
                  tty.output = [];
                }
              },
              ioctl_tcgets(tty) {
                return {
                  c_iflag: 25856,
                  c_oflag: 5,
                  c_cflag: 191,
                  c_lflag: 35387,
                  c_cc: [3, 28, 127, 21, 4, 0, 1, 0, 17, 19, 26, 0, 18, 15, 23, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
                };
              },
              ioctl_tcsets(tty, optional_actions, data2) {
                return 0;
              },
              ioctl_tiocgwinsz(tty) {
                return [24, 80];
              }
            },
            default_tty1_ops: {
              put_char(tty, val) {
                if (val === null || val === 10) {
                  err(UTF8ArrayToString(tty.output, 0));
                  tty.output = [];
                } else {
                  if (val != 0)
                    tty.output.push(val);
                }
              },
              fsync(tty) {
                if (tty.output && tty.output.length > 0) {
                  err(UTF8ArrayToString(tty.output, 0));
                  tty.output = [];
                }
              }
            }
          };
          var mmapAlloc = (size) => {
            size = alignMemory(size, 65536);
            var ptr2 = _emscripten_builtin_memalign(65536, size);
            if (!ptr2)
              return 0;
            return zeroMemory(ptr2, size);
          };
          var MEMFS = {
            ops_table: null,
            mount(mount) {
              return MEMFS.createNode(null, "/", 16384 | 511, 0);
            },
            createNode(parent, name2, mode, dev) {
              if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
                throw new FS.ErrnoError(63);
              }
              MEMFS.ops_table || (MEMFS.ops_table = {
                dir: {
                  node: {
                    getattr: MEMFS.node_ops.getattr,
                    setattr: MEMFS.node_ops.setattr,
                    lookup: MEMFS.node_ops.lookup,
                    mknod: MEMFS.node_ops.mknod,
                    rename: MEMFS.node_ops.rename,
                    unlink: MEMFS.node_ops.unlink,
                    rmdir: MEMFS.node_ops.rmdir,
                    readdir: MEMFS.node_ops.readdir,
                    symlink: MEMFS.node_ops.symlink
                  },
                  stream: {
                    llseek: MEMFS.stream_ops.llseek
                  }
                },
                file: {
                  node: {
                    getattr: MEMFS.node_ops.getattr,
                    setattr: MEMFS.node_ops.setattr
                  },
                  stream: {
                    llseek: MEMFS.stream_ops.llseek,
                    read: MEMFS.stream_ops.read,
                    write: MEMFS.stream_ops.write,
                    allocate: MEMFS.stream_ops.allocate,
                    mmap: MEMFS.stream_ops.mmap,
                    msync: MEMFS.stream_ops.msync
                  }
                },
                link: {
                  node: {
                    getattr: MEMFS.node_ops.getattr,
                    setattr: MEMFS.node_ops.setattr,
                    readlink: MEMFS.node_ops.readlink
                  },
                  stream: {}
                },
                chrdev: {
                  node: {
                    getattr: MEMFS.node_ops.getattr,
                    setattr: MEMFS.node_ops.setattr
                  },
                  stream: FS.chrdev_stream_ops
                }
              });
              var node = FS.createNode(parent, name2, mode, dev);
              if (FS.isDir(node.mode)) {
                node.node_ops = MEMFS.ops_table.dir.node;
                node.stream_ops = MEMFS.ops_table.dir.stream;
                node.contents = {};
              } else if (FS.isFile(node.mode)) {
                node.node_ops = MEMFS.ops_table.file.node;
                node.stream_ops = MEMFS.ops_table.file.stream;
                node.usedBytes = 0;
                node.contents = null;
              } else if (FS.isLink(node.mode)) {
                node.node_ops = MEMFS.ops_table.link.node;
                node.stream_ops = MEMFS.ops_table.link.stream;
              } else if (FS.isChrdev(node.mode)) {
                node.node_ops = MEMFS.ops_table.chrdev.node;
                node.stream_ops = MEMFS.ops_table.chrdev.stream;
              }
              node.timestamp = Date.now();
              if (parent) {
                parent.contents[name2] = node;
                parent.timestamp = node.timestamp;
              }
              return node;
            },
            getFileDataAsTypedArray(node) {
              if (!node.contents)
                return new Uint8Array(0);
              if (node.contents.subarray)
                return node.contents.subarray(0, node.usedBytes);
              return new Uint8Array(node.contents);
            },
            expandFileStorage(node, newCapacity) {
              var prevCapacity = node.contents ? node.contents.length : 0;
              if (prevCapacity >= newCapacity)
                return;
              var CAPACITY_DOUBLING_MAX = 1024 * 1024;
              newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0);
              if (prevCapacity != 0)
                newCapacity = Math.max(newCapacity, 256);
              var oldContents = node.contents;
              node.contents = new Uint8Array(newCapacity);
              if (node.usedBytes > 0)
                node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
            },
            resizeFileStorage(node, newSize) {
              if (node.usedBytes == newSize)
                return;
              if (newSize == 0) {
                node.contents = null;
                node.usedBytes = 0;
              } else {
                var oldContents = node.contents;
                node.contents = new Uint8Array(newSize);
                if (oldContents) {
                  node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));
                }
                node.usedBytes = newSize;
              }
            },
            node_ops: {
              getattr(node) {
                var attr = {};
                attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
                attr.ino = node.id;
                attr.mode = node.mode;
                attr.nlink = 1;
                attr.uid = 0;
                attr.gid = 0;
                attr.rdev = node.rdev;
                if (FS.isDir(node.mode)) {
                  attr.size = 4096;
                } else if (FS.isFile(node.mode)) {
                  attr.size = node.usedBytes;
                } else if (FS.isLink(node.mode)) {
                  attr.size = node.link.length;
                } else {
                  attr.size = 0;
                }
                attr.atime = new Date(node.timestamp);
                attr.mtime = new Date(node.timestamp);
                attr.ctime = new Date(node.timestamp);
                attr.blksize = 4096;
                attr.blocks = Math.ceil(attr.size / attr.blksize);
                return attr;
              },
              setattr(node, attr) {
                if (attr.mode !== void 0) {
                  node.mode = attr.mode;
                }
                if (attr.timestamp !== void 0) {
                  node.timestamp = attr.timestamp;
                }
                if (attr.size !== void 0) {
                  MEMFS.resizeFileStorage(node, attr.size);
                }
              },
              lookup(parent, name2) {
                throw FS.genericErrors[44];
              },
              mknod(parent, name2, mode, dev) {
                return MEMFS.createNode(parent, name2, mode, dev);
              },
              rename(old_node, new_dir, new_name) {
                if (FS.isDir(old_node.mode)) {
                  var new_node;
                  try {
                    new_node = FS.lookupNode(new_dir, new_name);
                  } catch (e) {
                  }
                  if (new_node) {
                    for (var i2 in new_node.contents) {
                      throw new FS.ErrnoError(55);
                    }
                  }
                }
                delete old_node.parent.contents[old_node.name];
                old_node.parent.timestamp = Date.now();
                old_node.name = new_name;
                new_dir.contents[new_name] = old_node;
                new_dir.timestamp = old_node.parent.timestamp;
                old_node.parent = new_dir;
              },
              unlink(parent, name2) {
                delete parent.contents[name2];
                parent.timestamp = Date.now();
              },
              rmdir(parent, name2) {
                var node = FS.lookupNode(parent, name2);
                for (var i2 in node.contents) {
                  throw new FS.ErrnoError(55);
                }
                delete parent.contents[name2];
                parent.timestamp = Date.now();
              },
              readdir(node) {
                var entries = [".", ".."];
                for (var key of Object.keys(node.contents)) {
                  entries.push(key);
                }
                return entries;
              },
              symlink(parent, newname, oldpath) {
                var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
                node.link = oldpath;
                return node;
              },
              readlink(node) {
                if (!FS.isLink(node.mode)) {
                  throw new FS.ErrnoError(28);
                }
                return node.link;
              }
            },
            stream_ops: {
              read(stream, buffer, offset, length, position) {
                var contents = stream.node.contents;
                if (position >= stream.node.usedBytes)
                  return 0;
                var size = Math.min(stream.node.usedBytes - position, length);
                if (size > 8 && contents.subarray) {
                  buffer.set(contents.subarray(position, position + size), offset);
                } else {
                  for (var i2 = 0; i2 < size; i2++)
                    buffer[offset + i2] = contents[position + i2];
                }
                return size;
              },
              write(stream, buffer, offset, length, position, canOwn) {
                if (buffer.buffer === HEAP8.buffer) {
                  canOwn = false;
                }
                if (!length)
                  return 0;
                var node = stream.node;
                node.timestamp = Date.now();
                if (buffer.subarray && (!node.contents || node.contents.subarray)) {
                  if (canOwn) {
                    node.contents = buffer.subarray(offset, offset + length);
                    node.usedBytes = length;
                    return length;
                  } else if (node.usedBytes === 0 && position === 0) {
                    node.contents = buffer.slice(offset, offset + length);
                    node.usedBytes = length;
                    return length;
                  } else if (position + length <= node.usedBytes) {
                    node.contents.set(buffer.subarray(offset, offset + length), position);
                    return length;
                  }
                }
                MEMFS.expandFileStorage(node, position + length);
                if (node.contents.subarray && buffer.subarray) {
                  node.contents.set(buffer.subarray(offset, offset + length), position);
                } else {
                  for (var i2 = 0; i2 < length; i2++) {
                    node.contents[position + i2] = buffer[offset + i2];
                  }
                }
                node.usedBytes = Math.max(node.usedBytes, position + length);
                return length;
              },
              llseek(stream, offset, whence) {
                var position = offset;
                if (whence === 1) {
                  position += stream.position;
                } else if (whence === 2) {
                  if (FS.isFile(stream.node.mode)) {
                    position += stream.node.usedBytes;
                  }
                }
                if (position < 0) {
                  throw new FS.ErrnoError(28);
                }
                return position;
              },
              allocate(stream, offset, length) {
                MEMFS.expandFileStorage(stream.node, offset + length);
                stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
              },
              mmap(stream, length, position, prot, flags2) {
                if (!FS.isFile(stream.node.mode)) {
                  throw new FS.ErrnoError(43);
                }
                var ptr2;
                var allocated;
                var contents = stream.node.contents;
                if (!(flags2 & 2) && contents.buffer === HEAP8.buffer) {
                  allocated = false;
                  ptr2 = contents.byteOffset;
                } else {
                  if (position > 0 || position + length < contents.length) {
                    if (contents.subarray) {
                      contents = contents.subarray(position, position + length);
                    } else {
                      contents = Array.prototype.slice.call(contents, position, position + length);
                    }
                  }
                  allocated = true;
                  ptr2 = mmapAlloc(length);
                  if (!ptr2) {
                    throw new FS.ErrnoError(48);
                  }
                  HEAP8.set(contents, ptr2 >>> 0);
                }
                return {
                  ptr: ptr2,
                  allocated
                };
              },
              msync(stream, buffer, offset, length, mmapFlags) {
                MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);
                return 0;
              }
            }
          };
          var FS_createDataFile = (parent, name2, fileData, canRead, canWrite, canOwn) => {
            FS.createDataFile(parent, name2, fileData, canRead, canWrite, canOwn);
          };
          var FS_handledByPreloadPlugin = (byteArray, fullname, finish, onerror2) => {
            if (typeof Browser != "undefined")
              Browser.init();
            var handled = false;
            preloadPlugins.forEach((plugin) => {
              if (handled)
                return;
              if (plugin["canHandle"](fullname)) {
                plugin["handle"](byteArray, fullname, finish, onerror2);
                handled = true;
              }
            });
            return handled;
          };
          var FS_createPreloadedFile = (parent, name2, url2, canRead, canWrite, onload2, onerror2, dontCreateFile, canOwn, preFinish) => {
            var fullname = name2 ? PATH_FS.resolve(PATH.join2(parent, name2)) : parent;
            var dep = getUniqueRunDependency(`cp ${fullname}`);
            function processData(byteArray) {
              function finish(byteArray2) {
                preFinish?.();
                if (!dontCreateFile) {
                  FS_createDataFile(parent, name2, byteArray2, canRead, canWrite, canOwn);
                }
                onload2?.();
                removeRunDependency(dep);
              }
              if (FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {
                onerror2?.();
                removeRunDependency(dep);
              })) {
                return;
              }
              finish(byteArray);
            }
            addRunDependency(dep);
            if (typeof url2 == "string") {
              asyncLoad(url2, processData, onerror2);
            } else {
              processData(url2);
            }
          };
          var FS_modeStringToFlags = (str) => {
            var flagModes = {
              "r": 0,
              "r+": 2,
              "w": 512 | 64 | 1,
              "w+": 512 | 64 | 2,
              "a": 1024 | 64 | 1,
              "a+": 1024 | 64 | 2
            };
            var flags2 = flagModes[str];
            if (typeof flags2 == "undefined") {
              throw new Error(`Unknown file open mode: ${str}`);
            }
            return flags2;
          };
          var FS_getMode = (canRead, canWrite) => {
            var mode = 0;
            if (canRead)
              mode |= 292 | 73;
            if (canWrite)
              mode |= 146;
            return mode;
          };
          var FS = {
            root: null,
            mounts: [],
            devices: {},
            streams: [],
            nextInode: 1,
            nameTable: null,
            currentPath: "/",
            initialized: false,
            ignorePermissions: true,
            ErrnoError: null,
            genericErrors: {},
            filesystems: null,
            syncFSRequests: 0,
            lookupPath(path, opts = {}) {
              path = PATH_FS.resolve(path);
              if (!path)
                return {
                  path: "",
                  node: null
                };
              var defaults = {
                follow_mount: true,
                recurse_count: 0
              };
              opts = Object.assign(defaults, opts);
              if (opts.recurse_count > 8) {
                throw new FS.ErrnoError(32);
              }
              var parts2 = path.split("/").filter((p) => !!p);
              var current = FS.root;
              var current_path = "/";
              for (var i2 = 0; i2 < parts2.length; i2++) {
                var islast = i2 === parts2.length - 1;
                if (islast && opts.parent) {
                  break;
                }
                current = FS.lookupNode(current, parts2[i2]);
                current_path = PATH.join2(current_path, parts2[i2]);
                if (FS.isMountpoint(current)) {
                  if (!islast || islast && opts.follow_mount) {
                    current = current.mounted.root;
                  }
                }
                if (!islast || opts.follow) {
                  var count = 0;
                  while (FS.isLink(current.mode)) {
                    var link = FS.readlink(current_path);
                    current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
                    var lookup = FS.lookupPath(current_path, {
                      recurse_count: opts.recurse_count + 1
                    });
                    current = lookup.node;
                    if (count++ > 40) {
                      throw new FS.ErrnoError(32);
                    }
                  }
                }
              }
              return {
                path: current_path,
                node: current
              };
            },
            getPath(node) {
              var path;
              while (true) {
                if (FS.isRoot(node)) {
                  var mount = node.mount.mountpoint;
                  if (!path)
                    return mount;
                  return mount[mount.length - 1] !== "/" ? `${mount}/${path}` : mount + path;
                }
                path = path ? `${node.name}/${path}` : node.name;
                node = node.parent;
              }
            },
            hashName(parentid, name2) {
              var hash = 0;
              for (var i2 = 0; i2 < name2.length; i2++) {
                hash = (hash << 5) - hash + name2.charCodeAt(i2) | 0;
              }
              return (parentid + hash >>> 0) % FS.nameTable.length;
            },
            hashAddNode(node) {
              var hash = FS.hashName(node.parent.id, node.name);
              node.name_next = FS.nameTable[hash];
              FS.nameTable[hash] = node;
            },
            hashRemoveNode(node) {
              var hash = FS.hashName(node.parent.id, node.name);
              if (FS.nameTable[hash] === node) {
                FS.nameTable[hash] = node.name_next;
              } else {
                var current = FS.nameTable[hash];
                while (current) {
                  if (current.name_next === node) {
                    current.name_next = node.name_next;
                    break;
                  }
                  current = current.name_next;
                }
              }
            },
            lookupNode(parent, name2) {
              var errCode = FS.mayLookup(parent);
              if (errCode) {
                throw new FS.ErrnoError(errCode, parent);
              }
              var hash = FS.hashName(parent.id, name2);
              for (var node = FS.nameTable[hash]; node; node = node.name_next) {
                var nodeName = node.name;
                if (node.parent.id === parent.id && nodeName === name2) {
                  return node;
                }
              }
              return FS.lookup(parent, name2);
            },
            createNode(parent, name2, mode, rdev) {
              var node = new FS.FSNode(parent, name2, mode, rdev);
              FS.hashAddNode(node);
              return node;
            },
            destroyNode(node) {
              FS.hashRemoveNode(node);
            },
            isRoot(node) {
              return node === node.parent;
            },
            isMountpoint(node) {
              return !!node.mounted;
            },
            isFile(mode) {
              return (mode & 61440) === 32768;
            },
            isDir(mode) {
              return (mode & 61440) === 16384;
            },
            isLink(mode) {
              return (mode & 61440) === 40960;
            },
            isChrdev(mode) {
              return (mode & 61440) === 8192;
            },
            isBlkdev(mode) {
              return (mode & 61440) === 24576;
            },
            isFIFO(mode) {
              return (mode & 61440) === 4096;
            },
            isSocket(mode) {
              return (mode & 49152) === 49152;
            },
            flagsToPermissionString(flag) {
              var perms = ["r", "w", "rw"][flag & 3];
              if (flag & 512) {
                perms += "w";
              }
              return perms;
            },
            nodePermissions(node, perms) {
              if (FS.ignorePermissions) {
                return 0;
              }
              if (perms.includes("r") && !(node.mode & 292)) {
                return 2;
              } else if (perms.includes("w") && !(node.mode & 146)) {
                return 2;
              } else if (perms.includes("x") && !(node.mode & 73)) {
                return 2;
              }
              return 0;
            },
            mayLookup(dir) {
              var errCode = FS.nodePermissions(dir, "x");
              if (errCode)
                return errCode;
              if (!dir.node_ops.lookup)
                return 2;
              return 0;
            },
            mayCreate(dir, name2) {
              try {
                var node = FS.lookupNode(dir, name2);
                return 20;
              } catch (e) {
              }
              return FS.nodePermissions(dir, "wx");
            },
            mayDelete(dir, name2, isdir) {
              var node;
              try {
                node = FS.lookupNode(dir, name2);
              } catch (e) {
                return e.errno;
              }
              var errCode = FS.nodePermissions(dir, "wx");
              if (errCode) {
                return errCode;
              }
              if (isdir) {
                if (!FS.isDir(node.mode)) {
                  return 54;
                }
                if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
                  return 10;
                }
              } else {
                if (FS.isDir(node.mode)) {
                  return 31;
                }
              }
              return 0;
            },
            mayOpen(node, flags2) {
              if (!node) {
                return 44;
              }
              if (FS.isLink(node.mode)) {
                return 32;
              } else if (FS.isDir(node.mode)) {
                if (FS.flagsToPermissionString(flags2) !== "r" || flags2 & 512) {
                  return 31;
                }
              }
              return FS.nodePermissions(node, FS.flagsToPermissionString(flags2));
            },
            MAX_OPEN_FDS: 4096,
            nextfd() {
              for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {
                if (!FS.streams[fd]) {
                  return fd;
                }
              }
              throw new FS.ErrnoError(33);
            },
            getStreamChecked(fd) {
              var stream = FS.getStream(fd);
              if (!stream) {
                throw new FS.ErrnoError(8);
              }
              return stream;
            },
            getStream: (fd) => FS.streams[fd],
            createStream(stream, fd = -1) {
              if (!FS.FSStream) {
                FS.FSStream = function() {
                  this.shared = {};
                };
                FS.FSStream.prototype = {};
                Object.defineProperties(FS.FSStream.prototype, {
                  object: {
                    get() {
                      return this.node;
                    },
                    set(val) {
                      this.node = val;
                    }
                  },
                  isRead: {
                    get() {
                      return (this.flags & 2097155) !== 1;
                    }
                  },
                  isWrite: {
                    get() {
                      return (this.flags & 2097155) !== 0;
                    }
                  },
                  isAppend: {
                    get() {
                      return this.flags & 1024;
                    }
                  },
                  flags: {
                    get() {
                      return this.shared.flags;
                    },
                    set(val) {
                      this.shared.flags = val;
                    }
                  },
                  position: {
                    get() {
                      return this.shared.position;
                    },
                    set(val) {
                      this.shared.position = val;
                    }
                  }
                });
              }
              stream = Object.assign(new FS.FSStream(), stream);
              if (fd == -1) {
                fd = FS.nextfd();
              }
              stream.fd = fd;
              FS.streams[fd] = stream;
              return stream;
            },
            closeStream(fd) {
              FS.streams[fd] = null;
            },
            chrdev_stream_ops: {
              open(stream) {
                var device = FS.getDevice(stream.node.rdev);
                stream.stream_ops = device.stream_ops;
                stream.stream_ops.open?.(stream);
              },
              llseek() {
                throw new FS.ErrnoError(70);
              }
            },
            major: (dev) => dev >> 8,
            minor: (dev) => dev & 255,
            makedev: (ma, mi) => ma << 8 | mi,
            registerDevice(dev, ops) {
              FS.devices[dev] = {
                stream_ops: ops
              };
            },
            getDevice: (dev) => FS.devices[dev],
            getMounts(mount) {
              var mounts = [];
              var check = [mount];
              while (check.length) {
                var m = check.pop();
                mounts.push(m);
                check.push.apply(check, m.mounts);
              }
              return mounts;
            },
            syncfs(populate, callback) {
              if (typeof populate == "function") {
                callback = populate;
                populate = false;
              }
              FS.syncFSRequests++;
              if (FS.syncFSRequests > 1) {
                err(`warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`);
              }
              var mounts = FS.getMounts(FS.root.mount);
              var completed = 0;
              function doCallback(errCode) {
                FS.syncFSRequests--;
                return callback(errCode);
              }
              function done(errCode) {
                if (errCode) {
                  if (!done.errored) {
                    done.errored = true;
                    return doCallback(errCode);
                  }
                  return;
                }
                if (++completed >= mounts.length) {
                  doCallback(null);
                }
              }
              mounts.forEach((mount) => {
                if (!mount.type.syncfs) {
                  return done(null);
                }
                mount.type.syncfs(mount, populate, done);
              });
            },
            mount(type, opts, mountpoint) {
              var root = mountpoint === "/";
              var pseudo = !mountpoint;
              var node;
              if (root && FS.root) {
                throw new FS.ErrnoError(10);
              } else if (!root && !pseudo) {
                var lookup = FS.lookupPath(mountpoint, {
                  follow_mount: false
                });
                mountpoint = lookup.path;
                node = lookup.node;
                if (FS.isMountpoint(node)) {
                  throw new FS.ErrnoError(10);
                }
                if (!FS.isDir(node.mode)) {
                  throw new FS.ErrnoError(54);
                }
              }
              var mount = {
                type,
                opts,
                mountpoint,
                mounts: []
              };
              var mountRoot = type.mount(mount);
              mountRoot.mount = mount;
              mount.root = mountRoot;
              if (root) {
                FS.root = mountRoot;
              } else if (node) {
                node.mounted = mount;
                if (node.mount) {
                  node.mount.mounts.push(mount);
                }
              }
              return mountRoot;
            },
            unmount(mountpoint) {
              var lookup = FS.lookupPath(mountpoint, {
                follow_mount: false
              });
              if (!FS.isMountpoint(lookup.node)) {
                throw new FS.ErrnoError(28);
              }
              var node = lookup.node;
              var mount = node.mounted;
              var mounts = FS.getMounts(mount);
              Object.keys(FS.nameTable).forEach((hash) => {
                var current = FS.nameTable[hash];
                while (current) {
                  var next = current.name_next;
                  if (mounts.includes(current.mount)) {
                    FS.destroyNode(current);
                  }
                  current = next;
                }
              });
              node.mounted = null;
              var idx = node.mount.mounts.indexOf(mount);
              node.mount.mounts.splice(idx, 1);
            },
            lookup(parent, name2) {
              return parent.node_ops.lookup(parent, name2);
            },
            mknod(path, mode, dev) {
              var lookup = FS.lookupPath(path, {
                parent: true
              });
              var parent = lookup.node;
              var name2 = PATH.basename(path);
              if (!name2 || name2 === "." || name2 === "..") {
                throw new FS.ErrnoError(28);
              }
              var errCode = FS.mayCreate(parent, name2);
              if (errCode) {
                throw new FS.ErrnoError(errCode);
              }
              if (!parent.node_ops.mknod) {
                throw new FS.ErrnoError(63);
              }
              return parent.node_ops.mknod(parent, name2, mode, dev);
            },
            create(path, mode) {
              mode = mode !== void 0 ? mode : 438;
              mode &= 4095;
              mode |= 32768;
              return FS.mknod(path, mode, 0);
            },
            mkdir(path, mode) {
              mode = mode !== void 0 ? mode : 511;
              mode &= 511 | 512;
              mode |= 16384;
              return FS.mknod(path, mode, 0);
            },
            mkdirTree(path, mode) {
              var dirs = path.split("/");
              var d = "";
              for (var i2 = 0; i2 < dirs.length; ++i2) {
                if (!dirs[i2])
                  continue;
                d += "/" + dirs[i2];
                try {
                  FS.mkdir(d, mode);
                } catch (e) {
                  if (e.errno != 20)
                    throw e;
                }
              }
            },
            mkdev(path, mode, dev) {
              if (typeof dev == "undefined") {
                dev = mode;
                mode = 438;
              }
              mode |= 8192;
              return FS.mknod(path, mode, dev);
            },
            symlink(oldpath, newpath) {
              if (!PATH_FS.resolve(oldpath)) {
                throw new FS.ErrnoError(44);
              }
              var lookup = FS.lookupPath(newpath, {
                parent: true
              });
              var parent = lookup.node;
              if (!parent) {
                throw new FS.ErrnoError(44);
              }
              var newname = PATH.basename(newpath);
              var errCode = FS.mayCreate(parent, newname);
              if (errCode) {
                throw new FS.ErrnoError(errCode);
              }
              if (!parent.node_ops.symlink) {
                throw new FS.ErrnoError(63);
              }
              return parent.node_ops.symlink(parent, newname, oldpath);
            },
            rename(old_path, new_path) {
              var old_dirname = PATH.dirname(old_path);
              var new_dirname = PATH.dirname(new_path);
              var old_name = PATH.basename(old_path);
              var new_name = PATH.basename(new_path);
              var lookup, old_dir, new_dir;
              lookup = FS.lookupPath(old_path, {
                parent: true
              });
              old_dir = lookup.node;
              lookup = FS.lookupPath(new_path, {
                parent: true
              });
              new_dir = lookup.node;
              if (!old_dir || !new_dir)
                throw new FS.ErrnoError(44);
              if (old_dir.mount !== new_dir.mount) {
                throw new FS.ErrnoError(75);
              }
              var old_node = FS.lookupNode(old_dir, old_name);
              var relative = PATH_FS.relative(old_path, new_dirname);
              if (relative.charAt(0) !== ".") {
                throw new FS.ErrnoError(28);
              }
              relative = PATH_FS.relative(new_path, old_dirname);
              if (relative.charAt(0) !== ".") {
                throw new FS.ErrnoError(55);
              }
              var new_node;
              try {
                new_node = FS.lookupNode(new_dir, new_name);
              } catch (e) {
              }
              if (old_node === new_node) {
                return;
              }
              var isdir = FS.isDir(old_node.mode);
              var errCode = FS.mayDelete(old_dir, old_name, isdir);
              if (errCode) {
                throw new FS.ErrnoError(errCode);
              }
              errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
              if (errCode) {
                throw new FS.ErrnoError(errCode);
              }
              if (!old_dir.node_ops.rename) {
                throw new FS.ErrnoError(63);
              }
              if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
                throw new FS.ErrnoError(10);
              }
              if (new_dir !== old_dir) {
                errCode = FS.nodePermissions(old_dir, "w");
                if (errCode) {
                  throw new FS.ErrnoError(errCode);
                }
              }
              FS.hashRemoveNode(old_node);
              try {
                old_dir.node_ops.rename(old_node, new_dir, new_name);
              } catch (e) {
                throw e;
              } finally {
                FS.hashAddNode(old_node);
              }
            },
            rmdir(path) {
              var lookup = FS.lookupPath(path, {
                parent: true
              });
              var parent = lookup.node;
              var name2 = PATH.basename(path);
              var node = FS.lookupNode(parent, name2);
              var errCode = FS.mayDelete(parent, name2, true);
              if (errCode) {
                throw new FS.ErrnoError(errCode);
              }
              if (!parent.node_ops.rmdir) {
                throw new FS.ErrnoError(63);
              }
              if (FS.isMountpoint(node)) {
                throw new FS.ErrnoError(10);
              }
              parent.node_ops.rmdir(parent, name2);
              FS.destroyNode(node);
            },
            readdir(path) {
              var lookup = FS.lookupPath(path, {
                follow: true
              });
              var node = lookup.node;
              if (!node.node_ops.readdir) {
                throw new FS.ErrnoError(54);
              }
              return node.node_ops.readdir(node);
            },
            unlink(path) {
              var lookup = FS.lookupPath(path, {
                parent: true
              });
              var parent = lookup.node;
              if (!parent) {
                throw new FS.ErrnoError(44);
              }
              var name2 = PATH.basename(path);
              var node = FS.lookupNode(parent, name2);
              var errCode = FS.mayDelete(parent, name2, false);
              if (errCode) {
                throw new FS.ErrnoError(errCode);
              }
              if (!parent.node_ops.unlink) {
                throw new FS.ErrnoError(63);
              }
              if (FS.isMountpoint(node)) {
                throw new FS.ErrnoError(10);
              }
              parent.node_ops.unlink(parent, name2);
              FS.destroyNode(node);
            },
            readlink(path) {
              var lookup = FS.lookupPath(path);
              var link = lookup.node;
              if (!link) {
                throw new FS.ErrnoError(44);
              }
              if (!link.node_ops.readlink) {
                throw new FS.ErrnoError(28);
              }
              return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
            },
            stat(path, dontFollow) {
              var lookup = FS.lookupPath(path, {
                follow: !dontFollow
              });
              var node = lookup.node;
              if (!node) {
                throw new FS.ErrnoError(44);
              }
              if (!node.node_ops.getattr) {
                throw new FS.ErrnoError(63);
              }
              return node.node_ops.getattr(node);
            },
            lstat(path) {
              return FS.stat(path, true);
            },
            chmod(path, mode, dontFollow) {
              var node;
              if (typeof path == "string") {
                var lookup = FS.lookupPath(path, {
                  follow: !dontFollow
                });
                node = lookup.node;
              } else {
                node = path;
              }
              if (!node.node_ops.setattr) {
                throw new FS.ErrnoError(63);
              }
              node.node_ops.setattr(node, {
                mode: mode & 4095 | node.mode & ~4095,
                timestamp: Date.now()
              });
            },
            lchmod(path, mode) {
              FS.chmod(path, mode, true);
            },
            fchmod(fd, mode) {
              var stream = FS.getStreamChecked(fd);
              FS.chmod(stream.node, mode);
            },
            chown(path, uid, gid, dontFollow) {
              var node;
              if (typeof path == "string") {
                var lookup = FS.lookupPath(path, {
                  follow: !dontFollow
                });
                node = lookup.node;
              } else {
                node = path;
              }
              if (!node.node_ops.setattr) {
                throw new FS.ErrnoError(63);
              }
              node.node_ops.setattr(node, {
                timestamp: Date.now()
              });
            },
            lchown(path, uid, gid) {
              FS.chown(path, uid, gid, true);
            },
            fchown(fd, uid, gid) {
              var stream = FS.getStreamChecked(fd);
              FS.chown(stream.node, uid, gid);
            },
            truncate(path, len2) {
              if (len2 < 0) {
                throw new FS.ErrnoError(28);
              }
              var node;
              if (typeof path == "string") {
                var lookup = FS.lookupPath(path, {
                  follow: true
                });
                node = lookup.node;
              } else {
                node = path;
              }
              if (!node.node_ops.setattr) {
                throw new FS.ErrnoError(63);
              }
              if (FS.isDir(node.mode)) {
                throw new FS.ErrnoError(31);
              }
              if (!FS.isFile(node.mode)) {
                throw new FS.ErrnoError(28);
              }
              var errCode = FS.nodePermissions(node, "w");
              if (errCode) {
                throw new FS.ErrnoError(errCode);
              }
              node.node_ops.setattr(node, {
                size: len2,
                timestamp: Date.now()
              });
            },
            ftruncate(fd, len2) {
              var stream = FS.getStreamChecked(fd);
              if ((stream.flags & 2097155) === 0) {
                throw new FS.ErrnoError(28);
              }
              FS.truncate(stream.node, len2);
            },
            utime(path, atime, mtime) {
              var lookup = FS.lookupPath(path, {
                follow: true
              });
              var node = lookup.node;
              node.node_ops.setattr(node, {
                timestamp: Math.max(atime, mtime)
              });
            },
            open(path, flags2, mode) {
              if (path === "") {
                throw new FS.ErrnoError(44);
              }
              flags2 = typeof flags2 == "string" ? FS_modeStringToFlags(flags2) : flags2;
              mode = typeof mode == "undefined" ? 438 : mode;
              if (flags2 & 64) {
                mode = mode & 4095 | 32768;
              } else {
                mode = 0;
              }
              var node;
              if (typeof path == "object") {
                node = path;
              } else {
                path = PATH.normalize(path);
                try {
                  var lookup = FS.lookupPath(path, {
                    follow: !(flags2 & 131072)
                  });
                  node = lookup.node;
                } catch (e) {
                }
              }
              var created = false;
              if (flags2 & 64) {
                if (node) {
                  if (flags2 & 128) {
                    throw new FS.ErrnoError(20);
                  }
                } else {
                  node = FS.mknod(path, mode, 0);
                  created = true;
                }
              }
              if (!node) {
                throw new FS.ErrnoError(44);
              }
              if (FS.isChrdev(node.mode)) {
                flags2 &= ~512;
              }
              if (flags2 & 65536 && !FS.isDir(node.mode)) {
                throw new FS.ErrnoError(54);
              }
              if (!created) {
                var errCode = FS.mayOpen(node, flags2);
                if (errCode) {
                  throw new FS.ErrnoError(errCode);
                }
              }
              if (flags2 & 512 && !created) {
                FS.truncate(node, 0);
              }
              flags2 &= ~(128 | 512 | 131072);
              var stream = FS.createStream({
                node,
                path: FS.getPath(node),
                flags: flags2,
                seekable: true,
                position: 0,
                stream_ops: node.stream_ops,
                ungotten: [],
                error: false
              });
              if (stream.stream_ops.open) {
                stream.stream_ops.open(stream);
              }
              if (Module["logReadFiles"] && !(flags2 & 1)) {
                if (!FS.readFiles)
                  FS.readFiles = {};
                if (!(path in FS.readFiles)) {
                  FS.readFiles[path] = 1;
                }
              }
              return stream;
            },
            close(stream) {
              if (FS.isClosed(stream)) {
                throw new FS.ErrnoError(8);
              }
              if (stream.getdents)
                stream.getdents = null;
              try {
                if (stream.stream_ops.close) {
                  stream.stream_ops.close(stream);
                }
              } catch (e) {
                throw e;
              } finally {
                FS.closeStream(stream.fd);
              }
              stream.fd = null;
            },
            isClosed(stream) {
              return stream.fd === null;
            },
            llseek(stream, offset, whence) {
              if (FS.isClosed(stream)) {
                throw new FS.ErrnoError(8);
              }
              if (!stream.seekable || !stream.stream_ops.llseek) {
                throw new FS.ErrnoError(70);
              }
              if (whence != 0 && whence != 1 && whence != 2) {
                throw new FS.ErrnoError(28);
              }
              stream.position = stream.stream_ops.llseek(stream, offset, whence);
              stream.ungotten = [];
              return stream.position;
            },
            read(stream, buffer, offset, length, position) {
              if (length < 0 || position < 0) {
                throw new FS.ErrnoError(28);
              }
              if (FS.isClosed(stream)) {
                throw new FS.ErrnoError(8);
              }
              if ((stream.flags & 2097155) === 1) {
                throw new FS.ErrnoError(8);
              }
              if (FS.isDir(stream.node.mode)) {
                throw new FS.ErrnoError(31);
              }
              if (!stream.stream_ops.read) {
                throw new FS.ErrnoError(28);
              }
              var seeking = typeof position != "undefined";
              if (!seeking) {
                position = stream.position;
              } else if (!stream.seekable) {
                throw new FS.ErrnoError(70);
              }
              var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
              if (!seeking)
                stream.position += bytesRead;
              return bytesRead;
            },
            write(stream, buffer, offset, length, position, canOwn) {
              if (length < 0 || position < 0) {
                throw new FS.ErrnoError(28);
              }
              if (FS.isClosed(stream)) {
                throw new FS.ErrnoError(8);
              }
              if ((stream.flags & 2097155) === 0) {
                throw new FS.ErrnoError(8);
              }
              if (FS.isDir(stream.node.mode)) {
                throw new FS.ErrnoError(31);
              }
              if (!stream.stream_ops.write) {
                throw new FS.ErrnoError(28);
              }
              if (stream.seekable && stream.flags & 1024) {
                FS.llseek(stream, 0, 2);
              }
              var seeking = typeof position != "undefined";
              if (!seeking) {
                position = stream.position;
              } else if (!stream.seekable) {
                throw new FS.ErrnoError(70);
              }
              var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
              if (!seeking)
                stream.position += bytesWritten;
              return bytesWritten;
            },
            allocate(stream, offset, length) {
              if (FS.isClosed(stream)) {
                throw new FS.ErrnoError(8);
              }
              if (offset < 0 || length <= 0) {
                throw new FS.ErrnoError(28);
              }
              if ((stream.flags & 2097155) === 0) {
                throw new FS.ErrnoError(8);
              }
              if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
                throw new FS.ErrnoError(43);
              }
              if (!stream.stream_ops.allocate) {
                throw new FS.ErrnoError(138);
              }
              stream.stream_ops.allocate(stream, offset, length);
            },
            mmap(stream, length, position, prot, flags2) {
              if ((prot & 2) !== 0 && (flags2 & 2) === 0 && (stream.flags & 2097155) !== 2) {
                throw new FS.ErrnoError(2);
              }
              if ((stream.flags & 2097155) === 1) {
                throw new FS.ErrnoError(2);
              }
              if (!stream.stream_ops.mmap) {
                throw new FS.ErrnoError(43);
              }
              return stream.stream_ops.mmap(stream, length, position, prot, flags2);
            },
            msync(stream, buffer, offset, length, mmapFlags) {
              if (!stream.stream_ops.msync) {
                return 0;
              }
              return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);
            },
            munmap: (stream) => 0,
            ioctl(stream, cmd, arg) {
              if (!stream.stream_ops.ioctl) {
                throw new FS.ErrnoError(59);
              }
              return stream.stream_ops.ioctl(stream, cmd, arg);
            },
            readFile(path, opts = {}) {
              opts.flags = opts.flags || 0;
              opts.encoding = opts.encoding || "binary";
              if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
                throw new Error(`Invalid encoding type "${opts.encoding}"`);
              }
              var ret;
              var stream = FS.open(path, opts.flags);
              var stat = FS.stat(path);
              var length = stat.size;
              var buf = new Uint8Array(length);
              FS.read(stream, buf, 0, length, 0);
              if (opts.encoding === "utf8") {
                ret = UTF8ArrayToString(buf, 0);
              } else if (opts.encoding === "binary") {
                ret = buf;
              }
              FS.close(stream);
              return ret;
            },
            writeFile(path, data2, opts = {}) {
              opts.flags = opts.flags || 577;
              var stream = FS.open(path, opts.flags, opts.mode);
              if (typeof data2 == "string") {
                var buf = new Uint8Array(lengthBytesUTF8(data2) + 1);
                var actualNumBytes = stringToUTF8Array(data2, buf, 0, buf.length);
                FS.write(stream, buf, 0, actualNumBytes, void 0, opts.canOwn);
              } else if (ArrayBuffer.isView(data2)) {
                FS.write(stream, data2, 0, data2.byteLength, void 0, opts.canOwn);
              } else {
                throw new Error("Unsupported data type");
              }
              FS.close(stream);
            },
            cwd: () => FS.currentPath,
            chdir(path) {
              var lookup = FS.lookupPath(path, {
                follow: true
              });
              if (lookup.node === null) {
                throw new FS.ErrnoError(44);
              }
              if (!FS.isDir(lookup.node.mode)) {
                throw new FS.ErrnoError(54);
              }
              var errCode = FS.nodePermissions(lookup.node, "x");
              if (errCode) {
                throw new FS.ErrnoError(errCode);
              }
              FS.currentPath = lookup.path;
            },
            createDefaultDirectories() {
              FS.mkdir("/tmp");
              FS.mkdir("/home");
              FS.mkdir("/home/web_user");
            },
            createDefaultDevices() {
              FS.mkdir("/dev");
              FS.registerDevice(FS.makedev(1, 3), {
                read: () => 0,
                write: (stream, buffer, offset, length, pos) => length
              });
              FS.mkdev("/dev/null", FS.makedev(1, 3));
              TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
              TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
              FS.mkdev("/dev/tty", FS.makedev(5, 0));
              FS.mkdev("/dev/tty1", FS.makedev(6, 0));
              var randomBuffer = new Uint8Array(1024), randomLeft = 0;
              var randomByte = () => {
                if (randomLeft === 0) {
                  randomLeft = randomFill(randomBuffer).byteLength;
                }
                return randomBuffer[--randomLeft];
              };
              FS.createDevice("/dev", "random", randomByte);
              FS.createDevice("/dev", "urandom", randomByte);
              FS.mkdir("/dev/shm");
              FS.mkdir("/dev/shm/tmp");
            },
            createSpecialDirectories() {
              FS.mkdir("/proc");
              var proc_self = FS.mkdir("/proc/self");
              FS.mkdir("/proc/self/fd");
              FS.mount({
                mount() {
                  var node = FS.createNode(proc_self, "fd", 16384 | 511, 73);
                  node.node_ops = {
                    lookup(parent, name2) {
                      var fd = +name2;
                      var stream = FS.getStreamChecked(fd);
                      var ret = {
                        parent: null,
                        mount: {
                          mountpoint: "fake"
                        },
                        node_ops: {
                          readlink: () => stream.path
                        }
                      };
                      ret.parent = ret;
                      return ret;
                    }
                  };
                  return node;
                }
              }, {}, "/proc/self/fd");
            },
            createStandardStreams() {
              if (Module["stdin"]) {
                FS.createDevice("/dev", "stdin", Module["stdin"]);
              } else {
                FS.symlink("/dev/tty", "/dev/stdin");
              }
              if (Module["stdout"]) {
                FS.createDevice("/dev", "stdout", null, Module["stdout"]);
              } else {
                FS.symlink("/dev/tty", "/dev/stdout");
              }
              if (Module["stderr"]) {
                FS.createDevice("/dev", "stderr", null, Module["stderr"]);
              } else {
                FS.symlink("/dev/tty1", "/dev/stderr");
              }
              var stdin = FS.open("/dev/stdin", 0);
              var stdout = FS.open("/dev/stdout", 1);
              var stderr = FS.open("/dev/stderr", 1);
            },
            ensureErrnoError() {
              if (FS.ErrnoError)
                return;
              FS.ErrnoError = function ErrnoError(errno, node) {
                this.name = "ErrnoError";
                this.node = node;
                this.setErrno = function(errno2) {
                  this.errno = errno2;
                };
                this.setErrno(errno);
                this.message = "FS error";
              };
              FS.ErrnoError.prototype = new Error();
              FS.ErrnoError.prototype.constructor = FS.ErrnoError;
              [44].forEach((code) => {
                FS.genericErrors[code] = new FS.ErrnoError(code);
                FS.genericErrors[code].stack = "<generic error, no stack>";
              });
            },
            staticInit() {
              FS.ensureErrnoError();
              FS.nameTable = new Array(4096);
              FS.mount(MEMFS, {}, "/");
              FS.createDefaultDirectories();
              FS.createDefaultDevices();
              FS.createSpecialDirectories();
              FS.filesystems = {
                "MEMFS": MEMFS
              };
            },
            init(input, output, error) {
              FS.init.initialized = true;
              FS.ensureErrnoError();
              Module["stdin"] = input || Module["stdin"];
              Module["stdout"] = output || Module["stdout"];
              Module["stderr"] = error || Module["stderr"];
              FS.createStandardStreams();
            },
            quit() {
              FS.init.initialized = false;
              _fflush(0);
              for (var i2 = 0; i2 < FS.streams.length; i2++) {
                var stream = FS.streams[i2];
                if (!stream) {
                  continue;
                }
                FS.close(stream);
              }
            },
            findObject(path, dontResolveLastLink) {
              var ret = FS.analyzePath(path, dontResolveLastLink);
              if (!ret.exists) {
                return null;
              }
              return ret.object;
            },
            analyzePath(path, dontResolveLastLink) {
              try {
                var lookup = FS.lookupPath(path, {
                  follow: !dontResolveLastLink
                });
                path = lookup.path;
              } catch (e) {
              }
              var ret = {
                isRoot: false,
                exists: false,
                error: 0,
                name: null,
                path: null,
                object: null,
                parentExists: false,
                parentPath: null,
                parentObject: null
              };
              try {
                var lookup = FS.lookupPath(path, {
                  parent: true
                });
                ret.parentExists = true;
                ret.parentPath = lookup.path;
                ret.parentObject = lookup.node;
                ret.name = PATH.basename(path);
                lookup = FS.lookupPath(path, {
                  follow: !dontResolveLastLink
                });
                ret.exists = true;
                ret.path = lookup.path;
                ret.object = lookup.node;
                ret.name = lookup.node.name;
                ret.isRoot = lookup.path === "/";
              } catch (e) {
                ret.error = e.errno;
              }
              return ret;
            },
            createPath(parent, path, canRead, canWrite) {
              parent = typeof parent == "string" ? parent : FS.getPath(parent);
              var parts2 = path.split("/").reverse();
              while (parts2.length) {
                var part = parts2.pop();
                if (!part)
                  continue;
                var current = PATH.join2(parent, part);
                try {
                  FS.mkdir(current);
                } catch (e) {
                }
                parent = current;
              }
              return current;
            },
            createFile(parent, name2, properties, canRead, canWrite) {
              var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name2);
              var mode = FS_getMode(canRead, canWrite);
              return FS.create(path, mode);
            },
            createDataFile(parent, name2, data2, canRead, canWrite, canOwn) {
              var path = name2;
              if (parent) {
                parent = typeof parent == "string" ? parent : FS.getPath(parent);
                path = name2 ? PATH.join2(parent, name2) : parent;
              }
              var mode = FS_getMode(canRead, canWrite);
              var node = FS.create(path, mode);
              if (data2) {
                if (typeof data2 == "string") {
                  var arr = new Array(data2.length);
                  for (var i2 = 0, len2 = data2.length; i2 < len2; ++i2)
                    arr[i2] = data2.charCodeAt(i2);
                  data2 = arr;
                }
                FS.chmod(node, mode | 146);
                var stream = FS.open(node, 577);
                FS.write(stream, data2, 0, data2.length, 0, canOwn);
                FS.close(stream);
                FS.chmod(node, mode);
              }
            },
            createDevice(parent, name2, input, output) {
              var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name2);
              var mode = FS_getMode(!!input, !!output);
              if (!FS.createDevice.major)
                FS.createDevice.major = 64;
              var dev = FS.makedev(FS.createDevice.major++, 0);
              FS.registerDevice(dev, {
                open(stream) {
                  stream.seekable = false;
                },
                close(stream) {
                  if (output?.buffer?.length) {
                    output(10);
                  }
                },
                read(stream, buffer, offset, length, pos) {
                  var bytesRead = 0;
                  for (var i2 = 0; i2 < length; i2++) {
                    var result;
                    try {
                      result = input();
                    } catch (e) {
                      throw new FS.ErrnoError(29);
                    }
                    if (result === void 0 && bytesRead === 0) {
                      throw new FS.ErrnoError(6);
                    }
                    if (result === null || result === void 0)
                      break;
                    bytesRead++;
                    buffer[offset + i2] = result;
                  }
                  if (bytesRead) {
                    stream.node.timestamp = Date.now();
                  }
                  return bytesRead;
                },
                write(stream, buffer, offset, length, pos) {
                  for (var i2 = 0; i2 < length; i2++) {
                    try {
                      output(buffer[offset + i2]);
                    } catch (e) {
                      throw new FS.ErrnoError(29);
                    }
                  }
                  if (length) {
                    stream.node.timestamp = Date.now();
                  }
                  return i2;
                }
              });
              return FS.mkdev(path, mode, dev);
            },
            forceLoadFile(obj) {
              if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
                return true;
              if (typeof XMLHttpRequest != "undefined") {
                throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
              } else if (read_) {
                try {
                  obj.contents = intArrayFromString(read_(obj.url), true);
                  obj.usedBytes = obj.contents.length;
                } catch (e) {
                  throw new FS.ErrnoError(29);
                }
              } else {
                throw new Error("Cannot load without read() or XMLHttpRequest.");
              }
            },
            createLazyFile(parent, name2, url2, canRead, canWrite) {
              function LazyUint8Array() {
                this.lengthKnown = false;
                this.chunks = [];
              }
              LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {
                if (idx > this.length - 1 || idx < 0) {
                  return void 0;
                }
                var chunkOffset = idx % this.chunkSize;
                var chunkNum = idx / this.chunkSize | 0;
                return this.getter(chunkNum)[chunkOffset];
              };
              LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
                this.getter = getter;
              };
              LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
                var xhr = new XMLHttpRequest();
                xhr.open("HEAD", url2, false);
                xhr.send(null);
                if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))
                  throw new Error("Couldn't load " + url2 + ". Status: " + xhr.status);
                var datalength = Number(xhr.getResponseHeader("Content-length"));
                var header;
                var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
                var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
                var chunkSize = 1024 * 1024;
                if (!hasByteServing)
                  chunkSize = datalength;
                var doXHR = (from, to) => {
                  if (from > to)
                    throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
                  if (to > datalength - 1)
                    throw new Error("only " + datalength + " bytes available! programmer error!");
                  var xhr2 = new XMLHttpRequest();
                  xhr2.open("GET", url2, false);
                  if (datalength !== chunkSize)
                    xhr2.setRequestHeader("Range", "bytes=" + from + "-" + to);
                  xhr2.responseType = "arraybuffer";
                  if (xhr2.overrideMimeType) {
                    xhr2.overrideMimeType("text/plain; charset=x-user-defined");
                  }
                  xhr2.send(null);
                  if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))
                    throw new Error("Couldn't load " + url2 + ". Status: " + xhr2.status);
                  if (xhr2.response !== void 0) {
                    return new Uint8Array(xhr2.response || []);
                  }
                  return intArrayFromString(xhr2.responseText || "", true);
                };
                var lazyArray2 = this;
                lazyArray2.setDataGetter((chunkNum) => {
                  var start2 = chunkNum * chunkSize;
                  var end = (chunkNum + 1) * chunkSize - 1;
                  end = Math.min(end, datalength - 1);
                  if (typeof lazyArray2.chunks[chunkNum] == "undefined") {
                    lazyArray2.chunks[chunkNum] = doXHR(start2, end);
                  }
                  if (typeof lazyArray2.chunks[chunkNum] == "undefined")
                    throw new Error("doXHR failed!");
                  return lazyArray2.chunks[chunkNum];
                });
                if (usesGzip || !datalength) {
                  chunkSize = datalength = 1;
                  datalength = this.getter(0).length;
                  chunkSize = datalength;
                  out("LazyFiles on gzip forces download of the whole file when length is accessed");
                }
                this._length = datalength;
                this._chunkSize = chunkSize;
                this.lengthKnown = true;
              };
              if (typeof XMLHttpRequest != "undefined") {
                if (!ENVIRONMENT_IS_WORKER)
                  throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
                var lazyArray = new LazyUint8Array();
                Object.defineProperties(lazyArray, {
                  length: {
                    get: function() {
                      if (!this.lengthKnown) {
                        this.cacheLength();
                      }
                      return this._length;
                    }
                  },
                  chunkSize: {
                    get: function() {
                      if (!this.lengthKnown) {
                        this.cacheLength();
                      }
                      return this._chunkSize;
                    }
                  }
                });
                var properties = {
                  isDevice: false,
                  contents: lazyArray
                };
              } else {
                var properties = {
                  isDevice: false,
                  url: url2
                };
              }
              var node = FS.createFile(parent, name2, properties, canRead, canWrite);
              if (properties.contents) {
                node.contents = properties.contents;
              } else if (properties.url) {
                node.contents = null;
                node.url = properties.url;
              }
              Object.defineProperties(node, {
                usedBytes: {
                  get: function() {
                    return this.contents.length;
                  }
                }
              });
              var stream_ops = {};
              var keys = Object.keys(node.stream_ops);
              keys.forEach((key) => {
                var fn = node.stream_ops[key];
                stream_ops[key] = function forceLoadLazyFile() {
                  FS.forceLoadFile(node);
                  return fn.apply(null, arguments);
                };
              });
              function writeChunks(stream, buffer, offset, length, position) {
                var contents = stream.node.contents;
                if (position >= contents.length)
                  return 0;
                var size = Math.min(contents.length - position, length);
                if (contents.slice) {
                  for (var i2 = 0; i2 < size; i2++) {
                    buffer[offset + i2] = contents[position + i2];
                  }
                } else {
                  for (var i2 = 0; i2 < size; i2++) {
                    buffer[offset + i2] = contents.get(position + i2);
                  }
                }
                return size;
              }
              stream_ops.read = (stream, buffer, offset, length, position) => {
                FS.forceLoadFile(node);
                return writeChunks(stream, buffer, offset, length, position);
              };
              stream_ops.mmap = (stream, length, position, prot, flags2) => {
                FS.forceLoadFile(node);
                var ptr2 = mmapAlloc(length);
                if (!ptr2) {
                  throw new FS.ErrnoError(48);
                }
                writeChunks(stream, HEAP8, ptr2, length, position);
                return {
                  ptr: ptr2,
                  allocated: true
                };
              };
              node.stream_ops = stream_ops;
              return node;
            }
          };
          var SYSCALLS = {
            DEFAULT_POLLMASK: 5,
            calculateAt(dirfd, path, allowEmpty) {
              if (PATH.isAbs(path)) {
                return path;
              }
              var dir;
              if (dirfd === -100) {
                dir = FS.cwd();
              } else {
                var dirstream = SYSCALLS.getStreamFromFD(dirfd);
                dir = dirstream.path;
              }
              if (path.length == 0) {
                if (!allowEmpty) {
                  throw new FS.ErrnoError(44);
                }
                return dir;
              }
              return PATH.join2(dir, path);
            },
            doStat(func2, path, buf) {
              try {
                var stat = func2(path);
              } catch (e) {
                if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {
                  return -54;
                }
                throw e;
              }
              HEAP32[buf >>> 2 >>> 0] = stat.dev;
              HEAP32[buf + 4 >>> 2 >>> 0] = stat.mode;
              HEAPU32[buf + 8 >>> 2 >>> 0] = stat.nlink;
              HEAP32[buf + 12 >>> 2 >>> 0] = stat.uid;
              HEAP32[buf + 16 >>> 2 >>> 0] = stat.gid;
              HEAP32[buf + 20 >>> 2 >>> 0] = stat.rdev;
              tempI64 = [stat.size >>> 0, (tempDouble = stat.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 24 >>> 2 >>> 0] = tempI64[0], HEAP32[buf + 28 >>> 2 >>> 0] = tempI64[1];
              HEAP32[buf + 32 >>> 2 >>> 0] = 4096;
              HEAP32[buf + 36 >>> 2 >>> 0] = stat.blocks;
              var atime = stat.atime.getTime();
              var mtime = stat.mtime.getTime();
              var ctime = stat.ctime.getTime();
              tempI64 = [Math.floor(atime / 1e3) >>> 0, (tempDouble = Math.floor(atime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 40 >>> 2 >>> 0] = tempI64[0], HEAP32[buf + 44 >>> 2 >>> 0] = tempI64[1];
              HEAPU32[buf + 48 >>> 2 >>> 0] = atime % 1e3 * 1e3;
              tempI64 = [Math.floor(mtime / 1e3) >>> 0, (tempDouble = Math.floor(mtime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 56 >>> 2 >>> 0] = tempI64[0], HEAP32[buf + 60 >>> 2 >>> 0] = tempI64[1];
              HEAPU32[buf + 64 >>> 2 >>> 0] = mtime % 1e3 * 1e3;
              tempI64 = [Math.floor(ctime / 1e3) >>> 0, (tempDouble = Math.floor(ctime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 72 >>> 2 >>> 0] = tempI64[0], HEAP32[buf + 76 >>> 2 >>> 0] = tempI64[1];
              HEAPU32[buf + 80 >>> 2 >>> 0] = ctime % 1e3 * 1e3;
              tempI64 = [stat.ino >>> 0, (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 88 >>> 2 >>> 0] = tempI64[0], HEAP32[buf + 92 >>> 2 >>> 0] = tempI64[1];
              return 0;
            },
            doMsync(addr2, stream, len2, flags2, offset) {
              if (!FS.isFile(stream.node.mode)) {
                throw new FS.ErrnoError(43);
              }
              if (flags2 & 2) {
                return 0;
              }
              var buffer = HEAPU8.slice(addr2, addr2 + len2);
              FS.msync(stream, buffer, offset, len2, flags2);
            },
            varargs: void 0,
            get() {
              var ret = HEAP32[+SYSCALLS.varargs >>> 2 >>> 0];
              SYSCALLS.varargs += 4;
              return ret;
            },
            getp() {
              return SYSCALLS.get();
            },
            getStr(ptr2) {
              var ret = UTF8ToString(ptr2);
              return ret;
            },
            getStreamFromFD(fd) {
              var stream = FS.getStreamChecked(fd);
              return stream;
            }
          };
          function ___syscall__newselect(nfds, readfds, writefds, exceptfds, timeout) {
            readfds >>>= 0;
            writefds >>>= 0;
            exceptfds >>>= 0;
            timeout >>>= 0;
            try {
              var total = 0;
              var srcReadLow = readfds ? HEAP32[readfds >>> 2 >>> 0] : 0, srcReadHigh = readfds ? HEAP32[readfds + 4 >>> 2 >>> 0] : 0;
              var srcWriteLow = writefds ? HEAP32[writefds >>> 2 >>> 0] : 0, srcWriteHigh = writefds ? HEAP32[writefds + 4 >>> 2 >>> 0] : 0;
              var srcExceptLow = exceptfds ? HEAP32[exceptfds >>> 2 >>> 0] : 0, srcExceptHigh = exceptfds ? HEAP32[exceptfds + 4 >>> 2 >>> 0] : 0;
              var dstReadLow = 0, dstReadHigh = 0;
              var dstWriteLow = 0, dstWriteHigh = 0;
              var dstExceptLow = 0, dstExceptHigh = 0;
              var allLow = (readfds ? HEAP32[readfds >>> 2 >>> 0] : 0) | (writefds ? HEAP32[writefds >>> 2 >>> 0] : 0) | (exceptfds ? HEAP32[exceptfds >>> 2 >>> 0] : 0);
              var allHigh = (readfds ? HEAP32[readfds + 4 >>> 2 >>> 0] : 0) | (writefds ? HEAP32[writefds + 4 >>> 2 >>> 0] : 0) | (exceptfds ? HEAP32[exceptfds + 4 >>> 2 >>> 0] : 0);
              var check = function(fd2, low, high, val) {
                return fd2 < 32 ? low & val : high & val;
              };
              for (var fd = 0; fd < nfds; fd++) {
                var mask = 1 << fd % 32;
                if (!check(fd, allLow, allHigh, mask)) {
                  continue;
                }
                var stream = SYSCALLS.getStreamFromFD(fd);
                var flags2 = SYSCALLS.DEFAULT_POLLMASK;
                if (stream.stream_ops.poll) {
                  var timeoutInMillis = -1;
                  if (timeout) {
                    var tv_sec = readfds ? HEAP32[timeout >>> 2 >>> 0] : 0, tv_usec = readfds ? HEAP32[timeout + 4 >>> 2 >>> 0] : 0;
                    timeoutInMillis = (tv_sec + tv_usec / 1e6) * 1e3;
                  }
                  flags2 = stream.stream_ops.poll(stream, timeoutInMillis);
                }
                if (flags2 & 1 && check(fd, srcReadLow, srcReadHigh, mask)) {
                  fd < 32 ? dstReadLow = dstReadLow | mask : dstReadHigh = dstReadHigh | mask;
                  total++;
                }
                if (flags2 & 4 && check(fd, srcWriteLow, srcWriteHigh, mask)) {
                  fd < 32 ? dstWriteLow = dstWriteLow | mask : dstWriteHigh = dstWriteHigh | mask;
                  total++;
                }
                if (flags2 & 2 && check(fd, srcExceptLow, srcExceptHigh, mask)) {
                  fd < 32 ? dstExceptLow = dstExceptLow | mask : dstExceptHigh = dstExceptHigh | mask;
                  total++;
                }
              }
              if (readfds) {
                HEAP32[readfds >>> 2 >>> 0] = dstReadLow;
                HEAP32[readfds + 4 >>> 2 >>> 0] = dstReadHigh;
              }
              if (writefds) {
                HEAP32[writefds >>> 2 >>> 0] = dstWriteLow;
                HEAP32[writefds + 4 >>> 2 >>> 0] = dstWriteHigh;
              }
              if (exceptfds) {
                HEAP32[exceptfds >>> 2 >>> 0] = dstExceptLow;
                HEAP32[exceptfds + 4 >>> 2 >>> 0] = dstExceptHigh;
              }
              return total;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall__newselect.sig = "iipppp";
          var SOCKFS = {
            mount(mount) {
              Module["websocket"] = Module["websocket"] && "object" === typeof Module["websocket"] ? Module["websocket"] : {};
              Module["websocket"]._callbacks = {};
              Module["websocket"]["on"] = function(event2, callback) {
                if ("function" === typeof callback) {
                  this._callbacks[event2] = callback;
                }
                return this;
              };
              Module["websocket"].emit = function(event2, param) {
                if ("function" === typeof this._callbacks[event2]) {
                  this._callbacks[event2].call(this, param);
                }
              };
              return FS.createNode(null, "/", 16384 | 511, 0);
            },
            createSocket(family, type, protocol) {
              type &= ~526336;
              var streaming = type == 1;
              if (streaming && protocol && protocol != 6) {
                throw new FS.ErrnoError(66);
              }
              var sock = {
                family,
                type,
                protocol,
                server: null,
                error: null,
                peers: {},
                pending: [],
                recv_queue: [],
                sock_ops: SOCKFS.websocket_sock_ops
              };
              var name2 = SOCKFS.nextname();
              var node = FS.createNode(SOCKFS.root, name2, 49152, 0);
              node.sock = sock;
              var stream = FS.createStream({
                path: name2,
                node,
                flags: 2,
                seekable: false,
                stream_ops: SOCKFS.stream_ops
              });
              sock.stream = stream;
              return sock;
            },
            getSocket(fd) {
              var stream = FS.getStream(fd);
              if (!stream || !FS.isSocket(stream.node.mode)) {
                return null;
              }
              return stream.node.sock;
            },
            stream_ops: {
              poll(stream) {
                var sock = stream.node.sock;
                return sock.sock_ops.poll(sock);
              },
              ioctl(stream, request, varargs) {
                var sock = stream.node.sock;
                return sock.sock_ops.ioctl(sock, request, varargs);
              },
              read(stream, buffer, offset, length, position) {
                var sock = stream.node.sock;
                var msg = sock.sock_ops.recvmsg(sock, length);
                if (!msg) {
                  return 0;
                }
                buffer.set(msg.buffer, offset);
                return msg.buffer.length;
              },
              write(stream, buffer, offset, length, position) {
                var sock = stream.node.sock;
                return sock.sock_ops.sendmsg(sock, buffer, offset, length);
              },
              close(stream) {
                var sock = stream.node.sock;
                sock.sock_ops.close(sock);
              }
            },
            nextname() {
              if (!SOCKFS.nextname.current) {
                SOCKFS.nextname.current = 0;
              }
              return "socket[" + SOCKFS.nextname.current++ + "]";
            },
            websocket_sock_ops: {
              createPeer(sock, addr2, port) {
                var ws;
                if (typeof addr2 == "object") {
                  ws = addr2;
                  addr2 = null;
                  port = null;
                }
                if (ws) {
                  if (ws._socket) {
                    addr2 = ws._socket.remoteAddress;
                    port = ws._socket.remotePort;
                  } else {
                    var result = /ws[s]?:\/\/([^:]+):(\d+)/.exec(ws.url);
                    if (!result) {
                      throw new Error("WebSocket URL must be in the format ws(s)://address:port");
                    }
                    addr2 = result[1];
                    port = parseInt(result[2], 10);
                  }
                } else {
                  try {
                    var runtimeConfig = Module["websocket"] && "object" === typeof Module["websocket"];
                    var url2 = "ws:#".replace("#", "//");
                    if (runtimeConfig) {
                      if ("string" === typeof Module["websocket"]["url"]) {
                        url2 = Module["websocket"]["url"];
                      }
                    }
                    if (url2 === "ws://" || url2 === "wss://") {
                      var parts2 = addr2.split("/");
                      url2 = url2 + parts2[0] + ":" + port + "/" + parts2.slice(1).join("/");
                    }
                    var subProtocols = "binary";
                    if (runtimeConfig) {
                      if ("string" === typeof Module["websocket"]["subprotocol"]) {
                        subProtocols = Module["websocket"]["subprotocol"];
                      }
                    }
                    var opts = void 0;
                    if (subProtocols !== "null") {
                      subProtocols = subProtocols.replace(/^ +| +$/g, "").split(/ *, */);
                      opts = subProtocols;
                    }
                    if (runtimeConfig && null === Module["websocket"]["subprotocol"]) {
                      subProtocols = "null";
                      opts = void 0;
                    }
                    var WebSocketConstructor;
                    if (ENVIRONMENT_IS_NODE) {
                      WebSocketConstructor = require_browser();
                    } else {
                      WebSocketConstructor = WebSocket;
                    }
                    ws = new WebSocketConstructor(url2, opts);
                    ws.binaryType = "arraybuffer";
                  } catch (e) {
                    throw new FS.ErrnoError(23);
                  }
                }
                var peer = {
                  addr: addr2,
                  port,
                  socket: ws,
                  dgram_send_queue: []
                };
                SOCKFS.websocket_sock_ops.addPeer(sock, peer);
                SOCKFS.websocket_sock_ops.handlePeerEvents(sock, peer);
                if (sock.type === 2 && typeof sock.sport != "undefined") {
                  peer.dgram_send_queue.push(new Uint8Array([255, 255, 255, 255, "p".charCodeAt(0), "o".charCodeAt(0), "r".charCodeAt(0), "t".charCodeAt(0), (sock.sport & 65280) >> 8, sock.sport & 255]));
                }
                return peer;
              },
              getPeer(sock, addr2, port) {
                return sock.peers[addr2 + ":" + port];
              },
              addPeer(sock, peer) {
                sock.peers[peer.addr + ":" + peer.port] = peer;
              },
              removePeer(sock, peer) {
                delete sock.peers[peer.addr + ":" + peer.port];
              },
              handlePeerEvents(sock, peer) {
                var first = true;
                var handleOpen = function() {
                  Module["websocket"].emit("open", sock.stream.fd);
                  try {
                    var queued = peer.dgram_send_queue.shift();
                    while (queued) {
                      peer.socket.send(queued);
                      queued = peer.dgram_send_queue.shift();
                    }
                  } catch (e) {
                    peer.socket.close();
                  }
                };
                function handleMessage(data2) {
                  if (typeof data2 == "string") {
                    var encoder4 = new TextEncoder();
                    data2 = encoder4.encode(data2);
                  } else {
                    assert(data2.byteLength !== void 0);
                    if (data2.byteLength == 0) {
                      return;
                    }
                    data2 = new Uint8Array(data2);
                  }
                  var wasfirst = first;
                  first = false;
                  if (wasfirst && data2.length === 10 && data2[0] === 255 && data2[1] === 255 && data2[2] === 255 && data2[3] === 255 && data2[4] === "p".charCodeAt(0) && data2[5] === "o".charCodeAt(0) && data2[6] === "r".charCodeAt(0) && data2[7] === "t".charCodeAt(0)) {
                    var newport = data2[8] << 8 | data2[9];
                    SOCKFS.websocket_sock_ops.removePeer(sock, peer);
                    peer.port = newport;
                    SOCKFS.websocket_sock_ops.addPeer(sock, peer);
                    return;
                  }
                  sock.recv_queue.push({
                    addr: peer.addr,
                    port: peer.port,
                    data: data2
                  });
                  Module["websocket"].emit("message", sock.stream.fd);
                }
                if (ENVIRONMENT_IS_NODE) {
                  peer.socket.on("open", handleOpen);
                  peer.socket.on("message", function(data2, isBinary) {
                    if (!isBinary) {
                      return;
                    }
                    handleMessage(new Uint8Array(data2).buffer);
                  });
                  peer.socket.on("close", function() {
                    Module["websocket"].emit("close", sock.stream.fd);
                  });
                  peer.socket.on("error", function(error) {
                    sock.error = 14;
                    Module["websocket"].emit("error", [sock.stream.fd, sock.error, "ECONNREFUSED: Connection refused"]);
                  });
                } else {
                  peer.socket.onopen = handleOpen;
                  peer.socket.onclose = function() {
                    Module["websocket"].emit("close", sock.stream.fd);
                  };
                  peer.socket.onmessage = function peer_socket_onmessage(event2) {
                    handleMessage(event2.data);
                  };
                  peer.socket.onerror = function(error) {
                    sock.error = 14;
                    Module["websocket"].emit("error", [sock.stream.fd, sock.error, "ECONNREFUSED: Connection refused"]);
                  };
                }
              },
              poll(sock) {
                if (sock.type === 1 && sock.server) {
                  return sock.pending.length ? 64 | 1 : 0;
                }
                var mask = 0;
                var dest = sock.type === 1 ? SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport) : null;
                if (sock.recv_queue.length || !dest || dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
                  mask |= 64 | 1;
                }
                if (!dest || dest && dest.socket.readyState === dest.socket.OPEN) {
                  mask |= 4;
                }
                if (dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
                  mask |= 16;
                }
                return mask;
              },
              ioctl(sock, request, arg) {
                switch (request) {
                  case 21531:
                    var bytes = 0;
                    if (sock.recv_queue.length) {
                      bytes = sock.recv_queue[0].data.length;
                    }
                    HEAP32[arg >>> 2 >>> 0] = bytes;
                    return 0;
                  default:
                    return 28;
                }
              },
              close(sock) {
                if (sock.server) {
                  try {
                    sock.server.close();
                  } catch (e) {
                  }
                  sock.server = null;
                }
                var peers = Object.keys(sock.peers);
                for (var i2 = 0; i2 < peers.length; i2++) {
                  var peer = sock.peers[peers[i2]];
                  try {
                    peer.socket.close();
                  } catch (e) {
                  }
                  SOCKFS.websocket_sock_ops.removePeer(sock, peer);
                }
                return 0;
              },
              bind(sock, addr2, port) {
                if (typeof sock.saddr != "undefined" || typeof sock.sport != "undefined") {
                  throw new FS.ErrnoError(28);
                }
                sock.saddr = addr2;
                sock.sport = port;
                if (sock.type === 2) {
                  if (sock.server) {
                    sock.server.close();
                    sock.server = null;
                  }
                  try {
                    sock.sock_ops.listen(sock, 0);
                  } catch (e) {
                    if (!(e.name === "ErrnoError"))
                      throw e;
                    if (e.errno !== 138)
                      throw e;
                  }
                }
              },
              connect(sock, addr2, port) {
                if (sock.server) {
                  throw new FS.ErrnoError(138);
                }
                if (typeof sock.daddr != "undefined" && typeof sock.dport != "undefined") {
                  var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
                  if (dest) {
                    if (dest.socket.readyState === dest.socket.CONNECTING) {
                      throw new FS.ErrnoError(7);
                    } else {
                      throw new FS.ErrnoError(30);
                    }
                  }
                }
                var peer = SOCKFS.websocket_sock_ops.createPeer(sock, addr2, port);
                sock.daddr = peer.addr;
                sock.dport = peer.port;
                throw new FS.ErrnoError(26);
              },
              listen(sock, backlog) {
                if (!ENVIRONMENT_IS_NODE) {
                  throw new FS.ErrnoError(138);
                }
                if (sock.server) {
                  throw new FS.ErrnoError(28);
                }
                var WebSocketServer = require_browser().Server;
                var host = sock.saddr;
                sock.server = new WebSocketServer({
                  host,
                  port: sock.sport
                });
                Module["websocket"].emit("listen", sock.stream.fd);
                sock.server.on("connection", function(ws) {
                  if (sock.type === 1) {
                    var newsock = SOCKFS.createSocket(sock.family, sock.type, sock.protocol);
                    var peer = SOCKFS.websocket_sock_ops.createPeer(newsock, ws);
                    newsock.daddr = peer.addr;
                    newsock.dport = peer.port;
                    sock.pending.push(newsock);
                    Module["websocket"].emit("connection", newsock.stream.fd);
                  } else {
                    SOCKFS.websocket_sock_ops.createPeer(sock, ws);
                    Module["websocket"].emit("connection", sock.stream.fd);
                  }
                });
                sock.server.on("close", function() {
                  Module["websocket"].emit("close", sock.stream.fd);
                  sock.server = null;
                });
                sock.server.on("error", function(error) {
                  sock.error = 23;
                  Module["websocket"].emit("error", [sock.stream.fd, sock.error, "EHOSTUNREACH: Host is unreachable"]);
                });
              },
              accept(listensock) {
                if (!listensock.server || !listensock.pending.length) {
                  throw new FS.ErrnoError(28);
                }
                var newsock = listensock.pending.shift();
                newsock.stream.flags = listensock.stream.flags;
                return newsock;
              },
              getname(sock, peer) {
                var addr2, port;
                if (peer) {
                  if (sock.daddr === void 0 || sock.dport === void 0) {
                    throw new FS.ErrnoError(53);
                  }
                  addr2 = sock.daddr;
                  port = sock.dport;
                } else {
                  addr2 = sock.saddr || 0;
                  port = sock.sport || 0;
                }
                return {
                  addr: addr2,
                  port
                };
              },
              sendmsg(sock, buffer, offset, length, addr2, port) {
                if (sock.type === 2) {
                  if (addr2 === void 0 || port === void 0) {
                    addr2 = sock.daddr;
                    port = sock.dport;
                  }
                  if (addr2 === void 0 || port === void 0) {
                    throw new FS.ErrnoError(17);
                  }
                } else {
                  addr2 = sock.daddr;
                  port = sock.dport;
                }
                var dest = SOCKFS.websocket_sock_ops.getPeer(sock, addr2, port);
                if (sock.type === 1) {
                  if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
                    throw new FS.ErrnoError(53);
                  } else if (dest.socket.readyState === dest.socket.CONNECTING) {
                    throw new FS.ErrnoError(6);
                  }
                }
                if (ArrayBuffer.isView(buffer)) {
                  offset += buffer.byteOffset;
                  buffer = buffer.buffer;
                }
                var data2;
                data2 = buffer.slice(offset, offset + length);
                if (sock.type === 2) {
                  if (!dest || dest.socket.readyState !== dest.socket.OPEN) {
                    if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
                      dest = SOCKFS.websocket_sock_ops.createPeer(sock, addr2, port);
                    }
                    dest.dgram_send_queue.push(data2);
                    return length;
                  }
                }
                try {
                  dest.socket.send(data2);
                  return length;
                } catch (e) {
                  throw new FS.ErrnoError(28);
                }
              },
              recvmsg(sock, length) {
                if (sock.type === 1 && sock.server) {
                  throw new FS.ErrnoError(53);
                }
                var queued = sock.recv_queue.shift();
                if (!queued) {
                  if (sock.type === 1) {
                    var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
                    if (!dest) {
                      throw new FS.ErrnoError(53);
                    }
                    if (dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
                      return null;
                    }
                    throw new FS.ErrnoError(6);
                  }
                  throw new FS.ErrnoError(6);
                }
                var queuedLength = queued.data.byteLength || queued.data.length;
                var queuedOffset = queued.data.byteOffset || 0;
                var queuedBuffer = queued.data.buffer || queued.data;
                var bytesRead = Math.min(length, queuedLength);
                var res = {
                  buffer: new Uint8Array(queuedBuffer, queuedOffset, bytesRead),
                  addr: queued.addr,
                  port: queued.port
                };
                if (sock.type === 1 && bytesRead < queuedLength) {
                  var bytesRemaining = queuedLength - bytesRead;
                  queued.data = new Uint8Array(queuedBuffer, queuedOffset + bytesRead, bytesRemaining);
                  sock.recv_queue.unshift(queued);
                }
                return res;
              }
            }
          };
          var getSocketFromFD = (fd) => {
            var socket = SOCKFS.getSocket(fd);
            if (!socket)
              throw new FS.ErrnoError(8);
            return socket;
          };
          var Sockets = {
            BUFFER_SIZE: 10240,
            MAX_BUFFER_SIZE: 10485760,
            nextFd: 1,
            fds: {},
            nextport: 1,
            maxport: 65535,
            peer: null,
            connections: {},
            portmap: {},
            localAddr: 4261412874,
            addrPool: [33554442, 50331658, 67108874, 83886090, 100663306, 117440522, 134217738, 150994954, 167772170, 184549386, 201326602, 218103818, 234881034]
          };
          var inetPton4 = (str) => {
            var b = str.split(".");
            for (var i2 = 0; i2 < 4; i2++) {
              var tmp2 = Number(b[i2]);
              if (isNaN(tmp2))
                return null;
              b[i2] = tmp2;
            }
            return (b[0] | b[1] << 8 | b[2] << 16 | b[3] << 24) >>> 0;
          };
          var jstoi_q = (str) => parseInt(str);
          var inetPton6 = (str) => {
            var words;
            var w, offset, z, i2;
            var valid6regx = /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i;
            var parts2 = [];
            if (!valid6regx.test(str)) {
              return null;
            }
            if (str === "::") {
              return [0, 0, 0, 0, 0, 0, 0, 0];
            }
            if (str.startsWith("::")) {
              str = str.replace("::", "Z:");
            } else {
              str = str.replace("::", ":Z:");
            }
            if (str.indexOf(".") > 0) {
              str = str.replace(new RegExp("[.]", "g"), ":");
              words = str.split(":");
              words[words.length - 4] = jstoi_q(words[words.length - 4]) + jstoi_q(words[words.length - 3]) * 256;
              words[words.length - 3] = jstoi_q(words[words.length - 2]) + jstoi_q(words[words.length - 1]) * 256;
              words = words.slice(0, words.length - 2);
            } else {
              words = str.split(":");
            }
            offset = 0;
            z = 0;
            for (w = 0; w < words.length; w++) {
              if (typeof words[w] == "string") {
                if (words[w] === "Z") {
                  for (z = 0; z < 8 - words.length + 1; z++) {
                    parts2[w + z] = 0;
                  }
                  offset = z - 1;
                } else {
                  parts2[w + offset] = _htons(parseInt(words[w], 16));
                }
              } else {
                parts2[w + offset] = words[w];
              }
            }
            return [parts2[1] << 16 | parts2[0], parts2[3] << 16 | parts2[2], parts2[5] << 16 | parts2[4], parts2[7] << 16 | parts2[6]];
          };
          var writeSockaddr = (sa, family, addr2, port, addrlen) => {
            switch (family) {
              case 2:
                addr2 = inetPton4(addr2);
                zeroMemory(sa, 16);
                if (addrlen) {
                  HEAP32[addrlen >>> 2 >>> 0] = 16;
                }
                HEAP16[sa >>> 1 >>> 0] = family;
                HEAP32[sa + 4 >>> 2 >>> 0] = addr2;
                HEAP16[sa + 2 >>> 1 >>> 0] = _htons(port);
                break;
              case 10:
                addr2 = inetPton6(addr2);
                zeroMemory(sa, 28);
                if (addrlen) {
                  HEAP32[addrlen >>> 2 >>> 0] = 28;
                }
                HEAP32[sa >>> 2 >>> 0] = family;
                HEAP32[sa + 8 >>> 2 >>> 0] = addr2[0];
                HEAP32[sa + 12 >>> 2 >>> 0] = addr2[1];
                HEAP32[sa + 16 >>> 2 >>> 0] = addr2[2];
                HEAP32[sa + 20 >>> 2 >>> 0] = addr2[3];
                HEAP16[sa + 2 >>> 1 >>> 0] = _htons(port);
                break;
              default:
                return 5;
            }
            return 0;
          };
          var DNS = {
            address_map: {
              id: 1,
              addrs: {},
              names: {}
            },
            lookup_name(name2) {
              var res = inetPton4(name2);
              if (res !== null) {
                return name2;
              }
              res = inetPton6(name2);
              if (res !== null) {
                return name2;
              }
              var addr2;
              if (DNS.address_map.addrs[name2]) {
                addr2 = DNS.address_map.addrs[name2];
              } else {
                var id = DNS.address_map.id++;
                assert(id < 65535, "exceeded max address mappings of 65535");
                addr2 = "172.29." + (id & 255) + "." + (id & 65280);
                DNS.address_map.names[addr2] = name2;
                DNS.address_map.addrs[name2] = addr2;
              }
              return addr2;
            },
            lookup_addr(addr2) {
              if (DNS.address_map.names[addr2]) {
                return DNS.address_map.names[addr2];
              }
              return null;
            }
          };
          function ___syscall_accept4(fd, addr2, addrlen, flags2, d1, d2) {
            addr2 >>>= 0;
            addrlen >>>= 0;
            try {
              var sock = getSocketFromFD(fd);
              var newsock = sock.sock_ops.accept(sock);
              if (addr2) {
                var errno = writeSockaddr(addr2, newsock.family, DNS.lookup_name(newsock.daddr), newsock.dport, addrlen);
              }
              return newsock.stream.fd;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_accept4.sig = "iippiii";
          var inetNtop4 = (addr2) => (addr2 & 255) + "." + (addr2 >> 8 & 255) + "." + (addr2 >> 16 & 255) + "." + (addr2 >> 24 & 255);
          var inetNtop6 = (ints) => {
            var str = "";
            var word = 0;
            var longest = 0;
            var lastzero = 0;
            var zstart = 0;
            var len2 = 0;
            var i2 = 0;
            var parts2 = [ints[0] & 65535, ints[0] >> 16, ints[1] & 65535, ints[1] >> 16, ints[2] & 65535, ints[2] >> 16, ints[3] & 65535, ints[3] >> 16];
            var hasipv4 = true;
            var v4part = "";
            for (i2 = 0; i2 < 5; i2++) {
              if (parts2[i2] !== 0) {
                hasipv4 = false;
                break;
              }
            }
            if (hasipv4) {
              v4part = inetNtop4(parts2[6] | parts2[7] << 16);
              if (parts2[5] === -1) {
                str = "::ffff:";
                str += v4part;
                return str;
              }
              if (parts2[5] === 0) {
                str = "::";
                if (v4part === "0.0.0.0")
                  v4part = "";
                if (v4part === "0.0.0.1")
                  v4part = "1";
                str += v4part;
                return str;
              }
            }
            for (word = 0; word < 8; word++) {
              if (parts2[word] === 0) {
                if (word - lastzero > 1) {
                  len2 = 0;
                }
                lastzero = word;
                len2++;
              }
              if (len2 > longest) {
                longest = len2;
                zstart = word - longest + 1;
              }
            }
            for (word = 0; word < 8; word++) {
              if (longest > 1) {
                if (parts2[word] === 0 && word >= zstart && word < zstart + longest) {
                  if (word === zstart) {
                    str += ":";
                    if (zstart === 0)
                      str += ":";
                  }
                  continue;
                }
              }
              str += Number(_ntohs(parts2[word] & 65535)).toString(16);
              str += word < 7 ? ":" : "";
            }
            return str;
          };
          var readSockaddr = (sa, salen) => {
            var family = HEAP16[sa >>> 1 >>> 0];
            var port = _ntohs(HEAPU16[sa + 2 >>> 1 >>> 0]);
            var addr2;
            switch (family) {
              case 2:
                if (salen !== 16) {
                  return {
                    errno: 28
                  };
                }
                addr2 = HEAP32[sa + 4 >>> 2 >>> 0];
                addr2 = inetNtop4(addr2);
                break;
              case 10:
                if (salen !== 28) {
                  return {
                    errno: 28
                  };
                }
                addr2 = [HEAP32[sa + 8 >>> 2 >>> 0], HEAP32[sa + 12 >>> 2 >>> 0], HEAP32[sa + 16 >>> 2 >>> 0], HEAP32[sa + 20 >>> 2 >>> 0]];
                addr2 = inetNtop6(addr2);
                break;
              default:
                return {
                  errno: 5
                };
            }
            return {
              family,
              addr: addr2,
              port
            };
          };
          var getSocketAddress = (addrp, addrlen, allowNull) => {
            if (allowNull && addrp === 0)
              return null;
            var info2 = readSockaddr(addrp, addrlen);
            if (info2.errno)
              throw new FS.ErrnoError(info2.errno);
            info2.addr = DNS.lookup_addr(info2.addr) || info2.addr;
            return info2;
          };
          function ___syscall_bind(fd, addr2, addrlen, d1, d2, d3) {
            addr2 >>>= 0;
            addrlen >>>= 0;
            try {
              var sock = getSocketFromFD(fd);
              var info2 = getSocketAddress(addr2, addrlen);
              sock.sock_ops.bind(sock, info2.addr, info2.port);
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_bind.sig = "iippiii";
          function ___syscall_chdir(path) {
            path >>>= 0;
            try {
              path = SYSCALLS.getStr(path);
              FS.chdir(path);
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_chdir.sig = "ip";
          function ___syscall_chmod(path, mode) {
            path >>>= 0;
            try {
              path = SYSCALLS.getStr(path);
              FS.chmod(path, mode);
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_chmod.sig = "ipi";
          function ___syscall_connect(fd, addr2, addrlen, d1, d2, d3) {
            addr2 >>>= 0;
            addrlen >>>= 0;
            try {
              var sock = getSocketFromFD(fd);
              var info2 = getSocketAddress(addr2, addrlen);
              sock.sock_ops.connect(sock, info2.addr, info2.port);
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_connect.sig = "iippiii";
          function ___syscall_dup(fd) {
            try {
              var old = SYSCALLS.getStreamFromFD(fd);
              return FS.createStream(old).fd;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_dup.sig = "ii";
          function ___syscall_dup3(fd, newfd, flags2) {
            try {
              var old = SYSCALLS.getStreamFromFD(fd);
              if (old.fd === newfd)
                return -28;
              var existing = FS.getStream(newfd);
              if (existing)
                FS.close(existing);
              return FS.createStream(old, newfd).fd;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_dup3.sig = "iiii";
          function ___syscall_faccessat(dirfd, path, amode, flags2) {
            path >>>= 0;
            try {
              path = SYSCALLS.getStr(path);
              path = SYSCALLS.calculateAt(dirfd, path);
              if (amode & ~7) {
                return -28;
              }
              var lookup = FS.lookupPath(path, {
                follow: true
              });
              var node = lookup.node;
              if (!node) {
                return -44;
              }
              var perms = "";
              if (amode & 4)
                perms += "r";
              if (amode & 2)
                perms += "w";
              if (amode & 1)
                perms += "x";
              if (perms && FS.nodePermissions(node, perms)) {
                return -2;
              }
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_faccessat.sig = "iipii";
          var ___syscall_fadvise64 = (fd, offset, len2, advice) => 0;
          ___syscall_fadvise64.sig = "iiiiiii";
          function ___syscall_fallocate(fd, mode, offset_low, offset_high, len_low, len_high) {
            var offset = convertI32PairToI53Checked(offset_low, offset_high);
            var len2 = convertI32PairToI53Checked(len_low, len_high);
            try {
              if (isNaN(offset))
                return 61;
              var stream = SYSCALLS.getStreamFromFD(fd);
              FS.allocate(stream, offset, len2);
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_fallocate.sig = "iiiiiii";
          function ___syscall_fchdir(fd) {
            try {
              var stream = SYSCALLS.getStreamFromFD(fd);
              FS.chdir(stream.path);
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_fchdir.sig = "ii";
          function ___syscall_fchmod(fd, mode) {
            try {
              FS.fchmod(fd, mode);
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_fchmod.sig = "iii";
          function ___syscall_fchmodat(dirfd, path, mode, varargs) {
            path >>>= 0;
            varargs >>>= 0;
            SYSCALLS.varargs = varargs;
            try {
              path = SYSCALLS.getStr(path);
              path = SYSCALLS.calculateAt(dirfd, path);
              FS.chmod(path, mode);
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_fchmodat.sig = "iipip";
          function ___syscall_fchown32(fd, owner, group) {
            try {
              FS.fchown(fd, owner, group);
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_fchown32.sig = "iiii";
          function ___syscall_fchownat(dirfd, path, owner, group, flags2) {
            path >>>= 0;
            try {
              path = SYSCALLS.getStr(path);
              var nofollow = flags2 & 256;
              flags2 = flags2 & ~256;
              path = SYSCALLS.calculateAt(dirfd, path);
              (nofollow ? FS.lchown : FS.chown)(path, owner, group);
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_fchownat.sig = "iipiii";
          function ___syscall_fcntl64(fd, cmd, varargs) {
            varargs >>>= 0;
            SYSCALLS.varargs = varargs;
            try {
              var stream = SYSCALLS.getStreamFromFD(fd);
              switch (cmd) {
                case 0: {
                  var arg = SYSCALLS.get();
                  if (arg < 0) {
                    return -28;
                  }
                  while (FS.streams[arg]) {
                    arg++;
                  }
                  var newStream;
                  newStream = FS.createStream(stream, arg);
                  return newStream.fd;
                }
                case 1:
                case 2:
                  return 0;
                case 3:
                  return stream.flags;
                case 4: {
                  var arg = SYSCALLS.get();
                  stream.flags |= arg;
                  return 0;
                }
                case 12: {
                  var arg = SYSCALLS.getp();
                  var offset = 0;
                  HEAP16[arg + offset >>> 1 >>> 0] = 2;
                  return 0;
                }
                case 13:
                case 14:
                  return 0;
              }
              return -28;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_fcntl64.sig = "iiip";
          function ___syscall_fdatasync(fd) {
            try {
              var stream = SYSCALLS.getStreamFromFD(fd);
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_fdatasync.sig = "ii";
          function ___syscall_fstat64(fd, buf) {
            buf >>>= 0;
            try {
              var stream = SYSCALLS.getStreamFromFD(fd);
              return SYSCALLS.doStat(FS.stat, stream.path, buf);
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_fstat64.sig = "iip";
          function ___syscall_statfs64(path, size, buf) {
            path >>>= 0;
            size >>>= 0;
            buf >>>= 0;
            try {
              path = SYSCALLS.getStr(path);
              HEAP32[buf + 4 >>> 2 >>> 0] = 4096;
              HEAP32[buf + 40 >>> 2 >>> 0] = 4096;
              HEAP32[buf + 8 >>> 2 >>> 0] = 1e6;
              HEAP32[buf + 12 >>> 2 >>> 0] = 5e5;
              HEAP32[buf + 16 >>> 2 >>> 0] = 5e5;
              HEAP32[buf + 20 >>> 2 >>> 0] = FS.nextInode;
              HEAP32[buf + 24 >>> 2 >>> 0] = 1e6;
              HEAP32[buf + 28 >>> 2 >>> 0] = 42;
              HEAP32[buf + 44 >>> 2 >>> 0] = 2;
              HEAP32[buf + 36 >>> 2 >>> 0] = 255;
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_statfs64.sig = "ippp";
          function ___syscall_fstatfs64(fd, size, buf) {
            size >>>= 0;
            buf >>>= 0;
            try {
              var stream = SYSCALLS.getStreamFromFD(fd);
              return ___syscall_statfs64(0, size, buf);
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_fstatfs64.sig = "iipp";
          function ___syscall_ftruncate64(fd, length_low, length_high) {
            var length = convertI32PairToI53Checked(length_low, length_high);
            try {
              if (isNaN(length))
                return 61;
              FS.ftruncate(fd, length);
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_ftruncate64.sig = "iiii";
          var stringToUTF8 = (str, outPtr, maxBytesToWrite) => stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
          function ___syscall_getcwd(buf, size) {
            buf >>>= 0;
            size >>>= 0;
            try {
              if (size === 0)
                return -28;
              var cwd = FS.cwd();
              var cwdLengthInBytes = lengthBytesUTF8(cwd) + 1;
              if (size < cwdLengthInBytes)
                return -68;
              stringToUTF8(cwd, buf, size);
              return cwdLengthInBytes;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_getcwd.sig = "ipp";
          function ___syscall_getdents64(fd, dirp, count) {
            dirp >>>= 0;
            count >>>= 0;
            try {
              var stream = SYSCALLS.getStreamFromFD(fd);
              stream.getdents || (stream.getdents = FS.readdir(stream.path));
              var struct_size = 280;
              var pos = 0;
              var off = FS.llseek(stream, 0, 1);
              var idx = Math.floor(off / struct_size);
              while (idx < stream.getdents.length && pos + struct_size <= count) {
                var id;
                var type;
                var name2 = stream.getdents[idx];
                if (name2 === ".") {
                  id = stream.node.id;
                  type = 4;
                } else if (name2 === "..") {
                  var lookup = FS.lookupPath(stream.path, {
                    parent: true
                  });
                  id = lookup.node.id;
                  type = 4;
                } else {
                  var child = FS.lookupNode(stream.node, name2);
                  id = child.id;
                  type = FS.isChrdev(child.mode) ? 2 : FS.isDir(child.mode) ? 4 : FS.isLink(child.mode) ? 10 : 8;
                }
                tempI64 = [id >>> 0, (tempDouble = id, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[dirp + pos >>> 2 >>> 0] = tempI64[0], HEAP32[dirp + pos + 4 >>> 2 >>> 0] = tempI64[1];
                tempI64 = [(idx + 1) * struct_size >>> 0, (tempDouble = (idx + 1) * struct_size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[dirp + pos + 8 >>> 2 >>> 0] = tempI64[0], HEAP32[dirp + pos + 12 >>> 2 >>> 0] = tempI64[1];
                HEAP16[dirp + pos + 16 >>> 1 >>> 0] = 280;
                HEAP8[dirp + pos + 18 >>> 0 >>> 0] = type;
                stringToUTF8(name2, dirp + pos + 19, 256);
                pos += struct_size;
                idx += 1;
              }
              FS.llseek(stream, idx * struct_size, 0);
              return pos;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_getdents64.sig = "iipp";
          function ___syscall_getpeername(fd, addr2, addrlen, d1, d2, d3) {
            addr2 >>>= 0;
            addrlen >>>= 0;
            try {
              var sock = getSocketFromFD(fd);
              if (!sock.daddr) {
                return -53;
              }
              var errno = writeSockaddr(addr2, sock.family, DNS.lookup_name(sock.daddr), sock.dport, addrlen);
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_getpeername.sig = "iippiii";
          function ___syscall_getsockname(fd, addr2, addrlen, d1, d2, d3) {
            addr2 >>>= 0;
            addrlen >>>= 0;
            try {
              var sock = getSocketFromFD(fd);
              var errno = writeSockaddr(addr2, sock.family, DNS.lookup_name(sock.saddr || "0.0.0.0"), sock.sport, addrlen);
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_getsockname.sig = "iippiii";
          function ___syscall_getsockopt(fd, level, optname, optval, optlen, d1) {
            optval >>>= 0;
            optlen >>>= 0;
            try {
              var sock = getSocketFromFD(fd);
              if (level === 1) {
                if (optname === 4) {
                  HEAP32[optval >>> 2 >>> 0] = sock.error;
                  HEAP32[optlen >>> 2 >>> 0] = 4;
                  sock.error = null;
                  return 0;
                }
              }
              return -50;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_getsockopt.sig = "iiiippi";
          function ___syscall_ioctl(fd, op, varargs) {
            varargs >>>= 0;
            SYSCALLS.varargs = varargs;
            try {
              var stream = SYSCALLS.getStreamFromFD(fd);
              switch (op) {
                case 21509: {
                  if (!stream.tty)
                    return -59;
                  return 0;
                }
                case 21505: {
                  if (!stream.tty)
                    return -59;
                  if (stream.tty.ops.ioctl_tcgets) {
                    var termios = stream.tty.ops.ioctl_tcgets(stream);
                    var argp = SYSCALLS.getp();
                    HEAP32[argp >>> 2 >>> 0] = termios.c_iflag || 0;
                    HEAP32[argp + 4 >>> 2 >>> 0] = termios.c_oflag || 0;
                    HEAP32[argp + 8 >>> 2 >>> 0] = termios.c_cflag || 0;
                    HEAP32[argp + 12 >>> 2 >>> 0] = termios.c_lflag || 0;
                    for (var i2 = 0; i2 < 32; i2++) {
                      HEAP8[argp + i2 + 17 >>> 0 >>> 0] = termios.c_cc[i2] || 0;
                    }
                    return 0;
                  }
                  return 0;
                }
                case 21510:
                case 21511:
                case 21512: {
                  if (!stream.tty)
                    return -59;
                  return 0;
                }
                case 21506:
                case 21507:
                case 21508: {
                  if (!stream.tty)
                    return -59;
                  if (stream.tty.ops.ioctl_tcsets) {
                    var argp = SYSCALLS.getp();
                    var c_iflag = HEAP32[argp >>> 2 >>> 0];
                    var c_oflag = HEAP32[argp + 4 >>> 2 >>> 0];
                    var c_cflag = HEAP32[argp + 8 >>> 2 >>> 0];
                    var c_lflag = HEAP32[argp + 12 >>> 2 >>> 0];
                    var c_cc = [];
                    for (var i2 = 0; i2 < 32; i2++) {
                      c_cc.push(HEAP8[argp + i2 + 17 >>> 0 >>> 0]);
                    }
                    return stream.tty.ops.ioctl_tcsets(stream.tty, op, {
                      c_iflag,
                      c_oflag,
                      c_cflag,
                      c_lflag,
                      c_cc
                    });
                  }
                  return 0;
                }
                case 21519: {
                  if (!stream.tty)
                    return -59;
                  var argp = SYSCALLS.getp();
                  HEAP32[argp >>> 2 >>> 0] = 0;
                  return 0;
                }
                case 21520: {
                  if (!stream.tty)
                    return -59;
                  return -28;
                }
                case 21531: {
                  var argp = SYSCALLS.getp();
                  return FS.ioctl(stream, op, argp);
                }
                case 21523: {
                  if (!stream.tty)
                    return -59;
                  if (stream.tty.ops.ioctl_tiocgwinsz) {
                    var winsize = stream.tty.ops.ioctl_tiocgwinsz(stream.tty);
                    var argp = SYSCALLS.getp();
                    HEAP16[argp >>> 1 >>> 0] = winsize[0];
                    HEAP16[argp + 2 >>> 1 >>> 0] = winsize[1];
                  }
                  return 0;
                }
                case 21524: {
                  if (!stream.tty)
                    return -59;
                  return 0;
                }
                case 21515: {
                  if (!stream.tty)
                    return -59;
                  return 0;
                }
                default:
                  return -28;
              }
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_ioctl.sig = "iiip";
          function ___syscall_listen(fd, backlog) {
            try {
              var sock = getSocketFromFD(fd);
              sock.sock_ops.listen(sock, backlog);
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_listen.sig = "iiiiiii";
          function ___syscall_lstat64(path, buf) {
            path >>>= 0;
            buf >>>= 0;
            try {
              path = SYSCALLS.getStr(path);
              return SYSCALLS.doStat(FS.lstat, path, buf);
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_lstat64.sig = "ipp";
          function ___syscall_mkdirat(dirfd, path, mode) {
            path >>>= 0;
            try {
              path = SYSCALLS.getStr(path);
              path = SYSCALLS.calculateAt(dirfd, path);
              path = PATH.normalize(path);
              if (path[path.length - 1] === "/")
                path = path.substr(0, path.length - 1);
              FS.mkdir(path, mode, 0);
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_mkdirat.sig = "iipi";
          function ___syscall_mknodat(dirfd, path, mode, dev) {
            path >>>= 0;
            try {
              path = SYSCALLS.getStr(path);
              path = SYSCALLS.calculateAt(dirfd, path);
              switch (mode & 61440) {
                case 32768:
                case 8192:
                case 24576:
                case 4096:
                case 49152:
                  break;
                default:
                  return -28;
              }
              FS.mknod(path, mode, dev);
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_mknodat.sig = "iipii";
          function ___syscall_newfstatat(dirfd, path, buf, flags2) {
            path >>>= 0;
            buf >>>= 0;
            try {
              path = SYSCALLS.getStr(path);
              var nofollow = flags2 & 256;
              var allowEmpty = flags2 & 4096;
              flags2 = flags2 & ~6400;
              path = SYSCALLS.calculateAt(dirfd, path, allowEmpty);
              return SYSCALLS.doStat(nofollow ? FS.lstat : FS.stat, path, buf);
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_newfstatat.sig = "iippi";
          function ___syscall_openat(dirfd, path, flags2, varargs) {
            path >>>= 0;
            varargs >>>= 0;
            SYSCALLS.varargs = varargs;
            try {
              path = SYSCALLS.getStr(path);
              path = SYSCALLS.calculateAt(dirfd, path);
              var mode = varargs ? SYSCALLS.get() : 0;
              return FS.open(path, flags2, mode).fd;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_openat.sig = "iipip";
          var PIPEFS = {
            BUCKET_BUFFER_SIZE: 8192,
            mount(mount) {
              return FS.createNode(null, "/", 16384 | 511, 0);
            },
            createPipe() {
              var pipe = {
                buckets: [],
                refcnt: 2
              };
              pipe.buckets.push({
                buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
                offset: 0,
                roffset: 0
              });
              var rName = PIPEFS.nextname();
              var wName = PIPEFS.nextname();
              var rNode = FS.createNode(PIPEFS.root, rName, 4096, 0);
              var wNode = FS.createNode(PIPEFS.root, wName, 4096, 0);
              rNode.pipe = pipe;
              wNode.pipe = pipe;
              var readableStream = FS.createStream({
                path: rName,
                node: rNode,
                flags: 0,
                seekable: false,
                stream_ops: PIPEFS.stream_ops
              });
              rNode.stream = readableStream;
              var writableStream = FS.createStream({
                path: wName,
                node: wNode,
                flags: 1,
                seekable: false,
                stream_ops: PIPEFS.stream_ops
              });
              wNode.stream = writableStream;
              return {
                readable_fd: readableStream.fd,
                writable_fd: writableStream.fd
              };
            },
            stream_ops: {
              poll(stream) {
                var pipe = stream.node.pipe;
                if ((stream.flags & 2097155) === 1) {
                  return 256 | 4;
                }
                if (pipe.buckets.length > 0) {
                  for (var i2 = 0; i2 < pipe.buckets.length; i2++) {
                    var bucket = pipe.buckets[i2];
                    if (bucket.offset - bucket.roffset > 0) {
                      return 64 | 1;
                    }
                  }
                }
                return 0;
              },
              ioctl(stream, request, varargs) {
                return 28;
              },
              fsync(stream) {
                return 28;
              },
              read(stream, buffer, offset, length, position) {
                var pipe = stream.node.pipe;
                var currentLength = 0;
                for (var i2 = 0; i2 < pipe.buckets.length; i2++) {
                  var bucket = pipe.buckets[i2];
                  currentLength += bucket.offset - bucket.roffset;
                }
                var data2 = buffer.subarray(offset, offset + length);
                if (length <= 0) {
                  return 0;
                }
                if (currentLength == 0) {
                  throw new FS.ErrnoError(6);
                }
                var toRead = Math.min(currentLength, length);
                var totalRead = toRead;
                var toRemove = 0;
                for (var i2 = 0; i2 < pipe.buckets.length; i2++) {
                  var currBucket = pipe.buckets[i2];
                  var bucketSize = currBucket.offset - currBucket.roffset;
                  if (toRead <= bucketSize) {
                    var tmpSlice = currBucket.buffer.subarray(currBucket.roffset, currBucket.offset);
                    if (toRead < bucketSize) {
                      tmpSlice = tmpSlice.subarray(0, toRead);
                      currBucket.roffset += toRead;
                    } else {
                      toRemove++;
                    }
                    data2.set(tmpSlice);
                    break;
                  } else {
                    var tmpSlice = currBucket.buffer.subarray(currBucket.roffset, currBucket.offset);
                    data2.set(tmpSlice);
                    data2 = data2.subarray(tmpSlice.byteLength);
                    toRead -= tmpSlice.byteLength;
                    toRemove++;
                  }
                }
                if (toRemove && toRemove == pipe.buckets.length) {
                  toRemove--;
                  pipe.buckets[toRemove].offset = 0;
                  pipe.buckets[toRemove].roffset = 0;
                }
                pipe.buckets.splice(0, toRemove);
                return totalRead;
              },
              write(stream, buffer, offset, length, position) {
                var pipe = stream.node.pipe;
                var data2 = buffer.subarray(offset, offset + length);
                var dataLen = data2.byteLength;
                if (dataLen <= 0) {
                  return 0;
                }
                var currBucket = null;
                if (pipe.buckets.length == 0) {
                  currBucket = {
                    buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
                    offset: 0,
                    roffset: 0
                  };
                  pipe.buckets.push(currBucket);
                } else {
                  currBucket = pipe.buckets[pipe.buckets.length - 1];
                }
                assert(currBucket.offset <= PIPEFS.BUCKET_BUFFER_SIZE);
                var freeBytesInCurrBuffer = PIPEFS.BUCKET_BUFFER_SIZE - currBucket.offset;
                if (freeBytesInCurrBuffer >= dataLen) {
                  currBucket.buffer.set(data2, currBucket.offset);
                  currBucket.offset += dataLen;
                  return dataLen;
                } else if (freeBytesInCurrBuffer > 0) {
                  currBucket.buffer.set(data2.subarray(0, freeBytesInCurrBuffer), currBucket.offset);
                  currBucket.offset += freeBytesInCurrBuffer;
                  data2 = data2.subarray(freeBytesInCurrBuffer, data2.byteLength);
                }
                var numBuckets = data2.byteLength / PIPEFS.BUCKET_BUFFER_SIZE | 0;
                var remElements = data2.byteLength % PIPEFS.BUCKET_BUFFER_SIZE;
                for (var i2 = 0; i2 < numBuckets; i2++) {
                  var newBucket = {
                    buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
                    offset: PIPEFS.BUCKET_BUFFER_SIZE,
                    roffset: 0
                  };
                  pipe.buckets.push(newBucket);
                  newBucket.buffer.set(data2.subarray(0, PIPEFS.BUCKET_BUFFER_SIZE));
                  data2 = data2.subarray(PIPEFS.BUCKET_BUFFER_SIZE, data2.byteLength);
                }
                if (remElements > 0) {
                  var newBucket = {
                    buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
                    offset: data2.byteLength,
                    roffset: 0
                  };
                  pipe.buckets.push(newBucket);
                  newBucket.buffer.set(data2);
                }
                return dataLen;
              },
              close(stream) {
                var pipe = stream.node.pipe;
                pipe.refcnt--;
                if (pipe.refcnt === 0) {
                  pipe.buckets = null;
                }
              }
            },
            nextname() {
              if (!PIPEFS.nextname.current) {
                PIPEFS.nextname.current = 0;
              }
              return "pipe[" + PIPEFS.nextname.current++ + "]";
            }
          };
          function ___syscall_pipe(fdPtr) {
            fdPtr >>>= 0;
            try {
              if (fdPtr == 0) {
                throw new FS.ErrnoError(21);
              }
              var res = PIPEFS.createPipe();
              HEAP32[fdPtr >>> 2 >>> 0] = res.readable_fd;
              HEAP32[fdPtr + 4 >>> 2 >>> 0] = res.writable_fd;
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_pipe.sig = "ip";
          function ___syscall_poll(fds, nfds, timeout) {
            fds >>>= 0;
            try {
              var nonzero = 0;
              for (var i2 = 0; i2 < nfds; i2++) {
                var pollfd = fds + 8 * i2;
                var fd = HEAP32[pollfd >>> 2 >>> 0];
                var events = HEAP16[pollfd + 4 >>> 1 >>> 0];
                var mask = 32;
                var stream = FS.getStream(fd);
                if (stream) {
                  mask = SYSCALLS.DEFAULT_POLLMASK;
                  if (stream.stream_ops.poll) {
                    mask = stream.stream_ops.poll(stream, -1);
                  }
                }
                mask &= events | 8 | 16;
                if (mask)
                  nonzero++;
                HEAP16[pollfd + 6 >>> 1 >>> 0] = mask;
              }
              return nonzero;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_poll.sig = "ipii";
          function ___syscall_readlinkat(dirfd, path, buf, bufsize) {
            path >>>= 0;
            buf >>>= 0;
            bufsize >>>= 0;
            try {
              path = SYSCALLS.getStr(path);
              path = SYSCALLS.calculateAt(dirfd, path);
              if (bufsize <= 0)
                return -28;
              var ret = FS.readlink(path);
              var len2 = Math.min(bufsize, lengthBytesUTF8(ret));
              var endChar = HEAP8[buf + len2 >>> 0];
              stringToUTF8(ret, buf, bufsize + 1);
              HEAP8[buf + len2 >>> 0] = endChar;
              return len2;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_readlinkat.sig = "iippp";
          function ___syscall_recvfrom(fd, buf, len2, flags2, addr2, addrlen) {
            buf >>>= 0;
            len2 >>>= 0;
            addr2 >>>= 0;
            addrlen >>>= 0;
            try {
              var sock = getSocketFromFD(fd);
              var msg = sock.sock_ops.recvmsg(sock, len2);
              if (!msg)
                return 0;
              if (addr2) {
                var errno = writeSockaddr(addr2, sock.family, DNS.lookup_name(msg.addr), msg.port, addrlen);
              }
              HEAPU8.set(msg.buffer, buf >>> 0);
              return msg.buffer.byteLength;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_recvfrom.sig = "iippipp";
          function ___syscall_recvmsg(fd, message, flags2, d1, d2, d3) {
            message >>>= 0;
            try {
              var sock = getSocketFromFD(fd);
              var iov = HEAPU32[message + 8 >>> 2 >>> 0];
              var num = HEAP32[message + 12 >>> 2 >>> 0];
              var total = 0;
              for (var i2 = 0; i2 < num; i2++) {
                total += HEAP32[iov + (8 * i2 + 4) >>> 2 >>> 0];
              }
              var msg = sock.sock_ops.recvmsg(sock, total);
              if (!msg)
                return 0;
              var name2 = HEAPU32[message >>> 2 >>> 0];
              if (name2) {
                var errno = writeSockaddr(name2, sock.family, DNS.lookup_name(msg.addr), msg.port);
              }
              var bytesRead = 0;
              var bytesRemaining = msg.buffer.byteLength;
              for (var i2 = 0; bytesRemaining > 0 && i2 < num; i2++) {
                var iovbase = HEAPU32[iov + (8 * i2 + 0) >>> 2 >>> 0];
                var iovlen = HEAP32[iov + (8 * i2 + 4) >>> 2 >>> 0];
                if (!iovlen) {
                  continue;
                }
                var length = Math.min(iovlen, bytesRemaining);
                var buf = msg.buffer.subarray(bytesRead, bytesRead + length);
                HEAPU8.set(buf, iovbase + bytesRead >>> 0);
                bytesRead += length;
                bytesRemaining -= length;
              }
              return bytesRead;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_recvmsg.sig = "iipiiii";
          function ___syscall_renameat(olddirfd, oldpath, newdirfd, newpath) {
            oldpath >>>= 0;
            newpath >>>= 0;
            try {
              oldpath = SYSCALLS.getStr(oldpath);
              newpath = SYSCALLS.getStr(newpath);
              oldpath = SYSCALLS.calculateAt(olddirfd, oldpath);
              newpath = SYSCALLS.calculateAt(newdirfd, newpath);
              FS.rename(oldpath, newpath);
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_renameat.sig = "iipip";
          function ___syscall_rmdir(path) {
            path >>>= 0;
            try {
              path = SYSCALLS.getStr(path);
              FS.rmdir(path);
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_rmdir.sig = "ip";
          function ___syscall_sendmsg(fd, message, flags2, d1, d2, d3) {
            message >>>= 0;
            d1 >>>= 0;
            d2 >>>= 0;
            try {
              var sock = getSocketFromFD(fd);
              var iov = HEAPU32[message + 8 >>> 2 >>> 0];
              var num = HEAP32[message + 12 >>> 2 >>> 0];
              var addr2, port;
              var name2 = HEAPU32[message >>> 2 >>> 0];
              var namelen = HEAP32[message + 4 >>> 2 >>> 0];
              if (name2) {
                var info2 = readSockaddr(name2, namelen);
                if (info2.errno)
                  return -info2.errno;
                port = info2.port;
                addr2 = DNS.lookup_addr(info2.addr) || info2.addr;
              }
              var total = 0;
              for (var i2 = 0; i2 < num; i2++) {
                total += HEAP32[iov + (8 * i2 + 4) >>> 2 >>> 0];
              }
              var view = new Uint8Array(total);
              var offset = 0;
              for (var i2 = 0; i2 < num; i2++) {
                var iovbase = HEAPU32[iov + (8 * i2 + 0) >>> 2 >>> 0];
                var iovlen = HEAP32[iov + (8 * i2 + 4) >>> 2 >>> 0];
                for (var j = 0; j < iovlen; j++) {
                  view[offset++] = HEAP8[iovbase + j >>> 0 >>> 0];
                }
              }
              return sock.sock_ops.sendmsg(sock, view, 0, total, addr2, port);
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_sendmsg.sig = "iipippi";
          function ___syscall_sendto(fd, message, length, flags2, addr2, addr_len) {
            message >>>= 0;
            length >>>= 0;
            addr2 >>>= 0;
            addr_len >>>= 0;
            try {
              var sock = getSocketFromFD(fd);
              var dest = getSocketAddress(addr2, addr_len, true);
              if (!dest) {
                return FS.write(sock.stream, HEAP8, message, length);
              }
              return sock.sock_ops.sendmsg(sock, HEAP8, message, length, dest.addr, dest.port);
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_sendto.sig = "iippipp";
          function ___syscall_socket(domain, type, protocol) {
            try {
              var sock = SOCKFS.createSocket(domain, type, protocol);
              return sock.stream.fd;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_socket.sig = "iiiiiii";
          function ___syscall_stat64(path, buf) {
            path >>>= 0;
            buf >>>= 0;
            try {
              path = SYSCALLS.getStr(path);
              return SYSCALLS.doStat(FS.stat, path, buf);
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_stat64.sig = "ipp";
          function ___syscall_symlink(target, linkpath) {
            target >>>= 0;
            linkpath >>>= 0;
            try {
              target = SYSCALLS.getStr(target);
              linkpath = SYSCALLS.getStr(linkpath);
              FS.symlink(target, linkpath);
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_symlink.sig = "ipp";
          function ___syscall_symlinkat(target, newdirfd, linkpath) {
            target >>>= 0;
            linkpath >>>= 0;
            try {
              linkpath = SYSCALLS.calculateAt(newdirfd, linkpath);
              FS.symlink(target, linkpath);
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_symlinkat.sig = "ipip";
          function ___syscall_truncate64(path, length_low, length_high) {
            path >>>= 0;
            var length = convertI32PairToI53Checked(length_low, length_high);
            try {
              if (isNaN(length))
                return 61;
              path = SYSCALLS.getStr(path);
              FS.truncate(path, length);
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_truncate64.sig = "ipii";
          function ___syscall_unlinkat(dirfd, path, flags2) {
            path >>>= 0;
            try {
              path = SYSCALLS.getStr(path);
              path = SYSCALLS.calculateAt(dirfd, path);
              if (flags2 === 0) {
                FS.unlink(path);
              } else if (flags2 === 512) {
                FS.rmdir(path);
              } else {
                abort("Invalid flags passed to unlinkat");
              }
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_unlinkat.sig = "iipi";
          var readI53FromI64 = (ptr2) => HEAPU32[ptr2 >>> 2 >>> 0] + HEAP32[ptr2 + 4 >>> 2 >>> 0] * 4294967296;
          function ___syscall_utimensat(dirfd, path, times, flags2) {
            path >>>= 0;
            times >>>= 0;
            try {
              path = SYSCALLS.getStr(path);
              path = SYSCALLS.calculateAt(dirfd, path, true);
              if (!times) {
                var atime = Date.now();
                var mtime = atime;
              } else {
                var seconds = readI53FromI64(times);
                var nanoseconds = HEAP32[times + 8 >>> 2 >>> 0];
                atime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
                times += 16;
                seconds = readI53FromI64(times);
                nanoseconds = HEAP32[times + 8 >>> 2 >>> 0];
                mtime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
              }
              FS.utime(path, atime, mtime);
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          ___syscall_utimensat.sig = "iippi";
          var ___table_base = new WebAssembly.Global({
            "value": "i32",
            "mutable": false
          }, 1);
          var ENV = {};
          var stringToUTF8OnStack = (str) => {
            var size = lengthBytesUTF8(str) + 1;
            var ret = stackAlloc(size);
            stringToUTF8(str, ret, size);
            return ret;
          };
          var withStackSave = (f) => {
            var stack = stackSave();
            var ret = f();
            stackRestore(stack);
            return ret;
          };
          var dlSetError = (msg) => {
            withStackSave(() => {
              var cmsg = stringToUTF8OnStack(msg);
              ___dl_seterr(cmsg, 0);
            });
          };
          var dlopenInternal = (handle2, jsflags) => {
            var filename = UTF8ToString(handle2 + 36);
            var flags2 = HEAP32[handle2 + 4 >>> 2 >>> 0];
            filename = PATH.normalize(filename);
            var searchpaths = [];
            var global2 = Boolean(flags2 & 256);
            var localScope2 = global2 ? null : {};
            var combinedFlags = {
              global: global2,
              nodelete: Boolean(flags2 & 4096),
              loadAsync: jsflags.loadAsync
            };
            if (jsflags.loadAsync) {
              return loadDynamicLibrary(filename, combinedFlags, localScope2, handle2);
            }
            try {
              return loadDynamicLibrary(filename, combinedFlags, localScope2, handle2);
            } catch (e) {
              dlSetError(`Could not load dynamic lib: ${filename}
${e}`);
              return 0;
            }
          };
          function __dlopen_js(handle2) {
            handle2 >>>= 0;
            return dlopenInternal(handle2, {
              loadAsync: false
            });
          }
          __dlopen_js.sig = "pp";
          function __dlsym_js(handle2, symbol, symbolIndex) {
            handle2 >>>= 0;
            symbol >>>= 0;
            symbolIndex >>>= 0;
            symbol = UTF8ToString(symbol);
            var result;
            var newSymIndex;
            var lib = LDSO.loadedLibsByHandle[handle2];
            if (!lib.exports.hasOwnProperty(symbol) || lib.exports[symbol].stub) {
              dlSetError(`Tried to lookup unknown symbol "${symbol}" in dynamic lib: ${lib.name}`);
              return 0;
            }
            newSymIndex = Object.keys(lib.exports).indexOf(symbol);
            var origSym = "orig$" + symbol;
            result = lib.exports[origSym];
            if (result) {
              newSymIndex = Object.keys(lib.exports).indexOf(origSym);
            } else
              result = lib.exports[symbol];
            if (typeof result == "function") {
              var addr2 = getFunctionAddress(result);
              if (addr2) {
                result = addr2;
              } else {
                result = addFunction(result, result.sig);
                HEAPU32[symbolIndex >>> 2 >>> 0] = newSymIndex;
              }
            }
            return result;
          }
          __dlsym_js.sig = "pppp";
          function __embind_register_bigint(primitiveType, name2, size, minRange, maxRange) {
            primitiveType >>>= 0;
            name2 >>>= 0;
            size >>>= 0;
          }
          __embind_register_bigint.sig = "vpppiiii";
          var embind_init_charCodes = () => {
            var codes = new Array(256);
            for (var i2 = 0; i2 < 256; ++i2) {
              codes[i2] = String.fromCharCode(i2);
            }
            embind_charCodes = codes;
          };
          var embind_charCodes;
          var readLatin1String = (ptr2) => {
            var ret = "";
            var c = ptr2;
            while (HEAPU8[c >>> 0]) {
              ret += embind_charCodes[HEAPU8[c++ >>> 0]];
            }
            return ret;
          };
          var awaitingDependencies = {};
          var registeredTypes = {};
          var typeDependencies = {};
          var BindingError;
          var throwBindingError = (message) => {
            throw new BindingError(message);
          };
          var InternalError;
          var throwInternalError = (message) => {
            throw new InternalError(message);
          };
          var whenDependentTypesAreResolved = (myTypes, dependentTypes, getTypeConverters) => {
            myTypes.forEach(function(type) {
              typeDependencies[type] = dependentTypes;
            });
            function onComplete(typeConverters2) {
              var myTypeConverters = getTypeConverters(typeConverters2);
              if (myTypeConverters.length !== myTypes.length) {
                throwInternalError("Mismatched type converter count");
              }
              for (var i2 = 0; i2 < myTypes.length; ++i2) {
                registerType(myTypes[i2], myTypeConverters[i2]);
              }
            }
            var typeConverters = new Array(dependentTypes.length);
            var unregisteredTypes = [];
            var registered = 0;
            dependentTypes.forEach((dt, i2) => {
              if (registeredTypes.hasOwnProperty(dt)) {
                typeConverters[i2] = registeredTypes[dt];
              } else {
                unregisteredTypes.push(dt);
                if (!awaitingDependencies.hasOwnProperty(dt)) {
                  awaitingDependencies[dt] = [];
                }
                awaitingDependencies[dt].push(() => {
                  typeConverters[i2] = registeredTypes[dt];
                  ++registered;
                  if (registered === unregisteredTypes.length) {
                    onComplete(typeConverters);
                  }
                });
              }
            });
            if (0 === unregisteredTypes.length) {
              onComplete(typeConverters);
            }
          };
          function sharedRegisterType(rawType, registeredInstance, options = {}) {
            var name2 = registeredInstance.name;
            if (!rawType) {
              throwBindingError(`type "${name2}" must have a positive integer typeid pointer`);
            }
            if (registeredTypes.hasOwnProperty(rawType)) {
              if (options.ignoreDuplicateRegistrations) {
                return;
              } else {
                throwBindingError(`Cannot register type '${name2}' twice`);
              }
            }
            registeredTypes[rawType] = registeredInstance;
            delete typeDependencies[rawType];
            if (awaitingDependencies.hasOwnProperty(rawType)) {
              var callbacks = awaitingDependencies[rawType];
              delete awaitingDependencies[rawType];
              callbacks.forEach((cb) => cb());
            }
          }
          function registerType(rawType, registeredInstance, options = {}) {
            if (!("argPackAdvance" in registeredInstance)) {
              throw new TypeError("registerType registeredInstance requires argPackAdvance");
            }
            return sharedRegisterType(rawType, registeredInstance, options);
          }
          var GenericWireTypeSize = 8;
          function __embind_register_bool(rawType, name2, trueValue, falseValue) {
            rawType >>>= 0;
            name2 >>>= 0;
            name2 = readLatin1String(name2);
            registerType(rawType, {
              name: name2,
              "fromWireType": function(wt) {
                return !!wt;
              },
              "toWireType": function(destructors, o) {
                return o ? trueValue : falseValue;
              },
              "argPackAdvance": GenericWireTypeSize,
              "readValueFromPointer": function(pointer) {
                return this["fromWireType"](HEAPU8[pointer >>> 0]);
              },
              destructorFunction: null
            });
          }
          __embind_register_bool.sig = "vppii";
          class HandleAllocator {
            constructor() {
              this.allocated = [void 0];
              this.freelist = [];
            }
            get(id) {
              return this.allocated[id];
            }
            has(id) {
              return this.allocated[id] !== void 0;
            }
            allocate(handle2) {
              var id = this.freelist.pop() || this.allocated.length;
              this.allocated[id] = handle2;
              return id;
            }
            free(id) {
              this.allocated[id] = void 0;
              this.freelist.push(id);
            }
          }
          var emval_handles = new HandleAllocator();
          function __emval_decref(handle2) {
            handle2 >>>= 0;
            if (handle2 >= emval_handles.reserved && 0 === --emval_handles.get(handle2).refcount) {
              emval_handles.free(handle2);
            }
          }
          __emval_decref.sig = "vp";
          var count_emval_handles = () => {
            var count = 0;
            for (var i2 = emval_handles.reserved; i2 < emval_handles.allocated.length; ++i2) {
              if (emval_handles.allocated[i2] !== void 0) {
                ++count;
              }
            }
            return count;
          };
          var init_emval = () => {
            emval_handles.allocated.push({
              value: void 0
            }, {
              value: null
            }, {
              value: true
            }, {
              value: false
            });
            Object.assign(emval_handles, {
              reserved: emval_handles.allocated.length
            }), Module["count_emval_handles"] = count_emval_handles;
          };
          var Emval = {
            toValue: (handle2) => {
              if (!handle2) {
                throwBindingError("Cannot use deleted val. handle = " + handle2);
              }
              return emval_handles.get(handle2).value;
            },
            toHandle: (value) => {
              switch (value) {
                case void 0:
                  return 1;
                case null:
                  return 2;
                case true:
                  return 3;
                case false:
                  return 4;
                default: {
                  return emval_handles.allocate({
                    refcount: 1,
                    value
                  });
                }
              }
            }
          };
          function simpleReadValueFromPointer(pointer) {
            return this["fromWireType"](HEAP32[pointer >>> 2 >>> 0]);
          }
          var EmValType = {
            name: "emscripten::val",
            "fromWireType": (handle2) => {
              var rv = Emval.toValue(handle2);
              __emval_decref(handle2);
              return rv;
            },
            "toWireType": (destructors, value) => Emval.toHandle(value),
            "argPackAdvance": GenericWireTypeSize,
            "readValueFromPointer": simpleReadValueFromPointer,
            destructorFunction: null
          };
          function __embind_register_emval(rawType) {
            rawType >>>= 0;
            return registerType(rawType, EmValType);
          }
          __embind_register_emval.sig = "vp";
          var embindRepr = (v) => {
            if (v === null) {
              return "null";
            }
            var t = typeof v;
            if (t === "object" || t === "array" || t === "function") {
              return v.toString();
            } else {
              return "" + v;
            }
          };
          var floatReadValueFromPointer = (name2, width) => {
            switch (width) {
              case 4:
                return function(pointer) {
                  return this["fromWireType"](HEAPF32[pointer >>> 2 >>> 0]);
                };
              case 8:
                return function(pointer) {
                  return this["fromWireType"](HEAPF64[pointer >>> 3 >>> 0]);
                };
              default:
                throw new TypeError(`invalid float width (${width}): ${name2}`);
            }
          };
          var __embind_register_float = function(rawType, name2, size) {
            rawType >>>= 0;
            name2 >>>= 0;
            size >>>= 0;
            name2 = readLatin1String(name2);
            registerType(rawType, {
              name: name2,
              "fromWireType": (value) => value,
              "toWireType": (destructors, value) => value,
              "argPackAdvance": GenericWireTypeSize,
              "readValueFromPointer": floatReadValueFromPointer(name2, size),
              destructorFunction: null
            });
          };
          __embind_register_float.sig = "vppp";
          var integerReadValueFromPointer = (name2, width, signed) => {
            switch (width) {
              case 1:
                return signed ? (pointer) => HEAP8[pointer >>> 0 >>> 0] : (pointer) => HEAPU8[pointer >>> 0 >>> 0];
              case 2:
                return signed ? (pointer) => HEAP16[pointer >>> 1 >>> 0] : (pointer) => HEAPU16[pointer >>> 1 >>> 0];
              case 4:
                return signed ? (pointer) => HEAP32[pointer >>> 2 >>> 0] : (pointer) => HEAPU32[pointer >>> 2 >>> 0];
              default:
                throw new TypeError(`invalid integer width (${width}): ${name2}`);
            }
          };
          function __embind_register_integer(primitiveType, name2, size, minRange, maxRange) {
            primitiveType >>>= 0;
            name2 >>>= 0;
            size >>>= 0;
            name2 = readLatin1String(name2);
            if (maxRange === -1) {
              maxRange = 4294967295;
            }
            var fromWireType = (value) => value;
            if (minRange === 0) {
              var bitshift = 32 - 8 * size;
              fromWireType = (value) => value << bitshift >>> bitshift;
            }
            var isUnsignedType = name2.includes("unsigned");
            var checkAssertions = (value, toTypeName) => {
            };
            var toWireType;
            if (isUnsignedType) {
              toWireType = function(destructors, value) {
                checkAssertions(value, this.name);
                return value >>> 0;
              };
            } else {
              toWireType = function(destructors, value) {
                checkAssertions(value, this.name);
                return value;
              };
            }
            registerType(primitiveType, {
              name: name2,
              "fromWireType": fromWireType,
              "toWireType": toWireType,
              "argPackAdvance": GenericWireTypeSize,
              "readValueFromPointer": integerReadValueFromPointer(name2, size, minRange !== 0),
              destructorFunction: null
            });
          }
          __embind_register_integer.sig = "vpppii";
          function __embind_register_memory_view(rawType, dataTypeIndex, name2) {
            rawType >>>= 0;
            name2 >>>= 0;
            var typeMapping = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
            var TA = typeMapping[dataTypeIndex];
            function decodeMemoryView(handle2) {
              var size = HEAPU32[handle2 >>> 2 >>> 0];
              var data2 = HEAPU32[handle2 + 4 >>> 2 >>> 0];
              return new TA(HEAP8.buffer, data2, size);
            }
            name2 = readLatin1String(name2);
            registerType(rawType, {
              name: name2,
              "fromWireType": decodeMemoryView,
              "argPackAdvance": GenericWireTypeSize,
              "readValueFromPointer": decodeMemoryView
            }, {
              ignoreDuplicateRegistrations: true
            });
          }
          __embind_register_memory_view.sig = "vpip";
          function readPointer(pointer) {
            return this["fromWireType"](HEAPU32[pointer >>> 2 >>> 0]);
          }
          function __embind_register_std_string(rawType, name2) {
            rawType >>>= 0;
            name2 >>>= 0;
            name2 = readLatin1String(name2);
            var stdStringIsUTF8 = name2 === "std::string";
            registerType(rawType, {
              name: name2,
              "fromWireType"(value) {
                var length = HEAPU32[value >>> 2 >>> 0];
                var payload = value + 4;
                var str;
                if (stdStringIsUTF8) {
                  var decodeStartPtr = payload;
                  for (var i2 = 0; i2 <= length; ++i2) {
                    var currentBytePtr = payload + i2;
                    if (i2 == length || HEAPU8[currentBytePtr >>> 0] == 0) {
                      var maxRead = currentBytePtr - decodeStartPtr;
                      var stringSegment = UTF8ToString(decodeStartPtr, maxRead);
                      if (str === void 0) {
                        str = stringSegment;
                      } else {
                        str += String.fromCharCode(0);
                        str += stringSegment;
                      }
                      decodeStartPtr = currentBytePtr + 1;
                    }
                  }
                } else {
                  var a = new Array(length);
                  for (var i2 = 0; i2 < length; ++i2) {
                    a[i2] = String.fromCharCode(HEAPU8[payload + i2 >>> 0]);
                  }
                  str = a.join("");
                }
                _free(value);
                return str;
              },
              "toWireType"(destructors, value) {
                if (value instanceof ArrayBuffer) {
                  value = new Uint8Array(value);
                }
                var length;
                var valueIsOfTypeString = typeof value == "string";
                if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) {
                  throwBindingError("Cannot pass non-string to std::string");
                }
                if (stdStringIsUTF8 && valueIsOfTypeString) {
                  length = lengthBytesUTF8(value);
                } else {
                  length = value.length;
                }
                var base = _malloc(4 + length + 1);
                var ptr2 = base + 4;
                HEAPU32[base >>> 2 >>> 0] = length;
                if (stdStringIsUTF8 && valueIsOfTypeString) {
                  stringToUTF8(value, ptr2, length + 1);
                } else {
                  if (valueIsOfTypeString) {
                    for (var i2 = 0; i2 < length; ++i2) {
                      var charCode = value.charCodeAt(i2);
                      if (charCode > 255) {
                        _free(ptr2);
                        throwBindingError("String has UTF-16 code units that do not fit in 8 bits");
                      }
                      HEAPU8[ptr2 + i2 >>> 0] = charCode;
                    }
                  } else {
                    for (var i2 = 0; i2 < length; ++i2) {
                      HEAPU8[ptr2 + i2 >>> 0] = value[i2];
                    }
                  }
                }
                if (destructors !== null) {
                  destructors.push(_free, base);
                }
                return base;
              },
              "argPackAdvance": GenericWireTypeSize,
              "readValueFromPointer": readPointer,
              destructorFunction(ptr2) {
                _free(ptr2);
              }
            });
          }
          __embind_register_std_string.sig = "vpp";
          var UTF16Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf-16le") : void 0;
          var UTF16ToString = (ptr2, maxBytesToRead) => {
            var endPtr = ptr2;
            var idx = endPtr >> 1;
            var maxIdx = idx + maxBytesToRead / 2;
            while (!(idx >= maxIdx) && HEAPU16[idx >>> 0])
              ++idx;
            endPtr = idx << 1;
            if (endPtr - ptr2 > 32 && UTF16Decoder)
              return UTF16Decoder.decode(HEAPU8.subarray(ptr2 >>> 0, endPtr >>> 0));
            var str = "";
            for (var i2 = 0; !(i2 >= maxBytesToRead / 2); ++i2) {
              var codeUnit = HEAP16[ptr2 + i2 * 2 >>> 1 >>> 0];
              if (codeUnit == 0)
                break;
              str += String.fromCharCode(codeUnit);
            }
            return str;
          };
          var stringToUTF16 = (str, outPtr, maxBytesToWrite) => {
            maxBytesToWrite ?? (maxBytesToWrite = 2147483647);
            if (maxBytesToWrite < 2)
              return 0;
            maxBytesToWrite -= 2;
            var startPtr = outPtr;
            var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;
            for (var i2 = 0; i2 < numCharsToWrite; ++i2) {
              var codeUnit = str.charCodeAt(i2);
              HEAP16[outPtr >>> 1 >>> 0] = codeUnit;
              outPtr += 2;
            }
            HEAP16[outPtr >>> 1 >>> 0] = 0;
            return outPtr - startPtr;
          };
          var lengthBytesUTF16 = (str) => str.length * 2;
          var UTF32ToString = (ptr2, maxBytesToRead) => {
            var i2 = 0;
            var str = "";
            while (!(i2 >= maxBytesToRead / 4)) {
              var utf32 = HEAP32[ptr2 + i2 * 4 >>> 2 >>> 0];
              if (utf32 == 0)
                break;
              ++i2;
              if (utf32 >= 65536) {
                var ch = utf32 - 65536;
                str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
              } else {
                str += String.fromCharCode(utf32);
              }
            }
            return str;
          };
          var stringToUTF32 = (str, outPtr, maxBytesToWrite) => {
            outPtr >>>= 0;
            maxBytesToWrite ?? (maxBytesToWrite = 2147483647);
            if (maxBytesToWrite < 4)
              return 0;
            var startPtr = outPtr;
            var endPtr = startPtr + maxBytesToWrite - 4;
            for (var i2 = 0; i2 < str.length; ++i2) {
              var codeUnit = str.charCodeAt(i2);
              if (codeUnit >= 55296 && codeUnit <= 57343) {
                var trailSurrogate = str.charCodeAt(++i2);
                codeUnit = 65536 + ((codeUnit & 1023) << 10) | trailSurrogate & 1023;
              }
              HEAP32[outPtr >>> 2 >>> 0] = codeUnit;
              outPtr += 4;
              if (outPtr + 4 > endPtr)
                break;
            }
            HEAP32[outPtr >>> 2 >>> 0] = 0;
            return outPtr - startPtr;
          };
          var lengthBytesUTF32 = (str) => {
            var len2 = 0;
            for (var i2 = 0; i2 < str.length; ++i2) {
              var codeUnit = str.charCodeAt(i2);
              if (codeUnit >= 55296 && codeUnit <= 57343)
                ++i2;
              len2 += 4;
            }
            return len2;
          };
          var __embind_register_std_wstring = function(rawType, charSize, name2) {
            rawType >>>= 0;
            charSize >>>= 0;
            name2 >>>= 0;
            name2 = readLatin1String(name2);
            var decodeString, encodeString, getHeap, lengthBytesUTF, shift;
            if (charSize === 2) {
              decodeString = UTF16ToString;
              encodeString = stringToUTF16;
              lengthBytesUTF = lengthBytesUTF16;
              getHeap = () => HEAPU16;
              shift = 1;
            } else if (charSize === 4) {
              decodeString = UTF32ToString;
              encodeString = stringToUTF32;
              lengthBytesUTF = lengthBytesUTF32;
              getHeap = () => HEAPU32;
              shift = 2;
            }
            registerType(rawType, {
              name: name2,
              "fromWireType": (value) => {
                var length = HEAPU32[value >>> 2 >>> 0];
                var HEAP2 = getHeap();
                var str;
                var decodeStartPtr = value + 4;
                for (var i2 = 0; i2 <= length; ++i2) {
                  var currentBytePtr = value + 4 + i2 * charSize;
                  if (i2 == length || HEAP2[currentBytePtr >>> shift] == 0) {
                    var maxReadBytes = currentBytePtr - decodeStartPtr;
                    var stringSegment = decodeString(decodeStartPtr, maxReadBytes);
                    if (str === void 0) {
                      str = stringSegment;
                    } else {
                      str += String.fromCharCode(0);
                      str += stringSegment;
                    }
                    decodeStartPtr = currentBytePtr + charSize;
                  }
                }
                _free(value);
                return str;
              },
              "toWireType": (destructors, value) => {
                if (!(typeof value == "string")) {
                  throwBindingError(`Cannot pass non-string to C++ string type ${name2}`);
                }
                var length = lengthBytesUTF(value);
                var ptr2 = _malloc(4 + length + charSize);
                HEAPU32[ptr2 >>> 2 >>> 0] = length >> shift;
                encodeString(value, ptr2 + 4, length + charSize);
                if (destructors !== null) {
                  destructors.push(_free, ptr2);
                }
                return ptr2;
              },
              "argPackAdvance": GenericWireTypeSize,
              "readValueFromPointer": simpleReadValueFromPointer,
              destructorFunction(ptr2) {
                _free(ptr2);
              }
            });
          };
          __embind_register_std_wstring.sig = "vppp";
          var __embind_register_void = function(rawType, name2) {
            rawType >>>= 0;
            name2 >>>= 0;
            name2 = readLatin1String(name2);
            registerType(rawType, {
              isVoid: true,
              name: name2,
              "argPackAdvance": 0,
              "fromWireType": () => void 0,
              "toWireType": (destructors, o) => void 0
            });
          };
          __embind_register_void.sig = "vpp";
          var handleException = (e) => {
            if (e instanceof ExitStatus || e == "unwind") {
              return EXITSTATUS;
            }
            quit_(1, e);
          };
          var runtimeKeepaliveCounter = 0;
          var keepRuntimeAlive = () => noExitRuntime || runtimeKeepaliveCounter > 0;
          var _proc_exit = (code) => {
            EXITSTATUS = code;
            if (!keepRuntimeAlive()) {
              Module["onExit"]?.(code);
              ABORT = true;
            }
            quit_(code, new ExitStatus(code));
          };
          _proc_exit.sig = "vi";
          var exitJS = (status, implicit) => {
            EXITSTATUS = status;
            _proc_exit(status);
          };
          var _exit = exitJS;
          _exit.sig = "vi";
          var maybeExit = () => {
            if (!keepRuntimeAlive()) {
              try {
                _exit(EXITSTATUS);
              } catch (e) {
                handleException(e);
              }
            }
          };
          var callUserCallback = (func2) => {
            if (ABORT) {
              return;
            }
            try {
              func2();
              maybeExit();
            } catch (e) {
              handleException(e);
            }
          };
          function __emscripten_dlopen_js(handle2, onsuccess, onerror2, user_data) {
            handle2 >>>= 0;
            onsuccess >>>= 0;
            onerror2 >>>= 0;
            user_data >>>= 0;
            function errorCallback(e) {
              var filename = UTF8ToString(handle2 + 36);
              dlSetError(`'Could not load dynamic lib: ${filename}
${e}`);
              callUserCallback(() => getWasmTableEntry(onerror2)(handle2, user_data));
            }
            function successCallback() {
              callUserCallback(() => getWasmTableEntry(onsuccess)(handle2, user_data));
            }
            var promise = dlopenInternal(handle2, {
              loadAsync: true
            });
            if (promise) {
              promise.then(successCallback, errorCallback);
            } else {
              errorCallback();
            }
          }
          __emscripten_dlopen_js.sig = "vpppp";
          var nowIsMonotonic = 1;
          var __emscripten_get_now_is_monotonic = () => nowIsMonotonic;
          __emscripten_get_now_is_monotonic.sig = "i";
          function __emscripten_get_progname(str, len2) {
            str >>>= 0;
            stringToUTF8(thisProgram, str, len2);
          }
          __emscripten_get_progname.sig = "vpi";
          function __emscripten_lookup_name(name2) {
            name2 >>>= 0;
            var nameString = UTF8ToString(name2);
            return inetPton4(DNS.lookup_name(nameString));
          }
          __emscripten_lookup_name.sig = "ip";
          var __emscripten_runtime_keepalive_clear = () => {
            noExitRuntime = false;
            runtimeKeepaliveCounter = 0;
          };
          __emscripten_runtime_keepalive_clear.sig = "v";
          function __emscripten_set_offscreencanvas_size(target, width, height) {
            target >>>= 0;
            return -1;
          }
          __emscripten_set_offscreencanvas_size.sig = "ipii";
          function __emscripten_system(command) {
            command >>>= 0;
            if (ENVIRONMENT_IS_NODE) {
              if (!command)
                return 1;
              var cmdstr = UTF8ToString(command);
              if (!cmdstr.length)
                return 0;
              var cp = ["child_process"].map(__require);
              var ret = cp.spawnSync(cmdstr, [], {
                shell: true,
                stdio: "inherit"
              });
              var _W_EXITCODE = (ret2, sig) => ret2 << 8 | sig;
              if (ret.status === null) {
                var signalToNumber = (sig) => {
                  switch (sig) {
                    case "SIGHUP":
                      return 1;
                    case "SIGINT":
                      return 2;
                    case "SIGQUIT":
                      return 3;
                    case "SIGFPE":
                      return 8;
                    case "SIGKILL":
                      return 9;
                    case "SIGALRM":
                      return 14;
                    case "SIGTERM":
                      return 15;
                  }
                  return 2;
                };
                return _W_EXITCODE(0, signalToNumber(ret.signal));
              }
              return _W_EXITCODE(ret.status, 0);
            }
            if (!command)
              return 0;
            return -52;
          }
          __emscripten_system.sig = "ip";
          function __gmtime_js(time_low, time_high, tmPtr) {
            var time = convertI32PairToI53Checked(time_low, time_high);
            tmPtr >>>= 0;
            var date = new Date(time * 1e3);
            HEAP32[tmPtr >>> 2 >>> 0] = date.getUTCSeconds();
            HEAP32[tmPtr + 4 >>> 2 >>> 0] = date.getUTCMinutes();
            HEAP32[tmPtr + 8 >>> 2 >>> 0] = date.getUTCHours();
            HEAP32[tmPtr + 12 >>> 2 >>> 0] = date.getUTCDate();
            HEAP32[tmPtr + 16 >>> 2 >>> 0] = date.getUTCMonth();
            HEAP32[tmPtr + 20 >>> 2 >>> 0] = date.getUTCFullYear() - 1900;
            HEAP32[tmPtr + 24 >>> 2 >>> 0] = date.getUTCDay();
            var start2 = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
            var yday = (date.getTime() - start2) / (1e3 * 60 * 60 * 24) | 0;
            HEAP32[tmPtr + 28 >>> 2 >>> 0] = yday;
          }
          __gmtime_js.sig = "viip";
          var isLeapYear = (year) => year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
          var MONTH_DAYS_LEAP_CUMULATIVE = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
          var MONTH_DAYS_REGULAR_CUMULATIVE = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
          var ydayFromDate = (date) => {
            var leap = isLeapYear(date.getFullYear());
            var monthDaysCumulative = leap ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE;
            var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1;
            return yday;
          };
          function __localtime_js(time_low, time_high, tmPtr) {
            var time = convertI32PairToI53Checked(time_low, time_high);
            tmPtr >>>= 0;
            var date = new Date(time * 1e3);
            HEAP32[tmPtr >>> 2 >>> 0] = date.getSeconds();
            HEAP32[tmPtr + 4 >>> 2 >>> 0] = date.getMinutes();
            HEAP32[tmPtr + 8 >>> 2 >>> 0] = date.getHours();
            HEAP32[tmPtr + 12 >>> 2 >>> 0] = date.getDate();
            HEAP32[tmPtr + 16 >>> 2 >>> 0] = date.getMonth();
            HEAP32[tmPtr + 20 >>> 2 >>> 0] = date.getFullYear() - 1900;
            HEAP32[tmPtr + 24 >>> 2 >>> 0] = date.getDay();
            var yday = ydayFromDate(date) | 0;
            HEAP32[tmPtr + 28 >>> 2 >>> 0] = yday;
            HEAP32[tmPtr + 36 >>> 2 >>> 0] = -(date.getTimezoneOffset() * 60);
            var start2 = new Date(date.getFullYear(), 0, 1);
            var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
            var winterOffset = start2.getTimezoneOffset();
            var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;
            HEAP32[tmPtr + 32 >>> 2 >>> 0] = dst;
          }
          __localtime_js.sig = "viip";
          var __mktime_js = function(tmPtr) {
            tmPtr >>>= 0;
            var ret = (() => {
              var date = new Date(HEAP32[tmPtr + 20 >>> 2 >>> 0] + 1900, HEAP32[tmPtr + 16 >>> 2 >>> 0], HEAP32[tmPtr + 12 >>> 2 >>> 0], HEAP32[tmPtr + 8 >>> 2 >>> 0], HEAP32[tmPtr + 4 >>> 2 >>> 0], HEAP32[tmPtr >>> 2 >>> 0], 0);
              var dst = HEAP32[tmPtr + 32 >>> 2 >>> 0];
              var guessedOffset = date.getTimezoneOffset();
              var start2 = new Date(date.getFullYear(), 0, 1);
              var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
              var winterOffset = start2.getTimezoneOffset();
              var dstOffset = Math.min(winterOffset, summerOffset);
              if (dst < 0) {
                HEAP32[tmPtr + 32 >>> 2 >>> 0] = Number(summerOffset != winterOffset && dstOffset == guessedOffset);
              } else if (dst > 0 != (dstOffset == guessedOffset)) {
                var nonDstOffset = Math.max(winterOffset, summerOffset);
                var trueOffset = dst > 0 ? dstOffset : nonDstOffset;
                date.setTime(date.getTime() + (trueOffset - guessedOffset) * 6e4);
              }
              HEAP32[tmPtr + 24 >>> 2 >>> 0] = date.getDay();
              var yday = ydayFromDate(date) | 0;
              HEAP32[tmPtr + 28 >>> 2 >>> 0] = yday;
              HEAP32[tmPtr >>> 2 >>> 0] = date.getSeconds();
              HEAP32[tmPtr + 4 >>> 2 >>> 0] = date.getMinutes();
              HEAP32[tmPtr + 8 >>> 2 >>> 0] = date.getHours();
              HEAP32[tmPtr + 12 >>> 2 >>> 0] = date.getDate();
              HEAP32[tmPtr + 16 >>> 2 >>> 0] = date.getMonth();
              HEAP32[tmPtr + 20 >>> 2 >>> 0] = date.getYear();
              var timeMs = date.getTime();
              if (isNaN(timeMs)) {
                return -1;
              }
              return timeMs / 1e3;
            })();
            return setTempRet0((tempDouble = ret, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)), ret >>> 0;
          };
          __mktime_js.sig = "ip";
          function __mmap_js(len2, prot, flags2, fd, offset_low, offset_high, allocated, addr2) {
            len2 >>>= 0;
            var offset = convertI32PairToI53Checked(offset_low, offset_high);
            allocated >>>= 0;
            addr2 >>>= 0;
            try {
              if (isNaN(offset))
                return 61;
              var stream = SYSCALLS.getStreamFromFD(fd);
              var res = FS.mmap(stream, len2, offset, prot, flags2);
              var ptr2 = res.ptr;
              HEAP32[allocated >>> 2 >>> 0] = res.allocated;
              HEAPU32[addr2 >>> 2 >>> 0] = ptr2;
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          __mmap_js.sig = "ipiiiiipp";
          function __msync_js(addr2, len2, prot, flags2, fd, offset_low, offset_high) {
            addr2 >>>= 0;
            len2 >>>= 0;
            var offset = convertI32PairToI53Checked(offset_low, offset_high);
            try {
              if (isNaN(offset))
                return 61;
              SYSCALLS.doMsync(addr2, SYSCALLS.getStreamFromFD(fd), len2, flags2, offset);
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          __msync_js.sig = "ippiiiii";
          function __munmap_js(addr2, len2, prot, flags2, fd, offset_low, offset_high) {
            addr2 >>>= 0;
            len2 >>>= 0;
            var offset = convertI32PairToI53Checked(offset_low, offset_high);
            try {
              if (isNaN(offset))
                return 61;
              var stream = SYSCALLS.getStreamFromFD(fd);
              if (prot & 2) {
                SYSCALLS.doMsync(addr2, stream, len2, flags2, offset);
              }
              FS.munmap(stream);
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return -e.errno;
            }
          }
          __munmap_js.sig = "ippiiiii";
          var timers = {};
          var _emscripten_get_now;
          _emscripten_get_now = () => performance.now();
          _emscripten_get_now.sig = "d";
          var __setitimer_js = (which, timeout_ms) => {
            if (timers[which]) {
              clearTimeout(timers[which].id);
              delete timers[which];
            }
            if (!timeout_ms)
              return 0;
            var id = setTimeout(() => {
              delete timers[which];
              callUserCallback(() => __emscripten_timeout(which, _emscripten_get_now()));
            }, timeout_ms);
            timers[which] = {
              id,
              timeout_ms
            };
            return 0;
          };
          __setitimer_js.sig = "iid";
          var __timegm_js = function(tmPtr) {
            tmPtr >>>= 0;
            var ret = (() => {
              var time = Date.UTC(HEAP32[tmPtr + 20 >>> 2 >>> 0] + 1900, HEAP32[tmPtr + 16 >>> 2 >>> 0], HEAP32[tmPtr + 12 >>> 2 >>> 0], HEAP32[tmPtr + 8 >>> 2 >>> 0], HEAP32[tmPtr + 4 >>> 2 >>> 0], HEAP32[tmPtr >>> 2 >>> 0], 0);
              var date = new Date(time);
              HEAP32[tmPtr + 24 >>> 2 >>> 0] = date.getUTCDay();
              var start2 = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
              var yday = (date.getTime() - start2) / (1e3 * 60 * 60 * 24) | 0;
              HEAP32[tmPtr + 28 >>> 2 >>> 0] = yday;
              return date.getTime() / 1e3;
            })();
            return setTempRet0((tempDouble = ret, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)), ret >>> 0;
          };
          __timegm_js.sig = "ip";
          var stringToNewUTF8 = (str) => {
            var size = lengthBytesUTF8(str) + 1;
            var ret = _malloc(size);
            if (ret)
              stringToUTF8(str, ret, size);
            return ret;
          };
          function __tzset_js(timezone, daylight, tzname) {
            timezone >>>= 0;
            daylight >>>= 0;
            tzname >>>= 0;
            var currentYear = (/* @__PURE__ */ new Date()).getFullYear();
            var winter = new Date(currentYear, 0, 1);
            var summer = new Date(currentYear, 6, 1);
            var winterOffset = winter.getTimezoneOffset();
            var summerOffset = summer.getTimezoneOffset();
            var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
            HEAPU32[timezone >>> 2 >>> 0] = stdTimezoneOffset * 60;
            HEAP32[daylight >>> 2 >>> 0] = Number(winterOffset != summerOffset);
            function extractZone(date) {
              var match = date.toTimeString().match(/\(([A-Za-z ]+)\)$/);
              return match ? match[1] : "GMT";
            }
            var winterName = extractZone(winter);
            var summerName = extractZone(summer);
            var winterNamePtr = stringToNewUTF8(winterName);
            var summerNamePtr = stringToNewUTF8(summerName);
            if (summerOffset < winterOffset) {
              HEAPU32[tzname >>> 2 >>> 0] = winterNamePtr;
              HEAPU32[tzname + 4 >>> 2 >>> 0] = summerNamePtr;
            } else {
              HEAPU32[tzname >>> 2 >>> 0] = summerNamePtr;
              HEAPU32[tzname + 4 >>> 2 >>> 0] = winterNamePtr;
            }
          }
          __tzset_js.sig = "vppp";
          var _abort = () => {
            abort("");
          };
          _abort.sig = "v";
          var _emscripten_set_main_loop_timing = (mode, value) => {
            Browser.mainLoop.timingMode = mode;
            Browser.mainLoop.timingValue = value;
            if (!Browser.mainLoop.func) {
              return 1;
            }
            if (!Browser.mainLoop.running) {
              Browser.mainLoop.running = true;
            }
            if (mode == 0) {
              Browser.mainLoop.scheduler = function Browser_mainLoop_scheduler_setTimeout() {
                var timeUntilNextTick = Math.max(0, Browser.mainLoop.tickStartTime + value - _emscripten_get_now()) | 0;
                setTimeout(Browser.mainLoop.runner, timeUntilNextTick);
              };
              Browser.mainLoop.method = "timeout";
            } else if (mode == 1) {
              Browser.mainLoop.scheduler = function Browser_mainLoop_scheduler_rAF() {
                Browser.requestAnimationFrame(Browser.mainLoop.runner);
              };
              Browser.mainLoop.method = "rAF";
            } else if (mode == 2) {
              if (typeof Browser.setImmediate == "undefined") {
                if (typeof setImmediate == "undefined") {
                  var setImmediates = [];
                  var emscriptenMainLoopMessageId = "setimmediate";
                  var Browser_setImmediate_messageHandler = (event2) => {
                    if (event2.data === emscriptenMainLoopMessageId || event2.data.target === emscriptenMainLoopMessageId) {
                      event2.stopPropagation();
                      setImmediates.shift()();
                    }
                  };
                  addEventListener("message", Browser_setImmediate_messageHandler, true);
                  Browser.setImmediate = function Browser_emulated_setImmediate(func2) {
                    setImmediates.push(func2);
                    if (ENVIRONMENT_IS_WORKER) {
                      if (Module["setImmediates"] === void 0)
                        Module["setImmediates"] = [];
                      Module["setImmediates"].push(func2);
                      postMessage({
                        target: emscriptenMainLoopMessageId
                      });
                    } else
                      postMessage(emscriptenMainLoopMessageId, "*");
                  };
                } else {
                  Browser.setImmediate = setImmediate;
                }
              }
              Browser.mainLoop.scheduler = function Browser_mainLoop_scheduler_setImmediate() {
                Browser.setImmediate(Browser.mainLoop.runner);
              };
              Browser.mainLoop.method = "immediate";
            }
            return 0;
          };
          _emscripten_set_main_loop_timing.sig = "iii";
          var setMainLoop = (browserIterationFunc, fps, simulateInfiniteLoop, arg, noSetTiming) => {
            assert(!Browser.mainLoop.func, "emscripten_set_main_loop: there can only be one main loop function at once: call emscripten_cancel_main_loop to cancel the previous one before setting a new one with different parameters.");
            Browser.mainLoop.func = browserIterationFunc;
            Browser.mainLoop.arg = arg;
            var thisMainLoopId = Browser.mainLoop.currentlyRunningMainloop;
            function checkIsRunning() {
              if (thisMainLoopId < Browser.mainLoop.currentlyRunningMainloop) {
                return false;
              }
              return true;
            }
            Browser.mainLoop.running = false;
            Browser.mainLoop.runner = function Browser_mainLoop_runner() {
              if (ABORT)
                return;
              if (Browser.mainLoop.queue.length > 0) {
                var start2 = Date.now();
                var blocker = Browser.mainLoop.queue.shift();
                blocker.func(blocker.arg);
                if (Browser.mainLoop.remainingBlockers) {
                  var remaining = Browser.mainLoop.remainingBlockers;
                  var next = remaining % 1 == 0 ? remaining - 1 : Math.floor(remaining);
                  if (blocker.counted) {
                    Browser.mainLoop.remainingBlockers = next;
                  } else {
                    next = next + 0.5;
                    Browser.mainLoop.remainingBlockers = (8 * remaining + next) / 9;
                  }
                }
                Browser.mainLoop.updateStatus();
                if (!checkIsRunning())
                  return;
                setTimeout(Browser.mainLoop.runner, 0);
                return;
              }
              if (!checkIsRunning())
                return;
              Browser.mainLoop.currentFrameNumber = Browser.mainLoop.currentFrameNumber + 1 | 0;
              if (Browser.mainLoop.timingMode == 1 && Browser.mainLoop.timingValue > 1 && Browser.mainLoop.currentFrameNumber % Browser.mainLoop.timingValue != 0) {
                Browser.mainLoop.scheduler();
                return;
              } else if (Browser.mainLoop.timingMode == 0) {
                Browser.mainLoop.tickStartTime = _emscripten_get_now();
              }
              Browser.mainLoop.runIter(browserIterationFunc);
              if (!checkIsRunning())
                return;
              if (typeof SDL == "object")
                SDL.audio?.queueNewAudioData?.();
              Browser.mainLoop.scheduler();
            };
            if (!noSetTiming) {
              if (fps && fps > 0) {
                _emscripten_set_main_loop_timing(0, 1e3 / fps);
              } else {
                _emscripten_set_main_loop_timing(1, 1);
              }
              Browser.mainLoop.scheduler();
            }
            if (simulateInfiniteLoop) {
              throw "unwind";
            }
          };
          var safeSetTimeout = (func2, timeout) => setTimeout(() => {
            callUserCallback(func2);
          }, timeout);
          var warnOnce = (text) => {
            warnOnce.shown || (warnOnce.shown = {});
            if (!warnOnce.shown[text]) {
              warnOnce.shown[text] = 1;
              if (ENVIRONMENT_IS_NODE)
                text = "warning: " + text;
              err(text);
            }
          };
          var Browser = {
            mainLoop: {
              running: false,
              scheduler: null,
              method: "",
              currentlyRunningMainloop: 0,
              func: null,
              arg: 0,
              timingMode: 0,
              timingValue: 0,
              currentFrameNumber: 0,
              queue: [],
              pause() {
                Browser.mainLoop.scheduler = null;
                Browser.mainLoop.currentlyRunningMainloop++;
              },
              resume() {
                Browser.mainLoop.currentlyRunningMainloop++;
                var timingMode = Browser.mainLoop.timingMode;
                var timingValue = Browser.mainLoop.timingValue;
                var func2 = Browser.mainLoop.func;
                Browser.mainLoop.func = null;
                setMainLoop(func2, 0, false, Browser.mainLoop.arg, true);
                _emscripten_set_main_loop_timing(timingMode, timingValue);
                Browser.mainLoop.scheduler();
              },
              updateStatus() {
                if (Module["setStatus"]) {
                  var message = Module["statusMessage"] || "Please wait...";
                  var remaining = Browser.mainLoop.remainingBlockers;
                  var expected = Browser.mainLoop.expectedBlockers;
                  if (remaining) {
                    if (remaining < expected) {
                      Module["setStatus"](message + " (" + (expected - remaining) + "/" + expected + ")");
                    } else {
                      Module["setStatus"](message);
                    }
                  } else {
                    Module["setStatus"]("");
                  }
                }
              },
              runIter(func2) {
                if (ABORT)
                  return;
                if (Module["preMainLoop"]) {
                  var preRet = Module["preMainLoop"]();
                  if (preRet === false) {
                    return;
                  }
                }
                callUserCallback(func2);
                Module["postMainLoop"]?.();
              }
            },
            isFullscreen: false,
            pointerLock: false,
            moduleContextCreatedCallbacks: [],
            workers: [],
            init() {
              if (Browser.initted)
                return;
              Browser.initted = true;
              var imagePlugin = {};
              imagePlugin["canHandle"] = function imagePlugin_canHandle(name2) {
                return !Module.noImageDecoding && /\.(jpg|jpeg|png|bmp)$/i.test(name2);
              };
              imagePlugin["handle"] = function imagePlugin_handle(byteArray, name2, onload2, onerror2) {
                var b = new Blob([byteArray], {
                  type: Browser.getMimetype(name2)
                });
                if (b.size !== byteArray.length) {
                  b = new Blob([new Uint8Array(byteArray).buffer], {
                    type: Browser.getMimetype(name2)
                  });
                }
                var url2 = URL.createObjectURL(b);
                var img = new Image();
                img.onload = () => {
                  assert(img.complete, `Image ${name2} could not be decoded`);
                  var canvas2 = document.createElement("canvas");
                  canvas2.width = img.width;
                  canvas2.height = img.height;
                  var ctx = canvas2.getContext("2d");
                  ctx.drawImage(img, 0, 0);
                  preloadedImages[name2] = canvas2;
                  URL.revokeObjectURL(url2);
                  onload2?.(byteArray);
                };
                img.onerror = (event2) => {
                  err(`Image ${url2} could not be decoded`);
                  onerror2?.();
                };
                img.src = url2;
              };
              preloadPlugins.push(imagePlugin);
              var audioPlugin = {};
              audioPlugin["canHandle"] = function audioPlugin_canHandle(name2) {
                return !Module.noAudioDecoding && name2.substr(-4) in {
                  ".ogg": 1,
                  ".wav": 1,
                  ".mp3": 1
                };
              };
              audioPlugin["handle"] = function audioPlugin_handle(byteArray, name2, onload2, onerror2) {
                var done = false;
                function finish(audio2) {
                  if (done)
                    return;
                  done = true;
                  preloadedAudios[name2] = audio2;
                  onload2?.(byteArray);
                }
                function fail() {
                  if (done)
                    return;
                  done = true;
                  preloadedAudios[name2] = new Audio();
                  onerror2?.();
                }
                var b = new Blob([byteArray], {
                  type: Browser.getMimetype(name2)
                });
                var url2 = URL.createObjectURL(b);
                var audio = new Audio();
                audio.addEventListener("canplaythrough", () => finish(audio), false);
                audio.onerror = function audio_onerror(event2) {
                  if (done)
                    return;
                  err(`warning: browser could not fully decode audio ${name2}, trying slower base64 approach`);
                  function encode64(data2) {
                    var BASE = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
                    var PAD = "=";
                    var ret = "";
                    var leftchar = 0;
                    var leftbits = 0;
                    for (var i2 = 0; i2 < data2.length; i2++) {
                      leftchar = leftchar << 8 | data2[i2];
                      leftbits += 8;
                      while (leftbits >= 6) {
                        var curr = leftchar >> leftbits - 6 & 63;
                        leftbits -= 6;
                        ret += BASE[curr];
                      }
                    }
                    if (leftbits == 2) {
                      ret += BASE[(leftchar & 3) << 4];
                      ret += PAD + PAD;
                    } else if (leftbits == 4) {
                      ret += BASE[(leftchar & 15) << 2];
                      ret += PAD;
                    }
                    return ret;
                  }
                  audio.src = "data:audio/x-" + name2.substr(-3) + ";base64," + encode64(byteArray);
                  finish(audio);
                };
                audio.src = url2;
                safeSetTimeout(() => {
                  finish(audio);
                }, 1e4);
              };
              preloadPlugins.push(audioPlugin);
              function pointerLockChange() {
                Browser.pointerLock = document["pointerLockElement"] === Module["canvas"] || document["mozPointerLockElement"] === Module["canvas"] || document["webkitPointerLockElement"] === Module["canvas"] || document["msPointerLockElement"] === Module["canvas"];
              }
              var canvas = Module["canvas"];
              if (canvas) {
                canvas.requestPointerLock = canvas["requestPointerLock"] || canvas["mozRequestPointerLock"] || canvas["webkitRequestPointerLock"] || canvas["msRequestPointerLock"] || (() => {
                });
                canvas.exitPointerLock = document["exitPointerLock"] || document["mozExitPointerLock"] || document["webkitExitPointerLock"] || document["msExitPointerLock"] || (() => {
                });
                canvas.exitPointerLock = canvas.exitPointerLock.bind(document);
                document.addEventListener("pointerlockchange", pointerLockChange, false);
                document.addEventListener("mozpointerlockchange", pointerLockChange, false);
                document.addEventListener("webkitpointerlockchange", pointerLockChange, false);
                document.addEventListener("mspointerlockchange", pointerLockChange, false);
                if (Module["elementPointerLock"]) {
                  canvas.addEventListener("click", (ev) => {
                    if (!Browser.pointerLock && Module["canvas"].requestPointerLock) {
                      Module["canvas"].requestPointerLock();
                      ev.preventDefault();
                    }
                  }, false);
                }
              }
            },
            createContext(canvas, useWebGL, setInModule, webGLContextAttributes) {
              if (useWebGL && Module.ctx && canvas == Module.canvas)
                return Module.ctx;
              var ctx;
              var contextHandle;
              if (useWebGL) {
                var contextAttributes = {
                  antialias: false,
                  alpha: false,
                  majorVersion: 1
                };
                if (webGLContextAttributes) {
                  for (var attribute in webGLContextAttributes) {
                    contextAttributes[attribute] = webGLContextAttributes[attribute];
                  }
                }
                if (typeof GL != "undefined") {
                  contextHandle = GL.createContext(canvas, contextAttributes);
                  if (contextHandle) {
                    ctx = GL.getContext(contextHandle).GLctx;
                  }
                }
              } else {
                ctx = canvas.getContext("2d");
              }
              if (!ctx)
                return null;
              if (setInModule) {
                if (!useWebGL)
                  assert(typeof GLctx == "undefined", "cannot set in module if GLctx is used, but we are a non-GL context that would replace it");
                Module.ctx = ctx;
                if (useWebGL)
                  GL.makeContextCurrent(contextHandle);
                Module.useWebGL = useWebGL;
                Browser.moduleContextCreatedCallbacks.forEach((callback) => callback());
                Browser.init();
              }
              return ctx;
            },
            destroyContext(canvas, useWebGL, setInModule) {
            },
            fullscreenHandlersInstalled: false,
            lockPointer: void 0,
            resizeCanvas: void 0,
            requestFullscreen(lockPointer, resizeCanvas) {
              Browser.lockPointer = lockPointer;
              Browser.resizeCanvas = resizeCanvas;
              if (typeof Browser.lockPointer == "undefined")
                Browser.lockPointer = true;
              if (typeof Browser.resizeCanvas == "undefined")
                Browser.resizeCanvas = false;
              var canvas = Module["canvas"];
              function fullscreenChange() {
                Browser.isFullscreen = false;
                var canvasContainer2 = canvas.parentNode;
                if ((document["fullscreenElement"] || document["mozFullScreenElement"] || document["msFullscreenElement"] || document["webkitFullscreenElement"] || document["webkitCurrentFullScreenElement"]) === canvasContainer2) {
                  canvas.exitFullscreen = Browser.exitFullscreen;
                  if (Browser.lockPointer)
                    canvas.requestPointerLock();
                  Browser.isFullscreen = true;
                  if (Browser.resizeCanvas) {
                    Browser.setFullscreenCanvasSize();
                  } else {
                    Browser.updateCanvasDimensions(canvas);
                  }
                } else {
                  canvasContainer2.parentNode.insertBefore(canvas, canvasContainer2);
                  canvasContainer2.parentNode.removeChild(canvasContainer2);
                  if (Browser.resizeCanvas) {
                    Browser.setWindowedCanvasSize();
                  } else {
                    Browser.updateCanvasDimensions(canvas);
                  }
                }
                Module["onFullScreen"]?.(Browser.isFullscreen);
                Module["onFullscreen"]?.(Browser.isFullscreen);
              }
              if (!Browser.fullscreenHandlersInstalled) {
                Browser.fullscreenHandlersInstalled = true;
                document.addEventListener("fullscreenchange", fullscreenChange, false);
                document.addEventListener("mozfullscreenchange", fullscreenChange, false);
                document.addEventListener("webkitfullscreenchange", fullscreenChange, false);
                document.addEventListener("MSFullscreenChange", fullscreenChange, false);
              }
              var canvasContainer = document.createElement("div");
              canvas.parentNode.insertBefore(canvasContainer, canvas);
              canvasContainer.appendChild(canvas);
              canvasContainer.requestFullscreen = canvasContainer["requestFullscreen"] || canvasContainer["mozRequestFullScreen"] || canvasContainer["msRequestFullscreen"] || (canvasContainer["webkitRequestFullscreen"] ? () => canvasContainer["webkitRequestFullscreen"](Element["ALLOW_KEYBOARD_INPUT"]) : null) || (canvasContainer["webkitRequestFullScreen"] ? () => canvasContainer["webkitRequestFullScreen"](Element["ALLOW_KEYBOARD_INPUT"]) : null);
              canvasContainer.requestFullscreen();
            },
            exitFullscreen() {
              if (!Browser.isFullscreen) {
                return false;
              }
              var CFS = document["exitFullscreen"] || document["cancelFullScreen"] || document["mozCancelFullScreen"] || document["msExitFullscreen"] || document["webkitCancelFullScreen"] || (() => {
              });
              CFS.apply(document, []);
              return true;
            },
            nextRAF: 0,
            fakeRequestAnimationFrame(func2) {
              var now = Date.now();
              if (Browser.nextRAF === 0) {
                Browser.nextRAF = now + 1e3 / 60;
              } else {
                while (now + 2 >= Browser.nextRAF) {
                  Browser.nextRAF += 1e3 / 60;
                }
              }
              var delay = Math.max(Browser.nextRAF - now, 0);
              setTimeout(func2, delay);
            },
            requestAnimationFrame(func2) {
              if (typeof requestAnimationFrame == "function") {
                requestAnimationFrame(func2);
                return;
              }
              var RAF = Browser.fakeRequestAnimationFrame;
              RAF(func2);
            },
            safeSetTimeout(func2, timeout) {
              return safeSetTimeout(func2, timeout);
            },
            safeRequestAnimationFrame(func2) {
              return Browser.requestAnimationFrame(() => {
                callUserCallback(func2);
              });
            },
            getMimetype(name2) {
              return {
                "jpg": "image/jpeg",
                "jpeg": "image/jpeg",
                "png": "image/png",
                "bmp": "image/bmp",
                "ogg": "audio/ogg",
                "wav": "audio/wav",
                "mp3": "audio/mpeg"
              }[name2.substr(name2.lastIndexOf(".") + 1)];
            },
            getUserMedia(func2) {
              window.getUserMedia || (window.getUserMedia = navigator["getUserMedia"] || navigator["mozGetUserMedia"]);
              window.getUserMedia(func2);
            },
            getMovementX(event2) {
              return event2["movementX"] || event2["mozMovementX"] || event2["webkitMovementX"] || 0;
            },
            getMovementY(event2) {
              return event2["movementY"] || event2["mozMovementY"] || event2["webkitMovementY"] || 0;
            },
            getMouseWheelDelta(event2) {
              var delta = 0;
              switch (event2.type) {
                case "DOMMouseScroll":
                  delta = event2.detail / 3;
                  break;
                case "mousewheel":
                  delta = event2.wheelDelta / 120;
                  break;
                case "wheel":
                  delta = event2.deltaY;
                  switch (event2.deltaMode) {
                    case 0:
                      delta /= 100;
                      break;
                    case 1:
                      delta /= 3;
                      break;
                    case 2:
                      delta *= 80;
                      break;
                    default:
                      throw "unrecognized mouse wheel delta mode: " + event2.deltaMode;
                  }
                  break;
                default:
                  throw "unrecognized mouse wheel event: " + event2.type;
              }
              return delta;
            },
            mouseX: 0,
            mouseY: 0,
            mouseMovementX: 0,
            mouseMovementY: 0,
            touches: {},
            lastTouches: {},
            calculateMouseCoords(pageX, pageY) {
              var rect = Module["canvas"].getBoundingClientRect();
              var cw = Module["canvas"].width;
              var ch = Module["canvas"].height;
              var scrollX = typeof window.scrollX != "undefined" ? window.scrollX : window.pageXOffset;
              var scrollY = typeof window.scrollY != "undefined" ? window.scrollY : window.pageYOffset;
              var adjustedX = pageX - (scrollX + rect.left);
              var adjustedY = pageY - (scrollY + rect.top);
              adjustedX = adjustedX * (cw / rect.width);
              adjustedY = adjustedY * (ch / rect.height);
              return {
                x: adjustedX,
                y: adjustedY
              };
            },
            setMouseCoords(pageX, pageY) {
              const {
                x,
                y
              } = Browser.calculateMouseCoords(pageX, pageY);
              Browser.mouseMovementX = x - Browser.mouseX;
              Browser.mouseMovementY = y - Browser.mouseY;
              Browser.mouseX = x;
              Browser.mouseY = y;
            },
            calculateMouseEvent(event2) {
              if (Browser.pointerLock) {
                if (event2.type != "mousemove" && "mozMovementX" in event2) {
                  Browser.mouseMovementX = Browser.mouseMovementY = 0;
                } else {
                  Browser.mouseMovementX = Browser.getMovementX(event2);
                  Browser.mouseMovementY = Browser.getMovementY(event2);
                }
                if (typeof SDL != "undefined") {
                  Browser.mouseX = SDL.mouseX + Browser.mouseMovementX;
                  Browser.mouseY = SDL.mouseY + Browser.mouseMovementY;
                } else {
                  Browser.mouseX += Browser.mouseMovementX;
                  Browser.mouseY += Browser.mouseMovementY;
                }
              } else {
                if (event2.type === "touchstart" || event2.type === "touchend" || event2.type === "touchmove") {
                  var touch = event2.touch;
                  if (touch === void 0) {
                    return;
                  }
                  var coords = Browser.calculateMouseCoords(touch.pageX, touch.pageY);
                  if (event2.type === "touchstart") {
                    Browser.lastTouches[touch.identifier] = coords;
                    Browser.touches[touch.identifier] = coords;
                  } else if (event2.type === "touchend" || event2.type === "touchmove") {
                    var last = Browser.touches[touch.identifier];
                    last || (last = coords);
                    Browser.lastTouches[touch.identifier] = last;
                    Browser.touches[touch.identifier] = coords;
                  }
                  return;
                }
                Browser.setMouseCoords(event2.pageX, event2.pageY);
              }
            },
            resizeListeners: [],
            updateResizeListeners() {
              var canvas = Module["canvas"];
              Browser.resizeListeners.forEach((listener) => listener(canvas.width, canvas.height));
            },
            setCanvasSize(width, height, noUpdates) {
              var canvas = Module["canvas"];
              Browser.updateCanvasDimensions(canvas, width, height);
              if (!noUpdates)
                Browser.updateResizeListeners();
            },
            windowedWidth: 0,
            windowedHeight: 0,
            setFullscreenCanvasSize() {
              if (typeof SDL != "undefined") {
                var flags2 = HEAPU32[SDL.screen >>> 2 >>> 0];
                flags2 = flags2 | 8388608;
                HEAP32[SDL.screen >>> 2 >>> 0] = flags2;
              }
              Browser.updateCanvasDimensions(Module["canvas"]);
              Browser.updateResizeListeners();
            },
            setWindowedCanvasSize() {
              if (typeof SDL != "undefined") {
                var flags2 = HEAPU32[SDL.screen >>> 2 >>> 0];
                flags2 = flags2 & ~8388608;
                HEAP32[SDL.screen >>> 2 >>> 0] = flags2;
              }
              Browser.updateCanvasDimensions(Module["canvas"]);
              Browser.updateResizeListeners();
            },
            updateCanvasDimensions(canvas, wNative, hNative) {
              if (wNative && hNative) {
                canvas.widthNative = wNative;
                canvas.heightNative = hNative;
              } else {
                wNative = canvas.widthNative;
                hNative = canvas.heightNative;
              }
              var w = wNative;
              var h = hNative;
              if (Module["forcedAspectRatio"] && Module["forcedAspectRatio"] > 0) {
                if (w / h < Module["forcedAspectRatio"]) {
                  w = Math.round(h * Module["forcedAspectRatio"]);
                } else {
                  h = Math.round(w / Module["forcedAspectRatio"]);
                }
              }
              if ((document["fullscreenElement"] || document["mozFullScreenElement"] || document["msFullscreenElement"] || document["webkitFullscreenElement"] || document["webkitCurrentFullScreenElement"]) === canvas.parentNode && typeof screen != "undefined") {
                var factor = Math.min(screen.width / w, screen.height / h);
                w = Math.round(w * factor);
                h = Math.round(h * factor);
              }
              if (Browser.resizeCanvas) {
                if (canvas.width != w)
                  canvas.width = w;
                if (canvas.height != h)
                  canvas.height = h;
                if (typeof canvas.style != "undefined") {
                  canvas.style.removeProperty("width");
                  canvas.style.removeProperty("height");
                }
              } else {
                if (canvas.width != wNative)
                  canvas.width = wNative;
                if (canvas.height != hNative)
                  canvas.height = hNative;
                if (typeof canvas.style != "undefined") {
                  if (w != wNative || h != hNative) {
                    canvas.style.setProperty("width", w + "px", "important");
                    canvas.style.setProperty("height", h + "px", "important");
                  } else {
                    canvas.style.removeProperty("width");
                    canvas.style.removeProperty("height");
                  }
                }
              }
            }
          };
          var AL = {
            QUEUE_INTERVAL: 25,
            QUEUE_LOOKAHEAD: 0.1,
            DEVICE_NAME: "Emscripten OpenAL",
            CAPTURE_DEVICE_NAME: "Emscripten OpenAL capture",
            ALC_EXTENSIONS: {
              ALC_SOFT_pause_device: true,
              ALC_SOFT_HRTF: true
            },
            AL_EXTENSIONS: {
              AL_EXT_float32: true,
              AL_SOFT_loop_points: true,
              AL_SOFT_source_length: true,
              AL_EXT_source_distance_model: true,
              AL_SOFT_source_spatialize: true
            },
            _alcErr: 0,
            alcErr: 0,
            deviceRefCounts: {},
            alcStringCache: {},
            paused: false,
            stringCache: {},
            contexts: {},
            currentCtx: null,
            buffers: {
              0: {
                id: 0,
                refCount: 0,
                audioBuf: null,
                frequency: 0,
                bytesPerSample: 2,
                channels: 1,
                length: 0
              }
            },
            paramArray: [],
            _nextId: 1,
            newId: () => AL.freeIds.length > 0 ? AL.freeIds.pop() : AL._nextId++,
            freeIds: [],
            scheduleContextAudio: (ctx) => {
              if (Browser.mainLoop.timingMode === 1 && document["visibilityState"] != "visible") {
                return;
              }
              for (var i2 in ctx.sources) {
                AL.scheduleSourceAudio(ctx.sources[i2]);
              }
            },
            scheduleSourceAudio: (src, lookahead) => {
              if (Browser.mainLoop.timingMode === 1 && document["visibilityState"] != "visible") {
                return;
              }
              if (src.state !== 4114) {
                return;
              }
              var currentTime = AL.updateSourceTime(src);
              var startTime = src.bufStartTime;
              var startOffset = src.bufOffset;
              var bufCursor = src.bufsProcessed;
              for (var i2 = 0; i2 < src.audioQueue.length; i2++) {
                var audioSrc = src.audioQueue[i2];
                startTime = audioSrc._startTime + audioSrc._duration;
                startOffset = 0;
                bufCursor += audioSrc._skipCount + 1;
              }
              if (!lookahead) {
                lookahead = AL.QUEUE_LOOKAHEAD;
              }
              var lookaheadTime = currentTime + lookahead;
              var skipCount = 0;
              while (startTime < lookaheadTime) {
                if (bufCursor >= src.bufQueue.length) {
                  if (src.looping) {
                    bufCursor %= src.bufQueue.length;
                  } else {
                    break;
                  }
                }
                var buf = src.bufQueue[bufCursor % src.bufQueue.length];
                if (buf.length === 0) {
                  skipCount++;
                  if (skipCount === src.bufQueue.length) {
                    break;
                  }
                } else {
                  var audioSrc = src.context.audioCtx.createBufferSource();
                  audioSrc.buffer = buf.audioBuf;
                  audioSrc.playbackRate.value = src.playbackRate;
                  if (buf.audioBuf._loopStart || buf.audioBuf._loopEnd) {
                    audioSrc.loopStart = buf.audioBuf._loopStart;
                    audioSrc.loopEnd = buf.audioBuf._loopEnd;
                  }
                  var duration = 0;
                  if (src.type === 4136 && src.looping) {
                    duration = Number.POSITIVE_INFINITY;
                    audioSrc.loop = true;
                    if (buf.audioBuf._loopStart) {
                      audioSrc.loopStart = buf.audioBuf._loopStart;
                    }
                    if (buf.audioBuf._loopEnd) {
                      audioSrc.loopEnd = buf.audioBuf._loopEnd;
                    }
                  } else {
                    duration = (buf.audioBuf.duration - startOffset) / src.playbackRate;
                  }
                  audioSrc._startOffset = startOffset;
                  audioSrc._duration = duration;
                  audioSrc._skipCount = skipCount;
                  skipCount = 0;
                  audioSrc.connect(src.gain);
                  if (typeof audioSrc.start != "undefined") {
                    startTime = Math.max(startTime, src.context.audioCtx.currentTime);
                    audioSrc.start(startTime, startOffset);
                  } else if (typeof audioSrc.noteOn != "undefined") {
                    startTime = Math.max(startTime, src.context.audioCtx.currentTime);
                    audioSrc.noteOn(startTime);
                  }
                  audioSrc._startTime = startTime;
                  src.audioQueue.push(audioSrc);
                  startTime += duration;
                }
                startOffset = 0;
                bufCursor++;
              }
            },
            updateSourceTime: (src) => {
              var currentTime = src.context.audioCtx.currentTime;
              if (src.state !== 4114) {
                return currentTime;
              }
              if (!isFinite(src.bufStartTime)) {
                src.bufStartTime = currentTime - src.bufOffset / src.playbackRate;
                src.bufOffset = 0;
              }
              var nextStartTime = 0;
              while (src.audioQueue.length) {
                var audioSrc = src.audioQueue[0];
                src.bufsProcessed += audioSrc._skipCount;
                nextStartTime = audioSrc._startTime + audioSrc._duration;
                if (currentTime < nextStartTime) {
                  break;
                }
                src.audioQueue.shift();
                src.bufStartTime = nextStartTime;
                src.bufOffset = 0;
                src.bufsProcessed++;
              }
              if (src.bufsProcessed >= src.bufQueue.length && !src.looping) {
                AL.setSourceState(src, 4116);
              } else if (src.type === 4136 && src.looping) {
                var buf = src.bufQueue[0];
                if (buf.length === 0) {
                  src.bufOffset = 0;
                } else {
                  var delta = (currentTime - src.bufStartTime) * src.playbackRate;
                  var loopStart = buf.audioBuf._loopStart || 0;
                  var loopEnd = buf.audioBuf._loopEnd || buf.audioBuf.duration;
                  if (loopEnd <= loopStart) {
                    loopEnd = buf.audioBuf.duration;
                  }
                  if (delta < loopEnd) {
                    src.bufOffset = delta;
                  } else {
                    src.bufOffset = loopStart + (delta - loopStart) % (loopEnd - loopStart);
                  }
                }
              } else if (src.audioQueue[0]) {
                src.bufOffset = (currentTime - src.audioQueue[0]._startTime) * src.playbackRate;
              } else {
                if (src.type !== 4136 && src.looping) {
                  var srcDuration = AL.sourceDuration(src) / src.playbackRate;
                  if (srcDuration > 0) {
                    src.bufStartTime += Math.floor((currentTime - src.bufStartTime) / srcDuration) * srcDuration;
                  }
                }
                for (var i2 = 0; i2 < src.bufQueue.length; i2++) {
                  if (src.bufsProcessed >= src.bufQueue.length) {
                    if (src.looping) {
                      src.bufsProcessed %= src.bufQueue.length;
                    } else {
                      AL.setSourceState(src, 4116);
                      break;
                    }
                  }
                  var buf = src.bufQueue[src.bufsProcessed];
                  if (buf.length > 0) {
                    nextStartTime = src.bufStartTime + buf.audioBuf.duration / src.playbackRate;
                    if (currentTime < nextStartTime) {
                      src.bufOffset = (currentTime - src.bufStartTime) * src.playbackRate;
                      break;
                    }
                    src.bufStartTime = nextStartTime;
                  }
                  src.bufOffset = 0;
                  src.bufsProcessed++;
                }
              }
              return currentTime;
            },
            cancelPendingSourceAudio: (src) => {
              AL.updateSourceTime(src);
              for (var i2 = 1; i2 < src.audioQueue.length; i2++) {
                var audioSrc = src.audioQueue[i2];
                audioSrc.stop();
              }
              if (src.audioQueue.length > 1) {
                src.audioQueue.length = 1;
              }
            },
            stopSourceAudio: (src) => {
              for (var i2 = 0; i2 < src.audioQueue.length; i2++) {
                src.audioQueue[i2].stop();
              }
              src.audioQueue.length = 0;
            },
            setSourceState: (src, state) => {
              if (state === 4114) {
                if (src.state === 4114 || src.state == 4116) {
                  src.bufsProcessed = 0;
                  src.bufOffset = 0;
                } else {
                }
                AL.stopSourceAudio(src);
                src.state = 4114;
                src.bufStartTime = Number.NEGATIVE_INFINITY;
                AL.scheduleSourceAudio(src);
              } else if (state === 4115) {
                if (src.state === 4114) {
                  AL.updateSourceTime(src);
                  AL.stopSourceAudio(src);
                  src.state = 4115;
                }
              } else if (state === 4116) {
                if (src.state !== 4113) {
                  src.state = 4116;
                  src.bufsProcessed = src.bufQueue.length;
                  src.bufStartTime = Number.NEGATIVE_INFINITY;
                  src.bufOffset = 0;
                  AL.stopSourceAudio(src);
                }
              } else if (state === 4113) {
                if (src.state !== 4113) {
                  src.state = 4113;
                  src.bufsProcessed = 0;
                  src.bufStartTime = Number.NEGATIVE_INFINITY;
                  src.bufOffset = 0;
                  AL.stopSourceAudio(src);
                }
              }
            },
            initSourcePanner: (src) => {
              if (src.type === 4144) {
                return;
              }
              var templateBuf = AL.buffers[0];
              for (var i2 = 0; i2 < src.bufQueue.length; i2++) {
                if (src.bufQueue[i2].id !== 0) {
                  templateBuf = src.bufQueue[i2];
                  break;
                }
              }
              if (src.spatialize === 1 || src.spatialize === 2 && templateBuf.channels === 1) {
                if (src.panner) {
                  return;
                }
                src.panner = src.context.audioCtx.createPanner();
                AL.updateSourceGlobal(src);
                AL.updateSourceSpace(src);
                src.panner.connect(src.context.gain);
                src.gain.disconnect();
                src.gain.connect(src.panner);
              } else {
                if (!src.panner) {
                  return;
                }
                src.panner.disconnect();
                src.gain.disconnect();
                src.gain.connect(src.context.gain);
                src.panner = null;
              }
            },
            updateContextGlobal: (ctx) => {
              for (var i2 in ctx.sources) {
                AL.updateSourceGlobal(ctx.sources[i2]);
              }
            },
            updateSourceGlobal: (src) => {
              var panner = src.panner;
              if (!panner) {
                return;
              }
              panner.refDistance = src.refDistance;
              panner.maxDistance = src.maxDistance;
              panner.rolloffFactor = src.rolloffFactor;
              panner.panningModel = src.context.hrtf ? "HRTF" : "equalpower";
              var distanceModel = src.context.sourceDistanceModel ? src.distanceModel : src.context.distanceModel;
              switch (distanceModel) {
                case 0:
                  panner.distanceModel = "inverse";
                  panner.refDistance = 340282e33;
                  break;
                case 53249:
                case 53250:
                  panner.distanceModel = "inverse";
                  break;
                case 53251:
                case 53252:
                  panner.distanceModel = "linear";
                  break;
                case 53253:
                case 53254:
                  panner.distanceModel = "exponential";
                  break;
              }
            },
            updateListenerSpace: (ctx) => {
              var listener = ctx.audioCtx.listener;
              if (listener.positionX) {
                listener.positionX.value = ctx.listener.position[0];
                listener.positionY.value = ctx.listener.position[1];
                listener.positionZ.value = ctx.listener.position[2];
              } else {
                listener.setPosition(ctx.listener.position[0], ctx.listener.position[1], ctx.listener.position[2]);
              }
              if (listener.forwardX) {
                listener.forwardX.value = ctx.listener.direction[0];
                listener.forwardY.value = ctx.listener.direction[1];
                listener.forwardZ.value = ctx.listener.direction[2];
                listener.upX.value = ctx.listener.up[0];
                listener.upY.value = ctx.listener.up[1];
                listener.upZ.value = ctx.listener.up[2];
              } else {
                listener.setOrientation(ctx.listener.direction[0], ctx.listener.direction[1], ctx.listener.direction[2], ctx.listener.up[0], ctx.listener.up[1], ctx.listener.up[2]);
              }
              for (var i2 in ctx.sources) {
                AL.updateSourceSpace(ctx.sources[i2]);
              }
            },
            updateSourceSpace: (src) => {
              if (!src.panner) {
                return;
              }
              var panner = src.panner;
              var posX = src.position[0];
              var posY = src.position[1];
              var posZ = src.position[2];
              var dirX = src.direction[0];
              var dirY = src.direction[1];
              var dirZ = src.direction[2];
              var listener = src.context.listener;
              var lPosX = listener.position[0];
              var lPosY = listener.position[1];
              var lPosZ = listener.position[2];
              if (src.relative) {
                var lBackX = -listener.direction[0];
                var lBackY = -listener.direction[1];
                var lBackZ = -listener.direction[2];
                var lUpX = listener.up[0];
                var lUpY = listener.up[1];
                var lUpZ = listener.up[2];
                var inverseMagnitude = (x, y, z) => {
                  var length = Math.sqrt(x * x + y * y + z * z);
                  if (length < Number.EPSILON) {
                    return 0;
                  }
                  return 1 / length;
                };
                var invMag = inverseMagnitude(lBackX, lBackY, lBackZ);
                lBackX *= invMag;
                lBackY *= invMag;
                lBackZ *= invMag;
                invMag = inverseMagnitude(lUpX, lUpY, lUpZ);
                lUpX *= invMag;
                lUpY *= invMag;
                lUpZ *= invMag;
                var lRightX = lUpY * lBackZ - lUpZ * lBackY;
                var lRightY = lUpZ * lBackX - lUpX * lBackZ;
                var lRightZ = lUpX * lBackY - lUpY * lBackX;
                invMag = inverseMagnitude(lRightX, lRightY, lRightZ);
                lRightX *= invMag;
                lRightY *= invMag;
                lRightZ *= invMag;
                lUpX = lBackY * lRightZ - lBackZ * lRightY;
                lUpY = lBackZ * lRightX - lBackX * lRightZ;
                lUpZ = lBackX * lRightY - lBackY * lRightX;
                var oldX = dirX;
                var oldY = dirY;
                var oldZ = dirZ;
                dirX = oldX * lRightX + oldY * lUpX + oldZ * lBackX;
                dirY = oldX * lRightY + oldY * lUpY + oldZ * lBackY;
                dirZ = oldX * lRightZ + oldY * lUpZ + oldZ * lBackZ;
                oldX = posX;
                oldY = posY;
                oldZ = posZ;
                posX = oldX * lRightX + oldY * lUpX + oldZ * lBackX;
                posY = oldX * lRightY + oldY * lUpY + oldZ * lBackY;
                posZ = oldX * lRightZ + oldY * lUpZ + oldZ * lBackZ;
                posX += lPosX;
                posY += lPosY;
                posZ += lPosZ;
              }
              if (panner.positionX) {
                if (posX != panner.positionX.value)
                  panner.positionX.value = posX;
                if (posY != panner.positionY.value)
                  panner.positionY.value = posY;
                if (posZ != panner.positionZ.value)
                  panner.positionZ.value = posZ;
              } else {
                panner.setPosition(posX, posY, posZ);
              }
              if (panner.orientationX) {
                if (dirX != panner.orientationX.value)
                  panner.orientationX.value = dirX;
                if (dirY != panner.orientationY.value)
                  panner.orientationY.value = dirY;
                if (dirZ != panner.orientationZ.value)
                  panner.orientationZ.value = dirZ;
              } else {
                panner.setOrientation(dirX, dirY, dirZ);
              }
              var oldShift = src.dopplerShift;
              var velX = src.velocity[0];
              var velY = src.velocity[1];
              var velZ = src.velocity[2];
              var lVelX = listener.velocity[0];
              var lVelY = listener.velocity[1];
              var lVelZ = listener.velocity[2];
              if (posX === lPosX && posY === lPosY && posZ === lPosZ || velX === lVelX && velY === lVelY && velZ === lVelZ) {
                src.dopplerShift = 1;
              } else {
                var speedOfSound = src.context.speedOfSound;
                var dopplerFactor = src.context.dopplerFactor;
                var slX = lPosX - posX;
                var slY = lPosY - posY;
                var slZ = lPosZ - posZ;
                var magSl = Math.sqrt(slX * slX + slY * slY + slZ * slZ);
                var vls = (slX * lVelX + slY * lVelY + slZ * lVelZ) / magSl;
                var vss = (slX * velX + slY * velY + slZ * velZ) / magSl;
                vls = Math.min(vls, speedOfSound / dopplerFactor);
                vss = Math.min(vss, speedOfSound / dopplerFactor);
                src.dopplerShift = (speedOfSound - dopplerFactor * vls) / (speedOfSound - dopplerFactor * vss);
              }
              if (src.dopplerShift !== oldShift) {
                AL.updateSourceRate(src);
              }
            },
            updateSourceRate: (src) => {
              if (src.state === 4114) {
                AL.cancelPendingSourceAudio(src);
                var audioSrc = src.audioQueue[0];
                if (!audioSrc) {
                  return;
                }
                var duration;
                if (src.type === 4136 && src.looping) {
                  duration = Number.POSITIVE_INFINITY;
                } else {
                  duration = (audioSrc.buffer.duration - audioSrc._startOffset) / src.playbackRate;
                }
                audioSrc._duration = duration;
                audioSrc.playbackRate.value = src.playbackRate;
                AL.scheduleSourceAudio(src);
              }
            },
            sourceDuration: (src) => {
              var length = 0;
              for (var i2 = 0; i2 < src.bufQueue.length; i2++) {
                var audioBuf = src.bufQueue[i2].audioBuf;
                length += audioBuf ? audioBuf.duration : 0;
              }
              return length;
            },
            sourceTell: (src) => {
              AL.updateSourceTime(src);
              var offset = 0;
              for (var i2 = 0; i2 < src.bufsProcessed; i2++) {
                if (src.bufQueue[i2].audioBuf) {
                  offset += src.bufQueue[i2].audioBuf.duration;
                }
              }
              offset += src.bufOffset;
              return offset;
            },
            sourceSeek: (src, offset) => {
              var playing = src.state == 4114;
              if (playing) {
                AL.setSourceState(src, 4113);
              }
              if (src.bufQueue[src.bufsProcessed].audioBuf !== null) {
                src.bufsProcessed = 0;
                while (offset > src.bufQueue[src.bufsProcessed].audioBuf.duration) {
                  offset -= src.bufQueue[src.bufsProcessed].audiobuf.duration;
                  src.bufsProcessed++;
                }
                src.bufOffset = offset;
              }
              if (playing) {
                AL.setSourceState(src, 4114);
              }
            },
            getGlobalParam: (funcname, param) => {
              if (!AL.currentCtx) {
                return null;
              }
              switch (param) {
                case 49152:
                  return AL.currentCtx.dopplerFactor;
                case 49155:
                  return AL.currentCtx.speedOfSound;
                case 53248:
                  return AL.currentCtx.distanceModel;
                default:
                  AL.currentCtx.err = 40962;
                  return null;
              }
            },
            setGlobalParam: (funcname, param, value) => {
              if (!AL.currentCtx) {
                return;
              }
              switch (param) {
                case 49152:
                  if (!Number.isFinite(value) || value < 0) {
                    AL.currentCtx.err = 40963;
                    return;
                  }
                  AL.currentCtx.dopplerFactor = value;
                  AL.updateListenerSpace(AL.currentCtx);
                  break;
                case 49155:
                  if (!Number.isFinite(value) || value <= 0) {
                    AL.currentCtx.err = 40963;
                    return;
                  }
                  AL.currentCtx.speedOfSound = value;
                  AL.updateListenerSpace(AL.currentCtx);
                  break;
                case 53248:
                  switch (value) {
                    case 0:
                    case 53249:
                    case 53250:
                    case 53251:
                    case 53252:
                    case 53253:
                    case 53254:
                      AL.currentCtx.distanceModel = value;
                      AL.updateContextGlobal(AL.currentCtx);
                      break;
                    default:
                      AL.currentCtx.err = 40963;
                      return;
                  }
                  break;
                default:
                  AL.currentCtx.err = 40962;
                  return;
              }
            },
            getListenerParam: (funcname, param) => {
              if (!AL.currentCtx) {
                return null;
              }
              switch (param) {
                case 4100:
                  return AL.currentCtx.listener.position;
                case 4102:
                  return AL.currentCtx.listener.velocity;
                case 4111:
                  return AL.currentCtx.listener.direction.concat(AL.currentCtx.listener.up);
                case 4106:
                  return AL.currentCtx.gain.gain.value;
                default:
                  AL.currentCtx.err = 40962;
                  return null;
              }
            },
            setListenerParam: (funcname, param, value) => {
              if (!AL.currentCtx) {
                return;
              }
              if (value === null) {
                AL.currentCtx.err = 40962;
                return;
              }
              var listener = AL.currentCtx.listener;
              switch (param) {
                case 4100:
                  if (!Number.isFinite(value[0]) || !Number.isFinite(value[1]) || !Number.isFinite(value[2])) {
                    AL.currentCtx.err = 40963;
                    return;
                  }
                  listener.position[0] = value[0];
                  listener.position[1] = value[1];
                  listener.position[2] = value[2];
                  AL.updateListenerSpace(AL.currentCtx);
                  break;
                case 4102:
                  if (!Number.isFinite(value[0]) || !Number.isFinite(value[1]) || !Number.isFinite(value[2])) {
                    AL.currentCtx.err = 40963;
                    return;
                  }
                  listener.velocity[0] = value[0];
                  listener.velocity[1] = value[1];
                  listener.velocity[2] = value[2];
                  AL.updateListenerSpace(AL.currentCtx);
                  break;
                case 4106:
                  if (!Number.isFinite(value) || value < 0) {
                    AL.currentCtx.err = 40963;
                    return;
                  }
                  AL.currentCtx.gain.gain.value = value;
                  break;
                case 4111:
                  if (!Number.isFinite(value[0]) || !Number.isFinite(value[1]) || !Number.isFinite(value[2]) || !Number.isFinite(value[3]) || !Number.isFinite(value[4]) || !Number.isFinite(value[5])) {
                    AL.currentCtx.err = 40963;
                    return;
                  }
                  listener.direction[0] = value[0];
                  listener.direction[1] = value[1];
                  listener.direction[2] = value[2];
                  listener.up[0] = value[3];
                  listener.up[1] = value[4];
                  listener.up[2] = value[5];
                  AL.updateListenerSpace(AL.currentCtx);
                  break;
                default:
                  AL.currentCtx.err = 40962;
                  return;
              }
            },
            getBufferParam: (funcname, bufferId, param) => {
              if (!AL.currentCtx) {
                return;
              }
              var buf = AL.buffers[bufferId];
              if (!buf || bufferId === 0) {
                AL.currentCtx.err = 40961;
                return;
              }
              switch (param) {
                case 8193:
                  return buf.frequency;
                case 8194:
                  return buf.bytesPerSample * 8;
                case 8195:
                  return buf.channels;
                case 8196:
                  return buf.length * buf.bytesPerSample * buf.channels;
                case 8213:
                  if (buf.length === 0) {
                    return [0, 0];
                  }
                  return [(buf.audioBuf._loopStart || 0) * buf.frequency, (buf.audioBuf._loopEnd || buf.length) * buf.frequency];
                default:
                  AL.currentCtx.err = 40962;
                  return null;
              }
            },
            setBufferParam: (funcname, bufferId, param, value) => {
              if (!AL.currentCtx) {
                return;
              }
              var buf = AL.buffers[bufferId];
              if (!buf || bufferId === 0) {
                AL.currentCtx.err = 40961;
                return;
              }
              if (value === null) {
                AL.currentCtx.err = 40962;
                return;
              }
              switch (param) {
                case 8196:
                  if (value !== 0) {
                    AL.currentCtx.err = 40963;
                    return;
                  }
                  break;
                case 8213:
                  if (value[0] < 0 || value[0] > buf.length || value[1] < 0 || value[1] > buf.Length || value[0] >= value[1]) {
                    AL.currentCtx.err = 40963;
                    return;
                  }
                  if (buf.refCount > 0) {
                    AL.currentCtx.err = 40964;
                    return;
                  }
                  if (buf.audioBuf) {
                    buf.audioBuf._loopStart = value[0] / buf.frequency;
                    buf.audioBuf._loopEnd = value[1] / buf.frequency;
                  }
                  break;
                default:
                  AL.currentCtx.err = 40962;
                  return;
              }
            },
            getSourceParam: (funcname, sourceId, param) => {
              if (!AL.currentCtx) {
                return null;
              }
              var src = AL.currentCtx.sources[sourceId];
              if (!src) {
                AL.currentCtx.err = 40961;
                return null;
              }
              switch (param) {
                case 514:
                  return src.relative;
                case 4097:
                  return src.coneInnerAngle;
                case 4098:
                  return src.coneOuterAngle;
                case 4099:
                  return src.pitch;
                case 4100:
                  return src.position;
                case 4101:
                  return src.direction;
                case 4102:
                  return src.velocity;
                case 4103:
                  return src.looping;
                case 4105:
                  if (src.type === 4136) {
                    return src.bufQueue[0].id;
                  }
                  return 0;
                case 4106:
                  return src.gain.gain.value;
                case 4109:
                  return src.minGain;
                case 4110:
                  return src.maxGain;
                case 4112:
                  return src.state;
                case 4117:
                  if (src.bufQueue.length === 1 && src.bufQueue[0].id === 0) {
                    return 0;
                  }
                  return src.bufQueue.length;
                case 4118:
                  if (src.bufQueue.length === 1 && src.bufQueue[0].id === 0 || src.looping) {
                    return 0;
                  }
                  return src.bufsProcessed;
                case 4128:
                  return src.refDistance;
                case 4129:
                  return src.rolloffFactor;
                case 4130:
                  return src.coneOuterGain;
                case 4131:
                  return src.maxDistance;
                case 4132:
                  return AL.sourceTell(src);
                case 4133:
                  var offset = AL.sourceTell(src);
                  if (offset > 0) {
                    offset *= src.bufQueue[0].frequency;
                  }
                  return offset;
                case 4134:
                  var offset = AL.sourceTell(src);
                  if (offset > 0) {
                    offset *= src.bufQueue[0].frequency * src.bufQueue[0].bytesPerSample;
                  }
                  return offset;
                case 4135:
                  return src.type;
                case 4628:
                  return src.spatialize;
                case 8201:
                  var length = 0;
                  var bytesPerFrame = 0;
                  for (var i2 = 0; i2 < src.bufQueue.length; i2++) {
                    length += src.bufQueue[i2].length;
                    if (src.bufQueue[i2].id !== 0) {
                      bytesPerFrame = src.bufQueue[i2].bytesPerSample * src.bufQueue[i2].channels;
                    }
                  }
                  return length * bytesPerFrame;
                case 8202:
                  var length = 0;
                  for (var i2 = 0; i2 < src.bufQueue.length; i2++) {
                    length += src.bufQueue[i2].length;
                  }
                  return length;
                case 8203:
                  return AL.sourceDuration(src);
                case 53248:
                  return src.distanceModel;
                default:
                  AL.currentCtx.err = 40962;
                  return null;
              }
            },
            setSourceParam: (funcname, sourceId, param, value) => {
              if (!AL.currentCtx) {
                return;
              }
              var src = AL.currentCtx.sources[sourceId];
              if (!src) {
                AL.currentCtx.err = 40961;
                return;
              }
              if (value === null) {
                AL.currentCtx.err = 40962;
                return;
              }
              switch (param) {
                case 514:
                  if (value === 1) {
                    src.relative = true;
                    AL.updateSourceSpace(src);
                  } else if (value === 0) {
                    src.relative = false;
                    AL.updateSourceSpace(src);
                  } else {
                    AL.currentCtx.err = 40963;
                    return;
                  }
                  break;
                case 4097:
                  if (!Number.isFinite(value)) {
                    AL.currentCtx.err = 40963;
                    return;
                  }
                  src.coneInnerAngle = value;
                  if (src.panner) {
                    src.panner.coneInnerAngle = value % 360;
                  }
                  break;
                case 4098:
                  if (!Number.isFinite(value)) {
                    AL.currentCtx.err = 40963;
                    return;
                  }
                  src.coneOuterAngle = value;
                  if (src.panner) {
                    src.panner.coneOuterAngle = value % 360;
                  }
                  break;
                case 4099:
                  if (!Number.isFinite(value) || value <= 0) {
                    AL.currentCtx.err = 40963;
                    return;
                  }
                  if (src.pitch === value) {
                    break;
                  }
                  src.pitch = value;
                  AL.updateSourceRate(src);
                  break;
                case 4100:
                  if (!Number.isFinite(value[0]) || !Number.isFinite(value[1]) || !Number.isFinite(value[2])) {
                    AL.currentCtx.err = 40963;
                    return;
                  }
                  src.position[0] = value[0];
                  src.position[1] = value[1];
                  src.position[2] = value[2];
                  AL.updateSourceSpace(src);
                  break;
                case 4101:
                  if (!Number.isFinite(value[0]) || !Number.isFinite(value[1]) || !Number.isFinite(value[2])) {
                    AL.currentCtx.err = 40963;
                    return;
                  }
                  src.direction[0] = value[0];
                  src.direction[1] = value[1];
                  src.direction[2] = value[2];
                  AL.updateSourceSpace(src);
                  break;
                case 4102:
                  if (!Number.isFinite(value[0]) || !Number.isFinite(value[1]) || !Number.isFinite(value[2])) {
                    AL.currentCtx.err = 40963;
                    return;
                  }
                  src.velocity[0] = value[0];
                  src.velocity[1] = value[1];
                  src.velocity[2] = value[2];
                  AL.updateSourceSpace(src);
                  break;
                case 4103:
                  if (value === 1) {
                    src.looping = true;
                    AL.updateSourceTime(src);
                    if (src.type === 4136 && src.audioQueue.length > 0) {
                      var audioSrc = src.audioQueue[0];
                      audioSrc.loop = true;
                      audioSrc._duration = Number.POSITIVE_INFINITY;
                    }
                  } else if (value === 0) {
                    src.looping = false;
                    var currentTime = AL.updateSourceTime(src);
                    if (src.type === 4136 && src.audioQueue.length > 0) {
                      var audioSrc = src.audioQueue[0];
                      audioSrc.loop = false;
                      audioSrc._duration = src.bufQueue[0].audioBuf.duration / src.playbackRate;
                      audioSrc._startTime = currentTime - src.bufOffset / src.playbackRate;
                    }
                  } else {
                    AL.currentCtx.err = 40963;
                    return;
                  }
                  break;
                case 4105:
                  if (src.state === 4114 || src.state === 4115) {
                    AL.currentCtx.err = 40964;
                    return;
                  }
                  if (value === 0) {
                    for (var i2 in src.bufQueue) {
                      src.bufQueue[i2].refCount--;
                    }
                    src.bufQueue.length = 1;
                    src.bufQueue[0] = AL.buffers[0];
                    src.bufsProcessed = 0;
                    src.type = 4144;
                  } else {
                    var buf = AL.buffers[value];
                    if (!buf) {
                      AL.currentCtx.err = 40963;
                      return;
                    }
                    for (var i2 in src.bufQueue) {
                      src.bufQueue[i2].refCount--;
                    }
                    src.bufQueue.length = 0;
                    buf.refCount++;
                    src.bufQueue = [buf];
                    src.bufsProcessed = 0;
                    src.type = 4136;
                  }
                  AL.initSourcePanner(src);
                  AL.scheduleSourceAudio(src);
                  break;
                case 4106:
                  if (!Number.isFinite(value) || value < 0) {
                    AL.currentCtx.err = 40963;
                    return;
                  }
                  src.gain.gain.value = value;
                  break;
                case 4109:
                  if (!Number.isFinite(value) || value < 0 || value > Math.min(src.maxGain, 1)) {
                    AL.currentCtx.err = 40963;
                    return;
                  }
                  src.minGain = value;
                  break;
                case 4110:
                  if (!Number.isFinite(value) || value < Math.max(0, src.minGain) || value > 1) {
                    AL.currentCtx.err = 40963;
                    return;
                  }
                  src.maxGain = value;
                  break;
                case 4128:
                  if (!Number.isFinite(value) || value < 0) {
                    AL.currentCtx.err = 40963;
                    return;
                  }
                  src.refDistance = value;
                  if (src.panner) {
                    src.panner.refDistance = value;
                  }
                  break;
                case 4129:
                  if (!Number.isFinite(value) || value < 0) {
                    AL.currentCtx.err = 40963;
                    return;
                  }
                  src.rolloffFactor = value;
                  if (src.panner) {
                    src.panner.rolloffFactor = value;
                  }
                  break;
                case 4130:
                  if (!Number.isFinite(value) || value < 0 || value > 1) {
                    AL.currentCtx.err = 40963;
                    return;
                  }
                  src.coneOuterGain = value;
                  if (src.panner) {
                    src.panner.coneOuterGain = value;
                  }
                  break;
                case 4131:
                  if (!Number.isFinite(value) || value < 0) {
                    AL.currentCtx.err = 40963;
                    return;
                  }
                  src.maxDistance = value;
                  if (src.panner) {
                    src.panner.maxDistance = value;
                  }
                  break;
                case 4132:
                  if (value < 0 || value > AL.sourceDuration(src)) {
                    AL.currentCtx.err = 40963;
                    return;
                  }
                  AL.sourceSeek(src, value);
                  break;
                case 4133:
                  var srcLen = AL.sourceDuration(src);
                  if (srcLen > 0) {
                    var frequency;
                    for (var bufId in src.bufQueue) {
                      if (bufId) {
                        frequency = src.bufQueue[bufId].frequency;
                        break;
                      }
                    }
                    value /= frequency;
                  }
                  if (value < 0 || value > srcLen) {
                    AL.currentCtx.err = 40963;
                    return;
                  }
                  AL.sourceSeek(src, value);
                  break;
                case 4134:
                  var srcLen = AL.sourceDuration(src);
                  if (srcLen > 0) {
                    var bytesPerSec;
                    for (var bufId in src.bufQueue) {
                      if (bufId) {
                        var buf = src.bufQueue[bufId];
                        bytesPerSec = buf.frequency * buf.bytesPerSample * buf.channels;
                        break;
                      }
                    }
                    value /= bytesPerSec;
                  }
                  if (value < 0 || value > srcLen) {
                    AL.currentCtx.err = 40963;
                    return;
                  }
                  AL.sourceSeek(src, value);
                  break;
                case 4628:
                  if (value !== 0 && value !== 1 && value !== 2) {
                    AL.currentCtx.err = 40963;
                    return;
                  }
                  src.spatialize = value;
                  AL.initSourcePanner(src);
                  break;
                case 8201:
                case 8202:
                case 8203:
                  AL.currentCtx.err = 40964;
                  break;
                case 53248:
                  switch (value) {
                    case 0:
                    case 53249:
                    case 53250:
                    case 53251:
                    case 53252:
                    case 53253:
                    case 53254:
                      src.distanceModel = value;
                      if (AL.currentCtx.sourceDistanceModel) {
                        AL.updateContextGlobal(AL.currentCtx);
                      }
                      break;
                    default:
                      AL.currentCtx.err = 40963;
                      return;
                  }
                  break;
                default:
                  AL.currentCtx.err = 40962;
                  return;
              }
            },
            captures: {},
            sharedCaptureAudioCtx: null,
            requireValidCaptureDevice: (deviceId, funcname) => {
              if (deviceId === 0) {
                AL.alcErr = 40961;
                return null;
              }
              var c = AL.captures[deviceId];
              if (!c) {
                AL.alcErr = 40961;
                return null;
              }
              var err2 = c.mediaStreamError;
              if (err2) {
                AL.alcErr = 40961;
                return null;
              }
              return c;
            }
          };
          var _alBuffer3f = (bufferId, param, value0, value1, value2) => {
            AL.setBufferParam("alBuffer3f", bufferId, param, null);
          };
          _alBuffer3f.sig = "viifff";
          var _alBuffer3i = (bufferId, param, value0, value1, value2) => {
            AL.setBufferParam("alBuffer3i", bufferId, param, null);
          };
          _alBuffer3i.sig = "viiiii";
          function _alBufferData(bufferId, format, pData, size, freq) {
            pData >>>= 0;
            if (!AL.currentCtx) {
              return;
            }
            var buf = AL.buffers[bufferId];
            if (!buf) {
              AL.currentCtx.err = 40963;
              return;
            }
            if (freq <= 0) {
              AL.currentCtx.err = 40963;
              return;
            }
            var audioBuf = null;
            try {
              switch (format) {
                case 4352:
                  if (size > 0) {
                    audioBuf = AL.currentCtx.audioCtx.createBuffer(1, size, freq);
                    var channel0 = audioBuf.getChannelData(0);
                    for (var i2 = 0; i2 < size; ++i2) {
                      channel0[i2] = HEAPU8[pData++ >>> 0] * 78125e-7 - 1;
                    }
                  }
                  buf.bytesPerSample = 1;
                  buf.channels = 1;
                  buf.length = size;
                  break;
                case 4353:
                  if (size > 0) {
                    audioBuf = AL.currentCtx.audioCtx.createBuffer(1, size >> 1, freq);
                    var channel0 = audioBuf.getChannelData(0);
                    pData >>= 1;
                    for (var i2 = 0; i2 < size >> 1; ++i2) {
                      channel0[i2] = HEAP16[pData++ >>> 0] * 30517578125e-15;
                    }
                  }
                  buf.bytesPerSample = 2;
                  buf.channels = 1;
                  buf.length = size >> 1;
                  break;
                case 4354:
                  if (size > 0) {
                    audioBuf = AL.currentCtx.audioCtx.createBuffer(2, size >> 1, freq);
                    var channel0 = audioBuf.getChannelData(0);
                    var channel1 = audioBuf.getChannelData(1);
                    for (var i2 = 0; i2 < size >> 1; ++i2) {
                      channel0[i2] = HEAPU8[pData++ >>> 0] * 78125e-7 - 1;
                      channel1[i2] = HEAPU8[pData++ >>> 0] * 78125e-7 - 1;
                    }
                  }
                  buf.bytesPerSample = 1;
                  buf.channels = 2;
                  buf.length = size >> 1;
                  break;
                case 4355:
                  if (size > 0) {
                    audioBuf = AL.currentCtx.audioCtx.createBuffer(2, size >> 2, freq);
                    var channel0 = audioBuf.getChannelData(0);
                    var channel1 = audioBuf.getChannelData(1);
                    pData >>= 1;
                    for (var i2 = 0; i2 < size >> 2; ++i2) {
                      channel0[i2] = HEAP16[pData++ >>> 0] * 30517578125e-15;
                      channel1[i2] = HEAP16[pData++ >>> 0] * 30517578125e-15;
                    }
                  }
                  buf.bytesPerSample = 2;
                  buf.channels = 2;
                  buf.length = size >> 2;
                  break;
                case 65552:
                  if (size > 0) {
                    audioBuf = AL.currentCtx.audioCtx.createBuffer(1, size >> 2, freq);
                    var channel0 = audioBuf.getChannelData(0);
                    pData >>= 2;
                    for (var i2 = 0; i2 < size >> 2; ++i2) {
                      channel0[i2] = HEAPF32[pData++ >>> 0];
                    }
                  }
                  buf.bytesPerSample = 4;
                  buf.channels = 1;
                  buf.length = size >> 2;
                  break;
                case 65553:
                  if (size > 0) {
                    audioBuf = AL.currentCtx.audioCtx.createBuffer(2, size >> 3, freq);
                    var channel0 = audioBuf.getChannelData(0);
                    var channel1 = audioBuf.getChannelData(1);
                    pData >>= 2;
                    for (var i2 = 0; i2 < size >> 3; ++i2) {
                      channel0[i2] = HEAPF32[pData++ >>> 0];
                      channel1[i2] = HEAPF32[pData++ >>> 0];
                    }
                  }
                  buf.bytesPerSample = 4;
                  buf.channels = 2;
                  buf.length = size >> 3;
                  break;
                default:
                  AL.currentCtx.err = 40963;
                  return;
              }
              buf.frequency = freq;
              buf.audioBuf = audioBuf;
            } catch (e) {
              AL.currentCtx.err = 40963;
              return;
            }
          }
          _alBufferData.sig = "viipii";
          var _alBufferf = (bufferId, param, value) => {
            AL.setBufferParam("alBufferf", bufferId, param, null);
          };
          _alBufferf.sig = "viif";
          function _alBufferfv(bufferId, param, pValues) {
            pValues >>>= 0;
            if (!AL.currentCtx) {
              return;
            }
            if (!pValues) {
              AL.currentCtx.err = 40963;
              return;
            }
            AL.setBufferParam("alBufferfv", bufferId, param, null);
          }
          _alBufferfv.sig = "viip";
          var _alBufferi = (bufferId, param, value) => {
            AL.setBufferParam("alBufferi", bufferId, param, null);
          };
          _alBufferi.sig = "viii";
          function _alBufferiv(bufferId, param, pValues) {
            pValues >>>= 0;
            if (!AL.currentCtx) {
              return;
            }
            if (!pValues) {
              AL.currentCtx.err = 40963;
              return;
            }
            switch (param) {
              case 8213:
                AL.paramArray[0] = HEAP32[pValues >>> 2 >>> 0];
                AL.paramArray[1] = HEAP32[pValues + 4 >>> 2 >>> 0];
                AL.setBufferParam("alBufferiv", bufferId, param, AL.paramArray);
                break;
              default:
                AL.setBufferParam("alBufferiv", bufferId, param, null);
                break;
            }
          }
          _alBufferiv.sig = "viip";
          function _alDeleteBuffers(count, pBufferIds) {
            pBufferIds >>>= 0;
            if (!AL.currentCtx) {
              return;
            }
            for (var i2 = 0; i2 < count; ++i2) {
              var bufId = HEAP32[pBufferIds + i2 * 4 >>> 2 >>> 0];
              if (bufId === 0) {
                continue;
              }
              if (!AL.buffers[bufId]) {
                AL.currentCtx.err = 40961;
                return;
              }
              if (AL.buffers[bufId].refCount) {
                AL.currentCtx.err = 40964;
                return;
              }
            }
            for (var i2 = 0; i2 < count; ++i2) {
              var bufId = HEAP32[pBufferIds + i2 * 4 >>> 2 >>> 0];
              if (bufId === 0) {
                continue;
              }
              AL.deviceRefCounts[AL.buffers[bufId].deviceId]--;
              delete AL.buffers[bufId];
              AL.freeIds.push(bufId);
            }
          }
          _alDeleteBuffers.sig = "vip";
          var _alSourcei = (sourceId, param, value) => {
            switch (param) {
              case 514:
              case 4097:
              case 4098:
              case 4103:
              case 4105:
              case 4128:
              case 4129:
              case 4131:
              case 4132:
              case 4133:
              case 4134:
              case 4628:
              case 8201:
              case 8202:
              case 53248:
                AL.setSourceParam("alSourcei", sourceId, param, value);
                break;
              default:
                AL.setSourceParam("alSourcei", sourceId, param, null);
                break;
            }
          };
          _alSourcei.sig = "viii";
          function _alDeleteSources(count, pSourceIds) {
            pSourceIds >>>= 0;
            if (!AL.currentCtx) {
              return;
            }
            for (var i2 = 0; i2 < count; ++i2) {
              var srcId = HEAP32[pSourceIds + i2 * 4 >>> 2 >>> 0];
              if (!AL.currentCtx.sources[srcId]) {
                AL.currentCtx.err = 40961;
                return;
              }
            }
            for (var i2 = 0; i2 < count; ++i2) {
              var srcId = HEAP32[pSourceIds + i2 * 4 >>> 2 >>> 0];
              AL.setSourceState(AL.currentCtx.sources[srcId], 4116);
              _alSourcei(srcId, 4105, 0);
              delete AL.currentCtx.sources[srcId];
              AL.freeIds.push(srcId);
            }
          }
          _alDeleteSources.sig = "vip";
          var _alDisable = (param) => {
            if (!AL.currentCtx) {
              return;
            }
            switch (param) {
              case "AL_SOURCE_DISTANCE_MODEL":
                AL.currentCtx.sourceDistanceModel = false;
                AL.updateContextGlobal(AL.currentCtx);
                break;
              default:
                AL.currentCtx.err = 40962;
                return;
            }
          };
          _alDisable.sig = "vi";
          var _alDistanceModel = (model) => {
            AL.setGlobalParam("alDistanceModel", 53248, model);
          };
          _alDistanceModel.sig = "vi";
          var _alDopplerFactor = (value) => {
            AL.setGlobalParam("alDopplerFactor", 49152, value);
          };
          _alDopplerFactor.sig = "vf";
          var _alDopplerVelocity = (value) => {
            warnOnce("alDopplerVelocity() is deprecated, and only kept for compatibility with OpenAL 1.0. Use alSpeedOfSound() instead.");
            if (!AL.currentCtx) {
              return;
            }
            if (value <= 0) {
              AL.currentCtx.err = 40963;
              return;
            }
          };
          _alDopplerVelocity.sig = "vf";
          var _alEnable = (param) => {
            if (!AL.currentCtx) {
              return;
            }
            switch (param) {
              case "AL_SOURCE_DISTANCE_MODEL":
                AL.currentCtx.sourceDistanceModel = true;
                AL.updateContextGlobal(AL.currentCtx);
                break;
              default:
                AL.currentCtx.err = 40962;
                return;
            }
          };
          _alEnable.sig = "vi";
          function _alGenBuffers(count, pBufferIds) {
            pBufferIds >>>= 0;
            if (!AL.currentCtx) {
              return;
            }
            for (var i2 = 0; i2 < count; ++i2) {
              var buf = {
                deviceId: AL.currentCtx.deviceId,
                id: AL.newId(),
                refCount: 0,
                audioBuf: null,
                frequency: 0,
                bytesPerSample: 2,
                channels: 1,
                length: 0
              };
              AL.deviceRefCounts[buf.deviceId]++;
              AL.buffers[buf.id] = buf;
              HEAP32[pBufferIds + i2 * 4 >>> 2 >>> 0] = buf.id;
            }
          }
          _alGenBuffers.sig = "vip";
          function _alGenSources(count, pSourceIds) {
            pSourceIds >>>= 0;
            if (!AL.currentCtx) {
              return;
            }
            for (var i2 = 0; i2 < count; ++i2) {
              var gain = AL.currentCtx.audioCtx.createGain();
              gain.connect(AL.currentCtx.gain);
              var src = {
                context: AL.currentCtx,
                id: AL.newId(),
                type: 4144,
                state: 4113,
                bufQueue: [AL.buffers[0]],
                audioQueue: [],
                looping: false,
                pitch: 1,
                dopplerShift: 1,
                gain,
                minGain: 0,
                maxGain: 1,
                panner: null,
                bufsProcessed: 0,
                bufStartTime: Number.NEGATIVE_INFINITY,
                bufOffset: 0,
                relative: false,
                refDistance: 1,
                maxDistance: 340282e33,
                rolloffFactor: 1,
                position: [0, 0, 0],
                velocity: [0, 0, 0],
                direction: [0, 0, 0],
                coneOuterGain: 0,
                coneInnerAngle: 360,
                coneOuterAngle: 360,
                distanceModel: 53250,
                spatialize: 2,
                get playbackRate() {
                  return this.pitch * this.dopplerShift;
                }
              };
              AL.currentCtx.sources[src.id] = src;
              HEAP32[pSourceIds + i2 * 4 >>> 2 >>> 0] = src.id;
            }
          }
          _alGenSources.sig = "vip";
          var _alGetBoolean = (param) => {
            var val = AL.getGlobalParam("alGetBoolean", param);
            if (val === null) {
              return 0;
            }
            switch (param) {
              case 49152:
              case 49155:
              case 53248:
                return val !== 0 ? 1 : 0;
              default:
                AL.currentCtx.err = 40962;
                return 0;
            }
          };
          _alGetBoolean.sig = "ii";
          function _alGetBooleanv(param, pValues) {
            pValues >>>= 0;
            var val = AL.getGlobalParam("alGetBooleanv", param);
            if (val === null || !pValues) {
              return;
            }
            switch (param) {
              case 49152:
              case 49155:
              case 53248:
                HEAP8[pValues >>> 0 >>> 0] = val;
                break;
              default:
                AL.currentCtx.err = 40962;
                return;
            }
          }
          _alGetBooleanv.sig = "vip";
          function _alGetBuffer3f(bufferId, param, pValue0, pValue1, pValue2) {
            pValue0 >>>= 0;
            pValue1 >>>= 0;
            pValue2 >>>= 0;
            var val = AL.getBufferParam("alGetBuffer3f", bufferId, param);
            if (val === null) {
              return;
            }
            if (!pValue0 || !pValue1 || !pValue2) {
              AL.currentCtx.err = 40963;
              return;
            }
            AL.currentCtx.err = 40962;
          }
          _alGetBuffer3f.sig = "viippp";
          function _alGetBuffer3i(bufferId, param, pValue0, pValue1, pValue2) {
            pValue0 >>>= 0;
            pValue1 >>>= 0;
            pValue2 >>>= 0;
            var val = AL.getBufferParam("alGetBuffer3i", bufferId, param);
            if (val === null) {
              return;
            }
            if (!pValue0 || !pValue1 || !pValue2) {
              AL.currentCtx.err = 40963;
              return;
            }
            AL.currentCtx.err = 40962;
          }
          _alGetBuffer3i.sig = "viippp";
          function _alGetBufferf(bufferId, param, pValue) {
            pValue >>>= 0;
            var val = AL.getBufferParam("alGetBufferf", bufferId, param);
            if (val === null) {
              return;
            }
            if (!pValue) {
              AL.currentCtx.err = 40963;
              return;
            }
            AL.currentCtx.err = 40962;
          }
          _alGetBufferf.sig = "viip";
          function _alGetBufferfv(bufferId, param, pValues) {
            pValues >>>= 0;
            var val = AL.getBufferParam("alGetBufferfv", bufferId, param);
            if (val === null) {
              return;
            }
            if (!pValues) {
              AL.currentCtx.err = 40963;
              return;
            }
            AL.currentCtx.err = 40962;
          }
          _alGetBufferfv.sig = "viip";
          function _alGetBufferi(bufferId, param, pValue) {
            pValue >>>= 0;
            var val = AL.getBufferParam("alGetBufferi", bufferId, param);
            if (val === null) {
              return;
            }
            if (!pValue) {
              AL.currentCtx.err = 40963;
              return;
            }
            switch (param) {
              case 8193:
              case 8194:
              case 8195:
              case 8196:
                HEAP32[pValue >>> 2 >>> 0] = val;
                break;
              default:
                AL.currentCtx.err = 40962;
                return;
            }
          }
          _alGetBufferi.sig = "viip";
          function _alGetBufferiv(bufferId, param, pValues) {
            pValues >>>= 0;
            var val = AL.getBufferParam("alGetBufferiv", bufferId, param);
            if (val === null) {
              return;
            }
            if (!pValues) {
              AL.currentCtx.err = 40963;
              return;
            }
            switch (param) {
              case 8193:
              case 8194:
              case 8195:
              case 8196:
                HEAP32[pValues >>> 2 >>> 0] = val;
                break;
              case 8213:
                HEAP32[pValues >>> 2 >>> 0] = val[0];
                HEAP32[pValues + 4 >>> 2 >>> 0] = val[1];
                break;
              default:
                AL.currentCtx.err = 40962;
                return;
            }
          }
          _alGetBufferiv.sig = "viip";
          var _alGetDouble = (param) => {
            var val = AL.getGlobalParam("alGetDouble", param);
            if (val === null) {
              return 0;
            }
            switch (param) {
              case 49152:
              case 49155:
              case 53248:
                return val;
              default:
                AL.currentCtx.err = 40962;
                return 0;
            }
          };
          _alGetDouble.sig = "di";
          function _alGetDoublev(param, pValues) {
            pValues >>>= 0;
            var val = AL.getGlobalParam("alGetDoublev", param);
            if (val === null || !pValues) {
              return;
            }
            switch (param) {
              case 49152:
              case 49155:
              case 53248:
                HEAPF64[pValues >>> 3 >>> 0] = val;
                break;
              default:
                AL.currentCtx.err = 40962;
                return;
            }
          }
          _alGetDoublev.sig = "vip";
          function _alGetEnumValue(pEnumName) {
            pEnumName >>>= 0;
            if (!AL.currentCtx) {
              return 0;
            }
            if (!pEnumName) {
              AL.currentCtx.err = 40963;
              return 0;
            }
            var name2 = UTF8ToString(pEnumName);
            switch (name2) {
              case "AL_BITS":
                return 8194;
              case "AL_BUFFER":
                return 4105;
              case "AL_BUFFERS_PROCESSED":
                return 4118;
              case "AL_BUFFERS_QUEUED":
                return 4117;
              case "AL_BYTE_OFFSET":
                return 4134;
              case "AL_CHANNELS":
                return 8195;
              case "AL_CONE_INNER_ANGLE":
                return 4097;
              case "AL_CONE_OUTER_ANGLE":
                return 4098;
              case "AL_CONE_OUTER_GAIN":
                return 4130;
              case "AL_DIRECTION":
                return 4101;
              case "AL_DISTANCE_MODEL":
                return 53248;
              case "AL_DOPPLER_FACTOR":
                return 49152;
              case "AL_DOPPLER_VELOCITY":
                return 49153;
              case "AL_EXPONENT_DISTANCE":
                return 53253;
              case "AL_EXPONENT_DISTANCE_CLAMPED":
                return 53254;
              case "AL_EXTENSIONS":
                return 45060;
              case "AL_FORMAT_MONO16":
                return 4353;
              case "AL_FORMAT_MONO8":
                return 4352;
              case "AL_FORMAT_STEREO16":
                return 4355;
              case "AL_FORMAT_STEREO8":
                return 4354;
              case "AL_FREQUENCY":
                return 8193;
              case "AL_GAIN":
                return 4106;
              case "AL_INITIAL":
                return 4113;
              case "AL_INVALID":
                return -1;
              case "AL_ILLEGAL_ENUM":
              case "AL_INVALID_ENUM":
                return 40962;
              case "AL_INVALID_NAME":
                return 40961;
              case "AL_ILLEGAL_COMMAND":
              case "AL_INVALID_OPERATION":
                return 40964;
              case "AL_INVALID_VALUE":
                return 40963;
              case "AL_INVERSE_DISTANCE":
                return 53249;
              case "AL_INVERSE_DISTANCE_CLAMPED":
                return 53250;
              case "AL_LINEAR_DISTANCE":
                return 53251;
              case "AL_LINEAR_DISTANCE_CLAMPED":
                return 53252;
              case "AL_LOOPING":
                return 4103;
              case "AL_MAX_DISTANCE":
                return 4131;
              case "AL_MAX_GAIN":
                return 4110;
              case "AL_MIN_GAIN":
                return 4109;
              case "AL_NONE":
                return 0;
              case "AL_NO_ERROR":
                return 0;
              case "AL_ORIENTATION":
                return 4111;
              case "AL_OUT_OF_MEMORY":
                return 40965;
              case "AL_PAUSED":
                return 4115;
              case "AL_PENDING":
                return 8209;
              case "AL_PITCH":
                return 4099;
              case "AL_PLAYING":
                return 4114;
              case "AL_POSITION":
                return 4100;
              case "AL_PROCESSED":
                return 8210;
              case "AL_REFERENCE_DISTANCE":
                return 4128;
              case "AL_RENDERER":
                return 45059;
              case "AL_ROLLOFF_FACTOR":
                return 4129;
              case "AL_SAMPLE_OFFSET":
                return 4133;
              case "AL_SEC_OFFSET":
                return 4132;
              case "AL_SIZE":
                return 8196;
              case "AL_SOURCE_RELATIVE":
                return 514;
              case "AL_SOURCE_STATE":
                return 4112;
              case "AL_SOURCE_TYPE":
                return 4135;
              case "AL_SPEED_OF_SOUND":
                return 49155;
              case "AL_STATIC":
                return 4136;
              case "AL_STOPPED":
                return 4116;
              case "AL_STREAMING":
                return 4137;
              case "AL_UNDETERMINED":
                return 4144;
              case "AL_UNUSED":
                return 8208;
              case "AL_VELOCITY":
                return 4102;
              case "AL_VENDOR":
                return 45057;
              case "AL_VERSION":
                return 45058;
              case "AL_AUTO_SOFT":
                return 2;
              case "AL_SOURCE_DISTANCE_MODEL":
                return 512;
              case "AL_SOURCE_SPATIALIZE_SOFT":
                return 4628;
              case "AL_LOOP_POINTS_SOFT":
                return 8213;
              case "AL_BYTE_LENGTH_SOFT":
                return 8201;
              case "AL_SAMPLE_LENGTH_SOFT":
                return 8202;
              case "AL_SEC_LENGTH_SOFT":
                return 8203;
              case "AL_FORMAT_MONO_FLOAT32":
                return 65552;
              case "AL_FORMAT_STEREO_FLOAT32":
                return 65553;
              default:
                AL.currentCtx.err = 40963;
                return 0;
            }
          }
          _alGetEnumValue.sig = "ip";
          var _alGetError = () => {
            if (!AL.currentCtx) {
              return 40964;
            }
            var err2 = AL.currentCtx.err;
            AL.currentCtx.err = 0;
            return err2;
          };
          _alGetError.sig = "i";
          var _alGetFloat = (param) => {
            var val = AL.getGlobalParam("alGetFloat", param);
            if (val === null) {
              return 0;
            }
            switch (param) {
              case 49152:
              case 49155:
              case 53248:
                return val;
              default:
                return 0;
            }
          };
          _alGetFloat.sig = "fi";
          function _alGetFloatv(param, pValues) {
            pValues >>>= 0;
            var val = AL.getGlobalParam("alGetFloatv", param);
            if (val === null || !pValues) {
              return;
            }
            switch (param) {
              case 49152:
              case 49155:
              case 53248:
                HEAPF32[pValues >>> 2 >>> 0] = val;
                break;
              default:
                AL.currentCtx.err = 40962;
                return;
            }
          }
          _alGetFloatv.sig = "vip";
          var _alGetInteger = (param) => {
            var val = AL.getGlobalParam("alGetInteger", param);
            if (val === null) {
              return 0;
            }
            switch (param) {
              case 49152:
              case 49155:
              case 53248:
                return val;
              default:
                AL.currentCtx.err = 40962;
                return 0;
            }
          };
          _alGetInteger.sig = "ii";
          function _alGetIntegerv(param, pValues) {
            pValues >>>= 0;
            var val = AL.getGlobalParam("alGetIntegerv", param);
            if (val === null || !pValues) {
              return;
            }
            switch (param) {
              case 49152:
              case 49155:
              case 53248:
                HEAP32[pValues >>> 2 >>> 0] = val;
                break;
              default:
                AL.currentCtx.err = 40962;
                return;
            }
          }
          _alGetIntegerv.sig = "vip";
          function _alGetListener3f(param, pValue0, pValue1, pValue2) {
            pValue0 >>>= 0;
            pValue1 >>>= 0;
            pValue2 >>>= 0;
            var val = AL.getListenerParam("alGetListener3f", param);
            if (val === null) {
              return;
            }
            if (!pValue0 || !pValue1 || !pValue2) {
              AL.currentCtx.err = 40963;
              return;
            }
            switch (param) {
              case 4100:
              case 4102:
                HEAPF32[pValue0 >>> 2 >>> 0] = val[0];
                HEAPF32[pValue1 >>> 2 >>> 0] = val[1];
                HEAPF32[pValue2 >>> 2 >>> 0] = val[2];
                break;
              default:
                AL.currentCtx.err = 40962;
                return;
            }
          }
          _alGetListener3f.sig = "vippp";
          function _alGetListener3i(param, pValue0, pValue1, pValue2) {
            pValue0 >>>= 0;
            pValue1 >>>= 0;
            pValue2 >>>= 0;
            var val = AL.getListenerParam("alGetListener3i", param);
            if (val === null) {
              return;
            }
            if (!pValue0 || !pValue1 || !pValue2) {
              AL.currentCtx.err = 40963;
              return;
            }
            switch (param) {
              case 4100:
              case 4102:
                HEAP32[pValue0 >>> 2 >>> 0] = val[0];
                HEAP32[pValue1 >>> 2 >>> 0] = val[1];
                HEAP32[pValue2 >>> 2 >>> 0] = val[2];
                break;
              default:
                AL.currentCtx.err = 40962;
                return;
            }
          }
          _alGetListener3i.sig = "vippp";
          function _alGetListenerf(param, pValue) {
            pValue >>>= 0;
            var val = AL.getListenerParam("alGetListenerf", param);
            if (val === null) {
              return;
            }
            if (!pValue) {
              AL.currentCtx.err = 40963;
              return;
            }
            switch (param) {
              case 4106:
                HEAPF32[pValue >>> 2 >>> 0] = val;
                break;
              default:
                AL.currentCtx.err = 40962;
                return;
            }
          }
          _alGetListenerf.sig = "vip";
          function _alGetListenerfv(param, pValues) {
            pValues >>>= 0;
            var val = AL.getListenerParam("alGetListenerfv", param);
            if (val === null) {
              return;
            }
            if (!pValues) {
              AL.currentCtx.err = 40963;
              return;
            }
            switch (param) {
              case 4100:
              case 4102:
                HEAPF32[pValues >>> 2 >>> 0] = val[0];
                HEAPF32[pValues + 4 >>> 2 >>> 0] = val[1];
                HEAPF32[pValues + 8 >>> 2 >>> 0] = val[2];
                break;
              case 4111:
                HEAPF32[pValues >>> 2 >>> 0] = val[0];
                HEAPF32[pValues + 4 >>> 2 >>> 0] = val[1];
                HEAPF32[pValues + 8 >>> 2 >>> 0] = val[2];
                HEAPF32[pValues + 12 >>> 2 >>> 0] = val[3];
                HEAPF32[pValues + 16 >>> 2 >>> 0] = val[4];
                HEAPF32[pValues + 20 >>> 2 >>> 0] = val[5];
                break;
              default:
                AL.currentCtx.err = 40962;
                return;
            }
          }
          _alGetListenerfv.sig = "vip";
          function _alGetListeneri(param, pValue) {
            pValue >>>= 0;
            var val = AL.getListenerParam("alGetListeneri", param);
            if (val === null) {
              return;
            }
            if (!pValue) {
              AL.currentCtx.err = 40963;
              return;
            }
            AL.currentCtx.err = 40962;
          }
          _alGetListeneri.sig = "vip";
          function _alGetListeneriv(param, pValues) {
            pValues >>>= 0;
            var val = AL.getListenerParam("alGetListeneriv", param);
            if (val === null) {
              return;
            }
            if (!pValues) {
              AL.currentCtx.err = 40963;
              return;
            }
            switch (param) {
              case 4100:
              case 4102:
                HEAP32[pValues >>> 2 >>> 0] = val[0];
                HEAP32[pValues + 4 >>> 2 >>> 0] = val[1];
                HEAP32[pValues + 8 >>> 2 >>> 0] = val[2];
                break;
              case 4111:
                HEAP32[pValues >>> 2 >>> 0] = val[0];
                HEAP32[pValues + 4 >>> 2 >>> 0] = val[1];
                HEAP32[pValues + 8 >>> 2 >>> 0] = val[2];
                HEAP32[pValues + 12 >>> 2 >>> 0] = val[3];
                HEAP32[pValues + 16 >>> 2 >>> 0] = val[4];
                HEAP32[pValues + 20 >>> 2 >>> 0] = val[5];
                break;
              default:
                AL.currentCtx.err = 40962;
                return;
            }
          }
          _alGetListeneriv.sig = "vip";
          function _alGetSource3f(sourceId, param, pValue0, pValue1, pValue2) {
            pValue0 >>>= 0;
            pValue1 >>>= 0;
            pValue2 >>>= 0;
            var val = AL.getSourceParam("alGetSource3f", sourceId, param);
            if (val === null) {
              return;
            }
            if (!pValue0 || !pValue1 || !pValue2) {
              AL.currentCtx.err = 40963;
              return;
            }
            switch (param) {
              case 4100:
              case 4101:
              case 4102:
                HEAPF32[pValue0 >>> 2 >>> 0] = val[0];
                HEAPF32[pValue1 >>> 2 >>> 0] = val[1];
                HEAPF32[pValue2 >>> 2 >>> 0] = val[2];
                break;
              default:
                AL.currentCtx.err = 40962;
                return;
            }
          }
          _alGetSource3f.sig = "viippp";
          function _alGetSource3i(sourceId, param, pValue0, pValue1, pValue2) {
            pValue0 >>>= 0;
            pValue1 >>>= 0;
            pValue2 >>>= 0;
            var val = AL.getSourceParam("alGetSource3i", sourceId, param);
            if (val === null) {
              return;
            }
            if (!pValue0 || !pValue1 || !pValue2) {
              AL.currentCtx.err = 40963;
              return;
            }
            switch (param) {
              case 4100:
              case 4101:
              case 4102:
                HEAP32[pValue0 >>> 2 >>> 0] = val[0];
                HEAP32[pValue1 >>> 2 >>> 0] = val[1];
                HEAP32[pValue2 >>> 2 >>> 0] = val[2];
                break;
              default:
                AL.currentCtx.err = 40962;
                return;
            }
          }
          _alGetSource3i.sig = "viippp";
          function _alGetSourcef(sourceId, param, pValue) {
            pValue >>>= 0;
            var val = AL.getSourceParam("alGetSourcef", sourceId, param);
            if (val === null) {
              return;
            }
            if (!pValue) {
              AL.currentCtx.err = 40963;
              return;
            }
            switch (param) {
              case 4097:
              case 4098:
              case 4099:
              case 4106:
              case 4109:
              case 4110:
              case 4128:
              case 4129:
              case 4130:
              case 4131:
              case 4132:
              case 4133:
              case 4134:
              case 8203:
                HEAPF32[pValue >>> 2 >>> 0] = val;
                break;
              default:
                AL.currentCtx.err = 40962;
                return;
            }
          }
          _alGetSourcef.sig = "viip";
          function _alGetSourcefv(sourceId, param, pValues) {
            pValues >>>= 0;
            var val = AL.getSourceParam("alGetSourcefv", sourceId, param);
            if (val === null) {
              return;
            }
            if (!pValues) {
              AL.currentCtx.err = 40963;
              return;
            }
            switch (param) {
              case 4097:
              case 4098:
              case 4099:
              case 4106:
              case 4109:
              case 4110:
              case 4128:
              case 4129:
              case 4130:
              case 4131:
              case 4132:
              case 4133:
              case 4134:
              case 8203:
                HEAPF32[pValues >>> 2 >>> 0] = val[0];
                break;
              case 4100:
              case 4101:
              case 4102:
                HEAPF32[pValues >>> 2 >>> 0] = val[0];
                HEAPF32[pValues + 4 >>> 2 >>> 0] = val[1];
                HEAPF32[pValues + 8 >>> 2 >>> 0] = val[2];
                break;
              default:
                AL.currentCtx.err = 40962;
                return;
            }
          }
          _alGetSourcefv.sig = "viip";
          function _alGetSourcei(sourceId, param, pValue) {
            pValue >>>= 0;
            var val = AL.getSourceParam("alGetSourcei", sourceId, param);
            if (val === null) {
              return;
            }
            if (!pValue) {
              AL.currentCtx.err = 40963;
              return;
            }
            switch (param) {
              case 514:
              case 4097:
              case 4098:
              case 4103:
              case 4105:
              case 4112:
              case 4117:
              case 4118:
              case 4128:
              case 4129:
              case 4131:
              case 4132:
              case 4133:
              case 4134:
              case 4135:
              case 4628:
              case 8201:
              case 8202:
              case 53248:
                HEAP32[pValue >>> 2 >>> 0] = val;
                break;
              default:
                AL.currentCtx.err = 40962;
                return;
            }
          }
          _alGetSourcei.sig = "viip";
          function _alGetSourceiv(sourceId, param, pValues) {
            pValues >>>= 0;
            var val = AL.getSourceParam("alGetSourceiv", sourceId, param);
            if (val === null) {
              return;
            }
            if (!pValues) {
              AL.currentCtx.err = 40963;
              return;
            }
            switch (param) {
              case 514:
              case 4097:
              case 4098:
              case 4103:
              case 4105:
              case 4112:
              case 4117:
              case 4118:
              case 4128:
              case 4129:
              case 4131:
              case 4132:
              case 4133:
              case 4134:
              case 4135:
              case 4628:
              case 8201:
              case 8202:
              case 53248:
                HEAP32[pValues >>> 2 >>> 0] = val;
                break;
              case 4100:
              case 4101:
              case 4102:
                HEAP32[pValues >>> 2 >>> 0] = val[0];
                HEAP32[pValues + 4 >>> 2 >>> 0] = val[1];
                HEAP32[pValues + 8 >>> 2 >>> 0] = val[2];
                break;
              default:
                AL.currentCtx.err = 40962;
                return;
            }
          }
          _alGetSourceiv.sig = "viip";
          function _alGetString(param) {
            if (AL.stringCache[param]) {
              return AL.stringCache[param];
            }
            var ret;
            switch (param) {
              case 0:
                ret = "No Error";
                break;
              case 40961:
                ret = "Invalid Name";
                break;
              case 40962:
                ret = "Invalid Enum";
                break;
              case 40963:
                ret = "Invalid Value";
                break;
              case 40964:
                ret = "Invalid Operation";
                break;
              case 40965:
                ret = "Out of Memory";
                break;
              case 45057:
                ret = "Emscripten";
                break;
              case 45058:
                ret = "1.1";
                break;
              case 45059:
                ret = "WebAudio";
                break;
              case 45060:
                ret = "";
                for (var ext in AL.AL_EXTENSIONS) {
                  ret = ret.concat(ext);
                  ret = ret.concat(" ");
                }
                ret = ret.trim();
                break;
              default:
                if (AL.currentCtx) {
                  AL.currentCtx.err = 40962;
                } else {
                }
                return 0;
            }
            ret = stringToNewUTF8(ret);
            AL.stringCache[param] = ret;
            return ret;
          }
          _alGetString.sig = "pi";
          var _alIsBuffer = (bufferId) => {
            if (!AL.currentCtx) {
              return false;
            }
            if (bufferId > AL.buffers.length) {
              return false;
            }
            if (!AL.buffers[bufferId]) {
              return false;
            }
            return true;
          };
          _alIsBuffer.sig = "ii";
          var _alIsEnabled = (param) => {
            if (!AL.currentCtx) {
              return 0;
            }
            switch (param) {
              case "AL_SOURCE_DISTANCE_MODEL":
                return AL.currentCtx.sourceDistanceModel ? 0 : 1;
              default:
                AL.currentCtx.err = 40962;
                return 0;
            }
          };
          _alIsEnabled.sig = "ii";
          function _alIsExtensionPresent(pExtName) {
            pExtName >>>= 0;
            var name2 = UTF8ToString(pExtName);
            return AL.AL_EXTENSIONS[name2] ? 1 : 0;
          }
          _alIsExtensionPresent.sig = "ip";
          var _alIsSource = (sourceId) => {
            if (!AL.currentCtx) {
              return false;
            }
            if (!AL.currentCtx.sources[sourceId]) {
              return false;
            }
            return true;
          };
          _alIsSource.sig = "ii";
          var _alListener3f = (param, value0, value1, value2) => {
            switch (param) {
              case 4100:
              case 4102:
                AL.paramArray[0] = value0;
                AL.paramArray[1] = value1;
                AL.paramArray[2] = value2;
                AL.setListenerParam("alListener3f", param, AL.paramArray);
                break;
              default:
                AL.setListenerParam("alListener3f", param, null);
                break;
            }
          };
          _alListener3f.sig = "vifff";
          var _alListener3i = (param, value0, value1, value2) => {
            switch (param) {
              case 4100:
              case 4102:
                AL.paramArray[0] = value0;
                AL.paramArray[1] = value1;
                AL.paramArray[2] = value2;
                AL.setListenerParam("alListener3i", param, AL.paramArray);
                break;
              default:
                AL.setListenerParam("alListener3i", param, null);
                break;
            }
          };
          _alListener3i.sig = "viiii";
          var _alListenerf = (param, value) => {
            switch (param) {
              case 4106:
                AL.setListenerParam("alListenerf", param, value);
                break;
              default:
                AL.setListenerParam("alListenerf", param, null);
                break;
            }
          };
          _alListenerf.sig = "vif";
          function _alListenerfv(param, pValues) {
            pValues >>>= 0;
            if (!AL.currentCtx) {
              return;
            }
            if (!pValues) {
              AL.currentCtx.err = 40963;
              return;
            }
            switch (param) {
              case 4100:
              case 4102:
                AL.paramArray[0] = HEAPF32[pValues >>> 2 >>> 0];
                AL.paramArray[1] = HEAPF32[pValues + 4 >>> 2 >>> 0];
                AL.paramArray[2] = HEAPF32[pValues + 8 >>> 2 >>> 0];
                AL.setListenerParam("alListenerfv", param, AL.paramArray);
                break;
              case 4111:
                AL.paramArray[0] = HEAPF32[pValues >>> 2 >>> 0];
                AL.paramArray[1] = HEAPF32[pValues + 4 >>> 2 >>> 0];
                AL.paramArray[2] = HEAPF32[pValues + 8 >>> 2 >>> 0];
                AL.paramArray[3] = HEAPF32[pValues + 12 >>> 2 >>> 0];
                AL.paramArray[4] = HEAPF32[pValues + 16 >>> 2 >>> 0];
                AL.paramArray[5] = HEAPF32[pValues + 20 >>> 2 >>> 0];
                AL.setListenerParam("alListenerfv", param, AL.paramArray);
                break;
              default:
                AL.setListenerParam("alListenerfv", param, null);
                break;
            }
          }
          _alListenerfv.sig = "vip";
          var _alListeneri = (param, value) => {
            AL.setListenerParam("alListeneri", param, null);
          };
          _alListeneri.sig = "vii";
          function _alListeneriv(param, pValues) {
            pValues >>>= 0;
            if (!AL.currentCtx) {
              return;
            }
            if (!pValues) {
              AL.currentCtx.err = 40963;
              return;
            }
            switch (param) {
              case 4100:
              case 4102:
                AL.paramArray[0] = HEAP32[pValues >>> 2 >>> 0];
                AL.paramArray[1] = HEAP32[pValues + 4 >>> 2 >>> 0];
                AL.paramArray[2] = HEAP32[pValues + 8 >>> 2 >>> 0];
                AL.setListenerParam("alListeneriv", param, AL.paramArray);
                break;
              case 4111:
                AL.paramArray[0] = HEAP32[pValues >>> 2 >>> 0];
                AL.paramArray[1] = HEAP32[pValues + 4 >>> 2 >>> 0];
                AL.paramArray[2] = HEAP32[pValues + 8 >>> 2 >>> 0];
                AL.paramArray[3] = HEAP32[pValues + 12 >>> 2 >>> 0];
                AL.paramArray[4] = HEAP32[pValues + 16 >>> 2 >>> 0];
                AL.paramArray[5] = HEAP32[pValues + 20 >>> 2 >>> 0];
                AL.setListenerParam("alListeneriv", param, AL.paramArray);
                break;
              default:
                AL.setListenerParam("alListeneriv", param, null);
                break;
            }
          }
          _alListeneriv.sig = "vip";
          var _alSource3f = (sourceId, param, value0, value1, value2) => {
            switch (param) {
              case 4100:
              case 4101:
              case 4102:
                AL.paramArray[0] = value0;
                AL.paramArray[1] = value1;
                AL.paramArray[2] = value2;
                AL.setSourceParam("alSource3f", sourceId, param, AL.paramArray);
                break;
              default:
                AL.setSourceParam("alSource3f", sourceId, param, null);
                break;
            }
          };
          _alSource3f.sig = "viifff";
          var _alSource3i = (sourceId, param, value0, value1, value2) => {
            switch (param) {
              case 4100:
              case 4101:
              case 4102:
                AL.paramArray[0] = value0;
                AL.paramArray[1] = value1;
                AL.paramArray[2] = value2;
                AL.setSourceParam("alSource3i", sourceId, param, AL.paramArray);
                break;
              default:
                AL.setSourceParam("alSource3i", sourceId, param, null);
                break;
            }
          };
          _alSource3i.sig = "viiiii";
          var _alSourcePause = (sourceId) => {
            if (!AL.currentCtx) {
              return;
            }
            var src = AL.currentCtx.sources[sourceId];
            if (!src) {
              AL.currentCtx.err = 40961;
              return;
            }
            AL.setSourceState(src, 4115);
          };
          _alSourcePause.sig = "vi";
          function _alSourcePausev(count, pSourceIds) {
            pSourceIds >>>= 0;
            if (!AL.currentCtx) {
              return;
            }
            if (!pSourceIds) {
              AL.currentCtx.err = 40963;
            }
            for (var i2 = 0; i2 < count; ++i2) {
              if (!AL.currentCtx.sources[HEAP32[pSourceIds + i2 * 4 >>> 2 >>> 0]]) {
                AL.currentCtx.err = 40961;
                return;
              }
            }
            for (var i2 = 0; i2 < count; ++i2) {
              var srcId = HEAP32[pSourceIds + i2 * 4 >>> 2 >>> 0];
              AL.setSourceState(AL.currentCtx.sources[srcId], 4115);
            }
          }
          _alSourcePausev.sig = "vip";
          var _alSourcePlay = (sourceId) => {
            if (!AL.currentCtx) {
              return;
            }
            var src = AL.currentCtx.sources[sourceId];
            if (!src) {
              AL.currentCtx.err = 40961;
              return;
            }
            AL.setSourceState(src, 4114);
          };
          _alSourcePlay.sig = "vi";
          function _alSourcePlayv(count, pSourceIds) {
            pSourceIds >>>= 0;
            if (!AL.currentCtx) {
              return;
            }
            if (!pSourceIds) {
              AL.currentCtx.err = 40963;
            }
            for (var i2 = 0; i2 < count; ++i2) {
              if (!AL.currentCtx.sources[HEAP32[pSourceIds + i2 * 4 >>> 2 >>> 0]]) {
                AL.currentCtx.err = 40961;
                return;
              }
            }
            for (var i2 = 0; i2 < count; ++i2) {
              var srcId = HEAP32[pSourceIds + i2 * 4 >>> 2 >>> 0];
              AL.setSourceState(AL.currentCtx.sources[srcId], 4114);
            }
          }
          _alSourcePlayv.sig = "vip";
          function _alSourceQueueBuffers(sourceId, count, pBufferIds) {
            pBufferIds >>>= 0;
            if (!AL.currentCtx) {
              return;
            }
            var src = AL.currentCtx.sources[sourceId];
            if (!src) {
              AL.currentCtx.err = 40961;
              return;
            }
            if (src.type === 4136) {
              AL.currentCtx.err = 40964;
              return;
            }
            if (count === 0) {
              return;
            }
            var templateBuf = AL.buffers[0];
            for (var i2 = 0; i2 < src.bufQueue.length; i2++) {
              if (src.bufQueue[i2].id !== 0) {
                templateBuf = src.bufQueue[i2];
                break;
              }
            }
            for (var i2 = 0; i2 < count; ++i2) {
              var bufId = HEAP32[pBufferIds + i2 * 4 >>> 2 >>> 0];
              var buf = AL.buffers[bufId];
              if (!buf) {
                AL.currentCtx.err = 40961;
                return;
              }
              if (templateBuf.id !== 0 && (buf.frequency !== templateBuf.frequency || buf.bytesPerSample !== templateBuf.bytesPerSample || buf.channels !== templateBuf.channels)) {
                AL.currentCtx.err = 40964;
              }
            }
            if (src.bufQueue.length === 1 && src.bufQueue[0].id === 0) {
              src.bufQueue.length = 0;
            }
            src.type = 4137;
            for (var i2 = 0; i2 < count; ++i2) {
              var bufId = HEAP32[pBufferIds + i2 * 4 >>> 2 >>> 0];
              var buf = AL.buffers[bufId];
              buf.refCount++;
              src.bufQueue.push(buf);
            }
            if (src.looping) {
              AL.cancelPendingSourceAudio(src);
            }
            AL.initSourcePanner(src);
            AL.scheduleSourceAudio(src);
          }
          _alSourceQueueBuffers.sig = "viip";
          var _alSourceRewind = (sourceId) => {
            if (!AL.currentCtx) {
              return;
            }
            var src = AL.currentCtx.sources[sourceId];
            if (!src) {
              AL.currentCtx.err = 40961;
              return;
            }
            AL.setSourceState(src, 4116);
            AL.setSourceState(src, 4113);
          };
          _alSourceRewind.sig = "vi";
          function _alSourceRewindv(count, pSourceIds) {
            pSourceIds >>>= 0;
            if (!AL.currentCtx) {
              return;
            }
            if (!pSourceIds) {
              AL.currentCtx.err = 40963;
            }
            for (var i2 = 0; i2 < count; ++i2) {
              if (!AL.currentCtx.sources[HEAP32[pSourceIds + i2 * 4 >>> 2 >>> 0]]) {
                AL.currentCtx.err = 40961;
                return;
              }
            }
            for (var i2 = 0; i2 < count; ++i2) {
              var srcId = HEAP32[pSourceIds + i2 * 4 >>> 2 >>> 0];
              AL.setSourceState(AL.currentCtx.sources[srcId], 4113);
            }
          }
          _alSourceRewindv.sig = "vip";
          var _alSourceStop = (sourceId) => {
            if (!AL.currentCtx) {
              return;
            }
            var src = AL.currentCtx.sources[sourceId];
            if (!src) {
              AL.currentCtx.err = 40961;
              return;
            }
            AL.setSourceState(src, 4116);
          };
          _alSourceStop.sig = "vi";
          function _alSourceStopv(count, pSourceIds) {
            pSourceIds >>>= 0;
            if (!AL.currentCtx) {
              return;
            }
            if (!pSourceIds) {
              AL.currentCtx.err = 40963;
            }
            for (var i2 = 0; i2 < count; ++i2) {
              if (!AL.currentCtx.sources[HEAP32[pSourceIds + i2 * 4 >>> 2 >>> 0]]) {
                AL.currentCtx.err = 40961;
                return;
              }
            }
            for (var i2 = 0; i2 < count; ++i2) {
              var srcId = HEAP32[pSourceIds + i2 * 4 >>> 2 >>> 0];
              AL.setSourceState(AL.currentCtx.sources[srcId], 4116);
            }
          }
          _alSourceStopv.sig = "vip";
          function _alSourceUnqueueBuffers(sourceId, count, pBufferIds) {
            pBufferIds >>>= 0;
            if (!AL.currentCtx) {
              return;
            }
            var src = AL.currentCtx.sources[sourceId];
            if (!src) {
              AL.currentCtx.err = 40961;
              return;
            }
            if (count > (src.bufQueue.length === 1 && src.bufQueue[0].id === 0 ? 0 : src.bufsProcessed)) {
              AL.currentCtx.err = 40963;
              return;
            }
            if (count === 0) {
              return;
            }
            for (var i2 = 0; i2 < count; i2++) {
              var buf = src.bufQueue.shift();
              buf.refCount--;
              HEAP32[pBufferIds + i2 * 4 >>> 2 >>> 0] = buf.id;
              src.bufsProcessed--;
            }
            if (src.bufQueue.length === 0) {
              src.bufQueue.push(AL.buffers[0]);
            }
            AL.initSourcePanner(src);
            AL.scheduleSourceAudio(src);
          }
          _alSourceUnqueueBuffers.sig = "viip";
          var _alSourcef = (sourceId, param, value) => {
            switch (param) {
              case 4097:
              case 4098:
              case 4099:
              case 4106:
              case 4109:
              case 4110:
              case 4128:
              case 4129:
              case 4130:
              case 4131:
              case 4132:
              case 4133:
              case 4134:
              case 8203:
                AL.setSourceParam("alSourcef", sourceId, param, value);
                break;
              default:
                AL.setSourceParam("alSourcef", sourceId, param, null);
                break;
            }
          };
          _alSourcef.sig = "viif";
          function _alSourcefv(sourceId, param, pValues) {
            pValues >>>= 0;
            if (!AL.currentCtx) {
              return;
            }
            if (!pValues) {
              AL.currentCtx.err = 40963;
              return;
            }
            switch (param) {
              case 4097:
              case 4098:
              case 4099:
              case 4106:
              case 4109:
              case 4110:
              case 4128:
              case 4129:
              case 4130:
              case 4131:
              case 4132:
              case 4133:
              case 4134:
              case 8203:
                var val = HEAPF32[pValues >>> 2 >>> 0];
                AL.setSourceParam("alSourcefv", sourceId, param, val);
                break;
              case 4100:
              case 4101:
              case 4102:
                AL.paramArray[0] = HEAPF32[pValues >>> 2 >>> 0];
                AL.paramArray[1] = HEAPF32[pValues + 4 >>> 2 >>> 0];
                AL.paramArray[2] = HEAPF32[pValues + 8 >>> 2 >>> 0];
                AL.setSourceParam("alSourcefv", sourceId, param, AL.paramArray);
                break;
              default:
                AL.setSourceParam("alSourcefv", sourceId, param, null);
                break;
            }
          }
          _alSourcefv.sig = "viip";
          function _alSourceiv(sourceId, param, pValues) {
            pValues >>>= 0;
            if (!AL.currentCtx) {
              return;
            }
            if (!pValues) {
              AL.currentCtx.err = 40963;
              return;
            }
            switch (param) {
              case 514:
              case 4097:
              case 4098:
              case 4103:
              case 4105:
              case 4128:
              case 4129:
              case 4131:
              case 4132:
              case 4133:
              case 4134:
              case 4628:
              case 8201:
              case 8202:
              case 53248:
                var val = HEAP32[pValues >>> 2 >>> 0];
                AL.setSourceParam("alSourceiv", sourceId, param, val);
                break;
              case 4100:
              case 4101:
              case 4102:
                AL.paramArray[0] = HEAP32[pValues >>> 2 >>> 0];
                AL.paramArray[1] = HEAP32[pValues + 4 >>> 2 >>> 0];
                AL.paramArray[2] = HEAP32[pValues + 8 >>> 2 >>> 0];
                AL.setSourceParam("alSourceiv", sourceId, param, AL.paramArray);
                break;
              default:
                AL.setSourceParam("alSourceiv", sourceId, param, null);
                break;
            }
          }
          _alSourceiv.sig = "viip";
          var _alSpeedOfSound = (value) => {
            AL.setGlobalParam("alSpeedOfSound", 49155, value);
          };
          _alSpeedOfSound.sig = "vf";
          var _alcCaptureCloseDevice = function(deviceId) {
            deviceId >>>= 0;
            var c = AL.requireValidCaptureDevice(deviceId, "alcCaptureCloseDevice");
            if (!c)
              return false;
            delete AL.captures[deviceId];
            AL.freeIds.push(deviceId);
            c.mediaStreamSourceNode?.disconnect();
            c.mergerNode?.disconnect();
            c.splitterNode?.disconnect();
            c.scriptProcessorNode?.disconnect();
            if (c.mediaStream) {
              c.mediaStream.getTracks().forEach((track) => track.stop());
            }
            delete c.buffers;
            c.capturedFrameCount = 0;
            c.isCapturing = false;
            return true;
          };
          _alcCaptureCloseDevice.sig = "ip";
          var listenOnce = (object, event2, func2) => {
            object.addEventListener(event2, func2, {
              "once": true
            });
          };
          var autoResumeAudioContext = (ctx, elements) => {
            if (!elements) {
              elements = [document, document.getElementById("canvas")];
            }
            ["keydown", "mousedown", "touchstart"].forEach((event2) => {
              elements.forEach((element) => {
                if (element) {
                  listenOnce(element, event2, () => {
                    if (ctx.state === "suspended")
                      ctx.resume();
                  });
                }
              });
            });
          };
          function _alcCaptureOpenDevice(pDeviceName, requestedSampleRate, format, bufferFrameCapacity) {
            pDeviceName >>>= 0;
            var resolvedDeviceName = AL.CAPTURE_DEVICE_NAME;
            if (pDeviceName !== 0) {
              resolvedDeviceName = UTF8ToString(pDeviceName);
              if (resolvedDeviceName !== AL.CAPTURE_DEVICE_NAME) {
                AL.alcErr = 40965;
                return 0;
              }
            }
            if (bufferFrameCapacity < 0) {
              AL.alcErr = 40964;
              return 0;
            }
            navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;
            var has_getUserMedia = navigator.getUserMedia || navigator.mediaDevices && navigator.mediaDevices.getUserMedia;
            if (!has_getUserMedia) {
              AL.alcErr = 40965;
              return 0;
            }
            var AudioContext2 = window.AudioContext || window.webkitAudioContext;
            if (!AL.sharedCaptureAudioCtx) {
              try {
                AL.sharedCaptureAudioCtx = new AudioContext2();
              } catch (e) {
                AL.alcErr = 40965;
                return 0;
              }
            }
            autoResumeAudioContext(AL.sharedCaptureAudioCtx);
            var outputChannelCount;
            switch (format) {
              case 65552:
              case 4353:
              case 4352:
                outputChannelCount = 1;
                break;
              case 65553:
              case 4355:
              case 4354:
                outputChannelCount = 2;
                break;
              default:
                AL.alcErr = 40964;
                return 0;
            }
            function newF32Array(cap) {
              return new Float32Array(cap);
            }
            function newI16Array(cap) {
              return new Int16Array(cap);
            }
            function newU8Array(cap) {
              return new Uint8Array(cap);
            }
            var requestedSampleType;
            var newSampleArray;
            switch (format) {
              case 65552:
              case 65553:
                requestedSampleType = "f32";
                newSampleArray = newF32Array;
                break;
              case 4353:
              case 4355:
                requestedSampleType = "i16";
                newSampleArray = newI16Array;
                break;
              case 4352:
              case 4354:
                requestedSampleType = "u8";
                newSampleArray = newU8Array;
                break;
            }
            var buffers = [];
            try {
              for (var chan = 0; chan < outputChannelCount; ++chan) {
                buffers[chan] = newSampleArray(bufferFrameCapacity);
              }
            } catch (e) {
              AL.alcErr = 40965;
              return 0;
            }
            var newCapture = {
              audioCtx: AL.sharedCaptureAudioCtx,
              deviceName: resolvedDeviceName,
              requestedSampleRate,
              requestedSampleType,
              outputChannelCount,
              inputChannelCount: null,
              mediaStreamError: null,
              mediaStreamSourceNode: null,
              mediaStream: null,
              mergerNode: null,
              splitterNode: null,
              scriptProcessorNode: null,
              isCapturing: false,
              buffers,
              get bufferFrameCapacity() {
                return buffers[0].length;
              },
              capturePlayhead: 0,
              captureReadhead: 0,
              capturedFrameCount: 0
            };
            var onError = (mediaStreamError) => {
              newCapture.mediaStreamError = mediaStreamError;
            };
            var onSuccess = (mediaStream) => {
              newCapture.mediaStreamSourceNode = newCapture.audioCtx.createMediaStreamSource(mediaStream);
              newCapture.mediaStream = mediaStream;
              var inputChannelCount = 1;
              switch (newCapture.mediaStreamSourceNode.channelCountMode) {
                case "max":
                  inputChannelCount = outputChannelCount;
                  break;
                case "clamped-max":
                  inputChannelCount = Math.min(outputChannelCount, newCapture.mediaStreamSourceNode.channelCount);
                  break;
                case "explicit":
                  inputChannelCount = newCapture.mediaStreamSourceNode.channelCount;
                  break;
              }
              newCapture.inputChannelCount = inputChannelCount;
              var processorFrameCount = 512;
              newCapture.scriptProcessorNode = newCapture.audioCtx.createScriptProcessor(processorFrameCount, inputChannelCount, outputChannelCount);
              if (inputChannelCount > outputChannelCount) {
                newCapture.mergerNode = newCapture.audioCtx.createChannelMerger(inputChannelCount);
                newCapture.mediaStreamSourceNode.connect(newCapture.mergerNode);
                newCapture.mergerNode.connect(newCapture.scriptProcessorNode);
              } else if (inputChannelCount < outputChannelCount) {
                newCapture.splitterNode = newCapture.audioCtx.createChannelSplitter(outputChannelCount);
                newCapture.mediaStreamSourceNode.connect(newCapture.splitterNode);
                newCapture.splitterNode.connect(newCapture.scriptProcessorNode);
              } else {
                newCapture.mediaStreamSourceNode.connect(newCapture.scriptProcessorNode);
              }
              newCapture.scriptProcessorNode.connect(newCapture.audioCtx.destination);
              newCapture.scriptProcessorNode.onaudioprocess = (audioProcessingEvent) => {
                if (!newCapture.isCapturing) {
                  return;
                }
                var c = newCapture;
                var srcBuf = audioProcessingEvent.inputBuffer;
                switch (format) {
                  case 65552:
                    var channel0 = srcBuf.getChannelData(0);
                    for (var i2 = 0; i2 < srcBuf.length; ++i2) {
                      var wi = (c.capturePlayhead + i2) % c.bufferFrameCapacity;
                      c.buffers[0][wi] = channel0[i2];
                    }
                    break;
                  case 65553:
                    var channel0 = srcBuf.getChannelData(0);
                    var channel1 = srcBuf.getChannelData(1);
                    for (var i2 = 0; i2 < srcBuf.length; ++i2) {
                      var wi = (c.capturePlayhead + i2) % c.bufferFrameCapacity;
                      c.buffers[0][wi] = channel0[i2];
                      c.buffers[1][wi] = channel1[i2];
                    }
                    break;
                  case 4353:
                    var channel0 = srcBuf.getChannelData(0);
                    for (var i2 = 0; i2 < srcBuf.length; ++i2) {
                      var wi = (c.capturePlayhead + i2) % c.bufferFrameCapacity;
                      c.buffers[0][wi] = channel0[i2] * 32767;
                    }
                    break;
                  case 4355:
                    var channel0 = srcBuf.getChannelData(0);
                    var channel1 = srcBuf.getChannelData(1);
                    for (var i2 = 0; i2 < srcBuf.length; ++i2) {
                      var wi = (c.capturePlayhead + i2) % c.bufferFrameCapacity;
                      c.buffers[0][wi] = channel0[i2] * 32767;
                      c.buffers[1][wi] = channel1[i2] * 32767;
                    }
                    break;
                  case 4352:
                    var channel0 = srcBuf.getChannelData(0);
                    for (var i2 = 0; i2 < srcBuf.length; ++i2) {
                      var wi = (c.capturePlayhead + i2) % c.bufferFrameCapacity;
                      c.buffers[0][wi] = (channel0[i2] + 1) * 127;
                    }
                    break;
                  case 4354:
                    var channel0 = srcBuf.getChannelData(0);
                    var channel1 = srcBuf.getChannelData(1);
                    for (var i2 = 0; i2 < srcBuf.length; ++i2) {
                      var wi = (c.capturePlayhead + i2) % c.bufferFrameCapacity;
                      c.buffers[0][wi] = (channel0[i2] + 1) * 127;
                      c.buffers[1][wi] = (channel1[i2] + 1) * 127;
                    }
                    break;
                }
                c.capturePlayhead += srcBuf.length;
                c.capturePlayhead %= c.bufferFrameCapacity;
                c.capturedFrameCount += srcBuf.length;
                c.capturedFrameCount = Math.min(c.capturedFrameCount, c.bufferFrameCapacity);
              };
            };
            if (navigator.mediaDevices?.getUserMedia) {
              navigator.mediaDevices.getUserMedia({
                audio: true
              }).then(onSuccess).catch(onError);
            } else {
              navigator.getUserMedia({
                audio: true
              }, onSuccess, onError);
            }
            var id = AL.newId();
            AL.captures[id] = newCapture;
            return id;
          }
          _alcCaptureOpenDevice.sig = "ppiii";
          function _alcCaptureSamples(deviceId, pFrames, requestedFrameCount) {
            deviceId >>>= 0;
            pFrames >>>= 0;
            var c = AL.requireValidCaptureDevice(deviceId, "alcCaptureSamples");
            if (!c)
              return;
            var dstfreq = c.requestedSampleRate;
            var srcfreq = c.audioCtx.sampleRate;
            var fratio = srcfreq / dstfreq;
            if (requestedFrameCount < 0 || requestedFrameCount > c.capturedFrameCount / fratio) {
              AL.alcErr = 40964;
              return;
            }
            function setF32Sample(i3, sample) {
              HEAPF32[pFrames + 4 * i3 >>> 2 >>> 0] = sample;
            }
            function setI16Sample(i3, sample) {
              HEAP16[pFrames + 2 * i3 >>> 1 >>> 0] = sample;
            }
            function setU8Sample(i3, sample) {
              HEAP8[pFrames + i3 >>> 0 >>> 0] = sample;
            }
            var setSample;
            switch (c.requestedSampleType) {
              case "f32":
                setSample = setF32Sample;
                break;
              case "i16":
                setSample = setI16Sample;
                break;
              case "u8":
                setSample = setU8Sample;
                break;
              default:
                return;
            }
            if (Math.floor(fratio) == fratio) {
              for (var i2 = 0, frame_i = 0; frame_i < requestedFrameCount; ++frame_i) {
                for (var chan = 0; chan < c.buffers.length; ++chan, ++i2) {
                  setSample(i2, c.buffers[chan][c.captureReadhead]);
                }
                c.captureReadhead = (fratio + c.captureReadhead) % c.bufferFrameCapacity;
              }
            } else {
              for (var i2 = 0, frame_i = 0; frame_i < requestedFrameCount; ++frame_i) {
                var lefti = Math.floor(c.captureReadhead);
                var righti = Math.ceil(c.captureReadhead);
                var d = c.captureReadhead - lefti;
                for (var chan = 0; chan < c.buffers.length; ++chan, ++i2) {
                  var lefts = c.buffers[chan][lefti];
                  var rights = c.buffers[chan][righti];
                  setSample(i2, (1 - d) * lefts + d * rights);
                }
                c.captureReadhead = (c.captureReadhead + fratio) % c.bufferFrameCapacity;
              }
            }
            c.capturedFrameCount = 0;
          }
          _alcCaptureSamples.sig = "vppi";
          function _alcCaptureStart(deviceId) {
            deviceId >>>= 0;
            var c = AL.requireValidCaptureDevice(deviceId, "alcCaptureStart");
            if (!c)
              return;
            if (c.isCapturing) {
              return;
            }
            c.isCapturing = true;
            c.capturedFrameCount = 0;
            c.capturePlayhead = 0;
          }
          _alcCaptureStart.sig = "vp";
          function _alcCaptureStop(deviceId) {
            deviceId >>>= 0;
            var c = AL.requireValidCaptureDevice(deviceId, "alcCaptureStop");
            if (!c)
              return;
            c.isCapturing = false;
          }
          _alcCaptureStop.sig = "vp";
          function _alcCloseDevice(deviceId) {
            deviceId >>>= 0;
            if (!(deviceId in AL.deviceRefCounts) || AL.deviceRefCounts[deviceId] > 0) {
              return 0;
            }
            delete AL.deviceRefCounts[deviceId];
            AL.freeIds.push(deviceId);
            return 1;
          }
          _alcCloseDevice.sig = "ip";
          function _alcCreateContext(deviceId, pAttrList) {
            deviceId >>>= 0;
            pAttrList >>>= 0;
            if (!(deviceId in AL.deviceRefCounts)) {
              AL.alcErr = 40961;
              return 0;
            }
            var options = null;
            var attrs = [];
            var hrtf = null;
            pAttrList >>= 2;
            if (pAttrList) {
              var attr = 0;
              var val = 0;
              while (true) {
                attr = HEAP32[pAttrList++ >>> 0];
                attrs.push(attr);
                if (attr === 0) {
                  break;
                }
                val = HEAP32[pAttrList++ >>> 0];
                attrs.push(val);
                switch (attr) {
                  case 4103:
                    if (!options) {
                      options = {};
                    }
                    options.sampleRate = val;
                    break;
                  case 4112:
                  case 4113:
                    break;
                  case 6546:
                    switch (val) {
                      case 0:
                        hrtf = false;
                        break;
                      case 1:
                        hrtf = true;
                        break;
                      case 2:
                        break;
                      default:
                        AL.alcErr = 40964;
                        return 0;
                    }
                    break;
                  case 6550:
                    if (val !== 0) {
                      AL.alcErr = 40964;
                      return 0;
                    }
                    break;
                  default:
                    AL.alcErr = 40964;
                    return 0;
                }
              }
            }
            var AudioContext2 = window.AudioContext || window.webkitAudioContext;
            var ac = null;
            try {
              if (options) {
                ac = new AudioContext2(options);
              } else {
                ac = new AudioContext2();
              }
            } catch (e) {
              if (e.name === "NotSupportedError") {
                AL.alcErr = 40964;
              } else {
                AL.alcErr = 40961;
              }
              return 0;
            }
            autoResumeAudioContext(ac);
            if (typeof ac.createGain == "undefined") {
              ac.createGain = ac.createGainNode;
            }
            var gain = ac.createGain();
            gain.connect(ac.destination);
            var ctx = {
              deviceId,
              id: AL.newId(),
              attrs,
              audioCtx: ac,
              listener: {
                position: [0, 0, 0],
                velocity: [0, 0, 0],
                direction: [0, 0, 0],
                up: [0, 0, 0]
              },
              sources: [],
              interval: setInterval(() => AL.scheduleContextAudio(ctx), AL.QUEUE_INTERVAL),
              gain,
              distanceModel: 53250,
              speedOfSound: 343.3,
              dopplerFactor: 1,
              sourceDistanceModel: false,
              hrtf: hrtf || false,
              _err: 0,
              get err() {
                return this._err;
              },
              set err(val2) {
                if (this._err === 0 || val2 === 0) {
                  this._err = val2;
                }
              }
            };
            AL.deviceRefCounts[deviceId]++;
            AL.contexts[ctx.id] = ctx;
            if (hrtf !== null) {
              for (var ctxId in AL.contexts) {
                var c = AL.contexts[ctxId];
                if (c.deviceId === deviceId) {
                  c.hrtf = hrtf;
                  AL.updateContextGlobal(c);
                }
              }
            }
            return ctx.id;
          }
          _alcCreateContext.sig = "ppp";
          function _alcDestroyContext(contextId) {
            contextId >>>= 0;
            var ctx = AL.contexts[contextId];
            if (AL.currentCtx === ctx) {
              AL.alcErr = 40962;
              return;
            }
            if (AL.contexts[contextId].interval) {
              clearInterval(AL.contexts[contextId].interval);
            }
            AL.deviceRefCounts[ctx.deviceId]--;
            delete AL.contexts[contextId];
            AL.freeIds.push(contextId);
          }
          _alcDestroyContext.sig = "vp";
          function _alcGetContextsDevice(contextId) {
            contextId >>>= 0;
            if (contextId in AL.contexts) {
              return AL.contexts[contextId].deviceId;
            }
            return 0;
          }
          _alcGetContextsDevice.sig = "pp";
          function _alcGetCurrentContext() {
            if (AL.currentCtx !== null) {
              return AL.currentCtx.id;
            }
            return 0;
          }
          _alcGetCurrentContext.sig = "p";
          function _alcGetEnumValue(deviceId, pEnumName) {
            deviceId >>>= 0;
            pEnumName >>>= 0;
            if (deviceId !== 0 && !(deviceId in AL.deviceRefCounts)) {
              return 0;
            } else if (!pEnumName) {
              AL.alcErr = 40964;
              return 0;
            }
            var name2 = UTF8ToString(pEnumName);
            switch (name2) {
              case "ALC_NO_ERROR":
                return 0;
              case "ALC_INVALID_DEVICE":
                return 40961;
              case "ALC_INVALID_CONTEXT":
                return 40962;
              case "ALC_INVALID_ENUM":
                return 40963;
              case "ALC_INVALID_VALUE":
                return 40964;
              case "ALC_OUT_OF_MEMORY":
                return 40965;
              case "ALC_MAJOR_VERSION":
                return 4096;
              case "ALC_MINOR_VERSION":
                return 4097;
              case "ALC_ATTRIBUTES_SIZE":
                return 4098;
              case "ALC_ALL_ATTRIBUTES":
                return 4099;
              case "ALC_DEFAULT_DEVICE_SPECIFIER":
                return 4100;
              case "ALC_DEVICE_SPECIFIER":
                return 4101;
              case "ALC_EXTENSIONS":
                return 4102;
              case "ALC_FREQUENCY":
                return 4103;
              case "ALC_REFRESH":
                return 4104;
              case "ALC_SYNC":
                return 4105;
              case "ALC_MONO_SOURCES":
                return 4112;
              case "ALC_STEREO_SOURCES":
                return 4113;
              case "ALC_CAPTURE_DEVICE_SPECIFIER":
                return 784;
              case "ALC_CAPTURE_DEFAULT_DEVICE_SPECIFIER":
                return 785;
              case "ALC_CAPTURE_SAMPLES":
                return 786;
              case "ALC_HRTF_SOFT":
                return 6546;
              case "ALC_HRTF_ID_SOFT":
                return 6550;
              case "ALC_DONT_CARE_SOFT":
                return 2;
              case "ALC_HRTF_STATUS_SOFT":
                return 6547;
              case "ALC_NUM_HRTF_SPECIFIERS_SOFT":
                return 6548;
              case "ALC_HRTF_SPECIFIER_SOFT":
                return 6549;
              case "ALC_HRTF_DISABLED_SOFT":
                return 0;
              case "ALC_HRTF_ENABLED_SOFT":
                return 1;
              case "ALC_HRTF_DENIED_SOFT":
                return 2;
              case "ALC_HRTF_REQUIRED_SOFT":
                return 3;
              case "ALC_HRTF_HEADPHONES_DETECTED_SOFT":
                return 4;
              case "ALC_HRTF_UNSUPPORTED_FORMAT_SOFT":
                return 5;
              default:
                AL.alcErr = 40964;
                return 0;
            }
          }
          _alcGetEnumValue.sig = "ipp";
          function _alcGetError(deviceId) {
            deviceId >>>= 0;
            var err2 = AL.alcErr;
            AL.alcErr = 0;
            return err2;
          }
          _alcGetError.sig = "ip";
          function _alcGetIntegerv(deviceId, param, size, pValues) {
            deviceId >>>= 0;
            pValues >>>= 0;
            if (size === 0 || !pValues) {
              return;
            }
            switch (param) {
              case 4096:
                HEAP32[pValues >>> 2 >>> 0] = 1;
                break;
              case 4097:
                HEAP32[pValues >>> 2 >>> 0] = 1;
                break;
              case 4098:
                if (!(deviceId in AL.deviceRefCounts)) {
                  AL.alcErr = 40961;
                  return;
                }
                if (!AL.currentCtx) {
                  AL.alcErr = 40962;
                  return;
                }
                HEAP32[pValues >>> 2 >>> 0] = AL.currentCtx.attrs.length;
                break;
              case 4099:
                if (!(deviceId in AL.deviceRefCounts)) {
                  AL.alcErr = 40961;
                  return;
                }
                if (!AL.currentCtx) {
                  AL.alcErr = 40962;
                  return;
                }
                for (var i2 = 0; i2 < AL.currentCtx.attrs.length; i2++) {
                  HEAP32[pValues + i2 * 4 >>> 2 >>> 0] = AL.currentCtx.attrs[i2];
                }
                break;
              case 4103:
                if (!(deviceId in AL.deviceRefCounts)) {
                  AL.alcErr = 40961;
                  return;
                }
                if (!AL.currentCtx) {
                  AL.alcErr = 40962;
                  return;
                }
                HEAP32[pValues >>> 2 >>> 0] = AL.currentCtx.audioCtx.sampleRate;
                break;
              case 4112:
              case 4113:
                if (!(deviceId in AL.deviceRefCounts)) {
                  AL.alcErr = 40961;
                  return;
                }
                if (!AL.currentCtx) {
                  AL.alcErr = 40962;
                  return;
                }
                HEAP32[pValues >>> 2 >>> 0] = 2147483647;
                break;
              case 6546:
              case 6547:
                if (!(deviceId in AL.deviceRefCounts)) {
                  AL.alcErr = 40961;
                  return;
                }
                var hrtfStatus = 0;
                for (var ctxId in AL.contexts) {
                  var ctx = AL.contexts[ctxId];
                  if (ctx.deviceId === deviceId) {
                    hrtfStatus = ctx.hrtf ? 1 : 0;
                  }
                }
                HEAP32[pValues >>> 2 >>> 0] = hrtfStatus;
                break;
              case 6548:
                if (!(deviceId in AL.deviceRefCounts)) {
                  AL.alcErr = 40961;
                  return;
                }
                HEAP32[pValues >>> 2 >>> 0] = 1;
                break;
              case 131075:
                if (!(deviceId in AL.deviceRefCounts)) {
                  AL.alcErr = 40961;
                  return;
                }
                if (!AL.currentCtx) {
                  AL.alcErr = 40962;
                  return;
                }
                HEAP32[pValues >>> 2 >>> 0] = 1;
              case 786:
                var c = AL.requireValidCaptureDevice(deviceId, "alcGetIntegerv");
                if (!c) {
                  return;
                }
                var n = c.capturedFrameCount;
                var dstfreq = c.requestedSampleRate;
                var srcfreq = c.audioCtx.sampleRate;
                var nsamples = Math.floor(n * (dstfreq / srcfreq));
                HEAP32[pValues >>> 2 >>> 0] = nsamples;
                break;
              default:
                AL.alcErr = 40963;
                return;
            }
          }
          _alcGetIntegerv.sig = "vpiip";
          function _alcGetString(deviceId, param) {
            deviceId >>>= 0;
            if (AL.alcStringCache[param]) {
              return AL.alcStringCache[param];
            }
            var ret;
            switch (param) {
              case 0:
                ret = "No Error";
                break;
              case 40961:
                ret = "Invalid Device";
                break;
              case 40962:
                ret = "Invalid Context";
                break;
              case 40963:
                ret = "Invalid Enum";
                break;
              case 40964:
                ret = "Invalid Value";
                break;
              case 40965:
                ret = "Out of Memory";
                break;
              case 4100:
                if (typeof AudioContext != "undefined" || typeof webkitAudioContext != "undefined") {
                  ret = AL.DEVICE_NAME;
                } else {
                  return 0;
                }
                break;
              case 4101:
                if (typeof AudioContext != "undefined" || typeof webkitAudioContext != "undefined") {
                  ret = AL.DEVICE_NAME.concat("\0");
                } else {
                  ret = "\0";
                }
                break;
              case 785:
                ret = AL.CAPTURE_DEVICE_NAME;
                break;
              case 784:
                if (deviceId === 0)
                  ret = AL.CAPTURE_DEVICE_NAME.concat("\0");
                else {
                  var c = AL.requireValidCaptureDevice(deviceId, "alcGetString");
                  if (!c) {
                    return 0;
                  }
                  ret = c.deviceName;
                }
                break;
              case 4102:
                if (!deviceId) {
                  AL.alcErr = 40961;
                  return 0;
                }
                ret = "";
                for (var ext in AL.ALC_EXTENSIONS) {
                  ret = ret.concat(ext);
                  ret = ret.concat(" ");
                }
                ret = ret.trim();
                break;
              default:
                AL.alcErr = 40963;
                return 0;
            }
            ret = stringToNewUTF8(ret);
            AL.alcStringCache[param] = ret;
            return ret;
          }
          _alcGetString.sig = "ppi";
          function _alcIsExtensionPresent(deviceId, pExtName) {
            deviceId >>>= 0;
            pExtName >>>= 0;
            var name2 = UTF8ToString(pExtName);
            return AL.ALC_EXTENSIONS[name2] ? 1 : 0;
          }
          _alcIsExtensionPresent.sig = "ipp";
          function _alcMakeContextCurrent(contextId) {
            contextId >>>= 0;
            if (contextId === 0) {
              AL.currentCtx = null;
            } else {
              AL.currentCtx = AL.contexts[contextId];
            }
            return 1;
          }
          _alcMakeContextCurrent.sig = "ip";
          function _alcOpenDevice(pDeviceName) {
            pDeviceName >>>= 0;
            if (pDeviceName) {
              var name2 = UTF8ToString(pDeviceName);
              if (name2 !== AL.DEVICE_NAME) {
                return 0;
              }
            }
            if (typeof AudioContext != "undefined" || typeof webkitAudioContext != "undefined") {
              var deviceId = AL.newId();
              AL.deviceRefCounts[deviceId] = 0;
              return deviceId;
            }
            return 0;
          }
          _alcOpenDevice.sig = "pp";
          function _alcProcessContext(contextId) {
            contextId >>>= 0;
          }
          _alcProcessContext.sig = "vp";
          function _alcSuspendContext(contextId) {
            contextId >>>= 0;
          }
          _alcSuspendContext.sig = "vp";
          function _duckdb_web_fs_directory_create(path, pathLen) {
            path >>>= 0;
            return globalThis.DUCKDB_RUNTIME.createDirectory(Module, path, pathLen);
          }
          _duckdb_web_fs_directory_create.sig = "vpi";
          function _duckdb_web_fs_directory_exists(path, pathLen) {
            path >>>= 0;
            return globalThis.DUCKDB_RUNTIME.checkDirectory(Module, path, pathLen);
          }
          _duckdb_web_fs_directory_exists.sig = "ipi";
          function _duckdb_web_fs_directory_list_files(path, pathLen) {
            path >>>= 0;
            return globalThis.DUCKDB_RUNTIME.listDirectoryEntries(Module, path, pathLen);
          }
          _duckdb_web_fs_directory_list_files.sig = "ipi";
          function _duckdb_web_fs_directory_remove(path, pathLen) {
            path >>>= 0;
            return globalThis.DUCKDB_RUNTIME.removeDirectory(Module, path, pathLen);
          }
          _duckdb_web_fs_directory_remove.sig = "vpi";
          function _duckdb_web_fs_file_close(fileId) {
            return globalThis.DUCKDB_RUNTIME.closeFile(Module, fileId);
          }
          _duckdb_web_fs_file_close.sig = "vi";
          function _duckdb_web_fs_file_exists(path, pathLen) {
            path >>>= 0;
            return globalThis.DUCKDB_RUNTIME.checkFile(Module, path, pathLen);
          }
          _duckdb_web_fs_file_exists.sig = "ipi";
          function _duckdb_web_fs_file_get_last_modified_time(fileId) {
            return globalThis.DUCKDB_RUNTIME.getLastFileModificationTime(Module, fileId);
          }
          _duckdb_web_fs_file_get_last_modified_time.sig = "ii";
          function _duckdb_web_fs_file_move(from, fromLen, to, toLen) {
            from >>>= 0;
            to >>>= 0;
            return globalThis.DUCKDB_RUNTIME.moveFile(Module, from, fromLen, to, toLen);
          }
          _duckdb_web_fs_file_move.sig = "vpipi";
          function _duckdb_web_fs_file_open(fileId, flags2) {
            return globalThis.DUCKDB_RUNTIME.openFile(Module, fileId, flags2);
          }
          _duckdb_web_fs_file_open.sig = "pii";
          function _duckdb_web_fs_file_read(fileId, buf, size, location) {
            buf >>>= 0;
            return globalThis.DUCKDB_RUNTIME.readFile(Module, fileId, buf, size, location);
          }
          _duckdb_web_fs_file_read.sig = "iipid";
          function _duckdb_web_fs_file_truncate(fileId, newSize) {
            return globalThis.DUCKDB_RUNTIME.truncateFile(Module, fileId, newSize);
          }
          _duckdb_web_fs_file_truncate.sig = "vid";
          function _duckdb_web_fs_file_write(fileId, buf, size, location) {
            buf >>>= 0;
            return globalThis.DUCKDB_RUNTIME.writeFile(Module, fileId, buf, size, location);
          }
          _duckdb_web_fs_file_write.sig = "iipid";
          function _duckdb_web_fs_get_default_data_protocol(Module2) {
            return globalThis.DUCKDB_RUNTIME.getDefaultDataProtocol(Module2);
          }
          _duckdb_web_fs_get_default_data_protocol.sig = "i";
          function _duckdb_web_fs_glob(path, pathLen) {
            path >>>= 0;
            return globalThis.DUCKDB_RUNTIME.glob(Module, path, pathLen);
          }
          _duckdb_web_fs_glob.sig = "vpi";
          function _duckdb_web_test_platform_feature(feature) {
            return globalThis.DUCKDB_RUNTIME.testPlatformFeature(Module, feature);
          }
          _duckdb_web_test_platform_feature.sig = "ii";
          function _duckdb_web_udf_scalar_call(funcId, descPtr, descSize, ptrsPtr, ptrsSize, response) {
            funcId >>>= 0;
            descSize >>>= 0;
            ptrsSize >>>= 0;
            return globalThis.DUCKDB_RUNTIME.callScalarUDF(Module, funcId, descPtr, descSize, ptrsPtr, ptrsSize, response);
          }
          _duckdb_web_udf_scalar_call.sig = "vpipipi";
          var _emscripten_alcDevicePauseSOFT = (deviceId) => {
            if (!(deviceId in AL.deviceRefCounts)) {
              AL.alcErr = 40961;
              return;
            }
            if (AL.paused) {
              return;
            }
            AL.paused = true;
            for (var ctxId in AL.contexts) {
              var ctx = AL.contexts[ctxId];
              if (ctx.deviceId !== deviceId) {
                continue;
              }
              ctx.audioCtx.suspend();
              clearInterval(ctx.interval);
              ctx.interval = null;
            }
          };
          _emscripten_alcDevicePauseSOFT.sig = "vi";
          var _emscripten_alcDeviceResumeSOFT = (deviceId) => {
            if (!(deviceId in AL.deviceRefCounts)) {
              AL.alcErr = 40961;
              return;
            }
            if (!AL.paused) {
              return;
            }
            AL.paused = false;
            for (var ctxId in AL.contexts) {
              var ctx = AL.contexts[ctxId];
              if (ctx.deviceId !== deviceId) {
                continue;
              }
              ctx.interval = setInterval(() => AL.scheduleContextAudio(ctx), AL.QUEUE_INTERVAL);
              ctx.audioCtx.resume();
            }
          };
          _emscripten_alcDeviceResumeSOFT.sig = "vi";
          var _emscripten_alcGetStringiSOFT = (deviceId, param, index) => {
            if (!(deviceId in AL.deviceRefCounts)) {
              AL.alcErr = 40961;
              return 0;
            }
            if (AL.alcStringCache[param]) {
              return AL.alcStringCache[param];
            }
            var ret;
            switch (param) {
              case 6549:
                if (index === 0) {
                  ret = "Web Audio HRTF";
                } else {
                  AL.alcErr = 40964;
                  return 0;
                }
                break;
              default:
                if (index !== 0) {
                  AL.alcErr = 40963;
                  return 0;
                }
                return _alcGetString(deviceId, param);
            }
            ret = stringToNewUTF8(ret);
            AL.alcStringCache[param] = ret;
            return ret;
          };
          _emscripten_alcGetStringiSOFT.sig = "iiii";
          var _emscripten_alcResetDeviceSOFT = (deviceId, pAttrList) => {
            if (!(deviceId in AL.deviceRefCounts)) {
              AL.alcErr = 40961;
              return 0;
            }
            var hrtf = null;
            pAttrList >>= 2;
            if (pAttrList) {
              var attr = 0;
              var val = 0;
              while (true) {
                attr = HEAP32[pAttrList++ >>> 0];
                if (attr === 0) {
                  break;
                }
                val = HEAP32[pAttrList++ >>> 0];
                switch (attr) {
                  case 6546:
                    if (val === 1) {
                      hrtf = true;
                    } else if (val === 0) {
                      hrtf = false;
                    }
                    break;
                }
              }
            }
            if (hrtf !== null) {
              for (var ctxId in AL.contexts) {
                var ctx = AL.contexts[ctxId];
                if (ctx.deviceId === deviceId) {
                  ctx.hrtf = hrtf;
                  AL.updateContextGlobal(ctx);
                }
              }
            }
            return 1;
          };
          _emscripten_alcResetDeviceSOFT.sig = "iii";
          var readEmAsmArgsArray = [];
          var readEmAsmArgs = (sigPtr, buf) => {
            readEmAsmArgsArray.length = 0;
            var ch;
            while (ch = HEAPU8[sigPtr++ >>> 0]) {
              var wide = ch != 105;
              wide &= ch != 112;
              buf += wide && buf % 8 ? 4 : 0;
              readEmAsmArgsArray.push(ch == 112 ? HEAPU32[buf >>> 2 >>> 0] : ch == 105 ? HEAP32[buf >>> 2 >>> 0] : HEAPF64[buf >>> 3 >>> 0]);
              buf += wide ? 8 : 4;
            }
            return readEmAsmArgsArray;
          };
          var runEmAsmFunction = (code, sigPtr, argbuf) => {
            var args2 = readEmAsmArgs(sigPtr, argbuf);
            return ASM_CONSTS[code].apply(null, args2);
          };
          function _emscripten_asm_const_int(code, sigPtr, argbuf) {
            code >>>= 0;
            sigPtr >>>= 0;
            argbuf >>>= 0;
            return runEmAsmFunction(code, sigPtr, argbuf);
          }
          _emscripten_asm_const_int.sig = "ippp";
          function _emscripten_asm_const_ptr(code, sigPtr, argbuf) {
            code >>>= 0;
            sigPtr >>>= 0;
            argbuf >>>= 0;
            return runEmAsmFunction(code, sigPtr, argbuf);
          }
          _emscripten_asm_const_ptr.sig = "pppp";
          function _emscripten_console_error(str) {
            str >>>= 0;
            console.error(UTF8ToString(str));
          }
          _emscripten_console_error.sig = "vp";
          function _emscripten_console_log(str) {
            str >>>= 0;
            console.log(UTF8ToString(str));
          }
          _emscripten_console_log.sig = "vp";
          function _emscripten_console_warn(str) {
            str >>>= 0;
            console.warn(UTF8ToString(str));
          }
          _emscripten_console_warn.sig = "vp";
          var _emscripten_date_now = () => Date.now();
          _emscripten_date_now.sig = "d";
          function _emscripten_err(str) {
            str >>>= 0;
            return err(UTF8ToString(str));
          }
          _emscripten_err.sig = "vp";
          var getHeapMax = () => 4294901760;
          function _emscripten_get_heap_max() {
            return getHeapMax();
          }
          _emscripten_get_heap_max.sig = "p";
          var _emscripten_get_now_res = () => {
            if (ENVIRONMENT_IS_NODE) {
              return 1;
            }
            return 1e3;
          };
          _emscripten_get_now_res.sig = "d";
          var webgl_enable_ANGLE_instanced_arrays = (ctx) => {
            var ext = ctx.getExtension("ANGLE_instanced_arrays");
            if (ext) {
              ctx["vertexAttribDivisor"] = (index, divisor) => ext["vertexAttribDivisorANGLE"](index, divisor);
              ctx["drawArraysInstanced"] = (mode, first, count, primcount) => ext["drawArraysInstancedANGLE"](mode, first, count, primcount);
              ctx["drawElementsInstanced"] = (mode, count, type, indices, primcount) => ext["drawElementsInstancedANGLE"](mode, count, type, indices, primcount);
              return 1;
            }
          };
          var webgl_enable_OES_vertex_array_object = (ctx) => {
            var ext = ctx.getExtension("OES_vertex_array_object");
            if (ext) {
              ctx["createVertexArray"] = () => ext["createVertexArrayOES"]();
              ctx["deleteVertexArray"] = (vao) => ext["deleteVertexArrayOES"](vao);
              ctx["bindVertexArray"] = (vao) => ext["bindVertexArrayOES"](vao);
              ctx["isVertexArray"] = (vao) => ext["isVertexArrayOES"](vao);
              return 1;
            }
          };
          var webgl_enable_WEBGL_draw_buffers = (ctx) => {
            var ext = ctx.getExtension("WEBGL_draw_buffers");
            if (ext) {
              ctx["drawBuffers"] = (n, bufs) => ext["drawBuffersWEBGL"](n, bufs);
              return 1;
            }
          };
          var webgl_enable_WEBGL_multi_draw = (ctx) => !!(ctx.multiDrawWebgl = ctx.getExtension("WEBGL_multi_draw"));
          var getEmscriptenSupportedExtensions = function(ctx) {
            var supportedExtensions = ["ANGLE_instanced_arrays", "EXT_blend_minmax", "EXT_disjoint_timer_query", "EXT_frag_depth", "EXT_shader_texture_lod", "EXT_sRGB", "OES_element_index_uint", "OES_fbo_render_mipmap", "OES_standard_derivatives", "OES_texture_float", "OES_texture_half_float", "OES_texture_half_float_linear", "OES_vertex_array_object", "WEBGL_color_buffer_float", "WEBGL_depth_texture", "WEBGL_draw_buffers", "EXT_color_buffer_half_float", "EXT_float_blend", "EXT_texture_compression_bptc", "EXT_texture_compression_rgtc", "EXT_texture_filter_anisotropic", "KHR_parallel_shader_compile", "OES_texture_float_linear", "WEBGL_compressed_texture_s3tc", "WEBGL_compressed_texture_s3tc_srgb", "WEBGL_debug_renderer_info", "WEBGL_debug_shaders", "WEBGL_lose_context", "WEBGL_multi_draw"];
            return (ctx.getSupportedExtensions() || []).filter((ext) => supportedExtensions.includes(ext));
          };
          var GL = {
            counter: 1,
            buffers: [],
            programs: [],
            framebuffers: [],
            renderbuffers: [],
            textures: [],
            shaders: [],
            vaos: [],
            contexts: [],
            offscreenCanvases: {},
            queries: [],
            stringCache: {},
            unpackAlignment: 4,
            recordError: function recordError(errorCode) {
              if (!GL.lastError) {
                GL.lastError = errorCode;
              }
            },
            getNewId: (table) => {
              var ret = GL.counter++;
              for (var i2 = table.length; i2 < ret; i2++) {
                table[i2] = null;
              }
              return ret;
            },
            getSource: (shader, count, string, length) => {
              var source = "";
              for (var i2 = 0; i2 < count; ++i2) {
                var len2 = length ? HEAP32[length + i2 * 4 >>> 2 >>> 0] : -1;
                source += UTF8ToString(HEAP32[string + i2 * 4 >>> 2 >>> 0], len2 < 0 ? void 0 : len2);
              }
              return source;
            },
            createContext: (canvas, webGLContextAttributes) => {
              if (!canvas.getContextSafariWebGL2Fixed) {
                let fixedGetContext2 = function(ver, attrs) {
                  var gl = canvas.getContextSafariWebGL2Fixed(ver, attrs);
                  return ver == "webgl" == gl instanceof WebGLRenderingContext ? gl : null;
                };
                var fixedGetContext = fixedGetContext2;
                canvas.getContextSafariWebGL2Fixed = canvas.getContext;
                canvas.getContext = fixedGetContext2;
              }
              var ctx = canvas.getContext("webgl", webGLContextAttributes);
              if (!ctx)
                return 0;
              var handle2 = GL.registerContext(ctx, webGLContextAttributes);
              return handle2;
            },
            registerContext: (ctx, webGLContextAttributes) => {
              var handle2 = GL.getNewId(GL.contexts);
              var context = {
                handle: handle2,
                attributes: webGLContextAttributes,
                version: webGLContextAttributes.majorVersion,
                GLctx: ctx
              };
              if (ctx.canvas)
                ctx.canvas.GLctxObject = context;
              GL.contexts[handle2] = context;
              if (typeof webGLContextAttributes.enableExtensionsByDefault == "undefined" || webGLContextAttributes.enableExtensionsByDefault) {
                GL.initExtensions(context);
              }
              return handle2;
            },
            makeContextCurrent: (contextHandle) => {
              GL.currentContext = GL.contexts[contextHandle];
              Module.ctx = GLctx = GL.currentContext?.GLctx;
              return !(contextHandle && !GLctx);
            },
            getContext: (contextHandle) => GL.contexts[contextHandle],
            deleteContext: (contextHandle) => {
              if (GL.currentContext === GL.contexts[contextHandle]) {
                GL.currentContext = null;
              }
              if (typeof JSEvents == "object") {
                JSEvents.removeAllHandlersOnTarget(GL.contexts[contextHandle].GLctx.canvas);
              }
              if (GL.contexts[contextHandle] && GL.contexts[contextHandle].GLctx.canvas) {
                GL.contexts[contextHandle].GLctx.canvas.GLctxObject = void 0;
              }
              GL.contexts[contextHandle] = null;
            },
            initExtensions: (context) => {
              context || (context = GL.currentContext);
              if (context.initExtensionsDone)
                return;
              context.initExtensionsDone = true;
              var GLctx2 = context.GLctx;
              webgl_enable_ANGLE_instanced_arrays(GLctx2);
              webgl_enable_OES_vertex_array_object(GLctx2);
              webgl_enable_WEBGL_draw_buffers(GLctx2);
              {
                GLctx2.disjointTimerQueryExt = GLctx2.getExtension("EXT_disjoint_timer_query");
              }
              webgl_enable_WEBGL_multi_draw(GLctx2);
              getEmscriptenSupportedExtensions(GLctx2).forEach((ext) => {
                if (!ext.includes("lose_context") && !ext.includes("debug")) {
                  GLctx2.getExtension(ext);
                }
              });
            }
          };
          function _glActiveTexture(x0) {
            GLctx.activeTexture(x0);
          }
          _glActiveTexture.sig = "vi";
          var _emscripten_glActiveTexture = _glActiveTexture;
          var _glAttachShader = (program, shader) => {
            GLctx.attachShader(GL.programs[program], GL.shaders[shader]);
          };
          _glAttachShader.sig = "vii";
          var _emscripten_glAttachShader = _glAttachShader;
          var _glBeginQueryEXT = (target, id) => {
            GLctx.disjointTimerQueryExt["beginQueryEXT"](target, GL.queries[id]);
          };
          _glBeginQueryEXT.sig = "vii";
          var _emscripten_glBeginQueryEXT = _glBeginQueryEXT;
          function _glBindAttribLocation(program, index, name2) {
            name2 >>>= 0;
            GLctx.bindAttribLocation(GL.programs[program], index, UTF8ToString(name2));
          }
          _glBindAttribLocation.sig = "viip";
          var _emscripten_glBindAttribLocation = _glBindAttribLocation;
          var _glBindBuffer = (target, buffer) => {
            GLctx.bindBuffer(target, GL.buffers[buffer]);
          };
          _glBindBuffer.sig = "vii";
          var _emscripten_glBindBuffer = _glBindBuffer;
          var _glBindFramebuffer = (target, framebuffer) => {
            GLctx.bindFramebuffer(target, GL.framebuffers[framebuffer]);
          };
          _glBindFramebuffer.sig = "vii";
          var _emscripten_glBindFramebuffer = _glBindFramebuffer;
          var _glBindRenderbuffer = (target, renderbuffer) => {
            GLctx.bindRenderbuffer(target, GL.renderbuffers[renderbuffer]);
          };
          _glBindRenderbuffer.sig = "vii";
          var _emscripten_glBindRenderbuffer = _glBindRenderbuffer;
          var _glBindTexture = (target, texture) => {
            GLctx.bindTexture(target, GL.textures[texture]);
          };
          _glBindTexture.sig = "vii";
          var _emscripten_glBindTexture = _glBindTexture;
          var _glBindVertexArray = (vao) => {
            GLctx.bindVertexArray(GL.vaos[vao]);
          };
          _glBindVertexArray.sig = "vi";
          var _glBindVertexArrayOES = _glBindVertexArray;
          _glBindVertexArrayOES.sig = "vi";
          var _emscripten_glBindVertexArrayOES = _glBindVertexArrayOES;
          function _glBlendColor(x0, x1, x2, x3) {
            GLctx.blendColor(x0, x1, x2, x3);
          }
          _glBlendColor.sig = "vffff";
          var _emscripten_glBlendColor = _glBlendColor;
          function _glBlendEquation(x0) {
            GLctx.blendEquation(x0);
          }
          _glBlendEquation.sig = "vi";
          var _emscripten_glBlendEquation = _glBlendEquation;
          function _glBlendEquationSeparate(x0, x1) {
            GLctx.blendEquationSeparate(x0, x1);
          }
          _glBlendEquationSeparate.sig = "vii";
          var _emscripten_glBlendEquationSeparate = _glBlendEquationSeparate;
          function _glBlendFunc(x0, x1) {
            GLctx.blendFunc(x0, x1);
          }
          _glBlendFunc.sig = "vii";
          var _emscripten_glBlendFunc = _glBlendFunc;
          function _glBlendFuncSeparate(x0, x1, x2, x3) {
            GLctx.blendFuncSeparate(x0, x1, x2, x3);
          }
          _glBlendFuncSeparate.sig = "viiii";
          var _emscripten_glBlendFuncSeparate = _glBlendFuncSeparate;
          function _glBufferData(target, size, data2, usage) {
            size >>>= 0;
            data2 >>>= 0;
            GLctx.bufferData(target, data2 ? HEAPU8.subarray(data2 >>> 0, data2 + size >>> 0) : size, usage);
          }
          _glBufferData.sig = "vippi";
          var _emscripten_glBufferData = _glBufferData;
          function _glBufferSubData(target, offset, size, data2) {
            offset >>>= 0;
            size >>>= 0;
            data2 >>>= 0;
            GLctx.bufferSubData(target, offset, HEAPU8.subarray(data2 >>> 0, data2 + size >>> 0));
          }
          _glBufferSubData.sig = "vippp";
          var _emscripten_glBufferSubData = _glBufferSubData;
          function _glCheckFramebufferStatus(x0) {
            return GLctx.checkFramebufferStatus(x0);
          }
          _glCheckFramebufferStatus.sig = "ii";
          var _emscripten_glCheckFramebufferStatus = _glCheckFramebufferStatus;
          function _glClear(x0) {
            GLctx.clear(x0);
          }
          _glClear.sig = "vi";
          var _emscripten_glClear = _glClear;
          function _glClearColor(x0, x1, x2, x3) {
            GLctx.clearColor(x0, x1, x2, x3);
          }
          _glClearColor.sig = "vffff";
          var _emscripten_glClearColor = _glClearColor;
          function _glClearDepthf(x0) {
            GLctx.clearDepth(x0);
          }
          _glClearDepthf.sig = "vf";
          var _emscripten_glClearDepthf = _glClearDepthf;
          function _glClearStencil(x0) {
            GLctx.clearStencil(x0);
          }
          _glClearStencil.sig = "vi";
          var _emscripten_glClearStencil = _glClearStencil;
          var _glColorMask = (red, green, blue, alpha) => {
            GLctx.colorMask(!!red, !!green, !!blue, !!alpha);
          };
          _glColorMask.sig = "viiii";
          var _emscripten_glColorMask = _glColorMask;
          var _glCompileShader = (shader) => {
            GLctx.compileShader(GL.shaders[shader]);
          };
          _glCompileShader.sig = "vi";
          var _emscripten_glCompileShader = _glCompileShader;
          function _glCompressedTexImage2D(target, level, internalFormat, width, height, border, imageSize, data2) {
            data2 >>>= 0;
            GLctx.compressedTexImage2D(target, level, internalFormat, width, height, border, data2 ? HEAPU8.subarray(data2 >>> 0, data2 + imageSize >>> 0) : null);
          }
          _glCompressedTexImage2D.sig = "viiiiiiip";
          var _emscripten_glCompressedTexImage2D = _glCompressedTexImage2D;
          function _glCompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data2) {
            data2 >>>= 0;
            GLctx.compressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, data2 ? HEAPU8.subarray(data2 >>> 0, data2 + imageSize >>> 0) : null);
          }
          _glCompressedTexSubImage2D.sig = "viiiiiiiip";
          var _emscripten_glCompressedTexSubImage2D = _glCompressedTexSubImage2D;
          function _glCopyTexImage2D(x0, x1, x2, x3, x4, x5, x6, x7) {
            GLctx.copyTexImage2D(x0, x1, x2, x3, x4, x5, x6, x7);
          }
          _glCopyTexImage2D.sig = "viiiiiiii";
          var _emscripten_glCopyTexImage2D = _glCopyTexImage2D;
          function _glCopyTexSubImage2D(x0, x1, x2, x3, x4, x5, x6, x7) {
            GLctx.copyTexSubImage2D(x0, x1, x2, x3, x4, x5, x6, x7);
          }
          _glCopyTexSubImage2D.sig = "viiiiiiii";
          var _emscripten_glCopyTexSubImage2D = _glCopyTexSubImage2D;
          var _glCreateProgram = () => {
            var id = GL.getNewId(GL.programs);
            var program = GLctx.createProgram();
            program.name = id;
            program.maxUniformLength = program.maxAttributeLength = program.maxUniformBlockNameLength = 0;
            program.uniformIdCounter = 1;
            GL.programs[id] = program;
            return id;
          };
          _glCreateProgram.sig = "i";
          var _emscripten_glCreateProgram = _glCreateProgram;
          var _glCreateShader = (shaderType) => {
            var id = GL.getNewId(GL.shaders);
            GL.shaders[id] = GLctx.createShader(shaderType);
            return id;
          };
          _glCreateShader.sig = "ii";
          var _emscripten_glCreateShader = _glCreateShader;
          function _glCullFace(x0) {
            GLctx.cullFace(x0);
          }
          _glCullFace.sig = "vi";
          var _emscripten_glCullFace = _glCullFace;
          function _glDeleteBuffers(n, buffers) {
            buffers >>>= 0;
            for (var i2 = 0; i2 < n; i2++) {
              var id = HEAP32[buffers + i2 * 4 >>> 2 >>> 0];
              var buffer = GL.buffers[id];
              if (!buffer)
                continue;
              GLctx.deleteBuffer(buffer);
              buffer.name = 0;
              GL.buffers[id] = null;
            }
          }
          _glDeleteBuffers.sig = "vip";
          var _emscripten_glDeleteBuffers = _glDeleteBuffers;
          function _glDeleteFramebuffers(n, framebuffers) {
            framebuffers >>>= 0;
            for (var i2 = 0; i2 < n; ++i2) {
              var id = HEAP32[framebuffers + i2 * 4 >>> 2 >>> 0];
              var framebuffer = GL.framebuffers[id];
              if (!framebuffer)
                continue;
              GLctx.deleteFramebuffer(framebuffer);
              framebuffer.name = 0;
              GL.framebuffers[id] = null;
            }
          }
          _glDeleteFramebuffers.sig = "vip";
          var _emscripten_glDeleteFramebuffers = _glDeleteFramebuffers;
          var _glDeleteProgram = (id) => {
            if (!id)
              return;
            var program = GL.programs[id];
            if (!program) {
              GL.recordError(1281);
              return;
            }
            GLctx.deleteProgram(program);
            program.name = 0;
            GL.programs[id] = null;
          };
          _glDeleteProgram.sig = "vi";
          var _emscripten_glDeleteProgram = _glDeleteProgram;
          function _glDeleteQueriesEXT(n, ids) {
            ids >>>= 0;
            for (var i2 = 0; i2 < n; i2++) {
              var id = HEAP32[ids + i2 * 4 >>> 2 >>> 0];
              var query = GL.queries[id];
              if (!query)
                continue;
              GLctx.disjointTimerQueryExt["deleteQueryEXT"](query);
              GL.queries[id] = null;
            }
          }
          _glDeleteQueriesEXT.sig = "vip";
          var _emscripten_glDeleteQueriesEXT = _glDeleteQueriesEXT;
          function _glDeleteRenderbuffers(n, renderbuffers) {
            renderbuffers >>>= 0;
            for (var i2 = 0; i2 < n; i2++) {
              var id = HEAP32[renderbuffers + i2 * 4 >>> 2 >>> 0];
              var renderbuffer = GL.renderbuffers[id];
              if (!renderbuffer)
                continue;
              GLctx.deleteRenderbuffer(renderbuffer);
              renderbuffer.name = 0;
              GL.renderbuffers[id] = null;
            }
          }
          _glDeleteRenderbuffers.sig = "vip";
          var _emscripten_glDeleteRenderbuffers = _glDeleteRenderbuffers;
          var _glDeleteShader = (id) => {
            if (!id)
              return;
            var shader = GL.shaders[id];
            if (!shader) {
              GL.recordError(1281);
              return;
            }
            GLctx.deleteShader(shader);
            GL.shaders[id] = null;
          };
          _glDeleteShader.sig = "vi";
          var _emscripten_glDeleteShader = _glDeleteShader;
          function _glDeleteTextures(n, textures) {
            textures >>>= 0;
            for (var i2 = 0; i2 < n; i2++) {
              var id = HEAP32[textures + i2 * 4 >>> 2 >>> 0];
              var texture = GL.textures[id];
              if (!texture)
                continue;
              GLctx.deleteTexture(texture);
              texture.name = 0;
              GL.textures[id] = null;
            }
          }
          _glDeleteTextures.sig = "vip";
          var _emscripten_glDeleteTextures = _glDeleteTextures;
          function _glDeleteVertexArrays(n, vaos) {
            vaos >>>= 0;
            for (var i2 = 0; i2 < n; i2++) {
              var id = HEAP32[vaos + i2 * 4 >>> 2 >>> 0];
              GLctx.deleteVertexArray(GL.vaos[id]);
              GL.vaos[id] = null;
            }
          }
          _glDeleteVertexArrays.sig = "vip";
          var _glDeleteVertexArraysOES = _glDeleteVertexArrays;
          _glDeleteVertexArraysOES.sig = "vip";
          var _emscripten_glDeleteVertexArraysOES = _glDeleteVertexArraysOES;
          function _glDepthFunc(x0) {
            GLctx.depthFunc(x0);
          }
          _glDepthFunc.sig = "vi";
          var _emscripten_glDepthFunc = _glDepthFunc;
          var _glDepthMask = (flag) => {
            GLctx.depthMask(!!flag);
          };
          _glDepthMask.sig = "vi";
          var _emscripten_glDepthMask = _glDepthMask;
          function _glDepthRangef(x0, x1) {
            GLctx.depthRange(x0, x1);
          }
          _glDepthRangef.sig = "vff";
          var _emscripten_glDepthRangef = _glDepthRangef;
          var _glDetachShader = (program, shader) => {
            GLctx.detachShader(GL.programs[program], GL.shaders[shader]);
          };
          _glDetachShader.sig = "vii";
          var _emscripten_glDetachShader = _glDetachShader;
          function _glDisable(x0) {
            GLctx.disable(x0);
          }
          _glDisable.sig = "vi";
          var _emscripten_glDisable = _glDisable;
          var _glDisableVertexAttribArray = (index) => {
            GLctx.disableVertexAttribArray(index);
          };
          _glDisableVertexAttribArray.sig = "vi";
          var _emscripten_glDisableVertexAttribArray = _glDisableVertexAttribArray;
          var _glDrawArrays = (mode, first, count) => {
            GLctx.drawArrays(mode, first, count);
          };
          _glDrawArrays.sig = "viii";
          var _emscripten_glDrawArrays = _glDrawArrays;
          var _glDrawArraysInstanced = (mode, first, count, primcount) => {
            GLctx.drawArraysInstanced(mode, first, count, primcount);
          };
          _glDrawArraysInstanced.sig = "viiii";
          var _glDrawArraysInstancedANGLE = _glDrawArraysInstanced;
          var _emscripten_glDrawArraysInstancedANGLE = _glDrawArraysInstancedANGLE;
          var tempFixedLengthArray = [];
          function _glDrawBuffers(n, bufs) {
            bufs >>>= 0;
            var bufArray = tempFixedLengthArray[n];
            for (var i2 = 0; i2 < n; i2++) {
              bufArray[i2] = HEAP32[bufs + i2 * 4 >>> 2 >>> 0];
            }
            GLctx.drawBuffers(bufArray);
          }
          _glDrawBuffers.sig = "vip";
          var _glDrawBuffersWEBGL = _glDrawBuffers;
          var _emscripten_glDrawBuffersWEBGL = _glDrawBuffersWEBGL;
          function _glDrawElements(mode, count, type, indices) {
            indices >>>= 0;
            GLctx.drawElements(mode, count, type, indices);
          }
          _glDrawElements.sig = "viiip";
          var _emscripten_glDrawElements = _glDrawElements;
          function _glDrawElementsInstanced(mode, count, type, indices, primcount) {
            indices >>>= 0;
            GLctx.drawElementsInstanced(mode, count, type, indices, primcount);
          }
          _glDrawElementsInstanced.sig = "viiipi";
          var _glDrawElementsInstancedANGLE = _glDrawElementsInstanced;
          var _emscripten_glDrawElementsInstancedANGLE = _glDrawElementsInstancedANGLE;
          function _glEnable(x0) {
            GLctx.enable(x0);
          }
          _glEnable.sig = "vi";
          var _emscripten_glEnable = _glEnable;
          var _glEnableVertexAttribArray = (index) => {
            GLctx.enableVertexAttribArray(index);
          };
          _glEnableVertexAttribArray.sig = "vi";
          var _emscripten_glEnableVertexAttribArray = _glEnableVertexAttribArray;
          var _glEndQueryEXT = (target) => {
            GLctx.disjointTimerQueryExt["endQueryEXT"](target);
          };
          _glEndQueryEXT.sig = "vi";
          var _emscripten_glEndQueryEXT = _glEndQueryEXT;
          function _glFinish() {
            GLctx.finish();
          }
          _glFinish.sig = "v";
          var _emscripten_glFinish = _glFinish;
          function _glFlush() {
            GLctx.flush();
          }
          _glFlush.sig = "v";
          var _emscripten_glFlush = _glFlush;
          var _glFramebufferRenderbuffer = (target, attachment, renderbuffertarget, renderbuffer) => {
            GLctx.framebufferRenderbuffer(target, attachment, renderbuffertarget, GL.renderbuffers[renderbuffer]);
          };
          _glFramebufferRenderbuffer.sig = "viiii";
          var _emscripten_glFramebufferRenderbuffer = _glFramebufferRenderbuffer;
          var _glFramebufferTexture2D = (target, attachment, textarget, texture, level) => {
            GLctx.framebufferTexture2D(target, attachment, textarget, GL.textures[texture], level);
          };
          _glFramebufferTexture2D.sig = "viiiii";
          var _emscripten_glFramebufferTexture2D = _glFramebufferTexture2D;
          function _glFrontFace(x0) {
            GLctx.frontFace(x0);
          }
          _glFrontFace.sig = "vi";
          var _emscripten_glFrontFace = _glFrontFace;
          var __glGenObject = (n, buffers, createFunction, objectTable) => {
            for (var i2 = 0; i2 < n; i2++) {
              var buffer = GLctx[createFunction]();
              var id = buffer && GL.getNewId(objectTable);
              if (buffer) {
                buffer.name = id;
                objectTable[id] = buffer;
              } else {
                GL.recordError(1282);
              }
              HEAP32[buffers + i2 * 4 >>> 2 >>> 0] = id;
            }
          };
          function _glGenBuffers(n, buffers) {
            buffers >>>= 0;
            __glGenObject(n, buffers, "createBuffer", GL.buffers);
          }
          _glGenBuffers.sig = "vip";
          var _emscripten_glGenBuffers = _glGenBuffers;
          function _glGenFramebuffers(n, ids) {
            ids >>>= 0;
            __glGenObject(n, ids, "createFramebuffer", GL.framebuffers);
          }
          _glGenFramebuffers.sig = "vip";
          var _emscripten_glGenFramebuffers = _glGenFramebuffers;
          function _glGenQueriesEXT(n, ids) {
            ids >>>= 0;
            for (var i2 = 0; i2 < n; i2++) {
              var query = GLctx.disjointTimerQueryExt["createQueryEXT"]();
              if (!query) {
                GL.recordError(1282);
                while (i2 < n)
                  HEAP32[ids + i2++ * 4 >>> 2 >>> 0] = 0;
                return;
              }
              var id = GL.getNewId(GL.queries);
              query.name = id;
              GL.queries[id] = query;
              HEAP32[ids + i2 * 4 >>> 2 >>> 0] = id;
            }
          }
          _glGenQueriesEXT.sig = "vip";
          var _emscripten_glGenQueriesEXT = _glGenQueriesEXT;
          function _glGenRenderbuffers(n, renderbuffers) {
            renderbuffers >>>= 0;
            __glGenObject(n, renderbuffers, "createRenderbuffer", GL.renderbuffers);
          }
          _glGenRenderbuffers.sig = "vip";
          var _emscripten_glGenRenderbuffers = _glGenRenderbuffers;
          function _glGenTextures(n, textures) {
            textures >>>= 0;
            __glGenObject(n, textures, "createTexture", GL.textures);
          }
          _glGenTextures.sig = "vip";
          var _emscripten_glGenTextures = _glGenTextures;
          function _glGenVertexArrays(n, arrays) {
            arrays >>>= 0;
            __glGenObject(n, arrays, "createVertexArray", GL.vaos);
          }
          _glGenVertexArrays.sig = "vip";
          var _glGenVertexArraysOES = _glGenVertexArrays;
          _glGenVertexArraysOES.sig = "vip";
          var _emscripten_glGenVertexArraysOES = _glGenVertexArraysOES;
          function _glGenerateMipmap(x0) {
            GLctx.generateMipmap(x0);
          }
          _glGenerateMipmap.sig = "vi";
          var _emscripten_glGenerateMipmap = _glGenerateMipmap;
          var __glGetActiveAttribOrUniform = (funcName, program, index, bufSize, length, size, type, name2) => {
            program = GL.programs[program];
            var info2 = GLctx[funcName](program, index);
            if (info2) {
              var numBytesWrittenExclNull = name2 && stringToUTF8(info2.name, name2, bufSize);
              if (length)
                HEAP32[length >>> 2 >>> 0] = numBytesWrittenExclNull;
              if (size)
                HEAP32[size >>> 2 >>> 0] = info2.size;
              if (type)
                HEAP32[type >>> 2 >>> 0] = info2.type;
            }
          };
          function _glGetActiveAttrib(program, index, bufSize, length, size, type, name2) {
            length >>>= 0;
            size >>>= 0;
            type >>>= 0;
            name2 >>>= 0;
            __glGetActiveAttribOrUniform("getActiveAttrib", program, index, bufSize, length, size, type, name2);
          }
          _glGetActiveAttrib.sig = "viiipppp";
          var _emscripten_glGetActiveAttrib = _glGetActiveAttrib;
          function _glGetActiveUniform(program, index, bufSize, length, size, type, name2) {
            length >>>= 0;
            size >>>= 0;
            type >>>= 0;
            name2 >>>= 0;
            __glGetActiveAttribOrUniform("getActiveUniform", program, index, bufSize, length, size, type, name2);
          }
          _glGetActiveUniform.sig = "viiipppp";
          var _emscripten_glGetActiveUniform = _glGetActiveUniform;
          function _glGetAttachedShaders(program, maxCount, count, shaders) {
            count >>>= 0;
            shaders >>>= 0;
            var result = GLctx.getAttachedShaders(GL.programs[program]);
            var len2 = result.length;
            if (len2 > maxCount) {
              len2 = maxCount;
            }
            HEAP32[count >>> 2 >>> 0] = len2;
            for (var i2 = 0; i2 < len2; ++i2) {
              var id = GL.shaders.indexOf(result[i2]);
              HEAP32[shaders + i2 * 4 >>> 2 >>> 0] = id;
            }
          }
          _glGetAttachedShaders.sig = "viipp";
          var _emscripten_glGetAttachedShaders = _glGetAttachedShaders;
          function _glGetAttribLocation(program, name2) {
            name2 >>>= 0;
            return GLctx.getAttribLocation(GL.programs[program], UTF8ToString(name2));
          }
          _glGetAttribLocation.sig = "iip";
          var _emscripten_glGetAttribLocation = _glGetAttribLocation;
          var writeI53ToI64 = (ptr2, num) => {
            HEAPU32[ptr2 >>> 2 >>> 0] = num;
            var lower = HEAPU32[ptr2 >>> 2 >>> 0];
            HEAPU32[ptr2 + 4 >>> 2 >>> 0] = (num - lower) / 4294967296;
          };
          var emscriptenWebGLGet = (name_, p, type) => {
            if (!p) {
              GL.recordError(1281);
              return;
            }
            var ret = void 0;
            switch (name_) {
              case 36346:
                ret = 1;
                break;
              case 36344:
                if (type != 0 && type != 1) {
                  GL.recordError(1280);
                }
                return;
              case 36345:
                ret = 0;
                break;
              case 34466:
                var formats = GLctx.getParameter(34467);
                ret = formats ? formats.length : 0;
                break;
            }
            if (ret === void 0) {
              var result = GLctx.getParameter(name_);
              switch (typeof result) {
                case "number":
                  ret = result;
                  break;
                case "boolean":
                  ret = result ? 1 : 0;
                  break;
                case "string":
                  GL.recordError(1280);
                  return;
                case "object":
                  if (result === null) {
                    switch (name_) {
                      case 34964:
                      case 35725:
                      case 34965:
                      case 36006:
                      case 36007:
                      case 32873:
                      case 34229:
                      case 34068: {
                        ret = 0;
                        break;
                      }
                      default: {
                        GL.recordError(1280);
                        return;
                      }
                    }
                  } else if (result instanceof Float32Array || result instanceof Uint32Array || result instanceof Int32Array || result instanceof Array) {
                    for (var i2 = 0; i2 < result.length; ++i2) {
                      switch (type) {
                        case 0:
                          HEAP32[p + i2 * 4 >>> 2 >>> 0] = result[i2];
                          break;
                        case 2:
                          HEAPF32[p + i2 * 4 >>> 2 >>> 0] = result[i2];
                          break;
                        case 4:
                          HEAP8[p + i2 >>> 0 >>> 0] = result[i2] ? 1 : 0;
                          break;
                      }
                    }
                    return;
                  } else {
                    try {
                      ret = result.name | 0;
                    } catch (e) {
                      GL.recordError(1280);
                      err(`GL_INVALID_ENUM in glGet${type}v: Unknown object returned from WebGL getParameter(${name_})! (error: ${e})`);
                      return;
                    }
                  }
                  break;
                default:
                  GL.recordError(1280);
                  err(`GL_INVALID_ENUM in glGet${type}v: Native code calling glGet${type}v(${name_}) and it returns ${result} of type ${typeof result}!`);
                  return;
              }
            }
            switch (type) {
              case 1:
                writeI53ToI64(p, ret);
                break;
              case 0:
                HEAP32[p >>> 2 >>> 0] = ret;
                break;
              case 2:
                HEAPF32[p >>> 2 >>> 0] = ret;
                break;
              case 4:
                HEAP8[p >>> 0 >>> 0] = ret ? 1 : 0;
                break;
            }
          };
          function _glGetBooleanv(name_, p) {
            p >>>= 0;
            return emscriptenWebGLGet(name_, p, 4);
          }
          _glGetBooleanv.sig = "vip";
          var _emscripten_glGetBooleanv = _glGetBooleanv;
          function _glGetBufferParameteriv(target, value, data2) {
            data2 >>>= 0;
            if (!data2) {
              GL.recordError(1281);
              return;
            }
            HEAP32[data2 >>> 2 >>> 0] = GLctx.getBufferParameter(target, value);
          }
          _glGetBufferParameteriv.sig = "viip";
          var _emscripten_glGetBufferParameteriv = _glGetBufferParameteriv;
          var _glGetError = () => {
            var error = GLctx.getError() || GL.lastError;
            GL.lastError = 0;
            return error;
          };
          _glGetError.sig = "i";
          var _emscripten_glGetError = _glGetError;
          function _glGetFloatv(name_, p) {
            p >>>= 0;
            return emscriptenWebGLGet(name_, p, 2);
          }
          _glGetFloatv.sig = "vip";
          var _emscripten_glGetFloatv = _glGetFloatv;
          function _glGetFramebufferAttachmentParameteriv(target, attachment, pname, params) {
            params >>>= 0;
            var result = GLctx.getFramebufferAttachmentParameter(target, attachment, pname);
            if (result instanceof WebGLRenderbuffer || result instanceof WebGLTexture) {
              result = result.name | 0;
            }
            HEAP32[params >>> 2 >>> 0] = result;
          }
          _glGetFramebufferAttachmentParameteriv.sig = "viiip";
          var _emscripten_glGetFramebufferAttachmentParameteriv = _glGetFramebufferAttachmentParameteriv;
          function _glGetIntegerv(name_, p) {
            p >>>= 0;
            return emscriptenWebGLGet(name_, p, 0);
          }
          _glGetIntegerv.sig = "vip";
          var _emscripten_glGetIntegerv = _glGetIntegerv;
          function _glGetProgramInfoLog(program, maxLength, length, infoLog) {
            length >>>= 0;
            infoLog >>>= 0;
            var log = GLctx.getProgramInfoLog(GL.programs[program]);
            if (log === null)
              log = "(unknown error)";
            var numBytesWrittenExclNull = maxLength > 0 && infoLog ? stringToUTF8(log, infoLog, maxLength) : 0;
            if (length)
              HEAP32[length >>> 2 >>> 0] = numBytesWrittenExclNull;
          }
          _glGetProgramInfoLog.sig = "viipp";
          var _emscripten_glGetProgramInfoLog = _glGetProgramInfoLog;
          function _glGetProgramiv(program, pname, p) {
            p >>>= 0;
            if (!p) {
              GL.recordError(1281);
              return;
            }
            if (program >= GL.counter) {
              GL.recordError(1281);
              return;
            }
            program = GL.programs[program];
            if (pname == 35716) {
              var log = GLctx.getProgramInfoLog(program);
              if (log === null)
                log = "(unknown error)";
              HEAP32[p >>> 2 >>> 0] = log.length + 1;
            } else if (pname == 35719) {
              if (!program.maxUniformLength) {
                for (var i2 = 0; i2 < GLctx.getProgramParameter(program, 35718); ++i2) {
                  program.maxUniformLength = Math.max(program.maxUniformLength, GLctx.getActiveUniform(program, i2).name.length + 1);
                }
              }
              HEAP32[p >>> 2 >>> 0] = program.maxUniformLength;
            } else if (pname == 35722) {
              if (!program.maxAttributeLength) {
                for (var i2 = 0; i2 < GLctx.getProgramParameter(program, 35721); ++i2) {
                  program.maxAttributeLength = Math.max(program.maxAttributeLength, GLctx.getActiveAttrib(program, i2).name.length + 1);
                }
              }
              HEAP32[p >>> 2 >>> 0] = program.maxAttributeLength;
            } else if (pname == 35381) {
              if (!program.maxUniformBlockNameLength) {
                for (var i2 = 0; i2 < GLctx.getProgramParameter(program, 35382); ++i2) {
                  program.maxUniformBlockNameLength = Math.max(program.maxUniformBlockNameLength, GLctx.getActiveUniformBlockName(program, i2).length + 1);
                }
              }
              HEAP32[p >>> 2 >>> 0] = program.maxUniformBlockNameLength;
            } else {
              HEAP32[p >>> 2 >>> 0] = GLctx.getProgramParameter(program, pname);
            }
          }
          _glGetProgramiv.sig = "viip";
          var _emscripten_glGetProgramiv = _glGetProgramiv;
          function _glGetQueryObjecti64vEXT(id, pname, params) {
            params >>>= 0;
            if (!params) {
              GL.recordError(1281);
              return;
            }
            var query = GL.queries[id];
            var param;
            {
              param = GLctx.disjointTimerQueryExt["getQueryObjectEXT"](query, pname);
            }
            var ret;
            if (typeof param == "boolean") {
              ret = param ? 1 : 0;
            } else {
              ret = param;
            }
            writeI53ToI64(params, ret);
          }
          _glGetQueryObjecti64vEXT.sig = "viip";
          var _emscripten_glGetQueryObjecti64vEXT = _glGetQueryObjecti64vEXT;
          function _glGetQueryObjectivEXT(id, pname, params) {
            params >>>= 0;
            if (!params) {
              GL.recordError(1281);
              return;
            }
            var query = GL.queries[id];
            var param = GLctx.disjointTimerQueryExt["getQueryObjectEXT"](query, pname);
            var ret;
            if (typeof param == "boolean") {
              ret = param ? 1 : 0;
            } else {
              ret = param;
            }
            HEAP32[params >>> 2 >>> 0] = ret;
          }
          _glGetQueryObjectivEXT.sig = "viip";
          var _emscripten_glGetQueryObjectivEXT = _glGetQueryObjectivEXT;
          var _glGetQueryObjectui64vEXT = _glGetQueryObjecti64vEXT;
          var _emscripten_glGetQueryObjectui64vEXT = _glGetQueryObjectui64vEXT;
          var _glGetQueryObjectuivEXT = _glGetQueryObjectivEXT;
          var _emscripten_glGetQueryObjectuivEXT = _glGetQueryObjectuivEXT;
          function _glGetQueryivEXT(target, pname, params) {
            params >>>= 0;
            if (!params) {
              GL.recordError(1281);
              return;
            }
            HEAP32[params >>> 2 >>> 0] = GLctx.disjointTimerQueryExt["getQueryEXT"](target, pname);
          }
          _glGetQueryivEXT.sig = "viip";
          var _emscripten_glGetQueryivEXT = _glGetQueryivEXT;
          function _glGetRenderbufferParameteriv(target, pname, params) {
            params >>>= 0;
            if (!params) {
              GL.recordError(1281);
              return;
            }
            HEAP32[params >>> 2 >>> 0] = GLctx.getRenderbufferParameter(target, pname);
          }
          _glGetRenderbufferParameteriv.sig = "viip";
          var _emscripten_glGetRenderbufferParameteriv = _glGetRenderbufferParameteriv;
          function _glGetShaderInfoLog(shader, maxLength, length, infoLog) {
            length >>>= 0;
            infoLog >>>= 0;
            var log = GLctx.getShaderInfoLog(GL.shaders[shader]);
            if (log === null)
              log = "(unknown error)";
            var numBytesWrittenExclNull = maxLength > 0 && infoLog ? stringToUTF8(log, infoLog, maxLength) : 0;
            if (length)
              HEAP32[length >>> 2 >>> 0] = numBytesWrittenExclNull;
          }
          _glGetShaderInfoLog.sig = "viipp";
          var _emscripten_glGetShaderInfoLog = _glGetShaderInfoLog;
          function _glGetShaderPrecisionFormat(shaderType, precisionType, range, precision) {
            range >>>= 0;
            precision >>>= 0;
            var result = GLctx.getShaderPrecisionFormat(shaderType, precisionType);
            HEAP32[range >>> 2 >>> 0] = result.rangeMin;
            HEAP32[range + 4 >>> 2 >>> 0] = result.rangeMax;
            HEAP32[precision >>> 2 >>> 0] = result.precision;
          }
          _glGetShaderPrecisionFormat.sig = "viipp";
          var _emscripten_glGetShaderPrecisionFormat = _glGetShaderPrecisionFormat;
          function _glGetShaderSource(shader, bufSize, length, source) {
            length >>>= 0;
            source >>>= 0;
            var result = GLctx.getShaderSource(GL.shaders[shader]);
            if (!result)
              return;
            var numBytesWrittenExclNull = bufSize > 0 && source ? stringToUTF8(result, source, bufSize) : 0;
            if (length)
              HEAP32[length >>> 2 >>> 0] = numBytesWrittenExclNull;
          }
          _glGetShaderSource.sig = "viipp";
          var _emscripten_glGetShaderSource = _glGetShaderSource;
          function _glGetShaderiv(shader, pname, p) {
            p >>>= 0;
            if (!p) {
              GL.recordError(1281);
              return;
            }
            if (pname == 35716) {
              var log = GLctx.getShaderInfoLog(GL.shaders[shader]);
              if (log === null)
                log = "(unknown error)";
              var logLength = log ? log.length + 1 : 0;
              HEAP32[p >>> 2 >>> 0] = logLength;
            } else if (pname == 35720) {
              var source = GLctx.getShaderSource(GL.shaders[shader]);
              var sourceLength = source ? source.length + 1 : 0;
              HEAP32[p >>> 2 >>> 0] = sourceLength;
            } else {
              HEAP32[p >>> 2 >>> 0] = GLctx.getShaderParameter(GL.shaders[shader], pname);
            }
          }
          _glGetShaderiv.sig = "viip";
          var _emscripten_glGetShaderiv = _glGetShaderiv;
          var webglGetExtensions = function $webglGetExtensions() {
            var exts = getEmscriptenSupportedExtensions(GLctx);
            exts = exts.concat(exts.map((e) => "GL_" + e));
            return exts;
          };
          function _glGetString(name_) {
            var ret = GL.stringCache[name_];
            if (!ret) {
              switch (name_) {
                case 7939:
                  ret = stringToNewUTF8(webglGetExtensions().join(" "));
                  break;
                case 7936:
                case 7937:
                case 37445:
                case 37446:
                  var s2 = GLctx.getParameter(name_);
                  if (!s2) {
                    GL.recordError(1280);
                  }
                  ret = s2 ? stringToNewUTF8(s2) : 0;
                  break;
                case 7938:
                  var glVersion = GLctx.getParameter(7938);
                  {
                    glVersion = `OpenGL ES 2.0 (${glVersion})`;
                  }
                  ret = stringToNewUTF8(glVersion);
                  break;
                case 35724:
                  var glslVersion = GLctx.getParameter(35724);
                  var ver_re = /^WebGL GLSL ES ([0-9]\.[0-9][0-9]?)(?:$| .*)/;
                  var ver_num = glslVersion.match(ver_re);
                  if (ver_num !== null) {
                    if (ver_num[1].length == 3)
                      ver_num[1] = ver_num[1] + "0";
                    glslVersion = `OpenGL ES GLSL ES ${ver_num[1]} (${glslVersion})`;
                  }
                  ret = stringToNewUTF8(glslVersion);
                  break;
                default:
                  GL.recordError(1280);
              }
              GL.stringCache[name_] = ret;
            }
            return ret;
          }
          _glGetString.sig = "pi";
          var _emscripten_glGetString = _glGetString;
          function _glGetTexParameterfv(target, pname, params) {
            params >>>= 0;
            if (!params) {
              GL.recordError(1281);
              return;
            }
            HEAPF32[params >>> 2 >>> 0] = GLctx.getTexParameter(target, pname);
          }
          _glGetTexParameterfv.sig = "viip";
          var _emscripten_glGetTexParameterfv = _glGetTexParameterfv;
          function _glGetTexParameteriv(target, pname, params) {
            params >>>= 0;
            if (!params) {
              GL.recordError(1281);
              return;
            }
            HEAP32[params >>> 2 >>> 0] = GLctx.getTexParameter(target, pname);
          }
          _glGetTexParameteriv.sig = "viip";
          var _emscripten_glGetTexParameteriv = _glGetTexParameteriv;
          var webglGetLeftBracePos = (name2) => name2.slice(-1) == "]" && name2.lastIndexOf("[");
          var webglPrepareUniformLocationsBeforeFirstUse = (program) => {
            var uniformLocsById = program.uniformLocsById, uniformSizeAndIdsByName = program.uniformSizeAndIdsByName, i2, j;
            if (!uniformLocsById) {
              program.uniformLocsById = uniformLocsById = {};
              program.uniformArrayNamesById = {};
              for (i2 = 0; i2 < GLctx.getProgramParameter(program, 35718); ++i2) {
                var u = GLctx.getActiveUniform(program, i2);
                var nm = u.name;
                var sz = u.size;
                var lb = webglGetLeftBracePos(nm);
                var arrayName = lb > 0 ? nm.slice(0, lb) : nm;
                var id = program.uniformIdCounter;
                program.uniformIdCounter += sz;
                uniformSizeAndIdsByName[arrayName] = [sz, id];
                for (j = 0; j < sz; ++j) {
                  uniformLocsById[id] = j;
                  program.uniformArrayNamesById[id++] = arrayName;
                }
              }
            }
          };
          function _glGetUniformLocation(program, name2) {
            name2 >>>= 0;
            name2 = UTF8ToString(name2);
            if (program = GL.programs[program]) {
              webglPrepareUniformLocationsBeforeFirstUse(program);
              var uniformLocsById = program.uniformLocsById;
              var arrayIndex = 0;
              var uniformBaseName = name2;
              var leftBrace = webglGetLeftBracePos(name2);
              if (leftBrace > 0) {
                arrayIndex = jstoi_q(name2.slice(leftBrace + 1)) >>> 0;
                uniformBaseName = name2.slice(0, leftBrace);
              }
              var sizeAndId = program.uniformSizeAndIdsByName[uniformBaseName];
              if (sizeAndId && arrayIndex < sizeAndId[0]) {
                arrayIndex += sizeAndId[1];
                if (uniformLocsById[arrayIndex] = uniformLocsById[arrayIndex] || GLctx.getUniformLocation(program, name2)) {
                  return arrayIndex;
                }
              }
            } else {
              GL.recordError(1281);
            }
            return -1;
          }
          _glGetUniformLocation.sig = "iip";
          var _emscripten_glGetUniformLocation = _glGetUniformLocation;
          var webglGetUniformLocation = (location) => {
            var p = GLctx.currentProgram;
            if (p) {
              var webglLoc = p.uniformLocsById[location];
              if (typeof webglLoc == "number") {
                p.uniformLocsById[location] = webglLoc = GLctx.getUniformLocation(p, p.uniformArrayNamesById[location] + (webglLoc > 0 ? `[${webglLoc}]` : ""));
              }
              return webglLoc;
            } else {
              GL.recordError(1282);
            }
          };
          var emscriptenWebGLGetUniform = (program, location, params, type) => {
            if (!params) {
              GL.recordError(1281);
              return;
            }
            program = GL.programs[program];
            webglPrepareUniformLocationsBeforeFirstUse(program);
            var data2 = GLctx.getUniform(program, webglGetUniformLocation(location));
            if (typeof data2 == "number" || typeof data2 == "boolean") {
              switch (type) {
                case 0:
                  HEAP32[params >>> 2 >>> 0] = data2;
                  break;
                case 2:
                  HEAPF32[params >>> 2 >>> 0] = data2;
                  break;
              }
            } else {
              for (var i2 = 0; i2 < data2.length; i2++) {
                switch (type) {
                  case 0:
                    HEAP32[params + i2 * 4 >>> 2 >>> 0] = data2[i2];
                    break;
                  case 2:
                    HEAPF32[params + i2 * 4 >>> 2 >>> 0] = data2[i2];
                    break;
                }
              }
            }
          };
          function _glGetUniformfv(program, location, params) {
            params >>>= 0;
            emscriptenWebGLGetUniform(program, location, params, 2);
          }
          _glGetUniformfv.sig = "viip";
          var _emscripten_glGetUniformfv = _glGetUniformfv;
          function _glGetUniformiv(program, location, params) {
            params >>>= 0;
            emscriptenWebGLGetUniform(program, location, params, 0);
          }
          _glGetUniformiv.sig = "viip";
          var _emscripten_glGetUniformiv = _glGetUniformiv;
          function _glGetVertexAttribPointerv(index, pname, pointer) {
            pointer >>>= 0;
            if (!pointer) {
              GL.recordError(1281);
              return;
            }
            HEAP32[pointer >>> 2 >>> 0] = GLctx.getVertexAttribOffset(index, pname);
          }
          _glGetVertexAttribPointerv.sig = "viip";
          var _emscripten_glGetVertexAttribPointerv = _glGetVertexAttribPointerv;
          var emscriptenWebGLGetVertexAttrib = (index, pname, params, type) => {
            if (!params) {
              GL.recordError(1281);
              return;
            }
            var data2 = GLctx.getVertexAttrib(index, pname);
            if (pname == 34975) {
              HEAP32[params >>> 2 >>> 0] = data2 && data2["name"];
            } else if (typeof data2 == "number" || typeof data2 == "boolean") {
              switch (type) {
                case 0:
                  HEAP32[params >>> 2 >>> 0] = data2;
                  break;
                case 2:
                  HEAPF32[params >>> 2 >>> 0] = data2;
                  break;
                case 5:
                  HEAP32[params >>> 2 >>> 0] = Math.fround(data2);
                  break;
              }
            } else {
              for (var i2 = 0; i2 < data2.length; i2++) {
                switch (type) {
                  case 0:
                    HEAP32[params + i2 * 4 >>> 2 >>> 0] = data2[i2];
                    break;
                  case 2:
                    HEAPF32[params + i2 * 4 >>> 2 >>> 0] = data2[i2];
                    break;
                  case 5:
                    HEAP32[params + i2 * 4 >>> 2 >>> 0] = Math.fround(data2[i2]);
                    break;
                }
              }
            }
          };
          function _glGetVertexAttribfv(index, pname, params) {
            params >>>= 0;
            emscriptenWebGLGetVertexAttrib(index, pname, params, 2);
          }
          _glGetVertexAttribfv.sig = "viip";
          var _emscripten_glGetVertexAttribfv = _glGetVertexAttribfv;
          function _glGetVertexAttribiv(index, pname, params) {
            params >>>= 0;
            emscriptenWebGLGetVertexAttrib(index, pname, params, 5);
          }
          _glGetVertexAttribiv.sig = "viip";
          var _emscripten_glGetVertexAttribiv = _glGetVertexAttribiv;
          function _glHint(x0, x1) {
            GLctx.hint(x0, x1);
          }
          _glHint.sig = "vii";
          var _emscripten_glHint = _glHint;
          var _glIsBuffer = (buffer) => {
            var b = GL.buffers[buffer];
            if (!b)
              return 0;
            return GLctx.isBuffer(b);
          };
          _glIsBuffer.sig = "ii";
          var _emscripten_glIsBuffer = _glIsBuffer;
          function _glIsEnabled(x0) {
            return GLctx.isEnabled(x0);
          }
          _glIsEnabled.sig = "ii";
          var _emscripten_glIsEnabled = _glIsEnabled;
          var _glIsFramebuffer = (framebuffer) => {
            var fb = GL.framebuffers[framebuffer];
            if (!fb)
              return 0;
            return GLctx.isFramebuffer(fb);
          };
          _glIsFramebuffer.sig = "ii";
          var _emscripten_glIsFramebuffer = _glIsFramebuffer;
          var _glIsProgram = (program) => {
            program = GL.programs[program];
            if (!program)
              return 0;
            return GLctx.isProgram(program);
          };
          _glIsProgram.sig = "ii";
          var _emscripten_glIsProgram = _glIsProgram;
          var _glIsQueryEXT = (id) => {
            var query = GL.queries[id];
            if (!query)
              return 0;
            return GLctx.disjointTimerQueryExt["isQueryEXT"](query);
          };
          _glIsQueryEXT.sig = "ii";
          var _emscripten_glIsQueryEXT = _glIsQueryEXT;
          var _glIsRenderbuffer = (renderbuffer) => {
            var rb = GL.renderbuffers[renderbuffer];
            if (!rb)
              return 0;
            return GLctx.isRenderbuffer(rb);
          };
          _glIsRenderbuffer.sig = "ii";
          var _emscripten_glIsRenderbuffer = _glIsRenderbuffer;
          var _glIsShader = (shader) => {
            var s2 = GL.shaders[shader];
            if (!s2)
              return 0;
            return GLctx.isShader(s2);
          };
          _glIsShader.sig = "ii";
          var _emscripten_glIsShader = _glIsShader;
          var _glIsTexture = (id) => {
            var texture = GL.textures[id];
            if (!texture)
              return 0;
            return GLctx.isTexture(texture);
          };
          _glIsTexture.sig = "ii";
          var _emscripten_glIsTexture = _glIsTexture;
          var _glIsVertexArray = (array) => {
            var vao = GL.vaos[array];
            if (!vao)
              return 0;
            return GLctx.isVertexArray(vao);
          };
          _glIsVertexArray.sig = "ii";
          var _glIsVertexArrayOES = _glIsVertexArray;
          _glIsVertexArrayOES.sig = "ii";
          var _emscripten_glIsVertexArrayOES = _glIsVertexArrayOES;
          function _glLineWidth(x0) {
            GLctx.lineWidth(x0);
          }
          _glLineWidth.sig = "vf";
          var _emscripten_glLineWidth = _glLineWidth;
          var _glLinkProgram = (program) => {
            program = GL.programs[program];
            GLctx.linkProgram(program);
            program.uniformLocsById = 0;
            program.uniformSizeAndIdsByName = {};
          };
          _glLinkProgram.sig = "vi";
          var _emscripten_glLinkProgram = _glLinkProgram;
          var _glPixelStorei = (pname, param) => {
            if (pname == 3317) {
              GL.unpackAlignment = param;
            }
            GLctx.pixelStorei(pname, param);
          };
          _glPixelStorei.sig = "vii";
          var _emscripten_glPixelStorei = _glPixelStorei;
          function _glPolygonOffset(x0, x1) {
            GLctx.polygonOffset(x0, x1);
          }
          _glPolygonOffset.sig = "vff";
          var _emscripten_glPolygonOffset = _glPolygonOffset;
          var _glQueryCounterEXT = (id, target) => {
            GLctx.disjointTimerQueryExt["queryCounterEXT"](GL.queries[id], target);
          };
          _glQueryCounterEXT.sig = "vii";
          var _emscripten_glQueryCounterEXT = _glQueryCounterEXT;
          var computeUnpackAlignedImageSize = (width, height, sizePerPixel, alignment) => {
            function roundedToNextMultipleOf(x, y) {
              return x + y - 1 & -y;
            }
            var plainRowSize = width * sizePerPixel;
            var alignedRowSize = roundedToNextMultipleOf(plainRowSize, alignment);
            return height * alignedRowSize;
          };
          var colorChannelsInGlTextureFormat = (format) => {
            var colorChannels = {
              5: 3,
              6: 4,
              8: 2,
              29502: 3,
              29504: 4
            };
            return colorChannels[format - 6402] || 1;
          };
          var heapObjectForWebGLType = (type) => {
            type -= 5120;
            if (type == 1)
              return HEAPU8;
            if (type == 4)
              return HEAP32;
            if (type == 6)
              return HEAPF32;
            if (type == 5 || type == 28922)
              return HEAPU32;
            return HEAPU16;
          };
          var heapAccessShiftForWebGLHeap = (heap) => 31 - Math.clz32(heap.BYTES_PER_ELEMENT);
          var emscriptenWebGLGetTexPixelData = (type, format, width, height, pixels, internalFormat) => {
            var heap = heapObjectForWebGLType(type);
            var shift = heapAccessShiftForWebGLHeap(heap);
            var byteSize = 1 << shift;
            var sizePerPixel = colorChannelsInGlTextureFormat(format) * byteSize;
            var bytes = computeUnpackAlignedImageSize(width, height, sizePerPixel, GL.unpackAlignment);
            return heap.subarray(pixels >>> shift, pixels + bytes >>> shift);
          };
          function _glReadPixels(x, y, width, height, format, type, pixels) {
            pixels >>>= 0;
            var pixelData = emscriptenWebGLGetTexPixelData(type, format, width, height, pixels, format);
            if (!pixelData) {
              GL.recordError(1280);
              return;
            }
            GLctx.readPixels(x, y, width, height, format, type, pixelData);
          }
          _glReadPixels.sig = "viiiiiip";
          var _emscripten_glReadPixels = _glReadPixels;
          var _glReleaseShaderCompiler = () => {
          };
          _glReleaseShaderCompiler.sig = "v";
          var _emscripten_glReleaseShaderCompiler = _glReleaseShaderCompiler;
          function _glRenderbufferStorage(x0, x1, x2, x3) {
            GLctx.renderbufferStorage(x0, x1, x2, x3);
          }
          _glRenderbufferStorage.sig = "viiii";
          var _emscripten_glRenderbufferStorage = _glRenderbufferStorage;
          var _glSampleCoverage = (value, invert) => {
            GLctx.sampleCoverage(value, !!invert);
          };
          _glSampleCoverage.sig = "vfi";
          var _emscripten_glSampleCoverage = _glSampleCoverage;
          function _glScissor(x0, x1, x2, x3) {
            GLctx.scissor(x0, x1, x2, x3);
          }
          _glScissor.sig = "viiii";
          var _emscripten_glScissor = _glScissor;
          function _glShaderBinary(count, shaders, binaryformat, binary2, length) {
            shaders >>>= 0;
            binary2 >>>= 0;
            GL.recordError(1280);
          }
          _glShaderBinary.sig = "vipipi";
          var _emscripten_glShaderBinary = _glShaderBinary;
          function _glShaderSource(shader, count, string, length) {
            string >>>= 0;
            length >>>= 0;
            var source = GL.getSource(shader, count, string, length);
            GLctx.shaderSource(GL.shaders[shader], source);
          }
          _glShaderSource.sig = "viipp";
          var _emscripten_glShaderSource = _glShaderSource;
          function _glStencilFunc(x0, x1, x2) {
            GLctx.stencilFunc(x0, x1, x2);
          }
          _glStencilFunc.sig = "viii";
          var _emscripten_glStencilFunc = _glStencilFunc;
          function _glStencilFuncSeparate(x0, x1, x2, x3) {
            GLctx.stencilFuncSeparate(x0, x1, x2, x3);
          }
          _glStencilFuncSeparate.sig = "viiii";
          var _emscripten_glStencilFuncSeparate = _glStencilFuncSeparate;
          function _glStencilMask(x0) {
            GLctx.stencilMask(x0);
          }
          _glStencilMask.sig = "vi";
          var _emscripten_glStencilMask = _glStencilMask;
          function _glStencilMaskSeparate(x0, x1) {
            GLctx.stencilMaskSeparate(x0, x1);
          }
          _glStencilMaskSeparate.sig = "vii";
          var _emscripten_glStencilMaskSeparate = _glStencilMaskSeparate;
          function _glStencilOp(x0, x1, x2) {
            GLctx.stencilOp(x0, x1, x2);
          }
          _glStencilOp.sig = "viii";
          var _emscripten_glStencilOp = _glStencilOp;
          function _glStencilOpSeparate(x0, x1, x2, x3) {
            GLctx.stencilOpSeparate(x0, x1, x2, x3);
          }
          _glStencilOpSeparate.sig = "viiii";
          var _emscripten_glStencilOpSeparate = _glStencilOpSeparate;
          function _glTexImage2D(target, level, internalFormat, width, height, border, format, type, pixels) {
            pixels >>>= 0;
            GLctx.texImage2D(target, level, internalFormat, width, height, border, format, type, pixels ? emscriptenWebGLGetTexPixelData(type, format, width, height, pixels, internalFormat) : null);
          }
          _glTexImage2D.sig = "viiiiiiiip";
          var _emscripten_glTexImage2D = _glTexImage2D;
          function _glTexParameterf(x0, x1, x2) {
            GLctx.texParameterf(x0, x1, x2);
          }
          _glTexParameterf.sig = "viif";
          var _emscripten_glTexParameterf = _glTexParameterf;
          function _glTexParameterfv(target, pname, params) {
            params >>>= 0;
            var param = HEAPF32[params >>> 2 >>> 0];
            GLctx.texParameterf(target, pname, param);
          }
          _glTexParameterfv.sig = "viip";
          var _emscripten_glTexParameterfv = _glTexParameterfv;
          function _glTexParameteri(x0, x1, x2) {
            GLctx.texParameteri(x0, x1, x2);
          }
          _glTexParameteri.sig = "viii";
          var _emscripten_glTexParameteri = _glTexParameteri;
          function _glTexParameteriv(target, pname, params) {
            params >>>= 0;
            var param = HEAP32[params >>> 2 >>> 0];
            GLctx.texParameteri(target, pname, param);
          }
          _glTexParameteriv.sig = "viip";
          var _emscripten_glTexParameteriv = _glTexParameteriv;
          function _glTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels) {
            pixels >>>= 0;
            var pixelData = null;
            if (pixels)
              pixelData = emscriptenWebGLGetTexPixelData(type, format, width, height, pixels, 0);
            GLctx.texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixelData);
          }
          _glTexSubImage2D.sig = "viiiiiiiip";
          var _emscripten_glTexSubImage2D = _glTexSubImage2D;
          var _glUniform1f = (location, v0) => {
            GLctx.uniform1f(webglGetUniformLocation(location), v0);
          };
          _glUniform1f.sig = "vif";
          var _emscripten_glUniform1f = _glUniform1f;
          var miniTempWebGLFloatBuffers = [];
          function _glUniform1fv(location, count, value) {
            value >>>= 0;
            if (count <= 288) {
              var view = miniTempWebGLFloatBuffers[count - 1];
              for (var i2 = 0; i2 < count; ++i2) {
                view[i2] = HEAPF32[value + 4 * i2 >>> 2 >>> 0];
              }
            } else {
              var view = HEAPF32.subarray(value >>> 2 >>> 0, value + count * 4 >>> 2 >>> 0);
            }
            GLctx.uniform1fv(webglGetUniformLocation(location), view);
          }
          _glUniform1fv.sig = "viip";
          var _emscripten_glUniform1fv = _glUniform1fv;
          var _glUniform1i = (location, v0) => {
            GLctx.uniform1i(webglGetUniformLocation(location), v0);
          };
          _glUniform1i.sig = "vii";
          var _emscripten_glUniform1i = _glUniform1i;
          var miniTempWebGLIntBuffers = [];
          function _glUniform1iv(location, count, value) {
            value >>>= 0;
            if (count <= 288) {
              var view = miniTempWebGLIntBuffers[count - 1];
              for (var i2 = 0; i2 < count; ++i2) {
                view[i2] = HEAP32[value + 4 * i2 >>> 2 >>> 0];
              }
            } else {
              var view = HEAP32.subarray(value >>> 2 >>> 0, value + count * 4 >>> 2 >>> 0);
            }
            GLctx.uniform1iv(webglGetUniformLocation(location), view);
          }
          _glUniform1iv.sig = "viip";
          var _emscripten_glUniform1iv = _glUniform1iv;
          var _glUniform2f = (location, v0, v1) => {
            GLctx.uniform2f(webglGetUniformLocation(location), v0, v1);
          };
          _glUniform2f.sig = "viff";
          var _emscripten_glUniform2f = _glUniform2f;
          function _glUniform2fv(location, count, value) {
            value >>>= 0;
            if (count <= 144) {
              var view = miniTempWebGLFloatBuffers[2 * count - 1];
              for (var i2 = 0; i2 < 2 * count; i2 += 2) {
                view[i2] = HEAPF32[value + 4 * i2 >>> 2 >>> 0];
                view[i2 + 1] = HEAPF32[value + (4 * i2 + 4) >>> 2 >>> 0];
              }
            } else {
              var view = HEAPF32.subarray(value >>> 2 >>> 0, value + count * 8 >>> 2 >>> 0);
            }
            GLctx.uniform2fv(webglGetUniformLocation(location), view);
          }
          _glUniform2fv.sig = "viip";
          var _emscripten_glUniform2fv = _glUniform2fv;
          var _glUniform2i = (location, v0, v1) => {
            GLctx.uniform2i(webglGetUniformLocation(location), v0, v1);
          };
          _glUniform2i.sig = "viii";
          var _emscripten_glUniform2i = _glUniform2i;
          function _glUniform2iv(location, count, value) {
            value >>>= 0;
            if (count <= 144) {
              var view = miniTempWebGLIntBuffers[2 * count - 1];
              for (var i2 = 0; i2 < 2 * count; i2 += 2) {
                view[i2] = HEAP32[value + 4 * i2 >>> 2 >>> 0];
                view[i2 + 1] = HEAP32[value + (4 * i2 + 4) >>> 2 >>> 0];
              }
            } else {
              var view = HEAP32.subarray(value >>> 2 >>> 0, value + count * 8 >>> 2 >>> 0);
            }
            GLctx.uniform2iv(webglGetUniformLocation(location), view);
          }
          _glUniform2iv.sig = "viip";
          var _emscripten_glUniform2iv = _glUniform2iv;
          var _glUniform3f = (location, v0, v1, v2) => {
            GLctx.uniform3f(webglGetUniformLocation(location), v0, v1, v2);
          };
          _glUniform3f.sig = "vifff";
          var _emscripten_glUniform3f = _glUniform3f;
          function _glUniform3fv(location, count, value) {
            value >>>= 0;
            if (count <= 96) {
              var view = miniTempWebGLFloatBuffers[3 * count - 1];
              for (var i2 = 0; i2 < 3 * count; i2 += 3) {
                view[i2] = HEAPF32[value + 4 * i2 >>> 2 >>> 0];
                view[i2 + 1] = HEAPF32[value + (4 * i2 + 4) >>> 2 >>> 0];
                view[i2 + 2] = HEAPF32[value + (4 * i2 + 8) >>> 2 >>> 0];
              }
            } else {
              var view = HEAPF32.subarray(value >>> 2 >>> 0, value + count * 12 >>> 2 >>> 0);
            }
            GLctx.uniform3fv(webglGetUniformLocation(location), view);
          }
          _glUniform3fv.sig = "viip";
          var _emscripten_glUniform3fv = _glUniform3fv;
          var _glUniform3i = (location, v0, v1, v2) => {
            GLctx.uniform3i(webglGetUniformLocation(location), v0, v1, v2);
          };
          _glUniform3i.sig = "viiii";
          var _emscripten_glUniform3i = _glUniform3i;
          function _glUniform3iv(location, count, value) {
            value >>>= 0;
            if (count <= 96) {
              var view = miniTempWebGLIntBuffers[3 * count - 1];
              for (var i2 = 0; i2 < 3 * count; i2 += 3) {
                view[i2] = HEAP32[value + 4 * i2 >>> 2 >>> 0];
                view[i2 + 1] = HEAP32[value + (4 * i2 + 4) >>> 2 >>> 0];
                view[i2 + 2] = HEAP32[value + (4 * i2 + 8) >>> 2 >>> 0];
              }
            } else {
              var view = HEAP32.subarray(value >>> 2 >>> 0, value + count * 12 >>> 2 >>> 0);
            }
            GLctx.uniform3iv(webglGetUniformLocation(location), view);
          }
          _glUniform3iv.sig = "viip";
          var _emscripten_glUniform3iv = _glUniform3iv;
          var _glUniform4f = (location, v0, v1, v2, v3) => {
            GLctx.uniform4f(webglGetUniformLocation(location), v0, v1, v2, v3);
          };
          _glUniform4f.sig = "viffff";
          var _emscripten_glUniform4f = _glUniform4f;
          function _glUniform4fv(location, count, value) {
            value >>>= 0;
            if (count <= 72) {
              var view = miniTempWebGLFloatBuffers[4 * count - 1];
              var heap = HEAPF32;
              value >>= 2;
              for (var i2 = 0; i2 < 4 * count; i2 += 4) {
                var dst = value + i2;
                view[i2] = heap[dst >>> 0];
                view[i2 + 1] = heap[dst + 1 >>> 0];
                view[i2 + 2] = heap[dst + 2 >>> 0];
                view[i2 + 3] = heap[dst + 3 >>> 0];
              }
            } else {
              var view = HEAPF32.subarray(value >>> 2 >>> 0, value + count * 16 >>> 2 >>> 0);
            }
            GLctx.uniform4fv(webglGetUniformLocation(location), view);
          }
          _glUniform4fv.sig = "viip";
          var _emscripten_glUniform4fv = _glUniform4fv;
          var _glUniform4i = (location, v0, v1, v2, v3) => {
            GLctx.uniform4i(webglGetUniformLocation(location), v0, v1, v2, v3);
          };
          _glUniform4i.sig = "viiiii";
          var _emscripten_glUniform4i = _glUniform4i;
          function _glUniform4iv(location, count, value) {
            value >>>= 0;
            if (count <= 72) {
              var view = miniTempWebGLIntBuffers[4 * count - 1];
              for (var i2 = 0; i2 < 4 * count; i2 += 4) {
                view[i2] = HEAP32[value + 4 * i2 >>> 2 >>> 0];
                view[i2 + 1] = HEAP32[value + (4 * i2 + 4) >>> 2 >>> 0];
                view[i2 + 2] = HEAP32[value + (4 * i2 + 8) >>> 2 >>> 0];
                view[i2 + 3] = HEAP32[value + (4 * i2 + 12) >>> 2 >>> 0];
              }
            } else {
              var view = HEAP32.subarray(value >>> 2 >>> 0, value + count * 16 >>> 2 >>> 0);
            }
            GLctx.uniform4iv(webglGetUniformLocation(location), view);
          }
          _glUniform4iv.sig = "viip";
          var _emscripten_glUniform4iv = _glUniform4iv;
          function _glUniformMatrix2fv(location, count, transpose, value) {
            value >>>= 0;
            if (count <= 72) {
              var view = miniTempWebGLFloatBuffers[4 * count - 1];
              for (var i2 = 0; i2 < 4 * count; i2 += 4) {
                view[i2] = HEAPF32[value + 4 * i2 >>> 2 >>> 0];
                view[i2 + 1] = HEAPF32[value + (4 * i2 + 4) >>> 2 >>> 0];
                view[i2 + 2] = HEAPF32[value + (4 * i2 + 8) >>> 2 >>> 0];
                view[i2 + 3] = HEAPF32[value + (4 * i2 + 12) >>> 2 >>> 0];
              }
            } else {
              var view = HEAPF32.subarray(value >>> 2 >>> 0, value + count * 16 >>> 2 >>> 0);
            }
            GLctx.uniformMatrix2fv(webglGetUniformLocation(location), !!transpose, view);
          }
          _glUniformMatrix2fv.sig = "viiip";
          var _emscripten_glUniformMatrix2fv = _glUniformMatrix2fv;
          function _glUniformMatrix3fv(location, count, transpose, value) {
            value >>>= 0;
            if (count <= 32) {
              var view = miniTempWebGLFloatBuffers[9 * count - 1];
              for (var i2 = 0; i2 < 9 * count; i2 += 9) {
                view[i2] = HEAPF32[value + 4 * i2 >>> 2 >>> 0];
                view[i2 + 1] = HEAPF32[value + (4 * i2 + 4) >>> 2 >>> 0];
                view[i2 + 2] = HEAPF32[value + (4 * i2 + 8) >>> 2 >>> 0];
                view[i2 + 3] = HEAPF32[value + (4 * i2 + 12) >>> 2 >>> 0];
                view[i2 + 4] = HEAPF32[value + (4 * i2 + 16) >>> 2 >>> 0];
                view[i2 + 5] = HEAPF32[value + (4 * i2 + 20) >>> 2 >>> 0];
                view[i2 + 6] = HEAPF32[value + (4 * i2 + 24) >>> 2 >>> 0];
                view[i2 + 7] = HEAPF32[value + (4 * i2 + 28) >>> 2 >>> 0];
                view[i2 + 8] = HEAPF32[value + (4 * i2 + 32) >>> 2 >>> 0];
              }
            } else {
              var view = HEAPF32.subarray(value >>> 2 >>> 0, value + count * 36 >>> 2 >>> 0);
            }
            GLctx.uniformMatrix3fv(webglGetUniformLocation(location), !!transpose, view);
          }
          _glUniformMatrix3fv.sig = "viiip";
          var _emscripten_glUniformMatrix3fv = _glUniformMatrix3fv;
          function _glUniformMatrix4fv(location, count, transpose, value) {
            value >>>= 0;
            if (count <= 18) {
              var view = miniTempWebGLFloatBuffers[16 * count - 1];
              var heap = HEAPF32;
              value >>= 2;
              for (var i2 = 0; i2 < 16 * count; i2 += 16) {
                var dst = value + i2;
                view[i2] = heap[dst >>> 0];
                view[i2 + 1] = heap[dst + 1 >>> 0];
                view[i2 + 2] = heap[dst + 2 >>> 0];
                view[i2 + 3] = heap[dst + 3 >>> 0];
                view[i2 + 4] = heap[dst + 4 >>> 0];
                view[i2 + 5] = heap[dst + 5 >>> 0];
                view[i2 + 6] = heap[dst + 6 >>> 0];
                view[i2 + 7] = heap[dst + 7 >>> 0];
                view[i2 + 8] = heap[dst + 8 >>> 0];
                view[i2 + 9] = heap[dst + 9 >>> 0];
                view[i2 + 10] = heap[dst + 10 >>> 0];
                view[i2 + 11] = heap[dst + 11 >>> 0];
                view[i2 + 12] = heap[dst + 12 >>> 0];
                view[i2 + 13] = heap[dst + 13 >>> 0];
                view[i2 + 14] = heap[dst + 14 >>> 0];
                view[i2 + 15] = heap[dst + 15 >>> 0];
              }
            } else {
              var view = HEAPF32.subarray(value >>> 2 >>> 0, value + count * 64 >>> 2 >>> 0);
            }
            GLctx.uniformMatrix4fv(webglGetUniformLocation(location), !!transpose, view);
          }
          _glUniformMatrix4fv.sig = "viiip";
          var _emscripten_glUniformMatrix4fv = _glUniformMatrix4fv;
          var _glUseProgram = (program) => {
            program = GL.programs[program];
            GLctx.useProgram(program);
            GLctx.currentProgram = program;
          };
          _glUseProgram.sig = "vi";
          var _emscripten_glUseProgram = _glUseProgram;
          var _glValidateProgram = (program) => {
            GLctx.validateProgram(GL.programs[program]);
          };
          _glValidateProgram.sig = "vi";
          var _emscripten_glValidateProgram = _glValidateProgram;
          function _glVertexAttrib1f(x0, x1) {
            GLctx.vertexAttrib1f(x0, x1);
          }
          _glVertexAttrib1f.sig = "vif";
          var _emscripten_glVertexAttrib1f = _glVertexAttrib1f;
          function _glVertexAttrib1fv(index, v) {
            v >>>= 0;
            GLctx.vertexAttrib1f(index, HEAPF32[v >>> 2]);
          }
          _glVertexAttrib1fv.sig = "vip";
          var _emscripten_glVertexAttrib1fv = _glVertexAttrib1fv;
          function _glVertexAttrib2f(x0, x1, x2) {
            GLctx.vertexAttrib2f(x0, x1, x2);
          }
          _glVertexAttrib2f.sig = "viff";
          var _emscripten_glVertexAttrib2f = _glVertexAttrib2f;
          function _glVertexAttrib2fv(index, v) {
            v >>>= 0;
            GLctx.vertexAttrib2f(index, HEAPF32[v >>> 2], HEAPF32[v + 4 >>> 2]);
          }
          _glVertexAttrib2fv.sig = "vip";
          var _emscripten_glVertexAttrib2fv = _glVertexAttrib2fv;
          function _glVertexAttrib3f(x0, x1, x2, x3) {
            GLctx.vertexAttrib3f(x0, x1, x2, x3);
          }
          _glVertexAttrib3f.sig = "vifff";
          var _emscripten_glVertexAttrib3f = _glVertexAttrib3f;
          function _glVertexAttrib3fv(index, v) {
            v >>>= 0;
            GLctx.vertexAttrib3f(index, HEAPF32[v >>> 2], HEAPF32[v + 4 >>> 2], HEAPF32[v + 8 >>> 2]);
          }
          _glVertexAttrib3fv.sig = "vip";
          var _emscripten_glVertexAttrib3fv = _glVertexAttrib3fv;
          function _glVertexAttrib4f(x0, x1, x2, x3, x4) {
            GLctx.vertexAttrib4f(x0, x1, x2, x3, x4);
          }
          _glVertexAttrib4f.sig = "viffff";
          var _emscripten_glVertexAttrib4f = _glVertexAttrib4f;
          function _glVertexAttrib4fv(index, v) {
            v >>>= 0;
            GLctx.vertexAttrib4f(index, HEAPF32[v >>> 2], HEAPF32[v + 4 >>> 2], HEAPF32[v + 8 >>> 2], HEAPF32[v + 12 >>> 2]);
          }
          _glVertexAttrib4fv.sig = "vip";
          var _emscripten_glVertexAttrib4fv = _glVertexAttrib4fv;
          var _glVertexAttribDivisor = (index, divisor) => {
            GLctx.vertexAttribDivisor(index, divisor);
          };
          _glVertexAttribDivisor.sig = "vii";
          var _glVertexAttribDivisorANGLE = _glVertexAttribDivisor;
          var _emscripten_glVertexAttribDivisorANGLE = _glVertexAttribDivisorANGLE;
          function _glVertexAttribPointer(index, size, type, normalized, stride, ptr2) {
            ptr2 >>>= 0;
            GLctx.vertexAttribPointer(index, size, type, !!normalized, stride, ptr2);
          }
          _glVertexAttribPointer.sig = "viiiiip";
          var _emscripten_glVertexAttribPointer = _glVertexAttribPointer;
          function _glViewport(x0, x1, x2, x3) {
            GLctx.viewport(x0, x1, x2, x3);
          }
          _glViewport.sig = "viiii";
          var _emscripten_glViewport = _glViewport;
          function _emscripten_memcpy_js(dest, src, num) {
            dest >>>= 0;
            src >>>= 0;
            num >>>= 0;
            return HEAPU8.copyWithin(dest >>> 0, src >>> 0, src + num >>> 0);
          }
          _emscripten_memcpy_js.sig = "vppp";
          function _emscripten_out(str) {
            str >>>= 0;
            return out(UTF8ToString(str));
          }
          _emscripten_out.sig = "vp";
          var promiseMap = new HandleAllocator();
          var makePromise = () => {
            var promiseInfo = {};
            promiseInfo.promise = new Promise((resolve, reject) => {
              promiseInfo.reject = reject;
              promiseInfo.resolve = resolve;
            });
            promiseInfo.id = promiseMap.allocate(promiseInfo);
            return promiseInfo;
          };
          function _emscripten_promise_create() {
            return makePromise().id;
          }
          _emscripten_promise_create.sig = "p";
          function _emscripten_promise_destroy(id) {
            id >>>= 0;
            promiseMap.free(id);
          }
          _emscripten_promise_destroy.sig = "vp";
          var getPromise = (id) => promiseMap.get(id).promise;
          function _emscripten_promise_resolve(id, result, value) {
            id >>>= 0;
            value >>>= 0;
            var info2 = promiseMap.get(id);
            switch (result) {
              case 0:
                info2.resolve(value);
                return;
              case 1:
                info2.resolve(getPromise(value));
                return;
              case 2:
                info2.resolve(getPromise(value));
                _emscripten_promise_destroy(value);
                return;
              case 3:
                info2.reject(value);
                return;
            }
          }
          _emscripten_promise_resolve.sig = "vpip";
          var growMemory = (size) => {
            var b = wasmMemory.buffer;
            var pages = (size - b.byteLength + 65535) / 65536;
            try {
              wasmMemory.grow(pages);
              updateMemoryViews();
              return 1;
            } catch (e) {
            }
          };
          function _emscripten_resize_heap(requestedSize) {
            requestedSize >>>= 0;
            var oldSize = HEAPU8.length;
            var maxHeapSize = getHeapMax();
            if (requestedSize > maxHeapSize) {
              return false;
            }
            var alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;
            for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
              var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
              overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
              var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
              var replacement = growMemory(newSize);
              if (replacement) {
                return true;
              }
            }
            return false;
          }
          _emscripten_resize_heap.sig = "ip";
          function _emscripten_wget_data(url2, pbuffer, pnum, perror) {
            url2 >>>= 0;
            pbuffer >>>= 0;
            pnum >>>= 0;
            perror >>>= 0;
            throw "Please compile your program with async support in order to use asynchronous operations like emscripten_wget_data";
          }
          _emscripten_wget_data.sig = "vpppp";
          var getExecutableName = () => thisProgram || "./this.program";
          var getEnvStrings = () => {
            if (!getEnvStrings.strings) {
              var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
              var env = {
                "USER": "web_user",
                "LOGNAME": "web_user",
                "PATH": "/",
                "PWD": "/",
                "HOME": "/home/web_user",
                "LANG": lang,
                "_": getExecutableName()
              };
              for (var x in ENV) {
                if (ENV[x] === void 0)
                  delete env[x];
                else
                  env[x] = ENV[x];
              }
              var strings = [];
              for (var x in env) {
                strings.push(`${x}=${env[x]}`);
              }
              getEnvStrings.strings = strings;
            }
            return getEnvStrings.strings;
          };
          var stringToAscii = (str, buffer) => {
            for (var i2 = 0; i2 < str.length; ++i2) {
              HEAP8[buffer++ >>> 0 >>> 0] = str.charCodeAt(i2);
            }
            HEAP8[buffer >>> 0 >>> 0] = 0;
          };
          var _environ_get = function(__environ, environ_buf) {
            __environ >>>= 0;
            environ_buf >>>= 0;
            var bufSize = 0;
            getEnvStrings().forEach((string, i2) => {
              var ptr2 = environ_buf + bufSize;
              HEAPU32[__environ + i2 * 4 >>> 2 >>> 0] = ptr2;
              stringToAscii(string, ptr2);
              bufSize += string.length + 1;
            });
            return 0;
          };
          _environ_get.sig = "ipp";
          var _environ_sizes_get = function(penviron_count, penviron_buf_size) {
            penviron_count >>>= 0;
            penviron_buf_size >>>= 0;
            var strings = getEnvStrings();
            HEAPU32[penviron_count >>> 2 >>> 0] = strings.length;
            var bufSize = 0;
            strings.forEach((string) => bufSize += string.length + 1);
            HEAPU32[penviron_buf_size >>> 2 >>> 0] = bufSize;
            return 0;
          };
          _environ_sizes_get.sig = "ipp";
          function _fd_close(fd) {
            try {
              var stream = SYSCALLS.getStreamFromFD(fd);
              FS.close(stream);
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return e.errno;
            }
          }
          _fd_close.sig = "ii";
          function _fd_fdstat_get(fd, pbuf) {
            pbuf >>>= 0;
            try {
              var rightsBase = 0;
              var rightsInheriting = 0;
              var flags2 = 0;
              {
                var stream = SYSCALLS.getStreamFromFD(fd);
                var type = stream.tty ? 2 : FS.isDir(stream.mode) ? 3 : FS.isLink(stream.mode) ? 7 : 4;
              }
              HEAP8[pbuf >>> 0 >>> 0] = type;
              HEAP16[pbuf + 2 >>> 1 >>> 0] = flags2;
              tempI64 = [rightsBase >>> 0, (tempDouble = rightsBase, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[pbuf + 8 >>> 2 >>> 0] = tempI64[0], HEAP32[pbuf + 12 >>> 2 >>> 0] = tempI64[1];
              tempI64 = [rightsInheriting >>> 0, (tempDouble = rightsInheriting, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[pbuf + 16 >>> 2 >>> 0] = tempI64[0], HEAP32[pbuf + 20 >>> 2 >>> 0] = tempI64[1];
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return e.errno;
            }
          }
          _fd_fdstat_get.sig = "iip";
          var doReadv = (stream, iov, iovcnt, offset) => {
            var ret = 0;
            for (var i2 = 0; i2 < iovcnt; i2++) {
              var ptr2 = HEAPU32[iov >>> 2 >>> 0];
              var len2 = HEAPU32[iov + 4 >>> 2 >>> 0];
              iov += 8;
              var curr = FS.read(stream, HEAP8, ptr2, len2, offset);
              if (curr < 0)
                return -1;
              ret += curr;
              if (curr < len2)
                break;
              if (typeof offset !== "undefined") {
                offset += curr;
              }
            }
            return ret;
          };
          function _fd_pread(fd, iov, iovcnt, offset_low, offset_high, pnum) {
            iov >>>= 0;
            iovcnt >>>= 0;
            var offset = convertI32PairToI53Checked(offset_low, offset_high);
            pnum >>>= 0;
            try {
              if (isNaN(offset))
                return 61;
              var stream = SYSCALLS.getStreamFromFD(fd);
              var num = doReadv(stream, iov, iovcnt, offset);
              HEAPU32[pnum >>> 2 >>> 0] = num;
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return e.errno;
            }
          }
          _fd_pread.sig = "iippiip";
          var doWritev = (stream, iov, iovcnt, offset) => {
            var ret = 0;
            for (var i2 = 0; i2 < iovcnt; i2++) {
              var ptr2 = HEAPU32[iov >>> 2 >>> 0];
              var len2 = HEAPU32[iov + 4 >>> 2 >>> 0];
              iov += 8;
              var curr = FS.write(stream, HEAP8, ptr2, len2, offset);
              if (curr < 0)
                return -1;
              ret += curr;
              if (typeof offset !== "undefined") {
                offset += curr;
              }
            }
            return ret;
          };
          function _fd_pwrite(fd, iov, iovcnt, offset_low, offset_high, pnum) {
            iov >>>= 0;
            iovcnt >>>= 0;
            var offset = convertI32PairToI53Checked(offset_low, offset_high);
            pnum >>>= 0;
            try {
              if (isNaN(offset))
                return 61;
              var stream = SYSCALLS.getStreamFromFD(fd);
              var num = doWritev(stream, iov, iovcnt, offset);
              HEAPU32[pnum >>> 2 >>> 0] = num;
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return e.errno;
            }
          }
          _fd_pwrite.sig = "iippiip";
          function _fd_read(fd, iov, iovcnt, pnum) {
            iov >>>= 0;
            iovcnt >>>= 0;
            pnum >>>= 0;
            try {
              var stream = SYSCALLS.getStreamFromFD(fd);
              var num = doReadv(stream, iov, iovcnt);
              HEAPU32[pnum >>> 2 >>> 0] = num;
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return e.errno;
            }
          }
          _fd_read.sig = "iippp";
          function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
            var offset = convertI32PairToI53Checked(offset_low, offset_high);
            newOffset >>>= 0;
            try {
              if (isNaN(offset))
                return 61;
              var stream = SYSCALLS.getStreamFromFD(fd);
              FS.llseek(stream, offset, whence);
              tempI64 = [stream.position >>> 0, (tempDouble = stream.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[newOffset >>> 2 >>> 0] = tempI64[0], HEAP32[newOffset + 4 >>> 2 >>> 0] = tempI64[1];
              if (stream.getdents && offset === 0 && whence === 0)
                stream.getdents = null;
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return e.errno;
            }
          }
          _fd_seek.sig = "iiiiip";
          function _fd_sync(fd) {
            try {
              var stream = SYSCALLS.getStreamFromFD(fd);
              if (stream.stream_ops?.fsync) {
                return stream.stream_ops.fsync(stream);
              }
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return e.errno;
            }
          }
          _fd_sync.sig = "ii";
          function _fd_write(fd, iov, iovcnt, pnum) {
            iov >>>= 0;
            iovcnt >>>= 0;
            pnum >>>= 0;
            try {
              var stream = SYSCALLS.getStreamFromFD(fd);
              var num = doWritev(stream, iov, iovcnt);
              HEAPU32[pnum >>> 2 >>> 0] = num;
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return e.errno;
            }
          }
          _fd_write.sig = "iippp";
          function _getaddrinfo(node, service, hint, out2) {
            node >>>= 0;
            service >>>= 0;
            hint >>>= 0;
            out2 >>>= 0;
            var addrs = [];
            var canon = null;
            var addr2 = 0;
            var port = 0;
            var flags2 = 0;
            var family = 0;
            var type = 0;
            var proto = 0;
            var ai, last;
            function allocaddrinfo(family2, type2, proto2, canon2, addr3, port2) {
              var sa, salen, ai2;
              var errno;
              salen = family2 === 10 ? 28 : 16;
              addr3 = family2 === 10 ? inetNtop6(addr3) : inetNtop4(addr3);
              sa = _malloc(salen);
              errno = writeSockaddr(sa, family2, addr3, port2);
              assert(!errno);
              ai2 = _malloc(32);
              HEAP32[ai2 + 4 >>> 2 >>> 0] = family2;
              HEAP32[ai2 + 8 >>> 2 >>> 0] = type2;
              HEAP32[ai2 + 12 >>> 2 >>> 0] = proto2;
              HEAPU32[ai2 + 24 >>> 2 >>> 0] = canon2;
              HEAPU32[ai2 + 20 >>> 2 >>> 0] = sa;
              if (family2 === 10) {
                HEAP32[ai2 + 16 >>> 2 >>> 0] = 28;
              } else {
                HEAP32[ai2 + 16 >>> 2 >>> 0] = 16;
              }
              HEAP32[ai2 + 28 >>> 2 >>> 0] = 0;
              return ai2;
            }
            if (hint) {
              flags2 = HEAP32[hint >>> 2 >>> 0];
              family = HEAP32[hint + 4 >>> 2 >>> 0];
              type = HEAP32[hint + 8 >>> 2 >>> 0];
              proto = HEAP32[hint + 12 >>> 2 >>> 0];
            }
            if (type && !proto) {
              proto = type === 2 ? 17 : 6;
            }
            if (!type && proto) {
              type = proto === 17 ? 2 : 1;
            }
            if (proto === 0) {
              proto = 6;
            }
            if (type === 0) {
              type = 1;
            }
            if (!node && !service) {
              return -2;
            }
            if (flags2 & ~(1 | 2 | 4 | 1024 | 8 | 16 | 32)) {
              return -1;
            }
            if (hint !== 0 && HEAP32[hint >>> 2 >>> 0] & 2 && !node) {
              return -1;
            }
            if (flags2 & 32) {
              return -2;
            }
            if (type !== 0 && type !== 1 && type !== 2) {
              return -7;
            }
            if (family !== 0 && family !== 2 && family !== 10) {
              return -6;
            }
            if (service) {
              service = UTF8ToString(service);
              port = parseInt(service, 10);
              if (isNaN(port)) {
                if (flags2 & 1024) {
                  return -2;
                }
                return -8;
              }
            }
            if (!node) {
              if (family === 0) {
                family = 2;
              }
              if ((flags2 & 1) === 0) {
                if (family === 2) {
                  addr2 = _htonl(2130706433);
                } else {
                  addr2 = [0, 0, 0, 1];
                }
              }
              ai = allocaddrinfo(family, type, proto, null, addr2, port);
              HEAPU32[out2 >>> 2 >>> 0] = ai;
              return 0;
            }
            node = UTF8ToString(node);
            addr2 = inetPton4(node);
            if (addr2 !== null) {
              if (family === 0 || family === 2) {
                family = 2;
              } else if (family === 10 && flags2 & 8) {
                addr2 = [0, 0, _htonl(65535), addr2];
                family = 10;
              } else {
                return -2;
              }
            } else {
              addr2 = inetPton6(node);
              if (addr2 !== null) {
                if (family === 0 || family === 10) {
                  family = 10;
                } else {
                  return -2;
                }
              }
            }
            if (addr2 != null) {
              ai = allocaddrinfo(family, type, proto, node, addr2, port);
              HEAPU32[out2 >>> 2 >>> 0] = ai;
              return 0;
            }
            if (flags2 & 4) {
              return -2;
            }
            node = DNS.lookup_name(node);
            addr2 = inetPton4(node);
            if (family === 0) {
              family = 2;
            } else if (family === 10) {
              addr2 = [0, 0, _htonl(65535), addr2];
            }
            ai = allocaddrinfo(family, type, proto, null, addr2, port);
            HEAPU32[out2 >>> 2 >>> 0] = ai;
            return 0;
          }
          _getaddrinfo.sig = "ipppp";
          function _getentropy(buffer, size) {
            buffer >>>= 0;
            size >>>= 0;
            randomFill(HEAPU8.subarray(buffer >>> 0, buffer + size >>> 0));
            return 0;
          }
          _getentropy.sig = "ipp";
          function _getnameinfo(sa, salen, node, nodelen, serv, servlen, flags2) {
            sa >>>= 0;
            node >>>= 0;
            serv >>>= 0;
            var info2 = readSockaddr(sa, salen);
            if (info2.errno) {
              return -6;
            }
            var port = info2.port;
            var addr2 = info2.addr;
            var overflowed = false;
            if (node && nodelen) {
              var lookup;
              if (flags2 & 1 || !(lookup = DNS.lookup_addr(addr2))) {
                if (flags2 & 8) {
                  return -2;
                }
              } else {
                addr2 = lookup;
              }
              var numBytesWrittenExclNull = stringToUTF8(addr2, node, nodelen);
              if (numBytesWrittenExclNull + 1 >= nodelen) {
                overflowed = true;
              }
            }
            if (serv && servlen) {
              port = "" + port;
              var numBytesWrittenExclNull = stringToUTF8(port, serv, servlen);
              if (numBytesWrittenExclNull + 1 >= servlen) {
                overflowed = true;
              }
            }
            if (overflowed) {
              return -12;
            }
            return 0;
          }
          _getnameinfo.sig = "ipipipii";
          function _pthread_kill() {
            return wasmImports["pthread_kill"].apply(null, arguments);
          }
          _pthread_kill.stub = true;
          var arraySum = (array, index) => {
            var sum2 = 0;
            for (var i2 = 0; i2 <= index; sum2 += array[i2++]) {
            }
            return sum2;
          };
          var MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
          var MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
          var addDays = (date, days) => {
            var newDate = new Date(date.getTime());
            while (days > 0) {
              var leap = isLeapYear(newDate.getFullYear());
              var currentMonth = newDate.getMonth();
              var daysInCurrentMonth = (leap ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[currentMonth];
              if (days > daysInCurrentMonth - newDate.getDate()) {
                days -= daysInCurrentMonth - newDate.getDate() + 1;
                newDate.setDate(1);
                if (currentMonth < 11) {
                  newDate.setMonth(currentMonth + 1);
                } else {
                  newDate.setMonth(0);
                  newDate.setFullYear(newDate.getFullYear() + 1);
                }
              } else {
                newDate.setDate(newDate.getDate() + days);
                return newDate;
              }
            }
            return newDate;
          };
          var writeArrayToMemory = (array, buffer) => {
            HEAP8.set(array, buffer >>> 0);
          };
          function _strftime(s2, maxsize, format, tm) {
            s2 >>>= 0;
            maxsize >>>= 0;
            format >>>= 0;
            tm >>>= 0;
            var tm_zone = HEAPU32[tm + 40 >>> 2 >>> 0];
            var date = {
              tm_sec: HEAP32[tm >>> 2 >>> 0],
              tm_min: HEAP32[tm + 4 >>> 2 >>> 0],
              tm_hour: HEAP32[tm + 8 >>> 2 >>> 0],
              tm_mday: HEAP32[tm + 12 >>> 2 >>> 0],
              tm_mon: HEAP32[tm + 16 >>> 2 >>> 0],
              tm_year: HEAP32[tm + 20 >>> 2 >>> 0],
              tm_wday: HEAP32[tm + 24 >>> 2 >>> 0],
              tm_yday: HEAP32[tm + 28 >>> 2 >>> 0],
              tm_isdst: HEAP32[tm + 32 >>> 2 >>> 0],
              tm_gmtoff: HEAP32[tm + 36 >>> 2 >>> 0],
              tm_zone: tm_zone ? UTF8ToString(tm_zone) : ""
            };
            var pattern = UTF8ToString(format);
            var EXPANSION_RULES_1 = {
              "%c": "%a %b %d %H:%M:%S %Y",
              "%D": "%m/%d/%y",
              "%F": "%Y-%m-%d",
              "%h": "%b",
              "%r": "%I:%M:%S %p",
              "%R": "%H:%M",
              "%T": "%H:%M:%S",
              "%x": "%m/%d/%y",
              "%X": "%H:%M:%S",
              "%Ec": "%c",
              "%EC": "%C",
              "%Ex": "%m/%d/%y",
              "%EX": "%H:%M:%S",
              "%Ey": "%y",
              "%EY": "%Y",
              "%Od": "%d",
              "%Oe": "%e",
              "%OH": "%H",
              "%OI": "%I",
              "%Om": "%m",
              "%OM": "%M",
              "%OS": "%S",
              "%Ou": "%u",
              "%OU": "%U",
              "%OV": "%V",
              "%Ow": "%w",
              "%OW": "%W",
              "%Oy": "%y"
            };
            for (var rule in EXPANSION_RULES_1) {
              pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_1[rule]);
            }
            var WEEKDAYS = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
            var MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
            function leadingSomething(value, digits, character) {
              var str = typeof value == "number" ? value.toString() : value || "";
              while (str.length < digits) {
                str = character[0] + str;
              }
              return str;
            }
            function leadingNulls(value, digits) {
              return leadingSomething(value, digits, "0");
            }
            function compareByDay(date1, date2) {
              function sgn(value) {
                return value < 0 ? -1 : value > 0 ? 1 : 0;
              }
              var compare;
              if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {
                if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {
                  compare = sgn(date1.getDate() - date2.getDate());
                }
              }
              return compare;
            }
            function getFirstWeekStartDate(janFourth) {
              switch (janFourth.getDay()) {
                case 0:
                  return new Date(janFourth.getFullYear() - 1, 11, 29);
                case 1:
                  return janFourth;
                case 2:
                  return new Date(janFourth.getFullYear(), 0, 3);
                case 3:
                  return new Date(janFourth.getFullYear(), 0, 2);
                case 4:
                  return new Date(janFourth.getFullYear(), 0, 1);
                case 5:
                  return new Date(janFourth.getFullYear() - 1, 11, 31);
                case 6:
                  return new Date(janFourth.getFullYear() - 1, 11, 30);
              }
            }
            function getWeekBasedYear(date2) {
              var thisDate = addDays(new Date(date2.tm_year + 1900, 0, 1), date2.tm_yday);
              var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);
              var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);
              var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
              var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
              if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {
                if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {
                  return thisDate.getFullYear() + 1;
                }
                return thisDate.getFullYear();
              }
              return thisDate.getFullYear() - 1;
            }
            var EXPANSION_RULES_2 = {
              "%a": (date2) => WEEKDAYS[date2.tm_wday].substring(0, 3),
              "%A": (date2) => WEEKDAYS[date2.tm_wday],
              "%b": (date2) => MONTHS[date2.tm_mon].substring(0, 3),
              "%B": (date2) => MONTHS[date2.tm_mon],
              "%C": (date2) => {
                var year = date2.tm_year + 1900;
                return leadingNulls(year / 100 | 0, 2);
              },
              "%d": (date2) => leadingNulls(date2.tm_mday, 2),
              "%e": (date2) => leadingSomething(date2.tm_mday, 2, " "),
              "%g": (date2) => getWeekBasedYear(date2).toString().substring(2),
              "%G": getWeekBasedYear,
              "%H": (date2) => leadingNulls(date2.tm_hour, 2),
              "%I": (date2) => {
                var twelveHour = date2.tm_hour;
                if (twelveHour == 0)
                  twelveHour = 12;
                else if (twelveHour > 12)
                  twelveHour -= 12;
                return leadingNulls(twelveHour, 2);
              },
              "%j": (date2) => leadingNulls(date2.tm_mday + arraySum(isLeapYear(date2.tm_year + 1900) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, date2.tm_mon - 1), 3),
              "%m": (date2) => leadingNulls(date2.tm_mon + 1, 2),
              "%M": (date2) => leadingNulls(date2.tm_min, 2),
              "%n": () => "\n",
              "%p": (date2) => {
                if (date2.tm_hour >= 0 && date2.tm_hour < 12) {
                  return "AM";
                }
                return "PM";
              },
              "%S": (date2) => leadingNulls(date2.tm_sec, 2),
              "%t": () => "	",
              "%u": (date2) => date2.tm_wday || 7,
              "%U": (date2) => {
                var days = date2.tm_yday + 7 - date2.tm_wday;
                return leadingNulls(Math.floor(days / 7), 2);
              },
              "%V": (date2) => {
                var val = Math.floor((date2.tm_yday + 7 - (date2.tm_wday + 6) % 7) / 7);
                if ((date2.tm_wday + 371 - date2.tm_yday - 2) % 7 <= 2) {
                  val++;
                }
                if (!val) {
                  val = 52;
                  var dec31 = (date2.tm_wday + 7 - date2.tm_yday - 1) % 7;
                  if (dec31 == 4 || dec31 == 5 && isLeapYear(date2.tm_year % 400 - 1)) {
                    val++;
                  }
                } else if (val == 53) {
                  var jan1 = (date2.tm_wday + 371 - date2.tm_yday) % 7;
                  if (jan1 != 4 && (jan1 != 3 || !isLeapYear(date2.tm_year)))
                    val = 1;
                }
                return leadingNulls(val, 2);
              },
              "%w": (date2) => date2.tm_wday,
              "%W": (date2) => {
                var days = date2.tm_yday + 7 - (date2.tm_wday + 6) % 7;
                return leadingNulls(Math.floor(days / 7), 2);
              },
              "%y": (date2) => (date2.tm_year + 1900).toString().substring(2),
              "%Y": (date2) => date2.tm_year + 1900,
              "%z": (date2) => {
                var off = date2.tm_gmtoff;
                var ahead = off >= 0;
                off = Math.abs(off) / 60;
                off = off / 60 * 100 + off % 60;
                return (ahead ? "+" : "-") + String("0000" + off).slice(-4);
              },
              "%Z": (date2) => date2.tm_zone,
              "%%": () => "%"
            };
            pattern = pattern.replace(/%%/g, "\0\0");
            for (var rule in EXPANSION_RULES_2) {
              if (pattern.includes(rule)) {
                pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_2[rule](date));
              }
            }
            pattern = pattern.replace(/\0\0/g, "%");
            var bytes = intArrayFromString(pattern, false);
            if (bytes.length > maxsize) {
              return 0;
            }
            writeArrayToMemory(bytes, s2);
            return bytes.length - 1;
          }
          _strftime.sig = "ppppp";
          function _strftime_l(s2, maxsize, format, tm, loc) {
            s2 >>>= 0;
            maxsize >>>= 0;
            format >>>= 0;
            tm >>>= 0;
            loc >>>= 0;
            return _strftime(s2, maxsize, format, tm);
          }
          _strftime_l.sig = "pppppp";
          function _strptime(buf, format, tm) {
            buf >>>= 0;
            format >>>= 0;
            tm >>>= 0;
            var pattern = UTF8ToString(format);
            var SPECIAL_CHARS = "\\!@#$^&*()+=-[]/{}|:<>?,.";
            for (var i2 = 0, ii = SPECIAL_CHARS.length; i2 < ii; ++i2) {
              pattern = pattern.replace(new RegExp("\\" + SPECIAL_CHARS[i2], "g"), "\\" + SPECIAL_CHARS[i2]);
            }
            var EQUIVALENT_MATCHERS = {
              "A": "%a",
              "B": "%b",
              "c": "%a %b %d %H:%M:%S %Y",
              "D": "%m\\/%d\\/%y",
              "e": "%d",
              "F": "%Y-%m-%d",
              "h": "%b",
              "R": "%H\\:%M",
              "r": "%I\\:%M\\:%S\\s%p",
              "T": "%H\\:%M\\:%S",
              "x": "%m\\/%d\\/(?:%y|%Y)",
              "X": "%H\\:%M\\:%S"
            };
            var DATE_PATTERNS = {
              "a": "(?:Sun(?:day)?)|(?:Mon(?:day)?)|(?:Tue(?:sday)?)|(?:Wed(?:nesday)?)|(?:Thu(?:rsday)?)|(?:Fri(?:day)?)|(?:Sat(?:urday)?)",
              "b": "(?:Jan(?:uary)?)|(?:Feb(?:ruary)?)|(?:Mar(?:ch)?)|(?:Apr(?:il)?)|May|(?:Jun(?:e)?)|(?:Jul(?:y)?)|(?:Aug(?:ust)?)|(?:Sep(?:tember)?)|(?:Oct(?:ober)?)|(?:Nov(?:ember)?)|(?:Dec(?:ember)?)",
              "C": "\\d\\d",
              "d": "0[1-9]|[1-9](?!\\d)|1\\d|2\\d|30|31",
              "H": "\\d(?!\\d)|[0,1]\\d|20|21|22|23",
              "I": "\\d(?!\\d)|0\\d|10|11|12",
              "j": "00[1-9]|0?[1-9](?!\\d)|0?[1-9]\\d(?!\\d)|[1,2]\\d\\d|3[0-6]\\d",
              "m": "0[1-9]|[1-9](?!\\d)|10|11|12",
              "M": "0\\d|\\d(?!\\d)|[1-5]\\d",
              "n": " ",
              "p": "AM|am|PM|pm|A\\.M\\.|a\\.m\\.|P\\.M\\.|p\\.m\\.",
              "S": "0\\d|\\d(?!\\d)|[1-5]\\d|60",
              "U": "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
              "W": "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
              "w": "[0-6]",
              "y": "\\d\\d",
              "Y": "\\d\\d\\d\\d",
              "t": " ",
              "z": "Z|(?:[\\+\\-]\\d\\d:?(?:\\d\\d)?)"
            };
            var MONTH_NUMBERS = {
              JAN: 0,
              FEB: 1,
              MAR: 2,
              APR: 3,
              MAY: 4,
              JUN: 5,
              JUL: 6,
              AUG: 7,
              SEP: 8,
              OCT: 9,
              NOV: 10,
              DEC: 11
            };
            var DAY_NUMBERS_SUN_FIRST = {
              SUN: 0,
              MON: 1,
              TUE: 2,
              WED: 3,
              THU: 4,
              FRI: 5,
              SAT: 6
            };
            var DAY_NUMBERS_MON_FIRST = {
              MON: 0,
              TUE: 1,
              WED: 2,
              THU: 3,
              FRI: 4,
              SAT: 5,
              SUN: 6
            };
            var capture = [];
            var pattern_out = pattern.replace(/%(.)/g, (m, c) => EQUIVALENT_MATCHERS[c] || m).replace(/%(.)/g, (_, c) => {
              let pat = DATE_PATTERNS[c];
              if (pat) {
                capture.push(c);
                return `(${pat})`;
              } else {
                return c;
              }
            }).replace(/\s+/g, "\\s*");
            var matches = new RegExp("^" + pattern_out, "i").exec(UTF8ToString(buf));
            function initDate() {
              function fixup(value2, min, max) {
                return typeof value2 != "number" || isNaN(value2) ? min : value2 >= min ? value2 <= max ? value2 : max : min;
              }
              return {
                year: fixup(HEAP32[tm + 20 >>> 2 >>> 0] + 1900, 1970, 9999),
                month: fixup(HEAP32[tm + 16 >>> 2 >>> 0], 0, 11),
                day: fixup(HEAP32[tm + 12 >>> 2 >>> 0], 1, 31),
                hour: fixup(HEAP32[tm + 8 >>> 2 >>> 0], 0, 23),
                min: fixup(HEAP32[tm + 4 >>> 2 >>> 0], 0, 59),
                sec: fixup(HEAP32[tm >>> 2 >>> 0], 0, 59),
                gmtoff: 0
              };
            }
            if (matches) {
              var date = initDate();
              var value;
              var getMatch = (symbol) => {
                var pos = capture.indexOf(symbol);
                if (pos >= 0) {
                  return matches[pos + 1];
                }
                return;
              };
              if (value = getMatch("S")) {
                date.sec = jstoi_q(value);
              }
              if (value = getMatch("M")) {
                date.min = jstoi_q(value);
              }
              if (value = getMatch("H")) {
                date.hour = jstoi_q(value);
              } else if (value = getMatch("I")) {
                var hour = jstoi_q(value);
                if (value = getMatch("p")) {
                  hour += value.toUpperCase()[0] === "P" ? 12 : 0;
                }
                date.hour = hour;
              }
              if (value = getMatch("Y")) {
                date.year = jstoi_q(value);
              } else if (value = getMatch("y")) {
                var year = jstoi_q(value);
                if (value = getMatch("C")) {
                  year += jstoi_q(value) * 100;
                } else {
                  year += year < 69 ? 2e3 : 1900;
                }
                date.year = year;
              }
              if (value = getMatch("m")) {
                date.month = jstoi_q(value) - 1;
              } else if (value = getMatch("b")) {
                date.month = MONTH_NUMBERS[value.substring(0, 3).toUpperCase()] || 0;
              }
              if (value = getMatch("d")) {
                date.day = jstoi_q(value);
              } else if (value = getMatch("j")) {
                var day = jstoi_q(value);
                var leapYear = isLeapYear(date.year);
                for (var month = 0; month < 12; ++month) {
                  var daysUntilMonth = arraySum(leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, month - 1);
                  if (day <= daysUntilMonth + (leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[month]) {
                    date.day = day - daysUntilMonth;
                  }
                }
              } else if (value = getMatch("a")) {
                var weekDay = value.substring(0, 3).toUpperCase();
                if (value = getMatch("U")) {
                  var weekDayNumber = DAY_NUMBERS_SUN_FIRST[weekDay];
                  var weekNumber = jstoi_q(value);
                  var janFirst = new Date(date.year, 0, 1);
                  var endDate;
                  if (janFirst.getDay() === 0) {
                    endDate = addDays(janFirst, weekDayNumber + 7 * (weekNumber - 1));
                  } else {
                    endDate = addDays(janFirst, 7 - janFirst.getDay() + weekDayNumber + 7 * (weekNumber - 1));
                  }
                  date.day = endDate.getDate();
                  date.month = endDate.getMonth();
                } else if (value = getMatch("W")) {
                  var weekDayNumber = DAY_NUMBERS_MON_FIRST[weekDay];
                  var weekNumber = jstoi_q(value);
                  var janFirst = new Date(date.year, 0, 1);
                  var endDate;
                  if (janFirst.getDay() === 1) {
                    endDate = addDays(janFirst, weekDayNumber + 7 * (weekNumber - 1));
                  } else {
                    endDate = addDays(janFirst, 7 - janFirst.getDay() + 1 + weekDayNumber + 7 * (weekNumber - 1));
                  }
                  date.day = endDate.getDate();
                  date.month = endDate.getMonth();
                }
              }
              if (value = getMatch("z")) {
                if (value.toLowerCase() === "z") {
                  date.gmtoff = 0;
                } else {
                  var match = value.match(/^((?:\-|\+)\d\d):?(\d\d)?/);
                  date.gmtoff = match[1] * 3600;
                  if (match[2]) {
                    date.gmtoff += date.gmtoff > 0 ? match[2] * 60 : -match[2] * 60;
                  }
                }
              }
              var fullDate = new Date(date.year, date.month, date.day, date.hour, date.min, date.sec, 0);
              HEAP32[tm >>> 2 >>> 0] = fullDate.getSeconds();
              HEAP32[tm + 4 >>> 2 >>> 0] = fullDate.getMinutes();
              HEAP32[tm + 8 >>> 2 >>> 0] = fullDate.getHours();
              HEAP32[tm + 12 >>> 2 >>> 0] = fullDate.getDate();
              HEAP32[tm + 16 >>> 2 >>> 0] = fullDate.getMonth();
              HEAP32[tm + 20 >>> 2 >>> 0] = fullDate.getFullYear() - 1900;
              HEAP32[tm + 24 >>> 2 >>> 0] = fullDate.getDay();
              HEAP32[tm + 28 >>> 2 >>> 0] = arraySum(isLeapYear(fullDate.getFullYear()) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, fullDate.getMonth() - 1) + fullDate.getDate() - 1;
              HEAP32[tm + 32 >>> 2 >>> 0] = 0;
              HEAP32[tm + 36 >>> 2 >>> 0] = date.gmtoff;
              return buf + intArrayFromString(matches[0]).length - 1;
            }
            return 0;
          }
          _strptime.sig = "pppp";
          var getCFunc = (ident) => {
            var func2 = Module["_" + ident];
            return func2;
          };
          var ccall = (ident, returnType, argTypes, args2, opts) => {
            var toC = {
              "string": (str) => {
                var ret2 = 0;
                if (str !== null && str !== void 0 && str !== 0) {
                  ret2 = stringToUTF8OnStack(str);
                }
                return ret2;
              },
              "array": (arr) => {
                var ret2 = stackAlloc(arr.length);
                writeArrayToMemory(arr, ret2);
                return ret2;
              }
            };
            function convertReturnValue(ret2) {
              if (returnType === "string") {
                return UTF8ToString(ret2);
              }
              if (returnType === "boolean")
                return Boolean(ret2);
              return ret2;
            }
            var func2 = getCFunc(ident);
            var cArgs = [];
            var stack = 0;
            if (args2) {
              for (var i2 = 0; i2 < args2.length; i2++) {
                var converter = toC[argTypes[i2]];
                if (converter) {
                  if (stack === 0)
                    stack = stackSave();
                  cArgs[i2] = converter(args2[i2]);
                } else {
                  cArgs[i2] = args2[i2];
                }
              }
            }
            var ret = func2.apply(null, cArgs);
            function onDone(ret2) {
              if (stack !== 0)
                stackRestore(stack);
              return convertReturnValue(ret2);
            }
            ret = onDone(ret);
            return ret;
          };
          var writeI53ToI64Clamped = (ptr2, num) => {
            if (num > 9223372036854776e3) {
              HEAPU32[ptr2 >>> 2 >>> 0] = 4294967295;
              HEAPU32[ptr2 + 4 >>> 2 >>> 0] = 2147483647;
            } else if (num < -9223372036854776e3) {
              HEAPU32[ptr2 >>> 2 >>> 0] = 0;
              HEAPU32[ptr2 + 4 >>> 2 >>> 0] = 2147483648;
            } else {
              writeI53ToI64(ptr2, num);
            }
          };
          var writeI53ToI64Signaling = (ptr2, num) => {
            if (num > 9223372036854776e3 || num < -9223372036854776e3) {
              throw `RangeError: ${num}`;
            }
            writeI53ToI64(ptr2, num);
          };
          var writeI53ToU64Clamped = (ptr2, num) => {
            if (num > 18446744073709552e3) {
              HEAPU32[ptr2 >>> 2 >>> 0] = 4294967295;
              HEAPU32[ptr2 + 4 >>> 2 >>> 0] = 4294967295;
            } else if (num < 0) {
              HEAPU32[ptr2 >>> 2 >>> 0] = 0;
              HEAPU32[ptr2 + 4 >>> 2 >>> 0] = 0;
            } else {
              writeI53ToI64(ptr2, num);
            }
          };
          var writeI53ToU64Signaling = (ptr2, num) => {
            if (num < 0 || num > 18446744073709552e3) {
              throw `RangeError: ${num}`;
            }
            writeI53ToI64(ptr2, num);
          };
          var readI53FromU64 = (ptr2) => HEAPU32[ptr2 >>> 2 >>> 0] + HEAPU32[ptr2 + 4 >>> 2 >>> 0] * 4294967296;
          var convertI32PairToI53 = (lo, hi) => (lo >>> 0) + hi * 4294967296;
          var convertU32PairToI53 = (lo, hi) => (lo >>> 0) + (hi >>> 0) * 4294967296;
          var ptrToString = (ptr2) => "0x" + ptr2.toString(16).padStart(8, "0");
          function _emscripten_notify_memory_growth(memoryIndex) {
            memoryIndex >>>= 0;
            updateMemoryViews();
          }
          _emscripten_notify_memory_growth.sig = "vp";
          function ___asctime_r(tmPtr, buf) {
            tmPtr >>>= 0;
            buf >>>= 0;
            var date = {
              tm_sec: HEAP32[tmPtr >>> 2 >>> 0],
              tm_min: HEAP32[tmPtr + 4 >>> 2 >>> 0],
              tm_hour: HEAP32[tmPtr + 8 >>> 2 >>> 0],
              tm_mday: HEAP32[tmPtr + 12 >>> 2 >>> 0],
              tm_mon: HEAP32[tmPtr + 16 >>> 2 >>> 0],
              tm_year: HEAP32[tmPtr + 20 >>> 2 >>> 0],
              tm_wday: HEAP32[tmPtr + 24 >>> 2 >>> 0]
            };
            var days = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
            var months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
            var s2 = days[date.tm_wday] + " " + months[date.tm_mon] + (date.tm_mday < 10 ? "  " : " ") + date.tm_mday + (date.tm_hour < 10 ? " 0" : " ") + date.tm_hour + (date.tm_min < 10 ? ":0" : ":") + date.tm_min + (date.tm_sec < 10 ? ":0" : ":") + date.tm_sec + " " + (1900 + date.tm_year) + "\n";
            stringToUTF8(s2, buf, 26);
            return buf;
          }
          ___asctime_r.sig = "ppp";
          function _strptime_l(buf, format, tm, locale) {
            buf >>>= 0;
            format >>>= 0;
            tm >>>= 0;
            locale >>>= 0;
            return _strptime(buf, format, tm);
          }
          _strptime_l.sig = "ppppp";
          var ERRNO_CODES = {
            "EPERM": 63,
            "ENOENT": 44,
            "ESRCH": 71,
            "EINTR": 27,
            "EIO": 29,
            "ENXIO": 60,
            "E2BIG": 1,
            "ENOEXEC": 45,
            "EBADF": 8,
            "ECHILD": 12,
            "EAGAIN": 6,
            "EWOULDBLOCK": 6,
            "ENOMEM": 48,
            "EACCES": 2,
            "EFAULT": 21,
            "ENOTBLK": 105,
            "EBUSY": 10,
            "EEXIST": 20,
            "EXDEV": 75,
            "ENODEV": 43,
            "ENOTDIR": 54,
            "EISDIR": 31,
            "EINVAL": 28,
            "ENFILE": 41,
            "EMFILE": 33,
            "ENOTTY": 59,
            "ETXTBSY": 74,
            "EFBIG": 22,
            "ENOSPC": 51,
            "ESPIPE": 70,
            "EROFS": 69,
            "EMLINK": 34,
            "EPIPE": 64,
            "EDOM": 18,
            "ERANGE": 68,
            "ENOMSG": 49,
            "EIDRM": 24,
            "ECHRNG": 106,
            "EL2NSYNC": 156,
            "EL3HLT": 107,
            "EL3RST": 108,
            "ELNRNG": 109,
            "EUNATCH": 110,
            "ENOCSI": 111,
            "EL2HLT": 112,
            "EDEADLK": 16,
            "ENOLCK": 46,
            "EBADE": 113,
            "EBADR": 114,
            "EXFULL": 115,
            "ENOANO": 104,
            "EBADRQC": 103,
            "EBADSLT": 102,
            "EDEADLOCK": 16,
            "EBFONT": 101,
            "ENOSTR": 100,
            "ENODATA": 116,
            "ETIME": 117,
            "ENOSR": 118,
            "ENONET": 119,
            "ENOPKG": 120,
            "EREMOTE": 121,
            "ENOLINK": 47,
            "EADV": 122,
            "ESRMNT": 123,
            "ECOMM": 124,
            "EPROTO": 65,
            "EMULTIHOP": 36,
            "EDOTDOT": 125,
            "EBADMSG": 9,
            "ENOTUNIQ": 126,
            "EBADFD": 127,
            "EREMCHG": 128,
            "ELIBACC": 129,
            "ELIBBAD": 130,
            "ELIBSCN": 131,
            "ELIBMAX": 132,
            "ELIBEXEC": 133,
            "ENOSYS": 52,
            "ENOTEMPTY": 55,
            "ENAMETOOLONG": 37,
            "ELOOP": 32,
            "EOPNOTSUPP": 138,
            "EPFNOSUPPORT": 139,
            "ECONNRESET": 15,
            "ENOBUFS": 42,
            "EAFNOSUPPORT": 5,
            "EPROTOTYPE": 67,
            "ENOTSOCK": 57,
            "ENOPROTOOPT": 50,
            "ESHUTDOWN": 140,
            "ECONNREFUSED": 14,
            "EADDRINUSE": 3,
            "ECONNABORTED": 13,
            "ENETUNREACH": 40,
            "ENETDOWN": 38,
            "ETIMEDOUT": 73,
            "EHOSTDOWN": 142,
            "EHOSTUNREACH": 23,
            "EINPROGRESS": 26,
            "EALREADY": 7,
            "EDESTADDRREQ": 17,
            "EMSGSIZE": 35,
            "EPROTONOSUPPORT": 66,
            "ESOCKTNOSUPPORT": 137,
            "EADDRNOTAVAIL": 4,
            "ENETRESET": 39,
            "EISCONN": 30,
            "ENOTCONN": 53,
            "ETOOMANYREFS": 141,
            "EUSERS": 136,
            "EDQUOT": 19,
            "ESTALE": 72,
            "ENOTSUP": 138,
            "ENOMEDIUM": 148,
            "EILSEQ": 25,
            "EOVERFLOW": 61,
            "ECANCELED": 11,
            "ENOTRECOVERABLE": 56,
            "EOWNERDEAD": 62,
            "ESTRPIPE": 135
          };
          var ERRNO_MESSAGES = {
            0: "Success",
            1: "Arg list too long",
            2: "Permission denied",
            3: "Address already in use",
            4: "Address not available",
            5: "Address family not supported by protocol family",
            6: "No more processes",
            7: "Socket already connected",
            8: "Bad file number",
            9: "Trying to read unreadable message",
            10: "Mount device busy",
            11: "Operation canceled",
            12: "No children",
            13: "Connection aborted",
            14: "Connection refused",
            15: "Connection reset by peer",
            16: "File locking deadlock error",
            17: "Destination address required",
            18: "Math arg out of domain of func",
            19: "Quota exceeded",
            20: "File exists",
            21: "Bad address",
            22: "File too large",
            23: "Host is unreachable",
            24: "Identifier removed",
            25: "Illegal byte sequence",
            26: "Connection already in progress",
            27: "Interrupted system call",
            28: "Invalid argument",
            29: "I/O error",
            30: "Socket is already connected",
            31: "Is a directory",
            32: "Too many symbolic links",
            33: "Too many open files",
            34: "Too many links",
            35: "Message too long",
            36: "Multihop attempted",
            37: "File or path name too long",
            38: "Network interface is not configured",
            39: "Connection reset by network",
            40: "Network is unreachable",
            41: "Too many open files in system",
            42: "No buffer space available",
            43: "No such device",
            44: "No such file or directory",
            45: "Exec format error",
            46: "No record locks available",
            47: "The link has been severed",
            48: "Not enough core",
            49: "No message of desired type",
            50: "Protocol not available",
            51: "No space left on device",
            52: "Function not implemented",
            53: "Socket is not connected",
            54: "Not a directory",
            55: "Directory not empty",
            56: "State not recoverable",
            57: "Socket operation on non-socket",
            59: "Not a typewriter",
            60: "No such device or address",
            61: "Value too large for defined data type",
            62: "Previous owner died",
            63: "Not super-user",
            64: "Broken pipe",
            65: "Protocol error",
            66: "Unknown protocol",
            67: "Protocol wrong type for socket",
            68: "Math result not representable",
            69: "Read only file system",
            70: "Illegal seek",
            71: "No such process",
            72: "Stale file handle",
            73: "Connection timed out",
            74: "Text file busy",
            75: "Cross-device link",
            100: "Device not a stream",
            101: "Bad font file fmt",
            102: "Invalid slot",
            103: "Invalid request code",
            104: "No anode",
            105: "Block device required",
            106: "Channel number out of range",
            107: "Level 3 halted",
            108: "Level 3 reset",
            109: "Link number out of range",
            110: "Protocol driver not attached",
            111: "No CSI structure available",
            112: "Level 2 halted",
            113: "Invalid exchange",
            114: "Invalid request descriptor",
            115: "Exchange full",
            116: "No data (for no delay io)",
            117: "Timer expired",
            118: "Out of streams resources",
            119: "Machine is not on the network",
            120: "Package not installed",
            121: "The object is remote",
            122: "Advertise error",
            123: "Srmount error",
            124: "Communication error on send",
            125: "Cross mount point (not really error)",
            126: "Given log. name not unique",
            127: "f.d. invalid for this operation",
            128: "Remote address changed",
            129: "Can   access a needed shared lib",
            130: "Accessing a corrupted shared lib",
            131: ".lib section in a.out corrupted",
            132: "Attempting to link in too many libs",
            133: "Attempting to exec a shared library",
            135: "Streams pipe error",
            136: "Too many users",
            137: "Socket type not supported",
            138: "Not supported",
            139: "Protocol family not supported",
            140: "Can't send after socket shutdown",
            141: "Too many references",
            142: "Host is down",
            148: "No medium (in tape drive)",
            156: "Level 2 not synchronized"
          };
          var Protocols = {
            list: [],
            map: {}
          };
          var _setprotoent = (stayopen) => {
            function allocprotoent(name2, proto, aliases) {
              var nameBuf = _malloc(name2.length + 1);
              stringToAscii(name2, nameBuf);
              var j = 0;
              var length = aliases.length;
              var aliasListBuf = _malloc((length + 1) * 4);
              for (var i2 = 0; i2 < length; i2++, j += 4) {
                var alias = aliases[i2];
                var aliasBuf = _malloc(alias.length + 1);
                stringToAscii(alias, aliasBuf);
                HEAPU32[aliasListBuf + j >>> 2 >>> 0] = aliasBuf;
              }
              HEAPU32[aliasListBuf + j >>> 2 >>> 0] = 0;
              var pe = _malloc(12);
              HEAPU32[pe >>> 2 >>> 0] = nameBuf;
              HEAPU32[pe + 4 >>> 2 >>> 0] = aliasListBuf;
              HEAP32[pe + 8 >>> 2 >>> 0] = proto;
              return pe;
            }
            var list = Protocols.list;
            var map = Protocols.map;
            if (list.length === 0) {
              var entry = allocprotoent("tcp", 6, ["TCP"]);
              list.push(entry);
              map["tcp"] = map["6"] = entry;
              entry = allocprotoent("udp", 17, ["UDP"]);
              list.push(entry);
              map["udp"] = map["17"] = entry;
            }
            _setprotoent.index = 0;
          };
          _setprotoent.sig = "vi";
          var _endprotoent = () => {
          };
          _endprotoent.sig = "v";
          function _getprotoent(number) {
            if (_setprotoent.index === Protocols.list.length) {
              return 0;
            }
            var result = Protocols.list[_setprotoent.index++];
            return result;
          }
          _getprotoent.sig = "p";
          function _getprotobyname(name2) {
            name2 >>>= 0;
            name2 = UTF8ToString(name2);
            _setprotoent(true);
            var result = Protocols.map[name2];
            return result;
          }
          _getprotobyname.sig = "pp";
          function _getprotobynumber(number) {
            _setprotoent(true);
            var result = Protocols.map[number];
            return result;
          }
          _getprotobynumber.sig = "pi";
          function _emscripten_run_script(ptr) {
            ptr >>>= 0;
            eval(UTF8ToString(ptr));
          }
          _emscripten_run_script.sig = "vp";
          function _emscripten_run_script_int(ptr) {
            ptr >>>= 0;
            return eval(UTF8ToString(ptr)) | 0;
          }
          _emscripten_run_script_int.sig = "ip";
          function _emscripten_run_script_string(ptr) {
            ptr >>>= 0;
            var s = eval(UTF8ToString(ptr));
            if (s == null) {
              return 0;
            }
            s += "";
            var me = _emscripten_run_script_string;
            var len = lengthBytesUTF8(s);
            if (!me.bufferSize || me.bufferSize < len + 1) {
              if (me.bufferSize)
                _free(me.buffer);
              me.bufferSize = len + 1;
              me.buffer = _malloc(me.bufferSize);
            }
            stringToUTF8(s, me.buffer, me.bufferSize);
            return me.buffer;
          }
          _emscripten_run_script_string.sig = "pp";
          var _emscripten_random = () => Math.random();
          _emscripten_random.sig = "f";
          function jsStackTrace() {
            var error = new Error();
            if (!error.stack) {
              try {
                throw new Error();
              } catch (e) {
                error = e;
              }
              if (!error.stack) {
                return "(no stack trace available)";
              }
            }
            return error.stack.toString();
          }
          function getCallstack(flags2) {
            var callstack = jsStackTrace();
            var iThisFunc = callstack.lastIndexOf("_emscripten_log");
            var iThisFunc2 = callstack.lastIndexOf("_emscripten_get_callstack");
            var iNextLine = callstack.indexOf("\n", Math.max(iThisFunc, iThisFunc2)) + 1;
            callstack = callstack.slice(iNextLine);
            if (flags2 & 8 && typeof emscripten_source_map == "undefined") {
              warnOnce('Source map information is not available, emscripten_log with EM_LOG_C_STACK will be ignored. Build with "--pre-js $EMSCRIPTEN/src/emscripten-source-map.min.js" linker flag to add source map loading to code.');
              flags2 ^= 8;
              flags2 |= 16;
            }
            var lines = callstack.split("\n");
            callstack = "";
            var newFirefoxRe = new RegExp("\\s*(.*?)@(.*?):([0-9]+):([0-9]+)");
            var firefoxRe = new RegExp("\\s*(.*?)@(.*):(.*)(:(.*))?");
            var chromeRe = new RegExp("\\s*at (.*?) \\((.*):(.*):(.*)\\)");
            for (var l in lines) {
              var line = lines[l];
              var symbolName = "";
              var file = "";
              var lineno = 0;
              var column = 0;
              var parts2 = chromeRe.exec(line);
              if (parts2 && parts2.length == 5) {
                symbolName = parts2[1];
                file = parts2[2];
                lineno = parts2[3];
                column = parts2[4];
              } else {
                parts2 = newFirefoxRe.exec(line);
                if (!parts2)
                  parts2 = firefoxRe.exec(line);
                if (parts2 && parts2.length >= 4) {
                  symbolName = parts2[1];
                  file = parts2[2];
                  lineno = parts2[3];
                  column = parts2[4] | 0;
                } else {
                  callstack += line + "\n";
                  continue;
                }
              }
              var haveSourceMap = false;
              if (flags2 & 8) {
                var orig = emscripten_source_map.originalPositionFor({
                  line: lineno,
                  column
                });
                haveSourceMap = orig?.source;
                if (haveSourceMap) {
                  if (flags2 & 64) {
                    orig.source = orig.source.substring(orig.source.replace(/\\/g, "/").lastIndexOf("/") + 1);
                  }
                  callstack += `    at ${symbolName} (${orig.source}:${orig.line}:${orig.column})
`;
                }
              }
              if (flags2 & 16 || !haveSourceMap) {
                if (flags2 & 64) {
                  file = file.substring(file.replace(/\\/g, "/").lastIndexOf("/") + 1);
                }
                callstack += (haveSourceMap ? `     = ${symbolName}` : `    at ${symbolName}`) + ` (${file}:${lineno}:${column})
`;
              }
            }
            callstack = callstack.replace(/\s+$/, "");
            return callstack;
          }
          function _emscripten_get_callstack(flags2, str, maxbytes) {
            str >>>= 0;
            var callstack = getCallstack(flags2);
            if (!str || maxbytes <= 0) {
              return lengthBytesUTF8(callstack) + 1;
            }
            var bytesWrittenExcludingNull = stringToUTF8(callstack, str, maxbytes);
            return bytesWrittenExcludingNull + 1;
          }
          _emscripten_get_callstack.sig = "iipi";
          var emscriptenLog = (flags2, str) => {
            if (flags2 & 24) {
              str = str.replace(/\s+$/, "");
              str += (str.length > 0 ? "\n" : "") + getCallstack(flags2);
            }
            if (flags2 & 1) {
              if (flags2 & 4) {
                console.error(str);
              } else if (flags2 & 2) {
                console.warn(str);
              } else if (flags2 & 512) {
                console.info(str);
              } else if (flags2 & 256) {
                console.debug(str);
              } else {
                console.log(str);
              }
            } else if (flags2 & 6) {
              err(str);
            } else {
              out(str);
            }
          };
          var reallyNegative = (x) => x < 0 || x === 0 && 1 / x === -Infinity;
          var reSign = (value, bits) => {
            if (value <= 0) {
              return value;
            }
            var half = bits <= 32 ? Math.abs(1 << bits - 1) : Math.pow(2, bits - 1);
            if (value >= half && (bits <= 32 || value > half)) {
              value = -2 * half + value;
            }
            return value;
          };
          var unSign = (value, bits) => {
            if (value >= 0) {
              return value;
            }
            return bits <= 32 ? 2 * Math.abs(1 << bits - 1) + value : Math.pow(2, bits) + value;
          };
          var strLen = (ptr2) => {
            var end = ptr2;
            while (HEAPU8[end >>> 0])
              ++end;
            return end - ptr2;
          };
          var formatString = (format, varargs) => {
            var textIndex = format;
            var argIndex = varargs;
            function prepVararg(ptr3, type) {
              if (type === "double" || type === "i64") {
                if (ptr3 & 7) {
                  ptr3 += 4;
                }
              } else {
              }
              return ptr3;
            }
            function getNextArg(type) {
              var ret2;
              argIndex = prepVararg(argIndex, type);
              if (type === "double") {
                ret2 = HEAPF64[argIndex >>> 3 >>> 0];
                argIndex += 8;
              } else if (type == "i64") {
                ret2 = [HEAP32[argIndex >>> 2 >>> 0], HEAP32[argIndex + 4 >>> 2 >>> 0]];
                argIndex += 8;
              } else {
                type = "i32";
                ret2 = HEAP32[argIndex >>> 2 >>> 0];
                argIndex += 4;
              }
              return ret2;
            }
            var ret = [];
            var curr, next, currArg;
            while (1) {
              var startTextIndex = textIndex;
              curr = HEAP8[textIndex >>> 0 >>> 0];
              if (curr === 0)
                break;
              next = HEAP8[textIndex + 1 >>> 0 >>> 0];
              if (curr == 37) {
                var flagAlwaysSigned = false;
                var flagLeftAlign = false;
                var flagAlternative = false;
                var flagZeroPad = false;
                var flagPadSign = false;
                flagsLoop:
                  while (1) {
                    switch (next) {
                      case 43:
                        flagAlwaysSigned = true;
                        break;
                      case 45:
                        flagLeftAlign = true;
                        break;
                      case 35:
                        flagAlternative = true;
                        break;
                      case 48:
                        if (flagZeroPad) {
                          break flagsLoop;
                        } else {
                          flagZeroPad = true;
                          break;
                        }
                      case 32:
                        flagPadSign = true;
                        break;
                      default:
                        break flagsLoop;
                    }
                    textIndex++;
                    next = HEAP8[textIndex + 1 >>> 0 >>> 0];
                  }
                var width = 0;
                if (next == 42) {
                  width = getNextArg("i32");
                  textIndex++;
                  next = HEAP8[textIndex + 1 >>> 0 >>> 0];
                } else {
                  while (next >= 48 && next <= 57) {
                    width = width * 10 + (next - 48);
                    textIndex++;
                    next = HEAP8[textIndex + 1 >>> 0 >>> 0];
                  }
                }
                var precisionSet = false, precision = -1;
                if (next == 46) {
                  precision = 0;
                  precisionSet = true;
                  textIndex++;
                  next = HEAP8[textIndex + 1 >>> 0 >>> 0];
                  if (next == 42) {
                    precision = getNextArg("i32");
                    textIndex++;
                  } else {
                    while (1) {
                      var precisionChr = HEAP8[textIndex + 1 >>> 0 >>> 0];
                      if (precisionChr < 48 || precisionChr > 57)
                        break;
                      precision = precision * 10 + (precisionChr - 48);
                      textIndex++;
                    }
                  }
                  next = HEAP8[textIndex + 1 >>> 0 >>> 0];
                }
                if (precision < 0) {
                  precision = 6;
                  precisionSet = false;
                }
                var argSize;
                switch (String.fromCharCode(next)) {
                  case "h":
                    var nextNext = HEAP8[textIndex + 2 >>> 0 >>> 0];
                    if (nextNext == 104) {
                      textIndex++;
                      argSize = 1;
                    } else {
                      argSize = 2;
                    }
                    break;
                  case "l":
                    var nextNext = HEAP8[textIndex + 2 >>> 0 >>> 0];
                    if (nextNext == 108) {
                      textIndex++;
                      argSize = 8;
                    } else {
                      argSize = 4;
                    }
                    break;
                  case "L":
                  case "q":
                  case "j":
                    argSize = 8;
                    break;
                  case "z":
                  case "t":
                  case "I":
                    argSize = 4;
                    break;
                  default:
                    argSize = null;
                }
                if (argSize)
                  textIndex++;
                next = HEAP8[textIndex + 1 >>> 0 >>> 0];
                switch (String.fromCharCode(next)) {
                  case "d":
                  case "i":
                  case "u":
                  case "o":
                  case "x":
                  case "X":
                  case "p": {
                    var signed = next == 100 || next == 105;
                    argSize = argSize || 4;
                    currArg = getNextArg("i" + argSize * 8);
                    var argText;
                    if (argSize == 8) {
                      currArg = next == 117 ? convertU32PairToI53(currArg[0], currArg[1]) : convertI32PairToI53(currArg[0], currArg[1]);
                    }
                    if (argSize <= 4) {
                      var limit = Math.pow(256, argSize) - 1;
                      currArg = (signed ? reSign : unSign)(currArg & limit, argSize * 8);
                    }
                    var currAbsArg = Math.abs(currArg);
                    var prefix = "";
                    if (next == 100 || next == 105) {
                      argText = reSign(currArg, 8 * argSize).toString(10);
                    } else if (next == 117) {
                      argText = unSign(currArg, 8 * argSize).toString(10);
                      currArg = Math.abs(currArg);
                    } else if (next == 111) {
                      argText = (flagAlternative ? "0" : "") + currAbsArg.toString(8);
                    } else if (next == 120 || next == 88) {
                      prefix = flagAlternative && currArg != 0 ? "0x" : "";
                      if (currArg < 0) {
                        currArg = -currArg;
                        argText = (currAbsArg - 1).toString(16);
                        var buffer = [];
                        for (var i2 = 0; i2 < argText.length; i2++) {
                          buffer.push((15 - parseInt(argText[i2], 16)).toString(16));
                        }
                        argText = buffer.join("");
                        while (argText.length < argSize * 2)
                          argText = "f" + argText;
                      } else {
                        argText = currAbsArg.toString(16);
                      }
                      if (next == 88) {
                        prefix = prefix.toUpperCase();
                        argText = argText.toUpperCase();
                      }
                    } else if (next == 112) {
                      if (currAbsArg === 0) {
                        argText = "(nil)";
                      } else {
                        prefix = "0x";
                        argText = currAbsArg.toString(16);
                      }
                    }
                    if (precisionSet) {
                      while (argText.length < precision) {
                        argText = "0" + argText;
                      }
                    }
                    if (currArg >= 0) {
                      if (flagAlwaysSigned) {
                        prefix = "+" + prefix;
                      } else if (flagPadSign) {
                        prefix = " " + prefix;
                      }
                    }
                    if (argText.charAt(0) == "-") {
                      prefix = "-" + prefix;
                      argText = argText.substr(1);
                    }
                    while (prefix.length + argText.length < width) {
                      if (flagLeftAlign) {
                        argText += " ";
                      } else {
                        if (flagZeroPad) {
                          argText = "0" + argText;
                        } else {
                          prefix = " " + prefix;
                        }
                      }
                    }
                    argText = prefix + argText;
                    argText.split("").forEach(function(chr) {
                      ret.push(chr.charCodeAt(0));
                    });
                    break;
                  }
                  case "f":
                  case "F":
                  case "e":
                  case "E":
                  case "g":
                  case "G": {
                    currArg = getNextArg("double");
                    var argText;
                    if (isNaN(currArg)) {
                      argText = "nan";
                      flagZeroPad = false;
                    } else if (!isFinite(currArg)) {
                      argText = (currArg < 0 ? "-" : "") + "inf";
                      flagZeroPad = false;
                    } else {
                      var isGeneral = false;
                      var effectivePrecision = Math.min(precision, 20);
                      if (next == 103 || next == 71) {
                        isGeneral = true;
                        precision = precision || 1;
                        var exponent = parseInt(currArg.toExponential(effectivePrecision).split("e")[1], 10);
                        if (precision > exponent && exponent >= -4) {
                          next = (next == 103 ? "f" : "F").charCodeAt(0);
                          precision -= exponent + 1;
                        } else {
                          next = (next == 103 ? "e" : "E").charCodeAt(0);
                          precision--;
                        }
                        effectivePrecision = Math.min(precision, 20);
                      }
                      if (next == 101 || next == 69) {
                        argText = currArg.toExponential(effectivePrecision);
                        if (/[eE][-+]\d$/.test(argText)) {
                          argText = argText.slice(0, -1) + "0" + argText.slice(-1);
                        }
                      } else if (next == 102 || next == 70) {
                        argText = currArg.toFixed(effectivePrecision);
                        if (currArg === 0 && reallyNegative(currArg)) {
                          argText = "-" + argText;
                        }
                      }
                      var parts2 = argText.split("e");
                      if (isGeneral && !flagAlternative) {
                        while (parts2[0].length > 1 && parts2[0].includes(".") && (parts2[0].slice(-1) == "0" || parts2[0].slice(-1) == ".")) {
                          parts2[0] = parts2[0].slice(0, -1);
                        }
                      } else {
                        if (flagAlternative && argText.indexOf(".") == -1)
                          parts2[0] += ".";
                        while (precision > effectivePrecision++)
                          parts2[0] += "0";
                      }
                      argText = parts2[0] + (parts2.length > 1 ? "e" + parts2[1] : "");
                      if (next == 69)
                        argText = argText.toUpperCase();
                      if (currArg >= 0) {
                        if (flagAlwaysSigned) {
                          argText = "+" + argText;
                        } else if (flagPadSign) {
                          argText = " " + argText;
                        }
                      }
                    }
                    while (argText.length < width) {
                      if (flagLeftAlign) {
                        argText += " ";
                      } else {
                        if (flagZeroPad && (argText[0] == "-" || argText[0] == "+")) {
                          argText = argText[0] + "0" + argText.slice(1);
                        } else {
                          argText = (flagZeroPad ? "0" : " ") + argText;
                        }
                      }
                    }
                    if (next < 97)
                      argText = argText.toUpperCase();
                    argText.split("").forEach(function(chr) {
                      ret.push(chr.charCodeAt(0));
                    });
                    break;
                  }
                  case "s": {
                    var arg = getNextArg("i8*");
                    var argLength = arg ? strLen(arg) : "(null)".length;
                    if (precisionSet)
                      argLength = Math.min(argLength, precision);
                    if (!flagLeftAlign) {
                      while (argLength < width--) {
                        ret.push(32);
                      }
                    }
                    if (arg) {
                      for (var i2 = 0; i2 < argLength; i2++) {
                        ret.push(HEAPU8[arg++ >>> 0 >>> 0]);
                      }
                    } else {
                      ret = ret.concat(intArrayFromString("(null)".substr(0, argLength), true));
                    }
                    if (flagLeftAlign) {
                      while (argLength < width--) {
                        ret.push(32);
                      }
                    }
                    break;
                  }
                  case "c": {
                    if (flagLeftAlign)
                      ret.push(getNextArg("i8"));
                    while (--width > 0) {
                      ret.push(32);
                    }
                    if (!flagLeftAlign)
                      ret.push(getNextArg("i8"));
                    break;
                  }
                  case "n": {
                    var ptr2 = getNextArg("i32*");
                    HEAP32[ptr2 >>> 2 >>> 0] = ret.length;
                    break;
                  }
                  case "%": {
                    ret.push(curr);
                    break;
                  }
                  default: {
                    for (var i2 = startTextIndex; i2 < textIndex + 2; i2++) {
                      ret.push(HEAP8[i2 >>> 0 >>> 0]);
                    }
                  }
                }
                textIndex += 2;
              } else {
                ret.push(curr);
                textIndex += 1;
              }
            }
            return ret;
          };
          function _emscripten_log(flags2, format, varargs) {
            format >>>= 0;
            varargs >>>= 0;
            var result = formatString(format, varargs);
            var str = UTF8ArrayToString(result, 0);
            emscriptenLog(flags2, str);
          }
          _emscripten_log.sig = "vipp";
          function _emscripten_get_compiler_setting(name2) {
            name2 >>>= 0;
            throw "You must build with -sRETAIN_COMPILER_SETTINGS for getCompilerSetting or emscripten_get_compiler_setting to work";
          }
          _emscripten_get_compiler_setting.sig = "pp";
          var _emscripten_has_asyncify = () => 0;
          _emscripten_has_asyncify.sig = "i";
          function _emscripten_debugger() {
            debugger;
          }
          _emscripten_debugger.sig = "v";
          function _emscripten_print_double(x, to, max) {
            to >>>= 0;
            var str = x + "";
            if (to)
              return stringToUTF8(str, to, max);
            else
              return lengthBytesUTF8(str);
          }
          _emscripten_print_double.sig = "idpi";
          var convertFrameToPC = (frame) => {
            abort("Cannot use convertFrameToPC (needed by __builtin_return_address) without -sUSE_OFFSET_CONVERTER");
            return 0;
          };
          function _emscripten_return_address(level) {
            var callstack = jsStackTrace().split("\n");
            if (callstack[0] == "Error") {
              callstack.shift();
            }
            var caller = callstack[level + 3];
            return convertFrameToPC(caller);
          }
          _emscripten_return_address.sig = "pi";
          var UNWIND_CACHE = {};
          var saveInUnwindCache = (callstack) => {
            callstack.forEach((frame) => {
              var pc = convertFrameToPC(frame);
              if (pc) {
                UNWIND_CACHE[pc] = frame;
              }
            });
          };
          function _emscripten_stack_snapshot() {
            var callstack = jsStackTrace().split("\n");
            if (callstack[0] == "Error") {
              callstack.shift();
            }
            saveInUnwindCache(callstack);
            UNWIND_CACHE.last_addr = convertFrameToPC(callstack[3]);
            UNWIND_CACHE.last_stack = callstack;
            return UNWIND_CACHE.last_addr;
          }
          _emscripten_stack_snapshot.sig = "p";
          function _emscripten_stack_unwind_buffer(addr2, buffer, count) {
            addr2 >>>= 0;
            buffer >>>= 0;
            var stack;
            if (UNWIND_CACHE.last_addr == addr2) {
              stack = UNWIND_CACHE.last_stack;
            } else {
              stack = jsStackTrace().split("\n");
              if (stack[0] == "Error") {
                stack.shift();
              }
              saveInUnwindCache(stack);
            }
            var offset = 3;
            while (stack[offset] && convertFrameToPC(stack[offset]) != addr2) {
              ++offset;
            }
            for (var i2 = 0; i2 < count && stack[i2 + offset]; ++i2) {
              HEAP32[buffer + i2 * 4 >>> 2 >>> 0] = convertFrameToPC(stack[i2 + offset]);
            }
            return i2;
          }
          _emscripten_stack_unwind_buffer.sig = "ippi";
          function _emscripten_pc_get_function(pc) {
            pc >>>= 0;
            abort("Cannot use emscripten_pc_get_function without -sUSE_OFFSET_CONVERTER");
            return 0;
          }
          _emscripten_pc_get_function.sig = "pp";
          var convertPCtoSourceLocation = (pc) => {
            if (UNWIND_CACHE.last_get_source_pc == pc)
              return UNWIND_CACHE.last_source;
            var match;
            var source;
            if (!source) {
              var frame = UNWIND_CACHE[pc];
              if (!frame)
                return null;
              if (match = /\((.*):(\d+):(\d+)\)$/.exec(frame)) {
                source = {
                  file: match[1],
                  line: match[2],
                  column: match[3]
                };
              } else if (match = /@(.*):(\d+):(\d+)/.exec(frame)) {
                source = {
                  file: match[1],
                  line: match[2],
                  column: match[3]
                };
              }
            }
            UNWIND_CACHE.last_get_source_pc = pc;
            UNWIND_CACHE.last_source = source;
            return source;
          };
          function _emscripten_pc_get_file(pc) {
            pc >>>= 0;
            var result = convertPCtoSourceLocation(pc);
            if (!result)
              return 0;
            if (_emscripten_pc_get_file.ret)
              _free(_emscripten_pc_get_file.ret);
            _emscripten_pc_get_file.ret = stringToNewUTF8(result.file);
            return _emscripten_pc_get_file.ret;
          }
          _emscripten_pc_get_file.sig = "pp";
          function _emscripten_pc_get_line(pc) {
            pc >>>= 0;
            var result = convertPCtoSourceLocation(pc);
            return result ? result.line : 0;
          }
          _emscripten_pc_get_line.sig = "ip";
          function _emscripten_pc_get_column(pc) {
            pc >>>= 0;
            var result = convertPCtoSourceLocation(pc);
            return result ? result.column || 0 : 0;
          }
          _emscripten_pc_get_column.sig = "ip";
          function _emscripten_get_module_name(buf, length) {
            buf >>>= 0;
            length >>>= 0;
            return stringToUTF8(wasmBinaryFile, buf, length);
          }
          _emscripten_get_module_name.sig = "ppp";
          function _emscripten_asm_const_double(code, sigPtr, argbuf) {
            code >>>= 0;
            sigPtr >>>= 0;
            argbuf >>>= 0;
            return runEmAsmFunction(code, sigPtr, argbuf);
          }
          _emscripten_asm_const_double.sig = "dppp";
          var runMainThreadEmAsm = (code, sigPtr, argbuf, sync) => {
            var args2 = readEmAsmArgs(sigPtr, argbuf);
            return ASM_CONSTS[code].apply(null, args2);
          };
          function _emscripten_asm_const_int_sync_on_main_thread(code, sigPtr, argbuf) {
            code >>>= 0;
            sigPtr >>>= 0;
            argbuf >>>= 0;
            return runMainThreadEmAsm(code, sigPtr, argbuf, 1);
          }
          _emscripten_asm_const_int_sync_on_main_thread.sig = "ippp";
          function _emscripten_asm_const_ptr_sync_on_main_thread(code, sigPtr, argbuf) {
            code >>>= 0;
            sigPtr >>>= 0;
            argbuf >>>= 0;
            return runMainThreadEmAsm(code, sigPtr, argbuf, 1);
          }
          _emscripten_asm_const_ptr_sync_on_main_thread.sig = "pppp";
          var _emscripten_asm_const_double_sync_on_main_thread = _emscripten_asm_const_int_sync_on_main_thread;
          _emscripten_asm_const_double_sync_on_main_thread.sig = "dppp";
          function _emscripten_asm_const_async_on_main_thread(code, sigPtr, argbuf) {
            code >>>= 0;
            sigPtr >>>= 0;
            argbuf >>>= 0;
            return runMainThreadEmAsm(code, sigPtr, argbuf, 0);
          }
          _emscripten_asm_const_async_on_main_thread.sig = "vppp";
          var jstoi_s = Number;
          function __Unwind_Backtrace(func2, arg) {
            func2 >>>= 0;
            arg >>>= 0;
            var trace = getCallstack();
            var parts2 = trace.split("\n");
            for (var i2 = 0; i2 < parts2.length; i2++) {
              var ret = getWasmTableEntry(func2)(0, arg);
              if (ret !== 0)
                return;
            }
          }
          __Unwind_Backtrace.sig = "ipp";
          function __Unwind_GetIPInfo(context, ipBefore) {
            context >>>= 0;
            ipBefore >>>= 0;
            return abort("Unwind_GetIPInfo");
          }
          __Unwind_GetIPInfo.sig = "ppp";
          function __Unwind_FindEnclosingFunction(ip) {
            ip >>>= 0;
            return 0;
          }
          __Unwind_FindEnclosingFunction.sig = "pp";
          var createDyncallWrapper = (sig) => {
            var sections = [];
            var prelude = [0, 97, 115, 109, 1, 0, 0, 0];
            sections.push(prelude);
            var wrappersig = [sig[0].replace("j", "i"), "i", sig.slice(1).replace(/j/g, "ii")].join("");
            var typeSectionBody = [3];
            generateFuncType(wrappersig, typeSectionBody);
            generateFuncType(sig, typeSectionBody);
            generateFuncType("vi", typeSectionBody);
            var typeSection = [1];
            uleb128Encode(typeSectionBody.length, typeSection);
            typeSection.push.apply(typeSection, typeSectionBody);
            sections.push(typeSection);
            var importSection = [2, 15, 2, 1, 101, 1, 116, 1, 112, 0, 0, 1, 101, 1, 114, 0, 2];
            sections.push(importSection);
            var functionSection = [3, 2, 1, 0];
            sections.push(functionSection);
            var exportSection = [7, 5, 1, 1, 102, 0, 1];
            sections.push(exportSection);
            var convert_code = [];
            if (sig[0] === "j") {
              convert_code = [1, 1, 126];
            } else {
              convert_code.push(0);
            }
            function localGet(j2) {
              convert_code.push(32);
              uleb128Encode(j2, convert_code);
            }
            var j = 1;
            for (var i2 = 1; i2 < sig.length; i2++) {
              if (sig[i2] == "j") {
                localGet(j + 1);
                convert_code.push(173, 66, 32, 134);
                localGet(j);
                convert_code.push(172, 132);
                j += 2;
              } else {
                localGet(j);
                j++;
              }
            }
            convert_code.push(32, 0, 17, 1, 0);
            if (sig[0] === "j") {
              convert_code.push(34);
              uleb128Encode(j, convert_code);
              convert_code.push(66, 32, 136, 167, 16, 0);
              localGet(j);
              convert_code.push(167);
            }
            convert_code.push(11);
            var codeBody = [1];
            uleb128Encode(convert_code.length, codeBody);
            codeBody.push.apply(codeBody, convert_code);
            var codeSection = [10];
            uleb128Encode(codeBody.length, codeSection);
            codeSection.push.apply(codeSection, codeBody);
            sections.push(codeSection);
            var bytes = new Uint8Array([].concat.apply([], sections));
            var module2 = new WebAssembly.Module(bytes);
            var instance10 = new WebAssembly.Instance(module2, {
              "e": {
                "t": wasmTable,
                "r": setTempRet0
              }
            });
            var wrappedFunc = instance10.exports["f"];
            return wrappedFunc;
          };
          var dynCallLegacy = (sig, ptr2, args2) => {
            if (!("dynCall_" + sig in Module)) {
              Module["dynCall_" + sig] = createDyncallWrapper(sig);
            }
            var f = Module["dynCall_" + sig];
            return args2 && args2.length ? f.apply(null, [ptr2].concat(args2)) : f.call(null, ptr2);
          };
          var dynCall = (sig, ptr2, args2) => {
            if (sig.includes("j")) {
              return dynCallLegacy(sig, ptr2, args2);
            }
            var rtn = getWasmTableEntry(ptr2).apply(null, args2);
            return rtn;
          };
          var getDynCaller = (sig, ptr2) => {
            var argCache = [];
            return function() {
              argCache.length = 0;
              Object.assign(argCache, arguments);
              return dynCall(sig, ptr2, argCache);
            };
          };
          var _emscripten_exit_with_live_runtime = () => {
            throw "unwind";
          };
          _emscripten_exit_with_live_runtime.sig = "v";
          var _emscripten_force_exit = (status) => {
            __emscripten_runtime_keepalive_clear();
            _exit(status);
          };
          _emscripten_force_exit.sig = "vi";
          function _emscripten_outn(str, len2) {
            str >>>= 0;
            len2 >>>= 0;
            return out(UTF8ToString(str, len2));
          }
          _emscripten_outn.sig = "vpp";
          function _emscripten_errn(str, len2) {
            str >>>= 0;
            len2 >>>= 0;
            return err(UTF8ToString(str, len2));
          }
          _emscripten_errn.sig = "vpp";
          var _emscripten_throw_number = (number) => {
            throw number;
          };
          _emscripten_throw_number.sig = "vd";
          function _emscripten_throw_string(str) {
            str >>>= 0;
            throw UTF8ToString(str);
          }
          _emscripten_throw_string.sig = "vp";
          var runtimeKeepalivePush = () => {
            runtimeKeepaliveCounter += 1;
          };
          runtimeKeepalivePush.sig = "v";
          var runtimeKeepalivePop = () => {
            runtimeKeepaliveCounter -= 1;
          };
          runtimeKeepalivePop.sig = "v";
          var _emscripten_runtime_keepalive_push = runtimeKeepalivePush;
          _emscripten_runtime_keepalive_push.sig = "v";
          var _emscripten_runtime_keepalive_pop = runtimeKeepalivePop;
          _emscripten_runtime_keepalive_pop.sig = "v";
          var _emscripten_runtime_keepalive_check = keepRuntimeAlive;
          _emscripten_runtime_keepalive_check.sig = "i";
          var asmjsMangle = (x) => {
            var unmangledSymbols = ["stackAlloc", "stackSave", "stackRestore", "getTempRet0", "setTempRet0"];
            if (x == "__main_argc_argv") {
              x = "main";
            }
            return x.indexOf("dynCall_") == 0 || unmangledSymbols.includes(x) ? x : "_" + x;
          };
          var ___global_base = 1024;
          function __emscripten_fs_load_embedded_files(ptr2) {
            ptr2 >>>= 0;
            do {
              var name_addr = HEAPU32[ptr2 >>> 2 >>> 0];
              ptr2 += 4;
              var len2 = HEAPU32[ptr2 >>> 2 >>> 0];
              ptr2 += 4;
              var content = HEAPU32[ptr2 >>> 2 >>> 0];
              ptr2 += 4;
              var name2 = UTF8ToString(name_addr);
              FS.createPath("/", PATH.dirname(name2), true, true);
              FS.createDataFile(name2, null, HEAP8.subarray(content >>> 0, content + len2 >>> 0), true, true, true);
            } while (HEAPU32[ptr2 >>> 2 >>> 0]);
          }
          __emscripten_fs_load_embedded_files.sig = "vp";
          var POINTER_SIZE = 4;
          function getNativeTypeSize(type) {
            switch (type) {
              case "i1":
              case "i8":
              case "u8":
                return 1;
              case "i16":
              case "u16":
                return 2;
              case "i32":
              case "u32":
                return 4;
              case "i64":
              case "u64":
                return 8;
              case "float":
                return 4;
              case "double":
                return 8;
              default: {
                if (type[type.length - 1] === "*") {
                  return POINTER_SIZE;
                }
                if (type[0] === "i") {
                  const bits = Number(type.substr(1));
                  assert(bits % 8 === 0, `getNativeTypeSize invalid bits ${bits}, ${type} type`);
                  return bits / 8;
                }
                return 0;
              }
            }
          }
          var STACK_SIZE = 65536;
          var STACK_ALIGN = 16;
          var ASSERTIONS = 0;
          var cwrap = (ident, returnType, argTypes, opts) => {
            var numericArgs = !argTypes || argTypes.every((type) => type === "number" || type === "boolean");
            var numericRet = returnType !== "string";
            if (numericRet && numericArgs && !opts) {
              return getCFunc(ident);
            }
            return function() {
              return ccall(ident, returnType, argTypes, arguments, opts);
            };
          };
          var removeFunction = (index) => {
            functionsInTableMap.delete(getWasmTableEntry(index));
            setWasmTableEntry(index, null);
            freeTableIndexes.push(index);
          };
          var _emscripten_math_cbrt = (x) => Math.cbrt(x);
          _emscripten_math_cbrt.sig = "dd";
          var _emscripten_math_pow = (x, y) => Math.pow(x, y);
          _emscripten_math_pow.sig = "ddd";
          var _emscripten_math_random = () => Math.random();
          _emscripten_math_random.sig = "d";
          var _emscripten_math_sign = (x) => Math.sign(x);
          _emscripten_math_sign.sig = "dd";
          var _emscripten_math_sqrt = (x) => Math.sqrt(x);
          _emscripten_math_sqrt.sig = "dd";
          var _emscripten_math_exp = (x) => Math.exp(x);
          _emscripten_math_exp.sig = "dd";
          var _emscripten_math_expm1 = (x) => Math.expm1(x);
          _emscripten_math_expm1.sig = "dd";
          var _emscripten_math_fmod = (x, y) => x % y;
          _emscripten_math_fmod.sig = "ddd";
          var _emscripten_math_log = (x) => Math.log(x);
          _emscripten_math_log.sig = "dd";
          var _emscripten_math_log1p = (x) => Math.log1p(x);
          _emscripten_math_log1p.sig = "dd";
          var _emscripten_math_log10 = (x) => Math.log10(x);
          _emscripten_math_log10.sig = "dd";
          var _emscripten_math_log2 = (x) => Math.log2(x);
          _emscripten_math_log2.sig = "dd";
          var _emscripten_math_round = (x) => Math.round(x);
          _emscripten_math_round.sig = "dd";
          var _emscripten_math_acos = (x) => Math.acos(x);
          _emscripten_math_acos.sig = "dd";
          var _emscripten_math_acosh = (x) => Math.acosh(x);
          _emscripten_math_acosh.sig = "dd";
          var _emscripten_math_asin = (x) => Math.asin(x);
          _emscripten_math_asin.sig = "dd";
          var _emscripten_math_asinh = (x) => Math.asinh(x);
          _emscripten_math_asinh.sig = "dd";
          var _emscripten_math_atan = (x) => Math.atan(x);
          _emscripten_math_atan.sig = "dd";
          var _emscripten_math_atanh = (x) => Math.atanh(x);
          _emscripten_math_atanh.sig = "dd";
          var _emscripten_math_atan2 = (y, x) => Math.atan2(y, x);
          _emscripten_math_atan2.sig = "ddd";
          var _emscripten_math_cos = (x) => Math.cos(x);
          _emscripten_math_cos.sig = "dd";
          var _emscripten_math_cosh = (x) => Math.cosh(x);
          _emscripten_math_cosh.sig = "dd";
          function _emscripten_math_hypot(count, varargs) {
            varargs >>>= 0;
            var args2 = [];
            for (var i2 = 0; i2 < count; ++i2) {
              args2.push(HEAPF64[varargs + i2 * 8 >>> 3 >>> 0]);
            }
            return Math.hypot.apply(null, args2);
          }
          _emscripten_math_hypot.sig = "dip";
          var _emscripten_math_sin = (x) => Math.sin(x);
          _emscripten_math_sin.sig = "dd";
          var _emscripten_math_sinh = (x) => Math.sinh(x);
          _emscripten_math_sinh.sig = "dd";
          var _emscripten_math_tan = (x) => Math.tan(x);
          _emscripten_math_tan.sig = "dd";
          var _emscripten_math_tanh = (x) => Math.tanh(x);
          _emscripten_math_tanh.sig = "dd";
          function intArrayToString(array) {
            var ret = [];
            for (var i2 = 0; i2 < array.length; i2++) {
              var chr = array[i2];
              if (chr > 255) {
                chr &= 255;
              }
              ret.push(String.fromCharCode(chr));
            }
            return ret.join("");
          }
          var AsciiToString = (ptr2) => {
            ptr2 >>>= 0;
            var str = "";
            while (1) {
              var ch = HEAPU8[ptr2++ >>> 0 >>> 0];
              if (!ch)
                return str;
              str += String.fromCharCode(ch);
            }
          };
          var JSEvents = {
            removeAllEventListeners() {
              while (JSEvents.eventHandlers.length) {
                JSEvents._removeHandler(JSEvents.eventHandlers.length - 1);
              }
              JSEvents.deferredCalls = [];
            },
            inEventHandler: 0,
            deferredCalls: [],
            deferCall(targetFunction, precedence, argsList) {
              function arraysHaveEqualContent(arrA, arrB) {
                if (arrA.length != arrB.length)
                  return false;
                for (var i3 in arrA) {
                  if (arrA[i3] != arrB[i3])
                    return false;
                }
                return true;
              }
              for (var i2 in JSEvents.deferredCalls) {
                var call = JSEvents.deferredCalls[i2];
                if (call.targetFunction == targetFunction && arraysHaveEqualContent(call.argsList, argsList)) {
                  return;
                }
              }
              JSEvents.deferredCalls.push({
                targetFunction,
                precedence,
                argsList
              });
              JSEvents.deferredCalls.sort((x, y) => x.precedence < y.precedence);
            },
            removeDeferredCalls(targetFunction) {
              for (var i2 = 0; i2 < JSEvents.deferredCalls.length; ++i2) {
                if (JSEvents.deferredCalls[i2].targetFunction == targetFunction) {
                  JSEvents.deferredCalls.splice(i2, 1);
                  --i2;
                }
              }
            },
            canPerformEventHandlerRequests() {
              if (navigator.userActivation) {
                return navigator.userActivation.isActive;
              }
              return JSEvents.inEventHandler && JSEvents.currentEventHandler.allowsDeferredCalls;
            },
            runDeferredCalls() {
              if (!JSEvents.canPerformEventHandlerRequests()) {
                return;
              }
              for (var i2 = 0; i2 < JSEvents.deferredCalls.length; ++i2) {
                var call = JSEvents.deferredCalls[i2];
                JSEvents.deferredCalls.splice(i2, 1);
                --i2;
                call.targetFunction.apply(null, call.argsList);
              }
            },
            eventHandlers: [],
            removeAllHandlersOnTarget: (target, eventTypeString) => {
              for (var i2 = 0; i2 < JSEvents.eventHandlers.length; ++i2) {
                if (JSEvents.eventHandlers[i2].target == target && (!eventTypeString || eventTypeString == JSEvents.eventHandlers[i2].eventTypeString)) {
                  JSEvents._removeHandler(i2--);
                }
              }
            },
            _removeHandler(i2) {
              var h = JSEvents.eventHandlers[i2];
              h.target.removeEventListener(h.eventTypeString, h.eventListenerFunc, h.useCapture);
              JSEvents.eventHandlers.splice(i2, 1);
            },
            registerOrRemoveHandler(eventHandler) {
              if (!eventHandler.target) {
                return -4;
              }
              if (eventHandler.callbackfunc) {
                eventHandler.eventListenerFunc = function(event2) {
                  ++JSEvents.inEventHandler;
                  JSEvents.currentEventHandler = eventHandler;
                  JSEvents.runDeferredCalls();
                  eventHandler.handlerFunc(event2);
                  JSEvents.runDeferredCalls();
                  --JSEvents.inEventHandler;
                };
                eventHandler.target.addEventListener(eventHandler.eventTypeString, eventHandler.eventListenerFunc, eventHandler.useCapture);
                JSEvents.eventHandlers.push(eventHandler);
              } else {
                for (var i2 = 0; i2 < JSEvents.eventHandlers.length; ++i2) {
                  if (JSEvents.eventHandlers[i2].target == eventHandler.target && JSEvents.eventHandlers[i2].eventTypeString == eventHandler.eventTypeString) {
                    JSEvents._removeHandler(i2--);
                  }
                }
              }
              return 0;
            },
            getNodeNameForTarget(target) {
              if (!target)
                return "";
              if (target == window)
                return "#window";
              if (target == screen)
                return "#screen";
              return target?.nodeName || "";
            },
            fullscreenEnabled() {
              return document.fullscreenEnabled || document.webkitFullscreenEnabled;
            }
          };
          var maybeCStringToJsString = (cString) => cString > 2 ? UTF8ToString(cString) : cString;
          var specialHTMLTargets = [0, typeof document != "undefined" ? document : 0, typeof window != "undefined" ? window : 0];
          var findEventTarget = (target) => {
            target = maybeCStringToJsString(target);
            var domElement = specialHTMLTargets[target] || (typeof document != "undefined" ? document.querySelector(target) : void 0);
            return domElement;
          };
          var registerKeyEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
            if (!JSEvents.keyEvent)
              JSEvents.keyEvent = _malloc(176);
            var keyEventHandlerFunc = (e) => {
              var keyEventData = JSEvents.keyEvent;
              HEAPF64[keyEventData >>> 3 >>> 0] = e.timeStamp;
              var idx = keyEventData >>> 2;
              HEAP32[idx + 2 >>> 0] = e.location;
              HEAP32[idx + 3 >>> 0] = e.ctrlKey;
              HEAP32[idx + 4 >>> 0] = e.shiftKey;
              HEAP32[idx + 5 >>> 0] = e.altKey;
              HEAP32[idx + 6 >>> 0] = e.metaKey;
              HEAP32[idx + 7 >>> 0] = e.repeat;
              HEAP32[idx + 8 >>> 0] = e.charCode;
              HEAP32[idx + 9 >>> 0] = e.keyCode;
              HEAP32[idx + 10 >>> 0] = e.which;
              stringToUTF8(e.key || "", keyEventData + 44, 32);
              stringToUTF8(e.code || "", keyEventData + 76, 32);
              stringToUTF8(e.char || "", keyEventData + 108, 32);
              stringToUTF8(e.locale || "", keyEventData + 140, 32);
              if (getWasmTableEntry(callbackfunc)(eventTypeId, keyEventData, userData))
                e.preventDefault();
            };
            var eventHandler = {
              target: findEventTarget(target),
              eventTypeString,
              callbackfunc,
              handlerFunc: keyEventHandlerFunc,
              useCapture
            };
            return JSEvents.registerOrRemoveHandler(eventHandler);
          };
          var findCanvasEventTarget = findEventTarget;
          function _emscripten_set_keypress_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
            target >>>= 0;
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            return registerKeyEventCallback(target, userData, useCapture, callbackfunc, 1, "keypress", targetThread);
          }
          _emscripten_set_keypress_callback_on_thread.sig = "ippipp";
          function _emscripten_set_keydown_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
            target >>>= 0;
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            return registerKeyEventCallback(target, userData, useCapture, callbackfunc, 2, "keydown", targetThread);
          }
          _emscripten_set_keydown_callback_on_thread.sig = "ippipp";
          function _emscripten_set_keyup_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
            target >>>= 0;
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            return registerKeyEventCallback(target, userData, useCapture, callbackfunc, 3, "keyup", targetThread);
          }
          _emscripten_set_keyup_callback_on_thread.sig = "ippipp";
          var getBoundingClientRect = (e) => specialHTMLTargets.indexOf(e) < 0 ? e.getBoundingClientRect() : {
            "left": 0,
            "top": 0
          };
          var fillMouseEventData = (eventStruct, e, target) => {
            HEAPF64[eventStruct >>> 3 >>> 0] = e.timeStamp;
            var idx = eventStruct >>> 2;
            HEAP32[idx + 2 >>> 0] = e.screenX;
            HEAP32[idx + 3 >>> 0] = e.screenY;
            HEAP32[idx + 4 >>> 0] = e.clientX;
            HEAP32[idx + 5 >>> 0] = e.clientY;
            HEAP32[idx + 6 >>> 0] = e.ctrlKey;
            HEAP32[idx + 7 >>> 0] = e.shiftKey;
            HEAP32[idx + 8 >>> 0] = e.altKey;
            HEAP32[idx + 9 >>> 0] = e.metaKey;
            HEAP16[idx * 2 + 20 >>> 0] = e.button;
            HEAP16[idx * 2 + 21 >>> 0] = e.buttons;
            HEAP32[idx + 11 >>> 0] = e["movementX"];
            HEAP32[idx + 12 >>> 0] = e["movementY"];
            var rect = getBoundingClientRect(target);
            HEAP32[idx + 13 >>> 0] = e.clientX - rect.left;
            HEAP32[idx + 14 >>> 0] = e.clientY - rect.top;
          };
          var registerMouseEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
            if (!JSEvents.mouseEvent)
              JSEvents.mouseEvent = _malloc(72);
            target = findEventTarget(target);
            var mouseEventHandlerFunc = (e = event) => {
              fillMouseEventData(JSEvents.mouseEvent, e, target);
              if (getWasmTableEntry(callbackfunc)(eventTypeId, JSEvents.mouseEvent, userData))
                e.preventDefault();
            };
            var eventHandler = {
              target,
              allowsDeferredCalls: eventTypeString != "mousemove" && eventTypeString != "mouseenter" && eventTypeString != "mouseleave",
              eventTypeString,
              callbackfunc,
              handlerFunc: mouseEventHandlerFunc,
              useCapture
            };
            return JSEvents.registerOrRemoveHandler(eventHandler);
          };
          function _emscripten_set_click_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
            target >>>= 0;
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            return registerMouseEventCallback(target, userData, useCapture, callbackfunc, 4, "click", targetThread);
          }
          _emscripten_set_click_callback_on_thread.sig = "ippipp";
          function _emscripten_set_mousedown_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
            target >>>= 0;
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            return registerMouseEventCallback(target, userData, useCapture, callbackfunc, 5, "mousedown", targetThread);
          }
          _emscripten_set_mousedown_callback_on_thread.sig = "ippipp";
          function _emscripten_set_mouseup_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
            target >>>= 0;
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            return registerMouseEventCallback(target, userData, useCapture, callbackfunc, 6, "mouseup", targetThread);
          }
          _emscripten_set_mouseup_callback_on_thread.sig = "ippipp";
          function _emscripten_set_dblclick_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
            target >>>= 0;
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            return registerMouseEventCallback(target, userData, useCapture, callbackfunc, 7, "dblclick", targetThread);
          }
          _emscripten_set_dblclick_callback_on_thread.sig = "ippipp";
          function _emscripten_set_mousemove_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
            target >>>= 0;
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            return registerMouseEventCallback(target, userData, useCapture, callbackfunc, 8, "mousemove", targetThread);
          }
          _emscripten_set_mousemove_callback_on_thread.sig = "ippipp";
          function _emscripten_set_mouseenter_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
            target >>>= 0;
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            return registerMouseEventCallback(target, userData, useCapture, callbackfunc, 33, "mouseenter", targetThread);
          }
          _emscripten_set_mouseenter_callback_on_thread.sig = "ippipp";
          function _emscripten_set_mouseleave_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
            target >>>= 0;
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            return registerMouseEventCallback(target, userData, useCapture, callbackfunc, 34, "mouseleave", targetThread);
          }
          _emscripten_set_mouseleave_callback_on_thread.sig = "ippipp";
          function _emscripten_set_mouseover_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
            target >>>= 0;
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            return registerMouseEventCallback(target, userData, useCapture, callbackfunc, 35, "mouseover", targetThread);
          }
          _emscripten_set_mouseover_callback_on_thread.sig = "ippipp";
          function _emscripten_set_mouseout_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
            target >>>= 0;
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            return registerMouseEventCallback(target, userData, useCapture, callbackfunc, 36, "mouseout", targetThread);
          }
          _emscripten_set_mouseout_callback_on_thread.sig = "ippipp";
          function _emscripten_get_mouse_status(mouseState) {
            mouseState >>>= 0;
            if (!JSEvents.mouseEvent)
              return -7;
            HEAP8.set(HEAP8.subarray(JSEvents.mouseEvent >>> 0, JSEvents.mouseEvent + 72 >>> 0), mouseState >>> 0);
            return 0;
          }
          _emscripten_get_mouse_status.sig = "ip";
          var registerWheelEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
            if (!JSEvents.wheelEvent)
              JSEvents.wheelEvent = _malloc(104);
            var wheelHandlerFunc = (e = event) => {
              var wheelEvent = JSEvents.wheelEvent;
              fillMouseEventData(wheelEvent, e, target);
              HEAPF64[wheelEvent + 72 >>> 3 >>> 0] = e["deltaX"];
              HEAPF64[wheelEvent + 80 >>> 3 >>> 0] = e["deltaY"];
              HEAPF64[wheelEvent + 88 >>> 3 >>> 0] = e["deltaZ"];
              HEAP32[wheelEvent + 96 >>> 2 >>> 0] = e["deltaMode"];
              if (getWasmTableEntry(callbackfunc)(eventTypeId, wheelEvent, userData))
                e.preventDefault();
            };
            var eventHandler = {
              target,
              allowsDeferredCalls: true,
              eventTypeString,
              callbackfunc,
              handlerFunc: wheelHandlerFunc,
              useCapture
            };
            return JSEvents.registerOrRemoveHandler(eventHandler);
          };
          function _emscripten_set_wheel_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
            target >>>= 0;
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            target = findEventTarget(target);
            if (!target)
              return -4;
            if (typeof target.onwheel != "undefined") {
              return registerWheelEventCallback(target, userData, useCapture, callbackfunc, 9, "wheel", targetThread);
            } else {
              return -1;
            }
          }
          _emscripten_set_wheel_callback_on_thread.sig = "ippipp";
          var registerUiEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
            if (!JSEvents.uiEvent)
              JSEvents.uiEvent = _malloc(36);
            target = findEventTarget(target);
            var uiEventHandlerFunc = (e = event) => {
              if (e.target != target) {
                return;
              }
              var b = document.body;
              if (!b) {
                return;
              }
              var uiEvent = JSEvents.uiEvent;
              HEAP32[uiEvent >>> 2 >>> 0] = e.detail;
              HEAP32[uiEvent + 4 >>> 2 >>> 0] = b.clientWidth;
              HEAP32[uiEvent + 8 >>> 2 >>> 0] = b.clientHeight;
              HEAP32[uiEvent + 12 >>> 2 >>> 0] = innerWidth;
              HEAP32[uiEvent + 16 >>> 2 >>> 0] = innerHeight;
              HEAP32[uiEvent + 20 >>> 2 >>> 0] = outerWidth;
              HEAP32[uiEvent + 24 >>> 2 >>> 0] = outerHeight;
              HEAP32[uiEvent + 28 >>> 2 >>> 0] = pageXOffset;
              HEAP32[uiEvent + 32 >>> 2 >>> 0] = pageYOffset;
              if (getWasmTableEntry(callbackfunc)(eventTypeId, uiEvent, userData))
                e.preventDefault();
            };
            var eventHandler = {
              target,
              eventTypeString,
              callbackfunc,
              handlerFunc: uiEventHandlerFunc,
              useCapture
            };
            return JSEvents.registerOrRemoveHandler(eventHandler);
          };
          function _emscripten_set_resize_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
            target >>>= 0;
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            return registerUiEventCallback(target, userData, useCapture, callbackfunc, 10, "resize", targetThread);
          }
          _emscripten_set_resize_callback_on_thread.sig = "ippipp";
          function _emscripten_set_scroll_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
            target >>>= 0;
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            return registerUiEventCallback(target, userData, useCapture, callbackfunc, 11, "scroll", targetThread);
          }
          _emscripten_set_scroll_callback_on_thread.sig = "ippipp";
          var registerFocusEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
            if (!JSEvents.focusEvent)
              JSEvents.focusEvent = _malloc(256);
            var focusEventHandlerFunc = (e = event) => {
              var nodeName = JSEvents.getNodeNameForTarget(e.target);
              var id = e.target.id ? e.target.id : "";
              var focusEvent = JSEvents.focusEvent;
              stringToUTF8(nodeName, focusEvent + 0, 128);
              stringToUTF8(id, focusEvent + 128, 128);
              if (getWasmTableEntry(callbackfunc)(eventTypeId, focusEvent, userData))
                e.preventDefault();
            };
            var eventHandler = {
              target: findEventTarget(target),
              eventTypeString,
              callbackfunc,
              handlerFunc: focusEventHandlerFunc,
              useCapture
            };
            return JSEvents.registerOrRemoveHandler(eventHandler);
          };
          function _emscripten_set_blur_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
            target >>>= 0;
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            return registerFocusEventCallback(target, userData, useCapture, callbackfunc, 12, "blur", targetThread);
          }
          _emscripten_set_blur_callback_on_thread.sig = "ippipp";
          function _emscripten_set_focus_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
            target >>>= 0;
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            return registerFocusEventCallback(target, userData, useCapture, callbackfunc, 13, "focus", targetThread);
          }
          _emscripten_set_focus_callback_on_thread.sig = "ippipp";
          function _emscripten_set_focusin_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
            target >>>= 0;
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            return registerFocusEventCallback(target, userData, useCapture, callbackfunc, 14, "focusin", targetThread);
          }
          _emscripten_set_focusin_callback_on_thread.sig = "ippipp";
          function _emscripten_set_focusout_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
            target >>>= 0;
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            return registerFocusEventCallback(target, userData, useCapture, callbackfunc, 15, "focusout", targetThread);
          }
          _emscripten_set_focusout_callback_on_thread.sig = "ippipp";
          var fillDeviceOrientationEventData = (eventStruct, e, target) => {
            HEAPF64[eventStruct >>> 3 >>> 0] = e.alpha;
            HEAPF64[eventStruct + 8 >>> 3 >>> 0] = e.beta;
            HEAPF64[eventStruct + 16 >>> 3 >>> 0] = e.gamma;
            HEAP32[eventStruct + 24 >>> 2 >>> 0] = e.absolute;
          };
          var registerDeviceOrientationEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
            if (!JSEvents.deviceOrientationEvent)
              JSEvents.deviceOrientationEvent = _malloc(32);
            var deviceOrientationEventHandlerFunc = (e = event) => {
              fillDeviceOrientationEventData(JSEvents.deviceOrientationEvent, e, target);
              if (getWasmTableEntry(callbackfunc)(eventTypeId, JSEvents.deviceOrientationEvent, userData))
                e.preventDefault();
            };
            var eventHandler = {
              target: findEventTarget(target),
              eventTypeString,
              callbackfunc,
              handlerFunc: deviceOrientationEventHandlerFunc,
              useCapture
            };
            return JSEvents.registerOrRemoveHandler(eventHandler);
          };
          function _emscripten_set_deviceorientation_callback_on_thread(userData, useCapture, callbackfunc, targetThread) {
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            return registerDeviceOrientationEventCallback(2, userData, useCapture, callbackfunc, 16, "deviceorientation", targetThread);
          }
          _emscripten_set_deviceorientation_callback_on_thread.sig = "ipipp";
          function _emscripten_get_deviceorientation_status(orientationState) {
            orientationState >>>= 0;
            if (!JSEvents.deviceOrientationEvent)
              return -7;
            HEAP32.set(HEAP32.subarray(JSEvents.deviceOrientationEvent >>> 0, 32 >>> 0), orientationState >>> 0);
            return 0;
          }
          _emscripten_get_deviceorientation_status.sig = "ip";
          var fillDeviceMotionEventData = (eventStruct, e, target) => {
            var supportedFields = 0;
            var a = e["acceleration"];
            supportedFields |= a && 1;
            var ag = e["accelerationIncludingGravity"];
            supportedFields |= ag && 2;
            var rr = e["rotationRate"];
            supportedFields |= rr && 4;
            a = a || {};
            ag = ag || {};
            rr = rr || {};
            HEAPF64[eventStruct >>> 3 >>> 0] = a["x"];
            HEAPF64[eventStruct + 8 >>> 3 >>> 0] = a["y"];
            HEAPF64[eventStruct + 16 >>> 3 >>> 0] = a["z"];
            HEAPF64[eventStruct + 24 >>> 3 >>> 0] = ag["x"];
            HEAPF64[eventStruct + 32 >>> 3 >>> 0] = ag["y"];
            HEAPF64[eventStruct + 40 >>> 3 >>> 0] = ag["z"];
            HEAPF64[eventStruct + 48 >>> 3 >>> 0] = rr["alpha"];
            HEAPF64[eventStruct + 56 >>> 3 >>> 0] = rr["beta"];
            HEAPF64[eventStruct + 64 >>> 3 >>> 0] = rr["gamma"];
          };
          var registerDeviceMotionEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
            if (!JSEvents.deviceMotionEvent)
              JSEvents.deviceMotionEvent = _malloc(80);
            var deviceMotionEventHandlerFunc = (e = event) => {
              fillDeviceMotionEventData(JSEvents.deviceMotionEvent, e, target);
              if (getWasmTableEntry(callbackfunc)(eventTypeId, JSEvents.deviceMotionEvent, userData))
                e.preventDefault();
            };
            var eventHandler = {
              target: findEventTarget(target),
              eventTypeString,
              callbackfunc,
              handlerFunc: deviceMotionEventHandlerFunc,
              useCapture
            };
            return JSEvents.registerOrRemoveHandler(eventHandler);
          };
          function _emscripten_set_devicemotion_callback_on_thread(userData, useCapture, callbackfunc, targetThread) {
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            return registerDeviceMotionEventCallback(2, userData, useCapture, callbackfunc, 17, "devicemotion", targetThread);
          }
          _emscripten_set_devicemotion_callback_on_thread.sig = "ipipp";
          function _emscripten_get_devicemotion_status(motionState) {
            motionState >>>= 0;
            if (!JSEvents.deviceMotionEvent)
              return -7;
            HEAP32.set(HEAP32.subarray(JSEvents.deviceMotionEvent >>> 0, 80 >>> 0), motionState >>> 0);
            return 0;
          }
          _emscripten_get_devicemotion_status.sig = "ip";
          var screenOrientation = () => {
            if (!screen)
              return void 0;
            return screen.orientation || screen.mozOrientation || screen.webkitOrientation || screen.msOrientation;
          };
          var fillOrientationChangeEventData = (eventStruct) => {
            var orientations = ["portrait-primary", "portrait-secondary", "landscape-primary", "landscape-secondary"];
            var orientations2 = ["portrait", "portrait", "landscape", "landscape"];
            var orientationString = screenOrientation();
            var orientation2 = orientations.indexOf(orientationString);
            if (orientation2 == -1) {
              orientation2 = orientations2.indexOf(orientationString);
            }
            HEAP32[eventStruct >>> 2 >>> 0] = 1 << orientation2;
            HEAP32[eventStruct + 4 >>> 2 >>> 0] = orientation2;
          };
          var registerOrientationChangeEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
            if (!JSEvents.orientationChangeEvent)
              JSEvents.orientationChangeEvent = _malloc(8);
            var orientationChangeEventHandlerFunc = (e = event) => {
              var orientationChangeEvent = JSEvents.orientationChangeEvent;
              fillOrientationChangeEventData(orientationChangeEvent);
              if (getWasmTableEntry(callbackfunc)(eventTypeId, orientationChangeEvent, userData))
                e.preventDefault();
            };
            if (eventTypeId == 18 && screen.mozOrientation !== void 0) {
              eventTypeString = "mozorientationchange";
            }
            var eventHandler = {
              target,
              eventTypeString,
              callbackfunc,
              handlerFunc: orientationChangeEventHandlerFunc,
              useCapture
            };
            return JSEvents.registerOrRemoveHandler(eventHandler);
          };
          function _emscripten_set_orientationchange_callback_on_thread(userData, useCapture, callbackfunc, targetThread) {
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            if (!screen || !screen["addEventListener"])
              return -1;
            return registerOrientationChangeEventCallback(screen, userData, useCapture, callbackfunc, 18, "orientationchange", targetThread);
          }
          _emscripten_set_orientationchange_callback_on_thread.sig = "ipipp";
          function _emscripten_get_orientation_status(orientationChangeEvent) {
            orientationChangeEvent >>>= 0;
            if (!screenOrientation() && typeof orientation == "undefined")
              return -1;
            fillOrientationChangeEventData(orientationChangeEvent);
            return 0;
          }
          _emscripten_get_orientation_status.sig = "ip";
          var _emscripten_lock_orientation = (allowedOrientations) => {
            var orientations = [];
            if (allowedOrientations & 1)
              orientations.push("portrait-primary");
            if (allowedOrientations & 2)
              orientations.push("portrait-secondary");
            if (allowedOrientations & 4)
              orientations.push("landscape-primary");
            if (allowedOrientations & 8)
              orientations.push("landscape-secondary");
            var succeeded;
            if (screen.lockOrientation) {
              succeeded = screen.lockOrientation(orientations);
            } else if (screen.mozLockOrientation) {
              succeeded = screen.mozLockOrientation(orientations);
            } else if (screen.webkitLockOrientation) {
              succeeded = screen.webkitLockOrientation(orientations);
            } else if (screen.msLockOrientation) {
              succeeded = screen.msLockOrientation(orientations);
            } else {
              return -1;
            }
            if (succeeded) {
              return 0;
            }
            return -6;
          };
          _emscripten_lock_orientation.sig = "ii";
          var _emscripten_unlock_orientation = () => {
            if (screen.unlockOrientation) {
              screen.unlockOrientation();
            } else if (screen.mozUnlockOrientation) {
              screen.mozUnlockOrientation();
            } else if (screen.webkitUnlockOrientation) {
              screen.webkitUnlockOrientation();
            } else if (screen.msUnlockOrientation) {
              screen.msUnlockOrientation();
            } else {
              return -1;
            }
            return 0;
          };
          _emscripten_unlock_orientation.sig = "i";
          var fillFullscreenChangeEventData = (eventStruct) => {
            var fullscreenElement = document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement;
            var isFullscreen = !!fullscreenElement;
            HEAP32[eventStruct >>> 2 >>> 0] = isFullscreen;
            HEAP32[eventStruct + 4 >>> 2 >>> 0] = JSEvents.fullscreenEnabled();
            var reportedElement = isFullscreen ? fullscreenElement : JSEvents.previousFullscreenElement;
            var nodeName = JSEvents.getNodeNameForTarget(reportedElement);
            var id = reportedElement?.id || "";
            stringToUTF8(nodeName, eventStruct + 8, 128);
            stringToUTF8(id, eventStruct + 136, 128);
            HEAP32[eventStruct + 264 >>> 2 >>> 0] = reportedElement ? reportedElement.clientWidth : 0;
            HEAP32[eventStruct + 268 >>> 2 >>> 0] = reportedElement ? reportedElement.clientHeight : 0;
            HEAP32[eventStruct + 272 >>> 2 >>> 0] = screen.width;
            HEAP32[eventStruct + 276 >>> 2 >>> 0] = screen.height;
            if (isFullscreen) {
              JSEvents.previousFullscreenElement = fullscreenElement;
            }
          };
          var registerFullscreenChangeEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
            if (!JSEvents.fullscreenChangeEvent)
              JSEvents.fullscreenChangeEvent = _malloc(280);
            var fullscreenChangeEventhandlerFunc = (e = event) => {
              var fullscreenChangeEvent = JSEvents.fullscreenChangeEvent;
              fillFullscreenChangeEventData(fullscreenChangeEvent);
              if (getWasmTableEntry(callbackfunc)(eventTypeId, fullscreenChangeEvent, userData))
                e.preventDefault();
            };
            var eventHandler = {
              target,
              eventTypeString,
              callbackfunc,
              handlerFunc: fullscreenChangeEventhandlerFunc,
              useCapture
            };
            return JSEvents.registerOrRemoveHandler(eventHandler);
          };
          function _emscripten_set_fullscreenchange_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
            target >>>= 0;
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            if (!JSEvents.fullscreenEnabled())
              return -1;
            target = findEventTarget(target);
            if (!target)
              return -4;
            registerFullscreenChangeEventCallback(target, userData, useCapture, callbackfunc, 19, "webkitfullscreenchange", targetThread);
            return registerFullscreenChangeEventCallback(target, userData, useCapture, callbackfunc, 19, "fullscreenchange", targetThread);
          }
          _emscripten_set_fullscreenchange_callback_on_thread.sig = "ippipp";
          function _emscripten_get_fullscreen_status(fullscreenStatus) {
            fullscreenStatus >>>= 0;
            if (!JSEvents.fullscreenEnabled())
              return -1;
            fillFullscreenChangeEventData(fullscreenStatus);
            return 0;
          }
          _emscripten_get_fullscreen_status.sig = "ip";
          function _emscripten_get_canvas_element_size(target, width, height) {
            target >>>= 0;
            width >>>= 0;
            height >>>= 0;
            var canvas = findCanvasEventTarget(target);
            if (!canvas)
              return -4;
            HEAP32[width >>> 2 >>> 0] = canvas.width;
            HEAP32[height >>> 2 >>> 0] = canvas.height;
          }
          _emscripten_get_canvas_element_size.sig = "ippp";
          var getCanvasElementSize = (target) => withStackSave(() => {
            var w = stackAlloc(8);
            var h = w + 4;
            var targetInt = stringToUTF8OnStack(target.id);
            var ret = _emscripten_get_canvas_element_size(targetInt, w, h);
            var size = [HEAP32[w >>> 2 >>> 0], HEAP32[h >>> 2 >>> 0]];
            return size;
          });
          function _emscripten_set_canvas_element_size(target, width, height) {
            target >>>= 0;
            var canvas = findCanvasEventTarget(target);
            if (!canvas)
              return -4;
            canvas.width = width;
            canvas.height = height;
            return 0;
          }
          _emscripten_set_canvas_element_size.sig = "ipii";
          var setCanvasElementSize = (target, width, height) => {
            if (!target.controlTransferredOffscreen) {
              target.width = width;
              target.height = height;
            } else {
              withStackSave(() => {
                var targetInt = stringToUTF8OnStack(target.id);
                _emscripten_set_canvas_element_size(targetInt, width, height);
              });
            }
          };
          var registerRestoreOldStyle = (canvas) => {
            var canvasSize = getCanvasElementSize(canvas);
            var oldWidth = canvasSize[0];
            var oldHeight = canvasSize[1];
            var oldCssWidth = canvas.style.width;
            var oldCssHeight = canvas.style.height;
            var oldBackgroundColor = canvas.style.backgroundColor;
            var oldDocumentBackgroundColor = document.body.style.backgroundColor;
            var oldPaddingLeft = canvas.style.paddingLeft;
            var oldPaddingRight = canvas.style.paddingRight;
            var oldPaddingTop = canvas.style.paddingTop;
            var oldPaddingBottom = canvas.style.paddingBottom;
            var oldMarginLeft = canvas.style.marginLeft;
            var oldMarginRight = canvas.style.marginRight;
            var oldMarginTop = canvas.style.marginTop;
            var oldMarginBottom = canvas.style.marginBottom;
            var oldDocumentBodyMargin = document.body.style.margin;
            var oldDocumentOverflow = document.documentElement.style.overflow;
            var oldDocumentScroll = document.body.scroll;
            var oldImageRendering = canvas.style.imageRendering;
            function restoreOldStyle() {
              var fullscreenElement = document.fullscreenElement || document.webkitFullscreenElement;
              if (!fullscreenElement) {
                document.removeEventListener("fullscreenchange", restoreOldStyle);
                document.removeEventListener("webkitfullscreenchange", restoreOldStyle);
                setCanvasElementSize(canvas, oldWidth, oldHeight);
                canvas.style.width = oldCssWidth;
                canvas.style.height = oldCssHeight;
                canvas.style.backgroundColor = oldBackgroundColor;
                if (!oldDocumentBackgroundColor)
                  document.body.style.backgroundColor = "white";
                document.body.style.backgroundColor = oldDocumentBackgroundColor;
                canvas.style.paddingLeft = oldPaddingLeft;
                canvas.style.paddingRight = oldPaddingRight;
                canvas.style.paddingTop = oldPaddingTop;
                canvas.style.paddingBottom = oldPaddingBottom;
                canvas.style.marginLeft = oldMarginLeft;
                canvas.style.marginRight = oldMarginRight;
                canvas.style.marginTop = oldMarginTop;
                canvas.style.marginBottom = oldMarginBottom;
                document.body.style.margin = oldDocumentBodyMargin;
                document.documentElement.style.overflow = oldDocumentOverflow;
                document.body.scroll = oldDocumentScroll;
                canvas.style.imageRendering = oldImageRendering;
                if (canvas.GLctxObject)
                  canvas.GLctxObject.GLctx.viewport(0, 0, oldWidth, oldHeight);
                if (currentFullscreenStrategy.canvasResizedCallback) {
                  getWasmTableEntry(currentFullscreenStrategy.canvasResizedCallback)(37, 0, currentFullscreenStrategy.canvasResizedCallbackUserData);
                }
              }
            }
            document.addEventListener("fullscreenchange", restoreOldStyle);
            document.addEventListener("webkitfullscreenchange", restoreOldStyle);
            return restoreOldStyle;
          };
          var setLetterbox = (element, topBottom, leftRight) => {
            element.style.paddingLeft = element.style.paddingRight = leftRight + "px";
            element.style.paddingTop = element.style.paddingBottom = topBottom + "px";
          };
          var JSEvents_resizeCanvasForFullscreen = (target, strategy) => {
            var restoreOldStyle = registerRestoreOldStyle(target);
            var cssWidth = strategy.softFullscreen ? innerWidth : screen.width;
            var cssHeight = strategy.softFullscreen ? innerHeight : screen.height;
            var rect = getBoundingClientRect(target);
            var windowedCssWidth = rect.width;
            var windowedCssHeight = rect.height;
            var canvasSize = getCanvasElementSize(target);
            var windowedRttWidth = canvasSize[0];
            var windowedRttHeight = canvasSize[1];
            if (strategy.scaleMode == 3) {
              setLetterbox(target, (cssHeight - windowedCssHeight) / 2, (cssWidth - windowedCssWidth) / 2);
              cssWidth = windowedCssWidth;
              cssHeight = windowedCssHeight;
            } else if (strategy.scaleMode == 2) {
              if (cssWidth * windowedRttHeight < windowedRttWidth * cssHeight) {
                var desiredCssHeight = windowedRttHeight * cssWidth / windowedRttWidth;
                setLetterbox(target, (cssHeight - desiredCssHeight) / 2, 0);
                cssHeight = desiredCssHeight;
              } else {
                var desiredCssWidth = windowedRttWidth * cssHeight / windowedRttHeight;
                setLetterbox(target, 0, (cssWidth - desiredCssWidth) / 2);
                cssWidth = desiredCssWidth;
              }
            }
            if (!target.style.backgroundColor)
              target.style.backgroundColor = "black";
            if (!document.body.style.backgroundColor)
              document.body.style.backgroundColor = "black";
            target.style.width = cssWidth + "px";
            target.style.height = cssHeight + "px";
            if (strategy.filteringMode == 1) {
              target.style.imageRendering = "optimizeSpeed";
              target.style.imageRendering = "-moz-crisp-edges";
              target.style.imageRendering = "-o-crisp-edges";
              target.style.imageRendering = "-webkit-optimize-contrast";
              target.style.imageRendering = "optimize-contrast";
              target.style.imageRendering = "crisp-edges";
              target.style.imageRendering = "pixelated";
            }
            var dpiScale = strategy.canvasResolutionScaleMode == 2 ? devicePixelRatio : 1;
            if (strategy.canvasResolutionScaleMode != 0) {
              var newWidth = cssWidth * dpiScale | 0;
              var newHeight = cssHeight * dpiScale | 0;
              setCanvasElementSize(target, newWidth, newHeight);
              if (target.GLctxObject)
                target.GLctxObject.GLctx.viewport(0, 0, newWidth, newHeight);
            }
            return restoreOldStyle;
          };
          var JSEvents_requestFullscreen = (target, strategy) => {
            if (strategy.scaleMode != 0 || strategy.canvasResolutionScaleMode != 0) {
              JSEvents_resizeCanvasForFullscreen(target, strategy);
            }
            if (target.requestFullscreen) {
              target.requestFullscreen();
            } else if (target.webkitRequestFullscreen) {
              target.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
            } else {
              return JSEvents.fullscreenEnabled() ? -3 : -1;
            }
            currentFullscreenStrategy = strategy;
            if (strategy.canvasResizedCallback) {
              getWasmTableEntry(strategy.canvasResizedCallback)(37, 0, strategy.canvasResizedCallbackUserData);
            }
            return 0;
          };
          var hideEverythingExceptGivenElement = (onlyVisibleElement) => {
            var child = onlyVisibleElement;
            var parent = child.parentNode;
            var hiddenElements = [];
            while (child != document.body) {
              var children = parent.children;
              for (var i2 = 0; i2 < children.length; ++i2) {
                if (children[i2] != child) {
                  hiddenElements.push({
                    node: children[i2],
                    displayState: children[i2].style.display
                  });
                  children[i2].style.display = "none";
                }
              }
              child = parent;
              parent = parent.parentNode;
            }
            return hiddenElements;
          };
          var restoreHiddenElements = (hiddenElements) => {
            for (var i2 = 0; i2 < hiddenElements.length; ++i2) {
              hiddenElements[i2].node.style.display = hiddenElements[i2].displayState;
            }
          };
          var currentFullscreenStrategy = {};
          var restoreOldWindowedStyle = null;
          var softFullscreenResizeWebGLRenderTarget = () => {
            var dpr = devicePixelRatio;
            var inHiDPIFullscreenMode = currentFullscreenStrategy.canvasResolutionScaleMode == 2;
            var inAspectRatioFixedFullscreenMode = currentFullscreenStrategy.scaleMode == 2;
            var inPixelPerfectFullscreenMode = currentFullscreenStrategy.canvasResolutionScaleMode != 0;
            var inCenteredWithoutScalingFullscreenMode = currentFullscreenStrategy.scaleMode == 3;
            var screenWidth = inHiDPIFullscreenMode ? Math.round(innerWidth * dpr) : innerWidth;
            var screenHeight = inHiDPIFullscreenMode ? Math.round(innerHeight * dpr) : innerHeight;
            var w = screenWidth;
            var h = screenHeight;
            var canvas = currentFullscreenStrategy.target;
            var canvasSize = getCanvasElementSize(canvas);
            var x = canvasSize[0];
            var y = canvasSize[1];
            var topMargin;
            if (inAspectRatioFixedFullscreenMode) {
              if (w * y < x * h)
                h = w * y / x | 0;
              else if (w * y > x * h)
                w = h * x / y | 0;
              topMargin = (screenHeight - h) / 2 | 0;
            }
            if (inPixelPerfectFullscreenMode) {
              setCanvasElementSize(canvas, w, h);
              if (canvas.GLctxObject)
                canvas.GLctxObject.GLctx.viewport(0, 0, w, h);
            }
            if (inHiDPIFullscreenMode) {
              topMargin /= dpr;
              w /= dpr;
              h /= dpr;
              w = Math.round(w * 1e4) / 1e4;
              h = Math.round(h * 1e4) / 1e4;
              topMargin = Math.round(topMargin * 1e4) / 1e4;
            }
            if (inCenteredWithoutScalingFullscreenMode) {
              var t = (innerHeight - jstoi_q(canvas.style.height)) / 2;
              var b = (innerWidth - jstoi_q(canvas.style.width)) / 2;
              setLetterbox(canvas, t, b);
            } else {
              canvas.style.width = w + "px";
              canvas.style.height = h + "px";
              var b = (innerWidth - w) / 2;
              setLetterbox(canvas, topMargin, b);
            }
            if (!inCenteredWithoutScalingFullscreenMode && currentFullscreenStrategy.canvasResizedCallback) {
              getWasmTableEntry(currentFullscreenStrategy.canvasResizedCallback)(37, 0, currentFullscreenStrategy.canvasResizedCallbackUserData);
            }
          };
          var doRequestFullscreen = (target, strategy) => {
            if (!JSEvents.fullscreenEnabled())
              return -1;
            target = findEventTarget(target);
            if (!target)
              return -4;
            if (!target.requestFullscreen && !target.webkitRequestFullscreen) {
              return -3;
            }
            var canPerformRequests = JSEvents.canPerformEventHandlerRequests();
            if (!canPerformRequests) {
              if (strategy.deferUntilInEventHandler) {
                JSEvents.deferCall(JSEvents_requestFullscreen, 1, [target, strategy]);
                return 1;
              }
              return -2;
            }
            return JSEvents_requestFullscreen(target, strategy);
          };
          function _emscripten_request_fullscreen(target, deferUntilInEventHandler) {
            target >>>= 0;
            var strategy = {
              scaleMode: 0,
              canvasResolutionScaleMode: 0,
              filteringMode: 0,
              deferUntilInEventHandler,
              canvasResizedCallbackTargetThread: 2
            };
            return doRequestFullscreen(target, strategy);
          }
          _emscripten_request_fullscreen.sig = "ipi";
          function _emscripten_request_fullscreen_strategy(target, deferUntilInEventHandler, fullscreenStrategy) {
            target >>>= 0;
            fullscreenStrategy >>>= 0;
            var strategy = {
              scaleMode: HEAP32[fullscreenStrategy >>> 2 >>> 0],
              canvasResolutionScaleMode: HEAP32[fullscreenStrategy + 4 >>> 2 >>> 0],
              filteringMode: HEAP32[fullscreenStrategy + 8 >>> 2 >>> 0],
              deferUntilInEventHandler,
              canvasResizedCallback: HEAP32[fullscreenStrategy + 12 >>> 2 >>> 0],
              canvasResizedCallbackUserData: HEAP32[fullscreenStrategy + 16 >>> 2 >>> 0]
            };
            return doRequestFullscreen(target, strategy);
          }
          _emscripten_request_fullscreen_strategy.sig = "ipip";
          function _emscripten_enter_soft_fullscreen(target, fullscreenStrategy) {
            target >>>= 0;
            fullscreenStrategy >>>= 0;
            target = findEventTarget(target);
            if (!target)
              return -4;
            var strategy = {
              scaleMode: HEAP32[fullscreenStrategy >>> 2 >>> 0],
              canvasResolutionScaleMode: HEAP32[fullscreenStrategy + 4 >>> 2 >>> 0],
              filteringMode: HEAP32[fullscreenStrategy + 8 >>> 2 >>> 0],
              canvasResizedCallback: HEAP32[fullscreenStrategy + 12 >>> 2 >>> 0],
              canvasResizedCallbackUserData: HEAP32[fullscreenStrategy + 16 >>> 2 >>> 0],
              target,
              softFullscreen: true
            };
            var restoreOldStyle = JSEvents_resizeCanvasForFullscreen(target, strategy);
            document.documentElement.style.overflow = "hidden";
            document.body.scroll = "no";
            document.body.style.margin = "0px";
            var hiddenElements = hideEverythingExceptGivenElement(target);
            function restoreWindowedState() {
              restoreOldStyle();
              restoreHiddenElements(hiddenElements);
              removeEventListener("resize", softFullscreenResizeWebGLRenderTarget);
              if (strategy.canvasResizedCallback) {
                getWasmTableEntry(strategy.canvasResizedCallback)(37, 0, strategy.canvasResizedCallbackUserData);
              }
              currentFullscreenStrategy = 0;
            }
            restoreOldWindowedStyle = restoreWindowedState;
            currentFullscreenStrategy = strategy;
            addEventListener("resize", softFullscreenResizeWebGLRenderTarget);
            if (strategy.canvasResizedCallback) {
              getWasmTableEntry(strategy.canvasResizedCallback)(37, 0, strategy.canvasResizedCallbackUserData);
            }
            return 0;
          }
          _emscripten_enter_soft_fullscreen.sig = "ipp";
          var _emscripten_exit_soft_fullscreen = () => {
            restoreOldWindowedStyle?.();
            restoreOldWindowedStyle = null;
            return 0;
          };
          _emscripten_exit_soft_fullscreen.sig = "i";
          var _emscripten_exit_fullscreen = () => {
            if (!JSEvents.fullscreenEnabled())
              return -1;
            JSEvents.removeDeferredCalls(JSEvents_requestFullscreen);
            var d = specialHTMLTargets[1];
            if (d.exitFullscreen) {
              d.fullscreenElement && d.exitFullscreen();
            } else if (d.webkitExitFullscreen) {
              d.webkitFullscreenElement && d.webkitExitFullscreen();
            } else {
              return -1;
            }
            return 0;
          };
          _emscripten_exit_fullscreen.sig = "i";
          var fillPointerlockChangeEventData = (eventStruct) => {
            var pointerLockElement = document.pointerLockElement || document.mozPointerLockElement || document.webkitPointerLockElement || document.msPointerLockElement;
            var isPointerlocked = !!pointerLockElement;
            HEAP32[eventStruct >>> 2 >>> 0] = isPointerlocked;
            var nodeName = JSEvents.getNodeNameForTarget(pointerLockElement);
            var id = pointerLockElement?.id || "";
            stringToUTF8(nodeName, eventStruct + 4, 128);
            stringToUTF8(id, eventStruct + 132, 128);
          };
          var registerPointerlockChangeEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
            if (!JSEvents.pointerlockChangeEvent)
              JSEvents.pointerlockChangeEvent = _malloc(260);
            var pointerlockChangeEventHandlerFunc = (e = event) => {
              var pointerlockChangeEvent = JSEvents.pointerlockChangeEvent;
              fillPointerlockChangeEventData(pointerlockChangeEvent);
              if (getWasmTableEntry(callbackfunc)(eventTypeId, pointerlockChangeEvent, userData))
                e.preventDefault();
            };
            var eventHandler = {
              target,
              eventTypeString,
              callbackfunc,
              handlerFunc: pointerlockChangeEventHandlerFunc,
              useCapture
            };
            return JSEvents.registerOrRemoveHandler(eventHandler);
          };
          function _emscripten_set_pointerlockchange_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
            target >>>= 0;
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            if (!document || !document.body || !document.body.requestPointerLock && !document.body.mozRequestPointerLock && !document.body.webkitRequestPointerLock && !document.body.msRequestPointerLock) {
              return -1;
            }
            target = findEventTarget(target);
            if (!target)
              return -4;
            registerPointerlockChangeEventCallback(target, userData, useCapture, callbackfunc, 20, "mozpointerlockchange", targetThread);
            registerPointerlockChangeEventCallback(target, userData, useCapture, callbackfunc, 20, "webkitpointerlockchange", targetThread);
            registerPointerlockChangeEventCallback(target, userData, useCapture, callbackfunc, 20, "mspointerlockchange", targetThread);
            return registerPointerlockChangeEventCallback(target, userData, useCapture, callbackfunc, 20, "pointerlockchange", targetThread);
          }
          _emscripten_set_pointerlockchange_callback_on_thread.sig = "ippipp";
          var registerPointerlockErrorEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
            var pointerlockErrorEventHandlerFunc = (e = event) => {
              if (getWasmTableEntry(callbackfunc)(eventTypeId, 0, userData))
                e.preventDefault();
            };
            var eventHandler = {
              target,
              eventTypeString,
              callbackfunc,
              handlerFunc: pointerlockErrorEventHandlerFunc,
              useCapture
            };
            return JSEvents.registerOrRemoveHandler(eventHandler);
          };
          function _emscripten_set_pointerlockerror_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
            target >>>= 0;
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            if (!document || !document.body.requestPointerLock && !document.body.mozRequestPointerLock && !document.body.webkitRequestPointerLock && !document.body.msRequestPointerLock) {
              return -1;
            }
            target = findEventTarget(target);
            if (!target)
              return -4;
            registerPointerlockErrorEventCallback(target, userData, useCapture, callbackfunc, 38, "mozpointerlockerror", targetThread);
            registerPointerlockErrorEventCallback(target, userData, useCapture, callbackfunc, 38, "webkitpointerlockerror", targetThread);
            registerPointerlockErrorEventCallback(target, userData, useCapture, callbackfunc, 38, "mspointerlockerror", targetThread);
            return registerPointerlockErrorEventCallback(target, userData, useCapture, callbackfunc, 38, "pointerlockerror", targetThread);
          }
          _emscripten_set_pointerlockerror_callback_on_thread.sig = "ippipp";
          function _emscripten_get_pointerlock_status(pointerlockStatus) {
            pointerlockStatus >>>= 0;
            if (pointerlockStatus)
              fillPointerlockChangeEventData(pointerlockStatus);
            if (!document.body || !document.body.requestPointerLock && !document.body.mozRequestPointerLock && !document.body.webkitRequestPointerLock && !document.body.msRequestPointerLock) {
              return -1;
            }
            return 0;
          }
          _emscripten_get_pointerlock_status.sig = "ip";
          var requestPointerLock = (target) => {
            if (target.requestPointerLock) {
              target.requestPointerLock();
            } else {
              if (document.body.requestPointerLock) {
                return -3;
              }
              return -1;
            }
            return 0;
          };
          function _emscripten_request_pointerlock(target, deferUntilInEventHandler) {
            target >>>= 0;
            target = findEventTarget(target);
            if (!target)
              return -4;
            if (!target.requestPointerLock) {
              return -1;
            }
            var canPerformRequests = JSEvents.canPerformEventHandlerRequests();
            if (!canPerformRequests) {
              if (deferUntilInEventHandler) {
                JSEvents.deferCall(requestPointerLock, 2, [target]);
                return 1;
              }
              return -2;
            }
            return requestPointerLock(target);
          }
          _emscripten_request_pointerlock.sig = "ipi";
          var _emscripten_exit_pointerlock = () => {
            JSEvents.removeDeferredCalls(requestPointerLock);
            if (document.exitPointerLock) {
              document.exitPointerLock();
            } else {
              return -1;
            }
            return 0;
          };
          _emscripten_exit_pointerlock.sig = "i";
          var _emscripten_vibrate = (msecs) => {
            if (!navigator.vibrate)
              return -1;
            navigator.vibrate(msecs);
            return 0;
          };
          _emscripten_vibrate.sig = "ii";
          function _emscripten_vibrate_pattern(msecsArray, numEntries) {
            msecsArray >>>= 0;
            if (!navigator.vibrate)
              return -1;
            var vibrateList = [];
            for (var i2 = 0; i2 < numEntries; ++i2) {
              var msecs = HEAP32[msecsArray + i2 * 4 >>> 2 >>> 0];
              vibrateList.push(msecs);
            }
            navigator.vibrate(vibrateList);
            return 0;
          }
          _emscripten_vibrate_pattern.sig = "ipi";
          var fillVisibilityChangeEventData = (eventStruct) => {
            var visibilityStates = ["hidden", "visible", "prerender", "unloaded"];
            var visibilityState = visibilityStates.indexOf(document.visibilityState);
            HEAP32[eventStruct >>> 2 >>> 0] = document.hidden;
            HEAP32[eventStruct + 4 >>> 2 >>> 0] = visibilityState;
          };
          var registerVisibilityChangeEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
            if (!JSEvents.visibilityChangeEvent)
              JSEvents.visibilityChangeEvent = _malloc(8);
            var visibilityChangeEventHandlerFunc = (e = event) => {
              var visibilityChangeEvent = JSEvents.visibilityChangeEvent;
              fillVisibilityChangeEventData(visibilityChangeEvent);
              if (getWasmTableEntry(callbackfunc)(eventTypeId, visibilityChangeEvent, userData))
                e.preventDefault();
            };
            var eventHandler = {
              target,
              eventTypeString,
              callbackfunc,
              handlerFunc: visibilityChangeEventHandlerFunc,
              useCapture
            };
            return JSEvents.registerOrRemoveHandler(eventHandler);
          };
          function _emscripten_set_visibilitychange_callback_on_thread(userData, useCapture, callbackfunc, targetThread) {
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            if (!specialHTMLTargets[1]) {
              return -4;
            }
            return registerVisibilityChangeEventCallback(specialHTMLTargets[1], userData, useCapture, callbackfunc, 21, "visibilitychange", targetThread);
          }
          _emscripten_set_visibilitychange_callback_on_thread.sig = "ipipp";
          function _emscripten_get_visibility_status(visibilityStatus) {
            visibilityStatus >>>= 0;
            if (typeof document.visibilityState == "undefined" && typeof document.hidden == "undefined") {
              return -1;
            }
            fillVisibilityChangeEventData(visibilityStatus);
            return 0;
          }
          _emscripten_get_visibility_status.sig = "ip";
          var registerTouchEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
            if (!JSEvents.touchEvent)
              JSEvents.touchEvent = _malloc(1696);
            target = findEventTarget(target);
            var touchEventHandlerFunc = (e) => {
              var t, touches = {}, et = e.touches;
              for (var i2 = 0; i2 < et.length; ++i2) {
                t = et[i2];
                t.isChanged = t.onTarget = 0;
                touches[t.identifier] = t;
              }
              for (var i2 = 0; i2 < e.changedTouches.length; ++i2) {
                t = e.changedTouches[i2];
                t.isChanged = 1;
                touches[t.identifier] = t;
              }
              for (var i2 = 0; i2 < e.targetTouches.length; ++i2) {
                touches[e.targetTouches[i2].identifier].onTarget = 1;
              }
              var touchEvent = JSEvents.touchEvent;
              HEAPF64[touchEvent >>> 3 >>> 0] = e.timeStamp;
              var idx = touchEvent >>> 2;
              HEAP32[idx + 3 >>> 0] = e.ctrlKey;
              HEAP32[idx + 4 >>> 0] = e.shiftKey;
              HEAP32[idx + 5 >>> 0] = e.altKey;
              HEAP32[idx + 6 >>> 0] = e.metaKey;
              idx += 7;
              var targetRect = getBoundingClientRect(target);
              var numTouches = 0;
              for (var i2 in touches) {
                t = touches[i2];
                HEAP32[idx + 0 >>> 0] = t.identifier;
                HEAP32[idx + 1 >>> 0] = t.screenX;
                HEAP32[idx + 2 >>> 0] = t.screenY;
                HEAP32[idx + 3 >>> 0] = t.clientX;
                HEAP32[idx + 4 >>> 0] = t.clientY;
                HEAP32[idx + 5 >>> 0] = t.pageX;
                HEAP32[idx + 6 >>> 0] = t.pageY;
                HEAP32[idx + 7 >>> 0] = t.isChanged;
                HEAP32[idx + 8 >>> 0] = t.onTarget;
                HEAP32[idx + 9 >>> 0] = t.clientX - targetRect.left;
                HEAP32[idx + 10 >>> 0] = t.clientY - targetRect.top;
                idx += 13;
                if (++numTouches > 31) {
                  break;
                }
              }
              HEAP32[touchEvent + 8 >>> 2 >>> 0] = numTouches;
              if (getWasmTableEntry(callbackfunc)(eventTypeId, touchEvent, userData))
                e.preventDefault();
            };
            var eventHandler = {
              target,
              allowsDeferredCalls: eventTypeString == "touchstart" || eventTypeString == "touchend",
              eventTypeString,
              callbackfunc,
              handlerFunc: touchEventHandlerFunc,
              useCapture
            };
            return JSEvents.registerOrRemoveHandler(eventHandler);
          };
          function _emscripten_set_touchstart_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
            target >>>= 0;
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            return registerTouchEventCallback(target, userData, useCapture, callbackfunc, 22, "touchstart", targetThread);
          }
          _emscripten_set_touchstart_callback_on_thread.sig = "ippipp";
          function _emscripten_set_touchend_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
            target >>>= 0;
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            return registerTouchEventCallback(target, userData, useCapture, callbackfunc, 23, "touchend", targetThread);
          }
          _emscripten_set_touchend_callback_on_thread.sig = "ippipp";
          function _emscripten_set_touchmove_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
            target >>>= 0;
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            return registerTouchEventCallback(target, userData, useCapture, callbackfunc, 24, "touchmove", targetThread);
          }
          _emscripten_set_touchmove_callback_on_thread.sig = "ippipp";
          function _emscripten_set_touchcancel_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
            target >>>= 0;
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            return registerTouchEventCallback(target, userData, useCapture, callbackfunc, 25, "touchcancel", targetThread);
          }
          _emscripten_set_touchcancel_callback_on_thread.sig = "ippipp";
          var fillGamepadEventData = (eventStruct, e) => {
            HEAPF64[eventStruct >>> 3 >>> 0] = e.timestamp;
            for (var i2 = 0; i2 < e.axes.length; ++i2) {
              HEAPF64[eventStruct + i2 * 8 + 16 >>> 3 >>> 0] = e.axes[i2];
            }
            for (var i2 = 0; i2 < e.buttons.length; ++i2) {
              if (typeof e.buttons[i2] == "object") {
                HEAPF64[eventStruct + i2 * 8 + 528 >>> 3 >>> 0] = e.buttons[i2].value;
              } else {
                HEAPF64[eventStruct + i2 * 8 + 528 >>> 3 >>> 0] = e.buttons[i2];
              }
            }
            for (var i2 = 0; i2 < e.buttons.length; ++i2) {
              if (typeof e.buttons[i2] == "object") {
                HEAP32[eventStruct + i2 * 4 + 1040 >>> 2 >>> 0] = e.buttons[i2].pressed;
              } else {
                HEAP32[eventStruct + i2 * 4 + 1040 >>> 2 >>> 0] = e.buttons[i2] == 1;
              }
            }
            HEAP32[eventStruct + 1296 >>> 2 >>> 0] = e.connected;
            HEAP32[eventStruct + 1300 >>> 2 >>> 0] = e.index;
            HEAP32[eventStruct + 8 >>> 2 >>> 0] = e.axes.length;
            HEAP32[eventStruct + 12 >>> 2 >>> 0] = e.buttons.length;
            stringToUTF8(e.id, eventStruct + 1304, 64);
            stringToUTF8(e.mapping, eventStruct + 1368, 64);
          };
          var registerGamepadEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
            if (!JSEvents.gamepadEvent)
              JSEvents.gamepadEvent = _malloc(1432);
            var gamepadEventHandlerFunc = (e = event) => {
              var gamepadEvent = JSEvents.gamepadEvent;
              fillGamepadEventData(gamepadEvent, e["gamepad"]);
              if (getWasmTableEntry(callbackfunc)(eventTypeId, gamepadEvent, userData))
                e.preventDefault();
            };
            var eventHandler = {
              target: findEventTarget(target),
              allowsDeferredCalls: true,
              eventTypeString,
              callbackfunc,
              handlerFunc: gamepadEventHandlerFunc,
              useCapture
            };
            return JSEvents.registerOrRemoveHandler(eventHandler);
          };
          var _emscripten_sample_gamepad_data = () => {
            try {
              if (navigator.getGamepads)
                return (JSEvents.lastGamepadState = navigator.getGamepads()) ? 0 : -1;
            } catch (e) {
              navigator.getGamepads = null;
            }
            return -1;
          };
          _emscripten_sample_gamepad_data.sig = "i";
          function _emscripten_set_gamepadconnected_callback_on_thread(userData, useCapture, callbackfunc, targetThread) {
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            if (_emscripten_sample_gamepad_data())
              return -1;
            return registerGamepadEventCallback(2, userData, useCapture, callbackfunc, 26, "gamepadconnected", targetThread);
          }
          _emscripten_set_gamepadconnected_callback_on_thread.sig = "ipipp";
          function _emscripten_set_gamepaddisconnected_callback_on_thread(userData, useCapture, callbackfunc, targetThread) {
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            if (_emscripten_sample_gamepad_data())
              return -1;
            return registerGamepadEventCallback(2, userData, useCapture, callbackfunc, 27, "gamepaddisconnected", targetThread);
          }
          _emscripten_set_gamepaddisconnected_callback_on_thread.sig = "ipipp";
          var _emscripten_get_num_gamepads = () => JSEvents.lastGamepadState.length;
          _emscripten_get_num_gamepads.sig = "i";
          function _emscripten_get_gamepad_status(index, gamepadState) {
            gamepadState >>>= 0;
            if (index < 0 || index >= JSEvents.lastGamepadState.length)
              return -5;
            if (!JSEvents.lastGamepadState[index])
              return -7;
            fillGamepadEventData(gamepadState, JSEvents.lastGamepadState[index]);
            return 0;
          }
          _emscripten_get_gamepad_status.sig = "iip";
          var registerBeforeUnloadEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString) => {
            var beforeUnloadEventHandlerFunc = (e = event) => {
              var confirmationMessage = getWasmTableEntry(callbackfunc)(eventTypeId, 0, userData);
              if (confirmationMessage) {
                confirmationMessage = UTF8ToString(confirmationMessage);
              }
              if (confirmationMessage) {
                e.preventDefault();
                e.returnValue = confirmationMessage;
                return confirmationMessage;
              }
            };
            var eventHandler = {
              target: findEventTarget(target),
              eventTypeString,
              callbackfunc,
              handlerFunc: beforeUnloadEventHandlerFunc,
              useCapture
            };
            return JSEvents.registerOrRemoveHandler(eventHandler);
          };
          function _emscripten_set_beforeunload_callback_on_thread(userData, callbackfunc, targetThread) {
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            if (typeof onbeforeunload == "undefined")
              return -1;
            if (targetThread !== 1)
              return -5;
            return registerBeforeUnloadEventCallback(2, userData, true, callbackfunc, 28, "beforeunload");
          }
          _emscripten_set_beforeunload_callback_on_thread.sig = "ippp";
          var fillBatteryEventData = (eventStruct, e) => {
            HEAPF64[eventStruct >>> 3 >>> 0] = e.chargingTime;
            HEAPF64[eventStruct + 8 >>> 3 >>> 0] = e.dischargingTime;
            HEAPF64[eventStruct + 16 >>> 3 >>> 0] = e.level;
            HEAP32[eventStruct + 24 >>> 2 >>> 0] = e.charging;
          };
          var battery = () => navigator.battery || navigator.mozBattery || navigator.webkitBattery;
          var registerBatteryEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
            if (!JSEvents.batteryEvent)
              JSEvents.batteryEvent = _malloc(32);
            var batteryEventHandlerFunc = (e = event) => {
              var batteryEvent = JSEvents.batteryEvent;
              fillBatteryEventData(batteryEvent, battery());
              if (getWasmTableEntry(callbackfunc)(eventTypeId, batteryEvent, userData))
                e.preventDefault();
            };
            var eventHandler = {
              target: findEventTarget(target),
              eventTypeString,
              callbackfunc,
              handlerFunc: batteryEventHandlerFunc,
              useCapture
            };
            return JSEvents.registerOrRemoveHandler(eventHandler);
          };
          function _emscripten_set_batterychargingchange_callback_on_thread(userData, callbackfunc, targetThread) {
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            if (!battery())
              return -1;
            return registerBatteryEventCallback(battery(), userData, true, callbackfunc, 29, "chargingchange", targetThread);
          }
          _emscripten_set_batterychargingchange_callback_on_thread.sig = "ippp";
          function _emscripten_set_batterylevelchange_callback_on_thread(userData, callbackfunc, targetThread) {
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            if (!battery())
              return -1;
            return registerBatteryEventCallback(battery(), userData, true, callbackfunc, 30, "levelchange", targetThread);
          }
          _emscripten_set_batterylevelchange_callback_on_thread.sig = "ippp";
          function _emscripten_get_battery_status(batteryState) {
            batteryState >>>= 0;
            if (!battery())
              return -1;
            fillBatteryEventData(batteryState, battery());
            return 0;
          }
          _emscripten_get_battery_status.sig = "ip";
          function _emscripten_set_element_css_size(target, width, height) {
            target >>>= 0;
            target = findEventTarget(target);
            if (!target)
              return -4;
            target.style.width = width + "px";
            target.style.height = height + "px";
            return 0;
          }
          _emscripten_set_element_css_size.sig = "ipdd";
          function _emscripten_get_element_css_size(target, width, height) {
            target >>>= 0;
            width >>>= 0;
            height >>>= 0;
            target = findEventTarget(target);
            if (!target)
              return -4;
            var rect = getBoundingClientRect(target);
            HEAPF64[width >>> 3 >>> 0] = rect.width;
            HEAPF64[height >>> 3 >>> 0] = rect.height;
            return 0;
          }
          _emscripten_get_element_css_size.sig = "ippp";
          var _emscripten_html5_remove_all_event_listeners = () => JSEvents.removeAllEventListeners();
          _emscripten_html5_remove_all_event_listeners.sig = "v";
          var _emscripten_request_animation_frame = function(cb, userData) {
            cb >>>= 0;
            userData >>>= 0;
            return requestAnimationFrame((timeStamp) => getWasmTableEntry(cb)(timeStamp, userData));
          };
          _emscripten_request_animation_frame.sig = "ipp";
          var _emscripten_cancel_animation_frame = (id) => cancelAnimationFrame(id);
          _emscripten_cancel_animation_frame.sig = "vi";
          function _emscripten_request_animation_frame_loop(cb, userData) {
            cb >>>= 0;
            userData >>>= 0;
            function tick(timeStamp) {
              if (getWasmTableEntry(cb)(timeStamp, userData)) {
                requestAnimationFrame(tick);
              }
            }
            return requestAnimationFrame(tick);
          }
          _emscripten_request_animation_frame_loop.sig = "vpp";
          var _emscripten_performance_now = () => performance.now();
          _emscripten_performance_now.sig = "d";
          var _emscripten_get_device_pixel_ratio = () => typeof devicePixelRatio == "number" && devicePixelRatio || 1;
          _emscripten_get_device_pixel_ratio.sig = "d";
          var demangle = (func2) => func2;
          var demangleAll = (text) => {
            var regex = /\b_Z[\w\d_]+/g;
            return text.replace(regex, function(x) {
              var y = demangle(x);
              return x === y ? x : y + " [" + x + "]";
            });
          };
          function stackTrace() {
            var js = jsStackTrace();
            if (Module["extraStackTrace"])
              js += "\n" + Module["extraStackTrace"]();
            return demangleAll(js);
          }
          function _random_get(buf, buf_len) {
            buf >>>= 0;
            buf_len >>>= 0;
            try {
              _getentropy(buf, buf_len);
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
                throw e;
              return e.errno;
            }
          }
          _random_get.sig = "ipp";
          var checkWasiClock = (clock_id) => clock_id == 0 || clock_id == 1 || clock_id == 2 || clock_id == 3;
          function _clock_time_get(clk_id, ignored_precision_low, ignored_precision_high, ptime) {
            var ignored_precision = convertI32PairToI53Checked(ignored_precision_low, ignored_precision_high);
            ptime >>>= 0;
            if (!checkWasiClock(clk_id)) {
              return 28;
            }
            var now;
            if (clk_id === 0) {
              now = Date.now();
            } else if (nowIsMonotonic) {
              now = _emscripten_get_now();
            } else {
              return 52;
            }
            var nsec = Math.round(now * 1e3 * 1e3);
            HEAP32[ptime >>> 2 >>> 0] = nsec >>> 0;
            HEAP32[ptime + 4 >>> 2 >>> 0] = nsec / Math.pow(2, 32) >>> 0;
            return 0;
          }
          _clock_time_get.sig = "iiiip";
          function _clock_res_get(clk_id, pres) {
            pres >>>= 0;
            if (!checkWasiClock(clk_id)) {
              return 28;
            }
            var nsec;
            if (clk_id === 0) {
              nsec = 1e3 * 1e3;
            } else if (nowIsMonotonic) {
              nsec = _emscripten_get_now_res();
            } else {
              return 52;
            }
            HEAP32[pres >>> 2 >>> 0] = nsec >>> 0;
            HEAP32[pres + 4 >>> 2 >>> 0] = nsec / Math.pow(2, 32) >>> 0;
            return 0;
          }
          _clock_res_get.sig = "iip";
          var wasiRightsToMuslOFlags = (rights) => {
            if (rights & 2 && rights & 64) {
              return 2;
            }
            if (rights & 2) {
              return 0;
            }
            if (rights & 64) {
              return 1;
            }
            throw new FS.ErrnoError(28);
          };
          var wasiOFlagsToMuslOFlags = (oflags) => {
            var musl_oflags = 0;
            if (oflags & 1) {
              musl_oflags |= 64;
            }
            if (oflags & 8) {
              musl_oflags |= 512;
            }
            if (oflags & 2) {
              musl_oflags |= 65536;
            }
            if (oflags & 4) {
              musl_oflags |= 128;
            }
            return musl_oflags;
          };
          var _emscripten_unwind_to_js_event_loop = () => {
            throw "unwind";
          };
          _emscripten_unwind_to_js_event_loop.sig = "v";
          var setImmediateWrapped = (func2) => {
            setImmediateWrapped.mapping || (setImmediateWrapped.mapping = []);
            var id = setImmediateWrapped.mapping.length;
            setImmediateWrapped.mapping[id] = setImmediate(() => {
              setImmediateWrapped.mapping[id] = void 0;
              func2();
            });
            return id;
          };
          var clearImmediateWrapped = (id) => {
            clearImmediate(setImmediateWrapped.mapping[id]);
            setImmediateWrapped.mapping[id] = void 0;
          };
          var polyfillSetImmediate = () => {
          };
          var _emscripten_set_immediate = function(cb, userData) {
            cb >>>= 0;
            userData >>>= 0;
            return emSetImmediate(() => {
              callUserCallback(() => getWasmTableEntry(cb)(userData));
            });
          };
          _emscripten_set_immediate.sig = "ipp";
          var _emscripten_clear_immediate = (id) => {
            emClearImmediate(id);
          };
          _emscripten_clear_immediate.sig = "vi";
          var _emscripten_set_immediate_loop = function(cb, userData) {
            cb >>>= 0;
            userData >>>= 0;
            function tick() {
              callUserCallback(() => {
                if (getWasmTableEntry(cb)(userData)) {
                  emSetImmediate(tick);
                } else {
                }
              });
            }
            emSetImmediate(tick);
          };
          _emscripten_set_immediate_loop.sig = "vpp";
          var _emscripten_set_timeout = function(cb, msecs, userData) {
            cb >>>= 0;
            userData >>>= 0;
            return safeSetTimeout(() => getWasmTableEntry(cb)(userData), msecs);
          };
          _emscripten_set_timeout.sig = "ipdp";
          var _emscripten_clear_timeout = clearTimeout;
          _emscripten_clear_timeout.sig = "vi";
          var _emscripten_set_timeout_loop = function(cb, msecs, userData) {
            cb >>>= 0;
            userData >>>= 0;
            function tick() {
              var t = _emscripten_get_now();
              var n = t + msecs;
              callUserCallback(() => {
                if (getWasmTableEntry(cb)(t, userData)) {
                  setTimeout(tick, n - _emscripten_get_now());
                }
              });
            }
            return setTimeout(tick, 0);
          };
          _emscripten_set_timeout_loop.sig = "vpdp";
          var _emscripten_set_interval = function(cb, msecs, userData) {
            cb >>>= 0;
            userData >>>= 0;
            return setInterval(() => {
              callUserCallback(() => getWasmTableEntry(cb)(userData));
            }, msecs);
          };
          _emscripten_set_interval.sig = "ipdp";
          var _emscripten_clear_interval = (id) => {
            clearInterval(id);
          };
          _emscripten_clear_interval.sig = "vi";
          var idsToPromises = (idBuf, size) => {
            var promises = [];
            for (var i2 = 0; i2 < size; i2++) {
              var id = HEAP32[idBuf + i2 * 4 >>> 2 >>> 0];
              promises[i2] = getPromise(id);
            }
            return promises;
          };
          var makePromiseCallback = (callback, userData) => (value) => {
            var stack = stackSave();
            var resultPtr = stackAlloc(POINTER_SIZE);
            HEAPU32[resultPtr >>> 2 >>> 0] = 0;
            try {
              var result = getWasmTableEntry(callback)(resultPtr, userData, value);
              var resultVal = HEAPU32[resultPtr >>> 2 >>> 0];
            } catch (e) {
              if (typeof e !== "number") {
                throw 0;
              }
              throw e;
            } finally {
              stackRestore(stack);
            }
            switch (result) {
              case 0:
                return resultVal;
              case 1:
                return getPromise(resultVal);
              case 2:
                var ret = getPromise(resultVal);
                _emscripten_promise_destroy(resultVal);
                return ret;
              case 3:
                throw resultVal;
            }
          };
          function _emscripten_promise_then(id, onFulfilled, onRejected, userData) {
            id >>>= 0;
            onFulfilled >>>= 0;
            onRejected >>>= 0;
            userData >>>= 0;
            var promise = getPromise(id);
            var newId = promiseMap.allocate({
              promise: promise.then(makePromiseCallback(onFulfilled, userData), makePromiseCallback(onRejected, userData))
            });
            return newId;
          }
          _emscripten_promise_then.sig = "ppppp";
          var _emscripten_promise_all = function(idBuf, resultBuf, size) {
            idBuf >>>= 0;
            resultBuf >>>= 0;
            size >>>= 0;
            var promises = idsToPromises(idBuf, size);
            var id = promiseMap.allocate({
              promise: Promise.all(promises).then((results) => {
                if (resultBuf) {
                  for (var i2 = 0; i2 < size; i2++) {
                    var result = results[i2];
                    HEAPU32[resultBuf + i2 * 4 >>> 2 >>> 0] = result;
                  }
                }
                return resultBuf;
              })
            });
            return id;
          };
          _emscripten_promise_all.sig = "pppp";
          var setPromiseResult = (ptr2, fulfill, value) => {
            var result = fulfill ? 0 : 3;
            HEAP32[ptr2 >>> 2 >>> 0] = result;
            HEAPU32[ptr2 + 4 >>> 2 >>> 0] = value;
          };
          var _emscripten_promise_all_settled = function(idBuf, resultBuf, size) {
            idBuf >>>= 0;
            resultBuf >>>= 0;
            size >>>= 0;
            var promises = idsToPromises(idBuf, size);
            var id = promiseMap.allocate({
              promise: Promise.allSettled(promises).then((results) => {
                if (resultBuf) {
                  var offset = resultBuf;
                  for (var i2 = 0; i2 < size; i2++, offset += 8) {
                    if (results[i2].status === "fulfilled") {
                      setPromiseResult(offset, true, results[i2].value);
                    } else {
                      setPromiseResult(offset, false, results[i2].reason);
                    }
                  }
                }
                return resultBuf;
              })
            });
            return id;
          };
          _emscripten_promise_all_settled.sig = "pppp";
          var _emscripten_promise_any = function(idBuf, errorBuf, size) {
            idBuf >>>= 0;
            errorBuf >>>= 0;
            size >>>= 0;
            var promises = idsToPromises(idBuf, size);
            var id = promiseMap.allocate({
              promise: Promise.any(promises).catch((err2) => {
                if (errorBuf) {
                  for (var i2 = 0; i2 < size; i2++) {
                    HEAPU32[errorBuf + i2 * 4 >>> 2 >>> 0] = err2.errors[i2];
                  }
                }
                throw errorBuf;
              })
            });
            return id;
          };
          _emscripten_promise_any.sig = "pppp";
          function _emscripten_promise_race(idBuf, size) {
            idBuf >>>= 0;
            size >>>= 0;
            var promises = idsToPromises(idBuf, size);
            var id = promiseMap.allocate({
              promise: Promise.race(promises)
            });
            return id;
          }
          _emscripten_promise_race.sig = "ppp";
          function _emscripten_promise_await(returnValuePtr, id) {
            returnValuePtr >>>= 0;
            id >>>= 0;
            abort("emscripten_promise_await is only available with ASYNCIFY");
          }
          _emscripten_promise_await.sig = "vpp";
          var getExceptionMessageCommon = (ptr2) => withStackSave(() => {
            var type_addr_addr = stackAlloc(4);
            var message_addr_addr = stackAlloc(4);
            ___get_exception_message(ptr2, type_addr_addr, message_addr_addr);
            var type_addr = HEAPU32[type_addr_addr >>> 2 >>> 0];
            var message_addr = HEAPU32[message_addr_addr >>> 2 >>> 0];
            var type = UTF8ToString(type_addr);
            _free(type_addr);
            var message;
            if (message_addr) {
              message = UTF8ToString(message_addr);
              _free(message_addr);
            }
            return [type, message];
          });
          var getCppExceptionTag = () => ___cpp_exception;
          var getCppExceptionThrownObjectFromWebAssemblyException = (ex) => {
            var unwind_header = ex.getArg(getCppExceptionTag(), 0);
            return ___thrown_object_from_unwind_exception(unwind_header);
          };
          var incrementExceptionRefcount = (ex) => {
            var ptr2 = getCppExceptionThrownObjectFromWebAssemblyException(ex);
            ___cxa_increment_exception_refcount(ptr2);
          };
          var decrementExceptionRefcount = (ex) => {
            var ptr2 = getCppExceptionThrownObjectFromWebAssemblyException(ex);
            ___cxa_decrement_exception_refcount(ptr2);
          };
          var getExceptionMessage = (ex) => {
            var ptr2 = getCppExceptionThrownObjectFromWebAssemblyException(ex);
            return getExceptionMessageCommon(ptr2);
          };
          var _emscripten_run_preload_plugins = function(file, onload2, onerror2) {
            file >>>= 0;
            onload2 >>>= 0;
            onerror2 >>>= 0;
            var _file = UTF8ToString(file);
            var data2 = FS.analyzePath(_file);
            if (!data2.exists)
              return -1;
            FS.createPreloadedFile(PATH.dirname(_file), PATH.basename(_file), new Uint8Array(data2.object.contents), true, true, () => {
              if (onload2)
                getWasmTableEntry(onload2)(file);
            }, () => {
              if (onerror2)
                getWasmTableEntry(onerror2)(file);
            }, true);
            return 0;
          };
          _emscripten_run_preload_plugins.sig = "ippp";
          var Browser_asyncPrepareDataCounter = 0;
          var _emscripten_run_preload_plugins_data = function(data2, size, suffix, arg, onload2, onerror2) {
            data2 >>>= 0;
            suffix >>>= 0;
            arg >>>= 0;
            onload2 >>>= 0;
            onerror2 >>>= 0;
            var _suffix = UTF8ToString(suffix);
            var name2 = "prepare_data_" + Browser_asyncPrepareDataCounter++ + "." + _suffix;
            var cname = stringToNewUTF8(name2);
            FS.createPreloadedFile("/", name2, HEAPU8.subarray(data2 >>> 0, data2 + size >>> 0), true, true, () => {
              if (onload2)
                getWasmTableEntry(onload2)(arg, cname);
            }, () => {
              if (onerror2)
                getWasmTableEntry(onerror2)(arg);
            }, true);
          };
          _emscripten_run_preload_plugins_data.sig = "vpipppp";
          var _emscripten_async_run_script = function(script2, millis) {
            script2 >>>= 0;
            safeSetTimeout(() => _emscripten_run_script(script2), millis);
          };
          _emscripten_async_run_script.sig = "vpi";
          var _emscripten_async_load_script = function(url, onload, onerror) {
            url >>>= 0;
            onload >>>= 0;
            onerror >>>= 0;
            url = UTF8ToString(url);
            onload = getWasmTableEntry(onload);
            onerror = getWasmTableEntry(onerror);
            assert(runDependencies === 0, "async_load_script must be run when no other dependencies are active");
            var loadDone = () => {
              if (onload) {
                if (runDependencies > 0) {
                  dependenciesFulfilled = onload;
                } else {
                  onload();
                }
              }
            };
            var loadError = () => {
              onerror?.();
            };
            if (ENVIRONMENT_IS_NODE) {
              readAsync(url, (data) => {
                eval(data);
                loadDone();
              }, loadError, false);
              return;
            }
            var script = document.createElement("script");
            script.onload = loadDone;
            script.onerror = loadError;
            script.src = url;
            document.body.appendChild(script);
          };
          _emscripten_async_load_script.sig = "vppp";
          function _emscripten_get_main_loop_timing(mode, value) {
            mode >>>= 0;
            value >>>= 0;
            if (mode)
              HEAP32[mode >>> 2 >>> 0] = Browser.mainLoop.timingMode;
            if (value)
              HEAP32[value >>> 2 >>> 0] = Browser.mainLoop.timingValue;
          }
          _emscripten_get_main_loop_timing.sig = "vpp";
          function _emscripten_set_main_loop(func2, fps, simulateInfiniteLoop) {
            func2 >>>= 0;
            var browserIterationFunc = getWasmTableEntry(func2);
            setMainLoop(browserIterationFunc, fps, simulateInfiniteLoop);
          }
          _emscripten_set_main_loop.sig = "vpii";
          var _emscripten_set_main_loop_arg = function(func2, arg, fps, simulateInfiniteLoop) {
            func2 >>>= 0;
            arg >>>= 0;
            var browserIterationFunc = () => getWasmTableEntry(func2)(arg);
            setMainLoop(browserIterationFunc, fps, simulateInfiniteLoop, arg);
          };
          _emscripten_set_main_loop_arg.sig = "vppii";
          var _emscripten_cancel_main_loop = () => {
            Browser.mainLoop.pause();
            Browser.mainLoop.func = null;
          };
          _emscripten_cancel_main_loop.sig = "v";
          var _emscripten_pause_main_loop = () => {
            Browser.mainLoop.pause();
          };
          _emscripten_pause_main_loop.sig = "v";
          var _emscripten_resume_main_loop = () => {
            Browser.mainLoop.resume();
          };
          _emscripten_resume_main_loop.sig = "v";
          var __emscripten_push_main_loop_blocker = function(func2, arg, name2) {
            func2 >>>= 0;
            arg >>>= 0;
            name2 >>>= 0;
            Browser.mainLoop.queue.push({
              func: () => {
                getWasmTableEntry(func2)(arg);
              },
              name: UTF8ToString(name2),
              counted: true
            });
            Browser.mainLoop.updateStatus();
          };
          __emscripten_push_main_loop_blocker.sig = "vppp";
          var __emscripten_push_uncounted_main_loop_blocker = function(func2, arg, name2) {
            func2 >>>= 0;
            arg >>>= 0;
            name2 >>>= 0;
            Browser.mainLoop.queue.push({
              func: () => {
                getWasmTableEntry(func2)(arg);
              },
              name: UTF8ToString(name2),
              counted: false
            });
            Browser.mainLoop.updateStatus();
          };
          __emscripten_push_uncounted_main_loop_blocker.sig = "vppp";
          var _emscripten_set_main_loop_expected_blockers = (num) => {
            Browser.mainLoop.expectedBlockers = num;
            Browser.mainLoop.remainingBlockers = num;
            Browser.mainLoop.updateStatus();
          };
          _emscripten_set_main_loop_expected_blockers.sig = "vi";
          function _emscripten_async_call(func2, arg, millis) {
            func2 >>>= 0;
            arg >>>= 0;
            function wrapper() {
              getWasmTableEntry(func2)(arg);
            }
            if (millis >= 0 || ENVIRONMENT_IS_NODE) {
              safeSetTimeout(wrapper, millis);
            } else {
              Browser.safeRequestAnimationFrame(wrapper);
            }
          }
          _emscripten_async_call.sig = "vppi";
          function _emscripten_get_window_title() {
            var buflen = 256;
            if (!_emscripten_get_window_title.buffer) {
              _emscripten_get_window_title.buffer = _malloc(buflen);
            }
            stringToUTF8(document.title, _emscripten_get_window_title.buffer, buflen);
            return _emscripten_get_window_title.buffer;
          }
          _emscripten_get_window_title.sig = "p";
          function _emscripten_set_window_title(title) {
            title >>>= 0;
            return document.title = UTF8ToString(title);
          }
          _emscripten_set_window_title.sig = "vp";
          function _emscripten_get_screen_size(width, height) {
            width >>>= 0;
            height >>>= 0;
            HEAP32[width >>> 2 >>> 0] = screen.width;
            HEAP32[height >>> 2 >>> 0] = screen.height;
          }
          _emscripten_get_screen_size.sig = "vpp";
          var _emscripten_hide_mouse = () => {
            var styleSheet = document.styleSheets[0];
            var rules = styleSheet.cssRules;
            for (var i2 = 0; i2 < rules.length; i2++) {
              if (rules[i2].cssText.substr(0, 6) == "canvas") {
                styleSheet.deleteRule(i2);
                i2--;
              }
            }
            styleSheet.insertRule("canvas.emscripten { border: 1px solid black; cursor: none; }", 0);
          };
          _emscripten_hide_mouse.sig = "v";
          var _emscripten_set_canvas_size = (width, height) => {
            Browser.setCanvasSize(width, height);
          };
          _emscripten_set_canvas_size.sig = "vii";
          function _emscripten_get_canvas_size(width, height, isFullscreen) {
            width >>>= 0;
            height >>>= 0;
            isFullscreen >>>= 0;
            var canvas = Module["canvas"];
            HEAP32[width >>> 2 >>> 0] = canvas.width;
            HEAP32[height >>> 2 >>> 0] = canvas.height;
            HEAP32[isFullscreen >>> 2 >>> 0] = Browser.isFullscreen ? 1 : 0;
          }
          _emscripten_get_canvas_size.sig = "vppp";
          function _emscripten_create_worker(url2) {
            url2 >>>= 0;
            url2 = UTF8ToString(url2);
            var id = Browser.workers.length;
            var info2 = {
              worker: new Worker(url2),
              callbacks: [],
              awaited: 0,
              buffer: 0,
              bufferSize: 0
            };
            info2.worker.onmessage = function info_worker_onmessage(msg) {
              if (ABORT)
                return;
              var info3 = Browser.workers[id];
              if (!info3)
                return;
              var callbackId = msg.data["callbackId"];
              var callbackInfo = info3.callbacks[callbackId];
              if (!callbackInfo)
                return;
              if (msg.data["finalResponse"]) {
                info3.awaited--;
                info3.callbacks[callbackId] = null;
              }
              var data2 = msg.data["data"];
              if (data2) {
                if (!data2.byteLength)
                  data2 = new Uint8Array(data2);
                if (!info3.buffer || info3.bufferSize < data2.length) {
                  if (info3.buffer)
                    _free(info3.buffer);
                  info3.bufferSize = data2.length;
                  info3.buffer = _malloc(data2.length);
                }
                HEAPU8.set(data2, info3.buffer >>> 0);
                callbackInfo.func(info3.buffer, data2.length, callbackInfo.arg);
              } else {
                callbackInfo.func(0, 0, callbackInfo.arg);
              }
            };
            Browser.workers.push(info2);
            return id;
          }
          _emscripten_create_worker.sig = "ip";
          var _emscripten_destroy_worker = (id) => {
            var info2 = Browser.workers[id];
            info2.worker.terminate();
            if (info2.buffer)
              _free(info2.buffer);
            Browser.workers[id] = null;
          };
          _emscripten_destroy_worker.sig = "vi";
          function _emscripten_call_worker(id, funcName, data2, size, callback, arg) {
            funcName >>>= 0;
            data2 >>>= 0;
            callback >>>= 0;
            arg >>>= 0;
            funcName = UTF8ToString(funcName);
            var info2 = Browser.workers[id];
            var callbackId = -1;
            if (callback) {
              callbackId = info2.callbacks.length;
              info2.callbacks.push({
                func: getWasmTableEntry(callback),
                arg
              });
              info2.awaited++;
            }
            var transferObject = {
              "funcName": funcName,
              "callbackId": callbackId,
              "data": data2 ? new Uint8Array(HEAPU8.subarray(data2 >>> 0, data2 + size >>> 0)) : 0
            };
            if (data2) {
              info2.worker.postMessage(transferObject, [transferObject.data.buffer]);
            } else {
              info2.worker.postMessage(transferObject);
            }
          }
          _emscripten_call_worker.sig = "vippipp";
          var _emscripten_get_worker_queue_size = (id) => {
            var info2 = Browser.workers[id];
            if (!info2)
              return -1;
            return info2.awaited;
          };
          _emscripten_get_worker_queue_size.sig = "ii";
          function _emscripten_get_preloaded_image_data(path, w, h) {
            path >>>= 0;
            w >>>= 0;
            h >>>= 0;
            if ((path | 0) === path)
              path = UTF8ToString(path);
            path = PATH_FS.resolve(path);
            var canvas = preloadedImages[path];
            if (canvas) {
              var ctx = canvas.getContext("2d");
              var image = ctx.getImageData(0, 0, canvas.width, canvas.height);
              var buf = _malloc(canvas.width * canvas.height * 4);
              HEAPU8.set(image.data, buf >>> 0);
              HEAP32[w >>> 2 >>> 0] = canvas.width;
              HEAP32[h >>> 2 >>> 0] = canvas.height;
              return buf;
            }
            return 0;
          }
          _emscripten_get_preloaded_image_data.sig = "pppp";
          function _emscripten_get_preloaded_image_data_from_FILE(file, w, h) {
            file >>>= 0;
            w >>>= 0;
            h >>>= 0;
            var fd = _fileno(file);
            var stream = FS.getStream(fd);
            if (stream) {
              return _emscripten_get_preloaded_image_data(stream.path, w, h);
            }
            return 0;
          }
          _emscripten_get_preloaded_image_data_from_FILE.sig = "pppp";
          var wget = {
            wgetRequests: {},
            nextWgetRequestHandle: 0,
            getNextWgetRequestHandle() {
              var handle2 = wget.nextWgetRequestHandle;
              wget.nextWgetRequestHandle++;
              return handle2;
            }
          };
          var FS_mkdirTree = (path, mode) => FS.mkdirTree(path, mode);
          var FS_unlink = (path) => FS.unlink(path);
          var _emscripten_async_wget = function(url2, file, onload2, onerror2) {
            url2 >>>= 0;
            file >>>= 0;
            onload2 >>>= 0;
            onerror2 >>>= 0;
            var _url = UTF8ToString(url2);
            var _file = UTF8ToString(file);
            _file = PATH_FS.resolve(_file);
            function doCallback(callback) {
              if (callback) {
                callUserCallback(() => {
                  withStackSave(() => {
                    getWasmTableEntry(callback)(stringToUTF8OnStack(_file));
                  });
                });
              }
            }
            var destinationDirectory = PATH.dirname(_file);
            FS_createPreloadedFile(destinationDirectory, PATH.basename(_file), _url, true, true, () => doCallback(onload2), () => doCallback(onerror2), false, false, () => {
              try {
                FS_unlink(_file);
              } catch (e) {
              }
              FS_mkdirTree(destinationDirectory);
            });
          };
          _emscripten_async_wget.sig = "vpppp";
          var _emscripten_async_wget_data = function(url2, userdata, onload2, onerror2) {
            url2 >>>= 0;
            userdata >>>= 0;
            onload2 >>>= 0;
            onerror2 >>>= 0;
            asyncLoad(UTF8ToString(url2), (byteArray) => {
              callUserCallback(() => {
                var buffer = _malloc(byteArray.length);
                HEAPU8.set(byteArray, buffer >>> 0);
                getWasmTableEntry(onload2)(userdata, buffer, byteArray.length);
                _free(buffer);
              });
            }, () => {
              if (onerror2) {
                callUserCallback(() => {
                  getWasmTableEntry(onerror2)(userdata);
                });
              }
            }, true);
          };
          _emscripten_async_wget_data.sig = "vpppp";
          var _emscripten_async_wget2 = function(url2, file, request, param, userdata, onload2, onerror2, onprogress) {
            url2 >>>= 0;
            file >>>= 0;
            request >>>= 0;
            param >>>= 0;
            userdata >>>= 0;
            onload2 >>>= 0;
            onerror2 >>>= 0;
            onprogress >>>= 0;
            var _url = UTF8ToString(url2);
            var _file = UTF8ToString(file);
            _file = PATH_FS.resolve(_file);
            var _request = UTF8ToString(request);
            var _param = UTF8ToString(param);
            var index = _file.lastIndexOf("/");
            var http = new XMLHttpRequest();
            http.open(_request, _url, true);
            http.responseType = "arraybuffer";
            var handle2 = wget.getNextWgetRequestHandle();
            var destinationDirectory = PATH.dirname(_file);
            http.onload = (e) => {
              if (http.status >= 200 && http.status < 300) {
                try {
                  FS.unlink(_file);
                } catch (e2) {
                }
                FS.mkdirTree(destinationDirectory);
                FS.createDataFile(_file.substr(0, index), _file.substr(index + 1), new Uint8Array(http.response), true, true, false);
                if (onload2) {
                  withStackSave(() => {
                    getWasmTableEntry(onload2)(handle2, userdata, stringToUTF8OnStack(_file));
                  });
                }
              } else {
                if (onerror2)
                  getWasmTableEntry(onerror2)(handle2, userdata, http.status);
              }
              delete wget.wgetRequests[handle2];
            };
            http.onerror = (e) => {
              if (onerror2)
                getWasmTableEntry(onerror2)(handle2, userdata, http.status);
              delete wget.wgetRequests[handle2];
            };
            http.onprogress = (e) => {
              if (e.lengthComputable || e.lengthComputable === void 0 && e.total != 0) {
                var percentComplete = e.loaded / e.total * 100;
                if (onprogress)
                  getWasmTableEntry(onprogress)(handle2, userdata, percentComplete);
              }
            };
            http.onabort = (e) => {
              delete wget.wgetRequests[handle2];
            };
            if (_request == "POST") {
              http.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
              http.send(_param);
            } else {
              http.send(null);
            }
            wget.wgetRequests[handle2] = http;
            return handle2;
          };
          _emscripten_async_wget2.sig = "ipppppppp";
          var _emscripten_async_wget2_data = function(url2, request, param, userdata, free, onload2, onerror2, onprogress) {
            url2 >>>= 0;
            request >>>= 0;
            param >>>= 0;
            userdata >>>= 0;
            onload2 >>>= 0;
            onerror2 >>>= 0;
            onprogress >>>= 0;
            var _url = UTF8ToString(url2);
            var _request = UTF8ToString(request);
            var _param = UTF8ToString(param);
            var http = new XMLHttpRequest();
            http.open(_request, _url, true);
            http.responseType = "arraybuffer";
            var handle2 = wget.getNextWgetRequestHandle();
            function onerrorjs() {
              if (onerror2) {
                withStackSave(() => {
                  var statusText = 0;
                  if (http.statusText) {
                    statusText = stringToUTF8OnStack(http.statusText);
                  }
                  getWasmTableEntry(onerror2)(handle2, userdata, http.status, statusText);
                });
              }
            }
            http.onload = (e) => {
              if (http.status >= 200 && http.status < 300 || http.status === 0 && _url.substr(0, 4).toLowerCase() != "http") {
                var byteArray = new Uint8Array(http.response);
                var buffer = _malloc(byteArray.length);
                HEAPU8.set(byteArray, buffer >>> 0);
                if (onload2)
                  getWasmTableEntry(onload2)(handle2, userdata, buffer, byteArray.length);
                if (free)
                  _free(buffer);
              } else {
                onerrorjs();
              }
              delete wget.wgetRequests[handle2];
            };
            http.onerror = (e) => {
              onerrorjs();
              delete wget.wgetRequests[handle2];
            };
            http.onprogress = (e) => {
              if (onprogress)
                getWasmTableEntry(onprogress)(handle2, userdata, e.loaded, e.lengthComputable || e.lengthComputable === void 0 ? e.total : 0);
            };
            http.onabort = (e) => {
              delete wget.wgetRequests[handle2];
            };
            if (_request == "POST") {
              http.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
              http.send(_param);
            } else {
              http.send(null);
            }
            wget.wgetRequests[handle2] = http;
            return handle2;
          };
          _emscripten_async_wget2_data.sig = "ippppippp";
          var _emscripten_async_wget2_abort = (handle2) => {
            var http = wget.wgetRequests[handle2];
            http?.abort();
          };
          _emscripten_async_wget2_abort.sig = "vi";
          function __dlsym_catchup_js(handle2, symbolIndex) {
            handle2 >>>= 0;
            var lib = LDSO.loadedLibsByHandle[handle2];
            var symDict = lib.exports;
            var symName = Object.keys(symDict)[symbolIndex];
            var sym = symDict[symName];
            var result = addFunction(sym, sym.sig);
            return result;
          }
          __dlsym_catchup_js.sig = "ppi";
          var _setNetworkCallback = (event2, userData, callback) => {
            function _callback(data2) {
              try {
                if (event2 === "error") {
                  withStackSave(function() {
                    var msg = stringToUTF8OnStack(data2[2]);
                    getWasmTableEntry(callback)(data2[0], data2[1], msg, userData);
                  });
                } else {
                  getWasmTableEntry(callback)(data2, userData);
                }
              } catch (e) {
                if (!(e instanceof ExitStatus)) {
                  if (e && typeof e == "object" && e.stack)
                    err("exception thrown: " + [e, e.stack]);
                  throw e;
                }
              }
            }
            Module["websocket"]["on"](event2, callback ? _callback : null);
          };
          function _emscripten_set_socket_error_callback(userData, callback) {
            userData >>>= 0;
            callback >>>= 0;
            _setNetworkCallback("error", userData, callback);
          }
          _emscripten_set_socket_error_callback.sig = "vpp";
          function _emscripten_set_socket_open_callback(userData, callback) {
            userData >>>= 0;
            callback >>>= 0;
            _setNetworkCallback("open", userData, callback);
          }
          _emscripten_set_socket_open_callback.sig = "vpp";
          function _emscripten_set_socket_listen_callback(userData, callback) {
            userData >>>= 0;
            callback >>>= 0;
            _setNetworkCallback("listen", userData, callback);
          }
          _emscripten_set_socket_listen_callback.sig = "vpp";
          function _emscripten_set_socket_connection_callback(userData, callback) {
            userData >>>= 0;
            callback >>>= 0;
            _setNetworkCallback("connection", userData, callback);
          }
          _emscripten_set_socket_connection_callback.sig = "vpp";
          function _emscripten_set_socket_message_callback(userData, callback) {
            userData >>>= 0;
            callback >>>= 0;
            _setNetworkCallback("message", userData, callback);
          }
          _emscripten_set_socket_message_callback.sig = "vpp";
          function _emscripten_set_socket_close_callback(userData, callback) {
            userData >>>= 0;
            callback >>>= 0;
            _setNetworkCallback("close", userData, callback);
          }
          _emscripten_set_socket_close_callback.sig = "vpp";
          function _emscripten_webgl_enable_ANGLE_instanced_arrays(ctx) {
            ctx >>>= 0;
            return webgl_enable_ANGLE_instanced_arrays(GL.contexts[ctx].GLctx);
          }
          _emscripten_webgl_enable_ANGLE_instanced_arrays.sig = "ip";
          function _emscripten_webgl_enable_OES_vertex_array_object(ctx) {
            ctx >>>= 0;
            return webgl_enable_OES_vertex_array_object(GL.contexts[ctx].GLctx);
          }
          _emscripten_webgl_enable_OES_vertex_array_object.sig = "ip";
          function _emscripten_webgl_enable_WEBGL_draw_buffers(ctx) {
            ctx >>>= 0;
            return webgl_enable_WEBGL_draw_buffers(GL.contexts[ctx].GLctx);
          }
          _emscripten_webgl_enable_WEBGL_draw_buffers.sig = "ip";
          function _emscripten_webgl_enable_WEBGL_multi_draw(ctx) {
            ctx >>>= 0;
            return webgl_enable_WEBGL_multi_draw(GL.contexts[ctx].GLctx);
          }
          _emscripten_webgl_enable_WEBGL_multi_draw.sig = "ip";
          function _glVertexPointer(size, type, stride, ptr2) {
            ptr2 >>>= 0;
            throw "Legacy GL function (glVertexPointer) called. If you want legacy GL emulation, you need to compile with -sLEGACY_GL_EMULATION to enable legacy GL emulation.";
          }
          _glVertexPointer.sig = "viiip";
          var _glMatrixMode = () => {
            throw "Legacy GL function (glMatrixMode) called. If you want legacy GL emulation, you need to compile with -sLEGACY_GL_EMULATION to enable legacy GL emulation.";
          };
          _glMatrixMode.sig = "vi";
          var _glBegin = () => {
            throw "Legacy GL function (glBegin) called. If you want legacy GL emulation, you need to compile with -sLEGACY_GL_EMULATION to enable legacy GL emulation.";
          };
          _glBegin.sig = "vi";
          var _glLoadIdentity = () => {
            throw "Legacy GL function (glLoadIdentity) called. If you want legacy GL emulation, you need to compile with -sLEGACY_GL_EMULATION to enable legacy GL emulation.";
          };
          _glLoadIdentity.sig = "v";
          var _glVertexAttribDivisorNV = _glVertexAttribDivisor;
          var _glDrawArraysInstancedNV = _glDrawArraysInstanced;
          var _glDrawElementsInstancedNV = _glDrawElementsInstanced;
          var _glVertexAttribDivisorEXT = _glVertexAttribDivisor;
          var _glDrawArraysInstancedEXT = _glDrawArraysInstanced;
          var _glDrawElementsInstancedEXT = _glDrawElementsInstanced;
          var _glVertexAttribDivisorARB = _glVertexAttribDivisor;
          var _glDrawArraysInstancedARB = _glDrawArraysInstanced;
          var _glDrawElementsInstancedARB = _glDrawElementsInstanced;
          var _glDrawBuffersEXT = _glDrawBuffers;
          function _glMultiDrawArraysWEBGL(mode, firsts, counts, drawcount) {
            firsts >>>= 0;
            counts >>>= 0;
            GLctx.multiDrawWebgl["multiDrawArraysWEBGL"](mode, HEAP32, firsts >> 2, HEAP32, counts >> 2, drawcount);
          }
          _glMultiDrawArraysWEBGL.sig = "vippi";
          var _glMultiDrawArrays = _glMultiDrawArraysWEBGL;
          _glMultiDrawArrays.sig = "vippi";
          var _glMultiDrawArraysANGLE = _glMultiDrawArraysWEBGL;
          function _glMultiDrawArraysInstancedWEBGL(mode, firsts, counts, instanceCounts, drawcount) {
            firsts >>>= 0;
            counts >>>= 0;
            instanceCounts >>>= 0;
            GLctx.multiDrawWebgl["multiDrawArraysInstancedWEBGL"](mode, HEAP32, firsts >> 2, HEAP32, counts >> 2, HEAP32, instanceCounts >> 2, drawcount);
          }
          _glMultiDrawArraysInstancedWEBGL.sig = "vipppi";
          var _glMultiDrawArraysInstancedANGLE = _glMultiDrawArraysInstancedWEBGL;
          function _glMultiDrawElementsWEBGL(mode, counts, type, offsets, drawcount) {
            counts >>>= 0;
            offsets >>>= 0;
            GLctx.multiDrawWebgl["multiDrawElementsWEBGL"](mode, HEAP32, counts >> 2, type, HEAP32, offsets >> 2, drawcount);
          }
          _glMultiDrawElementsWEBGL.sig = "vipipi";
          var _glMultiDrawElements = _glMultiDrawElementsWEBGL;
          _glMultiDrawElements.sig = "vipipi";
          var _glMultiDrawElementsANGLE = _glMultiDrawElementsWEBGL;
          function _glMultiDrawElementsInstancedWEBGL(mode, counts, type, offsets, instanceCounts, drawcount) {
            counts >>>= 0;
            offsets >>>= 0;
            instanceCounts >>>= 0;
            GLctx.multiDrawWebgl["multiDrawElementsInstancedWEBGL"](mode, HEAP32, counts >> 2, type, HEAP32, offsets >> 2, HEAP32, instanceCounts >> 2, drawcount);
          }
          _glMultiDrawElementsInstancedWEBGL.sig = "vipippi";
          var _glMultiDrawElementsInstancedANGLE = _glMultiDrawElementsInstancedWEBGL;
          function _glClearDepth(x0) {
            GLctx.clearDepth(x0);
          }
          _glClearDepth.sig = "vd";
          function _glDepthRange(x0, x1) {
            GLctx.depthRange(x0, x1);
          }
          _glDepthRange.sig = "vdd";
          var _emscripten_glGenVertexArrays = _glGenVertexArrays;
          var _emscripten_glDeleteVertexArrays = _glDeleteVertexArrays;
          var _emscripten_glBindVertexArray = _glBindVertexArray;
          var _emscripten_glIsVertexArray = _glIsVertexArray;
          var _emscripten_glVertexPointer = _glVertexPointer;
          var _emscripten_glMatrixMode = _glMatrixMode;
          var _emscripten_glBegin = _glBegin;
          var _emscripten_glLoadIdentity = _glLoadIdentity;
          var _emscripten_glVertexAttribDivisor = _glVertexAttribDivisor;
          var _emscripten_glDrawArraysInstanced = _glDrawArraysInstanced;
          var _emscripten_glDrawElementsInstanced = _glDrawElementsInstanced;
          var _emscripten_glVertexAttribDivisorNV = _glVertexAttribDivisorNV;
          var _emscripten_glDrawArraysInstancedNV = _glDrawArraysInstancedNV;
          var _emscripten_glDrawElementsInstancedNV = _glDrawElementsInstancedNV;
          var _emscripten_glVertexAttribDivisorEXT = _glVertexAttribDivisorEXT;
          var _emscripten_glDrawArraysInstancedEXT = _glDrawArraysInstancedEXT;
          var _emscripten_glDrawElementsInstancedEXT = _glDrawElementsInstancedEXT;
          var _emscripten_glVertexAttribDivisorARB = _glVertexAttribDivisorARB;
          var _emscripten_glDrawArraysInstancedARB = _glDrawArraysInstancedARB;
          var _emscripten_glDrawElementsInstancedARB = _glDrawElementsInstancedARB;
          var _emscripten_glDrawBuffers = _glDrawBuffers;
          var _emscripten_glDrawBuffersEXT = _glDrawBuffersEXT;
          var _emscripten_glMultiDrawArrays = _glMultiDrawArrays;
          var _emscripten_glMultiDrawArraysANGLE = _glMultiDrawArraysANGLE;
          var _emscripten_glMultiDrawArraysWEBGL = _glMultiDrawArraysWEBGL;
          var _emscripten_glMultiDrawArraysInstancedANGLE = _glMultiDrawArraysInstancedANGLE;
          var _emscripten_glMultiDrawArraysInstancedWEBGL = _glMultiDrawArraysInstancedWEBGL;
          var _emscripten_glMultiDrawElements = _glMultiDrawElements;
          var _emscripten_glMultiDrawElementsANGLE = _glMultiDrawElementsANGLE;
          var _emscripten_glMultiDrawElementsWEBGL = _glMultiDrawElementsWEBGL;
          var _emscripten_glMultiDrawElementsInstancedANGLE = _glMultiDrawElementsInstancedANGLE;
          var _emscripten_glMultiDrawElementsInstancedWEBGL = _glMultiDrawElementsInstancedWEBGL;
          var _emscripten_glClearDepth = _glClearDepth;
          var _emscripten_glDepthRange = _glDepthRange;
          var writeGLArray = (arr, dst, dstLength, heapType) => {
            var len2 = arr.length;
            var writeLength = dstLength < len2 ? dstLength : len2;
            var heap = heapType ? HEAPF32 : HEAP32;
            for (var i2 = 0; i2 < writeLength; ++i2) {
              heap[(dst >> 2) + i2 >>> 0] = arr[i2];
            }
            return len2;
          };
          function _emscripten_webgl_init_context_attributes(attributes) {
            attributes >>>= 0;
            var a = attributes >> 2;
            for (var i2 = 0; i2 < 56 >> 2; ++i2) {
              HEAP32[a + i2 >>> 0] = 0;
            }
            HEAP32[a + (0 >> 2) >>> 0] = HEAP32[a + (4 >> 2) >>> 0] = HEAP32[a + (12 >> 2) >>> 0] = HEAP32[a + (16 >> 2) >>> 0] = HEAP32[a + (32 >> 2) >>> 0] = HEAP32[a + (40 >> 2) >>> 0] = 1;
          }
          _emscripten_webgl_init_context_attributes.sig = "vp";
          var emscripten_webgl_power_preferences = ["default", "low-power", "high-performance"];
          function _emscripten_webgl_do_create_context(target, attributes) {
            target >>>= 0;
            attributes >>>= 0;
            var a = attributes >> 2;
            var powerPreference = HEAP32[a + (24 >> 2) >>> 0];
            var contextAttributes = {
              "alpha": !!HEAP32[a + (0 >> 2) >>> 0],
              "depth": !!HEAP32[a + (4 >> 2) >>> 0],
              "stencil": !!HEAP32[a + (8 >> 2) >>> 0],
              "antialias": !!HEAP32[a + (12 >> 2) >>> 0],
              "premultipliedAlpha": !!HEAP32[a + (16 >> 2) >>> 0],
              "preserveDrawingBuffer": !!HEAP32[a + (20 >> 2) >>> 0],
              "powerPreference": emscripten_webgl_power_preferences[powerPreference],
              "failIfMajorPerformanceCaveat": !!HEAP32[a + (28 >> 2) >>> 0],
              majorVersion: HEAP32[a + (32 >> 2) >>> 0],
              minorVersion: HEAP32[a + (36 >> 2) >>> 0],
              enableExtensionsByDefault: HEAP32[a + (40 >> 2) >>> 0],
              explicitSwapControl: HEAP32[a + (44 >> 2) >>> 0],
              proxyContextToMainThread: HEAP32[a + (48 >> 2) >>> 0],
              renderViaOffscreenBackBuffer: HEAP32[a + (52 >> 2) >>> 0]
            };
            var canvas = findCanvasEventTarget(target);
            if (!canvas) {
              return 0;
            }
            if (contextAttributes.explicitSwapControl) {
              return 0;
            }
            var contextHandle = GL.createContext(canvas, contextAttributes);
            return contextHandle;
          }
          _emscripten_webgl_do_create_context.sig = "ppp";
          var _emscripten_webgl_create_context = _emscripten_webgl_do_create_context;
          _emscripten_webgl_create_context.sig = "ppp";
          function _emscripten_webgl_do_get_current_context() {
            return GL.currentContext ? GL.currentContext.handle : 0;
          }
          _emscripten_webgl_do_get_current_context.sig = "p";
          var _emscripten_webgl_get_current_context = _emscripten_webgl_do_get_current_context;
          _emscripten_webgl_get_current_context.sig = "p";
          var _emscripten_webgl_do_commit_frame = () => {
            if (!GL.currentContext || !GL.currentContext.GLctx) {
              return -3;
            }
            if (!GL.currentContext.attributes.explicitSwapControl) {
              return -3;
            }
            return 0;
          };
          _emscripten_webgl_do_commit_frame.sig = "i";
          var _emscripten_webgl_commit_frame = _emscripten_webgl_do_commit_frame;
          _emscripten_webgl_commit_frame.sig = "i";
          function _emscripten_webgl_make_context_current(contextHandle) {
            contextHandle >>>= 0;
            var success = GL.makeContextCurrent(contextHandle);
            return success ? 0 : -5;
          }
          _emscripten_webgl_make_context_current.sig = "ip";
          function _emscripten_webgl_get_drawing_buffer_size(contextHandle, width, height) {
            contextHandle >>>= 0;
            width >>>= 0;
            height >>>= 0;
            var GLContext = GL.getContext(contextHandle);
            if (!GLContext || !GLContext.GLctx || !width || !height) {
              return -5;
            }
            HEAP32[width >>> 2 >>> 0] = GLContext.GLctx.drawingBufferWidth;
            HEAP32[height >>> 2 >>> 0] = GLContext.GLctx.drawingBufferHeight;
            return 0;
          }
          _emscripten_webgl_get_drawing_buffer_size.sig = "ippp";
          function _emscripten_webgl_get_context_attributes(c, a) {
            c >>>= 0;
            a >>>= 0;
            if (!a)
              return -5;
            c = GL.contexts[c];
            if (!c)
              return -3;
            var t = c.GLctx;
            if (!t)
              return -3;
            t = t.getContextAttributes();
            HEAP32[a >>> 2 >>> 0] = t.alpha;
            HEAP32[a + 4 >>> 2 >>> 0] = t.depth;
            HEAP32[a + 8 >>> 2 >>> 0] = t.stencil;
            HEAP32[a + 12 >>> 2 >>> 0] = t.antialias;
            HEAP32[a + 16 >>> 2 >>> 0] = t.premultipliedAlpha;
            HEAP32[a + 20 >>> 2 >>> 0] = t.preserveDrawingBuffer;
            var power = t["powerPreference"] && emscripten_webgl_power_preferences.indexOf(t["powerPreference"]);
            HEAP32[a + 24 >>> 2 >>> 0] = power;
            HEAP32[a + 28 >>> 2 >>> 0] = t.failIfMajorPerformanceCaveat;
            HEAP32[a + 32 >>> 2 >>> 0] = c.version;
            HEAP32[a + 36 >>> 2 >>> 0] = 0;
            HEAP32[a + 40 >>> 2 >>> 0] = c.attributes.enableExtensionsByDefault;
            return 0;
          }
          _emscripten_webgl_get_context_attributes.sig = "ipp";
          function _emscripten_webgl_destroy_context(contextHandle) {
            contextHandle >>>= 0;
            if (GL.currentContext == contextHandle)
              GL.currentContext = 0;
            GL.deleteContext(contextHandle);
          }
          _emscripten_webgl_destroy_context.sig = "ip";
          function _emscripten_webgl_enable_extension(contextHandle, extension) {
            contextHandle >>>= 0;
            extension >>>= 0;
            var context = GL.getContext(contextHandle);
            var extString = UTF8ToString(extension);
            if (extString.startsWith("GL_"))
              extString = extString.substr(3);
            if (extString == "ANGLE_instanced_arrays")
              webgl_enable_ANGLE_instanced_arrays(GLctx);
            if (extString == "OES_vertex_array_object")
              webgl_enable_OES_vertex_array_object(GLctx);
            if (extString == "WEBGL_draw_buffers")
              webgl_enable_WEBGL_draw_buffers(GLctx);
            if (extString == "WEBGL_multi_draw")
              webgl_enable_WEBGL_multi_draw(GLctx);
            var ext = context.GLctx.getExtension(extString);
            return !!ext;
          }
          _emscripten_webgl_enable_extension.sig = "ipp";
          var _emscripten_supports_offscreencanvas = () => 0;
          _emscripten_supports_offscreencanvas.sig = "i";
          var registerWebGlEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
            var webGlEventHandlerFunc = (e = event) => {
              if (getWasmTableEntry(callbackfunc)(eventTypeId, 0, userData))
                e.preventDefault();
            };
            var eventHandler = {
              target: findEventTarget(target),
              eventTypeString,
              callbackfunc,
              handlerFunc: webGlEventHandlerFunc,
              useCapture
            };
            JSEvents.registerOrRemoveHandler(eventHandler);
          };
          function _emscripten_set_webglcontextlost_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
            target >>>= 0;
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            registerWebGlEventCallback(target, userData, useCapture, callbackfunc, 31, "webglcontextlost", targetThread);
            return 0;
          }
          _emscripten_set_webglcontextlost_callback_on_thread.sig = "ippipp";
          function _emscripten_set_webglcontextrestored_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
            target >>>= 0;
            userData >>>= 0;
            callbackfunc >>>= 0;
            targetThread >>>= 0;
            registerWebGlEventCallback(target, userData, useCapture, callbackfunc, 32, "webglcontextrestored", targetThread);
            return 0;
          }
          _emscripten_set_webglcontextrestored_callback_on_thread.sig = "ippipp";
          function _emscripten_is_webgl_context_lost(contextHandle) {
            contextHandle >>>= 0;
            return !GL.contexts[contextHandle] || GL.contexts[contextHandle].GLctx.isContextLost();
          }
          _emscripten_is_webgl_context_lost.sig = "ip";
          function _emscripten_webgl_get_supported_extensions() {
            return stringToNewUTF8(GLctx.getSupportedExtensions().join(" "));
          }
          _emscripten_webgl_get_supported_extensions.sig = "p";
          var _emscripten_webgl_get_program_parameter_d = (program, param) => GLctx.getProgramParameter(GL.programs[program], param);
          _emscripten_webgl_get_program_parameter_d.sig = "dii";
          function _emscripten_webgl_get_program_info_log_utf8(program) {
            return stringToNewUTF8(GLctx.getProgramInfoLog(GL.programs[program]));
          }
          _emscripten_webgl_get_program_info_log_utf8.sig = "pi";
          var _emscripten_webgl_get_shader_parameter_d = (shader, param) => GLctx.getShaderParameter(GL.shaders[shader], param);
          _emscripten_webgl_get_shader_parameter_d.sig = "dii";
          function _emscripten_webgl_get_shader_info_log_utf8(shader) {
            return stringToNewUTF8(GLctx.getShaderInfoLog(GL.shaders[shader]));
          }
          _emscripten_webgl_get_shader_info_log_utf8.sig = "pi";
          function _emscripten_webgl_get_shader_source_utf8(shader) {
            return stringToNewUTF8(GLctx.getShaderSource(GL.shaders[shader]));
          }
          _emscripten_webgl_get_shader_source_utf8.sig = "pi";
          var _emscripten_webgl_get_vertex_attrib_d = (index, param) => GLctx.getVertexAttrib(index, param);
          _emscripten_webgl_get_vertex_attrib_d.sig = "dii";
          var _emscripten_webgl_get_vertex_attrib_o = (index, param) => {
            var obj = GLctx.getVertexAttrib(index, param);
            return obj?.name;
          };
          _emscripten_webgl_get_vertex_attrib_o.sig = "iii";
          function _emscripten_webgl_get_vertex_attrib_v(index, param, dst, dstLength, dstType) {
            dst >>>= 0;
            return writeGLArray(GLctx.getVertexAttrib(index, param), dst, dstLength, dstType);
          }
          _emscripten_webgl_get_vertex_attrib_v.sig = "iiipii";
          var _emscripten_webgl_get_uniform_d = (program, location) => GLctx.getUniform(GL.programs[program], webglGetUniformLocation(location));
          _emscripten_webgl_get_uniform_d.sig = "dii";
          function _emscripten_webgl_get_uniform_v(program, location, dst, dstLength, dstType) {
            dst >>>= 0;
            return writeGLArray(GLctx.getUniform(GL.programs[program], webglGetUniformLocation(location)), dst, dstLength, dstType);
          }
          _emscripten_webgl_get_uniform_v.sig = "iiipii";
          function _emscripten_webgl_get_parameter_v(param, dst, dstLength, dstType) {
            dst >>>= 0;
            return writeGLArray(GLctx.getParameter(param), dst, dstLength, dstType);
          }
          _emscripten_webgl_get_parameter_v.sig = "iipii";
          var _emscripten_webgl_get_parameter_d = (param) => GLctx.getParameter(param);
          _emscripten_webgl_get_parameter_d.sig = "di";
          var _emscripten_webgl_get_parameter_o = (param) => {
            var obj = GLctx.getParameter(param);
            return obj?.name;
          };
          _emscripten_webgl_get_parameter_o.sig = "ii";
          function _emscripten_webgl_get_parameter_utf8(param) {
            return stringToNewUTF8(GLctx.getParameter(param));
          }
          _emscripten_webgl_get_parameter_utf8.sig = "pi";
          function _emscripten_webgl_get_parameter_i64v(param, dst) {
            dst >>>= 0;
            return writeI53ToI64(dst, GLctx.getParameter(param));
          }
          _emscripten_webgl_get_parameter_i64v.sig = "vip";
          var _glutPostRedisplay = () => {
            if (GLUT.displayFunc && !GLUT.requestedAnimationFrame) {
              GLUT.requestedAnimationFrame = true;
              Browser.requestAnimationFrame(function() {
                GLUT.requestedAnimationFrame = false;
                Browser.mainLoop.runIter(function() {
                  getWasmTableEntry(GLUT.displayFunc)();
                });
              });
            }
          };
          _glutPostRedisplay.sig = "v";
          var GLUT = {
            initTime: null,
            idleFunc: null,
            displayFunc: null,
            keyboardFunc: null,
            keyboardUpFunc: null,
            specialFunc: null,
            specialUpFunc: null,
            reshapeFunc: null,
            motionFunc: null,
            passiveMotionFunc: null,
            mouseFunc: null,
            buttons: 0,
            modifiers: 0,
            initWindowWidth: 256,
            initWindowHeight: 256,
            initDisplayMode: 18,
            windowX: 0,
            windowY: 0,
            windowWidth: 0,
            windowHeight: 0,
            requestedAnimationFrame: false,
            saveModifiers: (event2) => {
              GLUT.modifiers = 0;
              if (event2["shiftKey"])
                GLUT.modifiers += 1;
              if (event2["ctrlKey"])
                GLUT.modifiers += 2;
              if (event2["altKey"])
                GLUT.modifiers += 4;
            },
            onMousemove: (event2) => {
              var lastX = Browser.mouseX;
              var lastY = Browser.mouseY;
              Browser.calculateMouseEvent(event2);
              var newX = Browser.mouseX;
              var newY = Browser.mouseY;
              if (newX == lastX && newY == lastY)
                return;
              if (GLUT.buttons == 0 && event2.target == Module["canvas"] && GLUT.passiveMotionFunc) {
                event2.preventDefault();
                GLUT.saveModifiers(event2);
                getWasmTableEntry(GLUT.passiveMotionFunc)(lastX, lastY);
              } else if (GLUT.buttons != 0 && GLUT.motionFunc) {
                event2.preventDefault();
                GLUT.saveModifiers(event2);
                getWasmTableEntry(GLUT.motionFunc)(lastX, lastY);
              }
            },
            getSpecialKey: (keycode) => {
              var key = null;
              switch (keycode) {
                case 8:
                  key = 120;
                  break;
                case 46:
                  key = 111;
                  break;
                case 112:
                  key = 1;
                  break;
                case 113:
                  key = 2;
                  break;
                case 114:
                  key = 3;
                  break;
                case 115:
                  key = 4;
                  break;
                case 116:
                  key = 5;
                  break;
                case 117:
                  key = 6;
                  break;
                case 118:
                  key = 7;
                  break;
                case 119:
                  key = 8;
                  break;
                case 120:
                  key = 9;
                  break;
                case 121:
                  key = 10;
                  break;
                case 122:
                  key = 11;
                  break;
                case 123:
                  key = 12;
                  break;
                case 37:
                  key = 100;
                  break;
                case 38:
                  key = 101;
                  break;
                case 39:
                  key = 102;
                  break;
                case 40:
                  key = 103;
                  break;
                case 33:
                  key = 104;
                  break;
                case 34:
                  key = 105;
                  break;
                case 36:
                  key = 106;
                  break;
                case 35:
                  key = 107;
                  break;
                case 45:
                  key = 108;
                  break;
                case 16:
                case 5:
                  key = 112;
                  break;
                case 6:
                  key = 113;
                  break;
                case 17:
                case 3:
                  key = 114;
                  break;
                case 4:
                  key = 115;
                  break;
                case 18:
                case 2:
                  key = 116;
                  break;
                case 1:
                  key = 117;
                  break;
              }
              return key;
            },
            getASCIIKey: (event2) => {
              if (event2["ctrlKey"] || event2["altKey"] || event2["metaKey"])
                return null;
              var keycode = event2["keyCode"];
              if (48 <= keycode && keycode <= 57)
                return keycode;
              if (65 <= keycode && keycode <= 90)
                return event2["shiftKey"] ? keycode : keycode + 32;
              if (96 <= keycode && keycode <= 105)
                return keycode - 48;
              if (106 <= keycode && keycode <= 111)
                return keycode - 106 + 42;
              switch (keycode) {
                case 9:
                case 13:
                case 27:
                case 32:
                case 61:
                  return keycode;
              }
              var s2 = event2["shiftKey"];
              switch (keycode) {
                case 186:
                  return s2 ? 58 : 59;
                case 187:
                  return s2 ? 43 : 61;
                case 188:
                  return s2 ? 60 : 44;
                case 189:
                  return s2 ? 95 : 45;
                case 190:
                  return s2 ? 62 : 46;
                case 191:
                  return s2 ? 63 : 47;
                case 219:
                  return s2 ? 123 : 91;
                case 220:
                  return s2 ? 124 : 47;
                case 221:
                  return s2 ? 125 : 93;
                case 222:
                  return s2 ? 34 : 39;
              }
              return null;
            },
            onKeydown: (event2) => {
              if (GLUT.specialFunc || GLUT.keyboardFunc) {
                var key = GLUT.getSpecialKey(event2["keyCode"]);
                if (key !== null) {
                  if (GLUT.specialFunc) {
                    event2.preventDefault();
                    GLUT.saveModifiers(event2);
                    getWasmTableEntry(GLUT.specialFunc)(key, Browser.mouseX, Browser.mouseY);
                  }
                } else {
                  key = GLUT.getASCIIKey(event2);
                  if (key !== null && GLUT.keyboardFunc) {
                    event2.preventDefault();
                    GLUT.saveModifiers(event2);
                    getWasmTableEntry(GLUT.keyboardFunc)(key, Browser.mouseX, Browser.mouseY);
                  }
                }
              }
            },
            onKeyup: (event2) => {
              if (GLUT.specialUpFunc || GLUT.keyboardUpFunc) {
                var key = GLUT.getSpecialKey(event2["keyCode"]);
                if (key !== null) {
                  if (GLUT.specialUpFunc) {
                    event2.preventDefault();
                    GLUT.saveModifiers(event2);
                    getWasmTableEntry(GLUT.specialUpFunc)(key, Browser.mouseX, Browser.mouseY);
                  }
                } else {
                  key = GLUT.getASCIIKey(event2);
                  if (key !== null && GLUT.keyboardUpFunc) {
                    event2.preventDefault();
                    GLUT.saveModifiers(event2);
                    getWasmTableEntry(GLUT.keyboardUpFunc)(key, Browser.mouseX, Browser.mouseY);
                  }
                }
              }
            },
            touchHandler: (event2) => {
              if (event2.target != Module["canvas"]) {
                return;
              }
              var touches = event2.changedTouches, main = touches[0], type = "";
              switch (event2.type) {
                case "touchstart":
                  type = "mousedown";
                  break;
                case "touchmove":
                  type = "mousemove";
                  break;
                case "touchend":
                  type = "mouseup";
                  break;
                default:
                  return;
              }
              var simulatedEvent = document.createEvent("MouseEvent");
              simulatedEvent.initMouseEvent(type, true, true, window, 1, main.screenX, main.screenY, main.clientX, main.clientY, false, false, false, false, 0, null);
              main.target.dispatchEvent(simulatedEvent);
              event2.preventDefault();
            },
            onMouseButtonDown: (event2) => {
              Browser.calculateMouseEvent(event2);
              GLUT.buttons |= 1 << event2["button"];
              if (event2.target == Module["canvas"] && GLUT.mouseFunc) {
                try {
                  event2.target.setCapture();
                } catch (e) {
                }
                event2.preventDefault();
                GLUT.saveModifiers(event2);
                getWasmTableEntry(GLUT.mouseFunc)(event2["button"], 0, Browser.mouseX, Browser.mouseY);
              }
            },
            onMouseButtonUp: (event2) => {
              Browser.calculateMouseEvent(event2);
              GLUT.buttons &= ~(1 << event2["button"]);
              if (GLUT.mouseFunc) {
                event2.preventDefault();
                GLUT.saveModifiers(event2);
                getWasmTableEntry(GLUT.mouseFunc)(event2["button"], 1, Browser.mouseX, Browser.mouseY);
              }
            },
            onMouseWheel: (event2) => {
              Browser.calculateMouseEvent(event2);
              var e = window.event || event2;
              var delta = -Browser.getMouseWheelDelta(event2);
              delta = delta == 0 ? 0 : delta > 0 ? Math.max(delta, 1) : Math.min(delta, -1);
              var button = 3;
              if (delta < 0) {
                button = 4;
              }
              if (GLUT.mouseFunc) {
                event2.preventDefault();
                GLUT.saveModifiers(event2);
                getWasmTableEntry(GLUT.mouseFunc)(button, 0, Browser.mouseX, Browser.mouseY);
              }
            },
            onFullscreenEventChange: (event2) => {
              var width;
              var height;
              if (document["fullscreen"] || document["fullScreen"] || document["mozFullScreen"] || document["webkitIsFullScreen"]) {
                width = screen["width"];
                height = screen["height"];
              } else {
                width = GLUT.windowWidth;
                height = GLUT.windowHeight;
                document.removeEventListener("fullscreenchange", GLUT.onFullscreenEventChange, true);
                document.removeEventListener("mozfullscreenchange", GLUT.onFullscreenEventChange, true);
                document.removeEventListener("webkitfullscreenchange", GLUT.onFullscreenEventChange, true);
              }
              Browser.setCanvasSize(width, height, true);
              if (GLUT.reshapeFunc) {
                getWasmTableEntry(GLUT.reshapeFunc)(width, height);
              }
              _glutPostRedisplay();
            }
          };
          var _glutGetModifiers = () => GLUT.modifiers;
          _glutGetModifiers.sig = "i";
          function _glutInit(argcp, argv) {
            argcp >>>= 0;
            argv >>>= 0;
            GLUT.initTime = Date.now();
            var isTouchDevice = "ontouchstart" in document.documentElement;
            if (isTouchDevice) {
              window.addEventListener("touchmove", GLUT.touchHandler, true);
              window.addEventListener("touchstart", GLUT.touchHandler, true);
              window.addEventListener("touchend", GLUT.touchHandler, true);
            }
            window.addEventListener("keydown", GLUT.onKeydown, true);
            window.addEventListener("keyup", GLUT.onKeyup, true);
            window.addEventListener("mousemove", GLUT.onMousemove, true);
            window.addEventListener("mousedown", GLUT.onMouseButtonDown, true);
            window.addEventListener("mouseup", GLUT.onMouseButtonUp, true);
            window.addEventListener("mousewheel", GLUT.onMouseWheel, true);
            window.addEventListener("DOMMouseScroll", GLUT.onMouseWheel, true);
            Browser.resizeListeners.push(function(width, height) {
              if (GLUT.reshapeFunc) {
                getWasmTableEntry(GLUT.reshapeFunc)(width, height);
              }
            });
            __ATEXIT__.push(function() {
              if (isTouchDevice) {
                window.removeEventListener("touchmove", GLUT.touchHandler, true);
                window.removeEventListener("touchstart", GLUT.touchHandler, true);
                window.removeEventListener("touchend", GLUT.touchHandler, true);
              }
              window.removeEventListener("keydown", GLUT.onKeydown, true);
              window.removeEventListener("keyup", GLUT.onKeyup, true);
              window.removeEventListener("mousemove", GLUT.onMousemove, true);
              window.removeEventListener("mousedown", GLUT.onMouseButtonDown, true);
              window.removeEventListener("mouseup", GLUT.onMouseButtonUp, true);
              window.removeEventListener("mousewheel", GLUT.onMouseWheel, true);
              window.removeEventListener("DOMMouseScroll", GLUT.onMouseWheel, true);
              Module["canvas"].width = Module["canvas"].height = 1;
            });
          }
          _glutInit.sig = "vpp";
          var _glutInitWindowSize = (width, height) => {
            Browser.setCanvasSize(GLUT.initWindowWidth = width, GLUT.initWindowHeight = height);
          };
          _glutInitWindowSize.sig = "vii";
          var _glutInitWindowPosition = (x, y) => {
          };
          _glutInitWindowPosition.sig = "vii";
          var _glutGet = (type) => {
            switch (type) {
              case 100:
                return 0;
              case 101:
                return 0;
              case 102:
                return Module["canvas"].width;
              case 103:
                return Module["canvas"].height;
              case 200:
                return Module["canvas"].width;
              case 201:
                return Module["canvas"].height;
              case 500:
                return 0;
              case 501:
                return 0;
              case 502:
                return GLUT.initWindowWidth;
              case 503:
                return GLUT.initWindowHeight;
              case 700:
                var now = Date.now();
                return now - GLUT.initTime;
              case 105:
                return Module.ctx.getContextAttributes().stencil ? 8 : 0;
              case 106:
                return Module.ctx.getContextAttributes().depth ? 8 : 0;
              case 110:
                return Module.ctx.getContextAttributes().alpha ? 8 : 0;
              case 120:
                return Module.ctx.getContextAttributes().antialias ? 1 : 0;
              default:
                throw "glutGet(" + type + ") not implemented yet";
            }
          };
          _glutGet.sig = "ii";
          function _glutIdleFunc(func2) {
            func2 >>>= 0;
            function callback() {
              if (GLUT.idleFunc) {
                getWasmTableEntry(GLUT.idleFunc)();
                safeSetTimeout(callback, 4);
              }
            }
            if (!GLUT.idleFunc) {
              safeSetTimeout(callback, 0);
            }
            GLUT.idleFunc = func2;
          }
          _glutIdleFunc.sig = "vp";
          var _glutTimerFunc = function(msec, func2, value) {
            func2 >>>= 0;
            return safeSetTimeout(() => getWasmTableEntry(func2)(value), msec);
          };
          _glutTimerFunc.sig = "vipi";
          function _glutDisplayFunc(func2) {
            func2 >>>= 0;
            GLUT.displayFunc = func2;
          }
          _glutDisplayFunc.sig = "vp";
          function _glutKeyboardFunc(func2) {
            func2 >>>= 0;
            GLUT.keyboardFunc = func2;
          }
          _glutKeyboardFunc.sig = "vp";
          function _glutKeyboardUpFunc(func2) {
            func2 >>>= 0;
            GLUT.keyboardUpFunc = func2;
          }
          _glutKeyboardUpFunc.sig = "vp";
          function _glutSpecialFunc(func2) {
            func2 >>>= 0;
            GLUT.specialFunc = func2;
          }
          _glutSpecialFunc.sig = "vp";
          function _glutSpecialUpFunc(func2) {
            func2 >>>= 0;
            GLUT.specialUpFunc = func2;
          }
          _glutSpecialUpFunc.sig = "vp";
          function _glutReshapeFunc(func2) {
            func2 >>>= 0;
            GLUT.reshapeFunc = func2;
          }
          _glutReshapeFunc.sig = "vp";
          function _glutMotionFunc(func2) {
            func2 >>>= 0;
            GLUT.motionFunc = func2;
          }
          _glutMotionFunc.sig = "vp";
          function _glutPassiveMotionFunc(func2) {
            func2 >>>= 0;
            GLUT.passiveMotionFunc = func2;
          }
          _glutPassiveMotionFunc.sig = "vp";
          function _glutMouseFunc(func2) {
            func2 >>>= 0;
            GLUT.mouseFunc = func2;
          }
          _glutMouseFunc.sig = "vp";
          var _glutSetCursor = (cursor) => {
            var cursorStyle = "auto";
            switch (cursor) {
              case 0:
                break;
              case 1:
                break;
              case 2:
                cursorStyle = "pointer";
                break;
              case 3:
                break;
              case 4:
                cursorStyle = "help";
                break;
              case 5:
                break;
              case 6:
                break;
              case 7:
                cursorStyle = "wait";
                break;
              case 8:
                cursorStyle = "text";
                break;
              case 9:
              case 102:
                cursorStyle = "crosshair";
                break;
              case 10:
                cursorStyle = "ns-resize";
                break;
              case 11:
                cursorStyle = "ew-resize";
                break;
              case 12:
                cursorStyle = "n-resize";
                break;
              case 13:
                cursorStyle = "s-resize";
                break;
              case 14:
                cursorStyle = "w-resize";
                break;
              case 15:
                cursorStyle = "e-resize";
                break;
              case 16:
                cursorStyle = "nw-resize";
                break;
              case 17:
                cursorStyle = "ne-resize";
                break;
              case 18:
                cursorStyle = "se-resize";
                break;
              case 19:
                cursorStyle = "sw-resize";
                break;
              case 100:
                break;
              case 101:
                cursorStyle = "none";
                break;
              default:
                throw "glutSetCursor: Unknown cursor type: " + cursor;
            }
            Module["canvas"].style.cursor = cursorStyle;
          };
          _glutSetCursor.sig = "vi";
          function _glutCreateWindow(name2) {
            name2 >>>= 0;
            var contextAttributes = {
              antialias: (GLUT.initDisplayMode & 128) != 0,
              depth: (GLUT.initDisplayMode & 16) != 0,
              stencil: (GLUT.initDisplayMode & 32) != 0,
              alpha: (GLUT.initDisplayMode & 8) != 0
            };
            Module.ctx = Browser.createContext(Module["canvas"], true, true, contextAttributes);
            return Module.ctx ? 1 : 0;
          }
          _glutCreateWindow.sig = "ip";
          var _glutDestroyWindow = (name2) => {
            Module.ctx = Browser.destroyContext(Module["canvas"], true, true);
            return 1;
          };
          _glutDestroyWindow.sig = "vi";
          var _glutReshapeWindow = (width, height) => {
            Browser.exitFullscreen();
            Browser.setCanvasSize(width, height, true);
            if (GLUT.reshapeFunc) {
              getWasmTableEntry(GLUT.reshapeFunc)(width, height);
            }
            _glutPostRedisplay();
          };
          _glutReshapeWindow.sig = "vii";
          var _glutPositionWindow = (x, y) => {
            Browser.exitFullscreen();
            _glutPostRedisplay();
          };
          _glutPositionWindow.sig = "vii";
          var _glutFullScreen = () => {
            GLUT.windowX = 0;
            GLUT.windowY = 0;
            GLUT.windowWidth = Module["canvas"].width;
            GLUT.windowHeight = Module["canvas"].height;
            document.addEventListener("fullscreenchange", GLUT.onFullscreenEventChange, true);
            document.addEventListener("mozfullscreenchange", GLUT.onFullscreenEventChange, true);
            document.addEventListener("webkitfullscreenchange", GLUT.onFullscreenEventChange, true);
            Browser.requestFullscreen(false, false);
          };
          _glutFullScreen.sig = "v";
          var _glutInitDisplayMode = (mode) => GLUT.initDisplayMode = mode;
          _glutInitDisplayMode.sig = "vi";
          var _glutSwapBuffers = () => {
          };
          _glutSwapBuffers.sig = "v";
          var _glutMainLoop = () => {
            _glutReshapeWindow(Module["canvas"].width, Module["canvas"].height);
            _glutPostRedisplay();
            throw "unwind";
          };
          _glutMainLoop.sig = "v";
          function _XOpenDisplay(name2) {
            name2 >>>= 0;
            return 1;
          }
          _XOpenDisplay.sig = "pp";
          function _XCreateWindow(display, parent, x, y, width, height, border_width, depth, class_, visual, valuemask, attributes) {
            display >>>= 0;
            parent >>>= 0;
            visual >>>= 0;
            valuemask >>>= 0;
            attributes >>>= 0;
            Browser.setCanvasSize(width, height);
            return 2;
          }
          _XCreateWindow.sig = "pppiiiiiiippp";
          function _XChangeWindowAttributes(display, window2, valuemask, attributes) {
            display >>>= 0;
            window2 >>>= 0;
            valuemask >>>= 0;
            attributes >>>= 0;
          }
          _XChangeWindowAttributes.sig = "ipppp";
          function _XSetWMHints(display, win, hints) {
            display >>>= 0;
            win >>>= 0;
            hints >>>= 0;
          }
          _XSetWMHints.sig = "ippp";
          function _XMapWindow(display, win) {
            display >>>= 0;
            win >>>= 0;
          }
          _XMapWindow.sig = "ipp";
          function _XStoreName(display, win, name2) {
            display >>>= 0;
            win >>>= 0;
            name2 >>>= 0;
          }
          _XStoreName.sig = "ippp";
          function _XInternAtom(display, name_, hmm) {
            display >>>= 0;
            name_ >>>= 0;
            return 0;
          }
          _XInternAtom.sig = "pppi";
          function _XSendEvent(display, win, propagate, event_mask, even_send) {
            display >>>= 0;
            win >>>= 0;
            event_mask >>>= 0;
            even_send >>>= 0;
          }
          _XSendEvent.sig = "ippipp";
          function _XPending(display) {
            display >>>= 0;
            return 0;
          }
          _XPending.sig = "ip";
          var EGL = {
            errorCode: 12288,
            defaultDisplayInitialized: false,
            currentContext: 0,
            currentReadSurface: 0,
            currentDrawSurface: 0,
            contextAttributes: {
              alpha: false,
              depth: false,
              stencil: false,
              antialias: false
            },
            stringCache: {},
            setErrorCode(code) {
              EGL.errorCode = code;
            },
            chooseConfig(display, attribList, config, config_size, numConfigs) {
              if (display != 62e3) {
                EGL.setErrorCode(12296);
                return 0;
              }
              if (attribList) {
                for (; ; ) {
                  var param = HEAP32[attribList >>> 2 >>> 0];
                  if (param == 12321) {
                    var alphaSize = HEAP32[attribList + 4 >>> 2 >>> 0];
                    EGL.contextAttributes.alpha = alphaSize > 0;
                  } else if (param == 12325) {
                    var depthSize = HEAP32[attribList + 4 >>> 2 >>> 0];
                    EGL.contextAttributes.depth = depthSize > 0;
                  } else if (param == 12326) {
                    var stencilSize = HEAP32[attribList + 4 >>> 2 >>> 0];
                    EGL.contextAttributes.stencil = stencilSize > 0;
                  } else if (param == 12337) {
                    var samples = HEAP32[attribList + 4 >>> 2 >>> 0];
                    EGL.contextAttributes.antialias = samples > 0;
                  } else if (param == 12338) {
                    var samples = HEAP32[attribList + 4 >>> 2 >>> 0];
                    EGL.contextAttributes.antialias = samples == 1;
                  } else if (param == 12544) {
                    var requestedPriority = HEAP32[attribList + 4 >>> 2 >>> 0];
                    EGL.contextAttributes.lowLatency = requestedPriority != 12547;
                  } else if (param == 12344) {
                    break;
                  }
                  attribList += 8;
                }
              }
              if ((!config || !config_size) && !numConfigs) {
                EGL.setErrorCode(12300);
                return 0;
              }
              if (numConfigs) {
                HEAP32[numConfigs >>> 2 >>> 0] = 1;
              }
              if (config && config_size > 0) {
                HEAPU32[config >>> 2 >>> 0] = 62002;
              }
              EGL.setErrorCode(12288);
              return 1;
            }
          };
          function _eglGetDisplay(nativeDisplayType) {
            nativeDisplayType >>>= 0;
            EGL.setErrorCode(12288);
            if (nativeDisplayType != 0 && nativeDisplayType != 1) {
              return 0;
            }
            return 62e3;
          }
          _eglGetDisplay.sig = "pp";
          function _eglInitialize(display, majorVersion, minorVersion) {
            display >>>= 0;
            majorVersion >>>= 0;
            minorVersion >>>= 0;
            if (display != 62e3) {
              EGL.setErrorCode(12296);
              return 0;
            }
            if (majorVersion) {
              HEAP32[majorVersion >>> 2 >>> 0] = 1;
            }
            if (minorVersion) {
              HEAP32[minorVersion >>> 2 >>> 0] = 4;
            }
            EGL.defaultDisplayInitialized = true;
            EGL.setErrorCode(12288);
            return 1;
          }
          _eglInitialize.sig = "ippp";
          function _eglTerminate(display) {
            display >>>= 0;
            if (display != 62e3) {
              EGL.setErrorCode(12296);
              return 0;
            }
            EGL.currentContext = 0;
            EGL.currentReadSurface = 0;
            EGL.currentDrawSurface = 0;
            EGL.defaultDisplayInitialized = false;
            EGL.setErrorCode(12288);
            return 1;
          }
          _eglTerminate.sig = "ip";
          function _eglGetConfigs(display, configs, config_size, numConfigs) {
            display >>>= 0;
            configs >>>= 0;
            numConfigs >>>= 0;
            return EGL.chooseConfig(display, 0, configs, config_size, numConfigs);
          }
          _eglGetConfigs.sig = "ippip";
          function _eglChooseConfig(display, attrib_list, configs, config_size, numConfigs) {
            display >>>= 0;
            attrib_list >>>= 0;
            configs >>>= 0;
            numConfigs >>>= 0;
            return EGL.chooseConfig(display, attrib_list, configs, config_size, numConfigs);
          }
          _eglChooseConfig.sig = "ipppip";
          function _eglGetConfigAttrib(display, config, attribute, value) {
            display >>>= 0;
            config >>>= 0;
            value >>>= 0;
            if (display != 62e3) {
              EGL.setErrorCode(12296);
              return 0;
            }
            if (config != 62002) {
              EGL.setErrorCode(12293);
              return 0;
            }
            if (!value) {
              EGL.setErrorCode(12300);
              return 0;
            }
            EGL.setErrorCode(12288);
            switch (attribute) {
              case 12320:
                HEAP32[value >>> 2 >>> 0] = EGL.contextAttributes.alpha ? 32 : 24;
                return 1;
              case 12321:
                HEAP32[value >>> 2 >>> 0] = EGL.contextAttributes.alpha ? 8 : 0;
                return 1;
              case 12322:
                HEAP32[value >>> 2 >>> 0] = 8;
                return 1;
              case 12323:
                HEAP32[value >>> 2 >>> 0] = 8;
                return 1;
              case 12324:
                HEAP32[value >>> 2 >>> 0] = 8;
                return 1;
              case 12325:
                HEAP32[value >>> 2 >>> 0] = EGL.contextAttributes.depth ? 24 : 0;
                return 1;
              case 12326:
                HEAP32[value >>> 2 >>> 0] = EGL.contextAttributes.stencil ? 8 : 0;
                return 1;
              case 12327:
                HEAP32[value >>> 2 >>> 0] = 12344;
                return 1;
              case 12328:
                HEAP32[value >>> 2 >>> 0] = 62002;
                return 1;
              case 12329:
                HEAP32[value >>> 2 >>> 0] = 0;
                return 1;
              case 12330:
                HEAP32[value >>> 2 >>> 0] = 4096;
                return 1;
              case 12331:
                HEAP32[value >>> 2 >>> 0] = 16777216;
                return 1;
              case 12332:
                HEAP32[value >>> 2 >>> 0] = 4096;
                return 1;
              case 12333:
                HEAP32[value >>> 2 >>> 0] = 0;
                return 1;
              case 12334:
                HEAP32[value >>> 2 >>> 0] = 0;
                return 1;
              case 12335:
                HEAP32[value >>> 2 >>> 0] = 12344;
                return 1;
              case 12337:
                HEAP32[value >>> 2 >>> 0] = EGL.contextAttributes.antialias ? 4 : 0;
                return 1;
              case 12338:
                HEAP32[value >>> 2 >>> 0] = EGL.contextAttributes.antialias ? 1 : 0;
                return 1;
              case 12339:
                HEAP32[value >>> 2 >>> 0] = 4;
                return 1;
              case 12340:
                HEAP32[value >>> 2 >>> 0] = 12344;
                return 1;
              case 12341:
              case 12342:
              case 12343:
                HEAP32[value >>> 2 >>> 0] = -1;
                return 1;
              case 12345:
              case 12346:
                HEAP32[value >>> 2 >>> 0] = 0;
                return 1;
              case 12347:
                HEAP32[value >>> 2 >>> 0] = 0;
                return 1;
              case 12348:
                HEAP32[value >>> 2 >>> 0] = 1;
                return 1;
              case 12349:
              case 12350:
                HEAP32[value >>> 2 >>> 0] = 0;
                return 1;
              case 12351:
                HEAP32[value >>> 2 >>> 0] = 12430;
                return 1;
              case 12352:
                HEAP32[value >>> 2 >>> 0] = 4;
                return 1;
              case 12354:
                HEAP32[value >>> 2 >>> 0] = 0;
                return 1;
              default:
                EGL.setErrorCode(12292);
                return 0;
            }
          }
          _eglGetConfigAttrib.sig = "ippip";
          function _eglCreateWindowSurface(display, config, win, attrib_list) {
            display >>>= 0;
            config >>>= 0;
            attrib_list >>>= 0;
            if (display != 62e3) {
              EGL.setErrorCode(12296);
              return 0;
            }
            if (config != 62002) {
              EGL.setErrorCode(12293);
              return 0;
            }
            EGL.setErrorCode(12288);
            return 62006;
          }
          _eglCreateWindowSurface.sig = "pppip";
          function _eglDestroySurface(display, surface) {
            display >>>= 0;
            surface >>>= 0;
            if (display != 62e3) {
              EGL.setErrorCode(12296);
              return 0;
            }
            if (surface != 62006) {
              EGL.setErrorCode(12301);
              return 1;
            }
            if (EGL.currentReadSurface == surface) {
              EGL.currentReadSurface = 0;
            }
            if (EGL.currentDrawSurface == surface) {
              EGL.currentDrawSurface = 0;
            }
            EGL.setErrorCode(12288);
            return 1;
          }
          _eglDestroySurface.sig = "ipp";
          function _eglCreateContext(display, config, hmm, contextAttribs) {
            display >>>= 0;
            config >>>= 0;
            hmm >>>= 0;
            contextAttribs >>>= 0;
            if (display != 62e3) {
              EGL.setErrorCode(12296);
              return 0;
            }
            var glesContextVersion = 1;
            for (; ; ) {
              var param = HEAP32[contextAttribs >>> 2 >>> 0];
              if (param == 12440) {
                glesContextVersion = HEAP32[contextAttribs + 4 >>> 2 >>> 0];
              } else if (param == 12344) {
                break;
              } else {
                EGL.setErrorCode(12292);
                return 0;
              }
              contextAttribs += 8;
            }
            if (glesContextVersion != 2) {
              EGL.setErrorCode(12293);
              return 0;
            }
            EGL.contextAttributes.majorVersion = glesContextVersion - 1;
            EGL.contextAttributes.minorVersion = 0;
            EGL.context = GL.createContext(Module["canvas"], EGL.contextAttributes);
            if (EGL.context != 0) {
              EGL.setErrorCode(12288);
              GL.makeContextCurrent(EGL.context);
              Module.useWebGL = true;
              Browser.moduleContextCreatedCallbacks.forEach(function(callback) {
                callback();
              });
              GL.makeContextCurrent(null);
              return 62004;
            } else {
              EGL.setErrorCode(12297);
              return 0;
            }
          }
          _eglCreateContext.sig = "ppppp";
          function _eglDestroyContext(display, context) {
            display >>>= 0;
            context >>>= 0;
            if (display != 62e3) {
              EGL.setErrorCode(12296);
              return 0;
            }
            if (context != 62004) {
              EGL.setErrorCode(12294);
              return 0;
            }
            GL.deleteContext(EGL.context);
            EGL.setErrorCode(12288);
            if (EGL.currentContext == context) {
              EGL.currentContext = 0;
            }
            return 1;
          }
          _eglDestroyContext.sig = "ipp";
          function _eglQuerySurface(display, surface, attribute, value) {
            display >>>= 0;
            surface >>>= 0;
            value >>>= 0;
            if (display != 62e3) {
              EGL.setErrorCode(12296);
              return 0;
            }
            if (surface != 62006) {
              EGL.setErrorCode(12301);
              return 0;
            }
            if (!value) {
              EGL.setErrorCode(12300);
              return 0;
            }
            EGL.setErrorCode(12288);
            switch (attribute) {
              case 12328:
                HEAP32[value >>> 2 >>> 0] = 62002;
                return 1;
              case 12376:
                return 1;
              case 12375:
                HEAP32[value >>> 2 >>> 0] = Module["canvas"].width;
                return 1;
              case 12374:
                HEAP32[value >>> 2 >>> 0] = Module["canvas"].height;
                return 1;
              case 12432:
                HEAP32[value >>> 2 >>> 0] = -1;
                return 1;
              case 12433:
                HEAP32[value >>> 2 >>> 0] = -1;
                return 1;
              case 12434:
                HEAP32[value >>> 2 >>> 0] = -1;
                return 1;
              case 12422:
                HEAP32[value >>> 2 >>> 0] = 12420;
                return 1;
              case 12441:
                HEAP32[value >>> 2 >>> 0] = 12442;
                return 1;
              case 12435:
                HEAP32[value >>> 2 >>> 0] = 12437;
                return 1;
              case 12416:
              case 12417:
              case 12418:
              case 12419:
                return 1;
              default:
                EGL.setErrorCode(12292);
                return 0;
            }
          }
          _eglQuerySurface.sig = "ippip";
          function _eglQueryContext(display, context, attribute, value) {
            display >>>= 0;
            context >>>= 0;
            value >>>= 0;
            if (display != 62e3) {
              EGL.setErrorCode(12296);
              return 0;
            }
            if (context != 62004) {
              EGL.setErrorCode(12294);
              return 0;
            }
            if (!value) {
              EGL.setErrorCode(12300);
              return 0;
            }
            EGL.setErrorCode(12288);
            switch (attribute) {
              case 12328:
                HEAP32[value >>> 2 >>> 0] = 62002;
                return 1;
              case 12439:
                HEAP32[value >>> 2 >>> 0] = 12448;
                return 1;
              case 12440:
                HEAP32[value >>> 2 >>> 0] = EGL.contextAttributes.majorVersion + 1;
                return 1;
              case 12422:
                HEAP32[value >>> 2 >>> 0] = 12420;
                return 1;
              default:
                EGL.setErrorCode(12292);
                return 0;
            }
          }
          _eglQueryContext.sig = "ippip";
          var _eglGetError = () => EGL.errorCode;
          _eglGetError.sig = "i";
          function _eglQueryString(display, name2) {
            display >>>= 0;
            if (display != 62e3) {
              EGL.setErrorCode(12296);
              return 0;
            }
            EGL.setErrorCode(12288);
            if (EGL.stringCache[name2])
              return EGL.stringCache[name2];
            var ret;
            switch (name2) {
              case 12371:
                ret = stringToNewUTF8("Emscripten");
                break;
              case 12372:
                ret = stringToNewUTF8("1.4 Emscripten EGL");
                break;
              case 12373:
                ret = stringToNewUTF8("");
                break;
              case 12429:
                ret = stringToNewUTF8("OpenGL_ES");
                break;
              default:
                EGL.setErrorCode(12300);
                return 0;
            }
            EGL.stringCache[name2] = ret;
            return ret;
          }
          _eglQueryString.sig = "ppi";
          var _eglBindAPI = (api) => {
            if (api == 12448) {
              EGL.setErrorCode(12288);
              return 1;
            }
            EGL.setErrorCode(12300);
            return 0;
          };
          _eglBindAPI.sig = "ii";
          var _eglQueryAPI = () => {
            EGL.setErrorCode(12288);
            return 12448;
          };
          _eglQueryAPI.sig = "i";
          var _eglWaitClient = () => {
            EGL.setErrorCode(12288);
            return 1;
          };
          _eglWaitClient.sig = "i";
          var _eglWaitNative = (nativeEngineId) => {
            EGL.setErrorCode(12288);
            return 1;
          };
          _eglWaitNative.sig = "ii";
          var _eglWaitGL = _eglWaitClient;
          _eglWaitGL.sig = "i";
          function _eglSwapInterval(display, interval) {
            display >>>= 0;
            if (display != 62e3) {
              EGL.setErrorCode(12296);
              return 0;
            }
            if (interval == 0)
              _emscripten_set_main_loop_timing(0, 0);
            else
              _emscripten_set_main_loop_timing(1, interval);
            EGL.setErrorCode(12288);
            return 1;
          }
          _eglSwapInterval.sig = "ipi";
          function _eglMakeCurrent(display, draw, read, context) {
            display >>>= 0;
            draw >>>= 0;
            read >>>= 0;
            context >>>= 0;
            if (display != 62e3) {
              EGL.setErrorCode(12296);
              return 0;
            }
            if (context != 0 && context != 62004) {
              EGL.setErrorCode(12294);
              return 0;
            }
            if (read != 0 && read != 62006 || draw != 0 && draw != 62006) {
              EGL.setErrorCode(12301);
              return 0;
            }
            GL.makeContextCurrent(context ? EGL.context : null);
            EGL.currentContext = context;
            EGL.currentDrawSurface = draw;
            EGL.currentReadSurface = read;
            EGL.setErrorCode(12288);
            return 1;
          }
          _eglMakeCurrent.sig = "ipppp";
          function _eglGetCurrentContext() {
            return EGL.currentContext;
          }
          _eglGetCurrentContext.sig = "p";
          function _eglGetCurrentSurface(readdraw) {
            if (readdraw == 12378) {
              return EGL.currentReadSurface;
            } else if (readdraw == 12377) {
              return EGL.currentDrawSurface;
            } else {
              EGL.setErrorCode(12300);
              return 0;
            }
          }
          _eglGetCurrentSurface.sig = "pi";
          function _eglGetCurrentDisplay() {
            return EGL.currentContext ? 62e3 : 0;
          }
          _eglGetCurrentDisplay.sig = "p";
          function _eglSwapBuffers(dpy, surface) {
            dpy >>>= 0;
            surface >>>= 0;
            if (!EGL.defaultDisplayInitialized) {
              EGL.setErrorCode(12289);
            } else if (!Module.ctx) {
              EGL.setErrorCode(12290);
            } else if (Module.ctx.isContextLost()) {
              EGL.setErrorCode(12302);
            } else {
              EGL.setErrorCode(12288);
              return 1;
            }
            return 0;
          }
          _eglSwapBuffers.sig = "ipp";
          var _eglReleaseThread = () => {
            EGL.currentContext = 0;
            EGL.currentReadSurface = 0;
            EGL.currentDrawSurface = 0;
            EGL.setErrorCode(12288);
            return 1;
          };
          _eglReleaseThread.sig = "i";
          function _uuid_clear(uu) {
            uu >>>= 0;
            return zeroMemory(uu, 16);
          }
          _uuid_clear.sig = "vp";
          function _uuid_compare(uu1, uu2) {
            uu1 >>>= 0;
            uu2 >>>= 0;
            return _memcmp(uu1, uu2, 16);
          }
          _uuid_compare.sig = "ipp";
          function _uuid_copy(dst, src) {
            dst >>>= 0;
            src >>>= 0;
            return _memcpy(dst, src, 16);
          }
          _uuid_copy.sig = "vpp";
          function _uuid_generate(out2) {
            out2 >>>= 0;
            var uuid = null;
            if (ENVIRONMENT_IS_NODE) {
              try {
                var rb = __require("crypto")["randomBytes"];
                uuid = rb(16);
              } catch (e) {
              }
            } else if (ENVIRONMENT_IS_WEB && typeof window.crypto != "undefined" && typeof window.crypto.getRandomValues != "undefined") {
              uuid = new Uint8Array(16);
              window.crypto.getRandomValues(uuid);
            }
            if (!uuid) {
              uuid = new Array(16);
              var d = (/* @__PURE__ */ new Date()).getTime();
              for (var i2 = 0; i2 < 16; i2++) {
                var r = (d + Math.random() * 256) % 256 | 0;
                d = d / 256 | 0;
                uuid[i2] = r;
              }
            }
            uuid[6] = uuid[6] & 15 | 64;
            uuid[8] = uuid[8] & 63 | 128;
            writeArrayToMemory(uuid, out2);
          }
          _uuid_generate.sig = "vp";
          function _uuid_is_null(uu) {
            uu >>>= 0;
            for (var i2 = 0; i2 < 4; i2++, uu = uu + 4 | 0) {
              var val = HEAP32[uu >>> 2 >>> 0];
              if (val) {
                return 0;
              }
            }
            return 1;
          }
          _uuid_is_null.sig = "ip";
          function _uuid_parse(inp, uu) {
            inp >>>= 0;
            uu >>>= 0;
            inp = UTF8ToString(inp);
            if (inp.length === 36) {
              var i2 = 0;
              var uuid = new Array(16);
              inp.toLowerCase().replace(/[0-9a-f]{2}/g, function(byte) {
                if (i2 < 16) {
                  uuid[i2++] = parseInt(byte, 16);
                }
              });
              if (i2 < 16) {
                return -1;
              }
              writeArrayToMemory(uuid, uu);
              return 0;
            }
            return -1;
          }
          _uuid_parse.sig = "ipp";
          function _uuid_unparse(uu, out2, upper) {
            uu >>>= 0;
            out2 >>>= 0;
            var i2 = 0;
            var uuid = "xxxx-xx-xx-xx-xxxxxx".replace(/[x]/g, function(c) {
              var r = upper ? HEAPU8[uu + i2 >>> 0 >>> 0].toString(16).toUpperCase() : HEAPU8[uu + i2 >>> 0 >>> 0].toString(16);
              r = r.length === 1 ? "0" + r : r;
              i2++;
              return r;
            });
            stringToUTF8(uuid, out2, 37);
          }
          _uuid_unparse.sig = "vpp";
          function _uuid_unparse_lower(uu, out2) {
            uu >>>= 0;
            out2 >>>= 0;
            _uuid_unparse(uu, out2);
          }
          _uuid_unparse_lower.sig = "vpp";
          function _uuid_unparse_upper(uu, out2) {
            uu >>>= 0;
            out2 >>>= 0;
            _uuid_unparse(uu, out2, true);
          }
          _uuid_unparse_upper.sig = "vpp";
          function _uuid_type(uu) {
            uu >>>= 0;
            return 4;
          }
          _uuid_type.sig = "ip";
          function _uuid_variant(uu) {
            uu >>>= 0;
            return 1;
          }
          _uuid_variant.sig = "ip";
          var GLEW = {
            isLinaroFork: 1,
            extensions: null,
            error: {
              0: null,
              1: null,
              2: null,
              3: null,
              4: null,
              5: null,
              6: null,
              7: null,
              8: null
            },
            version: {
              1: null,
              2: null,
              3: null,
              4: null
            },
            errorStringConstantFromCode(error) {
              if (GLEW.isLinaroFork) {
                switch (error) {
                  case 4:
                    return "OpenGL ES lib expected, found OpenGL lib";
                  case 5:
                    return "OpenGL lib expected, found OpenGL ES lib";
                  case 6:
                    return "Missing EGL version";
                  case 7:
                    return "EGL 1.1 and up are supported";
                  default:
                    break;
                }
              }
              switch (error) {
                case 0:
                  return "No error";
                case 1:
                  return "Missing GL version";
                case 2:
                  return "GL 1.1 and up are supported";
                case 3:
                  return "GLX 1.2 and up are supported";
                default:
                  return null;
              }
            },
            errorString(error) {
              if (!GLEW.error[error]) {
                var string = GLEW.errorStringConstantFromCode(error);
                if (!string) {
                  string = "Unknown error";
                  error = 8;
                }
                GLEW.error[error] = stringToNewUTF8(string);
              }
              return GLEW.error[error];
            },
            versionStringConstantFromCode(name2) {
              switch (name2) {
                case 1:
                  return "1.10.0";
                case 2:
                  return "1";
                case 3:
                  return "10";
                case 4:
                  return "0";
                default:
                  return null;
              }
            },
            versionString(name2) {
              if (!GLEW.version[name2]) {
                var string = GLEW.versionStringConstantFromCode(name2);
                if (!string)
                  return 0;
                GLEW.version[name2] = stringToNewUTF8(string);
              }
              return GLEW.version[name2];
            },
            extensionIsSupported(name2) {
              GLEW.extensions || (GLEW.extensions = webglGetExtensions());
              if (GLEW.extensions.includes(name2))
                return 1;
              return GLEW.extensions.includes("GL_" + name2);
            }
          };
          var _glewInit = () => 0;
          _glewInit.sig = "i";
          function _glewIsSupported(name2) {
            name2 >>>= 0;
            var exts = UTF8ToString(name2).split(" ");
            for (var i2 = 0; i2 < exts.length; ++i2) {
              if (!GLEW.extensionIsSupported(exts[i2]))
                return 0;
            }
            return 1;
          }
          _glewIsSupported.sig = "ip";
          function _glewGetExtension(name2) {
            name2 >>>= 0;
            return GLEW.extensionIsSupported(UTF8ToString(name2));
          }
          _glewGetExtension.sig = "ip";
          function _glewGetErrorString(error) {
            return GLEW.errorString(error);
          }
          _glewGetErrorString.sig = "pi";
          function _glewGetString(name2) {
            return GLEW.versionString(name2);
          }
          _glewGetString.sig = "pi";
          var IDBStore = {
            indexedDB() {
              if (typeof indexedDB != "undefined")
                return indexedDB;
              var ret = null;
              if (typeof window == "object")
                ret = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
              assert(ret, "IDBStore used, but indexedDB not supported");
              return ret;
            },
            DB_VERSION: 22,
            DB_STORE_NAME: "FILE_DATA",
            dbs: {},
            blobs: [0],
            getDB(name2, callback) {
              var db2 = IDBStore.dbs[name2];
              if (db2) {
                return callback(null, db2);
              }
              var req;
              try {
                req = IDBStore.indexedDB().open(name2, IDBStore.DB_VERSION);
              } catch (e) {
                return callback(e);
              }
              req.onupgradeneeded = (e) => {
                var db3 = e.target.result;
                var transaction = e.target.transaction;
                var fileStore;
                if (db3.objectStoreNames.contains(IDBStore.DB_STORE_NAME)) {
                  fileStore = transaction.objectStore(IDBStore.DB_STORE_NAME);
                } else {
                  fileStore = db3.createObjectStore(IDBStore.DB_STORE_NAME);
                }
              };
              req.onsuccess = () => {
                db2 = req.result;
                IDBStore.dbs[name2] = db2;
                callback(null, db2);
              };
              req.onerror = function(event2) {
                callback(event2.target.error || "unknown error");
                event2.preventDefault();
              };
            },
            getStore(dbName, type, callback) {
              IDBStore.getDB(dbName, (error, db2) => {
                if (error)
                  return callback(error);
                var transaction = db2.transaction([IDBStore.DB_STORE_NAME], type);
                transaction.onerror = (event2) => {
                  callback(event2.target.error || "unknown error");
                  event2.preventDefault();
                };
                var store = transaction.objectStore(IDBStore.DB_STORE_NAME);
                callback(null, store);
              });
            },
            getFile(dbName, id, callback) {
              IDBStore.getStore(dbName, "readonly", (err2, store) => {
                if (err2)
                  return callback(err2);
                var req = store.get(id);
                req.onsuccess = (event2) => {
                  var result = event2.target.result;
                  if (!result) {
                    return callback(`file ${id} not found`);
                  }
                  return callback(null, result);
                };
                req.onerror = callback;
              });
            },
            setFile(dbName, id, data2, callback) {
              IDBStore.getStore(dbName, "readwrite", (err2, store) => {
                if (err2)
                  return callback(err2);
                var req = store.put(data2, id);
                req.onsuccess = (event2) => callback();
                req.onerror = callback;
              });
            },
            deleteFile(dbName, id, callback) {
              IDBStore.getStore(dbName, "readwrite", (err2, store) => {
                if (err2)
                  return callback(err2);
                var req = store.delete(id);
                req.onsuccess = (event2) => callback();
                req.onerror = callback;
              });
            },
            existsFile(dbName, id, callback) {
              IDBStore.getStore(dbName, "readonly", (err2, store) => {
                if (err2)
                  return callback(err2);
                var req = store.count(id);
                req.onsuccess = (event2) => callback(null, event2.target.result > 0);
                req.onerror = callback;
              });
            },
            clearStore(dbName, callback) {
              IDBStore.getStore(dbName, "readwrite", (err2, store) => {
                if (err2)
                  return callback(err2);
                var req = store.clear();
                req.onsuccess = (event2) => callback();
                req.onerror = callback;
              });
            }
          };
          var _emscripten_idb_async_load = function(db2, id, arg, onload2, onerror2) {
            db2 >>>= 0;
            id >>>= 0;
            arg >>>= 0;
            onload2 >>>= 0;
            onerror2 >>>= 0;
            IDBStore.getFile(UTF8ToString(db2), UTF8ToString(id), (error, byteArray) => {
              callUserCallback(() => {
                if (error) {
                  if (onerror2)
                    getWasmTableEntry(onerror2)(arg);
                  return;
                }
                var buffer = _malloc(byteArray.length);
                HEAPU8.set(byteArray, buffer >>> 0);
                getWasmTableEntry(onload2)(arg, buffer, byteArray.length);
                _free(buffer);
              });
            });
          };
          _emscripten_idb_async_load.sig = "vppppp";
          var _emscripten_idb_async_store = function(db2, id, ptr2, num, arg, onstore, onerror2) {
            db2 >>>= 0;
            id >>>= 0;
            ptr2 >>>= 0;
            arg >>>= 0;
            onstore >>>= 0;
            onerror2 >>>= 0;
            IDBStore.setFile(UTF8ToString(db2), UTF8ToString(id), new Uint8Array(HEAPU8.subarray(ptr2 >>> 0, ptr2 + num >>> 0)), (error) => {
              callUserCallback(() => {
                if (error) {
                  if (onerror2)
                    getWasmTableEntry(onerror2)(arg);
                  return;
                }
                if (onstore)
                  getWasmTableEntry(onstore)(arg);
              });
            });
          };
          _emscripten_idb_async_store.sig = "vpppippp";
          var _emscripten_idb_async_delete = function(db2, id, arg, ondelete, onerror2) {
            db2 >>>= 0;
            id >>>= 0;
            arg >>>= 0;
            ondelete >>>= 0;
            onerror2 >>>= 0;
            IDBStore.deleteFile(UTF8ToString(db2), UTF8ToString(id), (error) => {
              callUserCallback(() => {
                if (error) {
                  if (onerror2)
                    getWasmTableEntry(onerror2)(arg);
                  return;
                }
                if (ondelete)
                  getWasmTableEntry(ondelete)(arg);
              });
            });
          };
          _emscripten_idb_async_delete.sig = "vppppp";
          var _emscripten_idb_async_exists = function(db2, id, arg, oncheck, onerror2) {
            db2 >>>= 0;
            id >>>= 0;
            arg >>>= 0;
            oncheck >>>= 0;
            onerror2 >>>= 0;
            IDBStore.existsFile(UTF8ToString(db2), UTF8ToString(id), (error, exists) => {
              callUserCallback(() => {
                if (error) {
                  if (onerror2)
                    getWasmTableEntry(onerror2)(arg);
                  return;
                }
                if (oncheck)
                  getWasmTableEntry(oncheck)(arg, exists);
              });
            });
          };
          _emscripten_idb_async_exists.sig = "vppppp";
          var _emscripten_idb_async_clear = function(db2, arg, onclear, onerror2) {
            db2 >>>= 0;
            arg >>>= 0;
            onclear >>>= 0;
            onerror2 >>>= 0;
            IDBStore.clearStore(UTF8ToString(db2), (error) => {
              callUserCallback(() => {
                if (error) {
                  if (onerror2)
                    getWasmTableEntry(onerror2)(arg);
                  return;
                }
                if (onclear)
                  getWasmTableEntry(onclear)(arg);
              });
            });
          };
          _emscripten_idb_async_clear.sig = "vpppp";
          function _emscripten_idb_load(db2, id, pbuffer, pnum, perror) {
            db2 >>>= 0;
            id >>>= 0;
            pbuffer >>>= 0;
            pnum >>>= 0;
            perror >>>= 0;
            throw "Please compile your program with async support in order to use synchronous operations like emscripten_idb_load, etc.";
          }
          _emscripten_idb_load.sig = "vppppp";
          function _emscripten_idb_store(db2, id, ptr2, num, perror) {
            db2 >>>= 0;
            id >>>= 0;
            ptr2 >>>= 0;
            perror >>>= 0;
            throw "Please compile your program with async support in order to use synchronous operations like emscripten_idb_store, etc.";
          }
          _emscripten_idb_store.sig = "vpppip";
          function _emscripten_idb_delete(db2, id, perror) {
            db2 >>>= 0;
            id >>>= 0;
            perror >>>= 0;
            throw "Please compile your program with async support in order to use synchronous operations like emscripten_idb_delete, etc.";
          }
          _emscripten_idb_delete.sig = "vppp";
          function _emscripten_idb_exists(db2, id, pexists, perror) {
            db2 >>>= 0;
            id >>>= 0;
            pexists >>>= 0;
            perror >>>= 0;
            throw "Please compile your program with async support in order to use synchronous operations like emscripten_idb_exists, etc.";
          }
          _emscripten_idb_exists.sig = "vpppp";
          function _emscripten_idb_clear(db2, perror) {
            db2 >>>= 0;
            perror >>>= 0;
            throw "Please compile your program with async support in order to use synchronous operations like emscripten_idb_clear, etc.";
          }
          _emscripten_idb_clear.sig = "vpp";
          var runAndAbortIfError = (func2) => {
            try {
              return func2();
            } catch (e) {
              abort(e);
            }
          };
          var _emscripten_sleep = () => {
            throw "Please compile your program with async support in order to use asynchronous operations like emscripten_sleep";
          };
          _emscripten_sleep.sig = "vi";
          function _emscripten_scan_registers(func2) {
            func2 >>>= 0;
            throw "Please compile your program with async support in order to use asynchronous operations like emscripten_scan_registers";
          }
          _emscripten_scan_registers.sig = "vp";
          function _emscripten_fiber_swap(oldFiber, newFiber) {
            oldFiber >>>= 0;
            newFiber >>>= 0;
            throw "Please compile your program with async support in order to use asynchronous operations like emscripten_fiber_swap";
          }
          _emscripten_fiber_swap.sig = "vpp";
          var _SDL_GetTicks = () => Date.now() - SDL.startTime | 0;
          _SDL_GetTicks.sig = "i";
          function _SDL_LockSurface(surf) {
            surf >>>= 0;
            var surfData = SDL.surfaces[surf];
            surfData.locked++;
            if (surfData.locked > 1)
              return 0;
            if (!surfData.buffer) {
              surfData.buffer = _malloc(surfData.width * surfData.height * 4);
              HEAPU32[surf + 20 >>> 2 >>> 0] = surfData.buffer;
            }
            HEAPU32[surf + 20 >>> 2 >>> 0] = surfData.buffer;
            if (surf == SDL.screen && Module.screenIsReadOnly && surfData.image)
              return 0;
            if (SDL.defaults.discardOnLock) {
              if (!surfData.image) {
                surfData.image = surfData.ctx.createImageData(surfData.width, surfData.height);
              }
              if (!SDL.defaults.opaqueFrontBuffer)
                return;
            } else {
              surfData.image = surfData.ctx.getImageData(0, 0, surfData.width, surfData.height);
            }
            if (surf == SDL.screen && SDL.defaults.opaqueFrontBuffer) {
              var data2 = surfData.image.data;
              var num = data2.length;
              for (var i2 = 0; i2 < num / 4; i2++) {
                data2[i2 * 4 + 3] = 255;
              }
            }
            if (SDL.defaults.copyOnLock && !SDL.defaults.discardOnLock) {
              if (surfData.isFlagSet(2097152)) {
                throw "CopyOnLock is not supported for SDL_LockSurface with SDL_HWPALETTE flag set" + new Error().stack;
              } else {
                HEAPU8.set(surfData.image.data, surfData.buffer >>> 0);
              }
            }
            return 0;
          }
          _SDL_LockSurface.sig = "ip";
          var SDL_ttfContext = () => SDL.ttfContext;
          var SDL_audio = () => SDL.audio;
          var SDL = {
            defaults: {
              width: 320,
              height: 200,
              copyOnLock: true,
              discardOnLock: false,
              opaqueFrontBuffer: true
            },
            version: null,
            surfaces: {},
            canvasPool: [],
            events: [],
            fonts: [null],
            audios: [null],
            rwops: [null],
            music: {
              audio: null,
              volume: 1
            },
            mixerFrequency: 22050,
            mixerFormat: 32784,
            mixerNumChannels: 2,
            mixerChunkSize: 1024,
            channelMinimumNumber: 0,
            GL: false,
            glAttributes: {
              0: 3,
              1: 3,
              2: 2,
              3: 0,
              4: 0,
              5: 1,
              6: 16,
              7: 0,
              8: 0,
              9: 0,
              10: 0,
              11: 0,
              12: 0,
              13: 0,
              14: 0,
              15: 1,
              16: 0,
              17: 0,
              18: 0
            },
            keyboardState: null,
            keyboardMap: {},
            canRequestFullscreen: false,
            isRequestingFullscreen: false,
            textInput: false,
            startTime: null,
            initFlags: 0,
            buttonState: 0,
            modState: 0,
            DOMButtons: [0, 0, 0],
            DOMEventToSDLEvent: {},
            TOUCH_DEFAULT_ID: 0,
            eventHandler: null,
            eventHandlerContext: null,
            eventHandlerTemp: 0,
            keyCodes: {
              16: 1249,
              17: 1248,
              18: 1250,
              20: 1081,
              33: 1099,
              34: 1102,
              35: 1101,
              36: 1098,
              37: 1104,
              38: 1106,
              39: 1103,
              40: 1105,
              44: 316,
              45: 1097,
              46: 127,
              91: 1251,
              93: 1125,
              96: 1122,
              97: 1113,
              98: 1114,
              99: 1115,
              100: 1116,
              101: 1117,
              102: 1118,
              103: 1119,
              104: 1120,
              105: 1121,
              106: 1109,
              107: 1111,
              109: 1110,
              110: 1123,
              111: 1108,
              112: 1082,
              113: 1083,
              114: 1084,
              115: 1085,
              116: 1086,
              117: 1087,
              118: 1088,
              119: 1089,
              120: 1090,
              121: 1091,
              122: 1092,
              123: 1093,
              124: 1128,
              125: 1129,
              126: 1130,
              127: 1131,
              128: 1132,
              129: 1133,
              130: 1134,
              131: 1135,
              132: 1136,
              133: 1137,
              134: 1138,
              135: 1139,
              144: 1107,
              160: 94,
              161: 33,
              162: 34,
              163: 35,
              164: 36,
              165: 37,
              166: 38,
              167: 95,
              168: 40,
              169: 41,
              170: 42,
              171: 43,
              172: 124,
              173: 45,
              174: 123,
              175: 125,
              176: 126,
              181: 127,
              182: 129,
              183: 128,
              188: 44,
              190: 46,
              191: 47,
              192: 96,
              219: 91,
              220: 92,
              221: 93,
              222: 39,
              224: 1251
            },
            scanCodes: {
              8: 42,
              9: 43,
              13: 40,
              27: 41,
              32: 44,
              35: 204,
              39: 53,
              44: 54,
              46: 55,
              47: 56,
              48: 39,
              49: 30,
              50: 31,
              51: 32,
              52: 33,
              53: 34,
              54: 35,
              55: 36,
              56: 37,
              57: 38,
              58: 203,
              59: 51,
              61: 46,
              91: 47,
              92: 49,
              93: 48,
              96: 52,
              97: 4,
              98: 5,
              99: 6,
              100: 7,
              101: 8,
              102: 9,
              103: 10,
              104: 11,
              105: 12,
              106: 13,
              107: 14,
              108: 15,
              109: 16,
              110: 17,
              111: 18,
              112: 19,
              113: 20,
              114: 21,
              115: 22,
              116: 23,
              117: 24,
              118: 25,
              119: 26,
              120: 27,
              121: 28,
              122: 29,
              127: 76,
              305: 224,
              308: 226,
              316: 70
            },
            loadRect: (rect) => ({
              x: HEAP32[rect + 0 >>> 2 >>> 0],
              y: HEAP32[rect + 4 >>> 2 >>> 0],
              w: HEAP32[rect + 8 >>> 2 >>> 0],
              h: HEAP32[rect + 12 >>> 2 >>> 0]
            }),
            updateRect: (rect, r) => {
              HEAP32[rect >>> 2 >>> 0] = r.x;
              HEAP32[rect + 4 >>> 2 >>> 0] = r.y;
              HEAP32[rect + 8 >>> 2 >>> 0] = r.w;
              HEAP32[rect + 12 >>> 2 >>> 0] = r.h;
            },
            intersectionOfRects: (first, second) => {
              var leftX = Math.max(first.x, second.x);
              var leftY = Math.max(first.y, second.y);
              var rightX = Math.min(first.x + first.w, second.x + second.w);
              var rightY = Math.min(first.y + first.h, second.y + second.h);
              return {
                x: leftX,
                y: leftY,
                w: Math.max(leftX, rightX) - leftX,
                h: Math.max(leftY, rightY) - leftY
              };
            },
            checkPixelFormat: (fmt) => {
            },
            loadColorToCSSRGB: (color) => {
              var rgba = HEAP32[color >>> 2 >>> 0];
              return "rgb(" + (rgba & 255) + "," + (rgba >> 8 & 255) + "," + (rgba >> 16 & 255) + ")";
            },
            loadColorToCSSRGBA: (color) => {
              var rgba = HEAP32[color >>> 2 >>> 0];
              return "rgba(" + (rgba & 255) + "," + (rgba >> 8 & 255) + "," + (rgba >> 16 & 255) + "," + (rgba >> 24 & 255) / 255 + ")";
            },
            translateColorToCSSRGBA: (rgba) => "rgba(" + (rgba & 255) + "," + (rgba >> 8 & 255) + "," + (rgba >> 16 & 255) + "," + (rgba >>> 24) / 255 + ")",
            translateRGBAToCSSRGBA: (r, g, b, a) => "rgba(" + (r & 255) + "," + (g & 255) + "," + (b & 255) + "," + (a & 255) / 255 + ")",
            translateRGBAToColor: (r, g, b, a) => r | g << 8 | b << 16 | a << 24,
            makeSurface: (width, height, flags2, usePageCanvas, source, rmask, gmask, bmask, amask) => {
              var is_SDL_HWSURFACE = flags2 & 1;
              var is_SDL_HWPALETTE = flags2 & 2097152;
              var is_SDL_OPENGL = flags2 & 67108864;
              var surf = _malloc(60);
              var pixelFormat = _malloc(44);
              var bpp = is_SDL_HWPALETTE ? 1 : 4;
              var buffer = 0;
              if (!is_SDL_HWSURFACE && !is_SDL_OPENGL) {
                buffer = _malloc(width * height * 4);
              }
              HEAP32[surf >>> 2 >>> 0] = flags2;
              HEAPU32[surf + 4 >>> 2 >>> 0] = pixelFormat;
              HEAP32[surf + 8 >>> 2 >>> 0] = width;
              HEAP32[surf + 12 >>> 2 >>> 0] = height;
              HEAP32[surf + 16 >>> 2 >>> 0] = width * bpp;
              HEAPU32[surf + 20 >>> 2 >>> 0] = buffer;
              HEAP32[surf + 36 >>> 2 >>> 0] = 0;
              HEAP32[surf + 40 >>> 2 >>> 0] = 0;
              HEAP32[surf + 44 >>> 2 >>> 0] = Module["canvas"].width;
              HEAP32[surf + 48 >>> 2 >>> 0] = Module["canvas"].height;
              HEAP32[surf + 56 >>> 2 >>> 0] = 1;
              HEAP32[pixelFormat >>> 2 >>> 0] = -2042224636;
              HEAP32[pixelFormat + 4 >>> 2 >>> 0] = 0;
              HEAP8[pixelFormat + 8 >>> 0 >>> 0] = bpp * 8;
              HEAP8[pixelFormat + 9 >>> 0 >>> 0] = bpp;
              HEAP32[pixelFormat + 12 >>> 2 >>> 0] = rmask || 255;
              HEAP32[pixelFormat + 16 >>> 2 >>> 0] = gmask || 65280;
              HEAP32[pixelFormat + 20 >>> 2 >>> 0] = bmask || 16711680;
              HEAP32[pixelFormat + 24 >>> 2 >>> 0] = amask || 4278190080;
              SDL.GL = SDL.GL || is_SDL_OPENGL;
              var canvas;
              if (!usePageCanvas) {
                if (SDL.canvasPool.length > 0) {
                  canvas = SDL.canvasPool.pop();
                } else {
                  canvas = document.createElement("canvas");
                }
                canvas.width = width;
                canvas.height = height;
              } else {
                canvas = Module["canvas"];
              }
              var webGLContextAttributes = {
                antialias: SDL.glAttributes[13] != 0 && SDL.glAttributes[14] > 1,
                depth: SDL.glAttributes[6] > 0,
                stencil: SDL.glAttributes[7] > 0,
                alpha: SDL.glAttributes[3] > 0
              };
              var ctx = Browser.createContext(canvas, is_SDL_OPENGL, usePageCanvas, webGLContextAttributes);
              SDL.surfaces[surf] = {
                width,
                height,
                canvas,
                ctx,
                surf,
                buffer,
                pixelFormat,
                alpha: 255,
                flags: flags2,
                locked: 0,
                usePageCanvas,
                source,
                isFlagSet: (flag) => flags2 & flag
              };
              return surf;
            },
            copyIndexedColorData: (surfData, rX, rY, rW, rH) => {
              if (!surfData.colors) {
                return;
              }
              var fullWidth = Module["canvas"].width;
              var fullHeight = Module["canvas"].height;
              var startX = rX || 0;
              var startY = rY || 0;
              var endX = (rW || fullWidth - startX) + startX;
              var endY = (rH || fullHeight - startY) + startY;
              var buffer = surfData.buffer;
              if (!surfData.image.data32) {
                surfData.image.data32 = new Uint32Array(surfData.image.data.buffer);
              }
              var data32 = surfData.image.data32;
              var colors32 = surfData.colors32;
              for (var y = startY; y < endY; ++y) {
                var base = y * fullWidth;
                for (var x = startX; x < endX; ++x) {
                  data32[base + x] = colors32[HEAPU8[buffer + base + x >>> 0 >>> 0]];
                }
              }
            },
            freeSurface: (surf) => {
              var refcountPointer = surf + 56;
              var refcount = HEAP32[refcountPointer >>> 2 >>> 0];
              if (refcount > 1) {
                HEAP32[refcountPointer >>> 2 >>> 0] = refcount - 1;
                return;
              }
              var info2 = SDL.surfaces[surf];
              if (!info2.usePageCanvas && info2.canvas)
                SDL.canvasPool.push(info2.canvas);
              if (info2.buffer)
                _free(info2.buffer);
              _free(info2.pixelFormat);
              _free(surf);
              SDL.surfaces[surf] = null;
              if (surf === SDL.screen) {
                SDL.screen = null;
              }
            },
            blitSurface: (src, srcrect, dst, dstrect, scale) => {
              var srcData = SDL.surfaces[src];
              var dstData = SDL.surfaces[dst];
              var sr, dr;
              if (srcrect) {
                sr = SDL.loadRect(srcrect);
              } else {
                sr = {
                  x: 0,
                  y: 0,
                  w: srcData.width,
                  h: srcData.height
                };
              }
              if (dstrect) {
                dr = SDL.loadRect(dstrect);
              } else {
                dr = {
                  x: 0,
                  y: 0,
                  w: srcData.width,
                  h: srcData.height
                };
              }
              if (dstData.clipRect) {
                var widthScale = !scale || sr.w === 0 ? 1 : sr.w / dr.w;
                var heightScale = !scale || sr.h === 0 ? 1 : sr.h / dr.h;
                dr = SDL.intersectionOfRects(dstData.clipRect, dr);
                sr.w = dr.w * widthScale;
                sr.h = dr.h * heightScale;
                if (dstrect) {
                  SDL.updateRect(dstrect, dr);
                }
              }
              var blitw, blith;
              if (scale) {
                blitw = dr.w;
                blith = dr.h;
              } else {
                blitw = sr.w;
                blith = sr.h;
              }
              if (sr.w === 0 || sr.h === 0 || blitw === 0 || blith === 0) {
                return 0;
              }
              var oldAlpha = dstData.ctx.globalAlpha;
              dstData.ctx.globalAlpha = srcData.alpha / 255;
              dstData.ctx.drawImage(srcData.canvas, sr.x, sr.y, sr.w, sr.h, dr.x, dr.y, blitw, blith);
              dstData.ctx.globalAlpha = oldAlpha;
              if (dst != SDL.screen) {
                warnOnce("WARNING: copying canvas data to memory for compatibility");
                _SDL_LockSurface(dst);
                dstData.locked--;
              }
              return 0;
            },
            downFingers: {},
            savedKeydown: null,
            receiveEvent: (event2) => {
              function unpressAllPressedKeys() {
                for (var code in SDL.keyboardMap) {
                  SDL.events.push({
                    type: "keyup",
                    keyCode: SDL.keyboardMap[code]
                  });
                }
              }
              switch (event2.type) {
                case "touchstart":
                case "touchmove": {
                  event2.preventDefault();
                  var touches = [];
                  if (event2.type === "touchstart") {
                    for (var i2 = 0; i2 < event2.touches.length; i2++) {
                      var touch = event2.touches[i2];
                      if (SDL.downFingers[touch.identifier] != true) {
                        SDL.downFingers[touch.identifier] = true;
                        touches.push(touch);
                      }
                    }
                  } else {
                    touches = event2.touches;
                  }
                  var firstTouch = touches[0];
                  if (firstTouch) {
                    if (event2.type == "touchstart") {
                      SDL.DOMButtons[0] = 1;
                    }
                    var mouseEventType;
                    switch (event2.type) {
                      case "touchstart":
                        mouseEventType = "mousedown";
                        break;
                      case "touchmove":
                        mouseEventType = "mousemove";
                        break;
                    }
                    var mouseEvent = {
                      type: mouseEventType,
                      button: 0,
                      pageX: firstTouch.clientX,
                      pageY: firstTouch.clientY
                    };
                    SDL.events.push(mouseEvent);
                  }
                  for (var i2 = 0; i2 < touches.length; i2++) {
                    var touch = touches[i2];
                    SDL.events.push({
                      type: event2.type,
                      touch
                    });
                  }
                  break;
                }
                case "touchend": {
                  event2.preventDefault();
                  for (var i2 = 0; i2 < event2.changedTouches.length; i2++) {
                    var touch = event2.changedTouches[i2];
                    if (SDL.downFingers[touch.identifier] === true) {
                      delete SDL.downFingers[touch.identifier];
                    }
                  }
                  var mouseEvent = {
                    type: "mouseup",
                    button: 0,
                    pageX: event2.changedTouches[0].clientX,
                    pageY: event2.changedTouches[0].clientY
                  };
                  SDL.DOMButtons[0] = 0;
                  SDL.events.push(mouseEvent);
                  for (var i2 = 0; i2 < event2.changedTouches.length; i2++) {
                    var touch = event2.changedTouches[i2];
                    SDL.events.push({
                      type: "touchend",
                      touch
                    });
                  }
                  break;
                }
                case "DOMMouseScroll":
                case "mousewheel":
                case "wheel":
                  var delta = -Browser.getMouseWheelDelta(event2);
                  delta = delta == 0 ? 0 : delta > 0 ? Math.max(delta, 1) : Math.min(delta, -1);
                  var button = delta > 0 ? 3 : 4;
                  SDL.events.push({
                    type: "mousedown",
                    button,
                    pageX: event2.pageX,
                    pageY: event2.pageY
                  });
                  SDL.events.push({
                    type: "mouseup",
                    button,
                    pageX: event2.pageX,
                    pageY: event2.pageY
                  });
                  SDL.events.push({
                    type: "wheel",
                    deltaX: 0,
                    deltaY: delta
                  });
                  event2.preventDefault();
                  break;
                case "mousemove":
                  if (SDL.DOMButtons[0] === 1) {
                    SDL.events.push({
                      type: "touchmove",
                      touch: {
                        identifier: 0,
                        deviceID: -1,
                        pageX: event2.pageX,
                        pageY: event2.pageY
                      }
                    });
                  }
                  if (Browser.pointerLock) {
                    if ("mozMovementX" in event2) {
                      event2["movementX"] = event2["mozMovementX"];
                      event2["movementY"] = event2["mozMovementY"];
                    }
                    if (event2["movementX"] == 0 && event2["movementY"] == 0) {
                      event2.preventDefault();
                      return;
                    }
                  }
                case "keydown":
                case "keyup":
                case "keypress":
                case "mousedown":
                case "mouseup":
                  if (event2.type !== "keydown" || !SDL_unicode() && !SDL.textInput || (event2.keyCode === 8 || event2.keyCode === 9)) {
                    event2.preventDefault();
                  }
                  if (event2.type == "mousedown") {
                    SDL.DOMButtons[event2.button] = 1;
                    SDL.events.push({
                      type: "touchstart",
                      touch: {
                        identifier: 0,
                        deviceID: -1,
                        pageX: event2.pageX,
                        pageY: event2.pageY
                      }
                    });
                  } else if (event2.type == "mouseup") {
                    if (!SDL.DOMButtons[event2.button]) {
                      return;
                    }
                    SDL.events.push({
                      type: "touchend",
                      touch: {
                        identifier: 0,
                        deviceID: -1,
                        pageX: event2.pageX,
                        pageY: event2.pageY
                      }
                    });
                    SDL.DOMButtons[event2.button] = 0;
                  }
                  if (event2.type === "keydown" || event2.type === "mousedown") {
                    SDL.canRequestFullscreen = true;
                  } else if (event2.type === "keyup" || event2.type === "mouseup") {
                    if (SDL.isRequestingFullscreen) {
                      Module["requestFullscreen"](true, true);
                      SDL.isRequestingFullscreen = false;
                    }
                    SDL.canRequestFullscreen = false;
                  }
                  if (event2.type === "keypress" && SDL.savedKeydown) {
                    SDL.savedKeydown.keypressCharCode = event2.charCode;
                    SDL.savedKeydown = null;
                  } else if (event2.type === "keydown") {
                    SDL.savedKeydown = event2;
                  }
                  if (event2.type !== "keypress" || SDL.textInput) {
                    SDL.events.push(event2);
                  }
                  break;
                case "mouseout":
                  for (var i2 = 0; i2 < 3; i2++) {
                    if (SDL.DOMButtons[i2]) {
                      SDL.events.push({
                        type: "mouseup",
                        button: i2,
                        pageX: event2.pageX,
                        pageY: event2.pageY
                      });
                      SDL.DOMButtons[i2] = 0;
                    }
                  }
                  event2.preventDefault();
                  break;
                case "focus":
                  SDL.events.push(event2);
                  event2.preventDefault();
                  break;
                case "blur":
                  SDL.events.push(event2);
                  unpressAllPressedKeys();
                  event2.preventDefault();
                  break;
                case "visibilitychange":
                  SDL.events.push({
                    type: "visibilitychange",
                    visible: !document.hidden
                  });
                  unpressAllPressedKeys();
                  event2.preventDefault();
                  break;
                case "unload":
                  if (Browser.mainLoop.runner) {
                    SDL.events.push(event2);
                    Browser.mainLoop.runner();
                  }
                  return;
                case "resize":
                  SDL.events.push(event2);
                  if (event2.preventDefault) {
                    event2.preventDefault();
                  }
                  break;
              }
              if (SDL.events.length >= 1e4) {
                err("SDL event queue full, dropping events");
                SDL.events = SDL.events.slice(0, 1e4);
              }
              SDL.flushEventsToHandler();
              return;
            },
            lookupKeyCodeForEvent: (event2) => {
              var code = event2.keyCode;
              if (code >= 65 && code <= 90) {
                code += 32;
              } else {
                code = SDL.keyCodes[event2.keyCode] || event2.keyCode;
                if (event2.location === 2 && code >= (224 | 1 << 10) && code <= (227 | 1 << 10)) {
                  code += 4;
                }
              }
              return code;
            },
            handleEvent: (event2) => {
              if (event2.handled)
                return;
              event2.handled = true;
              switch (event2.type) {
                case "touchstart":
                case "touchend":
                case "touchmove": {
                  Browser.calculateMouseEvent(event2);
                  break;
                }
                case "keydown":
                case "keyup": {
                  var down = event2.type === "keydown";
                  var code = SDL.lookupKeyCodeForEvent(event2);
                  HEAP8[SDL.keyboardState + code >>> 0 >>> 0] = down;
                  SDL.modState = (HEAP8[SDL.keyboardState + 1248 >>> 0 >>> 0] ? 64 : 0) | (HEAP8[SDL.keyboardState + 1249 >>> 0 >>> 0] ? 1 : 0) | (HEAP8[SDL.keyboardState + 1250 >>> 0 >>> 0] ? 256 : 0) | (HEAP8[SDL.keyboardState + 1252 >>> 0 >>> 0] ? 128 : 0) | (HEAP8[SDL.keyboardState + 1253 >>> 0 >>> 0] ? 2 : 0) | (HEAP8[SDL.keyboardState + 1254 >>> 0 >>> 0] ? 512 : 0);
                  if (down) {
                    SDL.keyboardMap[code] = event2.keyCode;
                  } else {
                    delete SDL.keyboardMap[code];
                  }
                  break;
                }
                case "mousedown":
                case "mouseup":
                  if (event2.type == "mousedown") {
                    SDL.buttonState |= 1 << event2.button;
                  } else if (event2.type == "mouseup") {
                    SDL.buttonState &= ~(1 << event2.button);
                  }
                case "mousemove": {
                  Browser.calculateMouseEvent(event2);
                  break;
                }
              }
            },
            flushEventsToHandler: () => {
              if (!SDL.eventHandler)
                return;
              while (SDL.pollEvent(SDL.eventHandlerTemp)) {
                getWasmTableEntry(SDL.eventHandler)(SDL.eventHandlerContext, SDL.eventHandlerTemp);
              }
            },
            pollEvent: (ptr2) => {
              if (SDL.initFlags & 512 && SDL.joystickEventState) {
                SDL.queryJoysticks();
              }
              if (ptr2) {
                while (SDL.events.length > 0) {
                  if (SDL.makeCEvent(SDL.events.shift(), ptr2) !== false)
                    return 1;
                }
                return 0;
              }
              return SDL.events.length > 0;
            },
            makeCEvent: (event2, ptr2) => {
              if (typeof event2 == "number") {
                _memcpy(ptr2, event2, 28);
                _free(event2);
                return;
              }
              SDL.handleEvent(event2);
              switch (event2.type) {
                case "keydown":
                case "keyup": {
                  var down = event2.type === "keydown";
                  var key = SDL.lookupKeyCodeForEvent(event2);
                  var scan;
                  if (key >= 1024) {
                    scan = key - 1024;
                  } else {
                    scan = SDL.scanCodes[key] || key;
                  }
                  HEAP32[ptr2 >>> 2 >>> 0] = SDL.DOMEventToSDLEvent[event2.type];
                  HEAP8[ptr2 + 8 >>> 0 >>> 0] = down ? 1 : 0;
                  HEAP8[ptr2 + 9 >>> 0 >>> 0] = 0;
                  HEAP32[ptr2 + 12 >>> 2 >>> 0] = scan;
                  HEAP32[ptr2 + 16 >>> 2 >>> 0] = key;
                  HEAP16[ptr2 + 20 >>> 1 >>> 0] = SDL.modState;
                  HEAP32[ptr2 + 24 >>> 2 >>> 0] = event2.keypressCharCode || key;
                  break;
                }
                case "keypress": {
                  HEAP32[ptr2 >>> 2 >>> 0] = SDL.DOMEventToSDLEvent[event2.type];
                  var cStr = intArrayFromString(String.fromCharCode(event2.charCode));
                  for (var i2 = 0; i2 < cStr.length; ++i2) {
                    HEAP8[ptr2 + (8 + i2) >>> 0 >>> 0] = cStr[i2];
                  }
                  break;
                }
                case "mousedown":
                case "mouseup":
                case "mousemove": {
                  if (event2.type != "mousemove") {
                    var down = event2.type === "mousedown";
                    HEAP32[ptr2 >>> 2 >>> 0] = SDL.DOMEventToSDLEvent[event2.type];
                    HEAP32[ptr2 + 4 >>> 2 >>> 0] = 0;
                    HEAP32[ptr2 + 8 >>> 2 >>> 0] = 0;
                    HEAP32[ptr2 + 12 >>> 2 >>> 0] = 0;
                    HEAP8[ptr2 + 16 >>> 0 >>> 0] = event2.button + 1;
                    HEAP8[ptr2 + 17 >>> 0 >>> 0] = down ? 1 : 0;
                    HEAP32[ptr2 + 20 >>> 2 >>> 0] = Browser.mouseX;
                    HEAP32[ptr2 + 24 >>> 2 >>> 0] = Browser.mouseY;
                  } else {
                    HEAP32[ptr2 >>> 2 >>> 0] = SDL.DOMEventToSDLEvent[event2.type];
                    HEAP32[ptr2 + 4 >>> 2 >>> 0] = 0;
                    HEAP32[ptr2 + 8 >>> 2 >>> 0] = 0;
                    HEAP32[ptr2 + 12 >>> 2 >>> 0] = 0;
                    HEAP32[ptr2 + 16 >>> 2 >>> 0] = SDL.buttonState;
                    HEAP32[ptr2 + 20 >>> 2 >>> 0] = Browser.mouseX;
                    HEAP32[ptr2 + 24 >>> 2 >>> 0] = Browser.mouseY;
                    HEAP32[ptr2 + 28 >>> 2 >>> 0] = Browser.mouseMovementX;
                    HEAP32[ptr2 + 32 >>> 2 >>> 0] = Browser.mouseMovementY;
                  }
                  break;
                }
                case "wheel": {
                  HEAP32[ptr2 >>> 2 >>> 0] = SDL.DOMEventToSDLEvent[event2.type];
                  HEAP32[ptr2 + 16 >>> 2 >>> 0] = event2.deltaX;
                  HEAP32[ptr2 + 20 >>> 2 >>> 0] = event2.deltaY;
                  break;
                }
                case "touchstart":
                case "touchend":
                case "touchmove": {
                  var touch = event2.touch;
                  if (!Browser.touches[touch.identifier])
                    break;
                  var w = Module["canvas"].width;
                  var h = Module["canvas"].height;
                  var x = Browser.touches[touch.identifier].x / w;
                  var y = Browser.touches[touch.identifier].y / h;
                  var lx = Browser.lastTouches[touch.identifier].x / w;
                  var ly = Browser.lastTouches[touch.identifier].y / h;
                  var dx = x - lx;
                  var dy = y - ly;
                  if (touch["deviceID"] === void 0)
                    touch.deviceID = SDL.TOUCH_DEFAULT_ID;
                  if (dx === 0 && dy === 0 && event2.type === "touchmove")
                    return false;
                  HEAP32[ptr2 >>> 2 >>> 0] = SDL.DOMEventToSDLEvent[event2.type];
                  HEAP32[ptr2 + 4 >>> 2 >>> 0] = _SDL_GetTicks();
                  tempI64 = [touch.deviceID >>> 0, (tempDouble = touch.deviceID, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[ptr2 + 8 >>> 2 >>> 0] = tempI64[0], HEAP32[ptr2 + 12 >>> 2 >>> 0] = tempI64[1];
                  tempI64 = [touch.identifier >>> 0, (tempDouble = touch.identifier, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[ptr2 + 16 >>> 2 >>> 0] = tempI64[0], HEAP32[ptr2 + 20 >>> 2 >>> 0] = tempI64[1];
                  HEAPF32[ptr2 + 24 >>> 2 >>> 0] = x;
                  HEAPF32[ptr2 + 28 >>> 2 >>> 0] = y;
                  HEAPF32[ptr2 + 32 >>> 2 >>> 0] = dx;
                  HEAPF32[ptr2 + 36 >>> 2 >>> 0] = dy;
                  if (touch.force !== void 0) {
                    HEAPF32[ptr2 + 40 >>> 2 >>> 0] = touch.force;
                  } else {
                    HEAPF32[ptr2 + 40 >>> 2 >>> 0] = event2.type == "touchend" ? 0 : 1;
                  }
                  break;
                }
                case "unload": {
                  HEAP32[ptr2 >>> 2 >>> 0] = SDL.DOMEventToSDLEvent[event2.type];
                  break;
                }
                case "resize": {
                  HEAP32[ptr2 >>> 2 >>> 0] = SDL.DOMEventToSDLEvent[event2.type];
                  HEAP32[ptr2 + 4 >>> 2 >>> 0] = event2.w;
                  HEAP32[ptr2 + 8 >>> 2 >>> 0] = event2.h;
                  break;
                }
                case "joystick_button_up":
                case "joystick_button_down": {
                  var state = event2.type === "joystick_button_up" ? 0 : 1;
                  HEAP32[ptr2 >>> 2 >>> 0] = SDL.DOMEventToSDLEvent[event2.type];
                  HEAP8[ptr2 + 4 >>> 0 >>> 0] = event2.index;
                  HEAP8[ptr2 + 5 >>> 0 >>> 0] = event2.button;
                  HEAP8[ptr2 + 6 >>> 0 >>> 0] = state;
                  break;
                }
                case "joystick_axis_motion": {
                  HEAP32[ptr2 >>> 2 >>> 0] = SDL.DOMEventToSDLEvent[event2.type];
                  HEAP8[ptr2 + 4 >>> 0 >>> 0] = event2.index;
                  HEAP8[ptr2 + 5 >>> 0 >>> 0] = event2.axis;
                  HEAP32[ptr2 + 8 >>> 2 >>> 0] = SDL.joystickAxisValueConversion(event2.value);
                  break;
                }
                case "focus": {
                  var SDL_WINDOWEVENT_FOCUS_GAINED = 12;
                  HEAP32[ptr2 >>> 2 >>> 0] = SDL.DOMEventToSDLEvent[event2.type];
                  HEAP32[ptr2 + 4 >>> 2 >>> 0] = 0;
                  HEAP8[ptr2 + 8 >>> 0 >>> 0] = SDL_WINDOWEVENT_FOCUS_GAINED;
                  break;
                }
                case "blur": {
                  var SDL_WINDOWEVENT_FOCUS_LOST = 13;
                  HEAP32[ptr2 >>> 2 >>> 0] = SDL.DOMEventToSDLEvent[event2.type];
                  HEAP32[ptr2 + 4 >>> 2 >>> 0] = 0;
                  HEAP8[ptr2 + 8 >>> 0 >>> 0] = SDL_WINDOWEVENT_FOCUS_LOST;
                  break;
                }
                case "visibilitychange": {
                  var SDL_WINDOWEVENT_SHOWN = 1;
                  var SDL_WINDOWEVENT_HIDDEN = 2;
                  var visibilityEventID = event2.visible ? SDL_WINDOWEVENT_SHOWN : SDL_WINDOWEVENT_HIDDEN;
                  HEAP32[ptr2 >>> 2 >>> 0] = SDL.DOMEventToSDLEvent[event2.type];
                  HEAP32[ptr2 + 4 >>> 2 >>> 0] = 0;
                  HEAP8[ptr2 + 8 >>> 0 >>> 0] = visibilityEventID;
                  break;
                }
                default:
                  throw "Unhandled SDL event: " + event2.type;
              }
            },
            makeFontString: (height, fontName) => {
              if (fontName.charAt(0) != "'" && fontName.charAt(0) != '"') {
                fontName = '"' + fontName + '"';
              }
              return height + "px " + fontName + ", serif";
            },
            estimateTextWidth: (fontData, text) => {
              var h = fontData.size;
              var fontString = SDL.makeFontString(h, fontData.name);
              var tempCtx = SDL_ttfContext();
              tempCtx.font = fontString;
              var ret = tempCtx.measureText(text).width | 0;
              return ret;
            },
            allocateChannels: (num) => {
              if (SDL.numChannels && SDL.numChannels >= num && num != 0)
                return;
              SDL.numChannels = num;
              SDL.channels = [];
              for (var i2 = 0; i2 < num; i2++) {
                SDL.channels[i2] = {
                  audio: null,
                  volume: 1
                };
              }
            },
            setGetVolume: (info2, volume) => {
              if (!info2)
                return 0;
              var ret = info2.volume * 128;
              if (volume != -1) {
                info2.volume = Math.min(Math.max(volume, 0), 128) / 128;
                if (info2.audio) {
                  try {
                    info2.audio.volume = info2.volume;
                    if (info2.audio.webAudioGainNode)
                      info2.audio.webAudioGainNode["gain"]["value"] = info2.volume;
                  } catch (e) {
                    err(`setGetVolume failed to set audio volume: ${e}`);
                  }
                }
              }
              return ret;
            },
            setPannerPosition: (info2, x, y, z) => {
              if (!info2)
                return;
              if (info2.audio) {
                if (info2.audio.webAudioPannerNode) {
                  info2.audio.webAudioPannerNode["setPosition"](x, y, z);
                }
              }
            },
            playWebAudio: (audio) => {
              if (!audio)
                return;
              if (audio.webAudioNode)
                return;
              if (!SDL.webAudioAvailable())
                return;
              try {
                var webAudio = audio.resource.webAudio;
                audio.paused = false;
                if (!webAudio.decodedBuffer) {
                  if (webAudio.onDecodeComplete === void 0)
                    abort("Cannot play back audio object that was not loaded");
                  webAudio.onDecodeComplete.push(() => {
                    if (!audio.paused)
                      SDL.playWebAudio(audio);
                  });
                  return;
                }
                audio.webAudioNode = SDL.audioContext["createBufferSource"]();
                audio.webAudioNode["buffer"] = webAudio.decodedBuffer;
                audio.webAudioNode["loop"] = audio.loop;
                audio.webAudioNode["onended"] = audio["onended"];
                audio.webAudioPannerNode = SDL.audioContext["createPanner"]();
                audio.webAudioPannerNode["setPosition"](0, 0, -0.5);
                audio.webAudioPannerNode["panningModel"] = "equalpower";
                audio.webAudioGainNode = SDL.audioContext["createGain"]();
                audio.webAudioGainNode["gain"]["value"] = audio.volume;
                audio.webAudioNode["connect"](audio.webAudioPannerNode);
                audio.webAudioPannerNode["connect"](audio.webAudioGainNode);
                audio.webAudioGainNode["connect"](SDL.audioContext["destination"]);
                audio.webAudioNode["start"](0, audio.currentPosition);
                audio.startTime = SDL.audioContext["currentTime"] - audio.currentPosition;
              } catch (e) {
                err(`playWebAudio failed: ${e}`);
              }
            },
            pauseWebAudio: (audio) => {
              if (!audio)
                return;
              if (audio.webAudioNode) {
                try {
                  audio.currentPosition = (SDL.audioContext["currentTime"] - audio.startTime) % audio.resource.webAudio.decodedBuffer.duration;
                  audio.webAudioNode["onended"] = void 0;
                  audio.webAudioNode.stop(0);
                  audio.webAudioNode = void 0;
                } catch (e) {
                  err(`pauseWebAudio failed: ${e}`);
                }
              }
              audio.paused = true;
            },
            openAudioContext: () => {
              if (!SDL.audioContext) {
                if (typeof AudioContext != "undefined")
                  SDL.audioContext = new AudioContext();
                else if (typeof webkitAudioContext != "undefined")
                  SDL.audioContext = new webkitAudioContext();
              }
            },
            webAudioAvailable: () => !!SDL.audioContext,
            fillWebAudioBufferFromHeap: (heapPtr, sizeSamplesPerChannel, dstAudioBuffer) => {
              var audio = SDL_audio();
              var numChannels = audio.channels;
              for (var c = 0; c < numChannels; ++c) {
                var channelData = dstAudioBuffer["getChannelData"](c);
                if (channelData.length != sizeSamplesPerChannel) {
                  throw "Web Audio output buffer length mismatch! Destination size: " + channelData.length + " samples vs expected " + sizeSamplesPerChannel + " samples!";
                }
                if (audio.format == 32784) {
                  for (var j = 0; j < sizeSamplesPerChannel; ++j) {
                    channelData[j] = HEAP16[heapPtr + (j * numChannels + c) * 2 >>> 1 >>> 0] / 32768;
                  }
                } else if (audio.format == 8) {
                  for (var j = 0; j < sizeSamplesPerChannel; ++j) {
                    var v = HEAP8[heapPtr + (j * numChannels + c) >>> 0 >>> 0];
                    channelData[j] = (v >= 0 ? v - 128 : v + 128) / 128;
                  }
                } else if (audio.format == 33056) {
                  for (var j = 0; j < sizeSamplesPerChannel; ++j) {
                    channelData[j] = HEAPF32[heapPtr + (j * numChannels + c) * 4 >>> 2 >>> 0];
                  }
                } else {
                  throw "Invalid SDL audio format " + audio.format + "!";
                }
              }
            },
            joystickEventState: 1,
            lastJoystickState: {},
            joystickNamePool: {},
            recordJoystickState: (joystick, state) => {
              var buttons = new Array(state.buttons.length);
              for (var i2 = 0; i2 < state.buttons.length; i2++) {
                buttons[i2] = SDL.getJoystickButtonState(state.buttons[i2]);
              }
              SDL.lastJoystickState[joystick] = {
                buttons,
                axes: state.axes.slice(0),
                timestamp: state.timestamp,
                index: state.index,
                id: state.id
              };
            },
            getJoystickButtonState: (button) => {
              if (typeof button == "object") {
                return button["pressed"];
              }
              return button > 0;
            },
            queryJoysticks: () => {
              for (var joystick in SDL.lastJoystickState) {
                var state = SDL.getGamepad(joystick - 1);
                var prevState = SDL.lastJoystickState[joystick];
                if (typeof state == "undefined")
                  return;
                if (state === null)
                  return;
                if (typeof state.timestamp != "number" || state.timestamp != prevState.timestamp || !state.timestamp) {
                  var i2;
                  for (i2 = 0; i2 < state.buttons.length; i2++) {
                    var buttonState = SDL.getJoystickButtonState(state.buttons[i2]);
                    if (buttonState !== prevState.buttons[i2]) {
                      SDL.events.push({
                        type: buttonState ? "joystick_button_down" : "joystick_button_up",
                        joystick,
                        index: joystick - 1,
                        button: i2
                      });
                    }
                  }
                  for (i2 = 0; i2 < state.axes.length; i2++) {
                    if (state.axes[i2] !== prevState.axes[i2]) {
                      SDL.events.push({
                        type: "joystick_axis_motion",
                        joystick,
                        index: joystick - 1,
                        axis: i2,
                        value: state.axes[i2]
                      });
                    }
                  }
                  SDL.recordJoystickState(joystick, state);
                }
              }
            },
            joystickAxisValueConversion: (value) => {
              value = Math.min(1, Math.max(value, -1));
              return Math.ceil((value + 1) * 32767.5 - 32768);
            },
            getGamepads: () => {
              var fcn = navigator.getGamepads || navigator.webkitGamepads || navigator.mozGamepads || navigator.gamepads || navigator.webkitGetGamepads;
              if (fcn !== void 0) {
                return fcn.apply(navigator);
              }
              return [];
            },
            getGamepad: (deviceIndex) => {
              var gamepads = SDL.getGamepads();
              if (gamepads.length > deviceIndex && deviceIndex >= 0) {
                return gamepads[deviceIndex];
              }
              return null;
            }
          };
          var SDL_unicode = () => SDL.unicode;
          function _SDL_Linked_Version() {
            if (SDL.version === null) {
              SDL.version = _malloc(3);
              HEAP8[SDL.version + 0 >>> 0 >>> 0] = 1;
              HEAP8[SDL.version + 1 >>> 0 >>> 0] = 3;
              HEAP8[SDL.version + 2 >>> 0 >>> 0] = 0;
            }
            return SDL.version;
          }
          _SDL_Linked_Version.sig = "p";
          var _SDL_Init = (initFlags) => {
            SDL.startTime = Date.now();
            SDL.initFlags = initFlags;
            if (!Module["doNotCaptureKeyboard"]) {
              var keyboardListeningElement = Module["keyboardListeningElement"] || document;
              keyboardListeningElement.addEventListener("keydown", SDL.receiveEvent);
              keyboardListeningElement.addEventListener("keyup", SDL.receiveEvent);
              keyboardListeningElement.addEventListener("keypress", SDL.receiveEvent);
              window.addEventListener("focus", SDL.receiveEvent);
              window.addEventListener("blur", SDL.receiveEvent);
              document.addEventListener("visibilitychange", SDL.receiveEvent);
            }
            window.addEventListener("unload", SDL.receiveEvent);
            SDL.keyboardState = _malloc(65536);
            zeroMemory(SDL.keyboardState, 65536);
            SDL.DOMEventToSDLEvent["keydown"] = 768;
            SDL.DOMEventToSDLEvent["keyup"] = 769;
            SDL.DOMEventToSDLEvent["keypress"] = 771;
            SDL.DOMEventToSDLEvent["mousedown"] = 1025;
            SDL.DOMEventToSDLEvent["mouseup"] = 1026;
            SDL.DOMEventToSDLEvent["mousemove"] = 1024;
            SDL.DOMEventToSDLEvent["wheel"] = 1027;
            SDL.DOMEventToSDLEvent["touchstart"] = 1792;
            SDL.DOMEventToSDLEvent["touchend"] = 1793;
            SDL.DOMEventToSDLEvent["touchmove"] = 1794;
            SDL.DOMEventToSDLEvent["unload"] = 256;
            SDL.DOMEventToSDLEvent["resize"] = 28673;
            SDL.DOMEventToSDLEvent["visibilitychange"] = 512;
            SDL.DOMEventToSDLEvent["focus"] = 512;
            SDL.DOMEventToSDLEvent["blur"] = 512;
            SDL.DOMEventToSDLEvent["joystick_axis_motion"] = 1536;
            SDL.DOMEventToSDLEvent["joystick_button_down"] = 1539;
            SDL.DOMEventToSDLEvent["joystick_button_up"] = 1540;
            return 0;
          };
          _SDL_Init.sig = "ii";
          var _SDL_WasInit = (flags2) => {
            if (SDL.startTime === null) {
              _SDL_Init(0);
            }
            return 1;
          };
          _SDL_WasInit.sig = "ii";
          function _SDL_GetVideoInfo() {
            var ret = _malloc(20);
            zeroMemory(ret, 3);
            HEAP32[ret + 12 >>> 2 >>> 0] = Module["canvas"].width;
            HEAP32[ret + 16 >>> 2 >>> 0] = Module["canvas"].height;
            return ret;
          }
          _SDL_GetVideoInfo.sig = "p";
          function _SDL_ListModes(format, flags2) {
            format >>>= 0;
            return -1;
          }
          _SDL_ListModes.sig = "ppi";
          var _SDL_VideoModeOK = (width, height, depth, flags2) => depth;
          _SDL_VideoModeOK.sig = "iiiii";
          function _SDL_VideoDriverName(buf, max_size) {
            buf >>>= 0;
            if (SDL.startTime === null) {
              return 0;
            }
            var driverName = [101, 109, 115, 99, 114, 105, 112, 116, 101, 110, 95, 115, 100, 108, 95, 100, 114, 105, 118, 101, 114];
            var index = 0;
            var size = driverName.length;
            if (max_size <= size) {
              size = max_size - 1;
            }
            while (index < size) {
              var value = driverName[index];
              HEAP8[buf + index >>> 0 >>> 0] = value;
              index++;
            }
            HEAP8[buf + index >>> 0 >>> 0] = 0;
            return buf;
          }
          _SDL_VideoDriverName.sig = "ppi";
          var _SDL_AudioDriverName = _SDL_VideoDriverName;
          _SDL_AudioDriverName.sig = "ppi";
          var _SDL_SetVideoMode = function(width, height, depth, flags2) {
            ["touchstart", "touchend", "touchmove", "mousedown", "mouseup", "mousemove", "mousewheel", "wheel", "mouseout", "DOMMouseScroll"].forEach((e) => Module["canvas"].addEventListener(e, SDL.receiveEvent, true));
            var canvas = Module["canvas"];
            if (width == 0 && height == 0) {
              width = canvas.width;
              height = canvas.height;
            }
            if (!SDL.addedResizeListener) {
              SDL.addedResizeListener = true;
              Browser.resizeListeners.push((w, h) => {
                if (!SDL.settingVideoMode) {
                  SDL.receiveEvent({
                    type: "resize",
                    w,
                    h
                  });
                }
              });
            }
            SDL.settingVideoMode = true;
            Browser.setCanvasSize(width, height);
            SDL.settingVideoMode = false;
            if (SDL.screen) {
              SDL.freeSurface(SDL.screen);
              assert(!SDL.screen);
            }
            if (SDL.GL)
              flags2 = flags2 | 67108864;
            SDL.screen = SDL.makeSurface(width, height, flags2, true, "screen");
            return SDL.screen;
          };
          _SDL_SetVideoMode.sig = "piiii";
          function _SDL_GetVideoSurface() {
            return SDL.screen;
          }
          _SDL_GetVideoSurface.sig = "p";
          var _SDL_AudioQuit = () => {
            for (var i2 = 0; i2 < SDL.numChannels; ++i2) {
              var chan = SDL.channels[i2];
              if (chan.audio) {
                chan.audio.pause();
                chan.audio = void 0;
              }
            }
            var audio = SDL.music.audio;
            audio?.pause();
            SDL.music.audio = void 0;
          };
          _SDL_AudioQuit.sig = "v";
          var _SDL_VideoQuit = () => out("SDL_VideoQuit called (and ignored)");
          _SDL_VideoQuit.sig = "v";
          var _SDL_QuitSubSystem = (flags2) => out("SDL_QuitSubSystem called (and ignored)");
          _SDL_QuitSubSystem.sig = "vi";
          var _SDL_Quit = () => {
            _SDL_AudioQuit();
            out("SDL_Quit called (and ignored)");
          };
          _SDL_Quit.sig = "v";
          function _SDL_UnlockSurface(surf) {
            surf >>>= 0;
            assert(!SDL.GL);
            var surfData = SDL.surfaces[surf];
            if (!surfData.locked || --surfData.locked > 0) {
              return;
            }
            if (surfData.isFlagSet(2097152)) {
              SDL.copyIndexedColorData(surfData);
            } else if (!surfData.colors) {
              var data2 = surfData.image.data;
              var buffer = surfData.buffer;
              assert(buffer % 4 == 0, "Invalid buffer offset: " + buffer);
              var src = buffer >> 2;
              var dst = 0;
              var isScreen = surf == SDL.screen;
              var num;
              if (typeof CanvasPixelArray != "undefined" && data2 instanceof CanvasPixelArray) {
                num = data2.length;
                while (dst < num) {
                  var val = HEAP32[src >>> 0];
                  data2[dst] = val & 255;
                  data2[dst + 1] = val >> 8 & 255;
                  data2[dst + 2] = val >> 16 & 255;
                  data2[dst + 3] = isScreen ? 255 : val >> 24 & 255;
                  src++;
                  dst += 4;
                }
              } else {
                var data32 = new Uint32Array(data2.buffer);
                if (isScreen && SDL.defaults.opaqueFrontBuffer) {
                  num = data32.length;
                  data32.set(HEAP32.subarray(src >>> 0, src + num >>> 0));
                  var data8 = new Uint8Array(data2.buffer);
                  var i2 = 3;
                  var j = i2 + 4 * num;
                  if (num % 8 == 0) {
                    while (i2 < j) {
                      data8[i2] = 255;
                      i2 = i2 + 4 | 0;
                      data8[i2] = 255;
                      i2 = i2 + 4 | 0;
                      data8[i2] = 255;
                      i2 = i2 + 4 | 0;
                      data8[i2] = 255;
                      i2 = i2 + 4 | 0;
                      data8[i2] = 255;
                      i2 = i2 + 4 | 0;
                      data8[i2] = 255;
                      i2 = i2 + 4 | 0;
                      data8[i2] = 255;
                      i2 = i2 + 4 | 0;
                      data8[i2] = 255;
                      i2 = i2 + 4 | 0;
                    }
                  } else {
                    while (i2 < j) {
                      data8[i2] = 255;
                      i2 = i2 + 4 | 0;
                    }
                  }
                } else {
                  data32.set(HEAP32.subarray(src >>> 0, src + data32.length >>> 0));
                }
              }
            } else {
              var width = Module["canvas"].width;
              var height = Module["canvas"].height;
              var s2 = surfData.buffer;
              var data2 = surfData.image.data;
              var colors = surfData.colors;
              for (var y = 0; y < height; y++) {
                var base = y * width * 4;
                for (var x = 0; x < width; x++) {
                  var val = HEAPU8[s2++ >>> 0 >>> 0] * 4;
                  var start2 = base + x * 4;
                  data2[start2] = colors[val];
                  data2[start2 + 1] = colors[val + 1];
                  data2[start2 + 2] = colors[val + 2];
                }
                s2 += width * 3;
              }
            }
            surfData.ctx.putImageData(surfData.image, 0, 0);
          }
          _SDL_UnlockSurface.sig = "vp";
          function _SDL_Flip(surf) {
            surf >>>= 0;
          }
          _SDL_Flip.sig = "ip";
          function _SDL_UpdateRect(surf, x, y, w, h) {
            surf >>>= 0;
          }
          _SDL_UpdateRect.sig = "vpiiii";
          function _SDL_UpdateRects(surf, numrects, rects) {
            surf >>>= 0;
            rects >>>= 0;
          }
          _SDL_UpdateRects.sig = "vpip";
          var _SDL_Delay = (delay) => {
            if (!ENVIRONMENT_IS_WORKER)
              abort("SDL_Delay called on the main thread! Potential infinite loop, quitting. (consider building with async support like ASYNCIFY)");
            var now = Date.now();
            while (Date.now() - now < delay) {
            }
          };
          _SDL_Delay.sig = "vi";
          function _SDL_WM_SetCaption(title, icon) {
            title >>>= 0;
            icon >>>= 0;
            if (title) {
              _emscripten_set_window_title(title);
            }
            icon && (icon = UTF8ToString(icon));
          }
          _SDL_WM_SetCaption.sig = "vpp";
          var _SDL_EnableKeyRepeat = (delay, interval) => {
          };
          _SDL_EnableKeyRepeat.sig = "iii";
          function _SDL_GetKeyboardState(numKeys) {
            numKeys >>>= 0;
            if (numKeys) {
              HEAP32[numKeys >>> 2 >>> 0] = 65536;
            }
            return SDL.keyboardState;
          }
          _SDL_GetKeyboardState.sig = "pp";
          var _SDL_GetKeyState = () => _SDL_GetKeyboardState(0);
          function _SDL_GetKeyName(key) {
            SDL.keyName || (SDL.keyName = stringToNewUTF8("unknown key"));
            return SDL.keyName;
          }
          _SDL_GetKeyName.sig = "pi";
          var _SDL_GetModState = () => SDL.modState;
          _SDL_GetModState.sig = "i";
          function _SDL_GetMouseState(x, y) {
            x >>>= 0;
            y >>>= 0;
            if (x)
              HEAP32[x >>> 2 >>> 0] = Browser.mouseX;
            if (y)
              HEAP32[y >>> 2 >>> 0] = Browser.mouseY;
            return SDL.buttonState;
          }
          _SDL_GetMouseState.sig = "ipp";
          var _SDL_WarpMouse = (x, y) => {
          };
          _SDL_WarpMouse.sig = "vii";
          var _SDL_ShowCursor = (toggle) => {
            switch (toggle) {
              case 0:
                if (Browser.isFullscreen) {
                  Module["canvas"].requestPointerLock();
                  return 0;
                }
                return 1;
              case 1:
                Module["canvas"].exitPointerLock();
                return 1;
              case -1:
                return !Browser.pointerLock;
              default:
                err(`SDL_ShowCursor called with unknown toggle parameter value: ${toggle}`);
                break;
            }
          };
          _SDL_ShowCursor.sig = "ii";
          function _SDL_GetError() {
            SDL.errorMessage || (SDL.errorMessage = stringToNewUTF8("unknown SDL-emscripten error"));
            return SDL.errorMessage;
          }
          _SDL_GetError.sig = "p";
          function _SDL_SetError(fmt, varargs) {
            fmt >>>= 0;
            varargs >>>= 0;
          }
          _SDL_SetError.sig = "vpp";
          function _SDL_CreateRGBSurface(flags2, width, height, depth, rmask, gmask, bmask, amask) {
            return SDL.makeSurface(width, height, flags2, false, "CreateRGBSurface", rmask, gmask, bmask, amask);
          }
          _SDL_CreateRGBSurface.sig = "piiiiiiii";
          function _SDL_CreateRGBSurfaceFrom(pixels, width, height, depth, pitch, rmask, gmask, bmask, amask) {
            pixels >>>= 0;
            var surf = SDL.makeSurface(width, height, 0, false, "CreateRGBSurfaceFrom", rmask, gmask, bmask, amask);
            if (depth !== 32) {
              err("TODO: Partially unimplemented SDL_CreateRGBSurfaceFrom called!");
              return surf;
            }
            var data2 = SDL.surfaces[surf];
            var image = data2.ctx.createImageData(width, height);
            var pitchOfDst = width * 4;
            for (var row = 0; row < height; ++row) {
              var baseOfSrc = row * pitch;
              var baseOfDst = row * pitchOfDst;
              for (var col = 0; col < width * 4; ++col) {
                image.data[baseOfDst + col] = HEAPU8[pixels + (baseOfDst + col) >>> 0 >>> 0];
              }
            }
            data2.ctx.putImageData(image, 0, 0);
            return surf;
          }
          _SDL_CreateRGBSurfaceFrom.sig = "ppiiiiiiii";
          function _SDL_ConvertSurface(surf, format, flags2) {
            surf >>>= 0;
            format >>>= 0;
            if (format) {
              SDL.checkPixelFormat(format);
            }
            var oldData = SDL.surfaces[surf];
            var ret = SDL.makeSurface(oldData.width, oldData.height, oldData.flags, false, "copy:" + oldData.source);
            var newData = SDL.surfaces[ret];
            newData.ctx.globalCompositeOperation = "copy";
            newData.ctx.drawImage(oldData.canvas, 0, 0);
            newData.ctx.globalCompositeOperation = oldData.ctx.globalCompositeOperation;
            return ret;
          }
          _SDL_ConvertSurface.sig = "pppi";
          function _SDL_DisplayFormatAlpha(surf) {
            surf >>>= 0;
            return _SDL_ConvertSurface(surf, 0, 0);
          }
          _SDL_DisplayFormatAlpha.sig = "pp";
          function _SDL_FreeSurface(surf) {
            surf >>>= 0;
            if (surf)
              SDL.freeSurface(surf);
          }
          _SDL_FreeSurface.sig = "vp";
          function _SDL_UpperBlit(src, srcrect, dst, dstrect) {
            src >>>= 0;
            srcrect >>>= 0;
            dst >>>= 0;
            dstrect >>>= 0;
            return SDL.blitSurface(src, srcrect, dst, dstrect, false);
          }
          _SDL_UpperBlit.sig = "ipppp";
          function _SDL_UpperBlitScaled(src, srcrect, dst, dstrect) {
            src >>>= 0;
            srcrect >>>= 0;
            dst >>>= 0;
            dstrect >>>= 0;
            return SDL.blitSurface(src, srcrect, dst, dstrect, true);
          }
          _SDL_UpperBlitScaled.sig = "ipppp";
          var _SDL_LowerBlit = _SDL_UpperBlit;
          _SDL_LowerBlit.sig = "ipppp";
          var _SDL_LowerBlitScaled = _SDL_UpperBlitScaled;
          _SDL_LowerBlitScaled.sig = "ipppp";
          function _SDL_GetClipRect(surf, rect) {
            surf >>>= 0;
            rect >>>= 0;
            assert(rect);
            var surfData = SDL.surfaces[surf];
            var r = surfData.clipRect || {
              x: 0,
              y: 0,
              w: surfData.width,
              h: surfData.height
            };
            SDL.updateRect(rect, r);
          }
          _SDL_GetClipRect.sig = "vpp";
          function _SDL_SetClipRect(surf, rect) {
            surf >>>= 0;
            rect >>>= 0;
            var surfData = SDL.surfaces[surf];
            if (rect) {
              surfData.clipRect = SDL.intersectionOfRects({
                x: 0,
                y: 0,
                w: surfData.width,
                h: surfData.height
              }, SDL.loadRect(rect));
            } else {
              delete surfData.clipRect;
            }
          }
          _SDL_SetClipRect.sig = "ipp";
          function _SDL_FillRect(surf, rect, color) {
            surf >>>= 0;
            rect >>>= 0;
            var surfData = SDL.surfaces[surf];
            assert(!surfData.locked);
            if (surfData.isFlagSet(2097152)) {
              color = surfData.colors32[color];
            }
            var r = rect ? SDL.loadRect(rect) : {
              x: 0,
              y: 0,
              w: surfData.width,
              h: surfData.height
            };
            if (surfData.clipRect) {
              r = SDL.intersectionOfRects(surfData.clipRect, r);
              if (rect) {
                SDL.updateRect(rect, r);
              }
            }
            surfData.ctx.save();
            surfData.ctx.fillStyle = SDL.translateColorToCSSRGBA(color);
            surfData.ctx.fillRect(r.x, r.y, r.w, r.h);
            surfData.ctx.restore();
            return 0;
          }
          _SDL_FillRect.sig = "ippi";
          function _zoomSurface(src, x, y, smooth) {
            src >>>= 0;
            var srcData = SDL.surfaces[src];
            var w = srcData.width * x;
            var h = srcData.height * y;
            var ret = SDL.makeSurface(Math.abs(w), Math.abs(h), srcData.flags, false, "zoomSurface");
            var dstData = SDL.surfaces[ret];
            if (x >= 0 && y >= 0)
              dstData.ctx.drawImage(srcData.canvas, 0, 0, w, h);
            else {
              dstData.ctx.save();
              dstData.ctx.scale(x < 0 ? -1 : 1, y < 0 ? -1 : 1);
              dstData.ctx.drawImage(srcData.canvas, w < 0 ? w : 0, h < 0 ? h : 0, Math.abs(w), Math.abs(h));
              dstData.ctx.restore();
            }
            return ret;
          }
          _zoomSurface.sig = "ppddi";
          function _rotozoomSurface(src, angle, zoom, smooth) {
            src >>>= 0;
            if (angle % 360 === 0) {
              return _zoomSurface(src, zoom, zoom, smooth);
            }
            var srcData = SDL.surfaces[src];
            var w = srcData.width * zoom;
            var h = srcData.height * zoom;
            var diagonal = Math.ceil(Math.sqrt(Math.pow(w, 2) + Math.pow(h, 2)));
            var ret = SDL.makeSurface(diagonal, diagonal, srcData.flags, false, "rotozoomSurface");
            var dstData = SDL.surfaces[ret];
            dstData.ctx.translate(diagonal / 2, diagonal / 2);
            dstData.ctx.rotate(-angle * Math.PI / 180);
            dstData.ctx.drawImage(srcData.canvas, -w / 2, -h / 2, w, h);
            return ret;
          }
          _rotozoomSurface.sig = "ppddi";
          function _SDL_SetAlpha(surf, flag, alpha) {
            surf >>>= 0;
            var surfData = SDL.surfaces[surf];
            surfData.alpha = alpha;
            if (!(flag & 65536)) {
              surfData.alpha = 255;
            }
          }
          _SDL_SetAlpha.sig = "ipii";
          function _SDL_SetColorKey(surf, flag, key) {
            surf >>>= 0;
            warnOnce("SDL_SetColorKey is a no-op for performance reasons");
            return 0;
          }
          _SDL_SetColorKey.sig = "ipii";
          function _SDL_PollEvent(ptr2) {
            ptr2 >>>= 0;
            return SDL.pollEvent(ptr2);
          }
          _SDL_PollEvent.sig = "ip";
          function _SDL_PushEvent(ptr2) {
            ptr2 >>>= 0;
            var copy = _malloc(28);
            _memcpy(copy, ptr2, 28);
            SDL.events.push(copy);
            return 0;
          }
          _SDL_PushEvent.sig = "ip";
          function _SDL_PeepEvents(events, requestedEventCount, action, from, to) {
            events >>>= 0;
            switch (action) {
              case 2: {
                assert(requestedEventCount == 1);
                var index = 0;
                var retrievedEventCount = 0;
                while (index < SDL.events.length && retrievedEventCount < requestedEventCount) {
                  var event2 = SDL.events[index];
                  var type = SDL.DOMEventToSDLEvent[event2.type];
                  if (from <= type && type <= to) {
                    if (SDL.makeCEvent(event2, events) === false) {
                      index++;
                    } else {
                      SDL.events.splice(index, 1);
                      retrievedEventCount++;
                    }
                  } else {
                    index++;
                  }
                }
                return retrievedEventCount;
              }
              default:
                throw "SDL_PeepEvents does not yet support that action: " + action;
            }
          }
          _SDL_PeepEvents.sig = "ipiiii";
          var _SDL_PumpEvents = () => SDL.events.forEach(SDL.handleEvent);
          _SDL_PumpEvents.sig = "v";
          function _emscripten_SDL_SetEventHandler(handler, userdata) {
            handler >>>= 0;
            userdata >>>= 0;
            SDL.eventHandler = handler;
            SDL.eventHandlerContext = userdata;
            if (!SDL.eventHandlerTemp)
              SDL.eventHandlerTemp = _malloc(28);
          }
          _emscripten_SDL_SetEventHandler.sig = "vpp";
          function _SDL_SetColors(surf, colors, firstColor, nColors) {
            surf >>>= 0;
            colors >>>= 0;
            var surfData = SDL.surfaces[surf];
            if (!surfData.colors) {
              var buffer = new ArrayBuffer(256 * 4);
              surfData.colors = new Uint8Array(buffer);
              surfData.colors32 = new Uint32Array(buffer);
            }
            for (var i2 = 0; i2 < nColors; ++i2) {
              var index = (firstColor + i2) * 4;
              surfData.colors[index] = HEAPU8[colors + i2 * 4 >>> 0 >>> 0];
              surfData.colors[index + 1] = HEAPU8[colors + (i2 * 4 + 1) >>> 0 >>> 0];
              surfData.colors[index + 2] = HEAPU8[colors + (i2 * 4 + 2) >>> 0 >>> 0];
              surfData.colors[index + 3] = 255;
            }
            return 1;
          }
          _SDL_SetColors.sig = "ippii";
          function _SDL_SetPalette(surf, flags2, colors, firstColor, nColors) {
            surf >>>= 0;
            colors >>>= 0;
            return _SDL_SetColors(surf, colors, firstColor, nColors);
          }
          _SDL_SetPalette.sig = "ipipii";
          function _SDL_MapRGB(fmt, r, g, b) {
            fmt >>>= 0;
            SDL.checkPixelFormat(fmt);
            return r & 255 | (g & 255) << 8 | (b & 255) << 16 | 4278190080;
          }
          _SDL_MapRGB.sig = "ipiii";
          function _SDL_MapRGBA(fmt, r, g, b, a) {
            fmt >>>= 0;
            SDL.checkPixelFormat(fmt);
            return r & 255 | (g & 255) << 8 | (b & 255) << 16 | (a & 255) << 24;
          }
          _SDL_MapRGBA.sig = "ipiiii";
          function _SDL_GetRGB(pixel, fmt, r, g, b) {
            fmt >>>= 0;
            r >>>= 0;
            g >>>= 0;
            b >>>= 0;
            SDL.checkPixelFormat(fmt);
            if (r) {
              HEAP8[r >>> 0 >>> 0] = pixel & 255;
            }
            if (g) {
              HEAP8[g >>> 0 >>> 0] = pixel >> 8 & 255;
            }
            if (b) {
              HEAP8[b >>> 0 >>> 0] = pixel >> 16 & 255;
            }
          }
          _SDL_GetRGB.sig = "vipppp";
          function _SDL_GetRGBA(pixel, fmt, r, g, b, a) {
            fmt >>>= 0;
            r >>>= 0;
            g >>>= 0;
            b >>>= 0;
            a >>>= 0;
            SDL.checkPixelFormat(fmt);
            if (r) {
              HEAP8[r >>> 0 >>> 0] = pixel & 255;
            }
            if (g) {
              HEAP8[g >>> 0 >>> 0] = pixel >> 8 & 255;
            }
            if (b) {
              HEAP8[b >>> 0 >>> 0] = pixel >> 16 & 255;
            }
            if (a) {
              HEAP8[a >>> 0 >>> 0] = pixel >> 24 & 255;
            }
          }
          _SDL_GetRGBA.sig = "vippppp";
          var _SDL_GetAppState = () => {
            var state = 0;
            if (Browser.pointerLock) {
              state |= 1;
            }
            if (document.hasFocus()) {
              state |= 2;
            }
            state |= 4;
            return state;
          };
          _SDL_GetAppState.sig = "i";
          var _SDL_WM_GrabInput = () => {
          };
          _SDL_WM_GrabInput.sig = "ii";
          function _SDL_WM_ToggleFullScreen(surf) {
            surf >>>= 0;
            if (Browser.exitFullscreen()) {
              return 1;
            }
            if (!SDL.canRequestFullscreen) {
              return 0;
            }
            SDL.isRequestingFullscreen = true;
            return 1;
          }
          _SDL_WM_ToggleFullScreen.sig = "ip";
          var _IMG_Init = (flags2) => flags2;
          _IMG_Init.sig = "ii";
          function _SDL_FreeRW(rwopsID) {
            rwopsID >>>= 0;
            SDL.rwops[rwopsID] = null;
            while (SDL.rwops.length > 0 && SDL.rwops[SDL.rwops.length - 1] === null) {
              SDL.rwops.pop();
            }
          }
          _SDL_FreeRW.sig = "vp";
          var _IMG_Load_RW = function(rwopsID, freeSrc) {
            rwopsID >>>= 0;
            try {
              var cleanup = () => {
                if (rwops && freeSrc)
                  _SDL_FreeRW(rwopsID);
              };
              var addCleanup = (func2) => {
                var old = cleanup;
                cleanup = () => {
                  old();
                  func2();
                };
              };
              var callStbImage = (func2, params) => withStackSave(() => {
                var x = stackAlloc(4);
                var y = stackAlloc(4);
                var comp = stackAlloc(4);
                var data3 = Module["_" + func2].apply(null, params.concat([x, y, comp, 0]));
                if (!data3)
                  return null;
                addCleanup(() => Module["_stbi_image_free"](data3));
                return {
                  rawData: true,
                  data: data3,
                  width: HEAP32[x >>> 2 >>> 0],
                  height: HEAP32[y >>> 2 >>> 0],
                  size: HEAP32[x >>> 2 >>> 0] * HEAP32[y >>> 2 >>> 0] * HEAP32[comp >>> 2 >>> 0],
                  bpp: HEAP32[comp >>> 2 >>> 0]
                };
              });
              var rwops = SDL.rwops[rwopsID];
              if (rwops === void 0) {
                return 0;
              }
              var raw;
              var filename = rwops.filename;
              if (filename === void 0) {
                warnOnce("Only file names that have been preloaded are supported for IMG_Load_RW. Consider using STB_IMAGE=1 if you want synchronous image decoding (see settings.js), or package files with --use-preload-plugins");
                return 0;
              }
              if (!raw) {
                filename = PATH_FS.resolve(filename);
                raw = preloadedImages[filename];
                if (!raw) {
                  if (raw === null)
                    err("Trying to reuse preloaded image, but freePreloadedMediaOnUse is set!");
                  warnOnce("Cannot find preloaded image " + filename);
                  warnOnce("Cannot find preloaded image " + filename + ". Consider using STB_IMAGE=1 if you want synchronous image decoding (see settings.js), or package files with --use-preload-plugins");
                  return 0;
                } else if (Module["freePreloadedMediaOnUse"]) {
                  preloadedImages[filename] = null;
                }
              }
              var surf = SDL.makeSurface(raw.width, raw.height, 0, false, "load:" + filename);
              var surfData = SDL.surfaces[surf];
              surfData.ctx.globalCompositeOperation = "copy";
              if (!raw.rawData) {
                surfData.ctx.drawImage(raw, 0, 0, raw.width, raw.height, 0, 0, raw.width, raw.height);
              } else {
                var imageData = surfData.ctx.getImageData(0, 0, surfData.width, surfData.height);
                if (raw.bpp == 4) {
                  imageData.data.set(HEAPU8.subarray(raw.data >>> 0, raw.data + raw.size >>> 0));
                } else if (raw.bpp == 3) {
                  var pixels = raw.size / 3;
                  var data2 = imageData.data;
                  var sourcePtr = raw.data;
                  var destPtr = 0;
                  for (var i2 = 0; i2 < pixels; i2++) {
                    data2[destPtr++] = HEAPU8[sourcePtr++ >>> 0 >>> 0];
                    data2[destPtr++] = HEAPU8[sourcePtr++ >>> 0 >>> 0];
                    data2[destPtr++] = HEAPU8[sourcePtr++ >>> 0 >>> 0];
                    data2[destPtr++] = 255;
                  }
                } else if (raw.bpp == 2) {
                  var pixels = raw.size;
                  var data2 = imageData.data;
                  var sourcePtr = raw.data;
                  var destPtr = 0;
                  for (var i2 = 0; i2 < pixels; i2++) {
                    var gray = HEAPU8[sourcePtr++ >>> 0 >>> 0];
                    var alpha = HEAPU8[sourcePtr++ >>> 0 >>> 0];
                    data2[destPtr++] = gray;
                    data2[destPtr++] = gray;
                    data2[destPtr++] = gray;
                    data2[destPtr++] = alpha;
                  }
                } else if (raw.bpp == 1) {
                  var pixels = raw.size;
                  var data2 = imageData.data;
                  var sourcePtr = raw.data;
                  var destPtr = 0;
                  for (var i2 = 0; i2 < pixels; i2++) {
                    var value = HEAPU8[sourcePtr++ >>> 0 >>> 0];
                    data2[destPtr++] = value;
                    data2[destPtr++] = value;
                    data2[destPtr++] = value;
                    data2[destPtr++] = 255;
                  }
                } else {
                  err(`cannot handle bpp ${raw.bpp}`);
                  return 0;
                }
                surfData.ctx.putImageData(imageData, 0, 0);
              }
              surfData.ctx.globalCompositeOperation = "source-over";
              _SDL_LockSurface(surf);
              surfData.locked--;
              if (SDL.GL) {
                surfData.canvas = surfData.ctx = null;
              }
              return surf;
            } finally {
              cleanup();
            }
          };
          _IMG_Load_RW.sig = "ppi";
          var _SDL_LoadBMP_RW = _IMG_Load_RW;
          _SDL_LoadBMP_RW.sig = "ppi";
          function _SDL_RWFromFile(_name, mode) {
            _name >>>= 0;
            mode >>>= 0;
            var id = SDL.rwops.length;
            var filename = UTF8ToString(_name);
            SDL.rwops.push({
              filename,
              mimetype: Browser.getMimetype(filename)
            });
            return id;
          }
          _SDL_RWFromFile.sig = "ppp";
          function _IMG_Load(filename) {
            filename >>>= 0;
            var rwops = _SDL_RWFromFile(filename, 0);
            var result = _IMG_Load_RW(rwops, 1);
            return result;
          }
          _IMG_Load.sig = "pp";
          var _IMG_Quit = () => out("IMG_Quit called (and ignored)");
          _IMG_Quit.sig = "v";
          function _SDL_OpenAudio(desired, obtained) {
            desired >>>= 0;
            obtained >>>= 0;
            try {
              SDL.audio = {
                freq: HEAPU32[desired >>> 2 >>> 0],
                format: HEAPU16[desired + 4 >>> 1 >>> 0],
                channels: HEAPU8[desired + 6 >>> 0 >>> 0],
                samples: HEAPU16[desired + 8 >>> 1 >>> 0],
                callback: HEAPU32[desired + 16 >>> 2 >>> 0],
                userdata: HEAPU32[desired + 20 >>> 2 >>> 0],
                paused: true,
                timer: null
              };
              if (SDL.audio.format == 8) {
                SDL.audio.silence = 128;
              } else if (SDL.audio.format == 32784) {
                SDL.audio.silence = 0;
              } else if (SDL.audio.format == 33056) {
                SDL.audio.silence = 0;
              } else {
                throw "Invalid SDL audio format " + SDL.audio.format + "!";
              }
              if (SDL.audio.freq <= 0) {
                throw "Unsupported sound frequency " + SDL.audio.freq + "!";
              } else if (SDL.audio.freq <= 22050) {
                SDL.audio.freq = 22050;
              } else if (SDL.audio.freq <= 32e3) {
                SDL.audio.freq = 32e3;
              } else if (SDL.audio.freq <= 44100) {
                SDL.audio.freq = 44100;
              } else if (SDL.audio.freq <= 48e3) {
                SDL.audio.freq = 48e3;
              } else if (SDL.audio.freq <= 96e3) {
                SDL.audio.freq = 96e3;
              } else {
                throw `Unsupported sound frequency ${SDL.audio.freq}!`;
              }
              if (SDL.audio.channels == 0) {
                SDL.audio.channels = 1;
              } else if (SDL.audio.channels < 0 || SDL.audio.channels > 32) {
                throw `Unsupported number of audio channels for SDL audio: ${SDL.audio.channels}!`;
              } else if (SDL.audio.channels != 1 && SDL.audio.channels != 2) {
                out(`Warning: Using untested number of audio channels ${SDL.audio.channels}`);
              }
              if (SDL.audio.samples < 128 || SDL.audio.samples > 524288) {
                throw `Unsupported audio callback buffer size ${SDL.audio.samples}!`;
              } else if ((SDL.audio.samples & SDL.audio.samples - 1) != 0) {
                throw `Audio callback buffer size ${SDL.audio.samples} must be a power-of-two!`;
              }
              var totalSamples = SDL.audio.samples * SDL.audio.channels;
              if (SDL.audio.format == 8) {
                SDL.audio.bytesPerSample = 1;
              } else if (SDL.audio.format == 32784) {
                SDL.audio.bytesPerSample = 2;
              } else if (SDL.audio.format == 33056) {
                SDL.audio.bytesPerSample = 4;
              } else {
                throw `Invalid SDL audio format ${SDL.audio.format}!`;
              }
              SDL.audio.bufferSize = totalSamples * SDL.audio.bytesPerSample;
              SDL.audio.bufferDurationSecs = SDL.audio.bufferSize / SDL.audio.bytesPerSample / SDL.audio.channels / SDL.audio.freq;
              SDL.audio.bufferingDelay = 50 / 1e3;
              SDL.audio.buffer = _malloc(SDL.audio.bufferSize);
              SDL.audio.numSimultaneouslyQueuedBuffers = Module["SDL_numSimultaneouslyQueuedBuffers"] || 5;
              SDL.audio.queueNewAudioData = () => {
                if (!SDL.audio)
                  return;
                for (var i2 = 0; i2 < SDL.audio.numSimultaneouslyQueuedBuffers; ++i2) {
                  var secsUntilNextPlayStart = SDL.audio.nextPlayTime - SDL.audioContext["currentTime"];
                  if (secsUntilNextPlayStart >= SDL.audio.bufferingDelay + SDL.audio.bufferDurationSecs * SDL.audio.numSimultaneouslyQueuedBuffers)
                    return;
                  getWasmTableEntry(SDL.audio.callback)(SDL.audio.userdata, SDL.audio.buffer, SDL.audio.bufferSize);
                  SDL.audio.pushAudio(SDL.audio.buffer, SDL.audio.bufferSize);
                }
              };
              SDL.audio.caller = () => {
                if (!SDL.audio)
                  return;
                --SDL.audio.numAudioTimersPending;
                SDL.audio.queueNewAudioData();
                var secsUntilNextPlayStart = SDL.audio.nextPlayTime - SDL.audioContext["currentTime"];
                var preemptBufferFeedSecs = SDL.audio.bufferDurationSecs / 2;
                if (SDL.audio.numAudioTimersPending < SDL.audio.numSimultaneouslyQueuedBuffers) {
                  ++SDL.audio.numAudioTimersPending;
                  SDL.audio.timer = safeSetTimeout(SDL.audio.caller, Math.max(0, 1e3 * (secsUntilNextPlayStart - preemptBufferFeedSecs)));
                  if (SDL.audio.numAudioTimersPending < SDL.audio.numSimultaneouslyQueuedBuffers) {
                    ++SDL.audio.numAudioTimersPending;
                    safeSetTimeout(SDL.audio.caller, 1);
                  }
                }
              };
              SDL.audio.audioOutput = new Audio();
              SDL.openAudioContext();
              if (!SDL.audioContext)
                throw "Web Audio API is not available!";
              autoResumeAudioContext(SDL.audioContext);
              SDL.audio.nextPlayTime = 0;
              SDL.audio.pushAudio = function(ptr2, sizeBytes) {
                try {
                  if (SDL.audio.paused)
                    return;
                  var sizeSamples = sizeBytes / SDL.audio.bytesPerSample;
                  var sizeSamplesPerChannel = sizeSamples / SDL.audio.channels;
                  if (sizeSamplesPerChannel != SDL.audio.samples) {
                    throw "Received mismatching audio buffer size!";
                  }
                  var source = SDL.audioContext["createBufferSource"]();
                  var soundBuffer = SDL.audioContext["createBuffer"](SDL.audio.channels, sizeSamplesPerChannel, SDL.audio.freq);
                  source["connect"](SDL.audioContext["destination"]);
                  SDL.fillWebAudioBufferFromHeap(ptr2, sizeSamplesPerChannel, soundBuffer);
                  source["buffer"] = soundBuffer;
                  var curtime = SDL.audioContext["currentTime"];
                  var playtime = Math.max(curtime + SDL.audio.bufferingDelay, SDL.audio.nextPlayTime);
                  if (typeof source["start"] != "undefined") {
                    source["start"](playtime);
                  } else if (typeof source["noteOn"] != "undefined") {
                    source["noteOn"](playtime);
                  }
                  SDL.audio.nextPlayTime = playtime + SDL.audio.bufferDurationSecs;
                } catch (e) {
                  err(`Web Audio API error playing back audio: ${e.toString()}`);
                }
              };
              if (obtained) {
                HEAP32[obtained >>> 2 >>> 0] = SDL.audio.freq;
                HEAP16[obtained + 4 >>> 1 >>> 0] = SDL.audio.format;
                HEAP8[obtained + 6 >>> 0 >>> 0] = SDL.audio.channels;
                HEAP8[obtained + 7 >>> 0 >>> 0] = SDL.audio.silence;
                HEAP16[obtained + 8 >>> 1 >>> 0] = SDL.audio.samples;
                HEAPU32[obtained + 16 >>> 2 >>> 0] = SDL.audio.callback;
                HEAPU32[obtained + 20 >>> 2 >>> 0] = SDL.audio.userdata;
              }
              SDL.allocateChannels(32);
            } catch (e) {
              err(`Initializing SDL audio threw an exception: "${e.toString()}"! Continuing without audio`);
              SDL.audio = null;
              SDL.allocateChannels(0);
              if (obtained) {
                HEAP32[obtained >>> 2 >>> 0] = 0;
                HEAP16[obtained + 4 >>> 1 >>> 0] = 0;
                HEAP8[obtained + 6 >>> 0 >>> 0] = 0;
                HEAP8[obtained + 7 >>> 0 >>> 0] = 0;
                HEAP16[obtained + 8 >>> 1 >>> 0] = 0;
                HEAPU32[obtained + 16 >>> 2 >>> 0] = 0;
                HEAPU32[obtained + 20 >>> 2 >>> 0] = 0;
              }
            }
            if (!SDL.audio) {
              return -1;
            }
            return 0;
          }
          _SDL_OpenAudio.sig = "ipp";
          var _SDL_PauseAudio = (pauseOn) => {
            if (!SDL.audio) {
              return;
            }
            if (pauseOn) {
              if (SDL.audio.timer !== void 0) {
                clearTimeout(SDL.audio.timer);
                SDL.audio.numAudioTimersPending = 0;
                SDL.audio.timer = void 0;
              }
            } else if (!SDL.audio.timer) {
              SDL.audio.numAudioTimersPending = 1;
              SDL.audio.timer = safeSetTimeout(SDL.audio.caller, 1);
            }
            SDL.audio.paused = pauseOn;
          };
          _SDL_PauseAudio.sig = "vi";
          var _SDL_CloseAudio = () => {
            if (SDL.audio) {
              if (SDL.audio.callbackRemover) {
                SDL.audio.callbackRemover();
                SDL.audio.callbackRemover = null;
              }
              _SDL_PauseAudio(1);
              _free(SDL.audio.buffer);
              SDL.audio = null;
              SDL.allocateChannels(0);
            }
          };
          _SDL_CloseAudio.sig = "v";
          var _SDL_LockAudio = () => {
          };
          _SDL_LockAudio.sig = "v";
          var _SDL_UnlockAudio = () => {
          };
          _SDL_UnlockAudio.sig = "v";
          function _SDL_CreateMutex() {
            return 0;
          }
          _SDL_CreateMutex.sig = "p";
          function _SDL_mutexP(mutex) {
            mutex >>>= 0;
            return 0;
          }
          _SDL_mutexP.sig = "ip";
          function _SDL_mutexV(mutex) {
            mutex >>>= 0;
            return 0;
          }
          _SDL_mutexV.sig = "ip";
          function _SDL_DestroyMutex(mutex) {
            mutex >>>= 0;
          }
          _SDL_DestroyMutex.sig = "vp";
          function _SDL_CreateCond() {
            return 0;
          }
          _SDL_CreateCond.sig = "p";
          function _SDL_CondSignal(cond) {
            cond >>>= 0;
          }
          _SDL_CondSignal.sig = "ip";
          function _SDL_CondWait(cond, mutex) {
            cond >>>= 0;
            mutex >>>= 0;
          }
          _SDL_CondWait.sig = "ipp";
          function _SDL_DestroyCond(cond) {
            cond >>>= 0;
          }
          _SDL_DestroyCond.sig = "vp";
          var _SDL_StartTextInput = () => {
            SDL.textInput = true;
          };
          _SDL_StartTextInput.sig = "v";
          var _SDL_StopTextInput = () => {
            SDL.textInput = false;
          };
          _SDL_StopTextInput.sig = "v";
          var _Mix_Init = (flags2) => {
            if (!flags2)
              return 0;
            return 8;
          };
          _Mix_Init.sig = "ii";
          var _Mix_Quit = () => {
          };
          _Mix_Quit.sig = "v";
          var _Mix_OpenAudio = (frequency, format, channels, chunksize) => {
            SDL.openAudioContext();
            autoResumeAudioContext(SDL.audioContext);
            SDL.allocateChannels(32);
            SDL.mixerFrequency = frequency;
            SDL.mixerFormat = format;
            SDL.mixerNumChannels = channels;
            SDL.mixerChunkSize = chunksize;
            return 0;
          };
          _Mix_OpenAudio.sig = "iiiii";
          var _Mix_CloseAudio = _SDL_CloseAudio;
          _Mix_CloseAudio.sig = "v";
          var _Mix_AllocateChannels = (num) => {
            SDL.allocateChannels(num);
            return num;
          };
          _Mix_AllocateChannels.sig = "ii";
          function _Mix_ChannelFinished(func2) {
            func2 >>>= 0;
            SDL.channelFinished = func2;
          }
          _Mix_ChannelFinished.sig = "vp";
          var _Mix_Volume = (channel, volume) => {
            if (channel == -1) {
              for (var i2 = 0; i2 < SDL.numChannels - 1; i2++) {
                _Mix_Volume(i2, volume);
              }
              return _Mix_Volume(SDL.numChannels - 1, volume);
            }
            return SDL.setGetVolume(SDL.channels[channel], volume);
          };
          _Mix_Volume.sig = "iii";
          var _Mix_SetPanning = (channel, left, right) => {
            left /= 255;
            right /= 255;
            SDL.setPannerPosition(SDL.channels[channel], right - left, 0, 0.1);
            return 1;
          };
          _Mix_SetPanning.sig = "iiii";
          function _Mix_LoadWAV_RW(rwopsID, freesrc) {
            rwopsID >>>= 0;
            var rwops = SDL.rwops[rwopsID];
            if (rwops === void 0)
              return 0;
            var filename = "";
            var audio;
            var webAudio;
            var bytes;
            if (rwops.filename !== void 0) {
              filename = PATH_FS.resolve(rwops.filename);
              var raw = preloadedAudios[filename];
              if (!raw) {
                if (raw === null)
                  err("Trying to reuse preloaded audio, but freePreloadedMediaOnUse is set!");
                if (!Module.noAudioDecoding)
                  warnOnce("Cannot find preloaded audio " + filename);
                try {
                  bytes = FS.readFile(filename);
                } catch (e) {
                  err(`Couldn't find file for: ${filename}`);
                  return 0;
                }
              }
              if (Module["freePreloadedMediaOnUse"]) {
                preloadedAudios[filename] = null;
              }
              audio = raw;
            } else if (rwops.bytes !== void 0) {
              if (SDL.webAudioAvailable())
                bytes = HEAPU8.buffer.slice(rwops.bytes, rwops.bytes + rwops.count);
              else
                bytes = HEAPU8.subarray(rwops.bytes >>> 0, rwops.bytes + rwops.count >>> 0);
            } else {
              return 0;
            }
            var arrayBuffer = bytes ? bytes.buffer || bytes : bytes;
            var canPlayWithWebAudio = Module["SDL_canPlayWithWebAudio"] === void 0 || Module["SDL_canPlayWithWebAudio"](filename, arrayBuffer);
            if (bytes !== void 0 && SDL.webAudioAvailable() && canPlayWithWebAudio) {
              audio = void 0;
              webAudio = {};
              webAudio.onDecodeComplete = [];
              var onDecodeComplete = (data2) => {
                webAudio.decodedBuffer = data2;
                webAudio.onDecodeComplete.forEach((e) => e());
                webAudio.onDecodeComplete = void 0;
              };
              SDL.audioContext["decodeAudioData"](arrayBuffer, onDecodeComplete);
            } else if (audio === void 0 && bytes) {
              var blob = new Blob([bytes], {
                type: rwops.mimetype
              });
              var url2 = URL.createObjectURL(blob);
              audio = new Audio();
              audio.src = url2;
              audio.mozAudioChannelType = "content";
            }
            var id = SDL.audios.length;
            SDL.audios.push({
              source: filename,
              audio,
              webAudio
            });
            return id;
          }
          _Mix_LoadWAV_RW.sig = "ppi";
          function _Mix_LoadWAV(filename) {
            filename >>>= 0;
            var rwops = _SDL_RWFromFile(filename, 0);
            var result = _Mix_LoadWAV_RW(rwops, 0);
            _SDL_FreeRW(rwops);
            return result;
          }
          _Mix_LoadWAV.sig = "pp";
          function _Mix_QuickLoad_RAW(mem, len2) {
            mem >>>= 0;
            var audio;
            var webAudio;
            var numSamples = len2 >> 1;
            var buffer = new Float32Array(numSamples);
            for (var i2 = 0; i2 < numSamples; ++i2) {
              buffer[i2] = HEAP16[mem + i2 * 2 >>> 1 >>> 0] / 32768;
            }
            if (SDL.webAudioAvailable()) {
              webAudio = {};
              webAudio.decodedBuffer = buffer;
            } else {
              audio = new Audio();
              audio.mozAudioChannelType = "content";
              audio.numChannels = SDL.mixerNumChannels;
              audio.frequency = SDL.mixerFrequency;
            }
            var id = SDL.audios.length;
            SDL.audios.push({
              source: "",
              audio,
              webAudio,
              buffer
            });
            return id;
          }
          _Mix_QuickLoad_RAW.sig = "ppi";
          function _Mix_FreeChunk(id) {
            id >>>= 0;
            SDL.audios[id] = null;
          }
          _Mix_FreeChunk.sig = "vp";
          var _Mix_ReserveChannels = (num) => {
            SDL.channelMinimumNumber = num;
          };
          _Mix_ReserveChannels.sig = "ii";
          function _Mix_PlayChannelTimed(channel, id, loops, ticks) {
            id >>>= 0;
            assert(ticks == -1);
            var info2 = SDL.audios[id];
            if (!info2)
              return -1;
            if (!info2.audio && !info2.webAudio)
              return -1;
            if (channel == -1) {
              for (var i2 = SDL.channelMinimumNumber; i2 < SDL.numChannels; i2++) {
                if (!SDL.channels[i2].audio) {
                  channel = i2;
                  break;
                }
              }
              if (channel == -1) {
                err(`All ${SDL.numChannels}  channels in use!`);
                return -1;
              }
            }
            var channelInfo = SDL.channels[channel];
            var audio;
            if (info2.webAudio) {
              audio = {};
              audio.resource = info2;
              audio.paused = false;
              audio.currentPosition = 0;
              audio.play = function() {
                SDL.playWebAudio(this);
              };
              audio.pause = function() {
                SDL.pauseWebAudio(this);
              };
            } else {
              audio = info2.audio.cloneNode(true);
              audio.numChannels = info2.audio.numChannels;
              audio.frequency = info2.audio.frequency;
            }
            audio["onended"] = function() {
              if (channelInfo.audio == this) {
                channelInfo.audio.paused = true;
                channelInfo.audio = null;
              }
              if (SDL.channelFinished)
                getWasmTableEntry(SDL.channelFinished)(channel);
            };
            channelInfo.audio = audio;
            audio.loop = loops != 0;
            audio.volume = channelInfo.volume;
            audio.play();
            return channel;
          }
          _Mix_PlayChannelTimed.sig = "iipii";
          var _Mix_FadingChannel = (channel) => 0;
          _Mix_FadingChannel.sig = "ii";
          var _Mix_HaltChannel = (channel) => {
            function halt(channel2) {
              var info2 = SDL.channels[channel2];
              if (info2.audio) {
                info2.audio.pause();
                info2.audio = null;
              }
              if (SDL.channelFinished) {
                getWasmTableEntry(SDL.channelFinished)(channel2);
              }
            }
            if (channel != -1) {
              halt(channel);
            } else {
              for (var i2 = 0; i2 < SDL.channels.length; ++i2)
                halt(i2);
            }
            return 0;
          };
          _Mix_HaltChannel.sig = "ii";
          var _Mix_HaltMusic = () => {
            var audio = SDL.music.audio;
            if (audio) {
              audio.src = audio.src;
              audio.currentPosition = 0;
              audio.pause();
            }
            SDL.music.audio = null;
            if (SDL.hookMusicFinished) {
              getWasmTableEntry(SDL.hookMusicFinished)();
            }
            return 0;
          };
          _Mix_HaltMusic.sig = "i";
          function _Mix_HookMusicFinished(func2) {
            func2 >>>= 0;
            SDL.hookMusicFinished = func2;
            if (SDL.music.audio) {
              SDL.music.audio["onended"] = _Mix_HaltMusic;
            }
          }
          _Mix_HookMusicFinished.sig = "vp";
          var _Mix_VolumeMusic = (volume) => SDL.setGetVolume(SDL.music, volume);
          _Mix_VolumeMusic.sig = "ii";
          var _Mix_LoadMUS_RW = _Mix_LoadWAV_RW;
          _Mix_LoadMUS_RW.sig = "pp";
          function _Mix_LoadMUS(filename) {
            filename >>>= 0;
            var rwops = _SDL_RWFromFile(filename, 0);
            var result = _Mix_LoadMUS_RW(rwops, 0);
            _SDL_FreeRW(rwops);
            return result;
          }
          _Mix_LoadMUS.sig = "pp";
          var _Mix_FreeMusic = _Mix_FreeChunk;
          _Mix_FreeMusic.sig = "vp";
          function _Mix_PlayMusic(id, loops) {
            id >>>= 0;
            if (SDL.music.audio) {
              if (!SDL.music.audio.paused)
                err(`Music is already playing. ${SDL.music.source}`);
              SDL.music.audio.pause();
            }
            var info2 = SDL.audios[id];
            var audio;
            if (info2.webAudio) {
              audio = {};
              audio.resource = info2;
              audio.paused = false;
              audio.currentPosition = 0;
              audio.play = function() {
                SDL.playWebAudio(this);
              };
              audio.pause = function() {
                SDL.pauseWebAudio(this);
              };
            } else if (info2.audio) {
              audio = info2.audio;
            }
            audio["onended"] = function() {
              if (SDL.music.audio == this)
                _Mix_HaltMusic();
            };
            audio.loop = loops != 0 && loops != 1;
            audio.volume = SDL.music.volume;
            SDL.music.audio = audio;
            audio.play();
            return 0;
          }
          _Mix_PlayMusic.sig = "ipi";
          var _Mix_PauseMusic = () => {
            var audio = SDL.music.audio;
            audio?.pause();
          };
          _Mix_PauseMusic.sig = "v";
          var _Mix_ResumeMusic = () => {
            var audio = SDL.music.audio;
            audio?.play();
          };
          _Mix_ResumeMusic.sig = "v";
          var _Mix_FadeInMusicPos = _Mix_PlayMusic;
          _Mix_FadeInMusicPos.sig = "ipiid";
          var _Mix_FadeOutMusic = _Mix_HaltMusic;
          _Mix_FadeOutMusic.sig = "ii";
          var _Mix_PlayingMusic = () => SDL.music.audio && !SDL.music.audio.paused ? 1 : 0;
          _Mix_PlayingMusic.sig = "i";
          var _Mix_Playing = (channel) => {
            if (channel === -1) {
              var count = 0;
              for (var i2 = 0; i2 < SDL.channels.length; i2++) {
                count += _Mix_Playing(i2);
              }
              return count;
            }
            var info2 = SDL.channels[channel];
            if (info2?.audio && !info2.audio.paused) {
              return 1;
            }
            return 0;
          };
          _Mix_Playing.sig = "ii";
          var _Mix_Pause = (channel) => {
            if (channel === -1) {
              for (var i2 = 0; i2 < SDL.channels.length; i2++) {
                _Mix_Pause(i2);
              }
              return;
            }
            var info2 = SDL.channels[channel];
            if (info2?.audio) {
              info2.audio.pause();
            } else {
            }
          };
          _Mix_Pause.sig = "vi";
          var _Mix_Paused = (channel) => {
            if (channel === -1) {
              var pausedCount = 0;
              for (var i2 = 0; i2 < SDL.channels.length; i2++) {
                pausedCount += _Mix_Paused(i2);
              }
              return pausedCount;
            }
            var info2 = SDL.channels[channel];
            if (info2?.audio?.paused) {
              return 1;
            }
            return 0;
          };
          _Mix_Paused.sig = "ii";
          var _Mix_PausedMusic = () => SDL.music.audio?.paused ? 1 : 0;
          _Mix_PausedMusic.sig = "i";
          var _Mix_Resume = (channel) => {
            if (channel === -1) {
              for (var i2 = 0; i2 < SDL.channels.length; i2++) {
                _Mix_Resume(i2);
              }
              return;
            }
            var info2 = SDL.channels[channel];
            if (info2?.audio)
              info2.audio.play();
          };
          _Mix_Resume.sig = "vi";
          var _TTF_Init = () => {
            try {
              var offscreenCanvas = new OffscreenCanvas(0, 0);
              SDL.ttfContext = offscreenCanvas.getContext("2d");
              if (typeof SDL.ttfContext.measureText != "function") {
                throw "bad context";
              }
            } catch (ex) {
              var canvas = document.createElement("canvas");
              SDL.ttfContext = canvas.getContext("2d");
            }
            return 0;
          };
          _TTF_Init.sig = "i";
          function _TTF_OpenFont(name2, size) {
            name2 >>>= 0;
            name2 = PATH.normalize(UTF8ToString(name2));
            var id = SDL.fonts.length;
            SDL.fonts.push({
              name: name2,
              size
            });
            return id;
          }
          _TTF_OpenFont.sig = "ppi";
          function _TTF_CloseFont(font) {
            font >>>= 0;
            SDL.fonts[font] = null;
          }
          _TTF_CloseFont.sig = "vp";
          function _TTF_RenderText_Solid(font, text, color) {
            font >>>= 0;
            text >>>= 0;
            color >>>= 0;
            text = UTF8ToString(text) || " ";
            var fontData = SDL.fonts[font];
            var w = SDL.estimateTextWidth(fontData, text);
            var h = fontData.size;
            color = SDL.loadColorToCSSRGB(color);
            var fontString = SDL.makeFontString(h, fontData.name);
            var surf = SDL.makeSurface(w, h, 0, false, "text:" + text);
            var surfData = SDL.surfaces[surf];
            surfData.ctx.save();
            surfData.ctx.fillStyle = color;
            surfData.ctx.font = fontString;
            surfData.ctx.textBaseline = "bottom";
            surfData.ctx.fillText(text, 0, h | 0);
            surfData.ctx.restore();
            return surf;
          }
          _TTF_RenderText_Solid.sig = "pppp";
          var _TTF_RenderText_Blended = _TTF_RenderText_Solid;
          _TTF_RenderText_Blended.sig = "pppp";
          var _TTF_RenderText_Shaded = _TTF_RenderText_Solid;
          _TTF_RenderText_Shaded.sig = "ppppp";
          var _TTF_RenderUTF8_Solid = _TTF_RenderText_Solid;
          _TTF_RenderUTF8_Solid.sig = "pppp";
          function _TTF_SizeText(font, text, w, h) {
            font >>>= 0;
            text >>>= 0;
            w >>>= 0;
            h >>>= 0;
            var fontData = SDL.fonts[font];
            if (w) {
              HEAP32[w >>> 2 >>> 0] = SDL.estimateTextWidth(fontData, UTF8ToString(text));
            }
            if (h) {
              HEAP32[h >>> 2 >>> 0] = fontData.size;
            }
            return 0;
          }
          _TTF_SizeText.sig = "ipppp";
          var _TTF_SizeUTF8 = _TTF_SizeText;
          _TTF_SizeUTF8.sig = "ipppp";
          function _TTF_GlyphMetrics(font, ch, minx, maxx, miny, maxy, advance) {
            font >>>= 0;
            minx >>>= 0;
            maxx >>>= 0;
            miny >>>= 0;
            maxy >>>= 0;
            advance >>>= 0;
            var fontData = SDL.fonts[font];
            var width = SDL.estimateTextWidth(fontData, String.fromCharCode(ch));
            if (advance) {
              HEAP32[advance >>> 2 >>> 0] = width;
            }
            if (minx) {
              HEAP32[minx >>> 2 >>> 0] = 0;
            }
            if (maxx) {
              HEAP32[maxx >>> 2 >>> 0] = width;
            }
            if (miny) {
              HEAP32[miny >>> 2 >>> 0] = 0;
            }
            if (maxy) {
              HEAP32[maxy >>> 2 >>> 0] = fontData.size;
            }
          }
          _TTF_GlyphMetrics.sig = "ipippppp";
          function _TTF_FontAscent(font) {
            font >>>= 0;
            var fontData = SDL.fonts[font];
            return fontData.size * 0.98 | 0;
          }
          _TTF_FontAscent.sig = "ip";
          function _TTF_FontDescent(font) {
            font >>>= 0;
            var fontData = SDL.fonts[font];
            return fontData.size * 0.02 | 0;
          }
          _TTF_FontDescent.sig = "ip";
          function _TTF_FontHeight(font) {
            font >>>= 0;
            var fontData = SDL.fonts[font];
            return fontData.size;
          }
          _TTF_FontHeight.sig = "ip";
          var _TTF_FontLineSkip = _TTF_FontHeight;
          _TTF_FontLineSkip.sig = "ip";
          var _TTF_Quit = () => out("TTF_Quit called (and ignored)");
          _TTF_Quit.sig = "v";
          var SDL_gfx = {
            drawRectangle: (surf, x1, y1, x2, y2, action, cssColor) => {
              x1 = x1 << 16 >> 16;
              y1 = y1 << 16 >> 16;
              x2 = x2 << 16 >> 16;
              y2 = y2 << 16 >> 16;
              var surfData = SDL.surfaces[surf];
              assert(!surfData.locked);
              var x = x1 < x2 ? x1 : x2;
              var y = y1 < y2 ? y1 : y2;
              var w = Math.abs(x2 - x1);
              var h = Math.abs(y2 - y1);
              surfData.ctx.save();
              surfData.ctx[action + "Style"] = cssColor;
              surfData.ctx[action + "Rect"](x, y, w, h);
              surfData.ctx.restore();
            },
            drawLine: (surf, x1, y1, x2, y2, cssColor) => {
              x1 = x1 << 16 >> 16;
              y1 = y1 << 16 >> 16;
              x2 = x2 << 16 >> 16;
              y2 = y2 << 16 >> 16;
              var surfData = SDL.surfaces[surf];
              assert(!surfData.locked);
              surfData.ctx.save();
              surfData.ctx.strokeStyle = cssColor;
              surfData.ctx.beginPath();
              surfData.ctx.moveTo(x1, y1);
              surfData.ctx.lineTo(x2, y2);
              surfData.ctx.stroke();
              surfData.ctx.restore();
            },
            drawEllipse: (surf, x, y, rx, ry, action, cssColor) => {
              x = x << 16 >> 16;
              y = y << 16 >> 16;
              rx = rx << 16 >> 16;
              ry = ry << 16 >> 16;
              var surfData = SDL.surfaces[surf];
              assert(!surfData.locked);
              surfData.ctx.save();
              surfData.ctx.beginPath();
              surfData.ctx.translate(x, y);
              surfData.ctx.scale(rx, ry);
              surfData.ctx.arc(0, 0, 1, 0, 2 * Math.PI);
              surfData.ctx.restore();
              surfData.ctx.save();
              surfData.ctx[action + "Style"] = cssColor;
              surfData.ctx[action]();
              surfData.ctx.restore();
            },
            translateColorToCSSRGBA: (rgba) => `rgba(${rgba >>> 24},${rgba >> 16 & 255},${rgba >> 8 & 255},${rgba & 255})`
          };
          function _boxColor(surf, x1, y1, x2, y2, color) {
            surf >>>= 0;
            return SDL_gfx.drawRectangle(surf, x1, y1, x2, y2, "fill", SDL_gfx.translateColorToCSSRGBA(color));
          }
          _boxColor.sig = "ipiiiii";
          function _boxRGBA(surf, x1, y1, x2, y2, r, g, b, a) {
            surf >>>= 0;
            return SDL_gfx.drawRectangle(surf, x1, y1, x2, y2, "fill", SDL.translateRGBAToCSSRGBA(r, g, b, a));
          }
          _boxRGBA.sig = "ipiiiiiiii";
          function _rectangleColor(surf, x1, y1, x2, y2, color) {
            surf >>>= 0;
            return SDL_gfx.drawRectangle(surf, x1, y1, x2, y2, "stroke", SDL_gfx.translateColorToCSSRGBA(color));
          }
          _rectangleColor.sig = "ipiiiii";
          function _rectangleRGBA(surf, x1, y1, x2, y2, r, g, b, a) {
            surf >>>= 0;
            return SDL_gfx.drawRectangle(surf, x1, y1, x2, y2, "stroke", SDL.translateRGBAToCSSRGBA(r, g, b, a));
          }
          _rectangleRGBA.sig = "ipiiiiiiii";
          function _ellipseColor(surf, x, y, rx, ry, color) {
            surf >>>= 0;
            return SDL_gfx.drawEllipse(surf, x, y, rx, ry, "stroke", SDL_gfx.translateColorToCSSRGBA(color));
          }
          _ellipseColor.sig = "ipiiiii";
          function _ellipseRGBA(surf, x, y, rx, ry, r, g, b, a) {
            surf >>>= 0;
            return SDL_gfx.drawEllipse(surf, x, y, rx, ry, "stroke", SDL.translateRGBAToCSSRGBA(r, g, b, a));
          }
          _ellipseRGBA.sig = "ipiiiiiiii";
          function _filledEllipseColor(surf, x, y, rx, ry, color) {
            surf >>>= 0;
            return SDL_gfx.drawEllipse(surf, x, y, rx, ry, "fill", SDL_gfx.translateColorToCSSRGBA(color));
          }
          _filledEllipseColor.sig = "ipiiiii";
          function _filledEllipseRGBA(surf, x, y, rx, ry, r, g, b, a) {
            surf >>>= 0;
            return SDL_gfx.drawEllipse(surf, x, y, rx, ry, "fill", SDL.translateRGBAToCSSRGBA(r, g, b, a));
          }
          _filledEllipseRGBA.sig = "ipiiiiiiii";
          function _lineColor(surf, x1, y1, x2, y2, color) {
            surf >>>= 0;
            return SDL_gfx.drawLine(surf, x1, y1, x2, y2, SDL_gfx.translateColorToCSSRGBA(color));
          }
          _lineColor.sig = "ipiiiii";
          function _lineRGBA(surf, x1, y1, x2, y2, r, g, b, a) {
            surf >>>= 0;
            return SDL_gfx.drawLine(surf, x1, y1, x2, y2, SDL.translateRGBAToCSSRGBA(r, g, b, a));
          }
          _lineRGBA.sig = "ipiiiiiiii";
          function _pixelRGBA(surf, x1, y1, r, g, b, a) {
            surf >>>= 0;
            return _boxRGBA(surf, x1, y1, x1, y1, r, g, b, a);
          }
          _pixelRGBA.sig = "ipiiiiii";
          var _SDL_GL_SetAttribute = (attr, value) => {
            if (!(attr in SDL.glAttributes)) {
              abort("Unknown SDL GL attribute (" + attr + "). Please check if your SDL version is supported.");
            }
            SDL.glAttributes[attr] = value;
          };
          _SDL_GL_SetAttribute.sig = "iii";
          function _SDL_GL_GetAttribute(attr, value) {
            value >>>= 0;
            if (!(attr in SDL.glAttributes)) {
              abort("Unknown SDL GL attribute (" + attr + "). Please check if your SDL version is supported.");
            }
            if (value)
              HEAP32[value >>> 2 >>> 0] = SDL.glAttributes[attr];
            return 0;
          }
          _SDL_GL_GetAttribute.sig = "iip";
          var _SDL_GL_SwapBuffers = () => {
            Browser.doSwapBuffers?.();
          };
          _SDL_GL_SwapBuffers.sig = "v";
          function _SDL_GL_ExtensionSupported(extension) {
            extension >>>= 0;
            return Module.ctx.getExtension(extension) | 0;
          }
          _SDL_GL_ExtensionSupported.sig = "ip";
          function _SDL_DestroyWindow(window2) {
            window2 >>>= 0;
          }
          _SDL_DestroyWindow.sig = "vp";
          function _SDL_DestroyRenderer(renderer) {
            renderer >>>= 0;
          }
          _SDL_DestroyRenderer.sig = "vp";
          function _SDL_GetWindowFlags(window2) {
            window2 >>>= 0;
            if (Browser.isFullscreen) {
              return 1;
            }
            return 0;
          }
          _SDL_GetWindowFlags.sig = "ip";
          function _SDL_GL_SwapWindow(window2) {
            window2 >>>= 0;
          }
          _SDL_GL_SwapWindow.sig = "vp";
          function _SDL_GL_MakeCurrent(window2, context) {
            window2 >>>= 0;
            context >>>= 0;
          }
          _SDL_GL_MakeCurrent.sig = "ipp";
          function _SDL_GL_DeleteContext(context) {
            context >>>= 0;
          }
          _SDL_GL_DeleteContext.sig = "vp";
          var _SDL_GL_GetSwapInterval = () => {
            if (Browser.mainLoop.timingMode == 1)
              return Browser.mainLoop.timingValue;
            else
              return 0;
          };
          _SDL_GL_GetSwapInterval.sig = "i";
          var _SDL_GL_SetSwapInterval = (state) => {
            _emscripten_set_main_loop_timing(1, state);
          };
          _SDL_GL_SetSwapInterval.sig = "ii";
          function _SDL_SetWindowTitle(window2, title) {
            window2 >>>= 0;
            title >>>= 0;
            if (title)
              document.title = UTF8ToString(title);
          }
          _SDL_SetWindowTitle.sig = "vpp";
          function _SDL_GetWindowSize(window2, width, height) {
            window2 >>>= 0;
            width >>>= 0;
            height >>>= 0;
            var w = Module["canvas"].width;
            var h = Module["canvas"].height;
            if (width)
              HEAP32[width >>> 2 >>> 0] = w;
            if (height)
              HEAP32[height >>> 2 >>> 0] = h;
          }
          _SDL_GetWindowSize.sig = "vppp";
          function _SDL_LogSetOutputFunction(callback, userdata) {
            callback >>>= 0;
            userdata >>>= 0;
          }
          _SDL_LogSetOutputFunction.sig = "vpp";
          function _SDL_SetWindowFullscreen(window2, fullscreen) {
            window2 >>>= 0;
            if (Browser.isFullscreen) {
              Module["canvas"].exitFullscreen();
              return 1;
            }
            return 0;
          }
          _SDL_SetWindowFullscreen.sig = "ipi";
          var _SDL_ClearError = () => {
          };
          _SDL_ClearError.sig = "v";
          var _SDL_SetGamma = (r, g, b) => -1;
          _SDL_SetGamma.sig = "ifff";
          function _SDL_SetGammaRamp(redTable, greenTable, blueTable) {
            redTable >>>= 0;
            greenTable >>>= 0;
            blueTable >>>= 0;
            return -1;
          }
          _SDL_SetGammaRamp.sig = "ippp";
          var _SDL_NumJoysticks = () => {
            var count = 0;
            var gamepads = SDL.getGamepads();
            for (var i2 = 0; i2 < gamepads.length; i2++) {
              if (gamepads[i2] !== void 0)
                count++;
            }
            return count;
          };
          _SDL_NumJoysticks.sig = "i";
          function _SDL_JoystickName(deviceIndex) {
            var gamepad = SDL.getGamepad(deviceIndex);
            if (gamepad) {
              var name2 = gamepad.id;
              if (SDL.joystickNamePool.hasOwnProperty(name2)) {
                return SDL.joystickNamePool[name2];
              }
              return SDL.joystickNamePool[name2] = stringToNewUTF8(name2);
            }
            return 0;
          }
          _SDL_JoystickName.sig = "pi";
          function _SDL_JoystickOpen(deviceIndex) {
            var gamepad = SDL.getGamepad(deviceIndex);
            if (gamepad) {
              var joystick = deviceIndex + 1;
              SDL.recordJoystickState(joystick, gamepad);
              return joystick;
            }
            return 0;
          }
          _SDL_JoystickOpen.sig = "pi";
          var _SDL_JoystickOpened = (deviceIndex) => SDL.lastJoystickState.hasOwnProperty(deviceIndex + 1) ? 1 : 0;
          _SDL_JoystickOpened.sig = "ii";
          function _SDL_JoystickIndex(joystick) {
            joystick >>>= 0;
            return joystick - 1;
          }
          _SDL_JoystickIndex.sig = "ip";
          function _SDL_JoystickNumAxes(joystick) {
            joystick >>>= 0;
            var gamepad = SDL.getGamepad(joystick - 1);
            if (gamepad) {
              return gamepad.axes.length;
            }
            return 0;
          }
          _SDL_JoystickNumAxes.sig = "ip";
          function _SDL_JoystickNumBalls(joystick) {
            joystick >>>= 0;
            return 0;
          }
          _SDL_JoystickNumBalls.sig = "ip";
          function _SDL_JoystickNumHats(joystick) {
            joystick >>>= 0;
            return 0;
          }
          _SDL_JoystickNumHats.sig = "ip";
          function _SDL_JoystickNumButtons(joystick) {
            joystick >>>= 0;
            var gamepad = SDL.getGamepad(joystick - 1);
            if (gamepad) {
              return gamepad.buttons.length;
            }
            return 0;
          }
          _SDL_JoystickNumButtons.sig = "ip";
          var _SDL_JoystickUpdate = () => SDL.queryJoysticks();
          _SDL_JoystickUpdate.sig = "v";
          var _SDL_JoystickEventState = (state) => {
            if (state < 0) {
              return SDL.joystickEventState;
            }
            return SDL.joystickEventState = state;
          };
          _SDL_JoystickEventState.sig = "ii";
          function _SDL_JoystickGetAxis(joystick, axis) {
            joystick >>>= 0;
            var gamepad = SDL.getGamepad(joystick - 1);
            if (gamepad && gamepad.axes.length > axis) {
              return SDL.joystickAxisValueConversion(gamepad.axes[axis]);
            }
            return 0;
          }
          _SDL_JoystickGetAxis.sig = "ipi";
          function _SDL_JoystickGetHat(joystick, hat) {
            joystick >>>= 0;
            return 0;
          }
          _SDL_JoystickGetHat.sig = "ipi";
          function _SDL_JoystickGetBall(joystick, ball, dxptr, dyptr) {
            joystick >>>= 0;
            dxptr >>>= 0;
            dyptr >>>= 0;
            return -1;
          }
          _SDL_JoystickGetBall.sig = "ipipp";
          function _SDL_JoystickGetButton(joystick, button) {
            joystick >>>= 0;
            var gamepad = SDL.getGamepad(joystick - 1);
            if (gamepad && gamepad.buttons.length > button) {
              return SDL.getJoystickButtonState(gamepad.buttons[button]) ? 1 : 0;
            }
            return 0;
          }
          _SDL_JoystickGetButton.sig = "ipi";
          function _SDL_JoystickClose(joystick) {
            joystick >>>= 0;
            delete SDL.lastJoystickState[joystick];
          }
          _SDL_JoystickClose.sig = "vp";
          var _SDL_InitSubSystem = (flags2) => 0;
          _SDL_InitSubSystem.sig = "ii";
          function _SDL_RWFromConstMem(mem, size) {
            mem >>>= 0;
            var id = SDL.rwops.length;
            SDL.rwops.push({
              bytes: mem,
              count: size
            });
            return id;
          }
          _SDL_RWFromConstMem.sig = "ppi";
          var _SDL_RWFromMem = _SDL_RWFromConstMem;
          _SDL_RWFromMem.sig = "ppi";
          var _SDL_GetNumAudioDrivers = () => 1;
          _SDL_GetNumAudioDrivers.sig = "i";
          function _SDL_GetCurrentAudioDriver() {
            return stringToNewUTF8("Emscripten Audio");
          }
          _SDL_GetCurrentAudioDriver.sig = "p";
          var _SDL_GetScancodeFromKey = (key) => SDL.scanCodes[key];
          _SDL_GetScancodeFromKey.sig = "ii";
          function _SDL_GetAudioDriver(index) {
            return _SDL_GetCurrentAudioDriver();
          }
          _SDL_GetAudioDriver.sig = "pi";
          var _SDL_EnableUNICODE = (on) => {
            var ret = SDL.unicode || 0;
            SDL.unicode = on;
            return ret;
          };
          _SDL_EnableUNICODE.sig = "ii";
          var _SDL_AddTimer = function(interval, callback, param) {
            callback >>>= 0;
            param >>>= 0;
            return safeSetTimeout(() => getWasmTableEntry(callback)(interval, param), interval);
          };
          _SDL_AddTimer.sig = "iipp";
          var _SDL_RemoveTimer = (id) => {
            clearTimeout(id);
            return true;
          };
          _SDL_RemoveTimer.sig = "ii";
          function _SDL_CreateThread(fs2, data2, pfnBeginThread, pfnEndThread) {
            fs2 >>>= 0;
            data2 >>>= 0;
            throw "SDL threads cannot be supported in the web platform because they assume shared state. See emscripten_create_worker etc. for a message-passing concurrency model that does let you run code in another thread.";
          }
          _SDL_CreateThread.sig = "ppp";
          function _SDL_WaitThread(thread, status) {
            thread >>>= 0;
            status >>>= 0;
            throw "SDL_WaitThread";
          }
          _SDL_WaitThread.sig = "vpp";
          function _SDL_GetThreadID(thread) {
            thread >>>= 0;
            throw "SDL_GetThreadID";
          }
          _SDL_GetThreadID.sig = "pp";
          function _SDL_ThreadID() {
            return 0;
          }
          _SDL_ThreadID.sig = "p";
          function _SDL_AllocRW() {
            throw "SDL_AllocRW: TODO";
          }
          _SDL_AllocRW.sig = "p";
          function _SDL_CondBroadcast(cond) {
            cond >>>= 0;
            throw "SDL_CondBroadcast: TODO";
          }
          _SDL_CondBroadcast.sig = "ip";
          function _SDL_CondWaitTimeout(cond, mutex, ms) {
            cond >>>= 0;
            mutex >>>= 0;
            throw "SDL_CondWaitTimeout: TODO";
          }
          _SDL_CondWaitTimeout.sig = "ippi";
          var _SDL_WM_IconifyWindow = () => {
            throw "SDL_WM_IconifyWindow TODO";
          };
          _SDL_WM_IconifyWindow.sig = "i";
          function _Mix_SetPostMix(func2, arg) {
            func2 >>>= 0;
            arg >>>= 0;
            return warnOnce("Mix_SetPostMix: TODO");
          }
          _Mix_SetPostMix.sig = "vpp";
          function _Mix_VolumeChunk(chunk, volume) {
            chunk >>>= 0;
            throw "Mix_VolumeChunk: TODO";
          }
          _Mix_VolumeChunk.sig = "ipi";
          var _Mix_SetPosition = (channel, angle, distance) => {
            throw "Mix_SetPosition: TODO";
          };
          _Mix_SetPosition.sig = "iiii";
          function _Mix_QuerySpec(frequency, format, channels) {
            frequency >>>= 0;
            format >>>= 0;
            channels >>>= 0;
            throw "Mix_QuerySpec: TODO";
          }
          _Mix_QuerySpec.sig = "ippp";
          function _Mix_FadeInChannelTimed(channel, chunk, loop, ms, ticks) {
            chunk >>>= 0;
            throw "Mix_FadeInChannelTimed";
          }
          _Mix_FadeInChannelTimed.sig = "iipiii";
          var _Mix_FadeOutChannel = () => {
            throw "Mix_FadeOutChannel";
          };
          _Mix_FadeOutChannel.sig = "iii";
          function _Mix_Linked_Version() {
            throw "Mix_Linked_Version: TODO";
          }
          _Mix_Linked_Version.sig = "p";
          function _SDL_SaveBMP_RW(surface, dst, freedst) {
            surface >>>= 0;
            dst >>>= 0;
            throw "SDL_SaveBMP_RW: TODO";
          }
          _SDL_SaveBMP_RW.sig = "ippi";
          function _SDL_WM_SetIcon(icon, mask) {
            icon >>>= 0;
            mask >>>= 0;
          }
          _SDL_WM_SetIcon.sig = "vpp";
          var _SDL_HasRDTSC = () => 0;
          _SDL_HasRDTSC.sig = "i";
          var _SDL_HasMMX = () => 0;
          _SDL_HasMMX.sig = "i";
          var _SDL_HasMMXExt = () => 0;
          _SDL_HasMMXExt.sig = "i";
          var _SDL_Has3DNow = () => 0;
          _SDL_Has3DNow.sig = "i";
          var _SDL_Has3DNowExt = () => 0;
          _SDL_Has3DNowExt.sig = "i";
          var _SDL_HasSSE = () => 0;
          _SDL_HasSSE.sig = "i";
          var _SDL_HasSSE2 = () => 0;
          _SDL_HasSSE2.sig = "i";
          var _SDL_HasAltiVec = () => 0;
          _SDL_HasAltiVec.sig = "i";
          var ALLOC_NORMAL = 0;
          var ALLOC_STACK = 1;
          var allocate = (slab, allocator) => {
            var ret;
            if (allocator == ALLOC_STACK) {
              ret = stackAlloc(slab.length);
            } else {
              ret = _malloc(slab.length);
            }
            if (!slab.subarray && !slab.slice) {
              slab = new Uint8Array(slab);
            }
            HEAPU8.set(slab, ret >>> 0);
            return ret;
          };
          var writeStringToMemory = (string, buffer, dontAddNull) => {
            warnOnce("writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!");
            var lastChar, end;
            if (dontAddNull) {
              end = buffer + lengthBytesUTF8(string);
              lastChar = HEAP8[end >>> 0];
            }
            stringToUTF8(string, buffer, Infinity);
            if (dontAddNull)
              HEAP8[end >>> 0] = lastChar;
          };
          var writeAsciiToMemory = (str, buffer, dontAddNull) => {
            for (var i2 = 0; i2 < str.length; ++i2) {
              HEAP8[buffer++ >>> 0 >>> 0] = str.charCodeAt(i2);
            }
            if (!dontAddNull)
              HEAP8[buffer >>> 0 >>> 0] = 0;
          };
          var allocateUTF8 = stringToNewUTF8;
          var allocateUTF8OnStack = stringToUTF8OnStack;
          var setErrNo = (value) => {
            HEAP32[___errno_location() >>> 2 >>> 0] = value;
            return value;
          };
          var _emscripten_is_main_browser_thread = () => !ENVIRONMENT_IS_WORKER;
          var tupleRegistrations = {};
          var structRegistrations = {};
          var getTypeName = (type) => {
            var ptr2 = ___getTypeName(type);
            var rv = readLatin1String(ptr2);
            _free(ptr2);
            return rv;
          };
          var getFunctionName = (signature) => {
            signature = signature.trim();
            const argsIndex = signature.indexOf("(");
            if (argsIndex !== -1) {
              return signature.substr(0, argsIndex);
            } else {
              return signature;
            }
          };
          var getFunctionArgsName = (signature) => {
            signature = signature.trim();
            const argsIndex = signature.indexOf("(") + 1;
            if (argsIndex !== 0) {
              return signature.substr(argsIndex, signature.length - argsIndex - 1).replaceAll(" ", "").split(",").filter((n) => n.length);
            } else {
              return [];
            }
          };
          var heap32VectorToArray = (count, firstElement) => {
            var array = [];
            for (var i2 = 0; i2 < count; i2++) {
              array.push(HEAPU32[firstElement + i2 * 4 >>> 2 >>> 0]);
            }
            return array;
          };
          var requireRegisteredType = (rawType, humanName) => {
            var impl = registeredTypes[rawType];
            if (void 0 === impl) {
              throwBindingError(humanName + " has unknown type " + getTypeName(rawType));
            }
            return impl;
          };
          function usesDestructorStack(argTypes) {
            for (var i2 = 1; i2 < argTypes.length; ++i2) {
              if (argTypes[i2] !== null && argTypes[i2].destructorFunction === void 0) {
                return true;
              }
            }
            return false;
          }
          function createJsInvoker(humanName, argTypes, isClassMethodFunc, returns, isAsync) {
            var needsDestructorStack = usesDestructorStack(argTypes);
            var argCount = argTypes.length;
            var argsList = "";
            var argsListWired = "";
            for (var i2 = 0; i2 < argCount - 2; ++i2) {
              argsList += (i2 !== 0 ? ", " : "") + "arg" + i2;
              argsListWired += (i2 !== 0 ? ", " : "") + "arg" + i2 + "Wired";
            }
            var invokerFnBody = `
        return function (${argsList}) {
        if (arguments.length !== ${argCount - 2}) {
          throwBindingError('function ${humanName} called with ' + arguments.length + ' arguments, expected ${argCount - 2}');
        }`;
            if (needsDestructorStack) {
              invokerFnBody += "var destructors = [];\n";
            }
            var dtorStack = needsDestructorStack ? "destructors" : "null";
            var args1 = ["throwBindingError", "invoker", "fn", "runDestructors", "retType", "classParam"];
            if (isClassMethodFunc) {
              invokerFnBody += "var thisWired = classParam['toWireType'](" + dtorStack + ", this);\n";
            }
            for (var i2 = 0; i2 < argCount - 2; ++i2) {
              invokerFnBody += "var arg" + i2 + "Wired = argType" + i2 + "['toWireType'](" + dtorStack + ", arg" + i2 + "); // " + argTypes[i2 + 2].name + "\n";
              args1.push("argType" + i2);
            }
            if (isClassMethodFunc) {
              argsListWired = "thisWired" + (argsListWired.length > 0 ? ", " : "") + argsListWired;
            }
            invokerFnBody += (returns || isAsync ? "var rv = " : "") + "invoker(fn" + (argsListWired.length > 0 ? ", " : "") + argsListWired + ");\n";
            if (needsDestructorStack) {
              invokerFnBody += "runDestructors(destructors);\n";
            } else {
              for (var i2 = isClassMethodFunc ? 1 : 2; i2 < argTypes.length; ++i2) {
                var paramName = i2 === 1 ? "thisWired" : "arg" + (i2 - 2) + "Wired";
                if (argTypes[i2].destructorFunction !== null) {
                  invokerFnBody += paramName + "_dtor(" + paramName + "); // " + argTypes[i2].name + "\n";
                  args1.push(paramName + "_dtor");
                }
              }
            }
            if (returns) {
              invokerFnBody += "var ret = retType['fromWireType'](rv);\nreturn ret;\n";
            } else {
            }
            invokerFnBody += "}\n";
            return [args1, invokerFnBody];
          }
          var createNamedFunction = (name2, body2) => Object.defineProperty(body2, "name", {
            value: name2
          });
          var extendError = (baseErrorType, errorName) => {
            var errorClass = createNamedFunction(errorName, function(message) {
              this.name = errorName;
              this.message = message;
              var stack = new Error(message).stack;
              if (stack !== void 0) {
                this.stack = this.toString() + "\n" + stack.replace(/^Error(:[^\n]*)?\n/, "");
              }
            });
            errorClass.prototype = Object.create(baseErrorType.prototype);
            errorClass.prototype.constructor = errorClass;
            errorClass.prototype.toString = function() {
              if (this.message === void 0) {
                return this.name;
              } else {
                return `${this.name}: ${this.message}`;
              }
            };
            return errorClass;
          };
          var UnboundTypeError;
          var PureVirtualError;
          var registeredInstances = {};
          var getInheritedInstanceCount = () => Object.keys(registeredInstances).length;
          var getLiveInheritedInstances = () => {
            var rv = [];
            for (var k in registeredInstances) {
              if (registeredInstances.hasOwnProperty(k)) {
                rv.push(registeredInstances[k]);
              }
            }
            return rv;
          };
          var deletionQueue = [];
          var flushPendingDeletes = () => {
            while (deletionQueue.length) {
              var obj = deletionQueue.pop();
              obj.$$.deleteScheduled = false;
              obj["delete"]();
            }
          };
          var delayFunction;
          var setDelayFunction = (fn) => {
            delayFunction = fn;
            if (deletionQueue.length && delayFunction) {
              delayFunction(flushPendingDeletes);
            }
          };
          var init_embind = () => {
            Module["getInheritedInstanceCount"] = getInheritedInstanceCount;
            Module["getLiveInheritedInstances"] = getLiveInheritedInstances;
            Module["flushPendingDeletes"] = flushPendingDeletes;
            Module["setDelayFunction"] = setDelayFunction;
          };
          var throwUnboundTypeError = (message, types) => {
            var unboundTypes = [];
            var seen = {};
            function visit(type) {
              if (seen[type]) {
                return;
              }
              if (registeredTypes[type]) {
                return;
              }
              if (typeDependencies[type]) {
                typeDependencies[type].forEach(visit);
                return;
              }
              unboundTypes.push(type);
              seen[type] = true;
            }
            types.forEach(visit);
            throw new UnboundTypeError(`${message}: ` + unboundTypes.map(getTypeName).join([", "]));
          };
          var ensureOverloadTable = (proto, methodName, humanName) => {
            if (void 0 === proto[methodName].overloadTable) {
              var prevFunc = proto[methodName];
              proto[methodName] = function() {
                if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {
                  throwBindingError(`Function '${humanName}' called with an invalid number of arguments (${arguments.length}) - expects one of (${proto[methodName].overloadTable})!`);
                }
                return proto[methodName].overloadTable[arguments.length].apply(this, arguments);
              };
              proto[methodName].overloadTable = [];
              proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;
            }
          };
          var exposePublicSymbol = (name2, value, numArguments) => {
            if (Module.hasOwnProperty(name2)) {
              if (void 0 === numArguments || void 0 !== Module[name2].overloadTable && void 0 !== Module[name2].overloadTable[numArguments]) {
                throwBindingError(`Cannot register public name '${name2}' twice`);
              }
              ensureOverloadTable(Module, name2, name2);
              if (Module.hasOwnProperty(numArguments)) {
                throwBindingError(`Cannot register multiple overloads of a function with the same number of arguments (${numArguments})!`);
              }
              Module[name2].overloadTable[numArguments] = value;
            } else {
              Module[name2] = value;
              if (void 0 !== numArguments) {
                Module[name2].numArguments = numArguments;
              }
            }
          };
          var replacePublicSymbol = (name2, value, numArguments) => {
            if (!Module.hasOwnProperty(name2)) {
              throwInternalError("Replacing nonexistant public symbol");
            }
            if (void 0 !== Module[name2].overloadTable && void 0 !== numArguments) {
              Module[name2].overloadTable[numArguments] = value;
            } else {
              Module[name2] = value;
              Module[name2].argCount = numArguments;
            }
          };
          var getBasestPointer = (class_, ptr2) => {
            if (ptr2 === void 0) {
              throwBindingError("ptr should not be undefined");
            }
            while (class_.baseClass) {
              ptr2 = class_.upcast(ptr2);
              class_ = class_.baseClass;
            }
            return ptr2;
          };
          var registerInheritedInstance = (class_, ptr2, instance10) => {
            ptr2 = getBasestPointer(class_, ptr2);
            if (registeredInstances.hasOwnProperty(ptr2)) {
              throwBindingError(`Tried to register registered instance: ${ptr2}`);
            } else {
              registeredInstances[ptr2] = instance10;
            }
          };
          var unregisterInheritedInstance = (class_, ptr2) => {
            ptr2 = getBasestPointer(class_, ptr2);
            if (registeredInstances.hasOwnProperty(ptr2)) {
              delete registeredInstances[ptr2];
            } else {
              throwBindingError(`Tried to unregister unregistered instance: ${ptr2}`);
            }
          };
          var getInheritedInstance = (class_, ptr2) => {
            ptr2 = getBasestPointer(class_, ptr2);
            return registeredInstances[ptr2];
          };
          var registeredPointers = {};
          var enumReadValueFromPointer = (name2, width, signed) => {
            switch (width) {
              case 1:
                return signed ? function(pointer) {
                  return this["fromWireType"](HEAP8[pointer >>> 0 >>> 0]);
                } : function(pointer) {
                  return this["fromWireType"](HEAPU8[pointer >>> 0 >>> 0]);
                };
              case 2:
                return signed ? function(pointer) {
                  return this["fromWireType"](HEAP16[pointer >>> 1 >>> 0]);
                } : function(pointer) {
                  return this["fromWireType"](HEAPU16[pointer >>> 1 >>> 0]);
                };
              case 4:
                return signed ? function(pointer) {
                  return this["fromWireType"](HEAP32[pointer >>> 2 >>> 0]);
                } : function(pointer) {
                  return this["fromWireType"](HEAPU32[pointer >>> 2 >>> 0]);
                };
              default:
                throw new TypeError(`invalid integer width (${width}): ${name2}`);
            }
          };
          function __embind_register_user_type(rawType, name2) {
            rawType >>>= 0;
            name2 >>>= 0;
            __embind_register_emval(rawType);
          }
          __embind_register_user_type.sig = "vpp";
          function __embind_register_optional(rawOptionalType, rawType) {
            rawOptionalType >>>= 0;
            rawType >>>= 0;
            __embind_register_emval(rawOptionalType);
          }
          __embind_register_optional.sig = "vpp";
          var runDestructors = (destructors) => {
            while (destructors.length) {
              var ptr2 = destructors.pop();
              var del = destructors.pop();
              del(ptr2);
            }
          };
          function newFunc(constructor, argumentList) {
            if (!(constructor instanceof Function)) {
              throw new TypeError(`new_ called with constructor type ${typeof constructor} which is not a function`);
            }
            var dummy = createNamedFunction(constructor.name || "unknownFunctionName", function() {
            });
            dummy.prototype = constructor.prototype;
            var obj = new dummy();
            var r = constructor.apply(obj, argumentList);
            return r instanceof Object ? r : obj;
          }
          function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc, isAsync) {
            var argCount = argTypes.length;
            if (argCount < 2) {
              throwBindingError("argTypes array size mismatch! Must at least get return value and 'this' types!");
            }
            var isClassMethodFunc = argTypes[1] !== null && classType !== null;
            var needsDestructorStack = usesDestructorStack(argTypes);
            var returns = argTypes[0].name !== "void";
            var closureArgs = [throwBindingError, cppInvokerFunc, cppTargetFunc, runDestructors, argTypes[0], argTypes[1]];
            for (var i2 = 0; i2 < argCount - 2; ++i2) {
              closureArgs.push(argTypes[i2 + 2]);
            }
            if (!needsDestructorStack) {
              for (var i2 = isClassMethodFunc ? 1 : 2; i2 < argTypes.length; ++i2) {
                if (argTypes[i2].destructorFunction !== null) {
                  closureArgs.push(argTypes[i2].destructorFunction);
                }
              }
            }
            let [args2, invokerFnBody] = createJsInvoker(humanName, argTypes, isClassMethodFunc, returns, isAsync);
            args2.push(invokerFnBody);
            var invokerFn = newFunc(Function, args2).apply(null, closureArgs);
            return createNamedFunction(humanName, invokerFn);
          }
          var embind__requireFunction = (signature, rawFunction) => {
            signature = readLatin1String(signature);
            function makeDynCaller() {
              if (signature.includes("j")) {
                return getDynCaller(signature, rawFunction);
              }
              return getWasmTableEntry(rawFunction);
            }
            var fp = makeDynCaller();
            if (typeof fp != "function") {
              throwBindingError(`unknown function pointer with signature ${signature}: ${rawFunction}`);
            }
            return fp;
          };
          function __embind_register_function(name2, argCount, rawArgTypesAddr, signature, rawInvoker, fn, isAsync) {
            name2 >>>= 0;
            rawArgTypesAddr >>>= 0;
            signature >>>= 0;
            rawInvoker >>>= 0;
            fn >>>= 0;
            var argTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
            name2 = readLatin1String(name2);
            name2 = getFunctionName(name2);
            rawInvoker = embind__requireFunction(signature, rawInvoker);
            exposePublicSymbol(name2, function() {
              throwUnboundTypeError(`Cannot call ${name2} due to unbound types`, argTypes);
            }, argCount - 1);
            whenDependentTypesAreResolved([], argTypes, function(argTypes2) {
              var invokerArgsArray = [argTypes2[0], null].concat(argTypes2.slice(1));
              replacePublicSymbol(name2, craftInvokerFunction(name2, invokerArgsArray, null, rawInvoker, fn, isAsync), argCount - 1);
              return [];
            });
          }
          __embind_register_function.sig = "vpippppi";
          function __embind_register_value_array(rawType, name2, constructorSignature, rawConstructor, destructorSignature, rawDestructor) {
            rawType >>>= 0;
            name2 >>>= 0;
            constructorSignature >>>= 0;
            rawConstructor >>>= 0;
            destructorSignature >>>= 0;
            rawDestructor >>>= 0;
            tupleRegistrations[rawType] = {
              name: readLatin1String(name2),
              rawConstructor: embind__requireFunction(constructorSignature, rawConstructor),
              rawDestructor: embind__requireFunction(destructorSignature, rawDestructor),
              elements: []
            };
          }
          __embind_register_value_array.sig = "vpppppp";
          function __embind_register_value_array_element(rawTupleType, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {
            rawTupleType >>>= 0;
            getterReturnType >>>= 0;
            getterSignature >>>= 0;
            getter >>>= 0;
            getterContext >>>= 0;
            setterArgumentType >>>= 0;
            setterSignature >>>= 0;
            setter >>>= 0;
            setterContext >>>= 0;
            tupleRegistrations[rawTupleType].elements.push({
              getterReturnType,
              getter: embind__requireFunction(getterSignature, getter),
              getterContext,
              setterArgumentType,
              setter: embind__requireFunction(setterSignature, setter),
              setterContext
            });
          }
          __embind_register_value_array_element.sig = "vppppppppp";
          var __embind_finalize_value_array = function(rawTupleType) {
            rawTupleType >>>= 0;
            var reg = tupleRegistrations[rawTupleType];
            delete tupleRegistrations[rawTupleType];
            var elements = reg.elements;
            var elementsLength = elements.length;
            var elementTypes = elements.map((elt) => elt.getterReturnType).concat(elements.map((elt) => elt.setterArgumentType));
            var rawConstructor = reg.rawConstructor;
            var rawDestructor = reg.rawDestructor;
            whenDependentTypesAreResolved([rawTupleType], elementTypes, function(elementTypes2) {
              elements.forEach((elt, i2) => {
                var getterReturnType = elementTypes2[i2];
                var getter = elt.getter;
                var getterContext = elt.getterContext;
                var setterArgumentType = elementTypes2[i2 + elementsLength];
                var setter = elt.setter;
                var setterContext = elt.setterContext;
                elt.read = (ptr2) => getterReturnType["fromWireType"](getter(getterContext, ptr2));
                elt.write = (ptr2, o) => {
                  var destructors = [];
                  setter(setterContext, ptr2, setterArgumentType["toWireType"](destructors, o));
                  runDestructors(destructors);
                };
              });
              return [{
                name: reg.name,
                "fromWireType": (ptr2) => {
                  var rv = new Array(elementsLength);
                  for (var i2 = 0; i2 < elementsLength; ++i2) {
                    rv[i2] = elements[i2].read(ptr2);
                  }
                  rawDestructor(ptr2);
                  return rv;
                },
                "toWireType": (destructors, o) => {
                  if (elementsLength !== o.length) {
                    throw new TypeError(`Incorrect number of tuple elements for ${reg.name}: expected=${elementsLength}, actual=${o.length}`);
                  }
                  var ptr2 = rawConstructor();
                  for (var i2 = 0; i2 < elementsLength; ++i2) {
                    elements[i2].write(ptr2, o[i2]);
                  }
                  if (destructors !== null) {
                    destructors.push(rawDestructor, ptr2);
                  }
                  return ptr2;
                },
                "argPackAdvance": GenericWireTypeSize,
                "readValueFromPointer": simpleReadValueFromPointer,
                destructorFunction: rawDestructor
              }];
            });
          };
          __embind_finalize_value_array.sig = "vp";
          function __embind_register_value_object(rawType, name2, constructorSignature, rawConstructor, destructorSignature, rawDestructor) {
            rawType >>>= 0;
            name2 >>>= 0;
            constructorSignature >>>= 0;
            rawConstructor >>>= 0;
            destructorSignature >>>= 0;
            rawDestructor >>>= 0;
            structRegistrations[rawType] = {
              name: readLatin1String(name2),
              rawConstructor: embind__requireFunction(constructorSignature, rawConstructor),
              rawDestructor: embind__requireFunction(destructorSignature, rawDestructor),
              fields: []
            };
          }
          __embind_register_value_object.sig = "vpppppp";
          function __embind_register_value_object_field(structType, fieldName, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {
            structType >>>= 0;
            fieldName >>>= 0;
            getterReturnType >>>= 0;
            getterSignature >>>= 0;
            getter >>>= 0;
            getterContext >>>= 0;
            setterArgumentType >>>= 0;
            setterSignature >>>= 0;
            setter >>>= 0;
            setterContext >>>= 0;
            structRegistrations[structType].fields.push({
              fieldName: readLatin1String(fieldName),
              getterReturnType,
              getter: embind__requireFunction(getterSignature, getter),
              getterContext,
              setterArgumentType,
              setter: embind__requireFunction(setterSignature, setter),
              setterContext
            });
          }
          __embind_register_value_object_field.sig = "vpppppppppp";
          var __embind_finalize_value_object = function(structType) {
            structType >>>= 0;
            var reg = structRegistrations[structType];
            delete structRegistrations[structType];
            var rawConstructor = reg.rawConstructor;
            var rawDestructor = reg.rawDestructor;
            var fieldRecords = reg.fields;
            var fieldTypes = fieldRecords.map((field) => field.getterReturnType).concat(fieldRecords.map((field) => field.setterArgumentType));
            whenDependentTypesAreResolved([structType], fieldTypes, (fieldTypes2) => {
              var fields = {};
              fieldRecords.forEach((field, i2) => {
                var fieldName = field.fieldName;
                var getterReturnType = fieldTypes2[i2];
                var getter = field.getter;
                var getterContext = field.getterContext;
                var setterArgumentType = fieldTypes2[i2 + fieldRecords.length];
                var setter = field.setter;
                var setterContext = field.setterContext;
                fields[fieldName] = {
                  read: (ptr2) => getterReturnType["fromWireType"](getter(getterContext, ptr2)),
                  write: (ptr2, o) => {
                    var destructors = [];
                    setter(setterContext, ptr2, setterArgumentType["toWireType"](destructors, o));
                    runDestructors(destructors);
                  }
                };
              });
              return [{
                name: reg.name,
                "fromWireType": (ptr2) => {
                  var rv = {};
                  for (var i2 in fields) {
                    rv[i2] = fields[i2].read(ptr2);
                  }
                  rawDestructor(ptr2);
                  return rv;
                },
                "toWireType": (destructors, o) => {
                  for (var fieldName in fields) {
                    if (!(fieldName in o)) {
                      throw new TypeError(`Missing field: "${fieldName}"`);
                    }
                  }
                  var ptr2 = rawConstructor();
                  for (fieldName in fields) {
                    fields[fieldName].write(ptr2, o[fieldName]);
                  }
                  if (destructors !== null) {
                    destructors.push(rawDestructor, ptr2);
                  }
                  return ptr2;
                },
                "argPackAdvance": GenericWireTypeSize,
                "readValueFromPointer": simpleReadValueFromPointer,
                destructorFunction: rawDestructor
              }];
            });
          };
          __embind_finalize_value_object.sig = "vp";
          var upcastPointer = (ptr2, ptrClass, desiredClass) => {
            while (ptrClass !== desiredClass) {
              if (!ptrClass.upcast) {
                throwBindingError(`Expected null or instance of ${desiredClass.name}, got an instance of ${ptrClass.name}`);
              }
              ptr2 = ptrClass.upcast(ptr2);
              ptrClass = ptrClass.baseClass;
            }
            return ptr2;
          };
          function genericPointerToWireType(destructors, handle2) {
            var ptr2;
            if (handle2 === null) {
              if (this.isReference) {
                throwBindingError(`null is not a valid ${this.name}`);
              }
              if (this.isSmartPointer) {
                ptr2 = this.rawConstructor();
                if (destructors !== null) {
                  destructors.push(this.rawDestructor, ptr2);
                }
                return ptr2;
              } else {
                return 0;
              }
            }
            if (!handle2 || !handle2.$$) {
              throwBindingError(`Cannot pass "${embindRepr(handle2)}" as a ${this.name}`);
            }
            if (!handle2.$$.ptr) {
              throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);
            }
            if (!this.isConst && handle2.$$.ptrType.isConst) {
              throwBindingError(`Cannot convert argument of type ${handle2.$$.smartPtrType ? handle2.$$.smartPtrType.name : handle2.$$.ptrType.name} to parameter type ${this.name}`);
            }
            var handleClass = handle2.$$.ptrType.registeredClass;
            ptr2 = upcastPointer(handle2.$$.ptr, handleClass, this.registeredClass);
            if (this.isSmartPointer) {
              if (void 0 === handle2.$$.smartPtr) {
                throwBindingError("Passing raw pointer to smart pointer is illegal");
              }
              switch (this.sharingPolicy) {
                case 0:
                  if (handle2.$$.smartPtrType === this) {
                    ptr2 = handle2.$$.smartPtr;
                  } else {
                    throwBindingError(`Cannot convert argument of type ${handle2.$$.smartPtrType ? handle2.$$.smartPtrType.name : handle2.$$.ptrType.name} to parameter type ${this.name}`);
                  }
                  break;
                case 1:
                  ptr2 = handle2.$$.smartPtr;
                  break;
                case 2:
                  if (handle2.$$.smartPtrType === this) {
                    ptr2 = handle2.$$.smartPtr;
                  } else {
                    var clonedHandle = handle2["clone"]();
                    ptr2 = this.rawShare(ptr2, Emval.toHandle(() => clonedHandle["delete"]()));
                    if (destructors !== null) {
                      destructors.push(this.rawDestructor, ptr2);
                    }
                  }
                  break;
                default:
                  throwBindingError("Unsupporting sharing policy");
              }
            }
            return ptr2;
          }
          function constNoSmartPtrRawPointerToWireType(destructors, handle2) {
            if (handle2 === null) {
              if (this.isReference) {
                throwBindingError(`null is not a valid ${this.name}`);
              }
              return 0;
            }
            if (!handle2.$$) {
              throwBindingError(`Cannot pass "${embindRepr(handle2)}" as a ${this.name}`);
            }
            if (!handle2.$$.ptr) {
              throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);
            }
            var handleClass = handle2.$$.ptrType.registeredClass;
            var ptr2 = upcastPointer(handle2.$$.ptr, handleClass, this.registeredClass);
            return ptr2;
          }
          function nonConstNoSmartPtrRawPointerToWireType(destructors, handle2) {
            if (handle2 === null) {
              if (this.isReference) {
                throwBindingError(`null is not a valid ${this.name}`);
              }
              return 0;
            }
            if (!handle2.$$) {
              throwBindingError(`Cannot pass "${embindRepr(handle2)}" as a ${this.name}`);
            }
            if (!handle2.$$.ptr) {
              throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);
            }
            if (handle2.$$.ptrType.isConst) {
              throwBindingError(`Cannot convert argument of type ${handle2.$$.ptrType.name} to parameter type ${this.name}`);
            }
            var handleClass = handle2.$$.ptrType.registeredClass;
            var ptr2 = upcastPointer(handle2.$$.ptr, handleClass, this.registeredClass);
            return ptr2;
          }
          function RegisteredPointer(name2, registeredClass, isReference, isConst, isSmartPointer, pointeeType, sharingPolicy, rawGetPointee, rawConstructor, rawShare, rawDestructor) {
            this.name = name2;
            this.registeredClass = registeredClass;
            this.isReference = isReference;
            this.isConst = isConst;
            this.isSmartPointer = isSmartPointer;
            this.pointeeType = pointeeType;
            this.sharingPolicy = sharingPolicy;
            this.rawGetPointee = rawGetPointee;
            this.rawConstructor = rawConstructor;
            this.rawShare = rawShare;
            this.rawDestructor = rawDestructor;
            if (!isSmartPointer && registeredClass.baseClass === void 0) {
              if (isConst) {
                this["toWireType"] = constNoSmartPtrRawPointerToWireType;
                this.destructorFunction = null;
              } else {
                this["toWireType"] = nonConstNoSmartPtrRawPointerToWireType;
                this.destructorFunction = null;
              }
            } else {
              this["toWireType"] = genericPointerToWireType;
            }
          }
          var downcastPointer = (ptr2, ptrClass, desiredClass) => {
            if (ptrClass === desiredClass) {
              return ptr2;
            }
            if (void 0 === desiredClass.baseClass) {
              return null;
            }
            var rv = downcastPointer(ptr2, ptrClass, desiredClass.baseClass);
            if (rv === null) {
              return null;
            }
            return desiredClass.downcast(rv);
          };
          var finalizationRegistry = false;
          var detachFinalizer = (handle2) => {
          };
          var runDestructor = ($$) => {
            if ($$.smartPtr) {
              $$.smartPtrType.rawDestructor($$.smartPtr);
            } else {
              $$.ptrType.registeredClass.rawDestructor($$.ptr);
            }
          };
          var releaseClassHandle = ($$) => {
            $$.count.value -= 1;
            var toDelete = 0 === $$.count.value;
            if (toDelete) {
              runDestructor($$);
            }
          };
          var attachFinalizer = (handle2) => {
            if ("undefined" === typeof FinalizationRegistry) {
              attachFinalizer = (handle3) => handle3;
              return handle2;
            }
            finalizationRegistry = new FinalizationRegistry((info2) => {
              releaseClassHandle(info2.$$);
            });
            attachFinalizer = (handle3) => {
              var $$ = handle3.$$;
              var hasSmartPtr = !!$$.smartPtr;
              if (hasSmartPtr) {
                var info2 = {
                  $$
                };
                finalizationRegistry.register(handle3, info2, handle3);
              }
              return handle3;
            };
            detachFinalizer = (handle3) => finalizationRegistry.unregister(handle3);
            return attachFinalizer(handle2);
          };
          var makeClassHandle = (prototype, record) => {
            if (!record.ptrType || !record.ptr) {
              throwInternalError("makeClassHandle requires ptr and ptrType");
            }
            var hasSmartPtrType = !!record.smartPtrType;
            var hasSmartPtr = !!record.smartPtr;
            if (hasSmartPtrType !== hasSmartPtr) {
              throwInternalError("Both smartPtrType and smartPtr must be specified");
            }
            record.count = {
              value: 1
            };
            return attachFinalizer(Object.create(prototype, {
              $$: {
                value: record,
                writable: true
              }
            }));
          };
          function RegisteredPointer_fromWireType(ptr2) {
            var rawPointer = this.getPointee(ptr2);
            if (!rawPointer) {
              this.destructor(ptr2);
              return null;
            }
            var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);
            if (void 0 !== registeredInstance) {
              if (0 === registeredInstance.$$.count.value) {
                registeredInstance.$$.ptr = rawPointer;
                registeredInstance.$$.smartPtr = ptr2;
                return registeredInstance["clone"]();
              } else {
                var rv = registeredInstance["clone"]();
                this.destructor(ptr2);
                return rv;
              }
            }
            function makeDefaultHandle() {
              if (this.isSmartPointer) {
                return makeClassHandle(this.registeredClass.instancePrototype, {
                  ptrType: this.pointeeType,
                  ptr: rawPointer,
                  smartPtrType: this,
                  smartPtr: ptr2
                });
              } else {
                return makeClassHandle(this.registeredClass.instancePrototype, {
                  ptrType: this,
                  ptr: ptr2
                });
              }
            }
            var actualType = this.registeredClass.getActualType(rawPointer);
            var registeredPointerRecord = registeredPointers[actualType];
            if (!registeredPointerRecord) {
              return makeDefaultHandle.call(this);
            }
            var toType;
            if (this.isConst) {
              toType = registeredPointerRecord.constPointerType;
            } else {
              toType = registeredPointerRecord.pointerType;
            }
            var dp = downcastPointer(rawPointer, this.registeredClass, toType.registeredClass);
            if (dp === null) {
              return makeDefaultHandle.call(this);
            }
            if (this.isSmartPointer) {
              return makeClassHandle(toType.registeredClass.instancePrototype, {
                ptrType: toType,
                ptr: dp,
                smartPtrType: this,
                smartPtr: ptr2
              });
            } else {
              return makeClassHandle(toType.registeredClass.instancePrototype, {
                ptrType: toType,
                ptr: dp
              });
            }
          }
          var init_RegisteredPointer = () => {
            Object.assign(RegisteredPointer.prototype, {
              getPointee(ptr2) {
                if (this.rawGetPointee) {
                  ptr2 = this.rawGetPointee(ptr2);
                }
                return ptr2;
              },
              destructor(ptr2) {
                this.rawDestructor?.(ptr2);
              },
              "argPackAdvance": GenericWireTypeSize,
              "readValueFromPointer": readPointer,
              "fromWireType": RegisteredPointer_fromWireType
            });
          };
          var detachFinalizer_deps = ["$finalizationRegistry"];
          function ClassHandle() {
          }
          var shallowCopyInternalPointer = (o) => ({
            count: o.count,
            deleteScheduled: o.deleteScheduled,
            preservePointerOnDelete: o.preservePointerOnDelete,
            ptr: o.ptr,
            ptrType: o.ptrType,
            smartPtr: o.smartPtr,
            smartPtrType: o.smartPtrType
          });
          var throwInstanceAlreadyDeleted = (obj) => {
            function getInstanceTypeName(handle2) {
              return handle2.$$.ptrType.registeredClass.name;
            }
            throwBindingError(getInstanceTypeName(obj) + " instance already deleted");
          };
          var init_ClassHandle = () => {
            Object.assign(ClassHandle.prototype, {
              "isAliasOf"(other) {
                if (!(this instanceof ClassHandle)) {
                  return false;
                }
                if (!(other instanceof ClassHandle)) {
                  return false;
                }
                var leftClass = this.$$.ptrType.registeredClass;
                var left = this.$$.ptr;
                other.$$ = other.$$;
                var rightClass = other.$$.ptrType.registeredClass;
                var right = other.$$.ptr;
                while (leftClass.baseClass) {
                  left = leftClass.upcast(left);
                  leftClass = leftClass.baseClass;
                }
                while (rightClass.baseClass) {
                  right = rightClass.upcast(right);
                  rightClass = rightClass.baseClass;
                }
                return leftClass === rightClass && left === right;
              },
              "clone"() {
                if (!this.$$.ptr) {
                  throwInstanceAlreadyDeleted(this);
                }
                if (this.$$.preservePointerOnDelete) {
                  this.$$.count.value += 1;
                  return this;
                } else {
                  var clone = attachFinalizer(Object.create(Object.getPrototypeOf(this), {
                    $$: {
                      value: shallowCopyInternalPointer(this.$$)
                    }
                  }));
                  clone.$$.count.value += 1;
                  clone.$$.deleteScheduled = false;
                  return clone;
                }
              },
              "delete"() {
                if (!this.$$.ptr) {
                  throwInstanceAlreadyDeleted(this);
                }
                if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
                  throwBindingError("Object already scheduled for deletion");
                }
                detachFinalizer(this);
                releaseClassHandle(this.$$);
                if (!this.$$.preservePointerOnDelete) {
                  this.$$.smartPtr = void 0;
                  this.$$.ptr = void 0;
                }
              },
              "isDeleted"() {
                return !this.$$.ptr;
              },
              "deleteLater"() {
                if (!this.$$.ptr) {
                  throwInstanceAlreadyDeleted(this);
                }
                if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
                  throwBindingError("Object already scheduled for deletion");
                }
                deletionQueue.push(this);
                if (deletionQueue.length === 1 && delayFunction) {
                  delayFunction(flushPendingDeletes);
                }
                this.$$.deleteScheduled = true;
                return this;
              }
            });
          };
          function RegisteredClass(name2, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast) {
            this.name = name2;
            this.constructor = constructor;
            this.instancePrototype = instancePrototype;
            this.rawDestructor = rawDestructor;
            this.baseClass = baseClass;
            this.getActualType = getActualType;
            this.upcast = upcast;
            this.downcast = downcast;
            this.pureVirtualFunctions = [];
          }
          var char_0 = 48;
          var char_9 = 57;
          var makeLegalFunctionName = (name2) => {
            if (void 0 === name2) {
              return "_unknown";
            }
            name2 = name2.replace(/[^a-zA-Z0-9_]/g, "$");
            var f = name2.charCodeAt(0);
            if (f >= char_0 && f <= char_9) {
              return `_${name2}`;
            }
            return name2;
          };
          function __embind_register_class(rawType, rawPointerType, rawConstPointerType, baseClassRawType, getActualTypeSignature, getActualType, upcastSignature, upcast, downcastSignature, downcast, name2, destructorSignature, rawDestructor) {
            rawType >>>= 0;
            rawPointerType >>>= 0;
            rawConstPointerType >>>= 0;
            baseClassRawType >>>= 0;
            getActualTypeSignature >>>= 0;
            getActualType >>>= 0;
            upcastSignature >>>= 0;
            upcast >>>= 0;
            downcastSignature >>>= 0;
            downcast >>>= 0;
            name2 >>>= 0;
            destructorSignature >>>= 0;
            rawDestructor >>>= 0;
            name2 = readLatin1String(name2);
            getActualType = embind__requireFunction(getActualTypeSignature, getActualType);
            upcast && (upcast = embind__requireFunction(upcastSignature, upcast));
            downcast && (downcast = embind__requireFunction(downcastSignature, downcast));
            rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);
            var legalFunctionName = makeLegalFunctionName(name2);
            exposePublicSymbol(legalFunctionName, function() {
              throwUnboundTypeError(`Cannot construct ${name2} due to unbound types`, [baseClassRawType]);
            });
            whenDependentTypesAreResolved([rawType, rawPointerType, rawConstPointerType], baseClassRawType ? [baseClassRawType] : [], function(base) {
              var _a5;
              base = base[0];
              var baseClass;
              var basePrototype;
              if (baseClassRawType) {
                baseClass = base.registeredClass;
                basePrototype = baseClass.instancePrototype;
              } else {
                basePrototype = ClassHandle.prototype;
              }
              var constructor = createNamedFunction(name2, function() {
                if (Object.getPrototypeOf(this) !== instancePrototype) {
                  throw new BindingError("Use 'new' to construct " + name2);
                }
                if (void 0 === registeredClass.constructor_body) {
                  throw new BindingError(name2 + " has no accessible constructor");
                }
                var body2 = registeredClass.constructor_body[arguments.length];
                if (void 0 === body2) {
                  throw new BindingError(`Tried to invoke ctor of ${name2} with invalid number of parameters (${arguments.length}) - expected (${Object.keys(registeredClass.constructor_body).toString()}) parameters instead!`);
                }
                return body2.apply(this, arguments);
              });
              var instancePrototype = Object.create(basePrototype, {
                constructor: {
                  value: constructor
                }
              });
              constructor.prototype = instancePrototype;
              var registeredClass = new RegisteredClass(name2, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast);
              if (registeredClass.baseClass) {
                (_a5 = registeredClass.baseClass).__derivedClasses ?? (_a5.__derivedClasses = []);
                registeredClass.baseClass.__derivedClasses.push(registeredClass);
              }
              var referenceConverter = new RegisteredPointer(name2, registeredClass, true, false, false);
              var pointerConverter = new RegisteredPointer(name2 + "*", registeredClass, false, false, false);
              var constPointerConverter = new RegisteredPointer(name2 + " const*", registeredClass, false, true, false);
              registeredPointers[rawType] = {
                pointerType: pointerConverter,
                constPointerType: constPointerConverter
              };
              replacePublicSymbol(legalFunctionName, constructor);
              return [referenceConverter, pointerConverter, constPointerConverter];
            });
          }
          __embind_register_class.sig = "vppppppppppppp";
          function __embind_register_class_constructor(rawClassType, argCount, rawArgTypesAddr, invokerSignature, invoker, rawConstructor) {
            rawClassType >>>= 0;
            rawArgTypesAddr >>>= 0;
            invokerSignature >>>= 0;
            invoker >>>= 0;
            rawConstructor >>>= 0;
            var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
            invoker = embind__requireFunction(invokerSignature, invoker);
            var args2 = [rawConstructor];
            var destructors = [];
            whenDependentTypesAreResolved([], [rawClassType], function(classType) {
              classType = classType[0];
              var humanName = `constructor ${classType.name}`;
              if (void 0 === classType.registeredClass.constructor_body) {
                classType.registeredClass.constructor_body = [];
              }
              if (void 0 !== classType.registeredClass.constructor_body[argCount - 1]) {
                throw new BindingError(`Cannot register multiple constructors with identical number of parameters (${argCount - 1}) for class '${classType.name}'! Overload resolution is currently only performed using the parameter count, not actual type info!`);
              }
              classType.registeredClass.constructor_body[argCount - 1] = () => {
                throwUnboundTypeError(`Cannot construct ${classType.name} due to unbound types`, rawArgTypes);
              };
              whenDependentTypesAreResolved([], rawArgTypes, (argTypes) => {
                argTypes.splice(1, 0, null);
                classType.registeredClass.constructor_body[argCount - 1] = craftInvokerFunction(humanName, argTypes, null, invoker, rawConstructor);
                return [];
              });
              return [];
            });
          }
          __embind_register_class_constructor.sig = "vpipppp";
          var validateThis = (this_, classType, humanName) => {
            if (!(this_ instanceof Object)) {
              throwBindingError(`${humanName} with invalid "this": ${this_}`);
            }
            if (!(this_ instanceof classType.registeredClass.constructor)) {
              throwBindingError(`${humanName} incompatible with "this" of type ${this_.constructor.name}`);
            }
            if (!this_.$$.ptr) {
              throwBindingError(`cannot call emscripten binding method ${humanName} on deleted object`);
            }
            return upcastPointer(this_.$$.ptr, this_.$$.ptrType.registeredClass, classType.registeredClass);
          };
          function __embind_register_class_function(rawClassType, methodName, argCount, rawArgTypesAddr, invokerSignature, rawInvoker, context, isPureVirtual, isAsync) {
            rawClassType >>>= 0;
            methodName >>>= 0;
            rawArgTypesAddr >>>= 0;
            invokerSignature >>>= 0;
            rawInvoker >>>= 0;
            context >>>= 0;
            var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
            methodName = readLatin1String(methodName);
            methodName = getFunctionName(methodName);
            rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);
            whenDependentTypesAreResolved([], [rawClassType], function(classType) {
              classType = classType[0];
              var humanName = `${classType.name}.${methodName}`;
              if (methodName.startsWith("@@")) {
                methodName = Symbol[methodName.substring(2)];
              }
              if (isPureVirtual) {
                classType.registeredClass.pureVirtualFunctions.push(methodName);
              }
              function unboundTypesHandler() {
                throwUnboundTypeError(`Cannot call ${humanName} due to unbound types`, rawArgTypes);
              }
              var proto = classType.registeredClass.instancePrototype;
              var method = proto[methodName];
              if (void 0 === method || void 0 === method.overloadTable && method.className !== classType.name && method.argCount === argCount - 2) {
                unboundTypesHandler.argCount = argCount - 2;
                unboundTypesHandler.className = classType.name;
                proto[methodName] = unboundTypesHandler;
              } else {
                ensureOverloadTable(proto, methodName, humanName);
                proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;
              }
              whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
                var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context, isAsync);
                if (void 0 === proto[methodName].overloadTable) {
                  memberFunction.argCount = argCount - 2;
                  proto[methodName] = memberFunction;
                } else {
                  proto[methodName].overloadTable[argCount - 2] = memberFunction;
                }
                return [];
              });
              return [];
            });
          }
          __embind_register_class_function.sig = "vppippppii";
          function __embind_register_class_property(classType, fieldName, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {
            classType >>>= 0;
            fieldName >>>= 0;
            getterReturnType >>>= 0;
            getterSignature >>>= 0;
            getter >>>= 0;
            getterContext >>>= 0;
            setterArgumentType >>>= 0;
            setterSignature >>>= 0;
            setter >>>= 0;
            setterContext >>>= 0;
            fieldName = readLatin1String(fieldName);
            getter = embind__requireFunction(getterSignature, getter);
            whenDependentTypesAreResolved([], [classType], function(classType2) {
              classType2 = classType2[0];
              var humanName = `${classType2.name}.${fieldName}`;
              var desc = {
                get() {
                  throwUnboundTypeError(`Cannot access ${humanName} due to unbound types`, [getterReturnType, setterArgumentType]);
                },
                enumerable: true,
                configurable: true
              };
              if (setter) {
                desc.set = () => throwUnboundTypeError(`Cannot access ${humanName} due to unbound types`, [getterReturnType, setterArgumentType]);
              } else {
                desc.set = (v) => throwBindingError(humanName + " is a read-only property");
              }
              Object.defineProperty(classType2.registeredClass.instancePrototype, fieldName, desc);
              whenDependentTypesAreResolved([], setter ? [getterReturnType, setterArgumentType] : [getterReturnType], function(types) {
                var getterReturnType2 = types[0];
                var desc2 = {
                  get() {
                    var ptr2 = validateThis(this, classType2, humanName + " getter");
                    return getterReturnType2["fromWireType"](getter(getterContext, ptr2));
                  },
                  enumerable: true
                };
                if (setter) {
                  setter = embind__requireFunction(setterSignature, setter);
                  var setterArgumentType2 = types[1];
                  desc2.set = function(v) {
                    var ptr2 = validateThis(this, classType2, humanName + " setter");
                    var destructors = [];
                    setter(setterContext, ptr2, setterArgumentType2["toWireType"](destructors, v));
                    runDestructors(destructors);
                  };
                }
                Object.defineProperty(classType2.registeredClass.instancePrototype, fieldName, desc2);
                return [];
              });
              return [];
            });
          }
          __embind_register_class_property.sig = "vpppppppppp";
          function __embind_register_class_class_function(rawClassType, methodName, argCount, rawArgTypesAddr, invokerSignature, rawInvoker, fn, isAsync) {
            rawClassType >>>= 0;
            methodName >>>= 0;
            rawArgTypesAddr >>>= 0;
            invokerSignature >>>= 0;
            rawInvoker >>>= 0;
            fn >>>= 0;
            var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
            methodName = readLatin1String(methodName);
            methodName = getFunctionName(methodName);
            rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);
            whenDependentTypesAreResolved([], [rawClassType], function(classType) {
              classType = classType[0];
              var humanName = `${classType.name}.${methodName}`;
              function unboundTypesHandler() {
                throwUnboundTypeError(`Cannot call ${humanName} due to unbound types`, rawArgTypes);
              }
              if (methodName.startsWith("@@")) {
                methodName = Symbol[methodName.substring(2)];
              }
              var proto = classType.registeredClass.constructor;
              if (void 0 === proto[methodName]) {
                unboundTypesHandler.argCount = argCount - 1;
                proto[methodName] = unboundTypesHandler;
              } else {
                ensureOverloadTable(proto, methodName, humanName);
                proto[methodName].overloadTable[argCount - 1] = unboundTypesHandler;
              }
              whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
                var invokerArgsArray = [argTypes[0], null].concat(argTypes.slice(1));
                var func2 = craftInvokerFunction(humanName, invokerArgsArray, null, rawInvoker, fn, isAsync);
                if (void 0 === proto[methodName].overloadTable) {
                  func2.argCount = argCount - 1;
                  proto[methodName] = func2;
                } else {
                  proto[methodName].overloadTable[argCount - 1] = func2;
                }
                if (classType.registeredClass.__derivedClasses) {
                  for (const derivedClass of classType.registeredClass.__derivedClasses) {
                    if (!derivedClass.constructor.hasOwnProperty(methodName)) {
                      derivedClass.constructor[methodName] = func2;
                    }
                  }
                }
                return [];
              });
              return [];
            });
          }
          __embind_register_class_class_function.sig = "vppippppi";
          function __embind_register_class_class_property(rawClassType, fieldName, rawFieldType, rawFieldPtr, getterSignature, getter, setterSignature, setter) {
            rawClassType >>>= 0;
            fieldName >>>= 0;
            rawFieldType >>>= 0;
            rawFieldPtr >>>= 0;
            getterSignature >>>= 0;
            getter >>>= 0;
            setterSignature >>>= 0;
            setter >>>= 0;
            fieldName = readLatin1String(fieldName);
            getter = embind__requireFunction(getterSignature, getter);
            whenDependentTypesAreResolved([], [rawClassType], function(classType) {
              classType = classType[0];
              var humanName = `${classType.name}.${fieldName}`;
              var desc = {
                get() {
                  throwUnboundTypeError(`Cannot access ${humanName} due to unbound types`, [rawFieldType]);
                },
                enumerable: true,
                configurable: true
              };
              if (setter) {
                desc.set = () => {
                  throwUnboundTypeError(`Cannot access ${humanName} due to unbound types`, [rawFieldType]);
                };
              } else {
                desc.set = (v) => {
                  throwBindingError(`${humanName} is a read-only property`);
                };
              }
              Object.defineProperty(classType.registeredClass.constructor, fieldName, desc);
              whenDependentTypesAreResolved([], [rawFieldType], function(fieldType) {
                fieldType = fieldType[0];
                var desc2 = {
                  get() {
                    return fieldType["fromWireType"](getter(rawFieldPtr));
                  },
                  enumerable: true
                };
                if (setter) {
                  setter = embind__requireFunction(setterSignature, setter);
                  desc2.set = (v) => {
                    var destructors = [];
                    setter(rawFieldPtr, fieldType["toWireType"](destructors, v));
                    runDestructors(destructors);
                  };
                }
                Object.defineProperty(classType.registeredClass.constructor, fieldName, desc2);
                return [];
              });
              return [];
            });
          }
          __embind_register_class_class_property.sig = "vpppppppp";
          function __embind_create_inheriting_constructor(constructorName, wrapperType, properties) {
            constructorName >>>= 0;
            wrapperType >>>= 0;
            properties >>>= 0;
            constructorName = readLatin1String(constructorName);
            wrapperType = requireRegisteredType(wrapperType, "wrapper");
            properties = Emval.toValue(properties);
            var arraySlice = [].slice;
            var registeredClass = wrapperType.registeredClass;
            var wrapperPrototype = registeredClass.instancePrototype;
            var baseClass = registeredClass.baseClass;
            var baseClassPrototype = baseClass.instancePrototype;
            var baseConstructor = registeredClass.baseClass.constructor;
            var ctor = createNamedFunction(constructorName, function() {
              registeredClass.baseClass.pureVirtualFunctions.forEach(function(name2) {
                if (this[name2] === baseClassPrototype[name2]) {
                  throw new PureVirtualError(`Pure virtual function ${name2} must be implemented in JavaScript`);
                }
              }.bind(this));
              Object.defineProperty(this, "__parent", {
                value: wrapperPrototype
              });
              this["__construct"].apply(this, arraySlice.call(arguments));
            });
            wrapperPrototype["__construct"] = function __construct() {
              if (this === wrapperPrototype) {
                throwBindingError("Pass correct 'this' to __construct");
              }
              var inner = baseConstructor["implement"].apply(void 0, [this].concat(arraySlice.call(arguments)));
              detachFinalizer(inner);
              var $$ = inner.$$;
              inner["notifyOnDestruction"]();
              $$.preservePointerOnDelete = true;
              Object.defineProperties(this, {
                $$: {
                  value: $$
                }
              });
              attachFinalizer(this);
              registerInheritedInstance(registeredClass, $$.ptr, this);
            };
            wrapperPrototype["__destruct"] = function __destruct() {
              if (this === wrapperPrototype) {
                throwBindingError("Pass correct 'this' to __destruct");
              }
              detachFinalizer(this);
              unregisterInheritedInstance(registeredClass, this.$$.ptr);
            };
            ctor.prototype = Object.create(wrapperPrototype);
            Object.assign(ctor.prototype, properties);
            return Emval.toHandle(ctor);
          }
          __embind_create_inheriting_constructor.sig = "pppp";
          function __embind_register_smart_ptr(rawType, rawPointeeType, name2, sharingPolicy, getPointeeSignature, rawGetPointee, constructorSignature, rawConstructor, shareSignature, rawShare, destructorSignature, rawDestructor) {
            rawType >>>= 0;
            rawPointeeType >>>= 0;
            name2 >>>= 0;
            getPointeeSignature >>>= 0;
            rawGetPointee >>>= 0;
            constructorSignature >>>= 0;
            rawConstructor >>>= 0;
            shareSignature >>>= 0;
            rawShare >>>= 0;
            destructorSignature >>>= 0;
            rawDestructor >>>= 0;
            name2 = readLatin1String(name2);
            rawGetPointee = embind__requireFunction(getPointeeSignature, rawGetPointee);
            rawConstructor = embind__requireFunction(constructorSignature, rawConstructor);
            rawShare = embind__requireFunction(shareSignature, rawShare);
            rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);
            whenDependentTypesAreResolved([rawType], [rawPointeeType], function(pointeeType) {
              pointeeType = pointeeType[0];
              var registeredPointer = new RegisteredPointer(name2, pointeeType.registeredClass, false, false, true, pointeeType, sharingPolicy, rawGetPointee, rawConstructor, rawShare, rawDestructor);
              return [registeredPointer];
            });
          }
          __embind_register_smart_ptr.sig = "vpppipppppppp";
          function __embind_register_enum(rawType, name2, size, isSigned) {
            rawType >>>= 0;
            name2 >>>= 0;
            size >>>= 0;
            name2 = readLatin1String(name2);
            function ctor() {
            }
            ctor.values = {};
            registerType(rawType, {
              name: name2,
              constructor: ctor,
              "fromWireType": function(c) {
                return this.constructor.values[c];
              },
              "toWireType": (destructors, c) => c.value,
              "argPackAdvance": GenericWireTypeSize,
              "readValueFromPointer": enumReadValueFromPointer(name2, size, isSigned),
              destructorFunction: null
            });
            exposePublicSymbol(name2, ctor);
          }
          __embind_register_enum.sig = "vpppi";
          function __embind_register_enum_value(rawEnumType, name2, enumValue) {
            rawEnumType >>>= 0;
            name2 >>>= 0;
            var enumType = requireRegisteredType(rawEnumType, "enum");
            name2 = readLatin1String(name2);
            var Enum = enumType.constructor;
            var Value = Object.create(enumType.constructor.prototype, {
              value: {
                value: enumValue
              },
              constructor: {
                value: createNamedFunction(`${enumType.name}_${name2}`, function() {
                })
              }
            });
            Enum.values[enumValue] = Value;
            Enum[name2] = Value;
          }
          __embind_register_enum_value.sig = "vppi";
          function __embind_register_constant(name2, type, value) {
            name2 >>>= 0;
            type >>>= 0;
            name2 = readLatin1String(name2);
            whenDependentTypesAreResolved([], [type], function(type2) {
              type2 = type2[0];
              Module[name2] = type2["fromWireType"](value);
              return [];
            });
          }
          __embind_register_constant.sig = "vppd";
          var emval_symbols = {};
          function __emval_register_symbol(address) {
            address >>>= 0;
            emval_symbols[address] = readLatin1String(address);
          }
          __emval_register_symbol.sig = "vp";
          var getStringOrSymbol = (address) => {
            var symbol = emval_symbols[address];
            if (symbol === void 0) {
              return readLatin1String(address);
            }
            return symbol;
          };
          function __emval_incref(handle2) {
            handle2 >>>= 0;
            if (handle2 > 4) {
              emval_handles.get(handle2).refcount += 1;
            }
          }
          __emval_incref.sig = "vp";
          function __emval_run_destructors(handle2) {
            handle2 >>>= 0;
            var destructors = Emval.toValue(handle2);
            runDestructors(destructors);
            __emval_decref(handle2);
          }
          __emval_run_destructors.sig = "vp";
          function __emval_new_array() {
            return Emval.toHandle([]);
          }
          __emval_new_array.sig = "p";
          function __emval_new_array_from_memory_view(view) {
            view >>>= 0;
            view = Emval.toValue(view);
            var a = new Array(view.length);
            for (var i2 = 0; i2 < view.length; i2++)
              a[i2] = view[i2];
            return Emval.toHandle(a);
          }
          __emval_new_array_from_memory_view.sig = "pp";
          function __emval_new_object() {
            return Emval.toHandle({});
          }
          __emval_new_object.sig = "p";
          function __emval_new_cstring(v) {
            v >>>= 0;
            return Emval.toHandle(getStringOrSymbol(v));
          }
          __emval_new_cstring.sig = "pp";
          function __emval_new_u8string(v) {
            v >>>= 0;
            return Emval.toHandle(UTF8ToString(v));
          }
          __emval_new_u8string.sig = "pp";
          function __emval_new_u16string(v) {
            v >>>= 0;
            return Emval.toHandle(UTF16ToString(v));
          }
          __emval_new_u16string.sig = "pp";
          function __emval_take_value(type, arg) {
            type >>>= 0;
            arg >>>= 0;
            type = requireRegisteredType(type, "_emval_take_value");
            var v = type["readValueFromPointer"](arg);
            return Emval.toHandle(v);
          }
          __emval_take_value.sig = "ppp";
          var emval_get_global = () => {
            if (typeof globalThis == "object") {
              return globalThis;
            }
            return (/* @__PURE__ */ function() {
              return Function;
            }())("return this")();
          };
          function __emval_get_global(name2) {
            name2 >>>= 0;
            if (name2 === 0) {
              return Emval.toHandle(emval_get_global());
            } else {
              name2 = getStringOrSymbol(name2);
              return Emval.toHandle(emval_get_global()[name2]);
            }
          }
          __emval_get_global.sig = "pp";
          function __emval_get_module_property(name2) {
            name2 >>>= 0;
            name2 = getStringOrSymbol(name2);
            return Emval.toHandle(Module[name2]);
          }
          __emval_get_module_property.sig = "pp";
          function __emval_get_property(handle2, key) {
            handle2 >>>= 0;
            key >>>= 0;
            handle2 = Emval.toValue(handle2);
            key = Emval.toValue(key);
            return Emval.toHandle(handle2[key]);
          }
          __emval_get_property.sig = "ppp";
          function __emval_set_property(handle2, key, value) {
            handle2 >>>= 0;
            key >>>= 0;
            value >>>= 0;
            handle2 = Emval.toValue(handle2);
            key = Emval.toValue(key);
            value = Emval.toValue(value);
            handle2[key] = value;
          }
          __emval_set_property.sig = "vppp";
          var emval_returnValue = (returnType, destructorsRef, handle2) => {
            var destructors = [];
            var result = returnType["toWireType"](destructors, handle2);
            if (destructors.length) {
              HEAPU32[destructorsRef >>> 2 >>> 0] = Emval.toHandle(destructors);
            }
            return result;
          };
          function __emval_as(handle2, returnType, destructorsRef) {
            handle2 >>>= 0;
            returnType >>>= 0;
            destructorsRef >>>= 0;
            handle2 = Emval.toValue(handle2);
            returnType = requireRegisteredType(returnType, "emval::as");
            return emval_returnValue(returnType, destructorsRef, handle2);
          }
          __emval_as.sig = "dppp";
          function __emval_as_int64(handle2, returnType) {
            handle2 >>>= 0;
            returnType >>>= 0;
            handle2 = Emval.toValue(handle2);
            returnType = requireRegisteredType(returnType, "emval::as");
            return returnType["toWireType"](null, handle2);
          }
          __emval_as_int64.sig = "ipp";
          function __emval_as_uint64(handle2, returnType) {
            handle2 >>>= 0;
            returnType >>>= 0;
            handle2 = Emval.toValue(handle2);
            returnType = requireRegisteredType(returnType, "emval::as");
            return returnType["toWireType"](null, handle2);
          }
          __emval_as_uint64.sig = "ipp";
          function __emval_equals(first, second) {
            first >>>= 0;
            second >>>= 0;
            first = Emval.toValue(first);
            second = Emval.toValue(second);
            return first == second;
          }
          __emval_equals.sig = "ipp";
          function __emval_strictly_equals(first, second) {
            first >>>= 0;
            second >>>= 0;
            first = Emval.toValue(first);
            second = Emval.toValue(second);
            return first === second;
          }
          __emval_strictly_equals.sig = "ipp";
          function __emval_greater_than(first, second) {
            first >>>= 0;
            second >>>= 0;
            first = Emval.toValue(first);
            second = Emval.toValue(second);
            return first > second;
          }
          __emval_greater_than.sig = "ipp";
          function __emval_less_than(first, second) {
            first >>>= 0;
            second >>>= 0;
            first = Emval.toValue(first);
            second = Emval.toValue(second);
            return first < second;
          }
          __emval_less_than.sig = "ipp";
          function __emval_not(object) {
            object >>>= 0;
            object = Emval.toValue(object);
            return !object;
          }
          __emval_not.sig = "ip";
          var emval_methodCallers = [];
          function __emval_call(caller, handle2, destructorsRef, args2) {
            caller >>>= 0;
            handle2 >>>= 0;
            destructorsRef >>>= 0;
            args2 >>>= 0;
            caller = emval_methodCallers[caller];
            handle2 = Emval.toValue(handle2);
            return caller(null, handle2, destructorsRef, args2);
          }
          __emval_call.sig = "dpppp";
          var emval_lookupTypes = (argCount, argTypes) => {
            var a = new Array(argCount);
            for (var i2 = 0; i2 < argCount; ++i2) {
              a[i2] = requireRegisteredType(HEAPU32[argTypes + i2 * 4 >>> 2 >>> 0], "parameter " + i2);
            }
            return a;
          };
          var emval_addMethodCaller = (caller) => {
            var id = emval_methodCallers.length;
            emval_methodCallers.push(caller);
            return id;
          };
          var reflectConstruct = Reflect.construct;
          function __emval_get_method_caller(argCount, argTypes, kind) {
            argTypes >>>= 0;
            var types = emval_lookupTypes(argCount, argTypes);
            var retType = types.shift();
            argCount--;
            var functionBody = `return function (obj, func, destructorsRef, args) {
`;
            var offset = 0;
            var argsList = [];
            if (kind === 0) {
              argsList.push("obj");
            }
            var params = ["retType"];
            var args2 = [retType];
            for (var i2 = 0; i2 < argCount; ++i2) {
              argsList.push("arg" + i2);
              params.push("argType" + i2);
              args2.push(types[i2]);
              functionBody += `  var arg${i2} = argType${i2}.readValueFromPointer(args${offset ? "+" + offset : ""});
`;
              offset += types[i2]["argPackAdvance"];
            }
            var invoker = kind === 1 ? "new func" : "func.call";
            functionBody += `  var rv = ${invoker}(${argsList.join(", ")});
`;
            if (!retType.isVoid) {
              params.push("emval_returnValue");
              args2.push(emval_returnValue);
              functionBody += "  return emval_returnValue(retType, destructorsRef, rv);\n";
            }
            functionBody += "};\n";
            params.push(functionBody);
            var invokerFunction = newFunc(Function, params).apply(null, args2);
            var functionName = `methodCaller<(${types.map((t) => t.name).join(", ")}) => ${retType.name}>`;
            return emval_addMethodCaller(createNamedFunction(functionName, invokerFunction));
          }
          __emval_get_method_caller.sig = "pipi";
          function __emval_call_method(caller, objHandle, methodName, destructorsRef, args2) {
            caller >>>= 0;
            objHandle >>>= 0;
            methodName >>>= 0;
            destructorsRef >>>= 0;
            args2 >>>= 0;
            caller = emval_methodCallers[caller];
            objHandle = Emval.toValue(objHandle);
            methodName = getStringOrSymbol(methodName);
            return caller(objHandle, objHandle[methodName], destructorsRef, args2);
          }
          __emval_call_method.sig = "dppppp";
          function __emval_typeof(handle2) {
            handle2 >>>= 0;
            handle2 = Emval.toValue(handle2);
            return Emval.toHandle(typeof handle2);
          }
          __emval_typeof.sig = "pp";
          function __emval_instanceof(object, constructor) {
            object >>>= 0;
            constructor >>>= 0;
            object = Emval.toValue(object);
            constructor = Emval.toValue(constructor);
            return object instanceof constructor;
          }
          __emval_instanceof.sig = "ipp";
          function __emval_is_number(handle2) {
            handle2 >>>= 0;
            handle2 = Emval.toValue(handle2);
            return typeof handle2 == "number";
          }
          __emval_is_number.sig = "ip";
          function __emval_is_string(handle2) {
            handle2 >>>= 0;
            handle2 = Emval.toValue(handle2);
            return typeof handle2 == "string";
          }
          __emval_is_string.sig = "ip";
          function __emval_in(item, object) {
            item >>>= 0;
            object >>>= 0;
            item = Emval.toValue(item);
            object = Emval.toValue(object);
            return item in object;
          }
          __emval_in.sig = "ipp";
          function __emval_delete(object, property) {
            object >>>= 0;
            property >>>= 0;
            object = Emval.toValue(object);
            property = Emval.toValue(property);
            return delete object[property];
          }
          __emval_delete.sig = "ipp";
          function __emval_throw(object) {
            object >>>= 0;
            object = Emval.toValue(object);
            throw object;
          }
          __emval_throw.sig = "ip";
          function __emval_iter_begin(iterable) {
            iterable >>>= 0;
            iterable = Emval.toValue(iterable);
            return Emval.toHandle(iterable[Symbol.iterator]());
          }
          __emval_iter_begin.sig = "pp";
          function __emval_iter_next(iterator) {
            iterator >>>= 0;
            iterator = Emval.toValue(iterator);
            var result = iterator.next();
            return result.done ? 0 : Emval.toHandle(result.value);
          }
          __emval_iter_next.sig = "pp";
          var __emval_coro_suspend = function(promiseHandle, awaiterPtr) {
            promiseHandle >>>= 0;
            awaiterPtr >>>= 0;
            Emval.toValue(promiseHandle).then((result) => {
              __emval_coro_resume(awaiterPtr, Emval.toHandle(result));
            });
          };
          __emval_coro_suspend.sig = "vpp";
          var __emval_coro_make_promise = function(resolveHandlePtr, rejectHandlePtr) {
            resolveHandlePtr >>>= 0;
            rejectHandlePtr >>>= 0;
            return Emval.toHandle(new Promise((resolve, reject) => {
              const rejectWithCurrentException = () => {
                try {
                  ___cxa_rethrow();
                } catch (e) {
                  reject(e);
                }
              };
              HEAPU32[resolveHandlePtr >>> 2 >>> 0] = Emval.toHandle(resolve);
              HEAPU32[rejectHandlePtr >>> 2 >>> 0] = Emval.toHandle(rejectWithCurrentException);
            }));
          };
          __emval_coro_make_promise.sig = "ppp";
          function _duckdb_web_fs_file_sync(fileId) {
            return globalThis.DUCKDB_RUNTIME.syncFile(Module, fileId);
          }
          _duckdb_web_fs_file_sync.sig = "vi";
          function _duckdb_web_fs_file_remove(path, pathLen) {
            return globalThis.DUCKDB_RUNTIME.removeFile(Module, path, pathLen);
          }
          registerWasmPlugin();
          var FSNode = function(parent, name2, mode, rdev) {
            if (!parent) {
              parent = this;
            }
            this.parent = parent;
            this.mount = parent.mount;
            this.mounted = null;
            this.id = FS.nextInode++;
            this.name = name2;
            this.mode = mode;
            this.node_ops = {};
            this.stream_ops = {};
            this.rdev = rdev;
          };
          var readMode = 292 | 73;
          var writeMode = 146;
          Object.defineProperties(FSNode.prototype, {
            read: {
              get: function() {
                return (this.mode & readMode) === readMode;
              },
              set: function(val) {
                val ? this.mode |= readMode : this.mode &= ~readMode;
              }
            },
            write: {
              get: function() {
                return (this.mode & writeMode) === writeMode;
              },
              set: function(val) {
                val ? this.mode |= writeMode : this.mode &= ~writeMode;
              }
            },
            isFolder: {
              get: function() {
                return FS.isDir(this.mode);
              }
            },
            isDevice: {
              get: function() {
                return FS.isChrdev(this.mode);
              }
            }
          });
          FS.FSNode = FSNode;
          FS.createPreloadedFile = FS_createPreloadedFile;
          FS.staticInit();
          embind_init_charCodes();
          BindingError = Module["BindingError"] = class BindingError extends Error {
            constructor(message) {
              super(message);
              this.name = "BindingError";
            }
          };
          InternalError = Module["InternalError"] = class InternalError extends Error {
            constructor(message) {
              super(message);
              this.name = "InternalError";
            }
          };
          init_emval();
          Module["requestFullscreen"] = Browser.requestFullscreen;
          Module["requestAnimationFrame"] = Browser.requestAnimationFrame;
          Module["setCanvasSize"] = Browser.setCanvasSize;
          Module["pauseMainLoop"] = Browser.mainLoop.pause;
          Module["resumeMainLoop"] = Browser.mainLoop.resume;
          Module["getUserMedia"] = Browser.getUserMedia;
          Module["createContext"] = Browser.createContext;
          var preloadedImages = {};
          var preloadedAudios = {};
          var GLctx;
          for (var i = 0; i < 32; ++i)
            tempFixedLengthArray.push(new Array(i));
          var miniTempWebGLFloatBuffersStorage = new Float32Array(288);
          for (var i = 0; i < 288; ++i) {
            miniTempWebGLFloatBuffers[i] = miniTempWebGLFloatBuffersStorage.subarray(0, i + 1);
          }
          var miniTempWebGLIntBuffersStorage = new Int32Array(288);
          for (var i = 0; i < 288; ++i) {
            miniTempWebGLIntBuffers[i] = miniTempWebGLIntBuffersStorage.subarray(0, i + 1);
          }
          var emSetImmediate;
          var emClearImmediate;
          if (typeof setImmediate != "undefined") {
            emSetImmediate = setImmediateWrapped;
            emClearImmediate = clearImmediateWrapped;
          } else if (typeof addEventListener == "function") {
            var __setImmediate_id_counter = 0;
            var __setImmediate_queue = [];
            var __setImmediate_message_id = "_si";
            var __setImmediate_cb = (e) => {
              if (e.data === __setImmediate_message_id) {
                e.stopPropagation();
                __setImmediate_queue.shift()();
                ++__setImmediate_id_counter;
              }
            };
            addEventListener("message", __setImmediate_cb, true);
            emSetImmediate = (func2) => {
              postMessage(__setImmediate_message_id, "*");
              return __setImmediate_id_counter + __setImmediate_queue.push(func2) - 1;
            };
            emClearImmediate = (id) => {
              var index = id - __setImmediate_id_counter;
              if (index >= 0 && index < __setImmediate_queue.length)
                __setImmediate_queue[index] = () => {
                };
            };
          }
          UnboundTypeError = Module["UnboundTypeError"] = extendError(Error, "UnboundTypeError");
          PureVirtualError = Module["PureVirtualError"] = extendError(Error, "PureVirtualError");
          init_embind();
          init_RegisteredPointer();
          init_ClassHandle();
          var wasmImports = {
            IMG_Init: _IMG_Init,
            IMG_Load: _IMG_Load,
            IMG_Load_RW: _IMG_Load_RW,
            IMG_Quit: _IMG_Quit,
            Mix_AllocateChannels: _Mix_AllocateChannels,
            Mix_ChannelFinished: _Mix_ChannelFinished,
            Mix_CloseAudio: _Mix_CloseAudio,
            Mix_FadeInChannelTimed: _Mix_FadeInChannelTimed,
            Mix_FadeInMusicPos: _Mix_FadeInMusicPos,
            Mix_FadeOutChannel: _Mix_FadeOutChannel,
            Mix_FadeOutMusic: _Mix_FadeOutMusic,
            Mix_FadingChannel: _Mix_FadingChannel,
            Mix_FreeChunk: _Mix_FreeChunk,
            Mix_FreeMusic: _Mix_FreeMusic,
            Mix_HaltChannel: _Mix_HaltChannel,
            Mix_HaltMusic: _Mix_HaltMusic,
            Mix_HookMusicFinished: _Mix_HookMusicFinished,
            Mix_Init: _Mix_Init,
            Mix_Linked_Version: _Mix_Linked_Version,
            Mix_LoadMUS: _Mix_LoadMUS,
            Mix_LoadMUS_RW: _Mix_LoadMUS_RW,
            Mix_LoadWAV: _Mix_LoadWAV,
            Mix_LoadWAV_RW: _Mix_LoadWAV_RW,
            Mix_OpenAudio: _Mix_OpenAudio,
            Mix_Pause: _Mix_Pause,
            Mix_PauseMusic: _Mix_PauseMusic,
            Mix_Paused: _Mix_Paused,
            Mix_PausedMusic: _Mix_PausedMusic,
            Mix_PlayChannelTimed: _Mix_PlayChannelTimed,
            Mix_PlayMusic: _Mix_PlayMusic,
            Mix_Playing: _Mix_Playing,
            Mix_PlayingMusic: _Mix_PlayingMusic,
            Mix_QuerySpec: _Mix_QuerySpec,
            Mix_QuickLoad_RAW: _Mix_QuickLoad_RAW,
            Mix_Quit: _Mix_Quit,
            Mix_ReserveChannels: _Mix_ReserveChannels,
            Mix_Resume: _Mix_Resume,
            Mix_ResumeMusic: _Mix_ResumeMusic,
            Mix_SetPanning: _Mix_SetPanning,
            Mix_SetPosition: _Mix_SetPosition,
            Mix_SetPostMix: _Mix_SetPostMix,
            Mix_Volume: _Mix_Volume,
            Mix_VolumeChunk: _Mix_VolumeChunk,
            Mix_VolumeMusic: _Mix_VolumeMusic,
            SDL_AddTimer: _SDL_AddTimer,
            SDL_AllocRW: _SDL_AllocRW,
            SDL_AudioDriverName: _SDL_AudioDriverName,
            SDL_AudioQuit: _SDL_AudioQuit,
            SDL_ClearError: _SDL_ClearError,
            SDL_CloseAudio: _SDL_CloseAudio,
            SDL_CondBroadcast: _SDL_CondBroadcast,
            SDL_CondSignal: _SDL_CondSignal,
            SDL_CondWait: _SDL_CondWait,
            SDL_CondWaitTimeout: _SDL_CondWaitTimeout,
            SDL_ConvertSurface: _SDL_ConvertSurface,
            SDL_CreateCond: _SDL_CreateCond,
            SDL_CreateMutex: _SDL_CreateMutex,
            SDL_CreateRGBSurface: _SDL_CreateRGBSurface,
            SDL_CreateRGBSurfaceFrom: _SDL_CreateRGBSurfaceFrom,
            SDL_CreateThread: _SDL_CreateThread,
            SDL_Delay: _SDL_Delay,
            SDL_DestroyCond: _SDL_DestroyCond,
            SDL_DestroyMutex: _SDL_DestroyMutex,
            SDL_DestroyRenderer: _SDL_DestroyRenderer,
            SDL_DestroyWindow: _SDL_DestroyWindow,
            SDL_DisplayFormatAlpha: _SDL_DisplayFormatAlpha,
            SDL_EnableKeyRepeat: _SDL_EnableKeyRepeat,
            SDL_EnableUNICODE: _SDL_EnableUNICODE,
            SDL_FillRect: _SDL_FillRect,
            SDL_Flip: _SDL_Flip,
            SDL_FreeRW: _SDL_FreeRW,
            SDL_FreeSurface: _SDL_FreeSurface,
            SDL_GL_DeleteContext: _SDL_GL_DeleteContext,
            SDL_GL_ExtensionSupported: _SDL_GL_ExtensionSupported,
            SDL_GL_GetAttribute: _SDL_GL_GetAttribute,
            SDL_GL_GetSwapInterval: _SDL_GL_GetSwapInterval,
            SDL_GL_MakeCurrent: _SDL_GL_MakeCurrent,
            SDL_GL_SetAttribute: _SDL_GL_SetAttribute,
            SDL_GL_SetSwapInterval: _SDL_GL_SetSwapInterval,
            SDL_GL_SwapBuffers: _SDL_GL_SwapBuffers,
            SDL_GL_SwapWindow: _SDL_GL_SwapWindow,
            SDL_GetAppState: _SDL_GetAppState,
            SDL_GetAudioDriver: _SDL_GetAudioDriver,
            SDL_GetClipRect: _SDL_GetClipRect,
            SDL_GetCurrentAudioDriver: _SDL_GetCurrentAudioDriver,
            SDL_GetError: _SDL_GetError,
            SDL_GetKeyName: _SDL_GetKeyName,
            SDL_GetKeyState: _SDL_GetKeyState,
            SDL_GetKeyboardState: _SDL_GetKeyboardState,
            SDL_GetModState: _SDL_GetModState,
            SDL_GetMouseState: _SDL_GetMouseState,
            SDL_GetNumAudioDrivers: _SDL_GetNumAudioDrivers,
            SDL_GetRGB: _SDL_GetRGB,
            SDL_GetRGBA: _SDL_GetRGBA,
            SDL_GetScancodeFromKey: _SDL_GetScancodeFromKey,
            SDL_GetThreadID: _SDL_GetThreadID,
            SDL_GetTicks: _SDL_GetTicks,
            SDL_GetVideoInfo: _SDL_GetVideoInfo,
            SDL_GetVideoSurface: _SDL_GetVideoSurface,
            SDL_GetWindowFlags: _SDL_GetWindowFlags,
            SDL_GetWindowSize: _SDL_GetWindowSize,
            SDL_Has3DNow: _SDL_Has3DNow,
            SDL_Has3DNowExt: _SDL_Has3DNowExt,
            SDL_HasAltiVec: _SDL_HasAltiVec,
            SDL_HasMMX: _SDL_HasMMX,
            SDL_HasMMXExt: _SDL_HasMMXExt,
            SDL_HasRDTSC: _SDL_HasRDTSC,
            SDL_HasSSE: _SDL_HasSSE,
            SDL_HasSSE2: _SDL_HasSSE2,
            SDL_Init: _SDL_Init,
            SDL_InitSubSystem: _SDL_InitSubSystem,
            SDL_JoystickClose: _SDL_JoystickClose,
            SDL_JoystickEventState: _SDL_JoystickEventState,
            SDL_JoystickGetAxis: _SDL_JoystickGetAxis,
            SDL_JoystickGetBall: _SDL_JoystickGetBall,
            SDL_JoystickGetButton: _SDL_JoystickGetButton,
            SDL_JoystickGetHat: _SDL_JoystickGetHat,
            SDL_JoystickIndex: _SDL_JoystickIndex,
            SDL_JoystickName: _SDL_JoystickName,
            SDL_JoystickNumAxes: _SDL_JoystickNumAxes,
            SDL_JoystickNumBalls: _SDL_JoystickNumBalls,
            SDL_JoystickNumButtons: _SDL_JoystickNumButtons,
            SDL_JoystickNumHats: _SDL_JoystickNumHats,
            SDL_JoystickOpen: _SDL_JoystickOpen,
            SDL_JoystickOpened: _SDL_JoystickOpened,
            SDL_JoystickUpdate: _SDL_JoystickUpdate,
            SDL_Linked_Version: _SDL_Linked_Version,
            SDL_ListModes: _SDL_ListModes,
            SDL_LoadBMP_RW: _SDL_LoadBMP_RW,
            SDL_LockAudio: _SDL_LockAudio,
            SDL_LockSurface: _SDL_LockSurface,
            SDL_LogSetOutputFunction: _SDL_LogSetOutputFunction,
            SDL_LowerBlit: _SDL_LowerBlit,
            SDL_LowerBlitScaled: _SDL_LowerBlitScaled,
            SDL_MapRGB: _SDL_MapRGB,
            SDL_MapRGBA: _SDL_MapRGBA,
            SDL_NumJoysticks: _SDL_NumJoysticks,
            SDL_OpenAudio: _SDL_OpenAudio,
            SDL_PauseAudio: _SDL_PauseAudio,
            SDL_PeepEvents: _SDL_PeepEvents,
            SDL_PollEvent: _SDL_PollEvent,
            SDL_PumpEvents: _SDL_PumpEvents,
            SDL_PushEvent: _SDL_PushEvent,
            SDL_Quit: _SDL_Quit,
            SDL_QuitSubSystem: _SDL_QuitSubSystem,
            SDL_RWFromConstMem: _SDL_RWFromConstMem,
            SDL_RWFromFile: _SDL_RWFromFile,
            SDL_RWFromMem: _SDL_RWFromMem,
            SDL_RemoveTimer: _SDL_RemoveTimer,
            SDL_SaveBMP_RW: _SDL_SaveBMP_RW,
            SDL_SetAlpha: _SDL_SetAlpha,
            SDL_SetClipRect: _SDL_SetClipRect,
            SDL_SetColorKey: _SDL_SetColorKey,
            SDL_SetColors: _SDL_SetColors,
            SDL_SetError: _SDL_SetError,
            SDL_SetGamma: _SDL_SetGamma,
            SDL_SetGammaRamp: _SDL_SetGammaRamp,
            SDL_SetPalette: _SDL_SetPalette,
            SDL_SetVideoMode: _SDL_SetVideoMode,
            SDL_SetWindowFullscreen: _SDL_SetWindowFullscreen,
            SDL_SetWindowTitle: _SDL_SetWindowTitle,
            SDL_ShowCursor: _SDL_ShowCursor,
            SDL_StartTextInput: _SDL_StartTextInput,
            SDL_StopTextInput: _SDL_StopTextInput,
            SDL_ThreadID: _SDL_ThreadID,
            SDL_UnlockAudio: _SDL_UnlockAudio,
            SDL_UnlockSurface: _SDL_UnlockSurface,
            SDL_UpdateRect: _SDL_UpdateRect,
            SDL_UpdateRects: _SDL_UpdateRects,
            SDL_UpperBlit: _SDL_UpperBlit,
            SDL_UpperBlitScaled: _SDL_UpperBlitScaled,
            SDL_VideoDriverName: _SDL_VideoDriverName,
            SDL_VideoModeOK: _SDL_VideoModeOK,
            SDL_VideoQuit: _SDL_VideoQuit,
            SDL_WM_GrabInput: _SDL_WM_GrabInput,
            SDL_WM_IconifyWindow: _SDL_WM_IconifyWindow,
            SDL_WM_SetCaption: _SDL_WM_SetCaption,
            SDL_WM_SetIcon: _SDL_WM_SetIcon,
            SDL_WM_ToggleFullScreen: _SDL_WM_ToggleFullScreen,
            SDL_WaitThread: _SDL_WaitThread,
            SDL_WarpMouse: _SDL_WarpMouse,
            SDL_WasInit: _SDL_WasInit,
            SDL_mutexP: _SDL_mutexP,
            SDL_mutexV: _SDL_mutexV,
            TTF_CloseFont: _TTF_CloseFont,
            TTF_FontAscent: _TTF_FontAscent,
            TTF_FontDescent: _TTF_FontDescent,
            TTF_FontHeight: _TTF_FontHeight,
            TTF_FontLineSkip: _TTF_FontLineSkip,
            TTF_GlyphMetrics: _TTF_GlyphMetrics,
            TTF_Init: _TTF_Init,
            TTF_OpenFont: _TTF_OpenFont,
            TTF_Quit: _TTF_Quit,
            TTF_RenderText_Blended: _TTF_RenderText_Blended,
            TTF_RenderText_Shaded: _TTF_RenderText_Shaded,
            TTF_RenderText_Solid: _TTF_RenderText_Solid,
            TTF_RenderUTF8_Solid: _TTF_RenderUTF8_Solid,
            TTF_SizeText: _TTF_SizeText,
            TTF_SizeUTF8: _TTF_SizeUTF8,
            XChangeWindowAttributes: _XChangeWindowAttributes,
            XCreateWindow: _XCreateWindow,
            XInternAtom: _XInternAtom,
            XMapWindow: _XMapWindow,
            XOpenDisplay: _XOpenDisplay,
            XPending: _XPending,
            XSendEvent: _XSendEvent,
            XSetWMHints: _XSetWMHints,
            XStoreName: _XStoreName,
            _Unwind_Backtrace: __Unwind_Backtrace,
            _Unwind_FindEnclosingFunction: __Unwind_FindEnclosingFunction,
            _Unwind_GetIPInfo: __Unwind_GetIPInfo,
            __asctime_r: ___asctime_r,
            __assert_fail: ___assert_fail,
            __c_longjmp: ___c_longjmp,
            __call_sighandler: ___call_sighandler,
            __cpp_exception: ___cpp_exception,
            __global_base: ___global_base,
            __heap_base: ___heap_base,
            __indirect_function_table: wasmTable,
            __memory_base: ___memory_base,
            __stack_high: ___stack_high,
            __stack_low: ___stack_low,
            __stack_pointer: ___stack_pointer,
            __syscall__newselect: ___syscall__newselect,
            __syscall_accept4: ___syscall_accept4,
            __syscall_bind: ___syscall_bind,
            __syscall_chdir: ___syscall_chdir,
            __syscall_chmod: ___syscall_chmod,
            __syscall_connect: ___syscall_connect,
            __syscall_dup: ___syscall_dup,
            __syscall_dup3: ___syscall_dup3,
            __syscall_faccessat: ___syscall_faccessat,
            __syscall_fadvise64: ___syscall_fadvise64,
            __syscall_fallocate: ___syscall_fallocate,
            __syscall_fchdir: ___syscall_fchdir,
            __syscall_fchmod: ___syscall_fchmod,
            __syscall_fchmodat: ___syscall_fchmodat,
            __syscall_fchown32: ___syscall_fchown32,
            __syscall_fchownat: ___syscall_fchownat,
            __syscall_fcntl64: ___syscall_fcntl64,
            __syscall_fdatasync: ___syscall_fdatasync,
            __syscall_fstat64: ___syscall_fstat64,
            __syscall_fstatfs64: ___syscall_fstatfs64,
            __syscall_ftruncate64: ___syscall_ftruncate64,
            __syscall_getcwd: ___syscall_getcwd,
            __syscall_getdents64: ___syscall_getdents64,
            __syscall_getpeername: ___syscall_getpeername,
            __syscall_getsockname: ___syscall_getsockname,
            __syscall_getsockopt: ___syscall_getsockopt,
            __syscall_ioctl: ___syscall_ioctl,
            __syscall_listen: ___syscall_listen,
            __syscall_lstat64: ___syscall_lstat64,
            __syscall_mkdirat: ___syscall_mkdirat,
            __syscall_mknodat: ___syscall_mknodat,
            __syscall_newfstatat: ___syscall_newfstatat,
            __syscall_openat: ___syscall_openat,
            __syscall_pipe: ___syscall_pipe,
            __syscall_poll: ___syscall_poll,
            __syscall_readlinkat: ___syscall_readlinkat,
            __syscall_recvfrom: ___syscall_recvfrom,
            __syscall_recvmsg: ___syscall_recvmsg,
            __syscall_renameat: ___syscall_renameat,
            __syscall_rmdir: ___syscall_rmdir,
            __syscall_sendmsg: ___syscall_sendmsg,
            __syscall_sendto: ___syscall_sendto,
            __syscall_socket: ___syscall_socket,
            __syscall_stat64: ___syscall_stat64,
            __syscall_statfs64: ___syscall_statfs64,
            __syscall_symlink: ___syscall_symlink,
            __syscall_symlinkat: ___syscall_symlinkat,
            __syscall_truncate64: ___syscall_truncate64,
            __syscall_unlinkat: ___syscall_unlinkat,
            __syscall_utimensat: ___syscall_utimensat,
            __table_base: ___table_base,
            _dlopen_js: __dlopen_js,
            _dlsym_catchup_js: __dlsym_catchup_js,
            _dlsym_js: __dlsym_js,
            _embind_create_inheriting_constructor: __embind_create_inheriting_constructor,
            _embind_finalize_value_array: __embind_finalize_value_array,
            _embind_finalize_value_object: __embind_finalize_value_object,
            _embind_register_bigint: __embind_register_bigint,
            _embind_register_bool: __embind_register_bool,
            _embind_register_class: __embind_register_class,
            _embind_register_class_class_function: __embind_register_class_class_function,
            _embind_register_class_class_property: __embind_register_class_class_property,
            _embind_register_class_constructor: __embind_register_class_constructor,
            _embind_register_class_function: __embind_register_class_function,
            _embind_register_class_property: __embind_register_class_property,
            _embind_register_constant: __embind_register_constant,
            _embind_register_emval: __embind_register_emval,
            _embind_register_enum: __embind_register_enum,
            _embind_register_enum_value: __embind_register_enum_value,
            _embind_register_float: __embind_register_float,
            _embind_register_function: __embind_register_function,
            _embind_register_integer: __embind_register_integer,
            _embind_register_memory_view: __embind_register_memory_view,
            _embind_register_optional: __embind_register_optional,
            _embind_register_smart_ptr: __embind_register_smart_ptr,
            _embind_register_std_string: __embind_register_std_string,
            _embind_register_std_wstring: __embind_register_std_wstring,
            _embind_register_user_type: __embind_register_user_type,
            _embind_register_value_array: __embind_register_value_array,
            _embind_register_value_array_element: __embind_register_value_array_element,
            _embind_register_value_object: __embind_register_value_object,
            _embind_register_value_object_field: __embind_register_value_object_field,
            _embind_register_void: __embind_register_void,
            _emscripten_dlopen_js: __emscripten_dlopen_js,
            _emscripten_fs_load_embedded_files: __emscripten_fs_load_embedded_files,
            _emscripten_get_now_is_monotonic: __emscripten_get_now_is_monotonic,
            _emscripten_get_progname: __emscripten_get_progname,
            _emscripten_lookup_name: __emscripten_lookup_name,
            _emscripten_push_main_loop_blocker: __emscripten_push_main_loop_blocker,
            _emscripten_push_uncounted_main_loop_blocker: __emscripten_push_uncounted_main_loop_blocker,
            _emscripten_runtime_keepalive_clear: __emscripten_runtime_keepalive_clear,
            _emscripten_set_offscreencanvas_size: __emscripten_set_offscreencanvas_size,
            _emscripten_system: __emscripten_system,
            _emval_as: __emval_as,
            _emval_as_int64: __emval_as_int64,
            _emval_as_uint64: __emval_as_uint64,
            _emval_call: __emval_call,
            _emval_call_method: __emval_call_method,
            _emval_coro_make_promise: __emval_coro_make_promise,
            _emval_coro_suspend: __emval_coro_suspend,
            _emval_decref: __emval_decref,
            _emval_delete: __emval_delete,
            _emval_equals: __emval_equals,
            _emval_get_global: __emval_get_global,
            _emval_get_method_caller: __emval_get_method_caller,
            _emval_get_module_property: __emval_get_module_property,
            _emval_get_property: __emval_get_property,
            _emval_greater_than: __emval_greater_than,
            _emval_in: __emval_in,
            _emval_incref: __emval_incref,
            _emval_instanceof: __emval_instanceof,
            _emval_is_number: __emval_is_number,
            _emval_is_string: __emval_is_string,
            _emval_iter_begin: __emval_iter_begin,
            _emval_iter_next: __emval_iter_next,
            _emval_less_than: __emval_less_than,
            _emval_new_array: __emval_new_array,
            _emval_new_array_from_memory_view: __emval_new_array_from_memory_view,
            _emval_new_cstring: __emval_new_cstring,
            _emval_new_object: __emval_new_object,
            _emval_new_u16string: __emval_new_u16string,
            _emval_new_u8string: __emval_new_u8string,
            _emval_not: __emval_not,
            _emval_register_symbol: __emval_register_symbol,
            _emval_run_destructors: __emval_run_destructors,
            _emval_set_property: __emval_set_property,
            _emval_strictly_equals: __emval_strictly_equals,
            _emval_take_value: __emval_take_value,
            _emval_throw: __emval_throw,
            _emval_typeof: __emval_typeof,
            _glGenObject: __glGenObject,
            _glGetActiveAttribOrUniform: __glGetActiveAttribOrUniform,
            _gmtime_js: __gmtime_js,
            _localtime_js: __localtime_js,
            _mktime_js: __mktime_js,
            _mmap_js: __mmap_js,
            _msync_js: __msync_js,
            _munmap_js: __munmap_js,
            _setitimer_js: __setitimer_js,
            _timegm_js: __timegm_js,
            _tzset_js: __tzset_js,
            abort: _abort,
            alBuffer3f: _alBuffer3f,
            alBuffer3i: _alBuffer3i,
            alBufferData: _alBufferData,
            alBufferf: _alBufferf,
            alBufferfv: _alBufferfv,
            alBufferi: _alBufferi,
            alBufferiv: _alBufferiv,
            alDeleteBuffers: _alDeleteBuffers,
            alDeleteSources: _alDeleteSources,
            alDisable: _alDisable,
            alDistanceModel: _alDistanceModel,
            alDopplerFactor: _alDopplerFactor,
            alDopplerVelocity: _alDopplerVelocity,
            alEnable: _alEnable,
            alGenBuffers: _alGenBuffers,
            alGenSources: _alGenSources,
            alGetBoolean: _alGetBoolean,
            alGetBooleanv: _alGetBooleanv,
            alGetBuffer3f: _alGetBuffer3f,
            alGetBuffer3i: _alGetBuffer3i,
            alGetBufferf: _alGetBufferf,
            alGetBufferfv: _alGetBufferfv,
            alGetBufferi: _alGetBufferi,
            alGetBufferiv: _alGetBufferiv,
            alGetDouble: _alGetDouble,
            alGetDoublev: _alGetDoublev,
            alGetEnumValue: _alGetEnumValue,
            alGetError: _alGetError,
            alGetFloat: _alGetFloat,
            alGetFloatv: _alGetFloatv,
            alGetInteger: _alGetInteger,
            alGetIntegerv: _alGetIntegerv,
            alGetListener3f: _alGetListener3f,
            alGetListener3i: _alGetListener3i,
            alGetListenerf: _alGetListenerf,
            alGetListenerfv: _alGetListenerfv,
            alGetListeneri: _alGetListeneri,
            alGetListeneriv: _alGetListeneriv,
            alGetSource3f: _alGetSource3f,
            alGetSource3i: _alGetSource3i,
            alGetSourcef: _alGetSourcef,
            alGetSourcefv: _alGetSourcefv,
            alGetSourcei: _alGetSourcei,
            alGetSourceiv: _alGetSourceiv,
            alGetString: _alGetString,
            alIsBuffer: _alIsBuffer,
            alIsEnabled: _alIsEnabled,
            alIsExtensionPresent: _alIsExtensionPresent,
            alIsSource: _alIsSource,
            alListener3f: _alListener3f,
            alListener3i: _alListener3i,
            alListenerf: _alListenerf,
            alListenerfv: _alListenerfv,
            alListeneri: _alListeneri,
            alListeneriv: _alListeneriv,
            alSource3f: _alSource3f,
            alSource3i: _alSource3i,
            alSourcePause: _alSourcePause,
            alSourcePausev: _alSourcePausev,
            alSourcePlay: _alSourcePlay,
            alSourcePlayv: _alSourcePlayv,
            alSourceQueueBuffers: _alSourceQueueBuffers,
            alSourceRewind: _alSourceRewind,
            alSourceRewindv: _alSourceRewindv,
            alSourceStop: _alSourceStop,
            alSourceStopv: _alSourceStopv,
            alSourceUnqueueBuffers: _alSourceUnqueueBuffers,
            alSourcef: _alSourcef,
            alSourcefv: _alSourcefv,
            alSourcei: _alSourcei,
            alSourceiv: _alSourceiv,
            alSpeedOfSound: _alSpeedOfSound,
            alcCaptureCloseDevice: _alcCaptureCloseDevice,
            alcCaptureOpenDevice: _alcCaptureOpenDevice,
            alcCaptureSamples: _alcCaptureSamples,
            alcCaptureStart: _alcCaptureStart,
            alcCaptureStop: _alcCaptureStop,
            alcCloseDevice: _alcCloseDevice,
            alcCreateContext: _alcCreateContext,
            alcDestroyContext: _alcDestroyContext,
            alcGetContextsDevice: _alcGetContextsDevice,
            alcGetCurrentContext: _alcGetCurrentContext,
            alcGetEnumValue: _alcGetEnumValue,
            alcGetError: _alcGetError,
            alcGetIntegerv: _alcGetIntegerv,
            alcGetString: _alcGetString,
            alcIsExtensionPresent: _alcIsExtensionPresent,
            alcMakeContextCurrent: _alcMakeContextCurrent,
            alcOpenDevice: _alcOpenDevice,
            alcProcessContext: _alcProcessContext,
            alcSuspendContext: _alcSuspendContext,
            boxColor: _boxColor,
            boxRGBA: _boxRGBA,
            clock_res_get: _clock_res_get,
            clock_time_get: _clock_time_get,
            duckdb_web_fs_directory_create: _duckdb_web_fs_directory_create,
            duckdb_web_fs_directory_exists: _duckdb_web_fs_directory_exists,
            duckdb_web_fs_directory_list_files: _duckdb_web_fs_directory_list_files,
            duckdb_web_fs_directory_remove: _duckdb_web_fs_directory_remove,
            duckdb_web_fs_file_close: _duckdb_web_fs_file_close,
            duckdb_web_fs_file_exists: _duckdb_web_fs_file_exists,
            duckdb_web_fs_file_get_last_modified_time: _duckdb_web_fs_file_get_last_modified_time,
            duckdb_web_fs_file_move: _duckdb_web_fs_file_move,
            duckdb_web_fs_file_open: _duckdb_web_fs_file_open,
            duckdb_web_fs_file_read: _duckdb_web_fs_file_read,
            duckdb_web_fs_file_remove: _duckdb_web_fs_file_remove,
            duckdb_web_fs_file_sync: _duckdb_web_fs_file_sync,
            duckdb_web_fs_file_truncate: _duckdb_web_fs_file_truncate,
            duckdb_web_fs_file_write: _duckdb_web_fs_file_write,
            duckdb_web_fs_get_default_data_protocol: _duckdb_web_fs_get_default_data_protocol,
            duckdb_web_fs_glob: _duckdb_web_fs_glob,
            duckdb_web_test_platform_feature: _duckdb_web_test_platform_feature,
            duckdb_web_udf_scalar_call: _duckdb_web_udf_scalar_call,
            eglBindAPI: _eglBindAPI,
            eglChooseConfig: _eglChooseConfig,
            eglCreateContext: _eglCreateContext,
            eglCreateWindowSurface: _eglCreateWindowSurface,
            eglDestroyContext: _eglDestroyContext,
            eglDestroySurface: _eglDestroySurface,
            eglGetConfigAttrib: _eglGetConfigAttrib,
            eglGetConfigs: _eglGetConfigs,
            eglGetCurrentContext: _eglGetCurrentContext,
            eglGetCurrentDisplay: _eglGetCurrentDisplay,
            eglGetCurrentSurface: _eglGetCurrentSurface,
            eglGetDisplay: _eglGetDisplay,
            eglGetError: _eglGetError,
            eglInitialize: _eglInitialize,
            eglMakeCurrent: _eglMakeCurrent,
            eglQueryAPI: _eglQueryAPI,
            eglQueryContext: _eglQueryContext,
            eglQueryString: _eglQueryString,
            eglQuerySurface: _eglQuerySurface,
            eglReleaseThread: _eglReleaseThread,
            eglSwapBuffers: _eglSwapBuffers,
            eglSwapInterval: _eglSwapInterval,
            eglTerminate: _eglTerminate,
            eglWaitClient: _eglWaitClient,
            eglWaitGL: _eglWaitGL,
            eglWaitNative: _eglWaitNative,
            ellipseColor: _ellipseColor,
            ellipseRGBA: _ellipseRGBA,
            emscripten_SDL_SetEventHandler: _emscripten_SDL_SetEventHandler,
            emscripten_alcDevicePauseSOFT: _emscripten_alcDevicePauseSOFT,
            emscripten_alcDeviceResumeSOFT: _emscripten_alcDeviceResumeSOFT,
            emscripten_alcGetStringiSOFT: _emscripten_alcGetStringiSOFT,
            emscripten_alcResetDeviceSOFT: _emscripten_alcResetDeviceSOFT,
            emscripten_asm_const_async_on_main_thread: _emscripten_asm_const_async_on_main_thread,
            emscripten_asm_const_double: _emscripten_asm_const_double,
            emscripten_asm_const_double_sync_on_main_thread: _emscripten_asm_const_double_sync_on_main_thread,
            emscripten_asm_const_int: _emscripten_asm_const_int,
            emscripten_asm_const_int_sync_on_main_thread: _emscripten_asm_const_int_sync_on_main_thread,
            emscripten_asm_const_ptr: _emscripten_asm_const_ptr,
            emscripten_asm_const_ptr_sync_on_main_thread: _emscripten_asm_const_ptr_sync_on_main_thread,
            emscripten_async_call: _emscripten_async_call,
            emscripten_async_load_script: _emscripten_async_load_script,
            emscripten_async_run_script: _emscripten_async_run_script,
            emscripten_async_wget: _emscripten_async_wget,
            emscripten_async_wget2: _emscripten_async_wget2,
            emscripten_async_wget2_abort: _emscripten_async_wget2_abort,
            emscripten_async_wget2_data: _emscripten_async_wget2_data,
            emscripten_async_wget_data: _emscripten_async_wget_data,
            emscripten_call_worker: _emscripten_call_worker,
            emscripten_cancel_animation_frame: _emscripten_cancel_animation_frame,
            emscripten_cancel_main_loop: _emscripten_cancel_main_loop,
            emscripten_clear_immediate: _emscripten_clear_immediate,
            emscripten_clear_interval: _emscripten_clear_interval,
            emscripten_clear_timeout: _emscripten_clear_timeout,
            emscripten_console_error: _emscripten_console_error,
            emscripten_console_log: _emscripten_console_log,
            emscripten_console_warn: _emscripten_console_warn,
            emscripten_create_worker: _emscripten_create_worker,
            emscripten_date_now: _emscripten_date_now,
            emscripten_debugger: _emscripten_debugger,
            emscripten_destroy_worker: _emscripten_destroy_worker,
            emscripten_enter_soft_fullscreen: _emscripten_enter_soft_fullscreen,
            emscripten_err: _emscripten_err,
            emscripten_errn: _emscripten_errn,
            emscripten_exit_fullscreen: _emscripten_exit_fullscreen,
            emscripten_exit_pointerlock: _emscripten_exit_pointerlock,
            emscripten_exit_soft_fullscreen: _emscripten_exit_soft_fullscreen,
            emscripten_exit_with_live_runtime: _emscripten_exit_with_live_runtime,
            emscripten_fiber_swap: _emscripten_fiber_swap,
            emscripten_force_exit: _emscripten_force_exit,
            emscripten_get_battery_status: _emscripten_get_battery_status,
            emscripten_get_callstack: _emscripten_get_callstack,
            emscripten_get_canvas_element_size: _emscripten_get_canvas_element_size,
            emscripten_get_canvas_size: _emscripten_get_canvas_size,
            emscripten_get_compiler_setting: _emscripten_get_compiler_setting,
            emscripten_get_device_pixel_ratio: _emscripten_get_device_pixel_ratio,
            emscripten_get_devicemotion_status: _emscripten_get_devicemotion_status,
            emscripten_get_deviceorientation_status: _emscripten_get_deviceorientation_status,
            emscripten_get_element_css_size: _emscripten_get_element_css_size,
            emscripten_get_fullscreen_status: _emscripten_get_fullscreen_status,
            emscripten_get_gamepad_status: _emscripten_get_gamepad_status,
            emscripten_get_heap_max: _emscripten_get_heap_max,
            emscripten_get_main_loop_timing: _emscripten_get_main_loop_timing,
            emscripten_get_module_name: _emscripten_get_module_name,
            emscripten_get_mouse_status: _emscripten_get_mouse_status,
            emscripten_get_now: _emscripten_get_now,
            emscripten_get_now_res: _emscripten_get_now_res,
            emscripten_get_num_gamepads: _emscripten_get_num_gamepads,
            emscripten_get_orientation_status: _emscripten_get_orientation_status,
            emscripten_get_pointerlock_status: _emscripten_get_pointerlock_status,
            emscripten_get_preloaded_image_data: _emscripten_get_preloaded_image_data,
            emscripten_get_preloaded_image_data_from_FILE: _emscripten_get_preloaded_image_data_from_FILE,
            emscripten_get_screen_size: _emscripten_get_screen_size,
            emscripten_get_visibility_status: _emscripten_get_visibility_status,
            emscripten_get_window_title: _emscripten_get_window_title,
            emscripten_get_worker_queue_size: _emscripten_get_worker_queue_size,
            emscripten_glActiveTexture: _emscripten_glActiveTexture,
            emscripten_glAttachShader: _emscripten_glAttachShader,
            emscripten_glBegin: _emscripten_glBegin,
            emscripten_glBeginQueryEXT: _emscripten_glBeginQueryEXT,
            emscripten_glBindAttribLocation: _emscripten_glBindAttribLocation,
            emscripten_glBindBuffer: _emscripten_glBindBuffer,
            emscripten_glBindFramebuffer: _emscripten_glBindFramebuffer,
            emscripten_glBindRenderbuffer: _emscripten_glBindRenderbuffer,
            emscripten_glBindTexture: _emscripten_glBindTexture,
            emscripten_glBindVertexArray: _emscripten_glBindVertexArray,
            emscripten_glBindVertexArrayOES: _emscripten_glBindVertexArrayOES,
            emscripten_glBlendColor: _emscripten_glBlendColor,
            emscripten_glBlendEquation: _emscripten_glBlendEquation,
            emscripten_glBlendEquationSeparate: _emscripten_glBlendEquationSeparate,
            emscripten_glBlendFunc: _emscripten_glBlendFunc,
            emscripten_glBlendFuncSeparate: _emscripten_glBlendFuncSeparate,
            emscripten_glBufferData: _emscripten_glBufferData,
            emscripten_glBufferSubData: _emscripten_glBufferSubData,
            emscripten_glCheckFramebufferStatus: _emscripten_glCheckFramebufferStatus,
            emscripten_glClear: _emscripten_glClear,
            emscripten_glClearColor: _emscripten_glClearColor,
            emscripten_glClearDepth: _emscripten_glClearDepth,
            emscripten_glClearDepthf: _emscripten_glClearDepthf,
            emscripten_glClearStencil: _emscripten_glClearStencil,
            emscripten_glColorMask: _emscripten_glColorMask,
            emscripten_glCompileShader: _emscripten_glCompileShader,
            emscripten_glCompressedTexImage2D: _emscripten_glCompressedTexImage2D,
            emscripten_glCompressedTexSubImage2D: _emscripten_glCompressedTexSubImage2D,
            emscripten_glCopyTexImage2D: _emscripten_glCopyTexImage2D,
            emscripten_glCopyTexSubImage2D: _emscripten_glCopyTexSubImage2D,
            emscripten_glCreateProgram: _emscripten_glCreateProgram,
            emscripten_glCreateShader: _emscripten_glCreateShader,
            emscripten_glCullFace: _emscripten_glCullFace,
            emscripten_glDeleteBuffers: _emscripten_glDeleteBuffers,
            emscripten_glDeleteFramebuffers: _emscripten_glDeleteFramebuffers,
            emscripten_glDeleteProgram: _emscripten_glDeleteProgram,
            emscripten_glDeleteQueriesEXT: _emscripten_glDeleteQueriesEXT,
            emscripten_glDeleteRenderbuffers: _emscripten_glDeleteRenderbuffers,
            emscripten_glDeleteShader: _emscripten_glDeleteShader,
            emscripten_glDeleteTextures: _emscripten_glDeleteTextures,
            emscripten_glDeleteVertexArrays: _emscripten_glDeleteVertexArrays,
            emscripten_glDeleteVertexArraysOES: _emscripten_glDeleteVertexArraysOES,
            emscripten_glDepthFunc: _emscripten_glDepthFunc,
            emscripten_glDepthMask: _emscripten_glDepthMask,
            emscripten_glDepthRange: _emscripten_glDepthRange,
            emscripten_glDepthRangef: _emscripten_glDepthRangef,
            emscripten_glDetachShader: _emscripten_glDetachShader,
            emscripten_glDisable: _emscripten_glDisable,
            emscripten_glDisableVertexAttribArray: _emscripten_glDisableVertexAttribArray,
            emscripten_glDrawArrays: _emscripten_glDrawArrays,
            emscripten_glDrawArraysInstanced: _emscripten_glDrawArraysInstanced,
            emscripten_glDrawArraysInstancedANGLE: _emscripten_glDrawArraysInstancedANGLE,
            emscripten_glDrawArraysInstancedARB: _emscripten_glDrawArraysInstancedARB,
            emscripten_glDrawArraysInstancedEXT: _emscripten_glDrawArraysInstancedEXT,
            emscripten_glDrawArraysInstancedNV: _emscripten_glDrawArraysInstancedNV,
            emscripten_glDrawBuffers: _emscripten_glDrawBuffers,
            emscripten_glDrawBuffersEXT: _emscripten_glDrawBuffersEXT,
            emscripten_glDrawBuffersWEBGL: _emscripten_glDrawBuffersWEBGL,
            emscripten_glDrawElements: _emscripten_glDrawElements,
            emscripten_glDrawElementsInstanced: _emscripten_glDrawElementsInstanced,
            emscripten_glDrawElementsInstancedANGLE: _emscripten_glDrawElementsInstancedANGLE,
            emscripten_glDrawElementsInstancedARB: _emscripten_glDrawElementsInstancedARB,
            emscripten_glDrawElementsInstancedEXT: _emscripten_glDrawElementsInstancedEXT,
            emscripten_glDrawElementsInstancedNV: _emscripten_glDrawElementsInstancedNV,
            emscripten_glEnable: _emscripten_glEnable,
            emscripten_glEnableVertexAttribArray: _emscripten_glEnableVertexAttribArray,
            emscripten_glEndQueryEXT: _emscripten_glEndQueryEXT,
            emscripten_glFinish: _emscripten_glFinish,
            emscripten_glFlush: _emscripten_glFlush,
            emscripten_glFramebufferRenderbuffer: _emscripten_glFramebufferRenderbuffer,
            emscripten_glFramebufferTexture2D: _emscripten_glFramebufferTexture2D,
            emscripten_glFrontFace: _emscripten_glFrontFace,
            emscripten_glGenBuffers: _emscripten_glGenBuffers,
            emscripten_glGenFramebuffers: _emscripten_glGenFramebuffers,
            emscripten_glGenQueriesEXT: _emscripten_glGenQueriesEXT,
            emscripten_glGenRenderbuffers: _emscripten_glGenRenderbuffers,
            emscripten_glGenTextures: _emscripten_glGenTextures,
            emscripten_glGenVertexArrays: _emscripten_glGenVertexArrays,
            emscripten_glGenVertexArraysOES: _emscripten_glGenVertexArraysOES,
            emscripten_glGenerateMipmap: _emscripten_glGenerateMipmap,
            emscripten_glGetActiveAttrib: _emscripten_glGetActiveAttrib,
            emscripten_glGetActiveUniform: _emscripten_glGetActiveUniform,
            emscripten_glGetAttachedShaders: _emscripten_glGetAttachedShaders,
            emscripten_glGetAttribLocation: _emscripten_glGetAttribLocation,
            emscripten_glGetBooleanv: _emscripten_glGetBooleanv,
            emscripten_glGetBufferParameteriv: _emscripten_glGetBufferParameteriv,
            emscripten_glGetError: _emscripten_glGetError,
            emscripten_glGetFloatv: _emscripten_glGetFloatv,
            emscripten_glGetFramebufferAttachmentParameteriv: _emscripten_glGetFramebufferAttachmentParameteriv,
            emscripten_glGetIntegerv: _emscripten_glGetIntegerv,
            emscripten_glGetProgramInfoLog: _emscripten_glGetProgramInfoLog,
            emscripten_glGetProgramiv: _emscripten_glGetProgramiv,
            emscripten_glGetQueryObjecti64vEXT: _emscripten_glGetQueryObjecti64vEXT,
            emscripten_glGetQueryObjectivEXT: _emscripten_glGetQueryObjectivEXT,
            emscripten_glGetQueryObjectui64vEXT: _emscripten_glGetQueryObjectui64vEXT,
            emscripten_glGetQueryObjectuivEXT: _emscripten_glGetQueryObjectuivEXT,
            emscripten_glGetQueryivEXT: _emscripten_glGetQueryivEXT,
            emscripten_glGetRenderbufferParameteriv: _emscripten_glGetRenderbufferParameteriv,
            emscripten_glGetShaderInfoLog: _emscripten_glGetShaderInfoLog,
            emscripten_glGetShaderPrecisionFormat: _emscripten_glGetShaderPrecisionFormat,
            emscripten_glGetShaderSource: _emscripten_glGetShaderSource,
            emscripten_glGetShaderiv: _emscripten_glGetShaderiv,
            emscripten_glGetString: _emscripten_glGetString,
            emscripten_glGetTexParameterfv: _emscripten_glGetTexParameterfv,
            emscripten_glGetTexParameteriv: _emscripten_glGetTexParameteriv,
            emscripten_glGetUniformLocation: _emscripten_glGetUniformLocation,
            emscripten_glGetUniformfv: _emscripten_glGetUniformfv,
            emscripten_glGetUniformiv: _emscripten_glGetUniformiv,
            emscripten_glGetVertexAttribPointerv: _emscripten_glGetVertexAttribPointerv,
            emscripten_glGetVertexAttribfv: _emscripten_glGetVertexAttribfv,
            emscripten_glGetVertexAttribiv: _emscripten_glGetVertexAttribiv,
            emscripten_glHint: _emscripten_glHint,
            emscripten_glIsBuffer: _emscripten_glIsBuffer,
            emscripten_glIsEnabled: _emscripten_glIsEnabled,
            emscripten_glIsFramebuffer: _emscripten_glIsFramebuffer,
            emscripten_glIsProgram: _emscripten_glIsProgram,
            emscripten_glIsQueryEXT: _emscripten_glIsQueryEXT,
            emscripten_glIsRenderbuffer: _emscripten_glIsRenderbuffer,
            emscripten_glIsShader: _emscripten_glIsShader,
            emscripten_glIsTexture: _emscripten_glIsTexture,
            emscripten_glIsVertexArray: _emscripten_glIsVertexArray,
            emscripten_glIsVertexArrayOES: _emscripten_glIsVertexArrayOES,
            emscripten_glLineWidth: _emscripten_glLineWidth,
            emscripten_glLinkProgram: _emscripten_glLinkProgram,
            emscripten_glLoadIdentity: _emscripten_glLoadIdentity,
            emscripten_glMatrixMode: _emscripten_glMatrixMode,
            emscripten_glMultiDrawArrays: _emscripten_glMultiDrawArrays,
            emscripten_glMultiDrawArraysANGLE: _emscripten_glMultiDrawArraysANGLE,
            emscripten_glMultiDrawArraysInstancedANGLE: _emscripten_glMultiDrawArraysInstancedANGLE,
            emscripten_glMultiDrawArraysInstancedWEBGL: _emscripten_glMultiDrawArraysInstancedWEBGL,
            emscripten_glMultiDrawArraysWEBGL: _emscripten_glMultiDrawArraysWEBGL,
            emscripten_glMultiDrawElements: _emscripten_glMultiDrawElements,
            emscripten_glMultiDrawElementsANGLE: _emscripten_glMultiDrawElementsANGLE,
            emscripten_glMultiDrawElementsInstancedANGLE: _emscripten_glMultiDrawElementsInstancedANGLE,
            emscripten_glMultiDrawElementsInstancedWEBGL: _emscripten_glMultiDrawElementsInstancedWEBGL,
            emscripten_glMultiDrawElementsWEBGL: _emscripten_glMultiDrawElementsWEBGL,
            emscripten_glPixelStorei: _emscripten_glPixelStorei,
            emscripten_glPolygonOffset: _emscripten_glPolygonOffset,
            emscripten_glQueryCounterEXT: _emscripten_glQueryCounterEXT,
            emscripten_glReadPixels: _emscripten_glReadPixels,
            emscripten_glReleaseShaderCompiler: _emscripten_glReleaseShaderCompiler,
            emscripten_glRenderbufferStorage: _emscripten_glRenderbufferStorage,
            emscripten_glSampleCoverage: _emscripten_glSampleCoverage,
            emscripten_glScissor: _emscripten_glScissor,
            emscripten_glShaderBinary: _emscripten_glShaderBinary,
            emscripten_glShaderSource: _emscripten_glShaderSource,
            emscripten_glStencilFunc: _emscripten_glStencilFunc,
            emscripten_glStencilFuncSeparate: _emscripten_glStencilFuncSeparate,
            emscripten_glStencilMask: _emscripten_glStencilMask,
            emscripten_glStencilMaskSeparate: _emscripten_glStencilMaskSeparate,
            emscripten_glStencilOp: _emscripten_glStencilOp,
            emscripten_glStencilOpSeparate: _emscripten_glStencilOpSeparate,
            emscripten_glTexImage2D: _emscripten_glTexImage2D,
            emscripten_glTexParameterf: _emscripten_glTexParameterf,
            emscripten_glTexParameterfv: _emscripten_glTexParameterfv,
            emscripten_glTexParameteri: _emscripten_glTexParameteri,
            emscripten_glTexParameteriv: _emscripten_glTexParameteriv,
            emscripten_glTexSubImage2D: _emscripten_glTexSubImage2D,
            emscripten_glUniform1f: _emscripten_glUniform1f,
            emscripten_glUniform1fv: _emscripten_glUniform1fv,
            emscripten_glUniform1i: _emscripten_glUniform1i,
            emscripten_glUniform1iv: _emscripten_glUniform1iv,
            emscripten_glUniform2f: _emscripten_glUniform2f,
            emscripten_glUniform2fv: _emscripten_glUniform2fv,
            emscripten_glUniform2i: _emscripten_glUniform2i,
            emscripten_glUniform2iv: _emscripten_glUniform2iv,
            emscripten_glUniform3f: _emscripten_glUniform3f,
            emscripten_glUniform3fv: _emscripten_glUniform3fv,
            emscripten_glUniform3i: _emscripten_glUniform3i,
            emscripten_glUniform3iv: _emscripten_glUniform3iv,
            emscripten_glUniform4f: _emscripten_glUniform4f,
            emscripten_glUniform4fv: _emscripten_glUniform4fv,
            emscripten_glUniform4i: _emscripten_glUniform4i,
            emscripten_glUniform4iv: _emscripten_glUniform4iv,
            emscripten_glUniformMatrix2fv: _emscripten_glUniformMatrix2fv,
            emscripten_glUniformMatrix3fv: _emscripten_glUniformMatrix3fv,
            emscripten_glUniformMatrix4fv: _emscripten_glUniformMatrix4fv,
            emscripten_glUseProgram: _emscripten_glUseProgram,
            emscripten_glValidateProgram: _emscripten_glValidateProgram,
            emscripten_glVertexAttrib1f: _emscripten_glVertexAttrib1f,
            emscripten_glVertexAttrib1fv: _emscripten_glVertexAttrib1fv,
            emscripten_glVertexAttrib2f: _emscripten_glVertexAttrib2f,
            emscripten_glVertexAttrib2fv: _emscripten_glVertexAttrib2fv,
            emscripten_glVertexAttrib3f: _emscripten_glVertexAttrib3f,
            emscripten_glVertexAttrib3fv: _emscripten_glVertexAttrib3fv,
            emscripten_glVertexAttrib4f: _emscripten_glVertexAttrib4f,
            emscripten_glVertexAttrib4fv: _emscripten_glVertexAttrib4fv,
            emscripten_glVertexAttribDivisor: _emscripten_glVertexAttribDivisor,
            emscripten_glVertexAttribDivisorANGLE: _emscripten_glVertexAttribDivisorANGLE,
            emscripten_glVertexAttribDivisorARB: _emscripten_glVertexAttribDivisorARB,
            emscripten_glVertexAttribDivisorEXT: _emscripten_glVertexAttribDivisorEXT,
            emscripten_glVertexAttribDivisorNV: _emscripten_glVertexAttribDivisorNV,
            emscripten_glVertexAttribPointer: _emscripten_glVertexAttribPointer,
            emscripten_glVertexPointer: _emscripten_glVertexPointer,
            emscripten_glViewport: _emscripten_glViewport,
            emscripten_has_asyncify: _emscripten_has_asyncify,
            emscripten_hide_mouse: _emscripten_hide_mouse,
            emscripten_html5_remove_all_event_listeners: _emscripten_html5_remove_all_event_listeners,
            emscripten_idb_async_clear: _emscripten_idb_async_clear,
            emscripten_idb_async_delete: _emscripten_idb_async_delete,
            emscripten_idb_async_exists: _emscripten_idb_async_exists,
            emscripten_idb_async_load: _emscripten_idb_async_load,
            emscripten_idb_async_store: _emscripten_idb_async_store,
            emscripten_idb_clear: _emscripten_idb_clear,
            emscripten_idb_delete: _emscripten_idb_delete,
            emscripten_idb_exists: _emscripten_idb_exists,
            emscripten_idb_load: _emscripten_idb_load,
            emscripten_idb_store: _emscripten_idb_store,
            emscripten_is_main_browser_thread: _emscripten_is_main_browser_thread,
            emscripten_is_webgl_context_lost: _emscripten_is_webgl_context_lost,
            emscripten_lock_orientation: _emscripten_lock_orientation,
            emscripten_log: _emscripten_log,
            emscripten_math_acos: _emscripten_math_acos,
            emscripten_math_acosh: _emscripten_math_acosh,
            emscripten_math_asin: _emscripten_math_asin,
            emscripten_math_asinh: _emscripten_math_asinh,
            emscripten_math_atan: _emscripten_math_atan,
            emscripten_math_atan2: _emscripten_math_atan2,
            emscripten_math_atanh: _emscripten_math_atanh,
            emscripten_math_cbrt: _emscripten_math_cbrt,
            emscripten_math_cos: _emscripten_math_cos,
            emscripten_math_cosh: _emscripten_math_cosh,
            emscripten_math_exp: _emscripten_math_exp,
            emscripten_math_expm1: _emscripten_math_expm1,
            emscripten_math_fmod: _emscripten_math_fmod,
            emscripten_math_hypot: _emscripten_math_hypot,
            emscripten_math_log: _emscripten_math_log,
            emscripten_math_log10: _emscripten_math_log10,
            emscripten_math_log1p: _emscripten_math_log1p,
            emscripten_math_log2: _emscripten_math_log2,
            emscripten_math_pow: _emscripten_math_pow,
            emscripten_math_random: _emscripten_math_random,
            emscripten_math_round: _emscripten_math_round,
            emscripten_math_sign: _emscripten_math_sign,
            emscripten_math_sin: _emscripten_math_sin,
            emscripten_math_sinh: _emscripten_math_sinh,
            emscripten_math_sqrt: _emscripten_math_sqrt,
            emscripten_math_tan: _emscripten_math_tan,
            emscripten_math_tanh: _emscripten_math_tanh,
            emscripten_memcpy_js: _emscripten_memcpy_js,
            emscripten_notify_memory_growth: _emscripten_notify_memory_growth,
            emscripten_out: _emscripten_out,
            emscripten_outn: _emscripten_outn,
            emscripten_pause_main_loop: _emscripten_pause_main_loop,
            emscripten_pc_get_column: _emscripten_pc_get_column,
            emscripten_pc_get_file: _emscripten_pc_get_file,
            emscripten_pc_get_function: _emscripten_pc_get_function,
            emscripten_pc_get_line: _emscripten_pc_get_line,
            emscripten_performance_now: _emscripten_performance_now,
            emscripten_print_double: _emscripten_print_double,
            emscripten_promise_all: _emscripten_promise_all,
            emscripten_promise_all_settled: _emscripten_promise_all_settled,
            emscripten_promise_any: _emscripten_promise_any,
            emscripten_promise_await: _emscripten_promise_await,
            emscripten_promise_create: _emscripten_promise_create,
            emscripten_promise_destroy: _emscripten_promise_destroy,
            emscripten_promise_race: _emscripten_promise_race,
            emscripten_promise_resolve: _emscripten_promise_resolve,
            emscripten_promise_then: _emscripten_promise_then,
            emscripten_random: _emscripten_random,
            emscripten_request_animation_frame: _emscripten_request_animation_frame,
            emscripten_request_animation_frame_loop: _emscripten_request_animation_frame_loop,
            emscripten_request_fullscreen: _emscripten_request_fullscreen,
            emscripten_request_fullscreen_strategy: _emscripten_request_fullscreen_strategy,
            emscripten_request_pointerlock: _emscripten_request_pointerlock,
            emscripten_resize_heap: _emscripten_resize_heap,
            emscripten_resume_main_loop: _emscripten_resume_main_loop,
            emscripten_return_address: _emscripten_return_address,
            emscripten_run_preload_plugins: _emscripten_run_preload_plugins,
            emscripten_run_preload_plugins_data: _emscripten_run_preload_plugins_data,
            emscripten_run_script: _emscripten_run_script,
            emscripten_run_script_int: _emscripten_run_script_int,
            emscripten_run_script_string: _emscripten_run_script_string,
            emscripten_runtime_keepalive_check: _emscripten_runtime_keepalive_check,
            emscripten_runtime_keepalive_pop: _emscripten_runtime_keepalive_pop,
            emscripten_runtime_keepalive_push: _emscripten_runtime_keepalive_push,
            emscripten_sample_gamepad_data: _emscripten_sample_gamepad_data,
            emscripten_scan_registers: _emscripten_scan_registers,
            emscripten_set_batterychargingchange_callback_on_thread: _emscripten_set_batterychargingchange_callback_on_thread,
            emscripten_set_batterylevelchange_callback_on_thread: _emscripten_set_batterylevelchange_callback_on_thread,
            emscripten_set_beforeunload_callback_on_thread: _emscripten_set_beforeunload_callback_on_thread,
            emscripten_set_blur_callback_on_thread: _emscripten_set_blur_callback_on_thread,
            emscripten_set_canvas_element_size: _emscripten_set_canvas_element_size,
            emscripten_set_canvas_size: _emscripten_set_canvas_size,
            emscripten_set_click_callback_on_thread: _emscripten_set_click_callback_on_thread,
            emscripten_set_dblclick_callback_on_thread: _emscripten_set_dblclick_callback_on_thread,
            emscripten_set_devicemotion_callback_on_thread: _emscripten_set_devicemotion_callback_on_thread,
            emscripten_set_deviceorientation_callback_on_thread: _emscripten_set_deviceorientation_callback_on_thread,
            emscripten_set_element_css_size: _emscripten_set_element_css_size,
            emscripten_set_focus_callback_on_thread: _emscripten_set_focus_callback_on_thread,
            emscripten_set_focusin_callback_on_thread: _emscripten_set_focusin_callback_on_thread,
            emscripten_set_focusout_callback_on_thread: _emscripten_set_focusout_callback_on_thread,
            emscripten_set_fullscreenchange_callback_on_thread: _emscripten_set_fullscreenchange_callback_on_thread,
            emscripten_set_gamepadconnected_callback_on_thread: _emscripten_set_gamepadconnected_callback_on_thread,
            emscripten_set_gamepaddisconnected_callback_on_thread: _emscripten_set_gamepaddisconnected_callback_on_thread,
            emscripten_set_immediate: _emscripten_set_immediate,
            emscripten_set_immediate_loop: _emscripten_set_immediate_loop,
            emscripten_set_interval: _emscripten_set_interval,
            emscripten_set_keydown_callback_on_thread: _emscripten_set_keydown_callback_on_thread,
            emscripten_set_keypress_callback_on_thread: _emscripten_set_keypress_callback_on_thread,
            emscripten_set_keyup_callback_on_thread: _emscripten_set_keyup_callback_on_thread,
            emscripten_set_main_loop: _emscripten_set_main_loop,
            emscripten_set_main_loop_arg: _emscripten_set_main_loop_arg,
            emscripten_set_main_loop_expected_blockers: _emscripten_set_main_loop_expected_blockers,
            emscripten_set_main_loop_timing: _emscripten_set_main_loop_timing,
            emscripten_set_mousedown_callback_on_thread: _emscripten_set_mousedown_callback_on_thread,
            emscripten_set_mouseenter_callback_on_thread: _emscripten_set_mouseenter_callback_on_thread,
            emscripten_set_mouseleave_callback_on_thread: _emscripten_set_mouseleave_callback_on_thread,
            emscripten_set_mousemove_callback_on_thread: _emscripten_set_mousemove_callback_on_thread,
            emscripten_set_mouseout_callback_on_thread: _emscripten_set_mouseout_callback_on_thread,
            emscripten_set_mouseover_callback_on_thread: _emscripten_set_mouseover_callback_on_thread,
            emscripten_set_mouseup_callback_on_thread: _emscripten_set_mouseup_callback_on_thread,
            emscripten_set_orientationchange_callback_on_thread: _emscripten_set_orientationchange_callback_on_thread,
            emscripten_set_pointerlockchange_callback_on_thread: _emscripten_set_pointerlockchange_callback_on_thread,
            emscripten_set_pointerlockerror_callback_on_thread: _emscripten_set_pointerlockerror_callback_on_thread,
            emscripten_set_resize_callback_on_thread: _emscripten_set_resize_callback_on_thread,
            emscripten_set_scroll_callback_on_thread: _emscripten_set_scroll_callback_on_thread,
            emscripten_set_socket_close_callback: _emscripten_set_socket_close_callback,
            emscripten_set_socket_connection_callback: _emscripten_set_socket_connection_callback,
            emscripten_set_socket_error_callback: _emscripten_set_socket_error_callback,
            emscripten_set_socket_listen_callback: _emscripten_set_socket_listen_callback,
            emscripten_set_socket_message_callback: _emscripten_set_socket_message_callback,
            emscripten_set_socket_open_callback: _emscripten_set_socket_open_callback,
            emscripten_set_timeout: _emscripten_set_timeout,
            emscripten_set_timeout_loop: _emscripten_set_timeout_loop,
            emscripten_set_touchcancel_callback_on_thread: _emscripten_set_touchcancel_callback_on_thread,
            emscripten_set_touchend_callback_on_thread: _emscripten_set_touchend_callback_on_thread,
            emscripten_set_touchmove_callback_on_thread: _emscripten_set_touchmove_callback_on_thread,
            emscripten_set_touchstart_callback_on_thread: _emscripten_set_touchstart_callback_on_thread,
            emscripten_set_visibilitychange_callback_on_thread: _emscripten_set_visibilitychange_callback_on_thread,
            emscripten_set_webglcontextlost_callback_on_thread: _emscripten_set_webglcontextlost_callback_on_thread,
            emscripten_set_webglcontextrestored_callback_on_thread: _emscripten_set_webglcontextrestored_callback_on_thread,
            emscripten_set_wheel_callback_on_thread: _emscripten_set_wheel_callback_on_thread,
            emscripten_set_window_title: _emscripten_set_window_title,
            emscripten_sleep: _emscripten_sleep,
            emscripten_stack_snapshot: _emscripten_stack_snapshot,
            emscripten_stack_unwind_buffer: _emscripten_stack_unwind_buffer,
            emscripten_supports_offscreencanvas: _emscripten_supports_offscreencanvas,
            emscripten_throw_number: _emscripten_throw_number,
            emscripten_throw_string: _emscripten_throw_string,
            emscripten_unlock_orientation: _emscripten_unlock_orientation,
            emscripten_unwind_to_js_event_loop: _emscripten_unwind_to_js_event_loop,
            emscripten_vibrate: _emscripten_vibrate,
            emscripten_vibrate_pattern: _emscripten_vibrate_pattern,
            emscripten_webgl_commit_frame: _emscripten_webgl_commit_frame,
            emscripten_webgl_create_context: _emscripten_webgl_create_context,
            emscripten_webgl_destroy_context: _emscripten_webgl_destroy_context,
            emscripten_webgl_do_commit_frame: _emscripten_webgl_do_commit_frame,
            emscripten_webgl_do_create_context: _emscripten_webgl_do_create_context,
            emscripten_webgl_do_get_current_context: _emscripten_webgl_do_get_current_context,
            emscripten_webgl_enable_ANGLE_instanced_arrays: _emscripten_webgl_enable_ANGLE_instanced_arrays,
            emscripten_webgl_enable_OES_vertex_array_object: _emscripten_webgl_enable_OES_vertex_array_object,
            emscripten_webgl_enable_WEBGL_draw_buffers: _emscripten_webgl_enable_WEBGL_draw_buffers,
            emscripten_webgl_enable_WEBGL_multi_draw: _emscripten_webgl_enable_WEBGL_multi_draw,
            emscripten_webgl_enable_extension: _emscripten_webgl_enable_extension,
            emscripten_webgl_get_context_attributes: _emscripten_webgl_get_context_attributes,
            emscripten_webgl_get_current_context: _emscripten_webgl_get_current_context,
            emscripten_webgl_get_drawing_buffer_size: _emscripten_webgl_get_drawing_buffer_size,
            emscripten_webgl_get_parameter_d: _emscripten_webgl_get_parameter_d,
            emscripten_webgl_get_parameter_i64v: _emscripten_webgl_get_parameter_i64v,
            emscripten_webgl_get_parameter_o: _emscripten_webgl_get_parameter_o,
            emscripten_webgl_get_parameter_utf8: _emscripten_webgl_get_parameter_utf8,
            emscripten_webgl_get_parameter_v: _emscripten_webgl_get_parameter_v,
            emscripten_webgl_get_program_info_log_utf8: _emscripten_webgl_get_program_info_log_utf8,
            emscripten_webgl_get_program_parameter_d: _emscripten_webgl_get_program_parameter_d,
            emscripten_webgl_get_shader_info_log_utf8: _emscripten_webgl_get_shader_info_log_utf8,
            emscripten_webgl_get_shader_parameter_d: _emscripten_webgl_get_shader_parameter_d,
            emscripten_webgl_get_shader_source_utf8: _emscripten_webgl_get_shader_source_utf8,
            emscripten_webgl_get_supported_extensions: _emscripten_webgl_get_supported_extensions,
            emscripten_webgl_get_uniform_d: _emscripten_webgl_get_uniform_d,
            emscripten_webgl_get_uniform_v: _emscripten_webgl_get_uniform_v,
            emscripten_webgl_get_vertex_attrib_d: _emscripten_webgl_get_vertex_attrib_d,
            emscripten_webgl_get_vertex_attrib_o: _emscripten_webgl_get_vertex_attrib_o,
            emscripten_webgl_get_vertex_attrib_v: _emscripten_webgl_get_vertex_attrib_v,
            emscripten_webgl_init_context_attributes: _emscripten_webgl_init_context_attributes,
            emscripten_webgl_make_context_current: _emscripten_webgl_make_context_current,
            emscripten_wget_data: _emscripten_wget_data,
            endprotoent: _endprotoent,
            environ_get: _environ_get,
            environ_sizes_get: _environ_sizes_get,
            exit: _exit,
            fd_close: _fd_close,
            fd_fdstat_get: _fd_fdstat_get,
            fd_pread: _fd_pread,
            fd_pwrite: _fd_pwrite,
            fd_read: _fd_read,
            fd_seek: _fd_seek,
            fd_sync: _fd_sync,
            fd_write: _fd_write,
            filledEllipseColor: _filledEllipseColor,
            filledEllipseRGBA: _filledEllipseRGBA,
            getaddrinfo: _getaddrinfo,
            getentropy: _getentropy,
            getnameinfo: _getnameinfo,
            getprotobyname: _getprotobyname,
            getprotobynumber: _getprotobynumber,
            getprotoent: _getprotoent,
            glActiveTexture: _glActiveTexture,
            glAttachShader: _glAttachShader,
            glBegin: _glBegin,
            glBeginQueryEXT: _glBeginQueryEXT,
            glBindAttribLocation: _glBindAttribLocation,
            glBindBuffer: _glBindBuffer,
            glBindFramebuffer: _glBindFramebuffer,
            glBindRenderbuffer: _glBindRenderbuffer,
            glBindTexture: _glBindTexture,
            glBindVertexArray: _glBindVertexArray,
            glBindVertexArrayOES: _glBindVertexArrayOES,
            glBlendColor: _glBlendColor,
            glBlendEquation: _glBlendEquation,
            glBlendEquationSeparate: _glBlendEquationSeparate,
            glBlendFunc: _glBlendFunc,
            glBlendFuncSeparate: _glBlendFuncSeparate,
            glBufferData: _glBufferData,
            glBufferSubData: _glBufferSubData,
            glCheckFramebufferStatus: _glCheckFramebufferStatus,
            glClear: _glClear,
            glClearColor: _glClearColor,
            glClearDepth: _glClearDepth,
            glClearDepthf: _glClearDepthf,
            glClearStencil: _glClearStencil,
            glColorMask: _glColorMask,
            glCompileShader: _glCompileShader,
            glCompressedTexImage2D: _glCompressedTexImage2D,
            glCompressedTexSubImage2D: _glCompressedTexSubImage2D,
            glCopyTexImage2D: _glCopyTexImage2D,
            glCopyTexSubImage2D: _glCopyTexSubImage2D,
            glCreateProgram: _glCreateProgram,
            glCreateShader: _glCreateShader,
            glCullFace: _glCullFace,
            glDeleteBuffers: _glDeleteBuffers,
            glDeleteFramebuffers: _glDeleteFramebuffers,
            glDeleteProgram: _glDeleteProgram,
            glDeleteQueriesEXT: _glDeleteQueriesEXT,
            glDeleteRenderbuffers: _glDeleteRenderbuffers,
            glDeleteShader: _glDeleteShader,
            glDeleteTextures: _glDeleteTextures,
            glDeleteVertexArrays: _glDeleteVertexArrays,
            glDeleteVertexArraysOES: _glDeleteVertexArraysOES,
            glDepthFunc: _glDepthFunc,
            glDepthMask: _glDepthMask,
            glDepthRange: _glDepthRange,
            glDepthRangef: _glDepthRangef,
            glDetachShader: _glDetachShader,
            glDisable: _glDisable,
            glDisableVertexAttribArray: _glDisableVertexAttribArray,
            glDrawArrays: _glDrawArrays,
            glDrawArraysInstanced: _glDrawArraysInstanced,
            glDrawArraysInstancedANGLE: _glDrawArraysInstancedANGLE,
            glDrawArraysInstancedARB: _glDrawArraysInstancedARB,
            glDrawArraysInstancedEXT: _glDrawArraysInstancedEXT,
            glDrawArraysInstancedNV: _glDrawArraysInstancedNV,
            glDrawBuffers: _glDrawBuffers,
            glDrawBuffersEXT: _glDrawBuffersEXT,
            glDrawBuffersWEBGL: _glDrawBuffersWEBGL,
            glDrawElements: _glDrawElements,
            glDrawElementsInstanced: _glDrawElementsInstanced,
            glDrawElementsInstancedANGLE: _glDrawElementsInstancedANGLE,
            glDrawElementsInstancedARB: _glDrawElementsInstancedARB,
            glDrawElementsInstancedEXT: _glDrawElementsInstancedEXT,
            glDrawElementsInstancedNV: _glDrawElementsInstancedNV,
            glEnable: _glEnable,
            glEnableVertexAttribArray: _glEnableVertexAttribArray,
            glEndQueryEXT: _glEndQueryEXT,
            glFinish: _glFinish,
            glFlush: _glFlush,
            glFramebufferRenderbuffer: _glFramebufferRenderbuffer,
            glFramebufferTexture2D: _glFramebufferTexture2D,
            glFrontFace: _glFrontFace,
            glGenBuffers: _glGenBuffers,
            glGenFramebuffers: _glGenFramebuffers,
            glGenQueriesEXT: _glGenQueriesEXT,
            glGenRenderbuffers: _glGenRenderbuffers,
            glGenTextures: _glGenTextures,
            glGenVertexArrays: _glGenVertexArrays,
            glGenVertexArraysOES: _glGenVertexArraysOES,
            glGenerateMipmap: _glGenerateMipmap,
            glGetActiveAttrib: _glGetActiveAttrib,
            glGetActiveUniform: _glGetActiveUniform,
            glGetAttachedShaders: _glGetAttachedShaders,
            glGetAttribLocation: _glGetAttribLocation,
            glGetBooleanv: _glGetBooleanv,
            glGetBufferParameteriv: _glGetBufferParameteriv,
            glGetError: _glGetError,
            glGetFloatv: _glGetFloatv,
            glGetFramebufferAttachmentParameteriv: _glGetFramebufferAttachmentParameteriv,
            glGetIntegerv: _glGetIntegerv,
            glGetProgramInfoLog: _glGetProgramInfoLog,
            glGetProgramiv: _glGetProgramiv,
            glGetQueryObjecti64vEXT: _glGetQueryObjecti64vEXT,
            glGetQueryObjectivEXT: _glGetQueryObjectivEXT,
            glGetQueryObjectui64vEXT: _glGetQueryObjectui64vEXT,
            glGetQueryObjectuivEXT: _glGetQueryObjectuivEXT,
            glGetQueryivEXT: _glGetQueryivEXT,
            glGetRenderbufferParameteriv: _glGetRenderbufferParameteriv,
            glGetShaderInfoLog: _glGetShaderInfoLog,
            glGetShaderPrecisionFormat: _glGetShaderPrecisionFormat,
            glGetShaderSource: _glGetShaderSource,
            glGetShaderiv: _glGetShaderiv,
            glGetString: _glGetString,
            glGetTexParameterfv: _glGetTexParameterfv,
            glGetTexParameteriv: _glGetTexParameteriv,
            glGetUniformLocation: _glGetUniformLocation,
            glGetUniformfv: _glGetUniformfv,
            glGetUniformiv: _glGetUniformiv,
            glGetVertexAttribPointerv: _glGetVertexAttribPointerv,
            glGetVertexAttribfv: _glGetVertexAttribfv,
            glGetVertexAttribiv: _glGetVertexAttribiv,
            glHint: _glHint,
            glIsBuffer: _glIsBuffer,
            glIsEnabled: _glIsEnabled,
            glIsFramebuffer: _glIsFramebuffer,
            glIsProgram: _glIsProgram,
            glIsQueryEXT: _glIsQueryEXT,
            glIsRenderbuffer: _glIsRenderbuffer,
            glIsShader: _glIsShader,
            glIsTexture: _glIsTexture,
            glIsVertexArray: _glIsVertexArray,
            glIsVertexArrayOES: _glIsVertexArrayOES,
            glLineWidth: _glLineWidth,
            glLinkProgram: _glLinkProgram,
            glLoadIdentity: _glLoadIdentity,
            glMatrixMode: _glMatrixMode,
            glMultiDrawArrays: _glMultiDrawArrays,
            glMultiDrawArraysANGLE: _glMultiDrawArraysANGLE,
            glMultiDrawArraysInstancedANGLE: _glMultiDrawArraysInstancedANGLE,
            glMultiDrawArraysInstancedWEBGL: _glMultiDrawArraysInstancedWEBGL,
            glMultiDrawArraysWEBGL: _glMultiDrawArraysWEBGL,
            glMultiDrawElements: _glMultiDrawElements,
            glMultiDrawElementsANGLE: _glMultiDrawElementsANGLE,
            glMultiDrawElementsInstancedANGLE: _glMultiDrawElementsInstancedANGLE,
            glMultiDrawElementsInstancedWEBGL: _glMultiDrawElementsInstancedWEBGL,
            glMultiDrawElementsWEBGL: _glMultiDrawElementsWEBGL,
            glPixelStorei: _glPixelStorei,
            glPolygonOffset: _glPolygonOffset,
            glQueryCounterEXT: _glQueryCounterEXT,
            glReadPixels: _glReadPixels,
            glReleaseShaderCompiler: _glReleaseShaderCompiler,
            glRenderbufferStorage: _glRenderbufferStorage,
            glSampleCoverage: _glSampleCoverage,
            glScissor: _glScissor,
            glShaderBinary: _glShaderBinary,
            glShaderSource: _glShaderSource,
            glStencilFunc: _glStencilFunc,
            glStencilFuncSeparate: _glStencilFuncSeparate,
            glStencilMask: _glStencilMask,
            glStencilMaskSeparate: _glStencilMaskSeparate,
            glStencilOp: _glStencilOp,
            glStencilOpSeparate: _glStencilOpSeparate,
            glTexImage2D: _glTexImage2D,
            glTexParameterf: _glTexParameterf,
            glTexParameterfv: _glTexParameterfv,
            glTexParameteri: _glTexParameteri,
            glTexParameteriv: _glTexParameteriv,
            glTexSubImage2D: _glTexSubImage2D,
            glUniform1f: _glUniform1f,
            glUniform1fv: _glUniform1fv,
            glUniform1i: _glUniform1i,
            glUniform1iv: _glUniform1iv,
            glUniform2f: _glUniform2f,
            glUniform2fv: _glUniform2fv,
            glUniform2i: _glUniform2i,
            glUniform2iv: _glUniform2iv,
            glUniform3f: _glUniform3f,
            glUniform3fv: _glUniform3fv,
            glUniform3i: _glUniform3i,
            glUniform3iv: _glUniform3iv,
            glUniform4f: _glUniform4f,
            glUniform4fv: _glUniform4fv,
            glUniform4i: _glUniform4i,
            glUniform4iv: _glUniform4iv,
            glUniformMatrix2fv: _glUniformMatrix2fv,
            glUniformMatrix3fv: _glUniformMatrix3fv,
            glUniformMatrix4fv: _glUniformMatrix4fv,
            glUseProgram: _glUseProgram,
            glValidateProgram: _glValidateProgram,
            glVertexAttrib1f: _glVertexAttrib1f,
            glVertexAttrib1fv: _glVertexAttrib1fv,
            glVertexAttrib2f: _glVertexAttrib2f,
            glVertexAttrib2fv: _glVertexAttrib2fv,
            glVertexAttrib3f: _glVertexAttrib3f,
            glVertexAttrib3fv: _glVertexAttrib3fv,
            glVertexAttrib4f: _glVertexAttrib4f,
            glVertexAttrib4fv: _glVertexAttrib4fv,
            glVertexAttribDivisor: _glVertexAttribDivisor,
            glVertexAttribDivisorANGLE: _glVertexAttribDivisorANGLE,
            glVertexAttribDivisorARB: _glVertexAttribDivisorARB,
            glVertexAttribDivisorEXT: _glVertexAttribDivisorEXT,
            glVertexAttribDivisorNV: _glVertexAttribDivisorNV,
            glVertexAttribPointer: _glVertexAttribPointer,
            glVertexPointer: _glVertexPointer,
            glViewport: _glViewport,
            glewGetErrorString: _glewGetErrorString,
            glewGetExtension: _glewGetExtension,
            glewGetString: _glewGetString,
            glewInit: _glewInit,
            glewIsSupported: _glewIsSupported,
            glutCreateWindow: _glutCreateWindow,
            glutDestroyWindow: _glutDestroyWindow,
            glutDisplayFunc: _glutDisplayFunc,
            glutFullScreen: _glutFullScreen,
            glutGet: _glutGet,
            glutGetModifiers: _glutGetModifiers,
            glutIdleFunc: _glutIdleFunc,
            glutInit: _glutInit,
            glutInitDisplayMode: _glutInitDisplayMode,
            glutInitWindowPosition: _glutInitWindowPosition,
            glutInitWindowSize: _glutInitWindowSize,
            glutKeyboardFunc: _glutKeyboardFunc,
            glutKeyboardUpFunc: _glutKeyboardUpFunc,
            glutMainLoop: _glutMainLoop,
            glutMotionFunc: _glutMotionFunc,
            glutMouseFunc: _glutMouseFunc,
            glutPassiveMotionFunc: _glutPassiveMotionFunc,
            glutPositionWindow: _glutPositionWindow,
            glutPostRedisplay: _glutPostRedisplay,
            glutReshapeFunc: _glutReshapeFunc,
            glutReshapeWindow: _glutReshapeWindow,
            glutSetCursor: _glutSetCursor,
            glutSpecialFunc: _glutSpecialFunc,
            glutSpecialUpFunc: _glutSpecialUpFunc,
            glutSwapBuffers: _glutSwapBuffers,
            glutTimerFunc: _glutTimerFunc,
            lineColor: _lineColor,
            lineRGBA: _lineRGBA,
            memory: wasmMemory,
            pixelRGBA: _pixelRGBA,
            proc_exit: _proc_exit,
            pthread_kill: _pthread_kill,
            random_get: _random_get,
            rectangleColor: _rectangleColor,
            rectangleRGBA: _rectangleRGBA,
            rotozoomSurface: _rotozoomSurface,
            setNetworkCallback: _setNetworkCallback,
            setprotoent: _setprotoent,
            strftime: _strftime,
            strftime_l: _strftime_l,
            strptime: _strptime,
            strptime_l: _strptime_l,
            uuid_clear: _uuid_clear,
            uuid_compare: _uuid_compare,
            uuid_copy: _uuid_copy,
            uuid_generate: _uuid_generate,
            uuid_is_null: _uuid_is_null,
            uuid_parse: _uuid_parse,
            uuid_type: _uuid_type,
            uuid_unparse: _uuid_unparse,
            uuid_unparse_lower: _uuid_unparse_lower,
            uuid_unparse_upper: _uuid_unparse_upper,
            uuid_variant: _uuid_variant,
            zoomSurface: _zoomSurface
          };
          var wasmExports = createWasm();
          var _main = Module["_main"] = (a0, a1) => (_main = Module["_main"] = wasmExports["main"])(a0, a1);
          var _malloc = Module["_malloc"] = (a0) => (_malloc = Module["_malloc"] = wasmExports["malloc"])(a0);
          var _free = Module["_free"] = (a0) => (_free = Module["_free"] = wasmExports["free"])(a0);
          var _duckdb_web_fs_glob_add_path = Module["_duckdb_web_fs_glob_add_path"] = (a0) => (_duckdb_web_fs_glob_add_path = Module["_duckdb_web_fs_glob_add_path"] = wasmExports["duckdb_web_fs_glob_add_path"])(a0);
          var _duckdb_web_clear_response = Module["_duckdb_web_clear_response"] = () => (_duckdb_web_clear_response = Module["_duckdb_web_clear_response"] = wasmExports["duckdb_web_clear_response"])();
          var _duckdb_web_fail_with = Module["_duckdb_web_fail_with"] = (a0) => (_duckdb_web_fail_with = Module["_duckdb_web_fail_with"] = wasmExports["duckdb_web_fail_with"])(a0);
          var _duckdb_web_reset = Module["_duckdb_web_reset"] = (a0) => (_duckdb_web_reset = Module["_duckdb_web_reset"] = wasmExports["duckdb_web_reset"])(a0);
          var _duckdb_web_connect = Module["_duckdb_web_connect"] = () => (_duckdb_web_connect = Module["_duckdb_web_connect"] = wasmExports["duckdb_web_connect"])();
          var _duckdb_web_disconnect = Module["_duckdb_web_disconnect"] = (a0) => (_duckdb_web_disconnect = Module["_duckdb_web_disconnect"] = wasmExports["duckdb_web_disconnect"])(a0);
          var _duckdb_web_access_buffer = Module["_duckdb_web_access_buffer"] = (a0, a1) => (_duckdb_web_access_buffer = Module["_duckdb_web_access_buffer"] = wasmExports["duckdb_web_access_buffer"])(a0, a1);
          var _duckdb_web_flush_files = Module["_duckdb_web_flush_files"] = () => (_duckdb_web_flush_files = Module["_duckdb_web_flush_files"] = wasmExports["duckdb_web_flush_files"])();
          var _duckdb_web_flush_file = Module["_duckdb_web_flush_file"] = (a0) => (_duckdb_web_flush_file = Module["_duckdb_web_flush_file"] = wasmExports["duckdb_web_flush_file"])(a0);
          var _duckdb_web_open = Module["_duckdb_web_open"] = (a0, a1) => (_duckdb_web_open = Module["_duckdb_web_open"] = wasmExports["duckdb_web_open"])(a0, a1);
          var _duckdb_web_get_global_file_info = Module["_duckdb_web_get_global_file_info"] = (a0, a1) => (_duckdb_web_get_global_file_info = Module["_duckdb_web_get_global_file_info"] = wasmExports["duckdb_web_get_global_file_info"])(a0, a1);
          var _duckdb_web_collect_file_stats = Module["_duckdb_web_collect_file_stats"] = (a0, a1, a2) => (_duckdb_web_collect_file_stats = Module["_duckdb_web_collect_file_stats"] = wasmExports["duckdb_web_collect_file_stats"])(a0, a1, a2);
          var _duckdb_web_export_file_stats = Module["_duckdb_web_export_file_stats"] = (a0, a1) => (_duckdb_web_export_file_stats = Module["_duckdb_web_export_file_stats"] = wasmExports["duckdb_web_export_file_stats"])(a0, a1);
          var _duckdb_web_fs_drop_file = Module["_duckdb_web_fs_drop_file"] = (a0, a1) => (_duckdb_web_fs_drop_file = Module["_duckdb_web_fs_drop_file"] = wasmExports["duckdb_web_fs_drop_file"])(a0, a1);
          var _duckdb_web_fs_drop_files = Module["_duckdb_web_fs_drop_files"] = (a0) => (_duckdb_web_fs_drop_files = Module["_duckdb_web_fs_drop_files"] = wasmExports["duckdb_web_fs_drop_files"])(a0);
          var _duckdb_web_fs_glob_file_infos = Module["_duckdb_web_fs_glob_file_infos"] = (a0, a1) => (_duckdb_web_fs_glob_file_infos = Module["_duckdb_web_fs_glob_file_infos"] = wasmExports["duckdb_web_fs_glob_file_infos"])(a0, a1);
          var _duckdb_web_fs_get_file_info_by_id = Module["_duckdb_web_fs_get_file_info_by_id"] = (a0, a1, a2) => (_duckdb_web_fs_get_file_info_by_id = Module["_duckdb_web_fs_get_file_info_by_id"] = wasmExports["duckdb_web_fs_get_file_info_by_id"])(a0, a1, a2);
          var _duckdb_web_fs_get_file_info_by_name = Module["_duckdb_web_fs_get_file_info_by_name"] = (a0, a1, a2) => (_duckdb_web_fs_get_file_info_by_name = Module["_duckdb_web_fs_get_file_info_by_name"] = wasmExports["duckdb_web_fs_get_file_info_by_name"])(a0, a1, a2);
          var _duckdb_web_fs_register_file_url = Module["_duckdb_web_fs_register_file_url"] = (a0, a1, a2, a3, a4) => (_duckdb_web_fs_register_file_url = Module["_duckdb_web_fs_register_file_url"] = wasmExports["duckdb_web_fs_register_file_url"])(a0, a1, a2, a3, a4);
          var _duckdb_web_fs_register_file_buffer = Module["_duckdb_web_fs_register_file_buffer"] = (a0, a1, a2, a3) => (_duckdb_web_fs_register_file_buffer = Module["_duckdb_web_fs_register_file_buffer"] = wasmExports["duckdb_web_fs_register_file_buffer"])(a0, a1, a2, a3);
          var _duckdb_web_copy_file_to_buffer = Module["_duckdb_web_copy_file_to_buffer"] = (a0, a1) => (_duckdb_web_copy_file_to_buffer = Module["_duckdb_web_copy_file_to_buffer"] = wasmExports["duckdb_web_copy_file_to_buffer"])(a0, a1);
          var _duckdb_web_copy_file_to_path = Module["_duckdb_web_copy_file_to_path"] = (a0, a1, a2) => (_duckdb_web_copy_file_to_path = Module["_duckdb_web_copy_file_to_path"] = wasmExports["duckdb_web_copy_file_to_path"])(a0, a1, a2);
          var _duckdb_web_get_version = Module["_duckdb_web_get_version"] = (a0) => (_duckdb_web_get_version = Module["_duckdb_web_get_version"] = wasmExports["duckdb_web_get_version"])(a0);
          var _duckdb_web_get_feature_flags = Module["_duckdb_web_get_feature_flags"] = () => (_duckdb_web_get_feature_flags = Module["_duckdb_web_get_feature_flags"] = wasmExports["duckdb_web_get_feature_flags"])();
          var _duckdb_web_tokenize = Module["_duckdb_web_tokenize"] = (a0, a1) => (_duckdb_web_tokenize = Module["_duckdb_web_tokenize"] = wasmExports["duckdb_web_tokenize"])(a0, a1);
          var _duckdb_web_udf_scalar_create = Module["_duckdb_web_udf_scalar_create"] = (a0, a1, a2) => (_duckdb_web_udf_scalar_create = Module["_duckdb_web_udf_scalar_create"] = wasmExports["duckdb_web_udf_scalar_create"])(a0, a1, a2);
          var _duckdb_web_prepared_create = Module["_duckdb_web_prepared_create"] = (a0, a1, a2) => (_duckdb_web_prepared_create = Module["_duckdb_web_prepared_create"] = wasmExports["duckdb_web_prepared_create"])(a0, a1, a2);
          var _duckdb_web_prepared_close = Module["_duckdb_web_prepared_close"] = (a0, a1, a2) => (_duckdb_web_prepared_close = Module["_duckdb_web_prepared_close"] = wasmExports["duckdb_web_prepared_close"])(a0, a1, a2);
          var _duckdb_web_prepared_run = Module["_duckdb_web_prepared_run"] = (a0, a1, a2, a3) => (_duckdb_web_prepared_run = Module["_duckdb_web_prepared_run"] = wasmExports["duckdb_web_prepared_run"])(a0, a1, a2, a3);
          var _duckdb_web_prepared_send = Module["_duckdb_web_prepared_send"] = (a0, a1, a2, a3) => (_duckdb_web_prepared_send = Module["_duckdb_web_prepared_send"] = wasmExports["duckdb_web_prepared_send"])(a0, a1, a2, a3);
          var _duckdb_web_query_run = Module["_duckdb_web_query_run"] = (a0, a1, a2) => (_duckdb_web_query_run = Module["_duckdb_web_query_run"] = wasmExports["duckdb_web_query_run"])(a0, a1, a2);
          var _duckdb_web_pending_query_start = Module["_duckdb_web_pending_query_start"] = (a0, a1, a2) => (_duckdb_web_pending_query_start = Module["_duckdb_web_pending_query_start"] = wasmExports["duckdb_web_pending_query_start"])(a0, a1, a2);
          var _duckdb_web_pending_query_poll = Module["_duckdb_web_pending_query_poll"] = (a0, a1, a2) => (_duckdb_web_pending_query_poll = Module["_duckdb_web_pending_query_poll"] = wasmExports["duckdb_web_pending_query_poll"])(a0, a1, a2);
          var _duckdb_web_pending_query_cancel = Module["_duckdb_web_pending_query_cancel"] = (a0, a1) => (_duckdb_web_pending_query_cancel = Module["_duckdb_web_pending_query_cancel"] = wasmExports["duckdb_web_pending_query_cancel"])(a0, a1);
          var _duckdb_web_query_fetch_results = Module["_duckdb_web_query_fetch_results"] = (a0, a1) => (_duckdb_web_query_fetch_results = Module["_duckdb_web_query_fetch_results"] = wasmExports["duckdb_web_query_fetch_results"])(a0, a1);
          var _duckdb_web_get_tablenames = Module["_duckdb_web_get_tablenames"] = (a0, a1, a2) => (_duckdb_web_get_tablenames = Module["_duckdb_web_get_tablenames"] = wasmExports["duckdb_web_get_tablenames"])(a0, a1, a2);
          var _duckdb_web_insert_arrow_from_ipc_stream = Module["_duckdb_web_insert_arrow_from_ipc_stream"] = (a0, a1, a2, a3, a4) => (_duckdb_web_insert_arrow_from_ipc_stream = Module["_duckdb_web_insert_arrow_from_ipc_stream"] = wasmExports["duckdb_web_insert_arrow_from_ipc_stream"])(a0, a1, a2, a3, a4);
          var _duckdb_web_insert_csv_from_path = Module["_duckdb_web_insert_csv_from_path"] = (a0, a1, a2, a3) => (_duckdb_web_insert_csv_from_path = Module["_duckdb_web_insert_csv_from_path"] = wasmExports["duckdb_web_insert_csv_from_path"])(a0, a1, a2, a3);
          var _duckdb_web_insert_json_from_path = Module["_duckdb_web_insert_json_from_path"] = (a0, a1, a2, a3) => (_duckdb_web_insert_json_from_path = Module["_duckdb_web_insert_json_from_path"] = wasmExports["duckdb_web_insert_json_from_path"])(a0, a1, a2, a3);
          var _duckdb_web_fts_init = Module["_duckdb_web_fts_init"] = (a0) => (_duckdb_web_fts_init = Module["_duckdb_web_fts_init"] = wasmExports["duckdb_web_fts_init"])(a0);
          var _duckdb_web_parquet_init = Module["_duckdb_web_parquet_init"] = (a0) => (_duckdb_web_parquet_init = Module["_duckdb_web_parquet_init"] = wasmExports["duckdb_web_parquet_init"])(a0);
          var _freeaddrinfo = Module["_freeaddrinfo"] = (a0) => (_freeaddrinfo = Module["_freeaddrinfo"] = wasmExports["freeaddrinfo"])(a0);
          var _freeifaddrs = Module["_freeifaddrs"] = (a0) => (_freeifaddrs = Module["_freeifaddrs"] = wasmExports["freeifaddrs"])(a0);
          var _freelocale = Module["_freelocale"] = (a0) => (_freelocale = Module["_freelocale"] = wasmExports["freelocale"])(a0);
          var _malloc_trim = Module["_malloc_trim"] = (a0) => (_malloc_trim = Module["_malloc_trim"] = wasmExports["malloc_trim"])(a0);
          var _malloc_usable_size = Module["_malloc_usable_size"] = (a0) => (_malloc_usable_size = Module["_malloc_usable_size"] = wasmExports["malloc_usable_size"])(a0);
          var _malloc_footprint = Module["_malloc_footprint"] = () => (_malloc_footprint = Module["_malloc_footprint"] = wasmExports["malloc_footprint"])();
          var _malloc_max_footprint = Module["_malloc_max_footprint"] = () => (_malloc_max_footprint = Module["_malloc_max_footprint"] = wasmExports["malloc_max_footprint"])();
          var _malloc_footprint_limit = Module["_malloc_footprint_limit"] = () => (_malloc_footprint_limit = Module["_malloc_footprint_limit"] = wasmExports["malloc_footprint_limit"])();
          var _malloc_set_footprint_limit = Module["_malloc_set_footprint_limit"] = (a0) => (_malloc_set_footprint_limit = Module["_malloc_set_footprint_limit"] = wasmExports["malloc_set_footprint_limit"])(a0);
          var stackSave = () => (stackSave = wasmExports["stackSave"])();
          var stackRestore = (a0) => (stackRestore = wasmExports["stackRestore"])(a0);
          var stackAlloc = (a0) => (stackAlloc = wasmExports["stackAlloc"])(a0);
          var __ZTINSt3__220__shared_ptr_emplaceIN6duckdb3web2io23FileStatisticsCollectorENS_9allocatorIS4_EEEE = Module["__ZTINSt3__220__shared_ptr_emplaceIN6duckdb3web2io23FileStatisticsCollectorENS_9allocatorIS4_EEEE"] = 1755e3;
          var __ZTSN6duckdb15CreateIndexInfoE = Module["__ZTSN6duckdb15CreateIndexInfoE"] = 457e3;
          var __ZTIN6duckdb18RepeatFunctionDataE = Module["__ZTIN6duckdb18RepeatFunctionDataE"] = 1961e3;
          var __ZTIN6duckdb21ParallelCSVLocalStateE = Module["__ZTIN6duckdb21ParallelCSVLocalStateE"] = 1962e3;
          var __ZTVN6duckdb17IEJoinGlobalStateE = Module["__ZTVN6duckdb17IEJoinGlobalStateE"] = 1991e3;
          var __ZTVN6duckdb19OrderLocalSinkStateE = Module["__ZTVN6duckdb19OrderLocalSinkStateE"] = 1992e3;
          var __ZTVN6duckdb17InsertSourceStateE = Module["__ZTVN6duckdb17InsertSourceStateE"] = 1995e3;
          var __ZTINSt3__210__function6__funcIZN14duckdb_httplib6detail21write_content_chunkedIZNS2_10ClientImpl27write_content_with_providerERNS2_6StreamERKNS2_7RequestERNS2_5ErrorEEUlvE_NS3_10compressorEEEbS7_RKNS_8functionIFbmmRNS2_8DataSinkEEEERKT_RT0_SC_EUlvE_NS_9allocatorISR_EEFvvEEE = Module["__ZTINSt3__210__function6__funcIZN14duckdb_httplib6detail21write_content_chunkedIZNS2_10ClientImpl27write_content_with_providerERNS2_6StreamERKNS2_7RequestERNS2_5ErrorEEUlvE_NS3_10compressorEEEbS7_RKNS_8functionIFbmmRNS2_8DataSinkEEEERKT_RT0_SC_EUlvE_NS_9allocatorISR_EEFvvEEE"] = 2003e3;
          var __ZTINSt3__220__shared_ptr_pointerIPN6duckdb18PipelineFinishTaskENS_14default_deleteIS2_EENS_9allocatorIS2_EEEE = Module["__ZTINSt3__220__shared_ptr_pointerIPN6duckdb18PipelineFinishTaskENS_14default_deleteIS2_EENS_9allocatorIS2_EEEE"] = 2011e3;
          var __ZTIN6duckdb17PatasAnalyzeStateIdEE = Module["__ZTIN6duckdb17PatasAnalyzeStateIdEE"] = 2014e3;
          var __ZTIN6duckdb18LogicalCreateTableE = Module["__ZTIN6duckdb18LogicalCreateTableE"] = 2016e3;
          var __ZTVN6duckdb21ParquetReadLocalStateE = Module["__ZTVN6duckdb21ParquetReadLocalStateE"] = 2035e3;
          var __ZTIN6duckdb21TemplatedColumnReaderINS_9hugeint_tENS_29DecimalParquetValueConversionIS1_Lb1EEEEE = Module["__ZTIN6duckdb21TemplatedColumnReaderINS_9hugeint_tENS_29DecimalParquetValueConversionIS1_Lb1EEEEE"] = 2039e3;
          var __ZTIN6duckdb21TemplatedColumnReaderIbNS_29BooleanParquetValueConversionEEE = Module["__ZTIN6duckdb21TemplatedColumnReaderIbNS_29BooleanParquetValueConversionEEE"] = 204e4;
          var __ZTIN6duckdb21TemplatedColumnReaderIfNS_31TemplatedParquetValueConversionIfEEEE = Module["__ZTIN6duckdb21TemplatedColumnReaderIfNS_31TemplatedParquetValueConversionIfEEEE"] = 2041e3;
          var __ZTIN6duckdb21TemplatedColumnReaderINS_6date_tENS_30CallbackParquetValueConversionIiS1_XadL_ZNS_16ParquetIntToDateERKiEEEEEE = Module["__ZTIN6duckdb21TemplatedColumnReaderINS_6date_tENS_30CallbackParquetValueConversionIiS1_XadL_ZNS_16ParquetIntToDateERKiEEEEEE"] = 2042e3;
          var __ZTIN6duckdb21TemplatedColumnReaderIxNS_31TemplatedParquetValueConversionIiEEEE = Module["__ZTIN6duckdb21TemplatedColumnReaderIxNS_31TemplatedParquetValueConversionIiEEEE"] = 2043e3;
          var __ZN11duckdb_zstd21ZSTDInternalConstants14ML_defaultNormE = Module["__ZN11duckdb_zstd21ZSTDInternalConstants14ML_defaultNormE"] = 125e4;
          var __ZTIN5arrow14TemporalScalarINS_17MonthIntervalTypeEEE = Module["__ZTIN5arrow14TemporalScalarINS_17MonthIntervalTypeEEE"] = 205e4;
          var __ZTVN5arrow14LargeListArrayE = Module["__ZTVN5arrow14LargeListArrayE"] = 2054e3;
          var __ZTSNSt3__220__shared_ptr_emplaceIN5arrow14LargeListArrayENS_9allocatorIS2_EEEE = Module["__ZTSNSt3__220__shared_ptr_emplaceIN5arrow14LargeListArrayENS_9allocatorIS2_EEEE"] = 1267e3;
          var __ZTIN5arrow20RunEndEncodedBuilderE = Module["__ZTIN5arrow20RunEndEncodedBuilderE"] = 2056e3;
          var __ZTIZN5arrow22ValueComparatorVisitor5VisitINS_9Int16TypeEEENS_6StatusERKT_EUlRKNS_5ArrayExS9_xE_ = Module["__ZTIZN5arrow22ValueComparatorVisitor5VisitINS_9Int16TypeEEENS_6StatusERKT_EUlRKNS_5ArrayExS9_xE_"] = 2057e3;
          var __ZTVN5arrow9FloatTypeE = Module["__ZTVN5arrow9FloatTypeE"] = 2076e3;
          var __ZTIN5arrow2io8internal29InputStreamConcurrencyWrapperINS0_21CompressedInputStreamEEE = Module["__ZTIN5arrow2io8internal29InputStreamConcurrencyWrapperINS0_21CompressedInputStreamEEE"] = 2081e3;
          var __ZTVZN5arrow7compute8internal22GetFunctionOptionsTypeINS0_11ModeOptionsEJNS_8internal18DataMemberPropertyIS3_xEENS5_IS3_bEENS5_IS3_jEEEEEPKNS0_19FunctionOptionsTypeEDpRKT0_E11OptionsType = Module["__ZTVZN5arrow7compute8internal22GetFunctionOptionsTypeINS0_11ModeOptionsEJNS_8internal18DataMemberPropertyIS3_xEENS5_IS3_bEENS5_IS3_jEEEEEPKNS0_19FunctionOptionsTypeEDpRKT0_E11OptionsType"] = 2099e3;
          var __ZN5arrow7compute19ReplaceSliceOptions9kTypeNameE = Module["__ZN5arrow7compute19ReplaceSliceOptions9kTypeNameE"] = 1374e3;
          var __ZTIN5arrow7compute11JoinOptionsE = Module["__ZTIN5arrow7compute11JoinOptionsE"] = 21e5;
          var __ZTVN5arrow7compute14SelectKOptionsE = Module["__ZTVN5arrow7compute14SelectKOptionsE"] = 2103e3;
          var __ZGVZN5arrow7compute8internal22GetFunctionOptionsTypeINS0_19RunEndEncodeOptionsEJNS_8internal18DataMemberPropertyIS3_NSt3__210shared_ptrINS_8DataTypeEEEEEEEEPKNS0_19FunctionOptionsTypeEDpRKT0_E8instance = Module["__ZGVZN5arrow7compute8internal22GetFunctionOptionsTypeINS0_19RunEndEncodeOptionsEJNS_8internal18DataMemberPropertyIS3_NSt3__210shared_ptrINS_8DataTypeEEEEEEEEPKNS0_19FunctionOptionsTypeEDpRKT0_E8instance"] = 2166e3;
          var __ZTSN5arrow7compute19RunEndEncodeOptionsE = Module["__ZTSN5arrow7compute19RunEndEncodeOptionsE"] = 1382e3;
          var __ZTVN5arrow7compute5match16PrimitiveMatcherE = Module["__ZTVN5arrow7compute5match16PrimitiveMatcherE"] = 2106e3;
          var __ZTVN5arrow8internal6FnOnceIFvRKNS_10FutureImplEEE6FnImplINS_6FutureINSt3__210shared_ptrINS_6BufferEEEE21WrapResultyOnComplete8CallbackIZNS0_8Executor10DoTransferISC_SD_NS_6ResultISC_EEEENS8_IT_EESL_bEUlRKSJ_E_EEEE = Module["__ZTVN5arrow8internal6FnOnceIFvRKNS_10FutureImplEEE6FnImplINS_6FutureINSt3__210shared_ptrINS_6BufferEEEE21WrapResultyOnComplete8CallbackIZNS0_8Executor10DoTransferISC_SD_NS_6ResultISC_EEEENS8_IT_EESL_bEUlRKSJ_E_EEEE"] = 2112e3;
          var __ZTINSt3__214codecvt_bynameIwc11__mbstate_tEE = Module["__ZTINSt3__214codecvt_bynameIwc11__mbstate_tEE"] = 2124e3;
          var __ZTVNSt3__23pmr26synchronized_pool_resourceE = Module["__ZTVNSt3__23pmr26synchronized_pool_resourceE"] = 2125e3;
          var __ZTVSt9type_info = Module["__ZTVSt9type_info"] = 2134e3;
          function applySignatureConversions(wasmExports2) {
            wasmExports2 = Object.assign({}, wasmExports2);
            var makeWrapper_pppp = (f) => (a0, a1, a2) => f(a0, a1, a2) >>> 0;
            var makeWrapper_pp = (f) => (a0) => f(a0) >>> 0;
            var makeWrapper_p = (f) => () => f() >>> 0;
            var makeWrapper_ppp = (f) => (a0, a1) => f(a0, a1) >>> 0;
            var makeWrapper_pP = (f) => (a0) => f(a0) >>> 0;
            wasmExports2["memcpy"] = makeWrapper_pppp(wasmExports2["memcpy"]);
            wasmExports2["malloc"] = makeWrapper_pp(wasmExports2["malloc"]);
            wasmExports2["__errno_location"] = makeWrapper_p(wasmExports2["__errno_location"]);
            wasmExports2["pthread_self"] = makeWrapper_p(wasmExports2["pthread_self"]);
            wasmExports2["__getTypeName"] = makeWrapper_pp(wasmExports2["__getTypeName"]);
            wasmExports2["emscripten_builtin_malloc"] = makeWrapper_pp(wasmExports2["emscripten_builtin_malloc"]);
            wasmExports2["emscripten_stack_get_base"] = makeWrapper_p(wasmExports2["emscripten_stack_get_base"]);
            wasmExports2["emscripten_stack_get_end"] = makeWrapper_p(wasmExports2["emscripten_stack_get_end"]);
            wasmExports2["emscripten_builtin_memalign"] = makeWrapper_ppp(wasmExports2["emscripten_builtin_memalign"]);
            wasmExports2["emscripten_stack_get_current"] = makeWrapper_p(wasmExports2["emscripten_stack_get_current"]);
            wasmExports2["emscripten_main_runtime_thread_id"] = makeWrapper_p(wasmExports2["emscripten_main_runtime_thread_id"]);
            wasmExports2["sbrk"] = makeWrapper_pP(wasmExports2["sbrk"]);
            wasmExports2["memalign"] = makeWrapper_ppp(wasmExports2["memalign"]);
            wasmExports2["stackSave"] = makeWrapper_p(wasmExports2["stackSave"]);
            wasmExports2["stackAlloc"] = makeWrapper_pp(wasmExports2["stackAlloc"]);
            return wasmExports2;
          }
          Module["stackAlloc"] = stackAlloc;
          Module["stackSave"] = stackSave;
          Module["stackRestore"] = stackRestore;
          Module["ccall"] = ccall;
          var calledRun;
          dependenciesFulfilled = function runCaller() {
            if (!calledRun)
              run();
            if (!calledRun)
              dependenciesFulfilled = runCaller;
          };
          function callMain(args2 = []) {
            var entryFunction = resolveGlobalSymbol("main").sym;
            if (!entryFunction)
              return;
            args2.unshift(thisProgram);
            var argc = args2.length;
            var argv = stackAlloc((argc + 1) * 4);
            var argv_ptr = argv;
            args2.forEach((arg) => {
              HEAPU32[argv_ptr >>> 2 >>> 0] = stringToUTF8OnStack(arg);
              argv_ptr += 4;
            });
            HEAPU32[argv_ptr >>> 2 >>> 0] = 0;
            try {
              var ret = entryFunction(argc, argv);
              exitJS(ret, true);
              return ret;
            } catch (e) {
              return handleException(e);
            }
          }
          function run(args2 = arguments_) {
            if (runDependencies > 0) {
              return;
            }
            preRun();
            if (runDependencies > 0) {
              return;
            }
            function doRun() {
              if (calledRun)
                return;
              calledRun = true;
              Module["calledRun"] = true;
              if (ABORT)
                return;
              initRuntime();
              preMain();
              readyPromiseResolve(Module);
              if (Module["onRuntimeInitialized"])
                Module["onRuntimeInitialized"]();
              if (shouldRunNow)
                callMain(args2);
              postRun();
            }
            if (Module["setStatus"]) {
              Module["setStatus"]("Running...");
              setTimeout(function() {
                setTimeout(function() {
                  Module["setStatus"]("");
                }, 1);
                doRun();
              }, 1);
            } else {
              doRun();
            }
          }
          if (Module["preInit"]) {
            if (typeof Module["preInit"] == "function")
              Module["preInit"] = [Module["preInit"]];
            while (Module["preInit"].length > 0) {
              Module["preInit"].pop()();
            }
          }
          var shouldRunNow = true;
          if (Module["noInitialRun"])
            shouldRunNow = false;
          run();
          return moduleArg.ready;
        };
      })();
      if (typeof exports === "object" && typeof module === "object")
        module.exports = DuckDB;
      else if (typeof define === "function" && define["amd"])
        define([], () => DuckDB);
    }
  });

  // ../../node_modules/web-worker/cjs/browser.js
  var require_browser2 = __commonJS({
    "../../node_modules/web-worker/cjs/browser.js"(exports2, module2) {
      module2.exports = Worker;
    }
  });

  // ../../node_modules/tslib/tslib.es6.mjs
  function __rest(s2, e) {
    var t = {};
    for (var p in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0)
        t[p] = s2[p];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
        if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2]))
          t[p[i2]] = s2[p[i2]];
      }
    return t;
  }
  function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }
  function __values(o) {
    var s2 = typeof Symbol === "function" && Symbol.iterator, m = s2 && o[s2], i2 = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i2 >= o.length)
            o = void 0;
          return { value: o && o[i2++], done: !o };
        }
      };
    throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
  }
  function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i2, q = [];
    return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
      return this;
    }, i2;
    function verb(n) {
      if (g[n])
        i2[n] = function(v) {
          return new Promise(function(a, b) {
            q.push([n, v, a, b]) > 1 || resume(n, v);
          });
        };
    }
    function resume(n, v) {
      try {
        step(g[n](v));
      } catch (e) {
        settle(q[0][3], e);
      }
    }
    function step(r) {
      r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
      resume("next", value);
    }
    function reject(value) {
      resume("throw", value);
    }
    function settle(f, v) {
      if (f(v), q.shift(), q.length)
        resume(q[0][0], q[0][1]);
    }
  }
  function __asyncDelegator(o) {
    var i2, p;
    return i2 = {}, verb("next"), verb("throw", function(e) {
      throw e;
    }), verb("return"), i2[Symbol.iterator] = function() {
      return this;
    }, i2;
    function verb(n, f) {
      i2[n] = o[n] ? function(v) {
        return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
      } : f;
    }
  }
  function __asyncValues(o) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i2;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
      return this;
    }, i2);
    function verb(n) {
      i2[n] = o[n] && function(v) {
        return new Promise(function(resolve, reject) {
          v = o[n](v), settle(resolve, reject, v.done, v.value);
        });
      };
    }
    function settle(resolve, reject, d, v) {
      Promise.resolve(v).then(function(v2) {
        resolve({ value: v2, done: d });
      }, reject);
    }
  }

  // ../../node_modules/apache-arrow/util/buffer.mjs
  var buffer_exports = {};
  __export(buffer_exports, {
    compareArrayLike: () => compareArrayLike,
    joinUint8Arrays: () => joinUint8Arrays,
    memcpy: () => memcpy,
    rebaseValueOffsets: () => rebaseValueOffsets,
    toArrayBufferView: () => toArrayBufferView,
    toArrayBufferViewAsyncIterator: () => toArrayBufferViewAsyncIterator,
    toArrayBufferViewIterator: () => toArrayBufferViewIterator,
    toBigInt64Array: () => toBigInt64Array,
    toBigUint64Array: () => toBigUint64Array,
    toFloat32Array: () => toFloat32Array,
    toFloat32ArrayAsyncIterator: () => toFloat32ArrayAsyncIterator,
    toFloat32ArrayIterator: () => toFloat32ArrayIterator,
    toFloat64Array: () => toFloat64Array,
    toFloat64ArrayAsyncIterator: () => toFloat64ArrayAsyncIterator,
    toFloat64ArrayIterator: () => toFloat64ArrayIterator,
    toInt16Array: () => toInt16Array,
    toInt16ArrayAsyncIterator: () => toInt16ArrayAsyncIterator,
    toInt16ArrayIterator: () => toInt16ArrayIterator,
    toInt32Array: () => toInt32Array,
    toInt32ArrayAsyncIterator: () => toInt32ArrayAsyncIterator,
    toInt32ArrayIterator: () => toInt32ArrayIterator,
    toInt8Array: () => toInt8Array,
    toInt8ArrayAsyncIterator: () => toInt8ArrayAsyncIterator,
    toInt8ArrayIterator: () => toInt8ArrayIterator,
    toUint16Array: () => toUint16Array,
    toUint16ArrayAsyncIterator: () => toUint16ArrayAsyncIterator,
    toUint16ArrayIterator: () => toUint16ArrayIterator,
    toUint32Array: () => toUint32Array,
    toUint32ArrayAsyncIterator: () => toUint32ArrayAsyncIterator,
    toUint32ArrayIterator: () => toUint32ArrayIterator,
    toUint8Array: () => toUint8Array,
    toUint8ArrayAsyncIterator: () => toUint8ArrayAsyncIterator,
    toUint8ArrayIterator: () => toUint8ArrayIterator,
    toUint8ClampedArray: () => toUint8ClampedArray,
    toUint8ClampedArrayAsyncIterator: () => toUint8ClampedArrayAsyncIterator,
    toUint8ClampedArrayIterator: () => toUint8ClampedArrayIterator
  });

  // ../../node_modules/apache-arrow/util/utf8.mjs
  var decoder = new TextDecoder("utf-8");
  var decodeUtf8 = (buffer) => decoder.decode(buffer);
  var encoder = new TextEncoder();
  var encodeUtf8 = (value) => encoder.encode(value);

  // ../../node_modules/apache-arrow/util/compat.mjs
  var isNumber = (x) => typeof x === "number";
  var isBoolean = (x) => typeof x === "boolean";
  var isFunction = (x) => typeof x === "function";
  var isObject = (x) => x != null && Object(x) === x;
  var isPromise = (x) => {
    return isObject(x) && isFunction(x.then);
  };
  var isIterable = (x) => {
    return isObject(x) && isFunction(x[Symbol.iterator]);
  };
  var isAsyncIterable = (x) => {
    return isObject(x) && isFunction(x[Symbol.asyncIterator]);
  };
  var isArrowJSON = (x) => {
    return isObject(x) && isObject(x["schema"]);
  };
  var isIteratorResult = (x) => {
    return isObject(x) && "done" in x && "value" in x;
  };
  var isFileHandle = (x) => {
    return isObject(x) && isFunction(x["stat"]) && isNumber(x["fd"]);
  };
  var isFetchResponse = (x) => {
    return isObject(x) && isReadableDOMStream(x["body"]);
  };
  var isReadableInterop = (x) => "_getDOMStream" in x && "_getNodeStream" in x;
  var isWritableDOMStream = (x) => {
    return isObject(x) && isFunction(x["abort"]) && isFunction(x["getWriter"]) && !isReadableInterop(x);
  };
  var isReadableDOMStream = (x) => {
    return isObject(x) && isFunction(x["cancel"]) && isFunction(x["getReader"]) && !isReadableInterop(x);
  };
  var isWritableNodeStream = (x) => {
    return isObject(x) && isFunction(x["end"]) && isFunction(x["write"]) && isBoolean(x["writable"]) && !isReadableInterop(x);
  };
  var isReadableNodeStream = (x) => {
    return isObject(x) && isFunction(x["read"]) && isFunction(x["pipe"]) && isBoolean(x["readable"]) && !isReadableInterop(x);
  };
  var isFlatbuffersByteBuffer = (x) => {
    return isObject(x) && isFunction(x["clear"]) && isFunction(x["bytes"]) && isFunction(x["position"]) && isFunction(x["setPosition"]) && isFunction(x["capacity"]) && isFunction(x["getBufferIdentifier"]) && isFunction(x["createLong"]);
  };

  // ../../node_modules/apache-arrow/util/buffer.mjs
  var SharedArrayBuf = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : ArrayBuffer;
  function collapseContiguousByteRanges(chunks) {
    const result = chunks[0] ? [chunks[0]] : [];
    let xOffset, yOffset, xLen, yLen;
    for (let x, y, i2 = 0, j = 0, n = chunks.length; ++i2 < n; ) {
      x = result[j];
      y = chunks[i2];
      if (!x || !y || x.buffer !== y.buffer || y.byteOffset < x.byteOffset) {
        y && (result[++j] = y);
        continue;
      }
      ({ byteOffset: xOffset, byteLength: xLen } = x);
      ({ byteOffset: yOffset, byteLength: yLen } = y);
      if (xOffset + xLen < yOffset || yOffset + yLen < xOffset) {
        y && (result[++j] = y);
        continue;
      }
      result[j] = new Uint8Array(x.buffer, xOffset, yOffset - xOffset + yLen);
    }
    return result;
  }
  function memcpy(target, source, targetByteOffset = 0, sourceByteLength = source.byteLength) {
    const targetByteLength = target.byteLength;
    const dst = new Uint8Array(target.buffer, target.byteOffset, targetByteLength);
    const src = new Uint8Array(source.buffer, source.byteOffset, Math.min(sourceByteLength, targetByteLength));
    dst.set(src, targetByteOffset);
    return target;
  }
  function joinUint8Arrays(chunks, size) {
    const result = collapseContiguousByteRanges(chunks);
    const byteLength = result.reduce((x, b) => x + b.byteLength, 0);
    let source, sliced, buffer;
    let offset = 0, index = -1;
    const length = Math.min(size || Number.POSITIVE_INFINITY, byteLength);
    for (const n = result.length; ++index < n; ) {
      source = result[index];
      sliced = source.subarray(0, Math.min(source.length, length - offset));
      if (length <= offset + sliced.length) {
        if (sliced.length < source.length) {
          result[index] = source.subarray(sliced.length);
        } else if (sliced.length === source.length) {
          index++;
        }
        buffer ? memcpy(buffer, sliced, offset) : buffer = sliced;
        break;
      }
      memcpy(buffer || (buffer = new Uint8Array(length)), sliced, offset);
      offset += sliced.length;
    }
    return [buffer || new Uint8Array(0), result.slice(index), byteLength - (buffer ? buffer.byteLength : 0)];
  }
  function toArrayBufferView(ArrayBufferViewCtor, input) {
    let value = isIteratorResult(input) ? input.value : input;
    if (value instanceof ArrayBufferViewCtor) {
      if (ArrayBufferViewCtor === Uint8Array) {
        return new ArrayBufferViewCtor(value.buffer, value.byteOffset, value.byteLength);
      }
      return value;
    }
    if (!value) {
      return new ArrayBufferViewCtor(0);
    }
    if (typeof value === "string") {
      value = encodeUtf8(value);
    }
    if (value instanceof ArrayBuffer) {
      return new ArrayBufferViewCtor(value);
    }
    if (value instanceof SharedArrayBuf) {
      return new ArrayBufferViewCtor(value);
    }
    if (isFlatbuffersByteBuffer(value)) {
      return toArrayBufferView(ArrayBufferViewCtor, value.bytes());
    }
    return !ArrayBuffer.isView(value) ? ArrayBufferViewCtor.from(value) : value.byteLength <= 0 ? new ArrayBufferViewCtor(0) : new ArrayBufferViewCtor(value.buffer, value.byteOffset, value.byteLength / ArrayBufferViewCtor.BYTES_PER_ELEMENT);
  }
  var toInt8Array = (input) => toArrayBufferView(Int8Array, input);
  var toInt16Array = (input) => toArrayBufferView(Int16Array, input);
  var toInt32Array = (input) => toArrayBufferView(Int32Array, input);
  var toBigInt64Array = (input) => toArrayBufferView(BigInt64Array, input);
  var toUint8Array = (input) => toArrayBufferView(Uint8Array, input);
  var toUint16Array = (input) => toArrayBufferView(Uint16Array, input);
  var toUint32Array = (input) => toArrayBufferView(Uint32Array, input);
  var toBigUint64Array = (input) => toArrayBufferView(BigUint64Array, input);
  var toFloat32Array = (input) => toArrayBufferView(Float32Array, input);
  var toFloat64Array = (input) => toArrayBufferView(Float64Array, input);
  var toUint8ClampedArray = (input) => toArrayBufferView(Uint8ClampedArray, input);
  var pump = (iterator) => {
    iterator.next();
    return iterator;
  };
  function* toArrayBufferViewIterator(ArrayCtor, source) {
    const wrap = function* (x) {
      yield x;
    };
    const buffers = typeof source === "string" ? wrap(source) : ArrayBuffer.isView(source) ? wrap(source) : source instanceof ArrayBuffer ? wrap(source) : source instanceof SharedArrayBuf ? wrap(source) : !isIterable(source) ? wrap(source) : source;
    yield* pump(function* (it2) {
      let r = null;
      do {
        r = it2.next(yield toArrayBufferView(ArrayCtor, r));
      } while (!r.done);
    }(buffers[Symbol.iterator]()));
    return new ArrayCtor();
  }
  var toInt8ArrayIterator = (input) => toArrayBufferViewIterator(Int8Array, input);
  var toInt16ArrayIterator = (input) => toArrayBufferViewIterator(Int16Array, input);
  var toInt32ArrayIterator = (input) => toArrayBufferViewIterator(Int32Array, input);
  var toUint8ArrayIterator = (input) => toArrayBufferViewIterator(Uint8Array, input);
  var toUint16ArrayIterator = (input) => toArrayBufferViewIterator(Uint16Array, input);
  var toUint32ArrayIterator = (input) => toArrayBufferViewIterator(Uint32Array, input);
  var toFloat32ArrayIterator = (input) => toArrayBufferViewIterator(Float32Array, input);
  var toFloat64ArrayIterator = (input) => toArrayBufferViewIterator(Float64Array, input);
  var toUint8ClampedArrayIterator = (input) => toArrayBufferViewIterator(Uint8ClampedArray, input);
  function toArrayBufferViewAsyncIterator(ArrayCtor, source) {
    return __asyncGenerator(this, arguments, function* toArrayBufferViewAsyncIterator_1() {
      if (isPromise(source)) {
        return yield __await(yield __await(yield* __asyncDelegator(__asyncValues(toArrayBufferViewAsyncIterator(ArrayCtor, yield __await(source))))));
      }
      const wrap = function(x) {
        return __asyncGenerator(this, arguments, function* () {
          yield yield __await(yield __await(x));
        });
      };
      const emit = function(source2) {
        return __asyncGenerator(this, arguments, function* () {
          yield __await(yield* __asyncDelegator(__asyncValues(pump(function* (it2) {
            let r = null;
            do {
              r = it2.next(yield r === null || r === void 0 ? void 0 : r.value);
            } while (!r.done);
          }(source2[Symbol.iterator]())))));
        });
      };
      const buffers = typeof source === "string" ? wrap(source) : ArrayBuffer.isView(source) ? wrap(source) : source instanceof ArrayBuffer ? wrap(source) : source instanceof SharedArrayBuf ? wrap(source) : isIterable(source) ? emit(source) : !isAsyncIterable(source) ? wrap(source) : source;
      yield __await(
        // otherwise if AsyncIterable, use it
        yield* __asyncDelegator(__asyncValues(pump(function(it2) {
          return __asyncGenerator(this, arguments, function* () {
            let r = null;
            do {
              r = yield __await(it2.next(yield yield __await(toArrayBufferView(ArrayCtor, r))));
            } while (!r.done);
          });
        }(buffers[Symbol.asyncIterator]()))))
      );
      return yield __await(new ArrayCtor());
    });
  }
  var toInt8ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Int8Array, input);
  var toInt16ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Int16Array, input);
  var toInt32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Int32Array, input);
  var toUint8ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint8Array, input);
  var toUint16ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint16Array, input);
  var toUint32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint32Array, input);
  var toFloat32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Float32Array, input);
  var toFloat64ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Float64Array, input);
  var toUint8ClampedArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint8ClampedArray, input);
  function rebaseValueOffsets(offset, length, valueOffsets) {
    if (offset !== 0) {
      valueOffsets = valueOffsets.slice(0, length);
      for (let i2 = -1, n = valueOffsets.length; ++i2 < n; ) {
        valueOffsets[i2] += offset;
      }
    }
    return valueOffsets.subarray(0, length);
  }
  function compareArrayLike(a, b) {
    let i2 = 0;
    const n = a.length;
    if (n !== b.length) {
      return false;
    }
    if (n > 0) {
      do {
        if (a[i2] !== b[i2]) {
          return false;
        }
      } while (++i2 < n);
    }
    return true;
  }

  // ../../node_modules/apache-arrow/io/adapters.mjs
  var adapters_default = {
    fromIterable(source) {
      return pump2(fromIterable(source));
    },
    fromAsyncIterable(source) {
      return pump2(fromAsyncIterable(source));
    },
    fromDOMStream(source) {
      return pump2(fromDOMStream(source));
    },
    fromNodeStream(stream) {
      return pump2(fromNodeStream(stream));
    },
    // @ts-ignore
    toDOMStream(source, options) {
      throw new Error(`"toDOMStream" not available in this environment`);
    },
    // @ts-ignore
    toNodeStream(source, options) {
      throw new Error(`"toNodeStream" not available in this environment`);
    }
  };
  var pump2 = (iterator) => {
    iterator.next();
    return iterator;
  };
  function* fromIterable(source) {
    let done, threw = false;
    let buffers = [], buffer;
    let cmd, size, bufferLength = 0;
    function byteRange() {
      if (cmd === "peek") {
        return joinUint8Arrays(buffers, size)[0];
      }
      [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);
      return buffer;
    }
    ({ cmd, size } = yield null);
    const it2 = toUint8ArrayIterator(source)[Symbol.iterator]();
    try {
      do {
        ({ done, value: buffer } = Number.isNaN(size - bufferLength) ? it2.next() : it2.next(size - bufferLength));
        if (!done && buffer.byteLength > 0) {
          buffers.push(buffer);
          bufferLength += buffer.byteLength;
        }
        if (done || size <= bufferLength) {
          do {
            ({ cmd, size } = yield byteRange());
          } while (size < bufferLength);
        }
      } while (!done);
    } catch (e) {
      (threw = true) && typeof it2.throw === "function" && it2.throw(e);
    } finally {
      threw === false && typeof it2.return === "function" && it2.return(null);
    }
    return null;
  }
  function fromAsyncIterable(source) {
    return __asyncGenerator(this, arguments, function* fromAsyncIterable_1() {
      let done, threw = false;
      let buffers = [], buffer;
      let cmd, size, bufferLength = 0;
      function byteRange() {
        if (cmd === "peek") {
          return joinUint8Arrays(buffers, size)[0];
        }
        [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);
        return buffer;
      }
      ({ cmd, size } = yield yield __await(null));
      const it2 = toUint8ArrayAsyncIterator(source)[Symbol.asyncIterator]();
      try {
        do {
          ({ done, value: buffer } = Number.isNaN(size - bufferLength) ? yield __await(it2.next()) : yield __await(it2.next(size - bufferLength)));
          if (!done && buffer.byteLength > 0) {
            buffers.push(buffer);
            bufferLength += buffer.byteLength;
          }
          if (done || size <= bufferLength) {
            do {
              ({ cmd, size } = yield yield __await(byteRange()));
            } while (size < bufferLength);
          }
        } while (!done);
      } catch (e) {
        (threw = true) && typeof it2.throw === "function" && (yield __await(it2.throw(e)));
      } finally {
        threw === false && typeof it2.return === "function" && (yield __await(it2.return(new Uint8Array(0))));
      }
      return yield __await(null);
    });
  }
  function fromDOMStream(source) {
    return __asyncGenerator(this, arguments, function* fromDOMStream_1() {
      let done = false, threw = false;
      let buffers = [], buffer;
      let cmd, size, bufferLength = 0;
      function byteRange() {
        if (cmd === "peek") {
          return joinUint8Arrays(buffers, size)[0];
        }
        [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);
        return buffer;
      }
      ({ cmd, size } = yield yield __await(null));
      const it2 = new AdaptiveByteReader(source);
      try {
        do {
          ({ done, value: buffer } = Number.isNaN(size - bufferLength) ? yield __await(it2["read"]()) : yield __await(it2["read"](size - bufferLength)));
          if (!done && buffer.byteLength > 0) {
            buffers.push(toUint8Array(buffer));
            bufferLength += buffer.byteLength;
          }
          if (done || size <= bufferLength) {
            do {
              ({ cmd, size } = yield yield __await(byteRange()));
            } while (size < bufferLength);
          }
        } while (!done);
      } catch (e) {
        (threw = true) && (yield __await(it2["cancel"](e)));
      } finally {
        threw === false ? yield __await(it2["cancel"]()) : source["locked"] && it2.releaseLock();
      }
      return yield __await(null);
    });
  }
  var AdaptiveByteReader = class {
    constructor(source) {
      this.source = source;
      this.reader = null;
      this.reader = this.source["getReader"]();
      this.reader["closed"].catch(() => {
      });
    }
    get closed() {
      return this.reader ? this.reader["closed"].catch(() => {
      }) : Promise.resolve();
    }
    releaseLock() {
      if (this.reader) {
        this.reader.releaseLock();
      }
      this.reader = null;
    }
    cancel(reason) {
      return __awaiter(this, void 0, void 0, function* () {
        const { reader, source } = this;
        reader && (yield reader["cancel"](reason).catch(() => {
        }));
        source && (source["locked"] && this.releaseLock());
      });
    }
    read(size) {
      return __awaiter(this, void 0, void 0, function* () {
        if (size === 0) {
          return { done: this.reader == null, value: new Uint8Array(0) };
        }
        const result = yield this.reader.read();
        !result.done && (result.value = toUint8Array(result));
        return result;
      });
    }
  };
  var onEvent = (stream, event2) => {
    const handler = (_) => resolve([event2, _]);
    let resolve;
    return [event2, handler, new Promise((r) => (resolve = r) && stream["once"](event2, handler))];
  };
  function fromNodeStream(stream) {
    return __asyncGenerator(this, arguments, function* fromNodeStream_1() {
      const events = [];
      let event2 = "error";
      let done = false, err2 = null;
      let cmd, size, bufferLength = 0;
      let buffers = [], buffer;
      function byteRange() {
        if (cmd === "peek") {
          return joinUint8Arrays(buffers, size)[0];
        }
        [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);
        return buffer;
      }
      ({ cmd, size } = yield yield __await(null));
      if (stream["isTTY"]) {
        yield yield __await(new Uint8Array(0));
        return yield __await(null);
      }
      try {
        events[0] = onEvent(stream, "end");
        events[1] = onEvent(stream, "error");
        do {
          events[2] = onEvent(stream, "readable");
          [event2, err2] = yield __await(Promise.race(events.map((x) => x[2])));
          if (event2 === "error") {
            break;
          }
          if (!(done = event2 === "end")) {
            if (!Number.isFinite(size - bufferLength)) {
              buffer = toUint8Array(stream["read"]());
            } else {
              buffer = toUint8Array(stream["read"](size - bufferLength));
              if (buffer.byteLength < size - bufferLength) {
                buffer = toUint8Array(stream["read"]());
              }
            }
            if (buffer.byteLength > 0) {
              buffers.push(buffer);
              bufferLength += buffer.byteLength;
            }
          }
          if (done || size <= bufferLength) {
            do {
              ({ cmd, size } = yield yield __await(byteRange()));
            } while (size < bufferLength);
          }
        } while (!done);
      } finally {
        yield __await(cleanup(events, event2 === "error" ? err2 : null));
      }
      return yield __await(null);
      function cleanup(events2, err3) {
        buffer = buffers = null;
        return new Promise((resolve, reject) => {
          for (const [evt, fn] of events2) {
            stream["off"](evt, fn);
          }
          try {
            const destroy = stream["destroy"];
            destroy && destroy.call(stream, err3);
            err3 = void 0;
          } catch (e) {
            err3 = e || err3;
          } finally {
            err3 != null ? reject(err3) : resolve();
          }
        });
      }
    });
  }

  // ../../node_modules/apache-arrow/enum.mjs
  var MetadataVersion;
  (function(MetadataVersion3) {
    MetadataVersion3[MetadataVersion3["V1"] = 0] = "V1";
    MetadataVersion3[MetadataVersion3["V2"] = 1] = "V2";
    MetadataVersion3[MetadataVersion3["V3"] = 2] = "V3";
    MetadataVersion3[MetadataVersion3["V4"] = 3] = "V4";
    MetadataVersion3[MetadataVersion3["V5"] = 4] = "V5";
  })(MetadataVersion || (MetadataVersion = {}));
  var UnionMode;
  (function(UnionMode3) {
    UnionMode3[UnionMode3["Sparse"] = 0] = "Sparse";
    UnionMode3[UnionMode3["Dense"] = 1] = "Dense";
  })(UnionMode || (UnionMode = {}));
  var Precision;
  (function(Precision3) {
    Precision3[Precision3["HALF"] = 0] = "HALF";
    Precision3[Precision3["SINGLE"] = 1] = "SINGLE";
    Precision3[Precision3["DOUBLE"] = 2] = "DOUBLE";
  })(Precision || (Precision = {}));
  var DateUnit;
  (function(DateUnit3) {
    DateUnit3[DateUnit3["DAY"] = 0] = "DAY";
    DateUnit3[DateUnit3["MILLISECOND"] = 1] = "MILLISECOND";
  })(DateUnit || (DateUnit = {}));
  var TimeUnit;
  (function(TimeUnit3) {
    TimeUnit3[TimeUnit3["SECOND"] = 0] = "SECOND";
    TimeUnit3[TimeUnit3["MILLISECOND"] = 1] = "MILLISECOND";
    TimeUnit3[TimeUnit3["MICROSECOND"] = 2] = "MICROSECOND";
    TimeUnit3[TimeUnit3["NANOSECOND"] = 3] = "NANOSECOND";
  })(TimeUnit || (TimeUnit = {}));
  var IntervalUnit;
  (function(IntervalUnit3) {
    IntervalUnit3[IntervalUnit3["YEAR_MONTH"] = 0] = "YEAR_MONTH";
    IntervalUnit3[IntervalUnit3["DAY_TIME"] = 1] = "DAY_TIME";
    IntervalUnit3[IntervalUnit3["MONTH_DAY_NANO"] = 2] = "MONTH_DAY_NANO";
  })(IntervalUnit || (IntervalUnit = {}));
  var MessageHeader;
  (function(MessageHeader3) {
    MessageHeader3[MessageHeader3["NONE"] = 0] = "NONE";
    MessageHeader3[MessageHeader3["Schema"] = 1] = "Schema";
    MessageHeader3[MessageHeader3["DictionaryBatch"] = 2] = "DictionaryBatch";
    MessageHeader3[MessageHeader3["RecordBatch"] = 3] = "RecordBatch";
    MessageHeader3[MessageHeader3["Tensor"] = 4] = "Tensor";
    MessageHeader3[MessageHeader3["SparseTensor"] = 5] = "SparseTensor";
  })(MessageHeader || (MessageHeader = {}));
  var Type;
  (function(Type3) {
    Type3[Type3["NONE"] = 0] = "NONE";
    Type3[Type3["Null"] = 1] = "Null";
    Type3[Type3["Int"] = 2] = "Int";
    Type3[Type3["Float"] = 3] = "Float";
    Type3[Type3["Binary"] = 4] = "Binary";
    Type3[Type3["Utf8"] = 5] = "Utf8";
    Type3[Type3["Bool"] = 6] = "Bool";
    Type3[Type3["Decimal"] = 7] = "Decimal";
    Type3[Type3["Date"] = 8] = "Date";
    Type3[Type3["Time"] = 9] = "Time";
    Type3[Type3["Timestamp"] = 10] = "Timestamp";
    Type3[Type3["Interval"] = 11] = "Interval";
    Type3[Type3["List"] = 12] = "List";
    Type3[Type3["Struct"] = 13] = "Struct";
    Type3[Type3["Union"] = 14] = "Union";
    Type3[Type3["FixedSizeBinary"] = 15] = "FixedSizeBinary";
    Type3[Type3["FixedSizeList"] = 16] = "FixedSizeList";
    Type3[Type3["Map"] = 17] = "Map";
    Type3[Type3["Duration"] = 18] = "Duration";
    Type3[Type3["Dictionary"] = -1] = "Dictionary";
    Type3[Type3["Int8"] = -2] = "Int8";
    Type3[Type3["Int16"] = -3] = "Int16";
    Type3[Type3["Int32"] = -4] = "Int32";
    Type3[Type3["Int64"] = -5] = "Int64";
    Type3[Type3["Uint8"] = -6] = "Uint8";
    Type3[Type3["Uint16"] = -7] = "Uint16";
    Type3[Type3["Uint32"] = -8] = "Uint32";
    Type3[Type3["Uint64"] = -9] = "Uint64";
    Type3[Type3["Float16"] = -10] = "Float16";
    Type3[Type3["Float32"] = -11] = "Float32";
    Type3[Type3["Float64"] = -12] = "Float64";
    Type3[Type3["DateDay"] = -13] = "DateDay";
    Type3[Type3["DateMillisecond"] = -14] = "DateMillisecond";
    Type3[Type3["TimestampSecond"] = -15] = "TimestampSecond";
    Type3[Type3["TimestampMillisecond"] = -16] = "TimestampMillisecond";
    Type3[Type3["TimestampMicrosecond"] = -17] = "TimestampMicrosecond";
    Type3[Type3["TimestampNanosecond"] = -18] = "TimestampNanosecond";
    Type3[Type3["TimeSecond"] = -19] = "TimeSecond";
    Type3[Type3["TimeMillisecond"] = -20] = "TimeMillisecond";
    Type3[Type3["TimeMicrosecond"] = -21] = "TimeMicrosecond";
    Type3[Type3["TimeNanosecond"] = -22] = "TimeNanosecond";
    Type3[Type3["DenseUnion"] = -23] = "DenseUnion";
    Type3[Type3["SparseUnion"] = -24] = "SparseUnion";
    Type3[Type3["IntervalDayTime"] = -25] = "IntervalDayTime";
    Type3[Type3["IntervalYearMonth"] = -26] = "IntervalYearMonth";
    Type3[Type3["DurationSecond"] = -27] = "DurationSecond";
    Type3[Type3["DurationMillisecond"] = -28] = "DurationMillisecond";
    Type3[Type3["DurationMicrosecond"] = -29] = "DurationMicrosecond";
    Type3[Type3["DurationNanosecond"] = -30] = "DurationNanosecond";
  })(Type || (Type = {}));
  var BufferType;
  (function(BufferType2) {
    BufferType2[BufferType2["OFFSET"] = 0] = "OFFSET";
    BufferType2[BufferType2["DATA"] = 1] = "DATA";
    BufferType2[BufferType2["VALIDITY"] = 2] = "VALIDITY";
    BufferType2[BufferType2["TYPE"] = 3] = "TYPE";
  })(BufferType || (BufferType = {}));

  // ../../node_modules/apache-arrow/util/vector.mjs
  var vector_exports = {};
  __export(vector_exports, {
    clampIndex: () => clampIndex,
    clampRange: () => clampRange,
    createElementComparator: () => createElementComparator
  });

  // ../../node_modules/apache-arrow/util/pretty.mjs
  var pretty_exports = {};
  __export(pretty_exports, {
    valueToString: () => valueToString
  });
  var undf = void 0;
  function valueToString(x) {
    if (x === null) {
      return "null";
    }
    if (x === undf) {
      return "undefined";
    }
    switch (typeof x) {
      case "number":
        return `${x}`;
      case "bigint":
        return `${x}`;
      case "string":
        return `"${x}"`;
    }
    if (typeof x[Symbol.toPrimitive] === "function") {
      return x[Symbol.toPrimitive]("string");
    }
    if (ArrayBuffer.isView(x)) {
      if (x instanceof BigInt64Array || x instanceof BigUint64Array) {
        return `[${[...x].map((x2) => valueToString(x2))}]`;
      }
      return `[${x}]`;
    }
    return ArrayBuffer.isView(x) ? `[${x}]` : JSON.stringify(x, (_, y) => typeof y === "bigint" ? `${y}` : y);
  }

  // ../../node_modules/apache-arrow/util/bn.mjs
  var bn_exports = {};
  __export(bn_exports, {
    BN: () => BN,
    bigNumToBigInt: () => bigNumToBigInt,
    bigNumToString: () => bigNumToString,
    isArrowBigNumSymbol: () => isArrowBigNumSymbol
  });
  var isArrowBigNumSymbol = Symbol.for("isArrowBigNum");
  function BigNum(x, ...xs) {
    if (xs.length === 0) {
      return Object.setPrototypeOf(toArrayBufferView(this["TypedArray"], x), this.constructor.prototype);
    }
    return Object.setPrototypeOf(new this["TypedArray"](x, ...xs), this.constructor.prototype);
  }
  BigNum.prototype[isArrowBigNumSymbol] = true;
  BigNum.prototype.toJSON = function() {
    return `"${bigNumToString(this)}"`;
  };
  BigNum.prototype.valueOf = function() {
    return bigNumToNumber(this);
  };
  BigNum.prototype.toString = function() {
    return bigNumToString(this);
  };
  BigNum.prototype[Symbol.toPrimitive] = function(hint = "default") {
    switch (hint) {
      case "number":
        return bigNumToNumber(this);
      case "string":
        return bigNumToString(this);
      case "default":
        return bigNumToBigInt(this);
    }
    return bigNumToString(this);
  };
  function SignedBigNum(...args2) {
    return BigNum.apply(this, args2);
  }
  function UnsignedBigNum(...args2) {
    return BigNum.apply(this, args2);
  }
  function DecimalBigNum(...args2) {
    return BigNum.apply(this, args2);
  }
  Object.setPrototypeOf(SignedBigNum.prototype, Object.create(Int32Array.prototype));
  Object.setPrototypeOf(UnsignedBigNum.prototype, Object.create(Uint32Array.prototype));
  Object.setPrototypeOf(DecimalBigNum.prototype, Object.create(Uint32Array.prototype));
  Object.assign(SignedBigNum.prototype, BigNum.prototype, { "constructor": SignedBigNum, "signed": true, "TypedArray": Int32Array, "BigIntArray": BigInt64Array });
  Object.assign(UnsignedBigNum.prototype, BigNum.prototype, { "constructor": UnsignedBigNum, "signed": false, "TypedArray": Uint32Array, "BigIntArray": BigUint64Array });
  Object.assign(DecimalBigNum.prototype, BigNum.prototype, { "constructor": DecimalBigNum, "signed": true, "TypedArray": Uint32Array, "BigIntArray": BigUint64Array });
  function bigNumToNumber(bn) {
    const { buffer, byteOffset, length, "signed": signed } = bn;
    const words = new BigUint64Array(buffer, byteOffset, length);
    const negative = signed && words.at(-1) & BigInt(1) << BigInt(63);
    let number = negative ? BigInt(1) : BigInt(0);
    let i2 = BigInt(0);
    if (!negative) {
      for (const word of words) {
        number += word * (BigInt(1) << BigInt(32) * i2++);
      }
    } else {
      for (const word of words) {
        number += ~word * (BigInt(1) << BigInt(32) * i2++);
      }
      number *= BigInt(-1);
    }
    return number;
  }
  var bigNumToString = (a) => {
    if (a.byteLength === 8) {
      const bigIntArray = new a["BigIntArray"](a.buffer, a.byteOffset, 1);
      return `${bigIntArray[0]}`;
    }
    if (!a["signed"]) {
      return unsignedBigNumToString(a);
    }
    let array = new Uint16Array(a.buffer, a.byteOffset, a.byteLength / 2);
    const highOrderWord = new Int16Array([array.at(-1)])[0];
    if (highOrderWord >= 0) {
      return unsignedBigNumToString(a);
    }
    array = array.slice();
    let carry = 1;
    for (let i2 = 0; i2 < array.length; i2++) {
      const elem = array[i2];
      const updated = ~elem + carry;
      array[i2] = updated;
      carry &= elem === 0 ? 1 : 0;
    }
    const negated = unsignedBigNumToString(array);
    return `-${negated}`;
  };
  var bigNumToBigInt = (a) => {
    if (a.byteLength === 8) {
      const bigIntArray = new a["BigIntArray"](a.buffer, a.byteOffset, 1);
      return bigIntArray[0];
    } else {
      return bigNumToString(a);
    }
  };
  function unsignedBigNumToString(a) {
    let digits = "";
    const base64 = new Uint32Array(2);
    let base32 = new Uint16Array(a.buffer, a.byteOffset, a.byteLength / 2);
    const checks = new Uint32Array((base32 = new Uint16Array(base32).reverse()).buffer);
    let i2 = -1;
    const n = base32.length - 1;
    do {
      for (base64[0] = base32[i2 = 0]; i2 < n; ) {
        base32[i2++] = base64[1] = base64[0] / 10;
        base64[0] = (base64[0] - base64[1] * 10 << 16) + base32[i2];
      }
      base32[i2] = base64[1] = base64[0] / 10;
      base64[0] = base64[0] - base64[1] * 10;
      digits = `${base64[0]}${digits}`;
    } while (checks[0] || checks[1] || checks[2] || checks[3]);
    return digits !== null && digits !== void 0 ? digits : `0`;
  }
  var BN = class _BN {
    /** @nocollapse */
    static new(num, isSigned) {
      switch (isSigned) {
        case true:
          return new SignedBigNum(num);
        case false:
          return new UnsignedBigNum(num);
      }
      switch (num.constructor) {
        case Int8Array:
        case Int16Array:
        case Int32Array:
        case BigInt64Array:
          return new SignedBigNum(num);
      }
      if (num.byteLength === 16) {
        return new DecimalBigNum(num);
      }
      return new UnsignedBigNum(num);
    }
    /** @nocollapse */
    static signed(num) {
      return new SignedBigNum(num);
    }
    /** @nocollapse */
    static unsigned(num) {
      return new UnsignedBigNum(num);
    }
    /** @nocollapse */
    static decimal(num) {
      return new DecimalBigNum(num);
    }
    constructor(num, isSigned) {
      return _BN.new(num, isSigned);
    }
  };

  // ../../node_modules/apache-arrow/util/bigint.mjs
  function bigIntToNumber(number) {
    if (typeof number === "bigint" && (number < Number.MIN_SAFE_INTEGER || number > Number.MAX_SAFE_INTEGER)) {
      throw new TypeError(`${number} is not safe to convert to a number.`);
    }
    return Number(number);
  }

  // ../../node_modules/apache-arrow/type.mjs
  var _a;
  var _b;
  var _c;
  var _d;
  var _e;
  var _f;
  var _g;
  var _h;
  var _j;
  var _k;
  var _l;
  var _m;
  var _o;
  var _p;
  var _q;
  var _r;
  var _s;
  var _t;
  var _u;
  var _v;
  var DataType = class _DataType {
    /** @nocollapse */
    static isNull(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Null;
    }
    /** @nocollapse */
    static isInt(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Int;
    }
    /** @nocollapse */
    static isFloat(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Float;
    }
    /** @nocollapse */
    static isBinary(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Binary;
    }
    /** @nocollapse */
    static isUtf8(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Utf8;
    }
    /** @nocollapse */
    static isBool(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Bool;
    }
    /** @nocollapse */
    static isDecimal(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Decimal;
    }
    /** @nocollapse */
    static isDate(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Date;
    }
    /** @nocollapse */
    static isTime(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Time;
    }
    /** @nocollapse */
    static isTimestamp(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Timestamp;
    }
    /** @nocollapse */
    static isInterval(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Interval;
    }
    /** @nocollapse */
    static isDuration(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Duration;
    }
    /** @nocollapse */
    static isList(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.List;
    }
    /** @nocollapse */
    static isStruct(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Struct;
    }
    /** @nocollapse */
    static isUnion(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Union;
    }
    /** @nocollapse */
    static isFixedSizeBinary(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.FixedSizeBinary;
    }
    /** @nocollapse */
    static isFixedSizeList(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.FixedSizeList;
    }
    /** @nocollapse */
    static isMap(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Map;
    }
    /** @nocollapse */
    static isDictionary(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Dictionary;
    }
    /** @nocollapse */
    static isDenseUnion(x) {
      return _DataType.isUnion(x) && x.mode === UnionMode.Dense;
    }
    /** @nocollapse */
    static isSparseUnion(x) {
      return _DataType.isUnion(x) && x.mode === UnionMode.Sparse;
    }
    get typeId() {
      return Type.NONE;
    }
  };
  _a = Symbol.toStringTag;
  DataType[_a] = ((proto) => {
    proto.children = null;
    proto.ArrayType = Array;
    return proto[Symbol.toStringTag] = "DataType";
  })(DataType.prototype);
  var Null = class extends DataType {
    toString() {
      return `Null`;
    }
    get typeId() {
      return Type.Null;
    }
  };
  _b = Symbol.toStringTag;
  Null[_b] = ((proto) => proto[Symbol.toStringTag] = "Null")(Null.prototype);
  var Int_ = class extends DataType {
    constructor(isSigned, bitWidth) {
      super();
      this.isSigned = isSigned;
      this.bitWidth = bitWidth;
    }
    get typeId() {
      return Type.Int;
    }
    get ArrayType() {
      switch (this.bitWidth) {
        case 8:
          return this.isSigned ? Int8Array : Uint8Array;
        case 16:
          return this.isSigned ? Int16Array : Uint16Array;
        case 32:
          return this.isSigned ? Int32Array : Uint32Array;
        case 64:
          return this.isSigned ? BigInt64Array : BigUint64Array;
      }
      throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
    }
    toString() {
      return `${this.isSigned ? `I` : `Ui`}nt${this.bitWidth}`;
    }
  };
  _c = Symbol.toStringTag;
  Int_[_c] = ((proto) => {
    proto.isSigned = null;
    proto.bitWidth = null;
    return proto[Symbol.toStringTag] = "Int";
  })(Int_.prototype);
  var Int8 = class extends Int_ {
    constructor() {
      super(true, 8);
    }
    get ArrayType() {
      return Int8Array;
    }
  };
  var Int16 = class extends Int_ {
    constructor() {
      super(true, 16);
    }
    get ArrayType() {
      return Int16Array;
    }
  };
  var Int32 = class extends Int_ {
    constructor() {
      super(true, 32);
    }
    get ArrayType() {
      return Int32Array;
    }
  };
  var Int64 = class extends Int_ {
    constructor() {
      super(true, 64);
    }
    get ArrayType() {
      return BigInt64Array;
    }
  };
  var Uint8 = class extends Int_ {
    constructor() {
      super(false, 8);
    }
    get ArrayType() {
      return Uint8Array;
    }
  };
  var Uint16 = class extends Int_ {
    constructor() {
      super(false, 16);
    }
    get ArrayType() {
      return Uint16Array;
    }
  };
  var Uint32 = class extends Int_ {
    constructor() {
      super(false, 32);
    }
    get ArrayType() {
      return Uint32Array;
    }
  };
  var Uint64 = class extends Int_ {
    constructor() {
      super(false, 64);
    }
    get ArrayType() {
      return BigUint64Array;
    }
  };
  Object.defineProperty(Int8.prototype, "ArrayType", { value: Int8Array });
  Object.defineProperty(Int16.prototype, "ArrayType", { value: Int16Array });
  Object.defineProperty(Int32.prototype, "ArrayType", { value: Int32Array });
  Object.defineProperty(Int64.prototype, "ArrayType", { value: BigInt64Array });
  Object.defineProperty(Uint8.prototype, "ArrayType", { value: Uint8Array });
  Object.defineProperty(Uint16.prototype, "ArrayType", { value: Uint16Array });
  Object.defineProperty(Uint32.prototype, "ArrayType", { value: Uint32Array });
  Object.defineProperty(Uint64.prototype, "ArrayType", { value: BigUint64Array });
  var Float = class extends DataType {
    constructor(precision) {
      super();
      this.precision = precision;
    }
    get typeId() {
      return Type.Float;
    }
    get ArrayType() {
      switch (this.precision) {
        case Precision.HALF:
          return Uint16Array;
        case Precision.SINGLE:
          return Float32Array;
        case Precision.DOUBLE:
          return Float64Array;
      }
      throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
    }
    toString() {
      return `Float${this.precision << 5 || 16}`;
    }
  };
  _d = Symbol.toStringTag;
  Float[_d] = ((proto) => {
    proto.precision = null;
    return proto[Symbol.toStringTag] = "Float";
  })(Float.prototype);
  var Float16 = class extends Float {
    constructor() {
      super(Precision.HALF);
    }
  };
  var Float32 = class extends Float {
    constructor() {
      super(Precision.SINGLE);
    }
  };
  var Float64 = class extends Float {
    constructor() {
      super(Precision.DOUBLE);
    }
  };
  Object.defineProperty(Float16.prototype, "ArrayType", { value: Uint16Array });
  Object.defineProperty(Float32.prototype, "ArrayType", { value: Float32Array });
  Object.defineProperty(Float64.prototype, "ArrayType", { value: Float64Array });
  var Binary = class extends DataType {
    constructor() {
      super();
    }
    get typeId() {
      return Type.Binary;
    }
    toString() {
      return `Binary`;
    }
  };
  _e = Symbol.toStringTag;
  Binary[_e] = ((proto) => {
    proto.ArrayType = Uint8Array;
    return proto[Symbol.toStringTag] = "Binary";
  })(Binary.prototype);
  var Utf8 = class extends DataType {
    constructor() {
      super();
    }
    get typeId() {
      return Type.Utf8;
    }
    toString() {
      return `Utf8`;
    }
  };
  _f = Symbol.toStringTag;
  Utf8[_f] = ((proto) => {
    proto.ArrayType = Uint8Array;
    return proto[Symbol.toStringTag] = "Utf8";
  })(Utf8.prototype);
  var Bool = class extends DataType {
    constructor() {
      super();
    }
    get typeId() {
      return Type.Bool;
    }
    toString() {
      return `Bool`;
    }
  };
  _g = Symbol.toStringTag;
  Bool[_g] = ((proto) => {
    proto.ArrayType = Uint8Array;
    return proto[Symbol.toStringTag] = "Bool";
  })(Bool.prototype);
  var Decimal = class extends DataType {
    constructor(scale, precision, bitWidth = 128) {
      super();
      this.scale = scale;
      this.precision = precision;
      this.bitWidth = bitWidth;
    }
    get typeId() {
      return Type.Decimal;
    }
    toString() {
      return `Decimal[${this.precision}e${this.scale > 0 ? `+` : ``}${this.scale}]`;
    }
  };
  _h = Symbol.toStringTag;
  Decimal[_h] = ((proto) => {
    proto.scale = null;
    proto.precision = null;
    proto.ArrayType = Uint32Array;
    return proto[Symbol.toStringTag] = "Decimal";
  })(Decimal.prototype);
  var Date_ = class extends DataType {
    constructor(unit) {
      super();
      this.unit = unit;
    }
    get typeId() {
      return Type.Date;
    }
    toString() {
      return `Date${(this.unit + 1) * 32}<${DateUnit[this.unit]}>`;
    }
  };
  _j = Symbol.toStringTag;
  Date_[_j] = ((proto) => {
    proto.unit = null;
    proto.ArrayType = Int32Array;
    return proto[Symbol.toStringTag] = "Date";
  })(Date_.prototype);
  var DateDay = class extends Date_ {
    constructor() {
      super(DateUnit.DAY);
    }
  };
  var DateMillisecond = class extends Date_ {
    constructor() {
      super(DateUnit.MILLISECOND);
    }
  };
  var Time_ = class extends DataType {
    constructor(unit, bitWidth) {
      super();
      this.unit = unit;
      this.bitWidth = bitWidth;
    }
    get typeId() {
      return Type.Time;
    }
    toString() {
      return `Time${this.bitWidth}<${TimeUnit[this.unit]}>`;
    }
    get ArrayType() {
      switch (this.bitWidth) {
        case 32:
          return Int32Array;
        case 64:
          return BigInt64Array;
      }
      throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
    }
  };
  _k = Symbol.toStringTag;
  Time_[_k] = ((proto) => {
    proto.unit = null;
    proto.bitWidth = null;
    return proto[Symbol.toStringTag] = "Time";
  })(Time_.prototype);
  var Timestamp_ = class extends DataType {
    constructor(unit, timezone) {
      super();
      this.unit = unit;
      this.timezone = timezone;
    }
    get typeId() {
      return Type.Timestamp;
    }
    toString() {
      return `Timestamp<${TimeUnit[this.unit]}${this.timezone ? `, ${this.timezone}` : ``}>`;
    }
  };
  _l = Symbol.toStringTag;
  Timestamp_[_l] = ((proto) => {
    proto.unit = null;
    proto.timezone = null;
    proto.ArrayType = Int32Array;
    return proto[Symbol.toStringTag] = "Timestamp";
  })(Timestamp_.prototype);
  var TimestampSecond = class extends Timestamp_ {
    constructor(timezone) {
      super(TimeUnit.SECOND, timezone);
    }
  };
  var Interval_ = class extends DataType {
    constructor(unit) {
      super();
      this.unit = unit;
    }
    get typeId() {
      return Type.Interval;
    }
    toString() {
      return `Interval<${IntervalUnit[this.unit]}>`;
    }
  };
  _m = Symbol.toStringTag;
  Interval_[_m] = ((proto) => {
    proto.unit = null;
    proto.ArrayType = Int32Array;
    return proto[Symbol.toStringTag] = "Interval";
  })(Interval_.prototype);
  var Duration = class extends DataType {
    constructor(unit) {
      super();
      this.unit = unit;
    }
    get typeId() {
      return Type.Duration;
    }
    toString() {
      return `Duration<${TimeUnit[this.unit]}>`;
    }
  };
  _o = Symbol.toStringTag;
  Duration[_o] = ((proto) => {
    proto.unit = null;
    proto.ArrayType = BigInt64Array;
    return proto[Symbol.toStringTag] = "Duration";
  })(Duration.prototype);
  var List = class extends DataType {
    constructor(child) {
      super();
      this.children = [child];
    }
    get typeId() {
      return Type.List;
    }
    toString() {
      return `List<${this.valueType}>`;
    }
    get valueType() {
      return this.children[0].type;
    }
    get valueField() {
      return this.children[0];
    }
    get ArrayType() {
      return this.valueType.ArrayType;
    }
  };
  _p = Symbol.toStringTag;
  List[_p] = ((proto) => {
    proto.children = null;
    return proto[Symbol.toStringTag] = "List";
  })(List.prototype);
  var Struct = class extends DataType {
    constructor(children) {
      super();
      this.children = children;
    }
    get typeId() {
      return Type.Struct;
    }
    toString() {
      return `Struct<{${this.children.map((f) => `${f.name}:${f.type}`).join(`, `)}}>`;
    }
  };
  _q = Symbol.toStringTag;
  Struct[_q] = ((proto) => {
    proto.children = null;
    return proto[Symbol.toStringTag] = "Struct";
  })(Struct.prototype);
  var Union_ = class extends DataType {
    constructor(mode, typeIds, children) {
      super();
      this.mode = mode;
      this.children = children;
      this.typeIds = typeIds = Int32Array.from(typeIds);
      this.typeIdToChildIndex = typeIds.reduce((typeIdToChildIndex, typeId, idx) => (typeIdToChildIndex[typeId] = idx) && typeIdToChildIndex || typeIdToChildIndex, /* @__PURE__ */ Object.create(null));
    }
    get typeId() {
      return Type.Union;
    }
    toString() {
      return `${this[Symbol.toStringTag]}<${this.children.map((x) => `${x.type}`).join(` | `)}>`;
    }
  };
  _r = Symbol.toStringTag;
  Union_[_r] = ((proto) => {
    proto.mode = null;
    proto.typeIds = null;
    proto.children = null;
    proto.typeIdToChildIndex = null;
    proto.ArrayType = Int8Array;
    return proto[Symbol.toStringTag] = "Union";
  })(Union_.prototype);
  var FixedSizeBinary = class extends DataType {
    constructor(byteWidth) {
      super();
      this.byteWidth = byteWidth;
    }
    get typeId() {
      return Type.FixedSizeBinary;
    }
    toString() {
      return `FixedSizeBinary[${this.byteWidth}]`;
    }
  };
  _s = Symbol.toStringTag;
  FixedSizeBinary[_s] = ((proto) => {
    proto.byteWidth = null;
    proto.ArrayType = Uint8Array;
    return proto[Symbol.toStringTag] = "FixedSizeBinary";
  })(FixedSizeBinary.prototype);
  var FixedSizeList = class extends DataType {
    constructor(listSize, child) {
      super();
      this.listSize = listSize;
      this.children = [child];
    }
    get typeId() {
      return Type.FixedSizeList;
    }
    get valueType() {
      return this.children[0].type;
    }
    get valueField() {
      return this.children[0];
    }
    get ArrayType() {
      return this.valueType.ArrayType;
    }
    toString() {
      return `FixedSizeList[${this.listSize}]<${this.valueType}>`;
    }
  };
  _t = Symbol.toStringTag;
  FixedSizeList[_t] = ((proto) => {
    proto.children = null;
    proto.listSize = null;
    return proto[Symbol.toStringTag] = "FixedSizeList";
  })(FixedSizeList.prototype);
  var Map_ = class extends DataType {
    constructor(entries, keysSorted = false) {
      var _w, _x, _y;
      super();
      this.children = [entries];
      this.keysSorted = keysSorted;
      if (entries) {
        entries["name"] = "entries";
        if ((_w = entries === null || entries === void 0 ? void 0 : entries.type) === null || _w === void 0 ? void 0 : _w.children) {
          const key = (_x = entries === null || entries === void 0 ? void 0 : entries.type) === null || _x === void 0 ? void 0 : _x.children[0];
          if (key) {
            key["name"] = "key";
          }
          const val = (_y = entries === null || entries === void 0 ? void 0 : entries.type) === null || _y === void 0 ? void 0 : _y.children[1];
          if (val) {
            val["name"] = "value";
          }
        }
      }
    }
    get typeId() {
      return Type.Map;
    }
    get keyType() {
      return this.children[0].type.children[0].type;
    }
    get valueType() {
      return this.children[0].type.children[1].type;
    }
    get childType() {
      return this.children[0].type;
    }
    toString() {
      return `Map<{${this.children[0].type.children.map((f) => `${f.name}:${f.type}`).join(`, `)}}>`;
    }
  };
  _u = Symbol.toStringTag;
  Map_[_u] = ((proto) => {
    proto.children = null;
    proto.keysSorted = null;
    return proto[Symbol.toStringTag] = "Map_";
  })(Map_.prototype);
  var getId = /* @__PURE__ */ ((atomicDictionaryId) => () => ++atomicDictionaryId)(-1);
  var Dictionary = class extends DataType {
    constructor(dictionary, indices, id, isOrdered) {
      super();
      this.indices = indices;
      this.dictionary = dictionary;
      this.isOrdered = isOrdered || false;
      this.id = id == null ? getId() : bigIntToNumber(id);
    }
    get typeId() {
      return Type.Dictionary;
    }
    get children() {
      return this.dictionary.children;
    }
    get valueType() {
      return this.dictionary;
    }
    get ArrayType() {
      return this.dictionary.ArrayType;
    }
    toString() {
      return `Dictionary<${this.indices}, ${this.dictionary}>`;
    }
  };
  _v = Symbol.toStringTag;
  Dictionary[_v] = ((proto) => {
    proto.id = null;
    proto.indices = null;
    proto.isOrdered = null;
    proto.dictionary = null;
    return proto[Symbol.toStringTag] = "Dictionary";
  })(Dictionary.prototype);
  function strideForType(type) {
    const t = type;
    switch (type.typeId) {
      case Type.Decimal:
        return type.bitWidth / 32;
      case Type.Timestamp:
        return 2;
      case Type.Date:
        return 1 + t.unit;
      case Type.Interval:
        return 1 + t.unit;
      case Type.FixedSizeList:
        return t.listSize;
      case Type.FixedSizeBinary:
        return t.byteWidth;
      default:
        return 1;
    }
  }

  // ../../node_modules/apache-arrow/visitor.mjs
  var Visitor = class {
    visitMany(nodes, ...args2) {
      return nodes.map((node, i2) => this.visit(node, ...args2.map((x) => x[i2])));
    }
    visit(...args2) {
      return this.getVisitFn(args2[0], false).apply(this, args2);
    }
    getVisitFn(node, throwIfNotFound = true) {
      return getVisitFn(this, node, throwIfNotFound);
    }
    getVisitFnByTypeId(typeId, throwIfNotFound = true) {
      return getVisitFnByTypeId(this, typeId, throwIfNotFound);
    }
    visitNull(_node, ..._args) {
      return null;
    }
    visitBool(_node, ..._args) {
      return null;
    }
    visitInt(_node, ..._args) {
      return null;
    }
    visitFloat(_node, ..._args) {
      return null;
    }
    visitUtf8(_node, ..._args) {
      return null;
    }
    visitBinary(_node, ..._args) {
      return null;
    }
    visitFixedSizeBinary(_node, ..._args) {
      return null;
    }
    visitDate(_node, ..._args) {
      return null;
    }
    visitTimestamp(_node, ..._args) {
      return null;
    }
    visitTime(_node, ..._args) {
      return null;
    }
    visitDecimal(_node, ..._args) {
      return null;
    }
    visitList(_node, ..._args) {
      return null;
    }
    visitStruct(_node, ..._args) {
      return null;
    }
    visitUnion(_node, ..._args) {
      return null;
    }
    visitDictionary(_node, ..._args) {
      return null;
    }
    visitInterval(_node, ..._args) {
      return null;
    }
    visitDuration(_node, ..._args) {
      return null;
    }
    visitFixedSizeList(_node, ..._args) {
      return null;
    }
    visitMap(_node, ..._args) {
      return null;
    }
  };
  function getVisitFn(visitor, node, throwIfNotFound = true) {
    if (typeof node === "number") {
      return getVisitFnByTypeId(visitor, node, throwIfNotFound);
    }
    if (typeof node === "string" && node in Type) {
      return getVisitFnByTypeId(visitor, Type[node], throwIfNotFound);
    }
    if (node && node instanceof DataType) {
      return getVisitFnByTypeId(visitor, inferDType(node), throwIfNotFound);
    }
    if ((node === null || node === void 0 ? void 0 : node.type) && node.type instanceof DataType) {
      return getVisitFnByTypeId(visitor, inferDType(node.type), throwIfNotFound);
    }
    return getVisitFnByTypeId(visitor, Type.NONE, throwIfNotFound);
  }
  function getVisitFnByTypeId(visitor, dtype, throwIfNotFound = true) {
    let fn = null;
    switch (dtype) {
      case Type.Null:
        fn = visitor.visitNull;
        break;
      case Type.Bool:
        fn = visitor.visitBool;
        break;
      case Type.Int:
        fn = visitor.visitInt;
        break;
      case Type.Int8:
        fn = visitor.visitInt8 || visitor.visitInt;
        break;
      case Type.Int16:
        fn = visitor.visitInt16 || visitor.visitInt;
        break;
      case Type.Int32:
        fn = visitor.visitInt32 || visitor.visitInt;
        break;
      case Type.Int64:
        fn = visitor.visitInt64 || visitor.visitInt;
        break;
      case Type.Uint8:
        fn = visitor.visitUint8 || visitor.visitInt;
        break;
      case Type.Uint16:
        fn = visitor.visitUint16 || visitor.visitInt;
        break;
      case Type.Uint32:
        fn = visitor.visitUint32 || visitor.visitInt;
        break;
      case Type.Uint64:
        fn = visitor.visitUint64 || visitor.visitInt;
        break;
      case Type.Float:
        fn = visitor.visitFloat;
        break;
      case Type.Float16:
        fn = visitor.visitFloat16 || visitor.visitFloat;
        break;
      case Type.Float32:
        fn = visitor.visitFloat32 || visitor.visitFloat;
        break;
      case Type.Float64:
        fn = visitor.visitFloat64 || visitor.visitFloat;
        break;
      case Type.Utf8:
        fn = visitor.visitUtf8;
        break;
      case Type.Binary:
        fn = visitor.visitBinary;
        break;
      case Type.FixedSizeBinary:
        fn = visitor.visitFixedSizeBinary;
        break;
      case Type.Date:
        fn = visitor.visitDate;
        break;
      case Type.DateDay:
        fn = visitor.visitDateDay || visitor.visitDate;
        break;
      case Type.DateMillisecond:
        fn = visitor.visitDateMillisecond || visitor.visitDate;
        break;
      case Type.Timestamp:
        fn = visitor.visitTimestamp;
        break;
      case Type.TimestampSecond:
        fn = visitor.visitTimestampSecond || visitor.visitTimestamp;
        break;
      case Type.TimestampMillisecond:
        fn = visitor.visitTimestampMillisecond || visitor.visitTimestamp;
        break;
      case Type.TimestampMicrosecond:
        fn = visitor.visitTimestampMicrosecond || visitor.visitTimestamp;
        break;
      case Type.TimestampNanosecond:
        fn = visitor.visitTimestampNanosecond || visitor.visitTimestamp;
        break;
      case Type.Time:
        fn = visitor.visitTime;
        break;
      case Type.TimeSecond:
        fn = visitor.visitTimeSecond || visitor.visitTime;
        break;
      case Type.TimeMillisecond:
        fn = visitor.visitTimeMillisecond || visitor.visitTime;
        break;
      case Type.TimeMicrosecond:
        fn = visitor.visitTimeMicrosecond || visitor.visitTime;
        break;
      case Type.TimeNanosecond:
        fn = visitor.visitTimeNanosecond || visitor.visitTime;
        break;
      case Type.Decimal:
        fn = visitor.visitDecimal;
        break;
      case Type.List:
        fn = visitor.visitList;
        break;
      case Type.Struct:
        fn = visitor.visitStruct;
        break;
      case Type.Union:
        fn = visitor.visitUnion;
        break;
      case Type.DenseUnion:
        fn = visitor.visitDenseUnion || visitor.visitUnion;
        break;
      case Type.SparseUnion:
        fn = visitor.visitSparseUnion || visitor.visitUnion;
        break;
      case Type.Dictionary:
        fn = visitor.visitDictionary;
        break;
      case Type.Interval:
        fn = visitor.visitInterval;
        break;
      case Type.IntervalDayTime:
        fn = visitor.visitIntervalDayTime || visitor.visitInterval;
        break;
      case Type.IntervalYearMonth:
        fn = visitor.visitIntervalYearMonth || visitor.visitInterval;
        break;
      case Type.Duration:
        fn = visitor.visitDuration;
        break;
      case Type.DurationSecond:
        fn = visitor.visitDurationSecond || visitor.visitDuration;
        break;
      case Type.DurationMillisecond:
        fn = visitor.visitDurationMillisecond || visitor.visitDuration;
        break;
      case Type.DurationMicrosecond:
        fn = visitor.visitDurationMicrosecond || visitor.visitDuration;
        break;
      case Type.DurationNanosecond:
        fn = visitor.visitDurationNanosecond || visitor.visitDuration;
        break;
      case Type.FixedSizeList:
        fn = visitor.visitFixedSizeList;
        break;
      case Type.Map:
        fn = visitor.visitMap;
        break;
    }
    if (typeof fn === "function")
      return fn;
    if (!throwIfNotFound)
      return () => null;
    throw new Error(`Unrecognized type '${Type[dtype]}'`);
  }
  function inferDType(type) {
    switch (type.typeId) {
      case Type.Null:
        return Type.Null;
      case Type.Int: {
        const { bitWidth, isSigned } = type;
        switch (bitWidth) {
          case 8:
            return isSigned ? Type.Int8 : Type.Uint8;
          case 16:
            return isSigned ? Type.Int16 : Type.Uint16;
          case 32:
            return isSigned ? Type.Int32 : Type.Uint32;
          case 64:
            return isSigned ? Type.Int64 : Type.Uint64;
        }
        return Type.Int;
      }
      case Type.Float:
        switch (type.precision) {
          case Precision.HALF:
            return Type.Float16;
          case Precision.SINGLE:
            return Type.Float32;
          case Precision.DOUBLE:
            return Type.Float64;
        }
        return Type.Float;
      case Type.Binary:
        return Type.Binary;
      case Type.Utf8:
        return Type.Utf8;
      case Type.Bool:
        return Type.Bool;
      case Type.Decimal:
        return Type.Decimal;
      case Type.Time:
        switch (type.unit) {
          case TimeUnit.SECOND:
            return Type.TimeSecond;
          case TimeUnit.MILLISECOND:
            return Type.TimeMillisecond;
          case TimeUnit.MICROSECOND:
            return Type.TimeMicrosecond;
          case TimeUnit.NANOSECOND:
            return Type.TimeNanosecond;
        }
        return Type.Time;
      case Type.Timestamp:
        switch (type.unit) {
          case TimeUnit.SECOND:
            return Type.TimestampSecond;
          case TimeUnit.MILLISECOND:
            return Type.TimestampMillisecond;
          case TimeUnit.MICROSECOND:
            return Type.TimestampMicrosecond;
          case TimeUnit.NANOSECOND:
            return Type.TimestampNanosecond;
        }
        return Type.Timestamp;
      case Type.Date:
        switch (type.unit) {
          case DateUnit.DAY:
            return Type.DateDay;
          case DateUnit.MILLISECOND:
            return Type.DateMillisecond;
        }
        return Type.Date;
      case Type.Interval:
        switch (type.unit) {
          case IntervalUnit.DAY_TIME:
            return Type.IntervalDayTime;
          case IntervalUnit.YEAR_MONTH:
            return Type.IntervalYearMonth;
        }
        return Type.Interval;
      case Type.Duration:
        switch (type.unit) {
          case TimeUnit.SECOND:
            return Type.DurationSecond;
          case TimeUnit.MILLISECOND:
            return Type.DurationMillisecond;
          case TimeUnit.MICROSECOND:
            return Type.DurationMicrosecond;
          case TimeUnit.NANOSECOND:
            return Type.DurationNanosecond;
        }
        return Type.Duration;
      case Type.Map:
        return Type.Map;
      case Type.List:
        return Type.List;
      case Type.Struct:
        return Type.Struct;
      case Type.Union:
        switch (type.mode) {
          case UnionMode.Dense:
            return Type.DenseUnion;
          case UnionMode.Sparse:
            return Type.SparseUnion;
        }
        return Type.Union;
      case Type.FixedSizeBinary:
        return Type.FixedSizeBinary;
      case Type.FixedSizeList:
        return Type.FixedSizeList;
      case Type.Dictionary:
        return Type.Dictionary;
    }
    throw new Error(`Unrecognized type '${Type[type.typeId]}'`);
  }
  Visitor.prototype.visitInt8 = null;
  Visitor.prototype.visitInt16 = null;
  Visitor.prototype.visitInt32 = null;
  Visitor.prototype.visitInt64 = null;
  Visitor.prototype.visitUint8 = null;
  Visitor.prototype.visitUint16 = null;
  Visitor.prototype.visitUint32 = null;
  Visitor.prototype.visitUint64 = null;
  Visitor.prototype.visitFloat16 = null;
  Visitor.prototype.visitFloat32 = null;
  Visitor.prototype.visitFloat64 = null;
  Visitor.prototype.visitDateDay = null;
  Visitor.prototype.visitDateMillisecond = null;
  Visitor.prototype.visitTimestampSecond = null;
  Visitor.prototype.visitTimestampMillisecond = null;
  Visitor.prototype.visitTimestampMicrosecond = null;
  Visitor.prototype.visitTimestampNanosecond = null;
  Visitor.prototype.visitTimeSecond = null;
  Visitor.prototype.visitTimeMillisecond = null;
  Visitor.prototype.visitTimeMicrosecond = null;
  Visitor.prototype.visitTimeNanosecond = null;
  Visitor.prototype.visitDenseUnion = null;
  Visitor.prototype.visitSparseUnion = null;
  Visitor.prototype.visitIntervalDayTime = null;
  Visitor.prototype.visitIntervalYearMonth = null;
  Visitor.prototype.visitDuration = null;
  Visitor.prototype.visitDurationSecond = null;
  Visitor.prototype.visitDurationMillisecond = null;
  Visitor.prototype.visitDurationMicrosecond = null;
  Visitor.prototype.visitDurationNanosecond = null;

  // ../../node_modules/apache-arrow/util/math.mjs
  var math_exports = {};
  __export(math_exports, {
    float64ToUint16: () => float64ToUint16,
    uint16ToFloat64: () => uint16ToFloat64
  });
  var f64 = new Float64Array(1);
  var u32 = new Uint32Array(f64.buffer);
  function uint16ToFloat64(h) {
    const expo = (h & 31744) >> 10;
    const sigf = (h & 1023) / 1024;
    const sign = Math.pow(-1, (h & 32768) >> 15);
    switch (expo) {
      case 31:
        return sign * (sigf ? Number.NaN : 1 / 0);
      case 0:
        return sign * (sigf ? 6103515625e-14 * sigf : 0);
    }
    return sign * Math.pow(2, expo - 15) * (1 + sigf);
  }
  function float64ToUint16(d) {
    if (d !== d) {
      return 32256;
    }
    f64[0] = d;
    const sign = (u32[1] & 2147483648) >> 16 & 65535;
    let expo = u32[1] & 2146435072, sigf = 0;
    if (expo >= 1089470464) {
      if (u32[0] > 0) {
        expo = 31744;
      } else {
        expo = (expo & 2080374784) >> 16;
        sigf = (u32[1] & 1048575) >> 10;
      }
    } else if (expo <= 1056964608) {
      sigf = 1048576 + (u32[1] & 1048575);
      sigf = 1048576 + (sigf << (expo >> 20) - 998) >> 21;
      expo = 0;
    } else {
      expo = expo - 1056964608 >> 10;
      sigf = (u32[1] & 1048575) + 512 >> 10;
    }
    return sign | expo | sigf & 65535;
  }

  // ../../node_modules/apache-arrow/visitor/set.mjs
  var SetVisitor = class extends Visitor {
  };
  function wrapSet(fn) {
    return (data2, _1, _2) => {
      if (data2.setValid(_1, _2 != null)) {
        return fn(data2, _1, _2);
      }
    };
  }
  var setEpochMsToDays = (data2, index, epochMs) => {
    data2[index] = Math.trunc(epochMs / 864e5);
  };
  var setEpochMsToMillisecondsLong = (data2, index, epochMs) => {
    data2[index] = Math.trunc(epochMs % 4294967296);
    data2[index + 1] = Math.trunc(epochMs / 4294967296);
  };
  var setEpochMsToMicrosecondsLong = (data2, index, epochMs) => {
    data2[index] = Math.trunc(epochMs * 1e3 % 4294967296);
    data2[index + 1] = Math.trunc(epochMs * 1e3 / 4294967296);
  };
  var setEpochMsToNanosecondsLong = (data2, index, epochMs) => {
    data2[index] = Math.trunc(epochMs * 1e6 % 4294967296);
    data2[index + 1] = Math.trunc(epochMs * 1e6 / 4294967296);
  };
  var setVariableWidthBytes = (values, valueOffsets, index, value) => {
    if (index + 1 < valueOffsets.length) {
      const { [index]: x, [index + 1]: y } = valueOffsets;
      values.set(value.subarray(0, y - x), x);
    }
  };
  var setBool = ({ offset, values }, index, val) => {
    const idx = offset + index;
    val ? values[idx >> 3] |= 1 << idx % 8 : values[idx >> 3] &= ~(1 << idx % 8);
  };
  var setInt = ({ values }, index, value) => {
    values[index] = value;
  };
  var setFloat = ({ values }, index, value) => {
    values[index] = value;
  };
  var setFloat16 = ({ values }, index, value) => {
    values[index] = float64ToUint16(value);
  };
  var setAnyFloat = (data2, index, value) => {
    switch (data2.type.precision) {
      case Precision.HALF:
        return setFloat16(data2, index, value);
      case Precision.SINGLE:
      case Precision.DOUBLE:
        return setFloat(data2, index, value);
    }
  };
  var setDateDay = ({ values }, index, value) => {
    setEpochMsToDays(values, index, value.valueOf());
  };
  var setDateMillisecond = ({ values }, index, value) => {
    setEpochMsToMillisecondsLong(values, index * 2, value.valueOf());
  };
  var setFixedSizeBinary = ({ stride, values }, index, value) => {
    values.set(value.subarray(0, stride), stride * index);
  };
  var setBinary = ({ values, valueOffsets }, index, value) => setVariableWidthBytes(values, valueOffsets, index, value);
  var setUtf8 = ({ values, valueOffsets }, index, value) => {
    setVariableWidthBytes(values, valueOffsets, index, encodeUtf8(value));
  };
  var setDate = (data2, index, value) => {
    data2.type.unit === DateUnit.DAY ? setDateDay(data2, index, value) : setDateMillisecond(data2, index, value);
  };
  var setTimestampSecond = ({ values }, index, value) => setEpochMsToMillisecondsLong(values, index * 2, value / 1e3);
  var setTimestampMillisecond = ({ values }, index, value) => setEpochMsToMillisecondsLong(values, index * 2, value);
  var setTimestampMicrosecond = ({ values }, index, value) => setEpochMsToMicrosecondsLong(values, index * 2, value);
  var setTimestampNanosecond = ({ values }, index, value) => setEpochMsToNanosecondsLong(values, index * 2, value);
  var setTimestamp = (data2, index, value) => {
    switch (data2.type.unit) {
      case TimeUnit.SECOND:
        return setTimestampSecond(data2, index, value);
      case TimeUnit.MILLISECOND:
        return setTimestampMillisecond(data2, index, value);
      case TimeUnit.MICROSECOND:
        return setTimestampMicrosecond(data2, index, value);
      case TimeUnit.NANOSECOND:
        return setTimestampNanosecond(data2, index, value);
    }
  };
  var setTimeSecond = ({ values }, index, value) => {
    values[index] = value;
  };
  var setTimeMillisecond = ({ values }, index, value) => {
    values[index] = value;
  };
  var setTimeMicrosecond = ({ values }, index, value) => {
    values[index] = value;
  };
  var setTimeNanosecond = ({ values }, index, value) => {
    values[index] = value;
  };
  var setTime = (data2, index, value) => {
    switch (data2.type.unit) {
      case TimeUnit.SECOND:
        return setTimeSecond(data2, index, value);
      case TimeUnit.MILLISECOND:
        return setTimeMillisecond(data2, index, value);
      case TimeUnit.MICROSECOND:
        return setTimeMicrosecond(data2, index, value);
      case TimeUnit.NANOSECOND:
        return setTimeNanosecond(data2, index, value);
    }
  };
  var setDecimal = ({ values, stride }, index, value) => {
    values.set(value.subarray(0, stride), stride * index);
  };
  var setList = (data2, index, value) => {
    const values = data2.children[0];
    const valueOffsets = data2.valueOffsets;
    const set = instance2.getVisitFn(values);
    if (Array.isArray(value)) {
      for (let idx = -1, itr = valueOffsets[index], end = valueOffsets[index + 1]; itr < end; ) {
        set(values, itr++, value[++idx]);
      }
    } else {
      for (let idx = -1, itr = valueOffsets[index], end = valueOffsets[index + 1]; itr < end; ) {
        set(values, itr++, value.get(++idx));
      }
    }
  };
  var setMap = (data2, index, value) => {
    const values = data2.children[0];
    const { valueOffsets } = data2;
    const set = instance2.getVisitFn(values);
    let { [index]: idx, [index + 1]: end } = valueOffsets;
    const entries = value instanceof Map ? value.entries() : Object.entries(value);
    for (const val of entries) {
      set(values, idx, val);
      if (++idx >= end)
        break;
    }
  };
  var _setStructArrayValue = (o, v) => (set, c, _, i2) => c && set(c, o, v[i2]);
  var _setStructVectorValue = (o, v) => (set, c, _, i2) => c && set(c, o, v.get(i2));
  var _setStructMapValue = (o, v) => (set, c, f, _) => c && set(c, o, v.get(f.name));
  var _setStructObjectValue = (o, v) => (set, c, f, _) => c && set(c, o, v[f.name]);
  var setStruct = (data2, index, value) => {
    const childSetters = data2.type.children.map((f) => instance2.getVisitFn(f.type));
    const set = value instanceof Map ? _setStructMapValue(index, value) : value instanceof Vector ? _setStructVectorValue(index, value) : Array.isArray(value) ? _setStructArrayValue(index, value) : _setStructObjectValue(index, value);
    data2.type.children.forEach((f, i2) => set(childSetters[i2], data2.children[i2], f, i2));
  };
  var setUnion = (data2, index, value) => {
    data2.type.mode === UnionMode.Dense ? setDenseUnion(data2, index, value) : setSparseUnion(data2, index, value);
  };
  var setDenseUnion = (data2, index, value) => {
    const childIndex = data2.type.typeIdToChildIndex[data2.typeIds[index]];
    const child = data2.children[childIndex];
    instance2.visit(child, data2.valueOffsets[index], value);
  };
  var setSparseUnion = (data2, index, value) => {
    const childIndex = data2.type.typeIdToChildIndex[data2.typeIds[index]];
    const child = data2.children[childIndex];
    instance2.visit(child, index, value);
  };
  var setDictionary = (data2, index, value) => {
    var _a5;
    (_a5 = data2.dictionary) === null || _a5 === void 0 ? void 0 : _a5.set(data2.values[index], value);
  };
  var setIntervalValue = (data2, index, value) => {
    data2.type.unit === IntervalUnit.DAY_TIME ? setIntervalDayTime(data2, index, value) : setIntervalYearMonth(data2, index, value);
  };
  var setIntervalDayTime = ({ values }, index, value) => {
    values.set(value.subarray(0, 2), 2 * index);
  };
  var setIntervalYearMonth = ({ values }, index, value) => {
    values[index] = value[0] * 12 + value[1] % 12;
  };
  var setDurationSecond = ({ values }, index, value) => {
    values[index] = value;
  };
  var setDurationMillisecond = ({ values }, index, value) => {
    values[index] = value;
  };
  var setDurationMicrosecond = ({ values }, index, value) => {
    values[index] = value;
  };
  var setDurationNanosecond = ({ values }, index, value) => {
    values[index] = value;
  };
  var setDuration = (data2, index, value) => {
    switch (data2.type.unit) {
      case TimeUnit.SECOND:
        return setDurationSecond(data2, index, value);
      case TimeUnit.MILLISECOND:
        return setDurationMillisecond(data2, index, value);
      case TimeUnit.MICROSECOND:
        return setDurationMicrosecond(data2, index, value);
      case TimeUnit.NANOSECOND:
        return setDurationNanosecond(data2, index, value);
    }
  };
  var setFixedSizeList = (data2, index, value) => {
    const { stride } = data2;
    const child = data2.children[0];
    const set = instance2.getVisitFn(child);
    if (Array.isArray(value)) {
      for (let idx = -1, offset = index * stride; ++idx < stride; ) {
        set(child, offset + idx, value[idx]);
      }
    } else {
      for (let idx = -1, offset = index * stride; ++idx < stride; ) {
        set(child, offset + idx, value.get(idx));
      }
    }
  };
  SetVisitor.prototype.visitBool = wrapSet(setBool);
  SetVisitor.prototype.visitInt = wrapSet(setInt);
  SetVisitor.prototype.visitInt8 = wrapSet(setInt);
  SetVisitor.prototype.visitInt16 = wrapSet(setInt);
  SetVisitor.prototype.visitInt32 = wrapSet(setInt);
  SetVisitor.prototype.visitInt64 = wrapSet(setInt);
  SetVisitor.prototype.visitUint8 = wrapSet(setInt);
  SetVisitor.prototype.visitUint16 = wrapSet(setInt);
  SetVisitor.prototype.visitUint32 = wrapSet(setInt);
  SetVisitor.prototype.visitUint64 = wrapSet(setInt);
  SetVisitor.prototype.visitFloat = wrapSet(setAnyFloat);
  SetVisitor.prototype.visitFloat16 = wrapSet(setFloat16);
  SetVisitor.prototype.visitFloat32 = wrapSet(setFloat);
  SetVisitor.prototype.visitFloat64 = wrapSet(setFloat);
  SetVisitor.prototype.visitUtf8 = wrapSet(setUtf8);
  SetVisitor.prototype.visitBinary = wrapSet(setBinary);
  SetVisitor.prototype.visitFixedSizeBinary = wrapSet(setFixedSizeBinary);
  SetVisitor.prototype.visitDate = wrapSet(setDate);
  SetVisitor.prototype.visitDateDay = wrapSet(setDateDay);
  SetVisitor.prototype.visitDateMillisecond = wrapSet(setDateMillisecond);
  SetVisitor.prototype.visitTimestamp = wrapSet(setTimestamp);
  SetVisitor.prototype.visitTimestampSecond = wrapSet(setTimestampSecond);
  SetVisitor.prototype.visitTimestampMillisecond = wrapSet(setTimestampMillisecond);
  SetVisitor.prototype.visitTimestampMicrosecond = wrapSet(setTimestampMicrosecond);
  SetVisitor.prototype.visitTimestampNanosecond = wrapSet(setTimestampNanosecond);
  SetVisitor.prototype.visitTime = wrapSet(setTime);
  SetVisitor.prototype.visitTimeSecond = wrapSet(setTimeSecond);
  SetVisitor.prototype.visitTimeMillisecond = wrapSet(setTimeMillisecond);
  SetVisitor.prototype.visitTimeMicrosecond = wrapSet(setTimeMicrosecond);
  SetVisitor.prototype.visitTimeNanosecond = wrapSet(setTimeNanosecond);
  SetVisitor.prototype.visitDecimal = wrapSet(setDecimal);
  SetVisitor.prototype.visitList = wrapSet(setList);
  SetVisitor.prototype.visitStruct = wrapSet(setStruct);
  SetVisitor.prototype.visitUnion = wrapSet(setUnion);
  SetVisitor.prototype.visitDenseUnion = wrapSet(setDenseUnion);
  SetVisitor.prototype.visitSparseUnion = wrapSet(setSparseUnion);
  SetVisitor.prototype.visitDictionary = wrapSet(setDictionary);
  SetVisitor.prototype.visitInterval = wrapSet(setIntervalValue);
  SetVisitor.prototype.visitIntervalDayTime = wrapSet(setIntervalDayTime);
  SetVisitor.prototype.visitIntervalYearMonth = wrapSet(setIntervalYearMonth);
  SetVisitor.prototype.visitDuration = wrapSet(setDuration);
  SetVisitor.prototype.visitDurationSecond = wrapSet(setDurationSecond);
  SetVisitor.prototype.visitDurationMillisecond = wrapSet(setDurationMillisecond);
  SetVisitor.prototype.visitDurationMicrosecond = wrapSet(setDurationMicrosecond);
  SetVisitor.prototype.visitDurationNanosecond = wrapSet(setDurationNanosecond);
  SetVisitor.prototype.visitFixedSizeList = wrapSet(setFixedSizeList);
  SetVisitor.prototype.visitMap = wrapSet(setMap);
  var instance2 = new SetVisitor();

  // ../../node_modules/apache-arrow/row/struct.mjs
  var kParent = Symbol.for("parent");
  var kRowIndex = Symbol.for("rowIndex");
  var StructRow = class {
    constructor(parent, rowIndex) {
      this[kParent] = parent;
      this[kRowIndex] = rowIndex;
      return new Proxy(this, new StructRowProxyHandler());
    }
    toArray() {
      return Object.values(this.toJSON());
    }
    toJSON() {
      const i2 = this[kRowIndex];
      const parent = this[kParent];
      const keys = parent.type.children;
      const json = {};
      for (let j = -1, n = keys.length; ++j < n; ) {
        json[keys[j].name] = instance3.visit(parent.children[j], i2);
      }
      return json;
    }
    toString() {
      return `{${[...this].map(([key, val]) => `${valueToString(key)}: ${valueToString(val)}`).join(", ")}}`;
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return this.toString();
    }
    [Symbol.iterator]() {
      return new StructRowIterator(this[kParent], this[kRowIndex]);
    }
  };
  var StructRowIterator = class {
    constructor(data2, rowIndex) {
      this.childIndex = 0;
      this.children = data2.children;
      this.rowIndex = rowIndex;
      this.childFields = data2.type.children;
      this.numChildren = this.childFields.length;
    }
    [Symbol.iterator]() {
      return this;
    }
    next() {
      const i2 = this.childIndex;
      if (i2 < this.numChildren) {
        this.childIndex = i2 + 1;
        return {
          done: false,
          value: [
            this.childFields[i2].name,
            instance3.visit(this.children[i2], this.rowIndex)
          ]
        };
      }
      return { done: true, value: null };
    }
  };
  Object.defineProperties(StructRow.prototype, {
    [Symbol.toStringTag]: { enumerable: false, configurable: false, value: "Row" },
    [kParent]: { writable: true, enumerable: false, configurable: false, value: null },
    [kRowIndex]: { writable: true, enumerable: false, configurable: false, value: -1 }
  });
  var StructRowProxyHandler = class {
    isExtensible() {
      return false;
    }
    deleteProperty() {
      return false;
    }
    preventExtensions() {
      return true;
    }
    ownKeys(row) {
      return row[kParent].type.children.map((f) => f.name);
    }
    has(row, key) {
      return row[kParent].type.children.findIndex((f) => f.name === key) !== -1;
    }
    getOwnPropertyDescriptor(row, key) {
      if (row[kParent].type.children.findIndex((f) => f.name === key) !== -1) {
        return { writable: true, enumerable: true, configurable: true };
      }
      return;
    }
    get(row, key) {
      if (Reflect.has(row, key)) {
        return row[key];
      }
      const idx = row[kParent].type.children.findIndex((f) => f.name === key);
      if (idx !== -1) {
        const val = instance3.visit(row[kParent].children[idx], row[kRowIndex]);
        Reflect.set(row, key, val);
        return val;
      }
    }
    set(row, key, val) {
      const idx = row[kParent].type.children.findIndex((f) => f.name === key);
      if (idx !== -1) {
        instance2.visit(row[kParent].children[idx], row[kRowIndex], val);
        return Reflect.set(row, key, val);
      } else if (Reflect.has(row, key) || typeof key === "symbol") {
        return Reflect.set(row, key, val);
      }
      return false;
    }
  };

  // ../../node_modules/apache-arrow/visitor/get.mjs
  var GetVisitor = class extends Visitor {
  };
  function wrapGet(fn) {
    return (data2, _1) => data2.getValid(_1) ? fn(data2, _1) : null;
  }
  var epochDaysToMs = (data2, index) => 864e5 * data2[index];
  var epochMillisecondsLongToMs = (data2, index) => 4294967296 * data2[index + 1] + (data2[index] >>> 0);
  var epochMicrosecondsLongToMs = (data2, index) => 4294967296 * (data2[index + 1] / 1e3) + (data2[index] >>> 0) / 1e3;
  var epochNanosecondsLongToMs = (data2, index) => 4294967296 * (data2[index + 1] / 1e6) + (data2[index] >>> 0) / 1e6;
  var epochMillisecondsToDate = (epochMs) => new Date(epochMs);
  var epochDaysToDate = (data2, index) => epochMillisecondsToDate(epochDaysToMs(data2, index));
  var epochMillisecondsLongToDate = (data2, index) => epochMillisecondsToDate(epochMillisecondsLongToMs(data2, index));
  var getNull = (_data, _index) => null;
  var getVariableWidthBytes = (values, valueOffsets, index) => {
    if (index + 1 >= valueOffsets.length) {
      return null;
    }
    const x = valueOffsets[index];
    const y = valueOffsets[index + 1];
    return values.subarray(x, y);
  };
  var getBool = ({ offset, values }, index) => {
    const idx = offset + index;
    const byte = values[idx >> 3];
    return (byte & 1 << idx % 8) !== 0;
  };
  var getDateDay = ({ values }, index) => epochDaysToDate(values, index);
  var getDateMillisecond = ({ values }, index) => epochMillisecondsLongToDate(values, index * 2);
  var getNumeric = ({ stride, values }, index) => values[stride * index];
  var getFloat16 = ({ stride, values }, index) => uint16ToFloat64(values[stride * index]);
  var getBigInts = ({ values }, index) => values[index];
  var getFixedSizeBinary = ({ stride, values }, index) => values.subarray(stride * index, stride * (index + 1));
  var getBinary = ({ values, valueOffsets }, index) => getVariableWidthBytes(values, valueOffsets, index);
  var getUtf8 = ({ values, valueOffsets }, index) => {
    const bytes = getVariableWidthBytes(values, valueOffsets, index);
    return bytes !== null ? decodeUtf8(bytes) : null;
  };
  var getInt = ({ values }, index) => values[index];
  var getFloat = ({ type, values }, index) => type.precision !== Precision.HALF ? values[index] : uint16ToFloat64(values[index]);
  var getDate = (data2, index) => data2.type.unit === DateUnit.DAY ? getDateDay(data2, index) : getDateMillisecond(data2, index);
  var getTimestampSecond = ({ values }, index) => 1e3 * epochMillisecondsLongToMs(values, index * 2);
  var getTimestampMillisecond = ({ values }, index) => epochMillisecondsLongToMs(values, index * 2);
  var getTimestampMicrosecond = ({ values }, index) => epochMicrosecondsLongToMs(values, index * 2);
  var getTimestampNanosecond = ({ values }, index) => epochNanosecondsLongToMs(values, index * 2);
  var getTimestamp = (data2, index) => {
    switch (data2.type.unit) {
      case TimeUnit.SECOND:
        return getTimestampSecond(data2, index);
      case TimeUnit.MILLISECOND:
        return getTimestampMillisecond(data2, index);
      case TimeUnit.MICROSECOND:
        return getTimestampMicrosecond(data2, index);
      case TimeUnit.NANOSECOND:
        return getTimestampNanosecond(data2, index);
    }
  };
  var getTimeSecond = ({ values }, index) => values[index];
  var getTimeMillisecond = ({ values }, index) => values[index];
  var getTimeMicrosecond = ({ values }, index) => values[index];
  var getTimeNanosecond = ({ values }, index) => values[index];
  var getTime = (data2, index) => {
    switch (data2.type.unit) {
      case TimeUnit.SECOND:
        return getTimeSecond(data2, index);
      case TimeUnit.MILLISECOND:
        return getTimeMillisecond(data2, index);
      case TimeUnit.MICROSECOND:
        return getTimeMicrosecond(data2, index);
      case TimeUnit.NANOSECOND:
        return getTimeNanosecond(data2, index);
    }
  };
  var getDecimal = ({ values, stride }, index) => BN.decimal(values.subarray(stride * index, stride * (index + 1)));
  var getList = (data2, index) => {
    const { valueOffsets, stride, children } = data2;
    const { [index * stride]: begin, [index * stride + 1]: end } = valueOffsets;
    const child = children[0];
    const slice = child.slice(begin, end - begin);
    return new Vector([slice]);
  };
  var getMap = (data2, index) => {
    const { valueOffsets, children } = data2;
    const { [index]: begin, [index + 1]: end } = valueOffsets;
    const child = children[0];
    return new MapRow(child.slice(begin, end - begin));
  };
  var getStruct = (data2, index) => {
    return new StructRow(data2, index);
  };
  var getUnion = (data2, index) => {
    return data2.type.mode === UnionMode.Dense ? getDenseUnion(data2, index) : getSparseUnion(data2, index);
  };
  var getDenseUnion = (data2, index) => {
    const childIndex = data2.type.typeIdToChildIndex[data2.typeIds[index]];
    const child = data2.children[childIndex];
    return instance3.visit(child, data2.valueOffsets[index]);
  };
  var getSparseUnion = (data2, index) => {
    const childIndex = data2.type.typeIdToChildIndex[data2.typeIds[index]];
    const child = data2.children[childIndex];
    return instance3.visit(child, index);
  };
  var getDictionary = (data2, index) => {
    var _a5;
    return (_a5 = data2.dictionary) === null || _a5 === void 0 ? void 0 : _a5.get(data2.values[index]);
  };
  var getInterval = (data2, index) => data2.type.unit === IntervalUnit.DAY_TIME ? getIntervalDayTime(data2, index) : getIntervalYearMonth(data2, index);
  var getIntervalDayTime = ({ values }, index) => values.subarray(2 * index, 2 * (index + 1));
  var getIntervalYearMonth = ({ values }, index) => {
    const interval = values[index];
    const int32s = new Int32Array(2);
    int32s[0] = Math.trunc(interval / 12);
    int32s[1] = Math.trunc(interval % 12);
    return int32s;
  };
  var getDurationSecond = ({ values }, index) => values[index];
  var getDurationMillisecond = ({ values }, index) => values[index];
  var getDurationMicrosecond = ({ values }, index) => values[index];
  var getDurationNanosecond = ({ values }, index) => values[index];
  var getDuration = (data2, index) => {
    switch (data2.type.unit) {
      case TimeUnit.SECOND:
        return getDurationSecond(data2, index);
      case TimeUnit.MILLISECOND:
        return getDurationMillisecond(data2, index);
      case TimeUnit.MICROSECOND:
        return getDurationMicrosecond(data2, index);
      case TimeUnit.NANOSECOND:
        return getDurationNanosecond(data2, index);
    }
  };
  var getFixedSizeList = (data2, index) => {
    const { stride, children } = data2;
    const child = children[0];
    const slice = child.slice(index * stride, stride);
    return new Vector([slice]);
  };
  GetVisitor.prototype.visitNull = wrapGet(getNull);
  GetVisitor.prototype.visitBool = wrapGet(getBool);
  GetVisitor.prototype.visitInt = wrapGet(getInt);
  GetVisitor.prototype.visitInt8 = wrapGet(getNumeric);
  GetVisitor.prototype.visitInt16 = wrapGet(getNumeric);
  GetVisitor.prototype.visitInt32 = wrapGet(getNumeric);
  GetVisitor.prototype.visitInt64 = wrapGet(getBigInts);
  GetVisitor.prototype.visitUint8 = wrapGet(getNumeric);
  GetVisitor.prototype.visitUint16 = wrapGet(getNumeric);
  GetVisitor.prototype.visitUint32 = wrapGet(getNumeric);
  GetVisitor.prototype.visitUint64 = wrapGet(getBigInts);
  GetVisitor.prototype.visitFloat = wrapGet(getFloat);
  GetVisitor.prototype.visitFloat16 = wrapGet(getFloat16);
  GetVisitor.prototype.visitFloat32 = wrapGet(getNumeric);
  GetVisitor.prototype.visitFloat64 = wrapGet(getNumeric);
  GetVisitor.prototype.visitUtf8 = wrapGet(getUtf8);
  GetVisitor.prototype.visitBinary = wrapGet(getBinary);
  GetVisitor.prototype.visitFixedSizeBinary = wrapGet(getFixedSizeBinary);
  GetVisitor.prototype.visitDate = wrapGet(getDate);
  GetVisitor.prototype.visitDateDay = wrapGet(getDateDay);
  GetVisitor.prototype.visitDateMillisecond = wrapGet(getDateMillisecond);
  GetVisitor.prototype.visitTimestamp = wrapGet(getTimestamp);
  GetVisitor.prototype.visitTimestampSecond = wrapGet(getTimestampSecond);
  GetVisitor.prototype.visitTimestampMillisecond = wrapGet(getTimestampMillisecond);
  GetVisitor.prototype.visitTimestampMicrosecond = wrapGet(getTimestampMicrosecond);
  GetVisitor.prototype.visitTimestampNanosecond = wrapGet(getTimestampNanosecond);
  GetVisitor.prototype.visitTime = wrapGet(getTime);
  GetVisitor.prototype.visitTimeSecond = wrapGet(getTimeSecond);
  GetVisitor.prototype.visitTimeMillisecond = wrapGet(getTimeMillisecond);
  GetVisitor.prototype.visitTimeMicrosecond = wrapGet(getTimeMicrosecond);
  GetVisitor.prototype.visitTimeNanosecond = wrapGet(getTimeNanosecond);
  GetVisitor.prototype.visitDecimal = wrapGet(getDecimal);
  GetVisitor.prototype.visitList = wrapGet(getList);
  GetVisitor.prototype.visitStruct = wrapGet(getStruct);
  GetVisitor.prototype.visitUnion = wrapGet(getUnion);
  GetVisitor.prototype.visitDenseUnion = wrapGet(getDenseUnion);
  GetVisitor.prototype.visitSparseUnion = wrapGet(getSparseUnion);
  GetVisitor.prototype.visitDictionary = wrapGet(getDictionary);
  GetVisitor.prototype.visitInterval = wrapGet(getInterval);
  GetVisitor.prototype.visitIntervalDayTime = wrapGet(getIntervalDayTime);
  GetVisitor.prototype.visitIntervalYearMonth = wrapGet(getIntervalYearMonth);
  GetVisitor.prototype.visitDuration = wrapGet(getDuration);
  GetVisitor.prototype.visitDurationSecond = wrapGet(getDurationSecond);
  GetVisitor.prototype.visitDurationMillisecond = wrapGet(getDurationMillisecond);
  GetVisitor.prototype.visitDurationMicrosecond = wrapGet(getDurationMicrosecond);
  GetVisitor.prototype.visitDurationNanosecond = wrapGet(getDurationNanosecond);
  GetVisitor.prototype.visitFixedSizeList = wrapGet(getFixedSizeList);
  GetVisitor.prototype.visitMap = wrapGet(getMap);
  var instance3 = new GetVisitor();

  // ../../node_modules/apache-arrow/row/map.mjs
  var kKeys = Symbol.for("keys");
  var kVals = Symbol.for("vals");
  var MapRow = class {
    constructor(slice) {
      this[kKeys] = new Vector([slice.children[0]]).memoize();
      this[kVals] = slice.children[1];
      return new Proxy(this, new MapRowProxyHandler());
    }
    [Symbol.iterator]() {
      return new MapRowIterator(this[kKeys], this[kVals]);
    }
    get size() {
      return this[kKeys].length;
    }
    toArray() {
      return Object.values(this.toJSON());
    }
    toJSON() {
      const keys = this[kKeys];
      const vals = this[kVals];
      const json = {};
      for (let i2 = -1, n = keys.length; ++i2 < n; ) {
        json[keys.get(i2)] = instance3.visit(vals, i2);
      }
      return json;
    }
    toString() {
      return `{${[...this].map(([key, val]) => `${valueToString(key)}: ${valueToString(val)}`).join(", ")}}`;
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return this.toString();
    }
  };
  var MapRowIterator = class {
    constructor(keys, vals) {
      this.keys = keys;
      this.vals = vals;
      this.keyIndex = 0;
      this.numKeys = keys.length;
    }
    [Symbol.iterator]() {
      return this;
    }
    next() {
      const i2 = this.keyIndex;
      if (i2 === this.numKeys) {
        return { done: true, value: null };
      }
      this.keyIndex++;
      return {
        done: false,
        value: [
          this.keys.get(i2),
          instance3.visit(this.vals, i2)
        ]
      };
    }
  };
  var MapRowProxyHandler = class {
    isExtensible() {
      return false;
    }
    deleteProperty() {
      return false;
    }
    preventExtensions() {
      return true;
    }
    ownKeys(row) {
      return row[kKeys].toArray().map(String);
    }
    has(row, key) {
      return row[kKeys].includes(key);
    }
    getOwnPropertyDescriptor(row, key) {
      const idx = row[kKeys].indexOf(key);
      if (idx !== -1) {
        return { writable: true, enumerable: true, configurable: true };
      }
      return;
    }
    get(row, key) {
      if (Reflect.has(row, key)) {
        return row[key];
      }
      const idx = row[kKeys].indexOf(key);
      if (idx !== -1) {
        const val = instance3.visit(Reflect.get(row, kVals), idx);
        Reflect.set(row, key, val);
        return val;
      }
    }
    set(row, key, val) {
      const idx = row[kKeys].indexOf(key);
      if (idx !== -1) {
        instance2.visit(Reflect.get(row, kVals), idx, val);
        return Reflect.set(row, key, val);
      } else if (Reflect.has(row, key)) {
        return Reflect.set(row, key, val);
      }
      return false;
    }
  };
  Object.defineProperties(MapRow.prototype, {
    [Symbol.toStringTag]: { enumerable: false, configurable: false, value: "Row" },
    [kKeys]: { writable: true, enumerable: false, configurable: false, value: null },
    [kVals]: { writable: true, enumerable: false, configurable: false, value: null }
  });

  // ../../node_modules/apache-arrow/util/vector.mjs
  function clampIndex(source, index, then) {
    const length = source.length;
    const adjust = index > -1 ? index : length + index % length;
    return then ? then(source, adjust) : adjust;
  }
  var tmp;
  function clampRange(source, begin, end, then) {
    const { length: len2 = 0 } = source;
    let lhs = typeof begin !== "number" ? 0 : begin;
    let rhs = typeof end !== "number" ? len2 : end;
    lhs < 0 && (lhs = (lhs % len2 + len2) % len2);
    rhs < 0 && (rhs = (rhs % len2 + len2) % len2);
    rhs < lhs && (tmp = lhs, lhs = rhs, rhs = tmp);
    rhs > len2 && (rhs = len2);
    return then ? then(source, lhs, rhs) : [lhs, rhs];
  }
  var isNaNFast = (value) => value !== value;
  function createElementComparator(search) {
    const typeofSearch = typeof search;
    if (typeofSearch !== "object" || search === null) {
      if (isNaNFast(search)) {
        return isNaNFast;
      }
      return (value) => value === search;
    }
    if (search instanceof Date) {
      const valueOfSearch = search.valueOf();
      return (value) => value instanceof Date ? value.valueOf() === valueOfSearch : false;
    }
    if (ArrayBuffer.isView(search)) {
      return (value) => value ? compareArrayLike(search, value) : false;
    }
    if (search instanceof Map) {
      return createMapComparator(search);
    }
    if (Array.isArray(search)) {
      return createArrayLikeComparator(search);
    }
    if (search instanceof Vector) {
      return createVectorComparator(search);
    }
    return createObjectComparator(search, true);
  }
  function createArrayLikeComparator(lhs) {
    const comparators = [];
    for (let i2 = -1, n = lhs.length; ++i2 < n; ) {
      comparators[i2] = createElementComparator(lhs[i2]);
    }
    return createSubElementsComparator(comparators);
  }
  function createMapComparator(lhs) {
    let i2 = -1;
    const comparators = [];
    for (const v of lhs.values())
      comparators[++i2] = createElementComparator(v);
    return createSubElementsComparator(comparators);
  }
  function createVectorComparator(lhs) {
    const comparators = [];
    for (let i2 = -1, n = lhs.length; ++i2 < n; ) {
      comparators[i2] = createElementComparator(lhs.get(i2));
    }
    return createSubElementsComparator(comparators);
  }
  function createObjectComparator(lhs, allowEmpty = false) {
    const keys = Object.keys(lhs);
    if (!allowEmpty && keys.length === 0) {
      return () => false;
    }
    const comparators = [];
    for (let i2 = -1, n = keys.length; ++i2 < n; ) {
      comparators[i2] = createElementComparator(lhs[keys[i2]]);
    }
    return createSubElementsComparator(comparators, keys);
  }
  function createSubElementsComparator(comparators, keys) {
    return (rhs) => {
      if (!rhs || typeof rhs !== "object") {
        return false;
      }
      switch (rhs.constructor) {
        case Array:
          return compareArray(comparators, rhs);
        case Map:
          return compareObject(comparators, rhs, rhs.keys());
        case MapRow:
        case StructRow:
        case Object:
        case void 0:
          return compareObject(comparators, rhs, keys || Object.keys(rhs));
      }
      return rhs instanceof Vector ? compareVector(comparators, rhs) : false;
    };
  }
  function compareArray(comparators, arr) {
    const n = comparators.length;
    if (arr.length !== n) {
      return false;
    }
    for (let i2 = -1; ++i2 < n; ) {
      if (!comparators[i2](arr[i2])) {
        return false;
      }
    }
    return true;
  }
  function compareVector(comparators, vec) {
    const n = comparators.length;
    if (vec.length !== n) {
      return false;
    }
    for (let i2 = -1; ++i2 < n; ) {
      if (!comparators[i2](vec.get(i2))) {
        return false;
      }
    }
    return true;
  }
  function compareObject(comparators, obj, keys) {
    const lKeyItr = keys[Symbol.iterator]();
    const rKeyItr = obj instanceof Map ? obj.keys() : Object.keys(obj)[Symbol.iterator]();
    const rValItr = obj instanceof Map ? obj.values() : Object.values(obj)[Symbol.iterator]();
    let i2 = 0;
    const n = comparators.length;
    let rVal = rValItr.next();
    let lKey = lKeyItr.next();
    let rKey = rKeyItr.next();
    for (; i2 < n && !lKey.done && !rKey.done && !rVal.done; ++i2, lKey = lKeyItr.next(), rKey = rKeyItr.next(), rVal = rValItr.next()) {
      if (lKey.value !== rKey.value || !comparators[i2](rVal.value)) {
        break;
      }
    }
    if (i2 === n && lKey.done && rKey.done && rVal.done) {
      return true;
    }
    lKeyItr.return && lKeyItr.return();
    rKeyItr.return && rKeyItr.return();
    rValItr.return && rValItr.return();
    return false;
  }

  // ../../node_modules/apache-arrow/util/bit.mjs
  var bit_exports = {};
  __export(bit_exports, {
    BitIterator: () => BitIterator,
    getBit: () => getBit,
    getBool: () => getBool2,
    packBools: () => packBools,
    popcnt_array: () => popcnt_array,
    popcnt_bit_range: () => popcnt_bit_range,
    popcnt_uint32: () => popcnt_uint32,
    setBool: () => setBool2,
    truncateBitmap: () => truncateBitmap
  });
  function getBool2(_data, _index, byte, bit) {
    return (byte & 1 << bit) !== 0;
  }
  function getBit(_data, _index, byte, bit) {
    return (byte & 1 << bit) >> bit;
  }
  function setBool2(bytes, index, value) {
    return value ? !!(bytes[index >> 3] |= 1 << index % 8) || true : !(bytes[index >> 3] &= ~(1 << index % 8)) && false;
  }
  function truncateBitmap(offset, length, bitmap) {
    const alignedSize = bitmap.byteLength + 7 & ~7;
    if (offset > 0 || bitmap.byteLength < alignedSize) {
      const bytes = new Uint8Array(alignedSize);
      bytes.set(offset % 8 === 0 ? bitmap.subarray(offset >> 3) : (
        // Otherwise iterate each bit from the offset and return a new one
        packBools(new BitIterator(bitmap, offset, length, null, getBool2)).subarray(0, alignedSize)
      ));
      return bytes;
    }
    return bitmap;
  }
  function packBools(values) {
    const xs = [];
    let i2 = 0, bit = 0, byte = 0;
    for (const value of values) {
      value && (byte |= 1 << bit);
      if (++bit === 8) {
        xs[i2++] = byte;
        byte = bit = 0;
      }
    }
    if (i2 === 0 || bit > 0) {
      xs[i2++] = byte;
    }
    const b = new Uint8Array(xs.length + 7 & ~7);
    b.set(xs);
    return b;
  }
  var BitIterator = class {
    constructor(bytes, begin, length, context, get) {
      this.bytes = bytes;
      this.length = length;
      this.context = context;
      this.get = get;
      this.bit = begin % 8;
      this.byteIndex = begin >> 3;
      this.byte = bytes[this.byteIndex++];
      this.index = 0;
    }
    next() {
      if (this.index < this.length) {
        if (this.bit === 8) {
          this.bit = 0;
          this.byte = this.bytes[this.byteIndex++];
        }
        return {
          value: this.get(this.context, this.index++, this.byte, this.bit++)
        };
      }
      return { done: true, value: null };
    }
    [Symbol.iterator]() {
      return this;
    }
  };
  function popcnt_bit_range(data2, lhs, rhs) {
    if (rhs - lhs <= 0) {
      return 0;
    }
    if (rhs - lhs < 8) {
      let sum2 = 0;
      for (const bit of new BitIterator(data2, lhs, rhs - lhs, data2, getBit)) {
        sum2 += bit;
      }
      return sum2;
    }
    const rhsInside = rhs >> 3 << 3;
    const lhsInside = lhs + (lhs % 8 === 0 ? 0 : 8 - lhs % 8);
    return (
      // Get the popcnt of bits between the left hand side, and the next highest multiple of 8
      popcnt_bit_range(data2, lhs, lhsInside) + // Get the popcnt of bits between the right hand side, and the next lowest multiple of 8
      popcnt_bit_range(data2, rhsInside, rhs) + // Get the popcnt of all bits between the left and right hand sides' multiples of 8
      popcnt_array(data2, lhsInside >> 3, rhsInside - lhsInside >> 3)
    );
  }
  function popcnt_array(arr, byteOffset, byteLength) {
    let cnt = 0, pos = Math.trunc(byteOffset);
    const view = new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    const len2 = byteLength === void 0 ? arr.byteLength : pos + byteLength;
    while (len2 - pos >= 4) {
      cnt += popcnt_uint32(view.getUint32(pos));
      pos += 4;
    }
    while (len2 - pos >= 2) {
      cnt += popcnt_uint32(view.getUint16(pos));
      pos += 2;
    }
    while (len2 - pos >= 1) {
      cnt += popcnt_uint32(view.getUint8(pos));
      pos += 1;
    }
    return cnt;
  }
  function popcnt_uint32(uint32) {
    let i2 = Math.trunc(uint32);
    i2 = i2 - (i2 >>> 1 & 1431655765);
    i2 = (i2 & 858993459) + (i2 >>> 2 & 858993459);
    return (i2 + (i2 >>> 4) & 252645135) * 16843009 >>> 24;
  }

  // ../../node_modules/apache-arrow/data.mjs
  var kUnknownNullCount = -1;
  var Data = class _Data {
    get typeId() {
      return this.type.typeId;
    }
    get ArrayType() {
      return this.type.ArrayType;
    }
    get buffers() {
      return [this.valueOffsets, this.values, this.nullBitmap, this.typeIds];
    }
    get nullable() {
      if (this._nullCount !== 0) {
        const { type } = this;
        if (DataType.isSparseUnion(type)) {
          return this.children.some((child) => child.nullable);
        } else if (DataType.isDenseUnion(type)) {
          return this.children.some((child) => child.nullable);
        }
        return this.nullBitmap && this.nullBitmap.byteLength > 0;
      }
      return true;
    }
    get byteLength() {
      let byteLength = 0;
      const { valueOffsets, values, nullBitmap, typeIds } = this;
      valueOffsets && (byteLength += valueOffsets.byteLength);
      values && (byteLength += values.byteLength);
      nullBitmap && (byteLength += nullBitmap.byteLength);
      typeIds && (byteLength += typeIds.byteLength);
      return this.children.reduce((byteLength2, child) => byteLength2 + child.byteLength, byteLength);
    }
    get nullCount() {
      if (DataType.isUnion(this.type)) {
        return this.children.reduce((nullCount2, child) => nullCount2 + child.nullCount, 0);
      }
      let nullCount = this._nullCount;
      let nullBitmap;
      if (nullCount <= kUnknownNullCount && (nullBitmap = this.nullBitmap)) {
        this._nullCount = nullCount = this.length - popcnt_bit_range(nullBitmap, this.offset, this.offset + this.length);
      }
      return nullCount;
    }
    constructor(type, offset, length, nullCount, buffers, children = [], dictionary) {
      this.type = type;
      this.children = children;
      this.dictionary = dictionary;
      this.offset = Math.floor(Math.max(offset || 0, 0));
      this.length = Math.floor(Math.max(length || 0, 0));
      this._nullCount = Math.floor(Math.max(nullCount || 0, -1));
      let buffer;
      if (buffers instanceof _Data) {
        this.stride = buffers.stride;
        this.values = buffers.values;
        this.typeIds = buffers.typeIds;
        this.nullBitmap = buffers.nullBitmap;
        this.valueOffsets = buffers.valueOffsets;
      } else {
        this.stride = strideForType(type);
        if (buffers) {
          (buffer = buffers[0]) && (this.valueOffsets = buffer);
          (buffer = buffers[1]) && (this.values = buffer);
          (buffer = buffers[2]) && (this.nullBitmap = buffer);
          (buffer = buffers[3]) && (this.typeIds = buffer);
        }
      }
    }
    getValid(index) {
      const { type } = this;
      if (DataType.isUnion(type)) {
        const union = type;
        const child = this.children[union.typeIdToChildIndex[this.typeIds[index]]];
        const indexInChild = union.mode === UnionMode.Dense ? this.valueOffsets[index] : index;
        return child.getValid(indexInChild);
      }
      if (this.nullable && this.nullCount > 0) {
        const pos = this.offset + index;
        const val = this.nullBitmap[pos >> 3];
        return (val & 1 << pos % 8) !== 0;
      }
      return true;
    }
    setValid(index, value) {
      let prev;
      const { type } = this;
      if (DataType.isUnion(type)) {
        const union = type;
        const child = this.children[union.typeIdToChildIndex[this.typeIds[index]]];
        const indexInChild = union.mode === UnionMode.Dense ? this.valueOffsets[index] : index;
        prev = child.getValid(indexInChild);
        child.setValid(indexInChild, value);
      } else {
        let { nullBitmap } = this;
        const { offset, length } = this;
        const idx = offset + index;
        const mask = 1 << idx % 8;
        const byteOffset = idx >> 3;
        if (!nullBitmap || nullBitmap.byteLength <= byteOffset) {
          nullBitmap = new Uint8Array((offset + length + 63 & ~63) >> 3).fill(255);
          if (this.nullCount > 0) {
            nullBitmap.set(truncateBitmap(offset, length, this.nullBitmap), 0);
          }
          Object.assign(this, { nullBitmap, _nullCount: -1 });
        }
        const byte = nullBitmap[byteOffset];
        prev = (byte & mask) !== 0;
        value ? nullBitmap[byteOffset] = byte | mask : nullBitmap[byteOffset] = byte & ~mask;
      }
      if (prev !== !!value) {
        this._nullCount = this.nullCount + (value ? -1 : 1);
      }
      return value;
    }
    clone(type = this.type, offset = this.offset, length = this.length, nullCount = this._nullCount, buffers = this, children = this.children) {
      return new _Data(type, offset, length, nullCount, buffers, children, this.dictionary);
    }
    slice(offset, length) {
      const { stride, typeId, children } = this;
      const nullCount = +(this._nullCount === 0) - 1;
      const childStride = typeId === 16 ? stride : 1;
      const buffers = this._sliceBuffers(offset, length, stride, typeId);
      return this.clone(
        this.type,
        this.offset + offset,
        length,
        nullCount,
        buffers,
        // Don't slice children if we have value offsets (the variable-width types)
        children.length === 0 || this.valueOffsets ? children : this._sliceChildren(children, childStride * offset, childStride * length)
      );
    }
    _changeLengthAndBackfillNullBitmap(newLength) {
      if (this.typeId === Type.Null) {
        return this.clone(this.type, 0, newLength, 0);
      }
      const { length, nullCount } = this;
      const bitmap = new Uint8Array((newLength + 63 & ~63) >> 3).fill(255, 0, length >> 3);
      bitmap[length >> 3] = (1 << length - (length & ~7)) - 1;
      if (nullCount > 0) {
        bitmap.set(truncateBitmap(this.offset, length, this.nullBitmap), 0);
      }
      const buffers = this.buffers;
      buffers[BufferType.VALIDITY] = bitmap;
      return this.clone(this.type, 0, newLength, nullCount + (newLength - length), buffers);
    }
    _sliceBuffers(offset, length, stride, typeId) {
      let arr;
      const { buffers } = this;
      (arr = buffers[BufferType.TYPE]) && (buffers[BufferType.TYPE] = arr.subarray(offset, offset + length));
      (arr = buffers[BufferType.OFFSET]) && (buffers[BufferType.OFFSET] = arr.subarray(offset, offset + length + 1)) || // Otherwise if no offsets, slice the data buffer. Don't slice the data vector for Booleans, since the offset goes by bits not bytes
      (arr = buffers[BufferType.DATA]) && (buffers[BufferType.DATA] = typeId === 6 ? arr : arr.subarray(stride * offset, stride * (offset + length)));
      return buffers;
    }
    _sliceChildren(children, offset, length) {
      return children.map((child) => child.slice(offset, length));
    }
  };
  Data.prototype.children = Object.freeze([]);
  var MakeDataVisitor = class _MakeDataVisitor extends Visitor {
    visit(props) {
      return this.getVisitFn(props["type"]).call(this, props);
    }
    visitNull(props) {
      const { ["type"]: type, ["offset"]: offset = 0, ["length"]: length = 0 } = props;
      return new Data(type, offset, length, length);
    }
    visitBool(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const data2 = toArrayBufferView(type.ArrayType, props["data"]);
      const { ["length"]: length = data2.length >> 3, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [void 0, data2, nullBitmap]);
    }
    visitInt(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const data2 = toArrayBufferView(type.ArrayType, props["data"]);
      const { ["length"]: length = data2.length, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [void 0, data2, nullBitmap]);
    }
    visitFloat(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const data2 = toArrayBufferView(type.ArrayType, props["data"]);
      const { ["length"]: length = data2.length, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [void 0, data2, nullBitmap]);
    }
    visitUtf8(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const data2 = toUint8Array(props["data"]);
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const valueOffsets = toInt32Array(props["valueOffsets"]);
      const { ["length"]: length = valueOffsets.length - 1, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [valueOffsets, data2, nullBitmap]);
    }
    visitBinary(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const data2 = toUint8Array(props["data"]);
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const valueOffsets = toInt32Array(props["valueOffsets"]);
      const { ["length"]: length = valueOffsets.length - 1, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [valueOffsets, data2, nullBitmap]);
    }
    visitFixedSizeBinary(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const data2 = toArrayBufferView(type.ArrayType, props["data"]);
      const { ["length"]: length = data2.length / strideForType(type), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [void 0, data2, nullBitmap]);
    }
    visitDate(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const data2 = toArrayBufferView(type.ArrayType, props["data"]);
      const { ["length"]: length = data2.length / strideForType(type), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [void 0, data2, nullBitmap]);
    }
    visitTimestamp(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const data2 = toArrayBufferView(type.ArrayType, props["data"]);
      const { ["length"]: length = data2.length / strideForType(type), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [void 0, data2, nullBitmap]);
    }
    visitTime(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const data2 = toArrayBufferView(type.ArrayType, props["data"]);
      const { ["length"]: length = data2.length / strideForType(type), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [void 0, data2, nullBitmap]);
    }
    visitDecimal(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const data2 = toArrayBufferView(type.ArrayType, props["data"]);
      const { ["length"]: length = data2.length / strideForType(type), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [void 0, data2, nullBitmap]);
    }
    visitList(props) {
      const { ["type"]: type, ["offset"]: offset = 0, ["child"]: child } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const valueOffsets = toInt32Array(props["valueOffsets"]);
      const { ["length"]: length = valueOffsets.length - 1, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [valueOffsets, void 0, nullBitmap], [child]);
    }
    visitStruct(props) {
      const { ["type"]: type, ["offset"]: offset = 0, ["children"]: children = [] } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const { length = children.reduce((len2, { length: length2 }) => Math.max(len2, length2), 0), nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [void 0, void 0, nullBitmap], children);
    }
    visitUnion(props) {
      const { ["type"]: type, ["offset"]: offset = 0, ["children"]: children = [] } = props;
      const typeIds = toArrayBufferView(type.ArrayType, props["typeIds"]);
      const { ["length"]: length = typeIds.length, ["nullCount"]: nullCount = -1 } = props;
      if (DataType.isSparseUnion(type)) {
        return new Data(type, offset, length, nullCount, [void 0, void 0, void 0, typeIds], children);
      }
      const valueOffsets = toInt32Array(props["valueOffsets"]);
      return new Data(type, offset, length, nullCount, [valueOffsets, void 0, void 0, typeIds], children);
    }
    visitDictionary(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const data2 = toArrayBufferView(type.indices.ArrayType, props["data"]);
      const { ["dictionary"]: dictionary = new Vector([new _MakeDataVisitor().visit({ type: type.dictionary })]) } = props;
      const { ["length"]: length = data2.length, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [void 0, data2, nullBitmap], [], dictionary);
    }
    visitInterval(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const data2 = toArrayBufferView(type.ArrayType, props["data"]);
      const { ["length"]: length = data2.length / strideForType(type), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [void 0, data2, nullBitmap]);
    }
    visitDuration(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const data2 = toArrayBufferView(type.ArrayType, props["data"]);
      const { ["length"]: length = data2.length, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [void 0, data2, nullBitmap]);
    }
    visitFixedSizeList(props) {
      const { ["type"]: type, ["offset"]: offset = 0, ["child"]: child = new _MakeDataVisitor().visit({ type: type.valueType }) } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const { ["length"]: length = child.length / strideForType(type), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [void 0, void 0, nullBitmap], [child]);
    }
    visitMap(props) {
      const { ["type"]: type, ["offset"]: offset = 0, ["child"]: child = new _MakeDataVisitor().visit({ type: type.childType }) } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const valueOffsets = toInt32Array(props["valueOffsets"]);
      const { ["length"]: length = valueOffsets.length - 1, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [valueOffsets, void 0, nullBitmap], [child]);
    }
  };
  var makeDataVisitor = new MakeDataVisitor();
  function makeData(props) {
    return makeDataVisitor.visit(props);
  }

  // ../../node_modules/apache-arrow/util/chunk.mjs
  var ChunkedIterator = class {
    constructor(numChunks = 0, getChunkIterator) {
      this.numChunks = numChunks;
      this.getChunkIterator = getChunkIterator;
      this.chunkIndex = 0;
      this.chunkIterator = this.getChunkIterator(0);
    }
    next() {
      while (this.chunkIndex < this.numChunks) {
        const next = this.chunkIterator.next();
        if (!next.done) {
          return next;
        }
        if (++this.chunkIndex < this.numChunks) {
          this.chunkIterator = this.getChunkIterator(this.chunkIndex);
        }
      }
      return { done: true, value: null };
    }
    [Symbol.iterator]() {
      return this;
    }
  };
  function computeChunkNullCounts(chunks) {
    return chunks.reduce((nullCount, chunk) => nullCount + chunk.nullCount, 0);
  }
  function computeChunkOffsets(chunks) {
    return chunks.reduce((offsets, chunk, index) => {
      offsets[index + 1] = offsets[index] + chunk.length;
      return offsets;
    }, new Uint32Array(chunks.length + 1));
  }
  function sliceChunks(chunks, offsets, begin, end) {
    const slices = [];
    for (let i2 = -1, n = chunks.length; ++i2 < n; ) {
      const chunk = chunks[i2];
      const offset = offsets[i2];
      const { length } = chunk;
      if (offset >= end) {
        break;
      }
      if (begin >= offset + length) {
        continue;
      }
      if (offset >= begin && offset + length <= end) {
        slices.push(chunk);
        continue;
      }
      const from = Math.max(0, begin - offset);
      const to = Math.min(end - offset, length);
      slices.push(chunk.slice(from, to - from));
    }
    if (slices.length === 0) {
      slices.push(chunks[0].slice(0, 0));
    }
    return slices;
  }
  function binarySearch(chunks, offsets, idx, fn) {
    let lhs = 0, mid = 0, rhs = offsets.length - 1;
    do {
      if (lhs >= rhs - 1) {
        return idx < offsets[rhs] ? fn(chunks, lhs, idx - offsets[lhs]) : null;
      }
      mid = lhs + Math.trunc((rhs - lhs) * 0.5);
      idx < offsets[mid] ? rhs = mid : lhs = mid;
    } while (lhs < rhs);
  }
  function isChunkedValid(data2, index) {
    return data2.getValid(index);
  }
  function wrapChunkedCall1(fn) {
    function chunkedFn(chunks, i2, j) {
      return fn(chunks[i2], j);
    }
    return function(index) {
      const data2 = this.data;
      return binarySearch(data2, this._offsets, index, chunkedFn);
    };
  }
  function wrapChunkedCall2(fn) {
    let _2;
    function chunkedFn(chunks, i2, j) {
      return fn(chunks[i2], j, _2);
    }
    return function(index, value) {
      const data2 = this.data;
      _2 = value;
      const result = binarySearch(data2, this._offsets, index, chunkedFn);
      _2 = void 0;
      return result;
    };
  }
  function wrapChunkedIndexOf(indexOf) {
    let _1;
    function chunkedIndexOf(data2, chunkIndex, fromIndex) {
      let begin = fromIndex, index = 0, total = 0;
      for (let i2 = chunkIndex - 1, n = data2.length; ++i2 < n; ) {
        const chunk = data2[i2];
        if (~(index = indexOf(chunk, _1, begin))) {
          return total + index;
        }
        begin = 0;
        total += chunk.length;
      }
      return -1;
    }
    return function(element, offset) {
      _1 = element;
      const data2 = this.data;
      const result = typeof offset !== "number" ? chunkedIndexOf(data2, 0, 0) : binarySearch(data2, this._offsets, offset, chunkedIndexOf);
      _1 = void 0;
      return result;
    };
  }

  // ../../node_modules/apache-arrow/visitor/indexof.mjs
  var IndexOfVisitor = class extends Visitor {
  };
  function nullIndexOf(data2, searchElement) {
    return searchElement === null && data2.length > 0 ? 0 : -1;
  }
  function indexOfNull(data2, fromIndex) {
    const { nullBitmap } = data2;
    if (!nullBitmap || data2.nullCount <= 0) {
      return -1;
    }
    let i2 = 0;
    for (const isValid of new BitIterator(nullBitmap, data2.offset + (fromIndex || 0), data2.length, nullBitmap, getBool2)) {
      if (!isValid) {
        return i2;
      }
      ++i2;
    }
    return -1;
  }
  function indexOfValue(data2, searchElement, fromIndex) {
    if (searchElement === void 0) {
      return -1;
    }
    if (searchElement === null) {
      switch (data2.typeId) {
        case Type.Union:
          break;
        case Type.Dictionary:
          break;
        default:
          return indexOfNull(data2, fromIndex);
      }
    }
    const get = instance3.getVisitFn(data2);
    const compare = createElementComparator(searchElement);
    for (let i2 = (fromIndex || 0) - 1, n = data2.length; ++i2 < n; ) {
      if (compare(get(data2, i2))) {
        return i2;
      }
    }
    return -1;
  }
  function indexOfUnion(data2, searchElement, fromIndex) {
    const get = instance3.getVisitFn(data2);
    const compare = createElementComparator(searchElement);
    for (let i2 = (fromIndex || 0) - 1, n = data2.length; ++i2 < n; ) {
      if (compare(get(data2, i2))) {
        return i2;
      }
    }
    return -1;
  }
  IndexOfVisitor.prototype.visitNull = nullIndexOf;
  IndexOfVisitor.prototype.visitBool = indexOfValue;
  IndexOfVisitor.prototype.visitInt = indexOfValue;
  IndexOfVisitor.prototype.visitInt8 = indexOfValue;
  IndexOfVisitor.prototype.visitInt16 = indexOfValue;
  IndexOfVisitor.prototype.visitInt32 = indexOfValue;
  IndexOfVisitor.prototype.visitInt64 = indexOfValue;
  IndexOfVisitor.prototype.visitUint8 = indexOfValue;
  IndexOfVisitor.prototype.visitUint16 = indexOfValue;
  IndexOfVisitor.prototype.visitUint32 = indexOfValue;
  IndexOfVisitor.prototype.visitUint64 = indexOfValue;
  IndexOfVisitor.prototype.visitFloat = indexOfValue;
  IndexOfVisitor.prototype.visitFloat16 = indexOfValue;
  IndexOfVisitor.prototype.visitFloat32 = indexOfValue;
  IndexOfVisitor.prototype.visitFloat64 = indexOfValue;
  IndexOfVisitor.prototype.visitUtf8 = indexOfValue;
  IndexOfVisitor.prototype.visitBinary = indexOfValue;
  IndexOfVisitor.prototype.visitFixedSizeBinary = indexOfValue;
  IndexOfVisitor.prototype.visitDate = indexOfValue;
  IndexOfVisitor.prototype.visitDateDay = indexOfValue;
  IndexOfVisitor.prototype.visitDateMillisecond = indexOfValue;
  IndexOfVisitor.prototype.visitTimestamp = indexOfValue;
  IndexOfVisitor.prototype.visitTimestampSecond = indexOfValue;
  IndexOfVisitor.prototype.visitTimestampMillisecond = indexOfValue;
  IndexOfVisitor.prototype.visitTimestampMicrosecond = indexOfValue;
  IndexOfVisitor.prototype.visitTimestampNanosecond = indexOfValue;
  IndexOfVisitor.prototype.visitTime = indexOfValue;
  IndexOfVisitor.prototype.visitTimeSecond = indexOfValue;
  IndexOfVisitor.prototype.visitTimeMillisecond = indexOfValue;
  IndexOfVisitor.prototype.visitTimeMicrosecond = indexOfValue;
  IndexOfVisitor.prototype.visitTimeNanosecond = indexOfValue;
  IndexOfVisitor.prototype.visitDecimal = indexOfValue;
  IndexOfVisitor.prototype.visitList = indexOfValue;
  IndexOfVisitor.prototype.visitStruct = indexOfValue;
  IndexOfVisitor.prototype.visitUnion = indexOfValue;
  IndexOfVisitor.prototype.visitDenseUnion = indexOfUnion;
  IndexOfVisitor.prototype.visitSparseUnion = indexOfUnion;
  IndexOfVisitor.prototype.visitDictionary = indexOfValue;
  IndexOfVisitor.prototype.visitInterval = indexOfValue;
  IndexOfVisitor.prototype.visitIntervalDayTime = indexOfValue;
  IndexOfVisitor.prototype.visitIntervalYearMonth = indexOfValue;
  IndexOfVisitor.prototype.visitDuration = indexOfValue;
  IndexOfVisitor.prototype.visitDurationSecond = indexOfValue;
  IndexOfVisitor.prototype.visitDurationMillisecond = indexOfValue;
  IndexOfVisitor.prototype.visitDurationMicrosecond = indexOfValue;
  IndexOfVisitor.prototype.visitDurationNanosecond = indexOfValue;
  IndexOfVisitor.prototype.visitFixedSizeList = indexOfValue;
  IndexOfVisitor.prototype.visitMap = indexOfValue;
  var instance4 = new IndexOfVisitor();

  // ../../node_modules/apache-arrow/visitor/iterator.mjs
  var IteratorVisitor = class extends Visitor {
  };
  function vectorIterator(vector) {
    const { type } = vector;
    if (vector.nullCount === 0 && vector.stride === 1 && (type.typeId === Type.Timestamp || type instanceof Int_ && type.bitWidth !== 64 || type instanceof Time_ && type.bitWidth !== 64 || type instanceof Float && type.precision !== Precision.HALF)) {
      return new ChunkedIterator(vector.data.length, (chunkIndex) => {
        const data2 = vector.data[chunkIndex];
        return data2.values.subarray(0, data2.length)[Symbol.iterator]();
      });
    }
    let offset = 0;
    return new ChunkedIterator(vector.data.length, (chunkIndex) => {
      const data2 = vector.data[chunkIndex];
      const length = data2.length;
      const inner = vector.slice(offset, offset + length);
      offset += length;
      return new VectorIterator(inner);
    });
  }
  var VectorIterator = class {
    constructor(vector) {
      this.vector = vector;
      this.index = 0;
    }
    next() {
      if (this.index < this.vector.length) {
        return {
          value: this.vector.get(this.index++)
        };
      }
      return { done: true, value: null };
    }
    [Symbol.iterator]() {
      return this;
    }
  };
  IteratorVisitor.prototype.visitNull = vectorIterator;
  IteratorVisitor.prototype.visitBool = vectorIterator;
  IteratorVisitor.prototype.visitInt = vectorIterator;
  IteratorVisitor.prototype.visitInt8 = vectorIterator;
  IteratorVisitor.prototype.visitInt16 = vectorIterator;
  IteratorVisitor.prototype.visitInt32 = vectorIterator;
  IteratorVisitor.prototype.visitInt64 = vectorIterator;
  IteratorVisitor.prototype.visitUint8 = vectorIterator;
  IteratorVisitor.prototype.visitUint16 = vectorIterator;
  IteratorVisitor.prototype.visitUint32 = vectorIterator;
  IteratorVisitor.prototype.visitUint64 = vectorIterator;
  IteratorVisitor.prototype.visitFloat = vectorIterator;
  IteratorVisitor.prototype.visitFloat16 = vectorIterator;
  IteratorVisitor.prototype.visitFloat32 = vectorIterator;
  IteratorVisitor.prototype.visitFloat64 = vectorIterator;
  IteratorVisitor.prototype.visitUtf8 = vectorIterator;
  IteratorVisitor.prototype.visitBinary = vectorIterator;
  IteratorVisitor.prototype.visitFixedSizeBinary = vectorIterator;
  IteratorVisitor.prototype.visitDate = vectorIterator;
  IteratorVisitor.prototype.visitDateDay = vectorIterator;
  IteratorVisitor.prototype.visitDateMillisecond = vectorIterator;
  IteratorVisitor.prototype.visitTimestamp = vectorIterator;
  IteratorVisitor.prototype.visitTimestampSecond = vectorIterator;
  IteratorVisitor.prototype.visitTimestampMillisecond = vectorIterator;
  IteratorVisitor.prototype.visitTimestampMicrosecond = vectorIterator;
  IteratorVisitor.prototype.visitTimestampNanosecond = vectorIterator;
  IteratorVisitor.prototype.visitTime = vectorIterator;
  IteratorVisitor.prototype.visitTimeSecond = vectorIterator;
  IteratorVisitor.prototype.visitTimeMillisecond = vectorIterator;
  IteratorVisitor.prototype.visitTimeMicrosecond = vectorIterator;
  IteratorVisitor.prototype.visitTimeNanosecond = vectorIterator;
  IteratorVisitor.prototype.visitDecimal = vectorIterator;
  IteratorVisitor.prototype.visitList = vectorIterator;
  IteratorVisitor.prototype.visitStruct = vectorIterator;
  IteratorVisitor.prototype.visitUnion = vectorIterator;
  IteratorVisitor.prototype.visitDenseUnion = vectorIterator;
  IteratorVisitor.prototype.visitSparseUnion = vectorIterator;
  IteratorVisitor.prototype.visitDictionary = vectorIterator;
  IteratorVisitor.prototype.visitInterval = vectorIterator;
  IteratorVisitor.prototype.visitIntervalDayTime = vectorIterator;
  IteratorVisitor.prototype.visitIntervalYearMonth = vectorIterator;
  IteratorVisitor.prototype.visitDuration = vectorIterator;
  IteratorVisitor.prototype.visitDurationSecond = vectorIterator;
  IteratorVisitor.prototype.visitDurationMillisecond = vectorIterator;
  IteratorVisitor.prototype.visitDurationMicrosecond = vectorIterator;
  IteratorVisitor.prototype.visitDurationNanosecond = vectorIterator;
  IteratorVisitor.prototype.visitFixedSizeList = vectorIterator;
  IteratorVisitor.prototype.visitMap = vectorIterator;
  var instance5 = new IteratorVisitor();

  // ../../node_modules/apache-arrow/visitor/bytelength.mjs
  var sum = (x, y) => x + y;
  var GetByteLengthVisitor = class extends Visitor {
    visitNull(____, _) {
      return 0;
    }
    visitInt(data2, _) {
      return data2.type.bitWidth / 8;
    }
    visitFloat(data2, _) {
      return data2.type.ArrayType.BYTES_PER_ELEMENT;
    }
    visitBool(____, _) {
      return 1 / 8;
    }
    visitDecimal(data2, _) {
      return data2.type.bitWidth / 8;
    }
    visitDate(data2, _) {
      return (data2.type.unit + 1) * 4;
    }
    visitTime(data2, _) {
      return data2.type.bitWidth / 8;
    }
    visitTimestamp(data2, _) {
      return data2.type.unit === TimeUnit.SECOND ? 4 : 8;
    }
    visitInterval(data2, _) {
      return (data2.type.unit + 1) * 4;
    }
    visitDuration(____, _) {
      return 8;
    }
    visitStruct(data2, i2) {
      return data2.children.reduce((total, child) => total + instance6.visit(child, i2), 0);
    }
    visitFixedSizeBinary(data2, _) {
      return data2.type.byteWidth;
    }
    visitMap(data2, i2) {
      return 8 + data2.children.reduce((total, child) => total + instance6.visit(child, i2), 0);
    }
    visitDictionary(data2, i2) {
      var _a5;
      return data2.type.indices.bitWidth / 8 + (((_a5 = data2.dictionary) === null || _a5 === void 0 ? void 0 : _a5.getByteLength(data2.values[i2])) || 0);
    }
  };
  var getUtf8ByteLength = ({ valueOffsets }, index) => {
    return 8 + (valueOffsets[index + 1] - valueOffsets[index]);
  };
  var getBinaryByteLength = ({ valueOffsets }, index) => {
    return 8 + (valueOffsets[index + 1] - valueOffsets[index]);
  };
  var getListByteLength = ({ valueOffsets, stride, children }, index) => {
    const child = children[0];
    const { [index * stride]: start2 } = valueOffsets;
    const { [index * stride + 1]: end } = valueOffsets;
    const visit = instance6.getVisitFn(child.type);
    const slice = child.slice(start2, end - start2);
    let size = 8;
    for (let idx = -1, len2 = end - start2; ++idx < len2; ) {
      size += visit(slice, idx);
    }
    return size;
  };
  var getFixedSizeListByteLength = ({ stride, children }, index) => {
    const child = children[0];
    const slice = child.slice(index * stride, stride);
    const visit = instance6.getVisitFn(child.type);
    let size = 0;
    for (let idx = -1, len2 = slice.length; ++idx < len2; ) {
      size += visit(slice, idx);
    }
    return size;
  };
  var getUnionByteLength = (data2, index) => {
    return data2.type.mode === UnionMode.Dense ? getDenseUnionByteLength(data2, index) : getSparseUnionByteLength(data2, index);
  };
  var getDenseUnionByteLength = ({ type, children, typeIds, valueOffsets }, index) => {
    const childIndex = type.typeIdToChildIndex[typeIds[index]];
    return 8 + instance6.visit(children[childIndex], valueOffsets[index]);
  };
  var getSparseUnionByteLength = ({ children }, index) => {
    return 4 + instance6.visitMany(children, children.map(() => index)).reduce(sum, 0);
  };
  GetByteLengthVisitor.prototype.visitUtf8 = getUtf8ByteLength;
  GetByteLengthVisitor.prototype.visitBinary = getBinaryByteLength;
  GetByteLengthVisitor.prototype.visitList = getListByteLength;
  GetByteLengthVisitor.prototype.visitFixedSizeList = getFixedSizeListByteLength;
  GetByteLengthVisitor.prototype.visitUnion = getUnionByteLength;
  GetByteLengthVisitor.prototype.visitDenseUnion = getDenseUnionByteLength;
  GetByteLengthVisitor.prototype.visitSparseUnion = getSparseUnionByteLength;
  var instance6 = new GetByteLengthVisitor();

  // ../../node_modules/apache-arrow/vector.mjs
  var _a2;
  var visitorsByTypeId = {};
  var vectorPrototypesByTypeId = {};
  var Vector = class _Vector {
    constructor(input) {
      var _b2, _c2, _d2;
      const data2 = input[0] instanceof _Vector ? input.flatMap((x) => x.data) : input;
      if (data2.length === 0 || data2.some((x) => !(x instanceof Data))) {
        throw new TypeError("Vector constructor expects an Array of Data instances.");
      }
      const type = (_b2 = data2[0]) === null || _b2 === void 0 ? void 0 : _b2.type;
      switch (data2.length) {
        case 0:
          this._offsets = [0];
          break;
        case 1: {
          const { get, set, indexOf, byteLength } = visitorsByTypeId[type.typeId];
          const unchunkedData = data2[0];
          this.isValid = (index) => isChunkedValid(unchunkedData, index);
          this.get = (index) => get(unchunkedData, index);
          this.set = (index, value) => set(unchunkedData, index, value);
          this.indexOf = (index) => indexOf(unchunkedData, index);
          this.getByteLength = (index) => byteLength(unchunkedData, index);
          this._offsets = [0, unchunkedData.length];
          break;
        }
        default:
          Object.setPrototypeOf(this, vectorPrototypesByTypeId[type.typeId]);
          this._offsets = computeChunkOffsets(data2);
          break;
      }
      this.data = data2;
      this.type = type;
      this.stride = strideForType(type);
      this.numChildren = (_d2 = (_c2 = type.children) === null || _c2 === void 0 ? void 0 : _c2.length) !== null && _d2 !== void 0 ? _d2 : 0;
      this.length = this._offsets.at(-1);
    }
    /**
     * The aggregate size (in bytes) of this Vector's buffers and/or child Vectors.
     */
    get byteLength() {
      return this.data.reduce((byteLength, data2) => byteLength + data2.byteLength, 0);
    }
    /**
     * The number of null elements in this Vector.
     */
    get nullCount() {
      return computeChunkNullCounts(this.data);
    }
    /**
     * The Array or TypedArray constructor used for the JS representation
     *  of the element's values in {@link Vector.prototype.toArray `toArray()`}.
     */
    get ArrayType() {
      return this.type.ArrayType;
    }
    /**
     * The name that should be printed when the Vector is logged in a message.
     */
    get [Symbol.toStringTag]() {
      return `${this.VectorName}<${this.type[Symbol.toStringTag]}>`;
    }
    /**
     * The name of this Vector.
     */
    get VectorName() {
      return `${Type[this.type.typeId]}Vector`;
    }
    /**
     * Check whether an element is null.
     * @param index The index at which to read the validity bitmap.
     */
    // @ts-ignore
    isValid(index) {
      return false;
    }
    /**
     * Get an element value by position.
     * @param index The index of the element to read.
     */
    // @ts-ignore
    get(index) {
      return null;
    }
    /**
     * Set an element value by position.
     * @param index The index of the element to write.
     * @param value The value to set.
     */
    // @ts-ignore
    set(index, value) {
      return;
    }
    /**
     * Retrieve the index of the first occurrence of a value in an Vector.
     * @param element The value to locate in the Vector.
     * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.
     */
    // @ts-ignore
    indexOf(element, offset) {
      return -1;
    }
    includes(element, offset) {
      return this.indexOf(element, offset) > -1;
    }
    /**
     * Get the size in bytes of an element by index.
     * @param index The index at which to get the byteLength.
     */
    // @ts-ignore
    getByteLength(index) {
      return 0;
    }
    /**
     * Iterator for the Vector's elements.
     */
    [Symbol.iterator]() {
      return instance5.visit(this);
    }
    /**
     * Combines two or more Vectors of the same type.
     * @param others Additional Vectors to add to the end of this Vector.
     */
    concat(...others) {
      return new _Vector(this.data.concat(others.flatMap((x) => x.data).flat(Number.POSITIVE_INFINITY)));
    }
    /**
     * Return a zero-copy sub-section of this Vector.
     * @param start The beginning of the specified portion of the Vector.
     * @param end The end of the specified portion of the Vector. This is exclusive of the element at the index 'end'.
     */
    slice(begin, end) {
      return new _Vector(clampRange(this, begin, end, ({ data: data2, _offsets }, begin2, end2) => sliceChunks(data2, _offsets, begin2, end2)));
    }
    toJSON() {
      return [...this];
    }
    /**
     * Return a JavaScript Array or TypedArray of the Vector's elements.
     *
     * @note If this Vector contains a single Data chunk and the Vector's type is a
     *  primitive numeric type corresponding to one of the JavaScript TypedArrays, this
     *  method returns a zero-copy slice of the underlying TypedArray values. If there's
     *  more than one chunk, the resulting TypedArray will be a copy of the data from each
     *  chunk's underlying TypedArray values.
     *
     * @returns An Array or TypedArray of the Vector's elements, based on the Vector's DataType.
     */
    toArray() {
      const { type, data: data2, length, stride, ArrayType } = this;
      switch (type.typeId) {
        case Type.Int:
        case Type.Float:
        case Type.Decimal:
        case Type.Time:
        case Type.Timestamp:
          switch (data2.length) {
            case 0:
              return new ArrayType();
            case 1:
              return data2[0].values.subarray(0, length * stride);
            default:
              return data2.reduce((memo, { values, length: chunk_length }) => {
                memo.array.set(values.subarray(0, chunk_length * stride), memo.offset);
                memo.offset += chunk_length * stride;
                return memo;
              }, { array: new ArrayType(length * stride), offset: 0 }).array;
          }
      }
      return [...this];
    }
    /**
     * Returns a string representation of the Vector.
     *
     * @returns A string representation of the Vector.
     */
    toString() {
      return `[${[...this].join(",")}]`;
    }
    /**
     * Returns a child Vector by name, or null if this Vector has no child with the given name.
     * @param name The name of the child to retrieve.
     */
    getChild(name2) {
      var _b2;
      return this.getChildAt((_b2 = this.type.children) === null || _b2 === void 0 ? void 0 : _b2.findIndex((f) => f.name === name2));
    }
    /**
     * Returns a child Vector by index, or null if this Vector has no child at the supplied index.
     * @param index The index of the child to retrieve.
     */
    getChildAt(index) {
      if (index > -1 && index < this.numChildren) {
        return new _Vector(this.data.map(({ children }) => children[index]));
      }
      return null;
    }
    get isMemoized() {
      if (DataType.isDictionary(this.type)) {
        return this.data[0].dictionary.isMemoized;
      }
      return false;
    }
    /**
     * Adds memoization to the Vector's {@link get} method. For dictionary
     * vectors, this method return a vector that memoizes only the dictionary
     * values.
     *
     * Memoization is very useful when decoding a value is expensive such as
     * Uft8. The memoization creates a cache of the size of the Vector and
     * therfore increases memory usage.
     *
     * @returns A new vector that memoizes calls to {@link get}.
     */
    memoize() {
      if (DataType.isDictionary(this.type)) {
        const dictionary = new MemoizedVector(this.data[0].dictionary);
        const newData = this.data.map((data2) => {
          const cloned = data2.clone();
          cloned.dictionary = dictionary;
          return cloned;
        });
        return new _Vector(newData);
      }
      return new MemoizedVector(this);
    }
    /**
     * Returns a vector without memoization of the {@link get} method. If this
     * vector is not memoized, this method returns this vector.
     *
     * @returns A a vector without memoization.
     */
    unmemoize() {
      if (DataType.isDictionary(this.type) && this.isMemoized) {
        const dictionary = this.data[0].dictionary.unmemoize();
        const newData = this.data.map((data2) => {
          const newData2 = data2.clone();
          newData2.dictionary = dictionary;
          return newData2;
        });
        return new _Vector(newData);
      }
      return this;
    }
  };
  _a2 = Symbol.toStringTag;
  Vector[_a2] = ((proto) => {
    proto.type = DataType.prototype;
    proto.data = [];
    proto.length = 0;
    proto.stride = 1;
    proto.numChildren = 0;
    proto._offsets = new Uint32Array([0]);
    proto[Symbol.isConcatSpreadable] = true;
    const typeIds = Object.keys(Type).map((T) => Type[T]).filter((T) => typeof T === "number" && T !== Type.NONE);
    for (const typeId of typeIds) {
      const get = instance3.getVisitFnByTypeId(typeId);
      const set = instance2.getVisitFnByTypeId(typeId);
      const indexOf = instance4.getVisitFnByTypeId(typeId);
      const byteLength = instance6.getVisitFnByTypeId(typeId);
      visitorsByTypeId[typeId] = { get, set, indexOf, byteLength };
      vectorPrototypesByTypeId[typeId] = Object.create(proto, {
        ["isValid"]: { value: wrapChunkedCall1(isChunkedValid) },
        ["get"]: { value: wrapChunkedCall1(instance3.getVisitFnByTypeId(typeId)) },
        ["set"]: { value: wrapChunkedCall2(instance2.getVisitFnByTypeId(typeId)) },
        ["indexOf"]: { value: wrapChunkedIndexOf(instance4.getVisitFnByTypeId(typeId)) },
        ["getByteLength"]: { value: wrapChunkedCall1(instance6.getVisitFnByTypeId(typeId)) }
      });
    }
    return "Vector";
  })(Vector.prototype);
  var MemoizedVector = class _MemoizedVector extends Vector {
    constructor(vector) {
      super(vector.data);
      const get = this.get;
      const set = this.set;
      const slice = this.slice;
      const cache = new Array(this.length);
      Object.defineProperty(this, "get", {
        value(index) {
          const cachedValue = cache[index];
          if (cachedValue !== void 0) {
            return cachedValue;
          }
          const value = get.call(this, index);
          cache[index] = value;
          return value;
        }
      });
      Object.defineProperty(this, "set", {
        value(index, value) {
          set.call(this, index, value);
          cache[index] = value;
        }
      });
      Object.defineProperty(this, "slice", {
        value: (begin, end) => new _MemoizedVector(slice.call(this, begin, end))
      });
      Object.defineProperty(this, "isMemoized", { value: true });
      Object.defineProperty(this, "unmemoize", {
        value: () => new Vector(this.data)
      });
      Object.defineProperty(this, "memoize", {
        value: () => this
      });
    }
  };
  function makeVector(init2) {
    if (init2) {
      if (init2 instanceof Data) {
        return new Vector([init2]);
      }
      if (init2 instanceof Vector) {
        return new Vector(init2.data);
      }
      if (init2.type instanceof DataType) {
        return new Vector([makeData(init2)]);
      }
      if (Array.isArray(init2)) {
        return new Vector(init2.flatMap((v) => unwrapInputs(v)));
      }
      if (ArrayBuffer.isView(init2)) {
        if (init2 instanceof DataView) {
          init2 = new Uint8Array(init2.buffer);
        }
        const props = { offset: 0, length: init2.length, nullCount: 0, data: init2 };
        if (init2 instanceof Int8Array) {
          return new Vector([makeData(Object.assign(Object.assign({}, props), { type: new Int8() }))]);
        }
        if (init2 instanceof Int16Array) {
          return new Vector([makeData(Object.assign(Object.assign({}, props), { type: new Int16() }))]);
        }
        if (init2 instanceof Int32Array) {
          return new Vector([makeData(Object.assign(Object.assign({}, props), { type: new Int32() }))]);
        }
        if (init2 instanceof BigInt64Array) {
          return new Vector([makeData(Object.assign(Object.assign({}, props), { type: new Int64() }))]);
        }
        if (init2 instanceof Uint8Array || init2 instanceof Uint8ClampedArray) {
          return new Vector([makeData(Object.assign(Object.assign({}, props), { type: new Uint8() }))]);
        }
        if (init2 instanceof Uint16Array) {
          return new Vector([makeData(Object.assign(Object.assign({}, props), { type: new Uint16() }))]);
        }
        if (init2 instanceof Uint32Array) {
          return new Vector([makeData(Object.assign(Object.assign({}, props), { type: new Uint32() }))]);
        }
        if (init2 instanceof BigUint64Array) {
          return new Vector([makeData(Object.assign(Object.assign({}, props), { type: new Uint64() }))]);
        }
        if (init2 instanceof Float32Array) {
          return new Vector([makeData(Object.assign(Object.assign({}, props), { type: new Float32() }))]);
        }
        if (init2 instanceof Float64Array) {
          return new Vector([makeData(Object.assign(Object.assign({}, props), { type: new Float64() }))]);
        }
        throw new Error("Unrecognized input");
      }
    }
    throw new Error("Unrecognized input");
  }
  function unwrapInputs(x) {
    return x instanceof Data ? [x] : x instanceof Vector ? x.data : makeVector(x).data;
  }

  // ../../node_modules/apache-arrow/builder/valid.mjs
  function createIsValidFunction(nullValues) {
    if (!nullValues || nullValues.length <= 0) {
      return function isValid(value) {
        return true;
      };
    }
    let fnBody = "";
    const noNaNs = nullValues.filter((x) => x === x);
    if (noNaNs.length > 0) {
      fnBody = `
    switch (x) {${noNaNs.map((x) => `
        case ${valueToCase(x)}:`).join("")}
            return false;
    }`;
    }
    if (nullValues.length !== noNaNs.length) {
      fnBody = `if (x !== x) return false;
${fnBody}`;
    }
    return new Function(`x`, `${fnBody}
return true;`);
  }
  function valueToCase(x) {
    if (typeof x !== "bigint") {
      return valueToString(x);
    }
    return `${valueToString(x)}n`;
  }

  // ../../node_modules/apache-arrow/builder/buffer.mjs
  var roundLengthUpToNearest64Bytes = (len2, BPE) => (Math.ceil(len2) * BPE + 63 & ~63 || 64) / BPE;
  var sliceOrExtendArray = (arr, len2 = 0) => arr.length >= len2 ? arr.subarray(0, len2) : memcpy(new arr.constructor(len2), arr, 0);
  var BufferBuilder = class {
    constructor(buffer, stride = 1) {
      this.buffer = buffer;
      this.stride = stride;
      this.BYTES_PER_ELEMENT = buffer.BYTES_PER_ELEMENT;
      this.ArrayType = buffer.constructor;
      this._resize(this.length = Math.ceil(buffer.length / stride));
    }
    get byteLength() {
      return Math.ceil(this.length * this.stride) * this.BYTES_PER_ELEMENT;
    }
    get reservedLength() {
      return this.buffer.length / this.stride;
    }
    get reservedByteLength() {
      return this.buffer.byteLength;
    }
    // @ts-ignore
    set(index, value) {
      return this;
    }
    append(value) {
      return this.set(this.length, value);
    }
    reserve(extra) {
      if (extra > 0) {
        this.length += extra;
        const stride = this.stride;
        const length = this.length * stride;
        const reserved = this.buffer.length;
        if (length >= reserved) {
          this._resize(reserved === 0 ? roundLengthUpToNearest64Bytes(length * 1, this.BYTES_PER_ELEMENT) : roundLengthUpToNearest64Bytes(length * 2, this.BYTES_PER_ELEMENT));
        }
      }
      return this;
    }
    flush(length = this.length) {
      length = roundLengthUpToNearest64Bytes(length * this.stride, this.BYTES_PER_ELEMENT);
      const array = sliceOrExtendArray(this.buffer, length);
      this.clear();
      return array;
    }
    clear() {
      this.length = 0;
      this._resize(0);
      return this;
    }
    _resize(newLength) {
      return this.buffer = memcpy(new this.ArrayType(newLength), this.buffer);
    }
  };
  BufferBuilder.prototype.offset = 0;
  var DataBufferBuilder = class extends BufferBuilder {
    last() {
      return this.get(this.length - 1);
    }
    get(index) {
      return this.buffer[index];
    }
    set(index, value) {
      this.reserve(index - this.length + 1);
      this.buffer[index * this.stride] = value;
      return this;
    }
  };
  var BitmapBufferBuilder = class extends DataBufferBuilder {
    constructor(data2 = new Uint8Array(0)) {
      super(data2, 1 / 8);
      this.numValid = 0;
    }
    get numInvalid() {
      return this.length - this.numValid;
    }
    get(idx) {
      return this.buffer[idx >> 3] >> idx % 8 & 1;
    }
    set(idx, val) {
      const { buffer } = this.reserve(idx - this.length + 1);
      const byte = idx >> 3, bit = idx % 8, cur = buffer[byte] >> bit & 1;
      val ? cur === 0 && (buffer[byte] |= 1 << bit, ++this.numValid) : cur === 1 && (buffer[byte] &= ~(1 << bit), --this.numValid);
      return this;
    }
    clear() {
      this.numValid = 0;
      return super.clear();
    }
  };
  var OffsetsBufferBuilder = class extends DataBufferBuilder {
    constructor(data2 = new Int32Array(1)) {
      super(data2, 1);
    }
    append(value) {
      return this.set(this.length - 1, value);
    }
    set(index, value) {
      const offset = this.length - 1;
      const buffer = this.reserve(index - offset + 1).buffer;
      if (offset < index++) {
        buffer.fill(buffer[offset], offset, index);
      }
      buffer[index] = buffer[index - 1] + value;
      return this;
    }
    flush(length = this.length - 1) {
      if (length > this.length) {
        this.set(length - 1, 0);
      }
      return super.flush(length + 1);
    }
  };

  // ../../node_modules/apache-arrow/builder.mjs
  var Builder = class {
    /** @nocollapse */
    // @ts-ignore
    static throughNode(options) {
      throw new Error(`"throughNode" not available in this environment`);
    }
    /** @nocollapse */
    // @ts-ignore
    static throughDOM(options) {
      throw new Error(`"throughDOM" not available in this environment`);
    }
    /**
     * Construct a builder with the given Arrow DataType with optional null values,
     * which will be interpreted as "null" when set or appended to the `Builder`.
     * @param {{ type: T, nullValues?: any[] }} options A `BuilderOptions` object used to create this `Builder`.
     */
    constructor({ "type": type, "nullValues": nulls }) {
      this.length = 0;
      this.finished = false;
      this.type = type;
      this.children = [];
      this.nullValues = nulls;
      this.stride = strideForType(type);
      this._nulls = new BitmapBufferBuilder();
      if (nulls && nulls.length > 0) {
        this._isValid = createIsValidFunction(nulls);
      }
    }
    /**
     * Flush the `Builder` and return a `Vector<T>`.
     * @returns {Vector<T>} A `Vector<T>` of the flushed values.
     */
    toVector() {
      return new Vector([this.flush()]);
    }
    get ArrayType() {
      return this.type.ArrayType;
    }
    get nullCount() {
      return this._nulls.numInvalid;
    }
    get numChildren() {
      return this.children.length;
    }
    /**
     * @returns The aggregate length (in bytes) of the values that have been written.
     */
    get byteLength() {
      let size = 0;
      const { _offsets, _values, _nulls, _typeIds, children } = this;
      _offsets && (size += _offsets.byteLength);
      _values && (size += _values.byteLength);
      _nulls && (size += _nulls.byteLength);
      _typeIds && (size += _typeIds.byteLength);
      return children.reduce((size2, child) => size2 + child.byteLength, size);
    }
    /**
     * @returns The aggregate number of rows that have been reserved to write new values.
     */
    get reservedLength() {
      return this._nulls.reservedLength;
    }
    /**
     * @returns The aggregate length (in bytes) that has been reserved to write new values.
     */
    get reservedByteLength() {
      let size = 0;
      this._offsets && (size += this._offsets.reservedByteLength);
      this._values && (size += this._values.reservedByteLength);
      this._nulls && (size += this._nulls.reservedByteLength);
      this._typeIds && (size += this._typeIds.reservedByteLength);
      return this.children.reduce((size2, child) => size2 + child.reservedByteLength, size);
    }
    get valueOffsets() {
      return this._offsets ? this._offsets.buffer : null;
    }
    get values() {
      return this._values ? this._values.buffer : null;
    }
    get nullBitmap() {
      return this._nulls ? this._nulls.buffer : null;
    }
    get typeIds() {
      return this._typeIds ? this._typeIds.buffer : null;
    }
    /**
     * Appends a value (or null) to this `Builder`.
     * This is equivalent to `builder.set(builder.length, value)`.
     * @param {T['TValue'] | TNull } value The value to append.
     */
    append(value) {
      return this.set(this.length, value);
    }
    /**
     * Validates whether a value is valid (true), or null (false)
     * @param {T['TValue'] | TNull } value The value to compare against null the value representations
     */
    isValid(value) {
      return this._isValid(value);
    }
    /**
     * Write a value (or null-value sentinel) at the supplied index.
     * If the value matches one of the null-value representations, a 1-bit is
     * written to the null `BitmapBufferBuilder`. Otherwise, a 0 is written to
     * the null `BitmapBufferBuilder`, and the value is passed to
     * `Builder.prototype.setValue()`.
     * @param {number} index The index of the value to write.
     * @param {T['TValue'] | TNull } value The value to write at the supplied index.
     * @returns {this} The updated `Builder` instance.
     */
    set(index, value) {
      if (this.setValid(index, this.isValid(value))) {
        this.setValue(index, value);
      }
      return this;
    }
    /**
     * Write a value to the underlying buffers at the supplied index, bypassing
     * the null-value check. This is a low-level method that
     * @param {number} index
     * @param {T['TValue'] | TNull } value
     */
    setValue(index, value) {
      this._setValue(this, index, value);
    }
    setValid(index, valid) {
      this.length = this._nulls.set(index, +valid).length;
      return valid;
    }
    // @ts-ignore
    addChild(child, name2 = `${this.numChildren}`) {
      throw new Error(`Cannot append children to non-nested type "${this.type}"`);
    }
    /**
     * Retrieve the child `Builder` at the supplied `index`, or null if no child
     * exists at that index.
     * @param {number} index The index of the child `Builder` to retrieve.
     * @returns {Builder | null} The child Builder at the supplied index or null.
     */
    getChildAt(index) {
      return this.children[index] || null;
    }
    /**
     * Commit all the values that have been written to their underlying
     * ArrayBuffers, including any child Builders if applicable, and reset
     * the internal `Builder` state.
     * @returns A `Data<T>` of the buffers and children representing the values written.
     */
    flush() {
      let data2;
      let typeIds;
      let nullBitmap;
      let valueOffsets;
      const { type, length, nullCount, _typeIds, _offsets, _values, _nulls } = this;
      if (typeIds = _typeIds === null || _typeIds === void 0 ? void 0 : _typeIds.flush(length)) {
        valueOffsets = _offsets === null || _offsets === void 0 ? void 0 : _offsets.flush(length);
      } else if (valueOffsets = _offsets === null || _offsets === void 0 ? void 0 : _offsets.flush(length)) {
        data2 = _values === null || _values === void 0 ? void 0 : _values.flush(_offsets.last());
      } else {
        data2 = _values === null || _values === void 0 ? void 0 : _values.flush(length);
      }
      if (nullCount > 0) {
        nullBitmap = _nulls === null || _nulls === void 0 ? void 0 : _nulls.flush(length);
      }
      const children = this.children.map((child) => child.flush());
      this.clear();
      return makeData({
        type,
        length,
        nullCount,
        children,
        "child": children[0],
        data: data2,
        typeIds,
        nullBitmap,
        valueOffsets
      });
    }
    /**
     * Finalize this `Builder`, and child builders if applicable.
     * @returns {this} The finalized `Builder` instance.
     */
    finish() {
      this.finished = true;
      for (const child of this.children)
        child.finish();
      return this;
    }
    /**
     * Clear this Builder's internal state, including child Builders if applicable, and reset the length to 0.
     * @returns {this} The cleared `Builder` instance.
     */
    clear() {
      var _a5, _b2, _c2, _d2;
      this.length = 0;
      (_a5 = this._nulls) === null || _a5 === void 0 ? void 0 : _a5.clear();
      (_b2 = this._values) === null || _b2 === void 0 ? void 0 : _b2.clear();
      (_c2 = this._offsets) === null || _c2 === void 0 ? void 0 : _c2.clear();
      (_d2 = this._typeIds) === null || _d2 === void 0 ? void 0 : _d2.clear();
      for (const child of this.children)
        child.clear();
      return this;
    }
  };
  Builder.prototype.length = 1;
  Builder.prototype.stride = 1;
  Builder.prototype.children = null;
  Builder.prototype.finished = false;
  Builder.prototype.nullValues = null;
  Builder.prototype._isValid = () => true;
  var FixedWidthBuilder = class extends Builder {
    constructor(opts) {
      super(opts);
      this._values = new DataBufferBuilder(new this.ArrayType(0), this.stride);
    }
    setValue(index, value) {
      const values = this._values;
      values.reserve(index - values.length + 1);
      return super.setValue(index, value);
    }
  };
  var VariableWidthBuilder = class extends Builder {
    constructor(opts) {
      super(opts);
      this._pendingLength = 0;
      this._offsets = new OffsetsBufferBuilder();
    }
    setValue(index, value) {
      const pending = this._pending || (this._pending = /* @__PURE__ */ new Map());
      const current = pending.get(index);
      current && (this._pendingLength -= current.length);
      this._pendingLength += value instanceof MapRow ? value[kKeys].length : value.length;
      pending.set(index, value);
    }
    setValid(index, isValid) {
      if (!super.setValid(index, isValid)) {
        (this._pending || (this._pending = /* @__PURE__ */ new Map())).set(index, void 0);
        return false;
      }
      return true;
    }
    clear() {
      this._pendingLength = 0;
      this._pending = void 0;
      return super.clear();
    }
    flush() {
      this._flush();
      return super.flush();
    }
    finish() {
      this._flush();
      return super.finish();
    }
    _flush() {
      const pending = this._pending;
      const pendingLength = this._pendingLength;
      this._pendingLength = 0;
      this._pending = void 0;
      if (pending && pending.size > 0) {
        this._flushPending(pending, pendingLength);
      }
      return this;
    }
  };

  // ../../node_modules/apache-arrow/fb/block.mjs
  var Block = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i2, bb) {
      this.bb_pos = i2;
      this.bb = bb;
      return this;
    }
    /**
     * Index to the start of the RecordBlock (note this is past the Message header)
     */
    offset() {
      return this.bb.readInt64(this.bb_pos);
    }
    /**
     * Length of the metadata
     */
    metaDataLength() {
      return this.bb.readInt32(this.bb_pos + 8);
    }
    /**
     * Length of the data (this is aligned so there can be a gap between this and
     * the metadata).
     */
    bodyLength() {
      return this.bb.readInt64(this.bb_pos + 16);
    }
    static sizeOf() {
      return 24;
    }
    static createBlock(builder, offset, metaDataLength, bodyLength) {
      builder.prep(8, 24);
      builder.writeInt64(BigInt(bodyLength !== null && bodyLength !== void 0 ? bodyLength : 0));
      builder.pad(4);
      builder.writeInt32(metaDataLength);
      builder.writeInt64(BigInt(offset !== null && offset !== void 0 ? offset : 0));
      return builder.offset();
    }
  };

  // ../../node_modules/apache-arrow/node_modules/flatbuffers/mjs/constants.js
  var SIZEOF_SHORT = 2;
  var SIZEOF_INT = 4;
  var FILE_IDENTIFIER_LENGTH = 4;
  var SIZE_PREFIX_LENGTH = 4;

  // ../../node_modules/apache-arrow/node_modules/flatbuffers/mjs/utils.js
  var int32 = new Int32Array(2);
  var float32 = new Float32Array(int32.buffer);
  var float64 = new Float64Array(int32.buffer);
  var isLittleEndian = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;

  // ../../node_modules/apache-arrow/node_modules/flatbuffers/mjs/encoding.js
  var Encoding;
  (function(Encoding2) {
    Encoding2[Encoding2["UTF8_BYTES"] = 1] = "UTF8_BYTES";
    Encoding2[Encoding2["UTF16_STRING"] = 2] = "UTF16_STRING";
  })(Encoding || (Encoding = {}));

  // ../../node_modules/apache-arrow/node_modules/flatbuffers/mjs/byte-buffer.js
  var ByteBuffer = class _ByteBuffer {
    /**
     * Create a new ByteBuffer with a given array of bytes (`Uint8Array`)
     */
    constructor(bytes_) {
      this.bytes_ = bytes_;
      this.position_ = 0;
      this.text_decoder_ = new TextDecoder();
    }
    /**
     * Create and allocate a new ByteBuffer with a given size.
     */
    static allocate(byte_size) {
      return new _ByteBuffer(new Uint8Array(byte_size));
    }
    clear() {
      this.position_ = 0;
    }
    /**
     * Get the underlying `Uint8Array`.
     */
    bytes() {
      return this.bytes_;
    }
    /**
     * Get the buffer's position.
     */
    position() {
      return this.position_;
    }
    /**
     * Set the buffer's position.
     */
    setPosition(position) {
      this.position_ = position;
    }
    /**
     * Get the buffer's capacity.
     */
    capacity() {
      return this.bytes_.length;
    }
    readInt8(offset) {
      return this.readUint8(offset) << 24 >> 24;
    }
    readUint8(offset) {
      return this.bytes_[offset];
    }
    readInt16(offset) {
      return this.readUint16(offset) << 16 >> 16;
    }
    readUint16(offset) {
      return this.bytes_[offset] | this.bytes_[offset + 1] << 8;
    }
    readInt32(offset) {
      return this.bytes_[offset] | this.bytes_[offset + 1] << 8 | this.bytes_[offset + 2] << 16 | this.bytes_[offset + 3] << 24;
    }
    readUint32(offset) {
      return this.readInt32(offset) >>> 0;
    }
    readInt64(offset) {
      return BigInt.asIntN(64, BigInt(this.readUint32(offset)) + (BigInt(this.readUint32(offset + 4)) << BigInt(32)));
    }
    readUint64(offset) {
      return BigInt.asUintN(64, BigInt(this.readUint32(offset)) + (BigInt(this.readUint32(offset + 4)) << BigInt(32)));
    }
    readFloat32(offset) {
      int32[0] = this.readInt32(offset);
      return float32[0];
    }
    readFloat64(offset) {
      int32[isLittleEndian ? 0 : 1] = this.readInt32(offset);
      int32[isLittleEndian ? 1 : 0] = this.readInt32(offset + 4);
      return float64[0];
    }
    writeInt8(offset, value) {
      this.bytes_[offset] = value;
    }
    writeUint8(offset, value) {
      this.bytes_[offset] = value;
    }
    writeInt16(offset, value) {
      this.bytes_[offset] = value;
      this.bytes_[offset + 1] = value >> 8;
    }
    writeUint16(offset, value) {
      this.bytes_[offset] = value;
      this.bytes_[offset + 1] = value >> 8;
    }
    writeInt32(offset, value) {
      this.bytes_[offset] = value;
      this.bytes_[offset + 1] = value >> 8;
      this.bytes_[offset + 2] = value >> 16;
      this.bytes_[offset + 3] = value >> 24;
    }
    writeUint32(offset, value) {
      this.bytes_[offset] = value;
      this.bytes_[offset + 1] = value >> 8;
      this.bytes_[offset + 2] = value >> 16;
      this.bytes_[offset + 3] = value >> 24;
    }
    writeInt64(offset, value) {
      this.writeInt32(offset, Number(BigInt.asIntN(32, value)));
      this.writeInt32(offset + 4, Number(BigInt.asIntN(32, value >> BigInt(32))));
    }
    writeUint64(offset, value) {
      this.writeUint32(offset, Number(BigInt.asUintN(32, value)));
      this.writeUint32(offset + 4, Number(BigInt.asUintN(32, value >> BigInt(32))));
    }
    writeFloat32(offset, value) {
      float32[0] = value;
      this.writeInt32(offset, int32[0]);
    }
    writeFloat64(offset, value) {
      float64[0] = value;
      this.writeInt32(offset, int32[isLittleEndian ? 0 : 1]);
      this.writeInt32(offset + 4, int32[isLittleEndian ? 1 : 0]);
    }
    /**
     * Return the file identifier.   Behavior is undefined for FlatBuffers whose
     * schema does not include a file_identifier (likely points at padding or the
     * start of a the root vtable).
     */
    getBufferIdentifier() {
      if (this.bytes_.length < this.position_ + SIZEOF_INT + FILE_IDENTIFIER_LENGTH) {
        throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");
      }
      let result = "";
      for (let i2 = 0; i2 < FILE_IDENTIFIER_LENGTH; i2++) {
        result += String.fromCharCode(this.readInt8(this.position_ + SIZEOF_INT + i2));
      }
      return result;
    }
    /**
     * Look up a field in the vtable, return an offset into the object, or 0 if the
     * field is not present.
     */
    __offset(bb_pos, vtable_offset) {
      const vtable = bb_pos - this.readInt32(bb_pos);
      return vtable_offset < this.readInt16(vtable) ? this.readInt16(vtable + vtable_offset) : 0;
    }
    /**
     * Initialize any Table-derived type to point to the union at the given offset.
     */
    __union(t, offset) {
      t.bb_pos = offset + this.readInt32(offset);
      t.bb = this;
      return t;
    }
    /**
     * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.
     * This allocates a new string and converts to wide chars upon each access.
     *
     * To avoid the conversion to string, pass Encoding.UTF8_BYTES as the
     * "optionalEncoding" argument. This is useful for avoiding conversion when
     * the data will just be packaged back up in another FlatBuffer later on.
     *
     * @param offset
     * @param opt_encoding Defaults to UTF16_STRING
     */
    __string(offset, opt_encoding) {
      offset += this.readInt32(offset);
      const length = this.readInt32(offset);
      offset += SIZEOF_INT;
      const utf8bytes = this.bytes_.subarray(offset, offset + length);
      if (opt_encoding === Encoding.UTF8_BYTES)
        return utf8bytes;
      else
        return this.text_decoder_.decode(utf8bytes);
    }
    /**
     * Handle unions that can contain string as its member, if a Table-derived type then initialize it,
     * if a string then return a new one
     *
     * WARNING: strings are immutable in JS so we can't change the string that the user gave us, this
     * makes the behaviour of __union_with_string different compared to __union
     */
    __union_with_string(o, offset) {
      if (typeof o === "string") {
        return this.__string(offset);
      }
      return this.__union(o, offset);
    }
    /**
     * Retrieve the relative offset stored at "offset"
     */
    __indirect(offset) {
      return offset + this.readInt32(offset);
    }
    /**
     * Get the start of data of a vector whose offset is stored at "offset" in this object.
     */
    __vector(offset) {
      return offset + this.readInt32(offset) + SIZEOF_INT;
    }
    /**
     * Get the length of a vector whose offset is stored at "offset" in this object.
     */
    __vector_len(offset) {
      return this.readInt32(offset + this.readInt32(offset));
    }
    __has_identifier(ident) {
      if (ident.length != FILE_IDENTIFIER_LENGTH) {
        throw new Error("FlatBuffers: file identifier must be length " + FILE_IDENTIFIER_LENGTH);
      }
      for (let i2 = 0; i2 < FILE_IDENTIFIER_LENGTH; i2++) {
        if (ident.charCodeAt(i2) != this.readInt8(this.position() + SIZEOF_INT + i2)) {
          return false;
        }
      }
      return true;
    }
    /**
     * A helper function for generating list for obj api
     */
    createScalarList(listAccessor, listLength) {
      const ret = [];
      for (let i2 = 0; i2 < listLength; ++i2) {
        const val = listAccessor(i2);
        if (val !== null) {
          ret.push(val);
        }
      }
      return ret;
    }
    /**
     * A helper function for generating list for obj api
     * @param listAccessor function that accepts an index and return data at that index
     * @param listLength listLength
     * @param res result list
     */
    createObjList(listAccessor, listLength) {
      const ret = [];
      for (let i2 = 0; i2 < listLength; ++i2) {
        const val = listAccessor(i2);
        if (val !== null) {
          ret.push(val.unpack());
        }
      }
      return ret;
    }
  };

  // ../../node_modules/apache-arrow/node_modules/flatbuffers/mjs/builder.js
  var Builder2 = class _Builder {
    /**
     * Create a FlatBufferBuilder.
     */
    constructor(opt_initial_size) {
      this.minalign = 1;
      this.vtable = null;
      this.vtable_in_use = 0;
      this.isNested = false;
      this.object_start = 0;
      this.vtables = [];
      this.vector_num_elems = 0;
      this.force_defaults = false;
      this.string_maps = null;
      this.text_encoder = new TextEncoder();
      let initial_size;
      if (!opt_initial_size) {
        initial_size = 1024;
      } else {
        initial_size = opt_initial_size;
      }
      this.bb = ByteBuffer.allocate(initial_size);
      this.space = initial_size;
    }
    clear() {
      this.bb.clear();
      this.space = this.bb.capacity();
      this.minalign = 1;
      this.vtable = null;
      this.vtable_in_use = 0;
      this.isNested = false;
      this.object_start = 0;
      this.vtables = [];
      this.vector_num_elems = 0;
      this.force_defaults = false;
      this.string_maps = null;
    }
    /**
     * In order to save space, fields that are set to their default value
     * don't get serialized into the buffer. Forcing defaults provides a
     * way to manually disable this optimization.
     *
     * @param forceDefaults true always serializes default values
     */
    forceDefaults(forceDefaults) {
      this.force_defaults = forceDefaults;
    }
    /**
     * Get the ByteBuffer representing the FlatBuffer. Only call this after you've
     * called finish(). The actual data starts at the ByteBuffer's current position,
     * not necessarily at 0.
     */
    dataBuffer() {
      return this.bb;
    }
    /**
     * Get the bytes representing the FlatBuffer. Only call this after you've
     * called finish().
     */
    asUint8Array() {
      return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());
    }
    /**
     * Prepare to write an element of `size` after `additional_bytes` have been
     * written, e.g. if you write a string, you need to align such the int length
     * field is aligned to 4 bytes, and the string data follows it directly. If all
     * you need to do is alignment, `additional_bytes` will be 0.
     *
     * @param size This is the of the new element to write
     * @param additional_bytes The padding size
     */
    prep(size, additional_bytes) {
      if (size > this.minalign) {
        this.minalign = size;
      }
      const align_size = ~(this.bb.capacity() - this.space + additional_bytes) + 1 & size - 1;
      while (this.space < align_size + size + additional_bytes) {
        const old_buf_size = this.bb.capacity();
        this.bb = _Builder.growByteBuffer(this.bb);
        this.space += this.bb.capacity() - old_buf_size;
      }
      this.pad(align_size);
    }
    pad(byte_size) {
      for (let i2 = 0; i2 < byte_size; i2++) {
        this.bb.writeInt8(--this.space, 0);
      }
    }
    writeInt8(value) {
      this.bb.writeInt8(this.space -= 1, value);
    }
    writeInt16(value) {
      this.bb.writeInt16(this.space -= 2, value);
    }
    writeInt32(value) {
      this.bb.writeInt32(this.space -= 4, value);
    }
    writeInt64(value) {
      this.bb.writeInt64(this.space -= 8, value);
    }
    writeFloat32(value) {
      this.bb.writeFloat32(this.space -= 4, value);
    }
    writeFloat64(value) {
      this.bb.writeFloat64(this.space -= 8, value);
    }
    /**
     * Add an `int8` to the buffer, properly aligned, and grows the buffer (if necessary).
     * @param value The `int8` to add the buffer.
     */
    addInt8(value) {
      this.prep(1, 0);
      this.writeInt8(value);
    }
    /**
     * Add an `int16` to the buffer, properly aligned, and grows the buffer (if necessary).
     * @param value The `int16` to add the buffer.
     */
    addInt16(value) {
      this.prep(2, 0);
      this.writeInt16(value);
    }
    /**
     * Add an `int32` to the buffer, properly aligned, and grows the buffer (if necessary).
     * @param value The `int32` to add the buffer.
     */
    addInt32(value) {
      this.prep(4, 0);
      this.writeInt32(value);
    }
    /**
     * Add an `int64` to the buffer, properly aligned, and grows the buffer (if necessary).
     * @param value The `int64` to add the buffer.
     */
    addInt64(value) {
      this.prep(8, 0);
      this.writeInt64(value);
    }
    /**
     * Add a `float32` to the buffer, properly aligned, and grows the buffer (if necessary).
     * @param value The `float32` to add the buffer.
     */
    addFloat32(value) {
      this.prep(4, 0);
      this.writeFloat32(value);
    }
    /**
     * Add a `float64` to the buffer, properly aligned, and grows the buffer (if necessary).
     * @param value The `float64` to add the buffer.
     */
    addFloat64(value) {
      this.prep(8, 0);
      this.writeFloat64(value);
    }
    addFieldInt8(voffset, value, defaultValue) {
      if (this.force_defaults || value != defaultValue) {
        this.addInt8(value);
        this.slot(voffset);
      }
    }
    addFieldInt16(voffset, value, defaultValue) {
      if (this.force_defaults || value != defaultValue) {
        this.addInt16(value);
        this.slot(voffset);
      }
    }
    addFieldInt32(voffset, value, defaultValue) {
      if (this.force_defaults || value != defaultValue) {
        this.addInt32(value);
        this.slot(voffset);
      }
    }
    addFieldInt64(voffset, value, defaultValue) {
      if (this.force_defaults || value !== defaultValue) {
        this.addInt64(value);
        this.slot(voffset);
      }
    }
    addFieldFloat32(voffset, value, defaultValue) {
      if (this.force_defaults || value != defaultValue) {
        this.addFloat32(value);
        this.slot(voffset);
      }
    }
    addFieldFloat64(voffset, value, defaultValue) {
      if (this.force_defaults || value != defaultValue) {
        this.addFloat64(value);
        this.slot(voffset);
      }
    }
    addFieldOffset(voffset, value, defaultValue) {
      if (this.force_defaults || value != defaultValue) {
        this.addOffset(value);
        this.slot(voffset);
      }
    }
    /**
     * Structs are stored inline, so nothing additional is being added. `d` is always 0.
     */
    addFieldStruct(voffset, value, defaultValue) {
      if (value != defaultValue) {
        this.nested(value);
        this.slot(voffset);
      }
    }
    /**
     * Structures are always stored inline, they need to be created right
     * where they're used.  You'll get this assertion failure if you
     * created it elsewhere.
     */
    nested(obj) {
      if (obj != this.offset()) {
        throw new TypeError("FlatBuffers: struct must be serialized inline.");
      }
    }
    /**
     * Should not be creating any other object, string or vector
     * while an object is being constructed
     */
    notNested() {
      if (this.isNested) {
        throw new TypeError("FlatBuffers: object serialization must not be nested.");
      }
    }
    /**
     * Set the current vtable at `voffset` to the current location in the buffer.
     */
    slot(voffset) {
      if (this.vtable !== null)
        this.vtable[voffset] = this.offset();
    }
    /**
     * @returns Offset relative to the end of the buffer.
     */
    offset() {
      return this.bb.capacity() - this.space;
    }
    /**
     * Doubles the size of the backing ByteBuffer and copies the old data towards
     * the end of the new buffer (since we build the buffer backwards).
     *
     * @param bb The current buffer with the existing data
     * @returns A new byte buffer with the old data copied
     * to it. The data is located at the end of the buffer.
     *
     * uint8Array.set() formally takes {Array<number>|ArrayBufferView}, so to pass
     * it a uint8Array we need to suppress the type check:
     * @suppress {checkTypes}
     */
    static growByteBuffer(bb) {
      const old_buf_size = bb.capacity();
      if (old_buf_size & 3221225472) {
        throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");
      }
      const new_buf_size = old_buf_size << 1;
      const nbb = ByteBuffer.allocate(new_buf_size);
      nbb.setPosition(new_buf_size - old_buf_size);
      nbb.bytes().set(bb.bytes(), new_buf_size - old_buf_size);
      return nbb;
    }
    /**
     * Adds on offset, relative to where it will be written.
     *
     * @param offset The offset to add.
     */
    addOffset(offset) {
      this.prep(SIZEOF_INT, 0);
      this.writeInt32(this.offset() - offset + SIZEOF_INT);
    }
    /**
     * Start encoding a new object in the buffer.  Users will not usually need to
     * call this directly. The FlatBuffers compiler will generate helper methods
     * that call this method internally.
     */
    startObject(numfields) {
      this.notNested();
      if (this.vtable == null) {
        this.vtable = [];
      }
      this.vtable_in_use = numfields;
      for (let i2 = 0; i2 < numfields; i2++) {
        this.vtable[i2] = 0;
      }
      this.isNested = true;
      this.object_start = this.offset();
    }
    /**
     * Finish off writing the object that is under construction.
     *
     * @returns The offset to the object inside `dataBuffer`
     */
    endObject() {
      if (this.vtable == null || !this.isNested) {
        throw new Error("FlatBuffers: endObject called without startObject");
      }
      this.addInt32(0);
      const vtableloc = this.offset();
      let i2 = this.vtable_in_use - 1;
      for (; i2 >= 0 && this.vtable[i2] == 0; i2--) {
      }
      const trimmed_size = i2 + 1;
      for (; i2 >= 0; i2--) {
        this.addInt16(this.vtable[i2] != 0 ? vtableloc - this.vtable[i2] : 0);
      }
      const standard_fields = 2;
      this.addInt16(vtableloc - this.object_start);
      const len2 = (trimmed_size + standard_fields) * SIZEOF_SHORT;
      this.addInt16(len2);
      let existing_vtable = 0;
      const vt1 = this.space;
      outer_loop:
        for (i2 = 0; i2 < this.vtables.length; i2++) {
          const vt2 = this.bb.capacity() - this.vtables[i2];
          if (len2 == this.bb.readInt16(vt2)) {
            for (let j = SIZEOF_SHORT; j < len2; j += SIZEOF_SHORT) {
              if (this.bb.readInt16(vt1 + j) != this.bb.readInt16(vt2 + j)) {
                continue outer_loop;
              }
            }
            existing_vtable = this.vtables[i2];
            break;
          }
        }
      if (existing_vtable) {
        this.space = this.bb.capacity() - vtableloc;
        this.bb.writeInt32(this.space, existing_vtable - vtableloc);
      } else {
        this.vtables.push(this.offset());
        this.bb.writeInt32(this.bb.capacity() - vtableloc, this.offset() - vtableloc);
      }
      this.isNested = false;
      return vtableloc;
    }
    /**
     * Finalize a buffer, poiting to the given `root_table`.
     */
    finish(root_table, opt_file_identifier, opt_size_prefix) {
      const size_prefix = opt_size_prefix ? SIZE_PREFIX_LENGTH : 0;
      if (opt_file_identifier) {
        const file_identifier = opt_file_identifier;
        this.prep(this.minalign, SIZEOF_INT + FILE_IDENTIFIER_LENGTH + size_prefix);
        if (file_identifier.length != FILE_IDENTIFIER_LENGTH) {
          throw new TypeError("FlatBuffers: file identifier must be length " + FILE_IDENTIFIER_LENGTH);
        }
        for (let i2 = FILE_IDENTIFIER_LENGTH - 1; i2 >= 0; i2--) {
          this.writeInt8(file_identifier.charCodeAt(i2));
        }
      }
      this.prep(this.minalign, SIZEOF_INT + size_prefix);
      this.addOffset(root_table);
      if (size_prefix) {
        this.addInt32(this.bb.capacity() - this.space);
      }
      this.bb.setPosition(this.space);
    }
    /**
     * Finalize a size prefixed buffer, pointing to the given `root_table`.
     */
    finishSizePrefixed(root_table, opt_file_identifier) {
      this.finish(root_table, opt_file_identifier, true);
    }
    /**
     * This checks a required field has been set in a given table that has
     * just been constructed.
     */
    requiredField(table, field) {
      const table_start = this.bb.capacity() - table;
      const vtable_start = table_start - this.bb.readInt32(table_start);
      const ok = field < this.bb.readInt16(vtable_start) && this.bb.readInt16(vtable_start + field) != 0;
      if (!ok) {
        throw new TypeError("FlatBuffers: field " + field + " must be set");
      }
    }
    /**
     * Start a new array/vector of objects.  Users usually will not call
     * this directly. The FlatBuffers compiler will create a start/end
     * method for vector types in generated code.
     *
     * @param elem_size The size of each element in the array
     * @param num_elems The number of elements in the array
     * @param alignment The alignment of the array
     */
    startVector(elem_size, num_elems, alignment) {
      this.notNested();
      this.vector_num_elems = num_elems;
      this.prep(SIZEOF_INT, elem_size * num_elems);
      this.prep(alignment, elem_size * num_elems);
    }
    /**
     * Finish off the creation of an array and all its elements. The array must be
     * created with `startVector`.
     *
     * @returns The offset at which the newly created array
     * starts.
     */
    endVector() {
      this.writeInt32(this.vector_num_elems);
      return this.offset();
    }
    /**
     * Encode the string `s` in the buffer using UTF-8. If the string passed has
     * already been seen, we return the offset of the already written string
     *
     * @param s The string to encode
     * @return The offset in the buffer where the encoded string starts
     */
    createSharedString(s2) {
      if (!s2) {
        return 0;
      }
      if (!this.string_maps) {
        this.string_maps = /* @__PURE__ */ new Map();
      }
      if (this.string_maps.has(s2)) {
        return this.string_maps.get(s2);
      }
      const offset = this.createString(s2);
      this.string_maps.set(s2, offset);
      return offset;
    }
    /**
     * Encode the string `s` in the buffer using UTF-8. If a Uint8Array is passed
     * instead of a string, it is assumed to contain valid UTF-8 encoded data.
     *
     * @param s The string to encode
     * @return The offset in the buffer where the encoded string starts
     */
    createString(s2) {
      if (s2 === null || s2 === void 0) {
        return 0;
      }
      let utf8;
      if (s2 instanceof Uint8Array) {
        utf8 = s2;
      } else {
        utf8 = this.text_encoder.encode(s2);
      }
      this.addInt8(0);
      this.startVector(1, utf8.length, 1);
      this.bb.setPosition(this.space -= utf8.length);
      for (let i2 = 0, offset = this.space, bytes = this.bb.bytes(); i2 < utf8.length; i2++) {
        bytes[offset++] = utf8[i2];
      }
      return this.endVector();
    }
    /**
     * A helper function to pack an object
     *
     * @returns offset of obj
     */
    createObjectOffset(obj) {
      if (obj === null) {
        return 0;
      }
      if (typeof obj === "string") {
        return this.createString(obj);
      } else {
        return obj.pack(this);
      }
    }
    /**
     * A helper function to pack a list of object
     *
     * @returns list of offsets of each non null object
     */
    createObjectOffsetList(list) {
      const ret = [];
      for (let i2 = 0; i2 < list.length; ++i2) {
        const val = list[i2];
        if (val !== null) {
          ret.push(this.createObjectOffset(val));
        } else {
          throw new TypeError("FlatBuffers: Argument for createObjectOffsetList cannot contain null.");
        }
      }
      return ret;
    }
    createStructOffsetList(list, startFunc) {
      startFunc(this, list.length);
      this.createObjectOffsetList(list.slice().reverse());
      return this.endVector();
    }
  };

  // ../../node_modules/apache-arrow/fb/key-value.mjs
  var KeyValue = class _KeyValue {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i2, bb) {
      this.bb_pos = i2;
      this.bb = bb;
      return this;
    }
    static getRootAsKeyValue(bb, obj) {
      return (obj || new _KeyValue()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsKeyValue(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new _KeyValue()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    key(optionalEncoding) {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    value(optionalEncoding) {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    static startKeyValue(builder) {
      builder.startObject(2);
    }
    static addKey(builder, keyOffset) {
      builder.addFieldOffset(0, keyOffset, 0);
    }
    static addValue(builder, valueOffset) {
      builder.addFieldOffset(1, valueOffset, 0);
    }
    static endKeyValue(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createKeyValue(builder, keyOffset, valueOffset) {
      _KeyValue.startKeyValue(builder);
      _KeyValue.addKey(builder, keyOffset);
      _KeyValue.addValue(builder, valueOffset);
      return _KeyValue.endKeyValue(builder);
    }
  };

  // ../../node_modules/apache-arrow/fb/metadata-version.mjs
  var MetadataVersion2;
  (function(MetadataVersion3) {
    MetadataVersion3[MetadataVersion3["V1"] = 0] = "V1";
    MetadataVersion3[MetadataVersion3["V2"] = 1] = "V2";
    MetadataVersion3[MetadataVersion3["V3"] = 2] = "V3";
    MetadataVersion3[MetadataVersion3["V4"] = 3] = "V4";
    MetadataVersion3[MetadataVersion3["V5"] = 4] = "V5";
  })(MetadataVersion2 || (MetadataVersion2 = {}));

  // ../../node_modules/apache-arrow/fb/endianness.mjs
  var Endianness;
  (function(Endianness2) {
    Endianness2[Endianness2["Little"] = 0] = "Little";
    Endianness2[Endianness2["Big"] = 1] = "Big";
  })(Endianness || (Endianness = {}));

  // ../../node_modules/apache-arrow/fb/dictionary-kind.mjs
  var DictionaryKind;
  (function(DictionaryKind2) {
    DictionaryKind2[DictionaryKind2["DenseArray"] = 0] = "DenseArray";
  })(DictionaryKind || (DictionaryKind = {}));

  // ../../node_modules/apache-arrow/fb/int.mjs
  var Int = class _Int {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i2, bb) {
      this.bb_pos = i2;
      this.bb = bb;
      return this;
    }
    static getRootAsInt(bb, obj) {
      return (obj || new _Int()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsInt(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new _Int()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    bitWidth() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    isSigned() {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    static startInt(builder) {
      builder.startObject(2);
    }
    static addBitWidth(builder, bitWidth) {
      builder.addFieldInt32(0, bitWidth, 0);
    }
    static addIsSigned(builder, isSigned) {
      builder.addFieldInt8(1, +isSigned, 0);
    }
    static endInt(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createInt(builder, bitWidth, isSigned) {
      _Int.startInt(builder);
      _Int.addBitWidth(builder, bitWidth);
      _Int.addIsSigned(builder, isSigned);
      return _Int.endInt(builder);
    }
  };

  // ../../node_modules/apache-arrow/fb/dictionary-encoding.mjs
  var DictionaryEncoding = class _DictionaryEncoding {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i2, bb) {
      this.bb_pos = i2;
      this.bb = bb;
      return this;
    }
    static getRootAsDictionaryEncoding(bb, obj) {
      return (obj || new _DictionaryEncoding()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsDictionaryEncoding(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new _DictionaryEncoding()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    /**
     * The known dictionary id in the application where this data is used. In
     * the file or streaming formats, the dictionary ids are found in the
     * DictionaryBatch messages
     */
    id() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt64(this.bb_pos + offset) : BigInt("0");
    }
    /**
     * The dictionary indices are constrained to be non-negative integers. If
     * this field is null, the indices must be signed int32. To maximize
     * cross-language compatibility and performance, implementations are
     * recommended to prefer signed integer types over unsigned integer types
     * and to avoid uint64 indices unless they are required by an application.
     */
    indexType(obj) {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? (obj || new Int()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    /**
     * By default, dictionaries are not ordered, or the order does not have
     * semantic meaning. In some statistical, applications, dictionary-encoding
     * is used to represent ordered categorical data, and we provide a way to
     * preserve that metadata here
     */
    isOrdered() {
      const offset = this.bb.__offset(this.bb_pos, 8);
      return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    dictionaryKind() {
      const offset = this.bb.__offset(this.bb_pos, 10);
      return offset ? this.bb.readInt16(this.bb_pos + offset) : DictionaryKind.DenseArray;
    }
    static startDictionaryEncoding(builder) {
      builder.startObject(4);
    }
    static addId(builder, id) {
      builder.addFieldInt64(0, id, BigInt("0"));
    }
    static addIndexType(builder, indexTypeOffset) {
      builder.addFieldOffset(1, indexTypeOffset, 0);
    }
    static addIsOrdered(builder, isOrdered) {
      builder.addFieldInt8(2, +isOrdered, 0);
    }
    static addDictionaryKind(builder, dictionaryKind) {
      builder.addFieldInt16(3, dictionaryKind, DictionaryKind.DenseArray);
    }
    static endDictionaryEncoding(builder) {
      const offset = builder.endObject();
      return offset;
    }
  };

  // ../../node_modules/apache-arrow/fb/binary.mjs
  var Binary2 = class _Binary {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i2, bb) {
      this.bb_pos = i2;
      this.bb = bb;
      return this;
    }
    static getRootAsBinary(bb, obj) {
      return (obj || new _Binary()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsBinary(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new _Binary()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static startBinary(builder) {
      builder.startObject(0);
    }
    static endBinary(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createBinary(builder) {
      _Binary.startBinary(builder);
      return _Binary.endBinary(builder);
    }
  };

  // ../../node_modules/apache-arrow/fb/bool.mjs
  var Bool2 = class _Bool {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i2, bb) {
      this.bb_pos = i2;
      this.bb = bb;
      return this;
    }
    static getRootAsBool(bb, obj) {
      return (obj || new _Bool()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsBool(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new _Bool()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static startBool(builder) {
      builder.startObject(0);
    }
    static endBool(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createBool(builder) {
      _Bool.startBool(builder);
      return _Bool.endBool(builder);
    }
  };

  // ../../node_modules/apache-arrow/fb/date-unit.mjs
  var DateUnit2;
  (function(DateUnit3) {
    DateUnit3[DateUnit3["DAY"] = 0] = "DAY";
    DateUnit3[DateUnit3["MILLISECOND"] = 1] = "MILLISECOND";
  })(DateUnit2 || (DateUnit2 = {}));

  // ../../node_modules/apache-arrow/fb/date.mjs
  var Date2 = class _Date {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i2, bb) {
      this.bb_pos = i2;
      this.bb = bb;
      return this;
    }
    static getRootAsDate(bb, obj) {
      return (obj || new _Date()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsDate(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new _Date()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    unit() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt16(this.bb_pos + offset) : DateUnit2.MILLISECOND;
    }
    static startDate(builder) {
      builder.startObject(1);
    }
    static addUnit(builder, unit) {
      builder.addFieldInt16(0, unit, DateUnit2.MILLISECOND);
    }
    static endDate(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createDate(builder, unit) {
      _Date.startDate(builder);
      _Date.addUnit(builder, unit);
      return _Date.endDate(builder);
    }
  };

  // ../../node_modules/apache-arrow/fb/decimal.mjs
  var Decimal2 = class _Decimal {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i2, bb) {
      this.bb_pos = i2;
      this.bb = bb;
      return this;
    }
    static getRootAsDecimal(bb, obj) {
      return (obj || new _Decimal()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsDecimal(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new _Decimal()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    /**
     * Total number of decimal digits
     */
    precision() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    /**
     * Number of digits after the decimal point "."
     */
    scale() {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    /**
     * Number of bits per value. The only accepted widths are 128 and 256.
     * We use bitWidth for consistency with Int::bitWidth.
     */
    bitWidth() {
      const offset = this.bb.__offset(this.bb_pos, 8);
      return offset ? this.bb.readInt32(this.bb_pos + offset) : 128;
    }
    static startDecimal(builder) {
      builder.startObject(3);
    }
    static addPrecision(builder, precision) {
      builder.addFieldInt32(0, precision, 0);
    }
    static addScale(builder, scale) {
      builder.addFieldInt32(1, scale, 0);
    }
    static addBitWidth(builder, bitWidth) {
      builder.addFieldInt32(2, bitWidth, 128);
    }
    static endDecimal(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createDecimal(builder, precision, scale, bitWidth) {
      _Decimal.startDecimal(builder);
      _Decimal.addPrecision(builder, precision);
      _Decimal.addScale(builder, scale);
      _Decimal.addBitWidth(builder, bitWidth);
      return _Decimal.endDecimal(builder);
    }
  };

  // ../../node_modules/apache-arrow/fb/time-unit.mjs
  var TimeUnit2;
  (function(TimeUnit3) {
    TimeUnit3[TimeUnit3["SECOND"] = 0] = "SECOND";
    TimeUnit3[TimeUnit3["MILLISECOND"] = 1] = "MILLISECOND";
    TimeUnit3[TimeUnit3["MICROSECOND"] = 2] = "MICROSECOND";
    TimeUnit3[TimeUnit3["NANOSECOND"] = 3] = "NANOSECOND";
  })(TimeUnit2 || (TimeUnit2 = {}));

  // ../../node_modules/apache-arrow/fb/duration.mjs
  var Duration2 = class _Duration {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i2, bb) {
      this.bb_pos = i2;
      this.bb = bb;
      return this;
    }
    static getRootAsDuration(bb, obj) {
      return (obj || new _Duration()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsDuration(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new _Duration()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    unit() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt16(this.bb_pos + offset) : TimeUnit2.MILLISECOND;
    }
    static startDuration(builder) {
      builder.startObject(1);
    }
    static addUnit(builder, unit) {
      builder.addFieldInt16(0, unit, TimeUnit2.MILLISECOND);
    }
    static endDuration(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createDuration(builder, unit) {
      _Duration.startDuration(builder);
      _Duration.addUnit(builder, unit);
      return _Duration.endDuration(builder);
    }
  };

  // ../../node_modules/apache-arrow/fb/fixed-size-binary.mjs
  var FixedSizeBinary2 = class _FixedSizeBinary {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i2, bb) {
      this.bb_pos = i2;
      this.bb = bb;
      return this;
    }
    static getRootAsFixedSizeBinary(bb, obj) {
      return (obj || new _FixedSizeBinary()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsFixedSizeBinary(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new _FixedSizeBinary()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    /**
     * Number of bytes per value
     */
    byteWidth() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    static startFixedSizeBinary(builder) {
      builder.startObject(1);
    }
    static addByteWidth(builder, byteWidth) {
      builder.addFieldInt32(0, byteWidth, 0);
    }
    static endFixedSizeBinary(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createFixedSizeBinary(builder, byteWidth) {
      _FixedSizeBinary.startFixedSizeBinary(builder);
      _FixedSizeBinary.addByteWidth(builder, byteWidth);
      return _FixedSizeBinary.endFixedSizeBinary(builder);
    }
  };

  // ../../node_modules/apache-arrow/fb/fixed-size-list.mjs
  var FixedSizeList2 = class _FixedSizeList {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i2, bb) {
      this.bb_pos = i2;
      this.bb = bb;
      return this;
    }
    static getRootAsFixedSizeList(bb, obj) {
      return (obj || new _FixedSizeList()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsFixedSizeList(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new _FixedSizeList()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    /**
     * Number of list items per value
     */
    listSize() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    static startFixedSizeList(builder) {
      builder.startObject(1);
    }
    static addListSize(builder, listSize) {
      builder.addFieldInt32(0, listSize, 0);
    }
    static endFixedSizeList(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createFixedSizeList(builder, listSize) {
      _FixedSizeList.startFixedSizeList(builder);
      _FixedSizeList.addListSize(builder, listSize);
      return _FixedSizeList.endFixedSizeList(builder);
    }
  };

  // ../../node_modules/apache-arrow/fb/precision.mjs
  var Precision2;
  (function(Precision3) {
    Precision3[Precision3["HALF"] = 0] = "HALF";
    Precision3[Precision3["SINGLE"] = 1] = "SINGLE";
    Precision3[Precision3["DOUBLE"] = 2] = "DOUBLE";
  })(Precision2 || (Precision2 = {}));

  // ../../node_modules/apache-arrow/fb/floating-point.mjs
  var FloatingPoint = class _FloatingPoint {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i2, bb) {
      this.bb_pos = i2;
      this.bb = bb;
      return this;
    }
    static getRootAsFloatingPoint(bb, obj) {
      return (obj || new _FloatingPoint()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsFloatingPoint(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new _FloatingPoint()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    precision() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt16(this.bb_pos + offset) : Precision2.HALF;
    }
    static startFloatingPoint(builder) {
      builder.startObject(1);
    }
    static addPrecision(builder, precision) {
      builder.addFieldInt16(0, precision, Precision2.HALF);
    }
    static endFloatingPoint(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createFloatingPoint(builder, precision) {
      _FloatingPoint.startFloatingPoint(builder);
      _FloatingPoint.addPrecision(builder, precision);
      return _FloatingPoint.endFloatingPoint(builder);
    }
  };

  // ../../node_modules/apache-arrow/fb/interval-unit.mjs
  var IntervalUnit2;
  (function(IntervalUnit3) {
    IntervalUnit3[IntervalUnit3["YEAR_MONTH"] = 0] = "YEAR_MONTH";
    IntervalUnit3[IntervalUnit3["DAY_TIME"] = 1] = "DAY_TIME";
    IntervalUnit3[IntervalUnit3["MONTH_DAY_NANO"] = 2] = "MONTH_DAY_NANO";
  })(IntervalUnit2 || (IntervalUnit2 = {}));

  // ../../node_modules/apache-arrow/fb/interval.mjs
  var Interval = class _Interval {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i2, bb) {
      this.bb_pos = i2;
      this.bb = bb;
      return this;
    }
    static getRootAsInterval(bb, obj) {
      return (obj || new _Interval()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsInterval(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new _Interval()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    unit() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt16(this.bb_pos + offset) : IntervalUnit2.YEAR_MONTH;
    }
    static startInterval(builder) {
      builder.startObject(1);
    }
    static addUnit(builder, unit) {
      builder.addFieldInt16(0, unit, IntervalUnit2.YEAR_MONTH);
    }
    static endInterval(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createInterval(builder, unit) {
      _Interval.startInterval(builder);
      _Interval.addUnit(builder, unit);
      return _Interval.endInterval(builder);
    }
  };

  // ../../node_modules/apache-arrow/fb/list.mjs
  var List2 = class _List {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i2, bb) {
      this.bb_pos = i2;
      this.bb = bb;
      return this;
    }
    static getRootAsList(bb, obj) {
      return (obj || new _List()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsList(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new _List()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static startList(builder) {
      builder.startObject(0);
    }
    static endList(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createList(builder) {
      _List.startList(builder);
      return _List.endList(builder);
    }
  };

  // ../../node_modules/apache-arrow/fb/map.mjs
  var Map2 = class _Map {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i2, bb) {
      this.bb_pos = i2;
      this.bb = bb;
      return this;
    }
    static getRootAsMap(bb, obj) {
      return (obj || new _Map()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsMap(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new _Map()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    /**
     * Set to true if the keys within each value are sorted
     */
    keysSorted() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    static startMap(builder) {
      builder.startObject(1);
    }
    static addKeysSorted(builder, keysSorted) {
      builder.addFieldInt8(0, +keysSorted, 0);
    }
    static endMap(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createMap(builder, keysSorted) {
      _Map.startMap(builder);
      _Map.addKeysSorted(builder, keysSorted);
      return _Map.endMap(builder);
    }
  };

  // ../../node_modules/apache-arrow/fb/null.mjs
  var Null2 = class _Null {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i2, bb) {
      this.bb_pos = i2;
      this.bb = bb;
      return this;
    }
    static getRootAsNull(bb, obj) {
      return (obj || new _Null()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsNull(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new _Null()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static startNull(builder) {
      builder.startObject(0);
    }
    static endNull(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createNull(builder) {
      _Null.startNull(builder);
      return _Null.endNull(builder);
    }
  };

  // ../../node_modules/apache-arrow/fb/struct-.mjs
  var Struct_ = class _Struct_ {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i2, bb) {
      this.bb_pos = i2;
      this.bb = bb;
      return this;
    }
    static getRootAsStruct_(bb, obj) {
      return (obj || new _Struct_()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsStruct_(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new _Struct_()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static startStruct_(builder) {
      builder.startObject(0);
    }
    static endStruct_(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createStruct_(builder) {
      _Struct_.startStruct_(builder);
      return _Struct_.endStruct_(builder);
    }
  };

  // ../../node_modules/apache-arrow/fb/time.mjs
  var Time = class _Time {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i2, bb) {
      this.bb_pos = i2;
      this.bb = bb;
      return this;
    }
    static getRootAsTime(bb, obj) {
      return (obj || new _Time()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsTime(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new _Time()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    unit() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt16(this.bb_pos + offset) : TimeUnit2.MILLISECOND;
    }
    bitWidth() {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? this.bb.readInt32(this.bb_pos + offset) : 32;
    }
    static startTime(builder) {
      builder.startObject(2);
    }
    static addUnit(builder, unit) {
      builder.addFieldInt16(0, unit, TimeUnit2.MILLISECOND);
    }
    static addBitWidth(builder, bitWidth) {
      builder.addFieldInt32(1, bitWidth, 32);
    }
    static endTime(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createTime(builder, unit, bitWidth) {
      _Time.startTime(builder);
      _Time.addUnit(builder, unit);
      _Time.addBitWidth(builder, bitWidth);
      return _Time.endTime(builder);
    }
  };

  // ../../node_modules/apache-arrow/fb/timestamp.mjs
  var Timestamp = class _Timestamp {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i2, bb) {
      this.bb_pos = i2;
      this.bb = bb;
      return this;
    }
    static getRootAsTimestamp(bb, obj) {
      return (obj || new _Timestamp()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsTimestamp(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new _Timestamp()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    unit() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt16(this.bb_pos + offset) : TimeUnit2.SECOND;
    }
    timezone(optionalEncoding) {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    static startTimestamp(builder) {
      builder.startObject(2);
    }
    static addUnit(builder, unit) {
      builder.addFieldInt16(0, unit, TimeUnit2.SECOND);
    }
    static addTimezone(builder, timezoneOffset) {
      builder.addFieldOffset(1, timezoneOffset, 0);
    }
    static endTimestamp(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createTimestamp(builder, unit, timezoneOffset) {
      _Timestamp.startTimestamp(builder);
      _Timestamp.addUnit(builder, unit);
      _Timestamp.addTimezone(builder, timezoneOffset);
      return _Timestamp.endTimestamp(builder);
    }
  };

  // ../../node_modules/apache-arrow/fb/union-mode.mjs
  var UnionMode2;
  (function(UnionMode3) {
    UnionMode3[UnionMode3["Sparse"] = 0] = "Sparse";
    UnionMode3[UnionMode3["Dense"] = 1] = "Dense";
  })(UnionMode2 || (UnionMode2 = {}));

  // ../../node_modules/apache-arrow/fb/union.mjs
  var Union = class _Union {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i2, bb) {
      this.bb_pos = i2;
      this.bb = bb;
      return this;
    }
    static getRootAsUnion(bb, obj) {
      return (obj || new _Union()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsUnion(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new _Union()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    mode() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt16(this.bb_pos + offset) : UnionMode2.Sparse;
    }
    typeIds(index) {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? this.bb.readInt32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
    }
    typeIdsLength() {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    typeIdsArray() {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    static startUnion(builder) {
      builder.startObject(2);
    }
    static addMode(builder, mode) {
      builder.addFieldInt16(0, mode, UnionMode2.Sparse);
    }
    static addTypeIds(builder, typeIdsOffset) {
      builder.addFieldOffset(1, typeIdsOffset, 0);
    }
    static createTypeIdsVector(builder, data2) {
      builder.startVector(4, data2.length, 4);
      for (let i2 = data2.length - 1; i2 >= 0; i2--) {
        builder.addInt32(data2[i2]);
      }
      return builder.endVector();
    }
    static startTypeIdsVector(builder, numElems) {
      builder.startVector(4, numElems, 4);
    }
    static endUnion(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createUnion(builder, mode, typeIdsOffset) {
      _Union.startUnion(builder);
      _Union.addMode(builder, mode);
      _Union.addTypeIds(builder, typeIdsOffset);
      return _Union.endUnion(builder);
    }
  };

  // ../../node_modules/apache-arrow/fb/utf8.mjs
  var Utf82 = class _Utf8 {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i2, bb) {
      this.bb_pos = i2;
      this.bb = bb;
      return this;
    }
    static getRootAsUtf8(bb, obj) {
      return (obj || new _Utf8()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsUtf8(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new _Utf8()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static startUtf8(builder) {
      builder.startObject(0);
    }
    static endUtf8(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createUtf8(builder) {
      _Utf8.startUtf8(builder);
      return _Utf8.endUtf8(builder);
    }
  };

  // ../../node_modules/apache-arrow/fb/type.mjs
  var Type2;
  (function(Type3) {
    Type3[Type3["NONE"] = 0] = "NONE";
    Type3[Type3["Null"] = 1] = "Null";
    Type3[Type3["Int"] = 2] = "Int";
    Type3[Type3["FloatingPoint"] = 3] = "FloatingPoint";
    Type3[Type3["Binary"] = 4] = "Binary";
    Type3[Type3["Utf8"] = 5] = "Utf8";
    Type3[Type3["Bool"] = 6] = "Bool";
    Type3[Type3["Decimal"] = 7] = "Decimal";
    Type3[Type3["Date"] = 8] = "Date";
    Type3[Type3["Time"] = 9] = "Time";
    Type3[Type3["Timestamp"] = 10] = "Timestamp";
    Type3[Type3["Interval"] = 11] = "Interval";
    Type3[Type3["List"] = 12] = "List";
    Type3[Type3["Struct_"] = 13] = "Struct_";
    Type3[Type3["Union"] = 14] = "Union";
    Type3[Type3["FixedSizeBinary"] = 15] = "FixedSizeBinary";
    Type3[Type3["FixedSizeList"] = 16] = "FixedSizeList";
    Type3[Type3["Map"] = 17] = "Map";
    Type3[Type3["Duration"] = 18] = "Duration";
    Type3[Type3["LargeBinary"] = 19] = "LargeBinary";
    Type3[Type3["LargeUtf8"] = 20] = "LargeUtf8";
    Type3[Type3["LargeList"] = 21] = "LargeList";
    Type3[Type3["RunEndEncoded"] = 22] = "RunEndEncoded";
  })(Type2 || (Type2 = {}));

  // ../../node_modules/apache-arrow/fb/field.mjs
  var Field = class _Field {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i2, bb) {
      this.bb_pos = i2;
      this.bb = bb;
      return this;
    }
    static getRootAsField(bb, obj) {
      return (obj || new _Field()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsField(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new _Field()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    name(optionalEncoding) {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Whether or not this field can contain nulls. Should be true in general.
     */
    nullable() {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    typeType() {
      const offset = this.bb.__offset(this.bb_pos, 8);
      return offset ? this.bb.readUint8(this.bb_pos + offset) : Type2.NONE;
    }
    /**
     * This is the type of the decoded value if the field is dictionary encoded.
     */
    type(obj) {
      const offset = this.bb.__offset(this.bb_pos, 10);
      return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
    }
    /**
     * Present only if the field is dictionary encoded.
     */
    dictionary(obj) {
      const offset = this.bb.__offset(this.bb_pos, 12);
      return offset ? (obj || new DictionaryEncoding()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    /**
     * children apply only to nested data types like Struct, List and Union. For
     * primitive types children will have length 0.
     */
    children(index, obj) {
      const offset = this.bb.__offset(this.bb_pos, 14);
      return offset ? (obj || new _Field()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    childrenLength() {
      const offset = this.bb.__offset(this.bb_pos, 14);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * User-defined metadata
     */
    customMetadata(index, obj) {
      const offset = this.bb.__offset(this.bb_pos, 16);
      return offset ? (obj || new KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    customMetadataLength() {
      const offset = this.bb.__offset(this.bb_pos, 16);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startField(builder) {
      builder.startObject(7);
    }
    static addName(builder, nameOffset) {
      builder.addFieldOffset(0, nameOffset, 0);
    }
    static addNullable(builder, nullable) {
      builder.addFieldInt8(1, +nullable, 0);
    }
    static addTypeType(builder, typeType) {
      builder.addFieldInt8(2, typeType, Type2.NONE);
    }
    static addType(builder, typeOffset) {
      builder.addFieldOffset(3, typeOffset, 0);
    }
    static addDictionary(builder, dictionaryOffset) {
      builder.addFieldOffset(4, dictionaryOffset, 0);
    }
    static addChildren(builder, childrenOffset) {
      builder.addFieldOffset(5, childrenOffset, 0);
    }
    static createChildrenVector(builder, data2) {
      builder.startVector(4, data2.length, 4);
      for (let i2 = data2.length - 1; i2 >= 0; i2--) {
        builder.addOffset(data2[i2]);
      }
      return builder.endVector();
    }
    static startChildrenVector(builder, numElems) {
      builder.startVector(4, numElems, 4);
    }
    static addCustomMetadata(builder, customMetadataOffset) {
      builder.addFieldOffset(6, customMetadataOffset, 0);
    }
    static createCustomMetadataVector(builder, data2) {
      builder.startVector(4, data2.length, 4);
      for (let i2 = data2.length - 1; i2 >= 0; i2--) {
        builder.addOffset(data2[i2]);
      }
      return builder.endVector();
    }
    static startCustomMetadataVector(builder, numElems) {
      builder.startVector(4, numElems, 4);
    }
    static endField(builder) {
      const offset = builder.endObject();
      return offset;
    }
  };

  // ../../node_modules/apache-arrow/fb/schema.mjs
  var Schema = class _Schema {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i2, bb) {
      this.bb_pos = i2;
      this.bb = bb;
      return this;
    }
    static getRootAsSchema(bb, obj) {
      return (obj || new _Schema()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsSchema(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new _Schema()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    /**
     * endianness of the buffer
     * it is Little Endian by default
     * if endianness doesn't match the underlying system then the vectors need to be converted
     */
    endianness() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt16(this.bb_pos + offset) : Endianness.Little;
    }
    fields(index, obj) {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? (obj || new Field()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    fieldsLength() {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    customMetadata(index, obj) {
      const offset = this.bb.__offset(this.bb_pos, 8);
      return offset ? (obj || new KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    customMetadataLength() {
      const offset = this.bb.__offset(this.bb_pos, 8);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * Features used in the stream/file.
     */
    features(index) {
      const offset = this.bb.__offset(this.bb_pos, 10);
      return offset ? this.bb.readInt64(this.bb.__vector(this.bb_pos + offset) + index * 8) : BigInt(0);
    }
    featuresLength() {
      const offset = this.bb.__offset(this.bb_pos, 10);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startSchema(builder) {
      builder.startObject(4);
    }
    static addEndianness(builder, endianness) {
      builder.addFieldInt16(0, endianness, Endianness.Little);
    }
    static addFields(builder, fieldsOffset) {
      builder.addFieldOffset(1, fieldsOffset, 0);
    }
    static createFieldsVector(builder, data2) {
      builder.startVector(4, data2.length, 4);
      for (let i2 = data2.length - 1; i2 >= 0; i2--) {
        builder.addOffset(data2[i2]);
      }
      return builder.endVector();
    }
    static startFieldsVector(builder, numElems) {
      builder.startVector(4, numElems, 4);
    }
    static addCustomMetadata(builder, customMetadataOffset) {
      builder.addFieldOffset(2, customMetadataOffset, 0);
    }
    static createCustomMetadataVector(builder, data2) {
      builder.startVector(4, data2.length, 4);
      for (let i2 = data2.length - 1; i2 >= 0; i2--) {
        builder.addOffset(data2[i2]);
      }
      return builder.endVector();
    }
    static startCustomMetadataVector(builder, numElems) {
      builder.startVector(4, numElems, 4);
    }
    static addFeatures(builder, featuresOffset) {
      builder.addFieldOffset(3, featuresOffset, 0);
    }
    static createFeaturesVector(builder, data2) {
      builder.startVector(8, data2.length, 8);
      for (let i2 = data2.length - 1; i2 >= 0; i2--) {
        builder.addInt64(data2[i2]);
      }
      return builder.endVector();
    }
    static startFeaturesVector(builder, numElems) {
      builder.startVector(8, numElems, 8);
    }
    static endSchema(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static finishSchemaBuffer(builder, offset) {
      builder.finish(offset);
    }
    static finishSizePrefixedSchemaBuffer(builder, offset) {
      builder.finish(offset, void 0, true);
    }
    static createSchema(builder, endianness, fieldsOffset, customMetadataOffset, featuresOffset) {
      _Schema.startSchema(builder);
      _Schema.addEndianness(builder, endianness);
      _Schema.addFields(builder, fieldsOffset);
      _Schema.addCustomMetadata(builder, customMetadataOffset);
      _Schema.addFeatures(builder, featuresOffset);
      return _Schema.endSchema(builder);
    }
  };

  // ../../node_modules/apache-arrow/fb/footer.mjs
  var Footer = class _Footer {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i2, bb) {
      this.bb_pos = i2;
      this.bb = bb;
      return this;
    }
    static getRootAsFooter(bb, obj) {
      return (obj || new _Footer()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsFooter(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new _Footer()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    version() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt16(this.bb_pos + offset) : MetadataVersion2.V1;
    }
    schema(obj) {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? (obj || new Schema()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    dictionaries(index, obj) {
      const offset = this.bb.__offset(this.bb_pos, 8);
      return offset ? (obj || new Block()).__init(this.bb.__vector(this.bb_pos + offset) + index * 24, this.bb) : null;
    }
    dictionariesLength() {
      const offset = this.bb.__offset(this.bb_pos, 8);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    recordBatches(index, obj) {
      const offset = this.bb.__offset(this.bb_pos, 10);
      return offset ? (obj || new Block()).__init(this.bb.__vector(this.bb_pos + offset) + index * 24, this.bb) : null;
    }
    recordBatchesLength() {
      const offset = this.bb.__offset(this.bb_pos, 10);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * User-defined metadata
     */
    customMetadata(index, obj) {
      const offset = this.bb.__offset(this.bb_pos, 12);
      return offset ? (obj || new KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    customMetadataLength() {
      const offset = this.bb.__offset(this.bb_pos, 12);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startFooter(builder) {
      builder.startObject(5);
    }
    static addVersion(builder, version) {
      builder.addFieldInt16(0, version, MetadataVersion2.V1);
    }
    static addSchema(builder, schemaOffset) {
      builder.addFieldOffset(1, schemaOffset, 0);
    }
    static addDictionaries(builder, dictionariesOffset) {
      builder.addFieldOffset(2, dictionariesOffset, 0);
    }
    static startDictionariesVector(builder, numElems) {
      builder.startVector(24, numElems, 8);
    }
    static addRecordBatches(builder, recordBatchesOffset) {
      builder.addFieldOffset(3, recordBatchesOffset, 0);
    }
    static startRecordBatchesVector(builder, numElems) {
      builder.startVector(24, numElems, 8);
    }
    static addCustomMetadata(builder, customMetadataOffset) {
      builder.addFieldOffset(4, customMetadataOffset, 0);
    }
    static createCustomMetadataVector(builder, data2) {
      builder.startVector(4, data2.length, 4);
      for (let i2 = data2.length - 1; i2 >= 0; i2--) {
        builder.addOffset(data2[i2]);
      }
      return builder.endVector();
    }
    static startCustomMetadataVector(builder, numElems) {
      builder.startVector(4, numElems, 4);
    }
    static endFooter(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static finishFooterBuffer(builder, offset) {
      builder.finish(offset);
    }
    static finishSizePrefixedFooterBuffer(builder, offset) {
      builder.finish(offset, void 0, true);
    }
  };

  // ../../node_modules/apache-arrow/schema.mjs
  var Schema2 = class _Schema {
    constructor(fields = [], metadata2, dictionaries, metadataVersion = MetadataVersion.V5) {
      this.fields = fields || [];
      this.metadata = metadata2 || /* @__PURE__ */ new Map();
      if (!dictionaries) {
        dictionaries = generateDictionaryMap(fields);
      }
      this.dictionaries = dictionaries;
      this.metadataVersion = metadataVersion;
    }
    get [Symbol.toStringTag]() {
      return "Schema";
    }
    get names() {
      return this.fields.map((f) => f.name);
    }
    toString() {
      return `Schema<{ ${this.fields.map((f, i2) => `${i2}: ${f}`).join(", ")} }>`;
    }
    /**
     * Construct a new Schema containing only specified fields.
     *
     * @param fieldNames Names of fields to keep.
     * @returns A new Schema of fields matching the specified names.
     */
    select(fieldNames) {
      const names = new Set(fieldNames);
      const fields = this.fields.filter((f) => names.has(f.name));
      return new _Schema(fields, this.metadata);
    }
    /**
     * Construct a new Schema containing only fields at the specified indices.
     *
     * @param fieldIndices Indices of fields to keep.
     * @returns A new Schema of fields at the specified indices.
     */
    selectAt(fieldIndices) {
      const fields = fieldIndices.map((i2) => this.fields[i2]).filter(Boolean);
      return new _Schema(fields, this.metadata);
    }
    assign(...args2) {
      const other = args2[0] instanceof _Schema ? args2[0] : Array.isArray(args2[0]) ? new _Schema(args2[0]) : new _Schema(args2);
      const curFields = [...this.fields];
      const metadata2 = mergeMaps(mergeMaps(/* @__PURE__ */ new Map(), this.metadata), other.metadata);
      const newFields = other.fields.filter((f2) => {
        const i2 = curFields.findIndex((f) => f.name === f2.name);
        return ~i2 ? (curFields[i2] = f2.clone({
          metadata: mergeMaps(mergeMaps(/* @__PURE__ */ new Map(), curFields[i2].metadata), f2.metadata)
        })) && false : true;
      });
      const newDictionaries = generateDictionaryMap(newFields, /* @__PURE__ */ new Map());
      return new _Schema([...curFields, ...newFields], metadata2, new Map([...this.dictionaries, ...newDictionaries]));
    }
  };
  Schema2.prototype.fields = null;
  Schema2.prototype.metadata = null;
  Schema2.prototype.dictionaries = null;
  var Field2 = class _Field {
    /** @nocollapse */
    static new(...args2) {
      let [name2, type, nullable, metadata2] = args2;
      if (args2[0] && typeof args2[0] === "object") {
        ({ name: name2 } = args2[0]);
        type === void 0 && (type = args2[0].type);
        nullable === void 0 && (nullable = args2[0].nullable);
        metadata2 === void 0 && (metadata2 = args2[0].metadata);
      }
      return new _Field(`${name2}`, type, nullable, metadata2);
    }
    constructor(name2, type, nullable = false, metadata2) {
      this.name = name2;
      this.type = type;
      this.nullable = nullable;
      this.metadata = metadata2 || /* @__PURE__ */ new Map();
    }
    get typeId() {
      return this.type.typeId;
    }
    get [Symbol.toStringTag]() {
      return "Field";
    }
    toString() {
      return `${this.name}: ${this.type}`;
    }
    clone(...args2) {
      let [name2, type, nullable, metadata2] = args2;
      !args2[0] || typeof args2[0] !== "object" ? [name2 = this.name, type = this.type, nullable = this.nullable, metadata2 = this.metadata] = args2 : { name: name2 = this.name, type = this.type, nullable = this.nullable, metadata: metadata2 = this.metadata } = args2[0];
      return _Field.new(name2, type, nullable, metadata2);
    }
  };
  Field2.prototype.type = null;
  Field2.prototype.name = null;
  Field2.prototype.nullable = null;
  Field2.prototype.metadata = null;
  function mergeMaps(m1, m2) {
    return new Map([...m1 || /* @__PURE__ */ new Map(), ...m2 || /* @__PURE__ */ new Map()]);
  }
  function generateDictionaryMap(fields, dictionaries = /* @__PURE__ */ new Map()) {
    for (let i2 = -1, n = fields.length; ++i2 < n; ) {
      const field = fields[i2];
      const type = field.type;
      if (DataType.isDictionary(type)) {
        if (!dictionaries.has(type.id)) {
          dictionaries.set(type.id, type.dictionary);
        } else if (dictionaries.get(type.id) !== type.dictionary) {
          throw new Error(`Cannot create Schema containing two different dictionaries with the same Id`);
        }
      }
      if (type.children && type.children.length > 0) {
        generateDictionaryMap(type.children, dictionaries);
      }
    }
    return dictionaries;
  }

  // ../../node_modules/apache-arrow/ipc/metadata/file.mjs
  var Builder3 = Builder2;
  var ByteBuffer2 = ByteBuffer;
  var Footer_ = class {
    /** @nocollapse */
    static decode(buf) {
      buf = new ByteBuffer2(toUint8Array(buf));
      const footer = Footer.getRootAsFooter(buf);
      const schema = Schema2.decode(footer.schema(), /* @__PURE__ */ new Map(), footer.version());
      return new OffHeapFooter(schema, footer);
    }
    /** @nocollapse */
    static encode(footer) {
      const b = new Builder3();
      const schemaOffset = Schema2.encode(b, footer.schema);
      Footer.startRecordBatchesVector(b, footer.numRecordBatches);
      for (const rb of [...footer.recordBatches()].slice().reverse()) {
        FileBlock.encode(b, rb);
      }
      const recordBatchesOffset = b.endVector();
      Footer.startDictionariesVector(b, footer.numDictionaries);
      for (const db2 of [...footer.dictionaryBatches()].slice().reverse()) {
        FileBlock.encode(b, db2);
      }
      const dictionaryBatchesOffset = b.endVector();
      Footer.startFooter(b);
      Footer.addSchema(b, schemaOffset);
      Footer.addVersion(b, MetadataVersion.V5);
      Footer.addRecordBatches(b, recordBatchesOffset);
      Footer.addDictionaries(b, dictionaryBatchesOffset);
      Footer.finishFooterBuffer(b, Footer.endFooter(b));
      return b.asUint8Array();
    }
    get numRecordBatches() {
      return this._recordBatches.length;
    }
    get numDictionaries() {
      return this._dictionaryBatches.length;
    }
    constructor(schema, version = MetadataVersion.V5, recordBatches, dictionaryBatches) {
      this.schema = schema;
      this.version = version;
      recordBatches && (this._recordBatches = recordBatches);
      dictionaryBatches && (this._dictionaryBatches = dictionaryBatches);
    }
    *recordBatches() {
      for (let block, i2 = -1, n = this.numRecordBatches; ++i2 < n; ) {
        if (block = this.getRecordBatch(i2)) {
          yield block;
        }
      }
    }
    *dictionaryBatches() {
      for (let block, i2 = -1, n = this.numDictionaries; ++i2 < n; ) {
        if (block = this.getDictionaryBatch(i2)) {
          yield block;
        }
      }
    }
    getRecordBatch(index) {
      return index >= 0 && index < this.numRecordBatches && this._recordBatches[index] || null;
    }
    getDictionaryBatch(index) {
      return index >= 0 && index < this.numDictionaries && this._dictionaryBatches[index] || null;
    }
  };
  var OffHeapFooter = class extends Footer_ {
    get numRecordBatches() {
      return this._footer.recordBatchesLength();
    }
    get numDictionaries() {
      return this._footer.dictionariesLength();
    }
    constructor(schema, _footer) {
      super(schema, _footer.version());
      this._footer = _footer;
    }
    getRecordBatch(index) {
      if (index >= 0 && index < this.numRecordBatches) {
        const fileBlock = this._footer.recordBatches(index);
        if (fileBlock) {
          return FileBlock.decode(fileBlock);
        }
      }
      return null;
    }
    getDictionaryBatch(index) {
      if (index >= 0 && index < this.numDictionaries) {
        const fileBlock = this._footer.dictionaries(index);
        if (fileBlock) {
          return FileBlock.decode(fileBlock);
        }
      }
      return null;
    }
  };
  var FileBlock = class _FileBlock {
    /** @nocollapse */
    static decode(block) {
      return new _FileBlock(block.metaDataLength(), block.bodyLength(), block.offset());
    }
    /** @nocollapse */
    static encode(b, fileBlock) {
      const { metaDataLength } = fileBlock;
      const offset = BigInt(fileBlock.offset);
      const bodyLength = BigInt(fileBlock.bodyLength);
      return Block.createBlock(b, offset, metaDataLength, bodyLength);
    }
    constructor(metaDataLength, bodyLength, offset) {
      this.metaDataLength = metaDataLength;
      this.offset = bigIntToNumber(offset);
      this.bodyLength = bigIntToNumber(bodyLength);
    }
  };

  // ../../node_modules/apache-arrow/io/interfaces.mjs
  var ITERATOR_DONE = Object.freeze({ done: true, value: void 0 });
  var ArrowJSON = class {
    constructor(_json) {
      this._json = _json;
    }
    get schema() {
      return this._json["schema"];
    }
    get batches() {
      return this._json["batches"] || [];
    }
    get dictionaries() {
      return this._json["dictionaries"] || [];
    }
  };
  var ReadableInterop = class {
    tee() {
      return this._getDOMStream().tee();
    }
    pipe(writable, options) {
      return this._getNodeStream().pipe(writable, options);
    }
    pipeTo(writable, options) {
      return this._getDOMStream().pipeTo(writable, options);
    }
    pipeThrough(duplex, options) {
      return this._getDOMStream().pipeThrough(duplex, options);
    }
    _getDOMStream() {
      return this._DOMStream || (this._DOMStream = this.toDOMStream());
    }
    _getNodeStream() {
      return this._nodeStream || (this._nodeStream = this.toNodeStream());
    }
  };
  var AsyncQueue = class extends ReadableInterop {
    constructor() {
      super();
      this._values = [];
      this.resolvers = [];
      this._closedPromise = new Promise((r) => this._closedPromiseResolve = r);
    }
    get closed() {
      return this._closedPromise;
    }
    cancel(reason) {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.return(reason);
      });
    }
    write(value) {
      if (this._ensureOpen()) {
        this.resolvers.length <= 0 ? this._values.push(value) : this.resolvers.shift().resolve({ done: false, value });
      }
    }
    abort(value) {
      if (this._closedPromiseResolve) {
        this.resolvers.length <= 0 ? this._error = { error: value } : this.resolvers.shift().reject({ done: true, value });
      }
    }
    close() {
      if (this._closedPromiseResolve) {
        const { resolvers } = this;
        while (resolvers.length > 0) {
          resolvers.shift().resolve(ITERATOR_DONE);
        }
        this._closedPromiseResolve();
        this._closedPromiseResolve = void 0;
      }
    }
    [Symbol.asyncIterator]() {
      return this;
    }
    toDOMStream(options) {
      return adapters_default.toDOMStream(this._closedPromiseResolve || this._error ? this : this._values, options);
    }
    toNodeStream(options) {
      return adapters_default.toNodeStream(this._closedPromiseResolve || this._error ? this : this._values, options);
    }
    throw(_) {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.abort(_);
        return ITERATOR_DONE;
      });
    }
    return(_) {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.close();
        return ITERATOR_DONE;
      });
    }
    read(size) {
      return __awaiter(this, void 0, void 0, function* () {
        return (yield this.next(size, "read")).value;
      });
    }
    peek(size) {
      return __awaiter(this, void 0, void 0, function* () {
        return (yield this.next(size, "peek")).value;
      });
    }
    next(..._args) {
      if (this._values.length > 0) {
        return Promise.resolve({ done: false, value: this._values.shift() });
      } else if (this._error) {
        return Promise.reject({ done: true, value: this._error.error });
      } else if (!this._closedPromiseResolve) {
        return Promise.resolve(ITERATOR_DONE);
      } else {
        return new Promise((resolve, reject) => {
          this.resolvers.push({ resolve, reject });
        });
      }
    }
    _ensureOpen() {
      if (this._closedPromiseResolve) {
        return true;
      }
      throw new Error(`AsyncQueue is closed`);
    }
  };

  // ../../node_modules/apache-arrow/io/stream.mjs
  var AsyncByteQueue = class extends AsyncQueue {
    write(value) {
      if ((value = toUint8Array(value)).byteLength > 0) {
        return super.write(value);
      }
    }
    toString(sync = false) {
      return sync ? decodeUtf8(this.toUint8Array(true)) : this.toUint8Array(false).then(decodeUtf8);
    }
    toUint8Array(sync = false) {
      return sync ? joinUint8Arrays(this._values)[0] : (() => __awaiter(this, void 0, void 0, function* () {
        var _a5, e_1, _b2, _c2;
        const buffers = [];
        let byteLength = 0;
        try {
          for (var _d2 = true, _e2 = __asyncValues(this), _f2; _f2 = yield _e2.next(), _a5 = _f2.done, !_a5; _d2 = true) {
            _c2 = _f2.value;
            _d2 = false;
            const chunk = _c2;
            buffers.push(chunk);
            byteLength += chunk.byteLength;
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (!_d2 && !_a5 && (_b2 = _e2.return))
              yield _b2.call(_e2);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        return joinUint8Arrays(buffers, byteLength)[0];
      }))();
    }
  };
  var ByteStream = class {
    constructor(source) {
      if (source) {
        this.source = new ByteStreamSource(adapters_default.fromIterable(source));
      }
    }
    [Symbol.iterator]() {
      return this;
    }
    next(value) {
      return this.source.next(value);
    }
    throw(value) {
      return this.source.throw(value);
    }
    return(value) {
      return this.source.return(value);
    }
    peek(size) {
      return this.source.peek(size);
    }
    read(size) {
      return this.source.read(size);
    }
  };
  var AsyncByteStream = class _AsyncByteStream {
    constructor(source) {
      if (source instanceof _AsyncByteStream) {
        this.source = source.source;
      } else if (source instanceof AsyncByteQueue) {
        this.source = new AsyncByteStreamSource(adapters_default.fromAsyncIterable(source));
      } else if (isReadableNodeStream(source)) {
        this.source = new AsyncByteStreamSource(adapters_default.fromNodeStream(source));
      } else if (isReadableDOMStream(source)) {
        this.source = new AsyncByteStreamSource(adapters_default.fromDOMStream(source));
      } else if (isFetchResponse(source)) {
        this.source = new AsyncByteStreamSource(adapters_default.fromDOMStream(source.body));
      } else if (isIterable(source)) {
        this.source = new AsyncByteStreamSource(adapters_default.fromIterable(source));
      } else if (isPromise(source)) {
        this.source = new AsyncByteStreamSource(adapters_default.fromAsyncIterable(source));
      } else if (isAsyncIterable(source)) {
        this.source = new AsyncByteStreamSource(adapters_default.fromAsyncIterable(source));
      }
    }
    [Symbol.asyncIterator]() {
      return this;
    }
    next(value) {
      return this.source.next(value);
    }
    throw(value) {
      return this.source.throw(value);
    }
    return(value) {
      return this.source.return(value);
    }
    get closed() {
      return this.source.closed;
    }
    cancel(reason) {
      return this.source.cancel(reason);
    }
    peek(size) {
      return this.source.peek(size);
    }
    read(size) {
      return this.source.read(size);
    }
  };
  var ByteStreamSource = class {
    constructor(source) {
      this.source = source;
    }
    cancel(reason) {
      this.return(reason);
    }
    peek(size) {
      return this.next(size, "peek").value;
    }
    read(size) {
      return this.next(size, "read").value;
    }
    next(size, cmd = "read") {
      return this.source.next({ cmd, size });
    }
    throw(value) {
      return Object.create(this.source.throw && this.source.throw(value) || ITERATOR_DONE);
    }
    return(value) {
      return Object.create(this.source.return && this.source.return(value) || ITERATOR_DONE);
    }
  };
  var AsyncByteStreamSource = class {
    constructor(source) {
      this.source = source;
      this._closedPromise = new Promise((r) => this._closedPromiseResolve = r);
    }
    cancel(reason) {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.return(reason);
      });
    }
    get closed() {
      return this._closedPromise;
    }
    read(size) {
      return __awaiter(this, void 0, void 0, function* () {
        return (yield this.next(size, "read")).value;
      });
    }
    peek(size) {
      return __awaiter(this, void 0, void 0, function* () {
        return (yield this.next(size, "peek")).value;
      });
    }
    next(size, cmd = "read") {
      return __awaiter(this, void 0, void 0, function* () {
        return yield this.source.next({ cmd, size });
      });
    }
    throw(value) {
      return __awaiter(this, void 0, void 0, function* () {
        const result = this.source.throw && (yield this.source.throw(value)) || ITERATOR_DONE;
        this._closedPromiseResolve && this._closedPromiseResolve();
        this._closedPromiseResolve = void 0;
        return Object.create(result);
      });
    }
    return(value) {
      return __awaiter(this, void 0, void 0, function* () {
        const result = this.source.return && (yield this.source.return(value)) || ITERATOR_DONE;
        this._closedPromiseResolve && this._closedPromiseResolve();
        this._closedPromiseResolve = void 0;
        return Object.create(result);
      });
    }
  };

  // ../../node_modules/apache-arrow/io/file.mjs
  var RandomAccessFile = class extends ByteStream {
    constructor(buffer, byteLength) {
      super();
      this.position = 0;
      this.buffer = toUint8Array(buffer);
      this.size = byteLength === void 0 ? this.buffer.byteLength : byteLength;
    }
    readInt32(position) {
      const { buffer, byteOffset } = this.readAt(position, 4);
      return new DataView(buffer, byteOffset).getInt32(0, true);
    }
    seek(position) {
      this.position = Math.min(position, this.size);
      return position < this.size;
    }
    read(nBytes) {
      const { buffer, size, position } = this;
      if (buffer && position < size) {
        if (typeof nBytes !== "number") {
          nBytes = Number.POSITIVE_INFINITY;
        }
        this.position = Math.min(size, position + Math.min(size - position, nBytes));
        return buffer.subarray(position, this.position);
      }
      return null;
    }
    readAt(position, nBytes) {
      const buf = this.buffer;
      const end = Math.min(this.size, position + nBytes);
      return buf ? buf.subarray(position, end) : new Uint8Array(nBytes);
    }
    close() {
      this.buffer && (this.buffer = null);
    }
    throw(value) {
      this.close();
      return { done: true, value };
    }
    return(value) {
      this.close();
      return { done: true, value };
    }
  };
  var AsyncRandomAccessFile = class extends AsyncByteStream {
    constructor(file, byteLength) {
      super();
      this.position = 0;
      this._handle = file;
      if (typeof byteLength === "number") {
        this.size = byteLength;
      } else {
        this._pending = (() => __awaiter(this, void 0, void 0, function* () {
          this.size = (yield file.stat()).size;
          delete this._pending;
        }))();
      }
    }
    readInt32(position) {
      return __awaiter(this, void 0, void 0, function* () {
        const { buffer, byteOffset } = yield this.readAt(position, 4);
        return new DataView(buffer, byteOffset).getInt32(0, true);
      });
    }
    seek(position) {
      return __awaiter(this, void 0, void 0, function* () {
        this._pending && (yield this._pending);
        this.position = Math.min(position, this.size);
        return position < this.size;
      });
    }
    read(nBytes) {
      return __awaiter(this, void 0, void 0, function* () {
        this._pending && (yield this._pending);
        const { _handle: file, size, position } = this;
        if (file && position < size) {
          if (typeof nBytes !== "number") {
            nBytes = Number.POSITIVE_INFINITY;
          }
          let pos = position, offset = 0, bytesRead = 0;
          const end = Math.min(size, pos + Math.min(size - pos, nBytes));
          const buffer = new Uint8Array(Math.max(0, (this.position = end) - pos));
          while ((pos += bytesRead) < end && (offset += bytesRead) < buffer.byteLength) {
            ({ bytesRead } = yield file.read(buffer, offset, buffer.byteLength - offset, pos));
          }
          return buffer;
        }
        return null;
      });
    }
    readAt(position, nBytes) {
      return __awaiter(this, void 0, void 0, function* () {
        this._pending && (yield this._pending);
        const { _handle: file, size } = this;
        if (file && position + nBytes < size) {
          const end = Math.min(size, position + nBytes);
          const buffer = new Uint8Array(end - position);
          return (yield file.read(buffer, 0, nBytes, position)).buffer;
        }
        return new Uint8Array(nBytes);
      });
    }
    close() {
      return __awaiter(this, void 0, void 0, function* () {
        const f = this._handle;
        this._handle = null;
        f && (yield f.close());
      });
    }
    throw(value) {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.close();
        return { done: true, value };
      });
    }
    return(value) {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.close();
        return { done: true, value };
      });
    }
  };

  // ../../node_modules/apache-arrow/util/int.mjs
  var int_exports = {};
  __export(int_exports, {
    BaseInt64: () => BaseInt64,
    Int128: () => Int128,
    Int64: () => Int642,
    Uint64: () => Uint642
  });
  var carryBit16 = 1 << 16;
  function intAsHex(value) {
    if (value < 0) {
      value = 4294967295 + value + 1;
    }
    return `0x${value.toString(16)}`;
  }
  var kInt32DecimalDigits = 8;
  var kPowersOfTen = [
    1,
    10,
    100,
    1e3,
    1e4,
    1e5,
    1e6,
    1e7,
    1e8
  ];
  var BaseInt64 = class {
    constructor(buffer) {
      this.buffer = buffer;
    }
    high() {
      return this.buffer[1];
    }
    low() {
      return this.buffer[0];
    }
    _times(other) {
      const L = new Uint32Array([
        this.buffer[1] >>> 16,
        this.buffer[1] & 65535,
        this.buffer[0] >>> 16,
        this.buffer[0] & 65535
      ]);
      const R = new Uint32Array([
        other.buffer[1] >>> 16,
        other.buffer[1] & 65535,
        other.buffer[0] >>> 16,
        other.buffer[0] & 65535
      ]);
      let product = L[3] * R[3];
      this.buffer[0] = product & 65535;
      let sum2 = product >>> 16;
      product = L[2] * R[3];
      sum2 += product;
      product = L[3] * R[2] >>> 0;
      sum2 += product;
      this.buffer[0] += sum2 << 16;
      this.buffer[1] = sum2 >>> 0 < product ? carryBit16 : 0;
      this.buffer[1] += sum2 >>> 16;
      this.buffer[1] += L[1] * R[3] + L[2] * R[2] + L[3] * R[1];
      this.buffer[1] += L[0] * R[3] + L[1] * R[2] + L[2] * R[1] + L[3] * R[0] << 16;
      return this;
    }
    _plus(other) {
      const sum2 = this.buffer[0] + other.buffer[0] >>> 0;
      this.buffer[1] += other.buffer[1];
      if (sum2 < this.buffer[0] >>> 0) {
        ++this.buffer[1];
      }
      this.buffer[0] = sum2;
    }
    lessThan(other) {
      return this.buffer[1] < other.buffer[1] || this.buffer[1] === other.buffer[1] && this.buffer[0] < other.buffer[0];
    }
    equals(other) {
      return this.buffer[1] === other.buffer[1] && this.buffer[0] == other.buffer[0];
    }
    greaterThan(other) {
      return other.lessThan(this);
    }
    hex() {
      return `${intAsHex(this.buffer[1])} ${intAsHex(this.buffer[0])}`;
    }
  };
  var Uint642 = class _Uint64 extends BaseInt64 {
    times(other) {
      this._times(other);
      return this;
    }
    plus(other) {
      this._plus(other);
      return this;
    }
    /** @nocollapse */
    static from(val, out_buffer = new Uint32Array(2)) {
      return _Uint64.fromString(typeof val === "string" ? val : val.toString(), out_buffer);
    }
    /** @nocollapse */
    static fromNumber(num, out_buffer = new Uint32Array(2)) {
      return _Uint64.fromString(num.toString(), out_buffer);
    }
    /** @nocollapse */
    static fromString(str, out_buffer = new Uint32Array(2)) {
      const length = str.length;
      const out2 = new _Uint64(out_buffer);
      for (let posn = 0; posn < length; ) {
        const group = kInt32DecimalDigits < length - posn ? kInt32DecimalDigits : length - posn;
        const chunk = new _Uint64(new Uint32Array([Number.parseInt(str.slice(posn, posn + group), 10), 0]));
        const multiple = new _Uint64(new Uint32Array([kPowersOfTen[group], 0]));
        out2.times(multiple);
        out2.plus(chunk);
        posn += group;
      }
      return out2;
    }
    /** @nocollapse */
    static convertArray(values) {
      const data2 = new Uint32Array(values.length * 2);
      for (let i2 = -1, n = values.length; ++i2 < n; ) {
        _Uint64.from(values[i2], new Uint32Array(data2.buffer, data2.byteOffset + 2 * i2 * 4, 2));
      }
      return data2;
    }
    /** @nocollapse */
    static multiply(left, right) {
      const rtrn = new _Uint64(new Uint32Array(left.buffer));
      return rtrn.times(right);
    }
    /** @nocollapse */
    static add(left, right) {
      const rtrn = new _Uint64(new Uint32Array(left.buffer));
      return rtrn.plus(right);
    }
  };
  var Int642 = class _Int64 extends BaseInt64 {
    negate() {
      this.buffer[0] = ~this.buffer[0] + 1;
      this.buffer[1] = ~this.buffer[1];
      if (this.buffer[0] == 0) {
        ++this.buffer[1];
      }
      return this;
    }
    times(other) {
      this._times(other);
      return this;
    }
    plus(other) {
      this._plus(other);
      return this;
    }
    lessThan(other) {
      const this_high = this.buffer[1] << 0;
      const other_high = other.buffer[1] << 0;
      return this_high < other_high || this_high === other_high && this.buffer[0] < other.buffer[0];
    }
    /** @nocollapse */
    static from(val, out_buffer = new Uint32Array(2)) {
      return _Int64.fromString(typeof val === "string" ? val : val.toString(), out_buffer);
    }
    /** @nocollapse */
    static fromNumber(num, out_buffer = new Uint32Array(2)) {
      return _Int64.fromString(num.toString(), out_buffer);
    }
    /** @nocollapse */
    static fromString(str, out_buffer = new Uint32Array(2)) {
      const negate = str.startsWith("-");
      const length = str.length;
      const out2 = new _Int64(out_buffer);
      for (let posn = negate ? 1 : 0; posn < length; ) {
        const group = kInt32DecimalDigits < length - posn ? kInt32DecimalDigits : length - posn;
        const chunk = new _Int64(new Uint32Array([Number.parseInt(str.slice(posn, posn + group), 10), 0]));
        const multiple = new _Int64(new Uint32Array([kPowersOfTen[group], 0]));
        out2.times(multiple);
        out2.plus(chunk);
        posn += group;
      }
      return negate ? out2.negate() : out2;
    }
    /** @nocollapse */
    static convertArray(values) {
      const data2 = new Uint32Array(values.length * 2);
      for (let i2 = -1, n = values.length; ++i2 < n; ) {
        _Int64.from(values[i2], new Uint32Array(data2.buffer, data2.byteOffset + 2 * i2 * 4, 2));
      }
      return data2;
    }
    /** @nocollapse */
    static multiply(left, right) {
      const rtrn = new _Int64(new Uint32Array(left.buffer));
      return rtrn.times(right);
    }
    /** @nocollapse */
    static add(left, right) {
      const rtrn = new _Int64(new Uint32Array(left.buffer));
      return rtrn.plus(right);
    }
  };
  var Int128 = class _Int128 {
    constructor(buffer) {
      this.buffer = buffer;
    }
    high() {
      return new Int642(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset + 8, 2));
    }
    low() {
      return new Int642(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset, 2));
    }
    negate() {
      this.buffer[0] = ~this.buffer[0] + 1;
      this.buffer[1] = ~this.buffer[1];
      this.buffer[2] = ~this.buffer[2];
      this.buffer[3] = ~this.buffer[3];
      if (this.buffer[0] == 0) {
        ++this.buffer[1];
      }
      if (this.buffer[1] == 0) {
        ++this.buffer[2];
      }
      if (this.buffer[2] == 0) {
        ++this.buffer[3];
      }
      return this;
    }
    times(other) {
      const L0 = new Uint642(new Uint32Array([this.buffer[3], 0]));
      const L1 = new Uint642(new Uint32Array([this.buffer[2], 0]));
      const L2 = new Uint642(new Uint32Array([this.buffer[1], 0]));
      const L3 = new Uint642(new Uint32Array([this.buffer[0], 0]));
      const R0 = new Uint642(new Uint32Array([other.buffer[3], 0]));
      const R1 = new Uint642(new Uint32Array([other.buffer[2], 0]));
      const R2 = new Uint642(new Uint32Array([other.buffer[1], 0]));
      const R3 = new Uint642(new Uint32Array([other.buffer[0], 0]));
      let product = Uint642.multiply(L3, R3);
      this.buffer[0] = product.low();
      const sum2 = new Uint642(new Uint32Array([product.high(), 0]));
      product = Uint642.multiply(L2, R3);
      sum2.plus(product);
      product = Uint642.multiply(L3, R2);
      sum2.plus(product);
      this.buffer[1] = sum2.low();
      this.buffer[3] = sum2.lessThan(product) ? 1 : 0;
      this.buffer[2] = sum2.high();
      const high = new Uint642(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset + 8, 2));
      high.plus(Uint642.multiply(L1, R3)).plus(Uint642.multiply(L2, R2)).plus(Uint642.multiply(L3, R1));
      this.buffer[3] += Uint642.multiply(L0, R3).plus(Uint642.multiply(L1, R2)).plus(Uint642.multiply(L2, R1)).plus(Uint642.multiply(L3, R0)).low();
      return this;
    }
    plus(other) {
      const sums = new Uint32Array(4);
      sums[3] = this.buffer[3] + other.buffer[3] >>> 0;
      sums[2] = this.buffer[2] + other.buffer[2] >>> 0;
      sums[1] = this.buffer[1] + other.buffer[1] >>> 0;
      sums[0] = this.buffer[0] + other.buffer[0] >>> 0;
      if (sums[0] < this.buffer[0] >>> 0) {
        ++sums[1];
      }
      if (sums[1] < this.buffer[1] >>> 0) {
        ++sums[2];
      }
      if (sums[2] < this.buffer[2] >>> 0) {
        ++sums[3];
      }
      this.buffer[3] = sums[3];
      this.buffer[2] = sums[2];
      this.buffer[1] = sums[1];
      this.buffer[0] = sums[0];
      return this;
    }
    hex() {
      return `${intAsHex(this.buffer[3])} ${intAsHex(this.buffer[2])} ${intAsHex(this.buffer[1])} ${intAsHex(this.buffer[0])}`;
    }
    /** @nocollapse */
    static multiply(left, right) {
      const rtrn = new _Int128(new Uint32Array(left.buffer));
      return rtrn.times(right);
    }
    /** @nocollapse */
    static add(left, right) {
      const rtrn = new _Int128(new Uint32Array(left.buffer));
      return rtrn.plus(right);
    }
    /** @nocollapse */
    static from(val, out_buffer = new Uint32Array(4)) {
      return _Int128.fromString(typeof val === "string" ? val : val.toString(), out_buffer);
    }
    /** @nocollapse */
    static fromNumber(num, out_buffer = new Uint32Array(4)) {
      return _Int128.fromString(num.toString(), out_buffer);
    }
    /** @nocollapse */
    static fromString(str, out_buffer = new Uint32Array(4)) {
      const negate = str.startsWith("-");
      const length = str.length;
      const out2 = new _Int128(out_buffer);
      for (let posn = negate ? 1 : 0; posn < length; ) {
        const group = kInt32DecimalDigits < length - posn ? kInt32DecimalDigits : length - posn;
        const chunk = new _Int128(new Uint32Array([Number.parseInt(str.slice(posn, posn + group), 10), 0, 0, 0]));
        const multiple = new _Int128(new Uint32Array([kPowersOfTen[group], 0, 0, 0]));
        out2.times(multiple);
        out2.plus(chunk);
        posn += group;
      }
      return negate ? out2.negate() : out2;
    }
    /** @nocollapse */
    static convertArray(values) {
      const data2 = new Uint32Array(values.length * 4);
      for (let i2 = -1, n = values.length; ++i2 < n; ) {
        _Int128.from(values[i2], new Uint32Array(data2.buffer, data2.byteOffset + 4 * 4 * i2, 4));
      }
      return data2;
    }
  };

  // ../../node_modules/apache-arrow/visitor/vectorloader.mjs
  var VectorLoader = class extends Visitor {
    constructor(bytes, nodes, buffers, dictionaries, metadataVersion = MetadataVersion.V5) {
      super();
      this.nodesIndex = -1;
      this.buffersIndex = -1;
      this.bytes = bytes;
      this.nodes = nodes;
      this.buffers = buffers;
      this.dictionaries = dictionaries;
      this.metadataVersion = metadataVersion;
    }
    visit(node) {
      return super.visit(node instanceof Field2 ? node.type : node);
    }
    visitNull(type, { length } = this.nextFieldNode()) {
      return makeData({ type, length });
    }
    visitBool(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitInt(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitFloat(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitUtf8(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), valueOffsets: this.readOffsets(type), data: this.readData(type) });
    }
    visitBinary(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), valueOffsets: this.readOffsets(type), data: this.readData(type) });
    }
    visitFixedSizeBinary(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitDate(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitTimestamp(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitTime(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitDecimal(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitList(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), valueOffsets: this.readOffsets(type), "child": this.visit(type.children[0]) });
    }
    visitStruct(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), children: this.visitMany(type.children) });
    }
    visitUnion(type, { length, nullCount } = this.nextFieldNode()) {
      if (this.metadataVersion < MetadataVersion.V5) {
        this.readNullBitmap(type, nullCount);
      }
      return type.mode === UnionMode.Sparse ? this.visitSparseUnion(type, { length, nullCount }) : this.visitDenseUnion(type, { length, nullCount });
    }
    visitDenseUnion(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, typeIds: this.readTypeIds(type), valueOffsets: this.readOffsets(type), children: this.visitMany(type.children) });
    }
    visitSparseUnion(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, typeIds: this.readTypeIds(type), children: this.visitMany(type.children) });
    }
    visitDictionary(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type.indices), dictionary: this.readDictionary(type) });
    }
    visitInterval(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitDuration(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitFixedSizeList(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), "child": this.visit(type.children[0]) });
    }
    visitMap(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), valueOffsets: this.readOffsets(type), "child": this.visit(type.children[0]) });
    }
    nextFieldNode() {
      return this.nodes[++this.nodesIndex];
    }
    nextBufferRange() {
      return this.buffers[++this.buffersIndex];
    }
    readNullBitmap(type, nullCount, buffer = this.nextBufferRange()) {
      return nullCount > 0 && this.readData(type, buffer) || new Uint8Array(0);
    }
    readOffsets(type, buffer) {
      return this.readData(type, buffer);
    }
    readTypeIds(type, buffer) {
      return this.readData(type, buffer);
    }
    readData(_type, { length, offset } = this.nextBufferRange()) {
      return this.bytes.subarray(offset, offset + length);
    }
    readDictionary(type) {
      return this.dictionaries.get(type.id);
    }
  };
  var JSONVectorLoader = class extends VectorLoader {
    constructor(sources, nodes, buffers, dictionaries, metadataVersion) {
      super(new Uint8Array(0), nodes, buffers, dictionaries, metadataVersion);
      this.sources = sources;
    }
    readNullBitmap(_type, nullCount, { offset } = this.nextBufferRange()) {
      return nullCount <= 0 ? new Uint8Array(0) : packBools(this.sources[offset]);
    }
    readOffsets(_type, { offset } = this.nextBufferRange()) {
      return toArrayBufferView(Uint8Array, toArrayBufferView(Int32Array, this.sources[offset]));
    }
    readTypeIds(type, { offset } = this.nextBufferRange()) {
      return toArrayBufferView(Uint8Array, toArrayBufferView(type.ArrayType, this.sources[offset]));
    }
    readData(type, { offset } = this.nextBufferRange()) {
      const { sources } = this;
      if (DataType.isTimestamp(type)) {
        return toArrayBufferView(Uint8Array, Int642.convertArray(sources[offset]));
      } else if ((DataType.isInt(type) || DataType.isTime(type)) && type.bitWidth === 64 || DataType.isDuration(type)) {
        return toArrayBufferView(Uint8Array, Int642.convertArray(sources[offset]));
      } else if (DataType.isDate(type) && type.unit === DateUnit.MILLISECOND) {
        return toArrayBufferView(Uint8Array, Int642.convertArray(sources[offset]));
      } else if (DataType.isDecimal(type)) {
        return toArrayBufferView(Uint8Array, Int128.convertArray(sources[offset]));
      } else if (DataType.isBinary(type) || DataType.isFixedSizeBinary(type)) {
        return binaryDataFromJSON(sources[offset]);
      } else if (DataType.isBool(type)) {
        return packBools(sources[offset]);
      } else if (DataType.isUtf8(type)) {
        return encodeUtf8(sources[offset].join(""));
      }
      return toArrayBufferView(Uint8Array, toArrayBufferView(type.ArrayType, sources[offset].map((x) => +x)));
    }
  };
  function binaryDataFromJSON(values) {
    const joined = values.join("");
    const data2 = new Uint8Array(joined.length / 2);
    for (let i2 = 0; i2 < joined.length; i2 += 2) {
      data2[i2 >> 1] = Number.parseInt(joined.slice(i2, i2 + 2), 16);
    }
    return data2;
  }

  // ../../node_modules/apache-arrow/builder/binary.mjs
  var BinaryBuilder = class extends VariableWidthBuilder {
    constructor(opts) {
      super(opts);
      this._values = new BufferBuilder(new Uint8Array(0));
    }
    get byteLength() {
      let size = this._pendingLength + this.length * 4;
      this._offsets && (size += this._offsets.byteLength);
      this._values && (size += this._values.byteLength);
      this._nulls && (size += this._nulls.byteLength);
      return size;
    }
    setValue(index, value) {
      return super.setValue(index, toUint8Array(value));
    }
    _flushPending(pending, pendingLength) {
      const offsets = this._offsets;
      const data2 = this._values.reserve(pendingLength).buffer;
      let offset = 0;
      for (const [index, value] of pending) {
        if (value === void 0) {
          offsets.set(index, 0);
        } else {
          const length = value.length;
          data2.set(value, offset);
          offsets.set(index, length);
          offset += length;
        }
      }
    }
  };

  // ../../node_modules/apache-arrow/builder/bool.mjs
  var BoolBuilder = class extends Builder {
    constructor(options) {
      super(options);
      this._values = new BitmapBufferBuilder();
    }
    setValue(index, value) {
      this._values.set(index, +value);
    }
  };

  // ../../node_modules/apache-arrow/builder/date.mjs
  var DateBuilder = class extends FixedWidthBuilder {
  };
  DateBuilder.prototype._setValue = setDate;
  var DateDayBuilder = class extends DateBuilder {
  };
  DateDayBuilder.prototype._setValue = setDateDay;
  var DateMillisecondBuilder = class extends DateBuilder {
  };
  DateMillisecondBuilder.prototype._setValue = setDateMillisecond;

  // ../../node_modules/apache-arrow/builder/decimal.mjs
  var DecimalBuilder = class extends FixedWidthBuilder {
  };
  DecimalBuilder.prototype._setValue = setDecimal;

  // ../../node_modules/apache-arrow/builder/dictionary.mjs
  var DictionaryBuilder = class extends Builder {
    constructor({ "type": type, "nullValues": nulls, "dictionaryHashFunction": hashFn }) {
      super({ type: new Dictionary(type.dictionary, type.indices, type.id, type.isOrdered) });
      this._nulls = null;
      this._dictionaryOffset = 0;
      this._keysToIndices = /* @__PURE__ */ Object.create(null);
      this.indices = makeBuilder({ "type": this.type.indices, "nullValues": nulls });
      this.dictionary = makeBuilder({ "type": this.type.dictionary, "nullValues": null });
      if (typeof hashFn === "function") {
        this.valueToKey = hashFn;
      }
    }
    get values() {
      return this.indices.values;
    }
    get nullCount() {
      return this.indices.nullCount;
    }
    get nullBitmap() {
      return this.indices.nullBitmap;
    }
    get byteLength() {
      return this.indices.byteLength + this.dictionary.byteLength;
    }
    get reservedLength() {
      return this.indices.reservedLength + this.dictionary.reservedLength;
    }
    get reservedByteLength() {
      return this.indices.reservedByteLength + this.dictionary.reservedByteLength;
    }
    isValid(value) {
      return this.indices.isValid(value);
    }
    setValid(index, valid) {
      const indices = this.indices;
      valid = indices.setValid(index, valid);
      this.length = indices.length;
      return valid;
    }
    setValue(index, value) {
      const keysToIndices = this._keysToIndices;
      const key = this.valueToKey(value);
      let idx = keysToIndices[key];
      if (idx === void 0) {
        keysToIndices[key] = idx = this._dictionaryOffset + this.dictionary.append(value).length - 1;
      }
      return this.indices.setValue(index, idx);
    }
    flush() {
      const type = this.type;
      const prev = this._dictionary;
      const curr = this.dictionary.toVector();
      const data2 = this.indices.flush().clone(type);
      data2.dictionary = prev ? prev.concat(curr) : curr;
      this.finished || (this._dictionaryOffset += curr.length);
      this._dictionary = data2.dictionary;
      this.clear();
      return data2;
    }
    finish() {
      this.indices.finish();
      this.dictionary.finish();
      this._dictionaryOffset = 0;
      this._keysToIndices = /* @__PURE__ */ Object.create(null);
      return super.finish();
    }
    clear() {
      this.indices.clear();
      this.dictionary.clear();
      return super.clear();
    }
    valueToKey(val) {
      return typeof val === "string" ? val : `${val}`;
    }
  };

  // ../../node_modules/apache-arrow/builder/fixedsizebinary.mjs
  var FixedSizeBinaryBuilder = class extends FixedWidthBuilder {
  };
  FixedSizeBinaryBuilder.prototype._setValue = setFixedSizeBinary;

  // ../../node_modules/apache-arrow/builder/fixedsizelist.mjs
  var FixedSizeListBuilder = class extends Builder {
    setValue(index, value) {
      const [child] = this.children;
      const start2 = index * this.stride;
      for (let i2 = -1, n = value.length; ++i2 < n; ) {
        child.set(start2 + i2, value[i2]);
      }
    }
    addChild(child, name2 = "0") {
      if (this.numChildren > 0) {
        throw new Error("FixedSizeListBuilder can only have one child.");
      }
      const childIndex = this.children.push(child);
      this.type = new FixedSizeList(this.type.listSize, new Field2(name2, child.type, true));
      return childIndex;
    }
  };

  // ../../node_modules/apache-arrow/builder/float.mjs
  var FloatBuilder = class extends FixedWidthBuilder {
    setValue(index, value) {
      this._values.set(index, value);
    }
  };
  var Float16Builder = class extends FloatBuilder {
    setValue(index, value) {
      super.setValue(index, float64ToUint16(value));
    }
  };
  var Float32Builder = class extends FloatBuilder {
  };
  var Float64Builder = class extends FloatBuilder {
  };

  // ../../node_modules/apache-arrow/builder/interval.mjs
  var IntervalBuilder = class extends FixedWidthBuilder {
  };
  IntervalBuilder.prototype._setValue = setIntervalValue;
  var IntervalDayTimeBuilder = class extends IntervalBuilder {
  };
  IntervalDayTimeBuilder.prototype._setValue = setIntervalDayTime;
  var IntervalYearMonthBuilder = class extends IntervalBuilder {
  };
  IntervalYearMonthBuilder.prototype._setValue = setIntervalYearMonth;

  // ../../node_modules/apache-arrow/builder/duration.mjs
  var DurationBuilder = class extends FixedWidthBuilder {
  };
  DurationBuilder.prototype._setValue = setDuration;
  var DurationSecondBuilder = class extends DurationBuilder {
  };
  DurationSecondBuilder.prototype._setValue = setDurationSecond;
  var DurationMillisecondBuilder = class extends DurationBuilder {
  };
  DurationMillisecondBuilder.prototype._setValue = setDurationMillisecond;
  var DurationMicrosecondBuilder = class extends DurationBuilder {
  };
  DurationMicrosecondBuilder.prototype._setValue = setDurationMicrosecond;
  var DurationNanosecondBuilder = class extends DurationBuilder {
  };
  DurationNanosecondBuilder.prototype._setValue = setDurationNanosecond;

  // ../../node_modules/apache-arrow/builder/int.mjs
  var IntBuilder = class extends FixedWidthBuilder {
    setValue(index, value) {
      this._values.set(index, value);
    }
  };
  var Int8Builder = class extends IntBuilder {
  };
  var Int16Builder = class extends IntBuilder {
  };
  var Int32Builder = class extends IntBuilder {
  };
  var Int64Builder = class extends IntBuilder {
  };
  var Uint8Builder = class extends IntBuilder {
  };
  var Uint16Builder = class extends IntBuilder {
  };
  var Uint32Builder = class extends IntBuilder {
  };
  var Uint64Builder = class extends IntBuilder {
  };

  // ../../node_modules/apache-arrow/builder/list.mjs
  var ListBuilder = class extends VariableWidthBuilder {
    constructor(opts) {
      super(opts);
      this._offsets = new OffsetsBufferBuilder();
    }
    addChild(child, name2 = "0") {
      if (this.numChildren > 0) {
        throw new Error("ListBuilder can only have one child.");
      }
      this.children[this.numChildren] = child;
      this.type = new List(new Field2(name2, child.type, true));
      return this.numChildren - 1;
    }
    _flushPending(pending) {
      const offsets = this._offsets;
      const [child] = this.children;
      for (const [index, value] of pending) {
        if (typeof value === "undefined") {
          offsets.set(index, 0);
        } else {
          const v = value;
          const n = v.length;
          const start2 = offsets.set(index, n).buffer[index];
          for (let i2 = -1; ++i2 < n; ) {
            child.set(start2 + i2, v[i2]);
          }
        }
      }
    }
  };

  // ../../node_modules/apache-arrow/builder/map.mjs
  var MapBuilder = class extends VariableWidthBuilder {
    set(index, value) {
      return super.set(index, value);
    }
    setValue(index, value) {
      const row = value instanceof Map ? value : new Map(Object.entries(value));
      const pending = this._pending || (this._pending = /* @__PURE__ */ new Map());
      const current = pending.get(index);
      current && (this._pendingLength -= current.size);
      this._pendingLength += row.size;
      pending.set(index, row);
    }
    addChild(child, name2 = `${this.numChildren}`) {
      if (this.numChildren > 0) {
        throw new Error("ListBuilder can only have one child.");
      }
      this.children[this.numChildren] = child;
      this.type = new Map_(new Field2(name2, child.type, true), this.type.keysSorted);
      return this.numChildren - 1;
    }
    _flushPending(pending) {
      const offsets = this._offsets;
      const [child] = this.children;
      for (const [index, value] of pending) {
        if (value === void 0) {
          offsets.set(index, 0);
        } else {
          let { [index]: idx, [index + 1]: end } = offsets.set(index, value.size).buffer;
          for (const val of value.entries()) {
            child.set(idx, val);
            if (++idx >= end)
              break;
          }
        }
      }
    }
  };

  // ../../node_modules/apache-arrow/builder/null.mjs
  var NullBuilder = class extends Builder {
    // @ts-ignore
    setValue(index, value) {
    }
    setValid(index, valid) {
      this.length = Math.max(index + 1, this.length);
      return valid;
    }
  };

  // ../../node_modules/apache-arrow/builder/struct.mjs
  var StructBuilder = class extends Builder {
    setValue(index, value) {
      const { children, type } = this;
      switch (Array.isArray(value) || value.constructor) {
        case true:
          return type.children.forEach((_, i2) => children[i2].set(index, value[i2]));
        case Map:
          return type.children.forEach((f, i2) => children[i2].set(index, value.get(f.name)));
        default:
          return type.children.forEach((f, i2) => children[i2].set(index, value[f.name]));
      }
    }
    /** @inheritdoc */
    setValid(index, valid) {
      if (!super.setValid(index, valid)) {
        this.children.forEach((child) => child.setValid(index, valid));
      }
      return valid;
    }
    addChild(child, name2 = `${this.numChildren}`) {
      const childIndex = this.children.push(child);
      this.type = new Struct([...this.type.children, new Field2(name2, child.type, true)]);
      return childIndex;
    }
  };

  // ../../node_modules/apache-arrow/builder/timestamp.mjs
  var TimestampBuilder = class extends FixedWidthBuilder {
  };
  TimestampBuilder.prototype._setValue = setTimestamp;
  var TimestampSecondBuilder = class extends TimestampBuilder {
  };
  TimestampSecondBuilder.prototype._setValue = setTimestampSecond;
  var TimestampMillisecondBuilder = class extends TimestampBuilder {
  };
  TimestampMillisecondBuilder.prototype._setValue = setTimestampMillisecond;
  var TimestampMicrosecondBuilder = class extends TimestampBuilder {
  };
  TimestampMicrosecondBuilder.prototype._setValue = setTimestampMicrosecond;
  var TimestampNanosecondBuilder = class extends TimestampBuilder {
  };
  TimestampNanosecondBuilder.prototype._setValue = setTimestampNanosecond;

  // ../../node_modules/apache-arrow/builder/time.mjs
  var TimeBuilder = class extends FixedWidthBuilder {
  };
  TimeBuilder.prototype._setValue = setTime;
  var TimeSecondBuilder = class extends TimeBuilder {
  };
  TimeSecondBuilder.prototype._setValue = setTimeSecond;
  var TimeMillisecondBuilder = class extends TimeBuilder {
  };
  TimeMillisecondBuilder.prototype._setValue = setTimeMillisecond;
  var TimeMicrosecondBuilder = class extends TimeBuilder {
  };
  TimeMicrosecondBuilder.prototype._setValue = setTimeMicrosecond;
  var TimeNanosecondBuilder = class extends TimeBuilder {
  };
  TimeNanosecondBuilder.prototype._setValue = setTimeNanosecond;

  // ../../node_modules/apache-arrow/builder/union.mjs
  var UnionBuilder = class extends Builder {
    constructor(options) {
      super(options);
      this._typeIds = new DataBufferBuilder(new Int8Array(0), 1);
      if (typeof options["valueToChildTypeId"] === "function") {
        this._valueToChildTypeId = options["valueToChildTypeId"];
      }
    }
    get typeIdToChildIndex() {
      return this.type.typeIdToChildIndex;
    }
    append(value, childTypeId) {
      return this.set(this.length, value, childTypeId);
    }
    set(index, value, childTypeId) {
      if (childTypeId === void 0) {
        childTypeId = this._valueToChildTypeId(this, value, index);
      }
      this.setValue(index, value, childTypeId);
      return this;
    }
    setValue(index, value, childTypeId) {
      this._typeIds.set(index, childTypeId);
      const childIndex = this.type.typeIdToChildIndex[childTypeId];
      const child = this.children[childIndex];
      child === null || child === void 0 ? void 0 : child.set(index, value);
    }
    addChild(child, name2 = `${this.children.length}`) {
      const childTypeId = this.children.push(child);
      const { type: { children, mode, typeIds } } = this;
      const fields = [...children, new Field2(name2, child.type)];
      this.type = new Union_(mode, [...typeIds, childTypeId], fields);
      return childTypeId;
    }
    /** @ignore */
    // @ts-ignore
    _valueToChildTypeId(builder, value, offset) {
      throw new Error(`Cannot map UnionBuilder value to child typeId. Pass the \`childTypeId\` as the second argument to unionBuilder.append(), or supply a \`valueToChildTypeId\` function as part of the UnionBuilder constructor options.`);
    }
  };
  var SparseUnionBuilder = class extends UnionBuilder {
  };
  var DenseUnionBuilder = class extends UnionBuilder {
    constructor(options) {
      super(options);
      this._offsets = new DataBufferBuilder(new Int32Array(0));
    }
    /** @ignore */
    setValue(index, value, childTypeId) {
      const id = this._typeIds.set(index, childTypeId).buffer[index];
      const child = this.getChildAt(this.type.typeIdToChildIndex[id]);
      const denseIndex = this._offsets.set(index, child.length).buffer[index];
      child === null || child === void 0 ? void 0 : child.set(denseIndex, value);
    }
  };

  // ../../node_modules/apache-arrow/builder/utf8.mjs
  var Utf8Builder = class extends VariableWidthBuilder {
    constructor(opts) {
      super(opts);
      this._values = new BufferBuilder(new Uint8Array(0));
    }
    get byteLength() {
      let size = this._pendingLength + this.length * 4;
      this._offsets && (size += this._offsets.byteLength);
      this._values && (size += this._values.byteLength);
      this._nulls && (size += this._nulls.byteLength);
      return size;
    }
    setValue(index, value) {
      return super.setValue(index, encodeUtf8(value));
    }
    // @ts-ignore
    _flushPending(pending, pendingLength) {
    }
  };
  Utf8Builder.prototype._flushPending = BinaryBuilder.prototype._flushPending;

  // ../../node_modules/apache-arrow/visitor/builderctor.mjs
  var GetBuilderCtor = class extends Visitor {
    visitNull() {
      return NullBuilder;
    }
    visitBool() {
      return BoolBuilder;
    }
    visitInt() {
      return IntBuilder;
    }
    visitInt8() {
      return Int8Builder;
    }
    visitInt16() {
      return Int16Builder;
    }
    visitInt32() {
      return Int32Builder;
    }
    visitInt64() {
      return Int64Builder;
    }
    visitUint8() {
      return Uint8Builder;
    }
    visitUint16() {
      return Uint16Builder;
    }
    visitUint32() {
      return Uint32Builder;
    }
    visitUint64() {
      return Uint64Builder;
    }
    visitFloat() {
      return FloatBuilder;
    }
    visitFloat16() {
      return Float16Builder;
    }
    visitFloat32() {
      return Float32Builder;
    }
    visitFloat64() {
      return Float64Builder;
    }
    visitUtf8() {
      return Utf8Builder;
    }
    visitBinary() {
      return BinaryBuilder;
    }
    visitFixedSizeBinary() {
      return FixedSizeBinaryBuilder;
    }
    visitDate() {
      return DateBuilder;
    }
    visitDateDay() {
      return DateDayBuilder;
    }
    visitDateMillisecond() {
      return DateMillisecondBuilder;
    }
    visitTimestamp() {
      return TimestampBuilder;
    }
    visitTimestampSecond() {
      return TimestampSecondBuilder;
    }
    visitTimestampMillisecond() {
      return TimestampMillisecondBuilder;
    }
    visitTimestampMicrosecond() {
      return TimestampMicrosecondBuilder;
    }
    visitTimestampNanosecond() {
      return TimestampNanosecondBuilder;
    }
    visitTime() {
      return TimeBuilder;
    }
    visitTimeSecond() {
      return TimeSecondBuilder;
    }
    visitTimeMillisecond() {
      return TimeMillisecondBuilder;
    }
    visitTimeMicrosecond() {
      return TimeMicrosecondBuilder;
    }
    visitTimeNanosecond() {
      return TimeNanosecondBuilder;
    }
    visitDecimal() {
      return DecimalBuilder;
    }
    visitList() {
      return ListBuilder;
    }
    visitStruct() {
      return StructBuilder;
    }
    visitUnion() {
      return UnionBuilder;
    }
    visitDenseUnion() {
      return DenseUnionBuilder;
    }
    visitSparseUnion() {
      return SparseUnionBuilder;
    }
    visitDictionary() {
      return DictionaryBuilder;
    }
    visitInterval() {
      return IntervalBuilder;
    }
    visitIntervalDayTime() {
      return IntervalDayTimeBuilder;
    }
    visitIntervalYearMonth() {
      return IntervalYearMonthBuilder;
    }
    visitDuration() {
      return DurationBuilder;
    }
    visitDurationSecond() {
      return DurationSecondBuilder;
    }
    visitDurationMillisecond() {
      return DurationMillisecondBuilder;
    }
    visitDurationMicrosecond() {
      return DurationMicrosecondBuilder;
    }
    visistDurationNanosecond() {
      return DurationNanosecondBuilder;
    }
    visitFixedSizeList() {
      return FixedSizeListBuilder;
    }
    visitMap() {
      return MapBuilder;
    }
  };
  var instance7 = new GetBuilderCtor();

  // ../../node_modules/apache-arrow/visitor/typecomparator.mjs
  var TypeComparator = class extends Visitor {
    compareSchemas(schema, other) {
      return schema === other || other instanceof schema.constructor && this.compareManyFields(schema.fields, other.fields);
    }
    compareManyFields(fields, others) {
      return fields === others || Array.isArray(fields) && Array.isArray(others) && fields.length === others.length && fields.every((f, i2) => this.compareFields(f, others[i2]));
    }
    compareFields(field, other) {
      return field === other || other instanceof field.constructor && field.name === other.name && field.nullable === other.nullable && this.visit(field.type, other.type);
    }
  };
  function compareConstructor(type, other) {
    return other instanceof type.constructor;
  }
  function compareAny(type, other) {
    return type === other || compareConstructor(type, other);
  }
  function compareInt(type, other) {
    return type === other || compareConstructor(type, other) && type.bitWidth === other.bitWidth && type.isSigned === other.isSigned;
  }
  function compareFloat(type, other) {
    return type === other || compareConstructor(type, other) && type.precision === other.precision;
  }
  function compareFixedSizeBinary(type, other) {
    return type === other || compareConstructor(type, other) && type.byteWidth === other.byteWidth;
  }
  function compareDate(type, other) {
    return type === other || compareConstructor(type, other) && type.unit === other.unit;
  }
  function compareTimestamp(type, other) {
    return type === other || compareConstructor(type, other) && type.unit === other.unit && type.timezone === other.timezone;
  }
  function compareTime(type, other) {
    return type === other || compareConstructor(type, other) && type.unit === other.unit && type.bitWidth === other.bitWidth;
  }
  function compareList(type, other) {
    return type === other || compareConstructor(type, other) && type.children.length === other.children.length && instance8.compareManyFields(type.children, other.children);
  }
  function compareStruct(type, other) {
    return type === other || compareConstructor(type, other) && type.children.length === other.children.length && instance8.compareManyFields(type.children, other.children);
  }
  function compareUnion(type, other) {
    return type === other || compareConstructor(type, other) && type.mode === other.mode && type.typeIds.every((x, i2) => x === other.typeIds[i2]) && instance8.compareManyFields(type.children, other.children);
  }
  function compareDictionary(type, other) {
    return type === other || compareConstructor(type, other) && type.id === other.id && type.isOrdered === other.isOrdered && instance8.visit(type.indices, other.indices) && instance8.visit(type.dictionary, other.dictionary);
  }
  function compareInterval(type, other) {
    return type === other || compareConstructor(type, other) && type.unit === other.unit;
  }
  function compareDuration(type, other) {
    return type === other || compareConstructor(type, other) && type.unit === other.unit;
  }
  function compareFixedSizeList(type, other) {
    return type === other || compareConstructor(type, other) && type.listSize === other.listSize && type.children.length === other.children.length && instance8.compareManyFields(type.children, other.children);
  }
  function compareMap(type, other) {
    return type === other || compareConstructor(type, other) && type.keysSorted === other.keysSorted && type.children.length === other.children.length && instance8.compareManyFields(type.children, other.children);
  }
  TypeComparator.prototype.visitNull = compareAny;
  TypeComparator.prototype.visitBool = compareAny;
  TypeComparator.prototype.visitInt = compareInt;
  TypeComparator.prototype.visitInt8 = compareInt;
  TypeComparator.prototype.visitInt16 = compareInt;
  TypeComparator.prototype.visitInt32 = compareInt;
  TypeComparator.prototype.visitInt64 = compareInt;
  TypeComparator.prototype.visitUint8 = compareInt;
  TypeComparator.prototype.visitUint16 = compareInt;
  TypeComparator.prototype.visitUint32 = compareInt;
  TypeComparator.prototype.visitUint64 = compareInt;
  TypeComparator.prototype.visitFloat = compareFloat;
  TypeComparator.prototype.visitFloat16 = compareFloat;
  TypeComparator.prototype.visitFloat32 = compareFloat;
  TypeComparator.prototype.visitFloat64 = compareFloat;
  TypeComparator.prototype.visitUtf8 = compareAny;
  TypeComparator.prototype.visitBinary = compareAny;
  TypeComparator.prototype.visitFixedSizeBinary = compareFixedSizeBinary;
  TypeComparator.prototype.visitDate = compareDate;
  TypeComparator.prototype.visitDateDay = compareDate;
  TypeComparator.prototype.visitDateMillisecond = compareDate;
  TypeComparator.prototype.visitTimestamp = compareTimestamp;
  TypeComparator.prototype.visitTimestampSecond = compareTimestamp;
  TypeComparator.prototype.visitTimestampMillisecond = compareTimestamp;
  TypeComparator.prototype.visitTimestampMicrosecond = compareTimestamp;
  TypeComparator.prototype.visitTimestampNanosecond = compareTimestamp;
  TypeComparator.prototype.visitTime = compareTime;
  TypeComparator.prototype.visitTimeSecond = compareTime;
  TypeComparator.prototype.visitTimeMillisecond = compareTime;
  TypeComparator.prototype.visitTimeMicrosecond = compareTime;
  TypeComparator.prototype.visitTimeNanosecond = compareTime;
  TypeComparator.prototype.visitDecimal = compareAny;
  TypeComparator.prototype.visitList = compareList;
  TypeComparator.prototype.visitStruct = compareStruct;
  TypeComparator.prototype.visitUnion = compareUnion;
  TypeComparator.prototype.visitDenseUnion = compareUnion;
  TypeComparator.prototype.visitSparseUnion = compareUnion;
  TypeComparator.prototype.visitDictionary = compareDictionary;
  TypeComparator.prototype.visitInterval = compareInterval;
  TypeComparator.prototype.visitIntervalDayTime = compareInterval;
  TypeComparator.prototype.visitIntervalYearMonth = compareInterval;
  TypeComparator.prototype.visitDuration = compareDuration;
  TypeComparator.prototype.visitDurationSecond = compareDuration;
  TypeComparator.prototype.visitDurationMillisecond = compareDuration;
  TypeComparator.prototype.visitDurationMicrosecond = compareDuration;
  TypeComparator.prototype.visitDurationNanosecond = compareDuration;
  TypeComparator.prototype.visitFixedSizeList = compareFixedSizeList;
  TypeComparator.prototype.visitMap = compareMap;
  var instance8 = new TypeComparator();
  function compareSchemas(schema, other) {
    return instance8.compareSchemas(schema, other);
  }
  function compareFields(field, other) {
    return instance8.compareFields(field, other);
  }
  function compareTypes(type, other) {
    return instance8.visit(type, other);
  }

  // ../../node_modules/apache-arrow/factories.mjs
  function makeBuilder(options) {
    const type = options.type;
    const builder = new (instance7.getVisitFn(type)())(options);
    if (type.children && type.children.length > 0) {
      const children = options["children"] || [];
      const defaultOptions = { "nullValues": options["nullValues"] };
      const getChildOptions = Array.isArray(children) ? (_, i2) => children[i2] || defaultOptions : ({ name: name2 }) => children[name2] || defaultOptions;
      for (const [index, field] of type.children.entries()) {
        const { type: type2 } = field;
        const opts = getChildOptions(field, index);
        builder.children.push(makeBuilder(Object.assign(Object.assign({}, opts), { type: type2 })));
      }
    }
    return builder;
  }
  function vectorFromArray(init2, type) {
    if (init2 instanceof Data || init2 instanceof Vector || init2.type instanceof DataType || ArrayBuffer.isView(init2)) {
      return makeVector(init2);
    }
    const options = { type: type !== null && type !== void 0 ? type : inferType(init2), nullValues: [null] };
    const chunks = [...builderThroughIterable(options)(init2)];
    const vector = chunks.length === 1 ? chunks[0] : chunks.reduce((a, b) => a.concat(b));
    if (DataType.isDictionary(vector.type)) {
      return vector.memoize();
    }
    return vector;
  }
  function inferType(value) {
    if (value.length === 0) {
      return new Null();
    }
    let nullsCount = 0;
    let arraysCount = 0;
    let objectsCount = 0;
    let numbersCount = 0;
    let stringsCount = 0;
    let bigintsCount = 0;
    let booleansCount = 0;
    let datesCount = 0;
    for (const val of value) {
      if (val == null) {
        ++nullsCount;
        continue;
      }
      switch (typeof val) {
        case "bigint":
          ++bigintsCount;
          continue;
        case "boolean":
          ++booleansCount;
          continue;
        case "number":
          ++numbersCount;
          continue;
        case "string":
          ++stringsCount;
          continue;
        case "object":
          if (Array.isArray(val)) {
            ++arraysCount;
          } else if (Object.prototype.toString.call(val) === "[object Date]") {
            ++datesCount;
          } else {
            ++objectsCount;
          }
          continue;
      }
      throw new TypeError("Unable to infer Vector type from input values, explicit type declaration expected.");
    }
    if (numbersCount + nullsCount === value.length) {
      return new Float64();
    } else if (stringsCount + nullsCount === value.length) {
      return new Dictionary(new Utf8(), new Int32());
    } else if (bigintsCount + nullsCount === value.length) {
      return new Int64();
    } else if (booleansCount + nullsCount === value.length) {
      return new Bool();
    } else if (datesCount + nullsCount === value.length) {
      return new DateMillisecond();
    } else if (arraysCount + nullsCount === value.length) {
      const array = value;
      const childType = inferType(array[array.findIndex((ary) => ary != null)]);
      if (array.every((ary) => ary == null || compareTypes(childType, inferType(ary)))) {
        return new List(new Field2("", childType, true));
      }
    } else if (objectsCount + nullsCount === value.length) {
      const fields = /* @__PURE__ */ new Map();
      for (const row of value) {
        for (const key of Object.keys(row)) {
          if (!fields.has(key) && row[key] != null) {
            fields.set(key, new Field2(key, inferType([row[key]]), true));
          }
        }
      }
      return new Struct([...fields.values()]);
    }
    throw new TypeError("Unable to infer Vector type from input values, explicit type declaration expected.");
  }
  function builderThroughIterable(options) {
    const { ["queueingStrategy"]: queueingStrategy = "count" } = options;
    const { ["highWaterMark"]: highWaterMark = queueingStrategy !== "bytes" ? Number.POSITIVE_INFINITY : Math.pow(2, 14) } = options;
    const sizeProperty = queueingStrategy !== "bytes" ? "length" : "byteLength";
    return function* (source) {
      let numChunks = 0;
      const builder = makeBuilder(options);
      for (const value of source) {
        if (builder.append(value)[sizeProperty] >= highWaterMark) {
          ++numChunks && (yield builder.toVector());
        }
      }
      if (builder.finish().length > 0 || numChunks === 0) {
        yield builder.toVector();
      }
    };
  }

  // ../../node_modules/apache-arrow/util/recordbatch.mjs
  function distributeVectorsIntoRecordBatches(schema, vecs) {
    return uniformlyDistributeChunksAcrossRecordBatches(schema, vecs.map((v) => v.data.concat()));
  }
  function uniformlyDistributeChunksAcrossRecordBatches(schema, cols) {
    const fields = [...schema.fields];
    const batches = [];
    const memo = { numBatches: cols.reduce((n, c) => Math.max(n, c.length), 0) };
    let numBatches = 0, batchLength = 0;
    let i2 = -1;
    const numColumns = cols.length;
    let child, children = [];
    while (memo.numBatches-- > 0) {
      for (batchLength = Number.POSITIVE_INFINITY, i2 = -1; ++i2 < numColumns; ) {
        children[i2] = child = cols[i2].shift();
        batchLength = Math.min(batchLength, child ? child.length : batchLength);
      }
      if (Number.isFinite(batchLength)) {
        children = distributeChildren(fields, batchLength, children, cols, memo);
        if (batchLength > 0) {
          batches[numBatches++] = makeData({
            type: new Struct(fields),
            length: batchLength,
            nullCount: 0,
            children: children.slice()
          });
        }
      }
    }
    return [
      schema = schema.assign(fields),
      batches.map((data2) => new RecordBatch(schema, data2))
    ];
  }
  function distributeChildren(fields, batchLength, children, columns, memo) {
    var _a5;
    const nullBitmapSize = (batchLength + 63 & ~63) >> 3;
    for (let i2 = -1, n = columns.length; ++i2 < n; ) {
      const child = children[i2];
      const length = child === null || child === void 0 ? void 0 : child.length;
      if (length >= batchLength) {
        if (length === batchLength) {
          children[i2] = child;
        } else {
          children[i2] = child.slice(0, batchLength);
          memo.numBatches = Math.max(memo.numBatches, columns[i2].unshift(child.slice(batchLength, length - batchLength)));
        }
      } else {
        const field = fields[i2];
        fields[i2] = field.clone({ nullable: true });
        children[i2] = (_a5 = child === null || child === void 0 ? void 0 : child._changeLengthAndBackfillNullBitmap(batchLength)) !== null && _a5 !== void 0 ? _a5 : makeData({
          type: field.type,
          length: batchLength,
          nullCount: batchLength,
          nullBitmap: new Uint8Array(nullBitmapSize)
        });
      }
    }
    return children;
  }

  // ../../node_modules/apache-arrow/table.mjs
  var _a3;
  var Table = class _Table {
    constructor(...args2) {
      var _b2, _c2;
      if (args2.length === 0) {
        this.batches = [];
        this.schema = new Schema2([]);
        this._offsets = [0];
        return this;
      }
      let schema;
      let offsets;
      if (args2[0] instanceof Schema2) {
        schema = args2.shift();
      }
      if (args2.at(-1) instanceof Uint32Array) {
        offsets = args2.pop();
      }
      const unwrap = (x) => {
        if (x) {
          if (x instanceof RecordBatch) {
            return [x];
          } else if (x instanceof _Table) {
            return x.batches;
          } else if (x instanceof Data) {
            if (x.type instanceof Struct) {
              return [new RecordBatch(new Schema2(x.type.children), x)];
            }
          } else if (Array.isArray(x)) {
            return x.flatMap((v) => unwrap(v));
          } else if (typeof x[Symbol.iterator] === "function") {
            return [...x].flatMap((v) => unwrap(v));
          } else if (typeof x === "object") {
            const keys = Object.keys(x);
            const vecs = keys.map((k) => new Vector([x[k]]));
            const schema2 = new Schema2(keys.map((k, i2) => new Field2(String(k), vecs[i2].type)));
            const [, batches2] = distributeVectorsIntoRecordBatches(schema2, vecs);
            return batches2.length === 0 ? [new RecordBatch(x)] : batches2;
          }
        }
        return [];
      };
      const batches = args2.flatMap((v) => unwrap(v));
      schema = (_c2 = schema !== null && schema !== void 0 ? schema : (_b2 = batches[0]) === null || _b2 === void 0 ? void 0 : _b2.schema) !== null && _c2 !== void 0 ? _c2 : new Schema2([]);
      if (!(schema instanceof Schema2)) {
        throw new TypeError("Table constructor expects a [Schema, RecordBatch[]] pair.");
      }
      for (const batch of batches) {
        if (!(batch instanceof RecordBatch)) {
          throw new TypeError("Table constructor expects a [Schema, RecordBatch[]] pair.");
        }
        if (!compareSchemas(schema, batch.schema)) {
          throw new TypeError("Table and inner RecordBatch schemas must be equivalent.");
        }
      }
      this.schema = schema;
      this.batches = batches;
      this._offsets = offsets !== null && offsets !== void 0 ? offsets : computeChunkOffsets(this.data);
    }
    /**
     * The contiguous {@link RecordBatch `RecordBatch`} chunks of the Table rows.
     */
    get data() {
      return this.batches.map(({ data: data2 }) => data2);
    }
    /**
     * The number of columns in this Table.
     */
    get numCols() {
      return this.schema.fields.length;
    }
    /**
     * The number of rows in this Table.
     */
    get numRows() {
      return this.data.reduce((numRows, data2) => numRows + data2.length, 0);
    }
    /**
     * The number of null rows in this Table.
     */
    get nullCount() {
      if (this._nullCount === -1) {
        this._nullCount = computeChunkNullCounts(this.data);
      }
      return this._nullCount;
    }
    /**
     * Check whether an element is null.
     *
     * @param index The index at which to read the validity bitmap.
     */
    // @ts-ignore
    isValid(index) {
      return false;
    }
    /**
     * Get an element value by position.
     *
     * @param index The index of the element to read.
     */
    // @ts-ignore
    get(index) {
      return null;
    }
    /**
     * Set an element value by position.
     *
     * @param index The index of the element to write.
     * @param value The value to set.
     */
    // @ts-ignore
    set(index, value) {
      return;
    }
    /**
     * Retrieve the index of the first occurrence of a value in an Vector.
     *
     * @param element The value to locate in the Vector.
     * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.
     */
    // @ts-ignore
    indexOf(element, offset) {
      return -1;
    }
    /**
     * Get the size in bytes of an element by index.
     * @param index The index at which to get the byteLength.
     */
    // @ts-ignore
    getByteLength(index) {
      return 0;
    }
    /**
     * Iterator for rows in this Table.
     */
    [Symbol.iterator]() {
      if (this.batches.length > 0) {
        return instance5.visit(new Vector(this.data));
      }
      return new Array(0)[Symbol.iterator]();
    }
    /**
     * Return a JavaScript Array of the Table rows.
     *
     * @returns An Array of Table rows.
     */
    toArray() {
      return [...this];
    }
    /**
     * Returns a string representation of the Table rows.
     *
     * @returns A string representation of the Table rows.
     */
    toString() {
      return `[
  ${this.toArray().join(",\n  ")}
]`;
    }
    /**
     * Combines two or more Tables of the same schema.
     *
     * @param others Additional Tables to add to the end of this Tables.
     */
    concat(...others) {
      const schema = this.schema;
      const data2 = this.data.concat(others.flatMap(({ data: data3 }) => data3));
      return new _Table(schema, data2.map((data3) => new RecordBatch(schema, data3)));
    }
    /**
     * Return a zero-copy sub-section of this Table.
     *
     * @param begin The beginning of the specified portion of the Table.
     * @param end The end of the specified portion of the Table. This is exclusive of the element at the index 'end'.
     */
    slice(begin, end) {
      const schema = this.schema;
      [begin, end] = clampRange({ length: this.numRows }, begin, end);
      const data2 = sliceChunks(this.data, this._offsets, begin, end);
      return new _Table(schema, data2.map((chunk) => new RecordBatch(schema, chunk)));
    }
    /**
     * Returns a child Vector by name, or null if this Vector has no child with the given name.
     *
     * @param name The name of the child to retrieve.
     */
    getChild(name2) {
      return this.getChildAt(this.schema.fields.findIndex((f) => f.name === name2));
    }
    /**
     * Returns a child Vector by index, or null if this Vector has no child at the supplied index.
     *
     * @param index The index of the child to retrieve.
     */
    getChildAt(index) {
      if (index > -1 && index < this.schema.fields.length) {
        const data2 = this.data.map((data3) => data3.children[index]);
        if (data2.length === 0) {
          const { type } = this.schema.fields[index];
          const empty = makeData({ type, length: 0, nullCount: 0 });
          data2.push(empty._changeLengthAndBackfillNullBitmap(this.numRows));
        }
        return new Vector(data2);
      }
      return null;
    }
    /**
     * Sets a child Vector by name.
     *
     * @param name The name of the child to overwrite.
     * @returns A new Table with the supplied child for the specified name.
     */
    setChild(name2, child) {
      var _b2;
      return this.setChildAt((_b2 = this.schema.fields) === null || _b2 === void 0 ? void 0 : _b2.findIndex((f) => f.name === name2), child);
    }
    setChildAt(index, child) {
      let schema = this.schema;
      let batches = [...this.batches];
      if (index > -1 && index < this.numCols) {
        if (!child) {
          child = new Vector([makeData({ type: new Null(), length: this.numRows })]);
        }
        const fields = schema.fields.slice();
        const field = fields[index].clone({ type: child.type });
        const children = this.schema.fields.map((_, i2) => this.getChildAt(i2));
        [fields[index], children[index]] = [field, child];
        [schema, batches] = distributeVectorsIntoRecordBatches(schema, children);
      }
      return new _Table(schema, batches);
    }
    /**
     * Construct a new Table containing only specified columns.
     *
     * @param columnNames Names of columns to keep.
     * @returns A new Table of columns matching the specified names.
     */
    select(columnNames) {
      const nameToIndex = this.schema.fields.reduce((m, f, i2) => m.set(f.name, i2), /* @__PURE__ */ new Map());
      return this.selectAt(columnNames.map((columnName) => nameToIndex.get(columnName)).filter((x) => x > -1));
    }
    /**
     * Construct a new Table containing only columns at the specified indices.
     *
     * @param columnIndices Indices of columns to keep.
     * @returns A new Table of columns at the specified indices.
     */
    selectAt(columnIndices) {
      const schema = this.schema.selectAt(columnIndices);
      const data2 = this.batches.map((batch) => batch.selectAt(columnIndices));
      return new _Table(schema, data2);
    }
    assign(other) {
      const fields = this.schema.fields;
      const [indices, oldToNew] = other.schema.fields.reduce((memo, f2, newIdx) => {
        const [indices2, oldToNew2] = memo;
        const i2 = fields.findIndex((f) => f.name === f2.name);
        ~i2 ? oldToNew2[i2] = newIdx : indices2.push(newIdx);
        return memo;
      }, [[], []]);
      const schema = this.schema.assign(other.schema);
      const columns = [
        ...fields.map((_, i2) => [i2, oldToNew[i2]]).map(([i2, j]) => j === void 0 ? this.getChildAt(i2) : other.getChildAt(j)),
        ...indices.map((i2) => other.getChildAt(i2))
      ].filter(Boolean);
      return new _Table(...distributeVectorsIntoRecordBatches(schema, columns));
    }
  };
  _a3 = Symbol.toStringTag;
  Table[_a3] = ((proto) => {
    proto.schema = null;
    proto.batches = [];
    proto._offsets = new Uint32Array([0]);
    proto._nullCount = -1;
    proto[Symbol.isConcatSpreadable] = true;
    proto["isValid"] = wrapChunkedCall1(isChunkedValid);
    proto["get"] = wrapChunkedCall1(instance3.getVisitFn(Type.Struct));
    proto["set"] = wrapChunkedCall2(instance2.getVisitFn(Type.Struct));
    proto["indexOf"] = wrapChunkedIndexOf(instance4.getVisitFn(Type.Struct));
    proto["getByteLength"] = wrapChunkedCall1(instance6.getVisitFn(Type.Struct));
    return "Table";
  })(Table.prototype);

  // ../../node_modules/apache-arrow/recordbatch.mjs
  var _a4;
  var RecordBatch = class _RecordBatch {
    constructor(...args2) {
      switch (args2.length) {
        case 2: {
          [this.schema] = args2;
          if (!(this.schema instanceof Schema2)) {
            throw new TypeError("RecordBatch constructor expects a [Schema, Data] pair.");
          }
          [
            ,
            this.data = makeData({
              nullCount: 0,
              type: new Struct(this.schema.fields),
              children: this.schema.fields.map((f) => makeData({ type: f.type, nullCount: 0 }))
            })
          ] = args2;
          if (!(this.data instanceof Data)) {
            throw new TypeError("RecordBatch constructor expects a [Schema, Data] pair.");
          }
          [this.schema, this.data] = ensureSameLengthData(this.schema, this.data.children);
          break;
        }
        case 1: {
          const [obj] = args2;
          const { fields, children, length } = Object.keys(obj).reduce((memo, name2, i2) => {
            memo.children[i2] = obj[name2];
            memo.length = Math.max(memo.length, obj[name2].length);
            memo.fields[i2] = Field2.new({ name: name2, type: obj[name2].type, nullable: true });
            return memo;
          }, {
            length: 0,
            fields: new Array(),
            children: new Array()
          });
          const schema = new Schema2(fields);
          const data2 = makeData({ type: new Struct(fields), length, children, nullCount: 0 });
          [this.schema, this.data] = ensureSameLengthData(schema, data2.children, length);
          break;
        }
        default:
          throw new TypeError("RecordBatch constructor expects an Object mapping names to child Data, or a [Schema, Data] pair.");
      }
    }
    get dictionaries() {
      return this._dictionaries || (this._dictionaries = collectDictionaries(this.schema.fields, this.data.children));
    }
    /**
     * The number of columns in this RecordBatch.
     */
    get numCols() {
      return this.schema.fields.length;
    }
    /**
     * The number of rows in this RecordBatch.
     */
    get numRows() {
      return this.data.length;
    }
    /**
     * The number of null rows in this RecordBatch.
     */
    get nullCount() {
      return this.data.nullCount;
    }
    /**
     * Check whether an element is null.
     * @param index The index at which to read the validity bitmap.
     */
    isValid(index) {
      return this.data.getValid(index);
    }
    /**
     * Get a row by position.
     * @param index The index of the element to read.
     */
    get(index) {
      return instance3.visit(this.data, index);
    }
    /**
     * Set a row by position.
     * @param index The index of the element to write.
     * @param value The value to set.
     */
    set(index, value) {
      return instance2.visit(this.data, index, value);
    }
    /**
     * Retrieve the index of the first occurrence of a row in an RecordBatch.
     * @param element The row to locate in the RecordBatch.
     * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.
     */
    indexOf(element, offset) {
      return instance4.visit(this.data, element, offset);
    }
    /**
     * Get the size (in bytes) of a row by index.
     * @param index The row index for which to compute the byteLength.
     */
    getByteLength(index) {
      return instance6.visit(this.data, index);
    }
    /**
     * Iterator for rows in this RecordBatch.
     */
    [Symbol.iterator]() {
      return instance5.visit(new Vector([this.data]));
    }
    /**
     * Return a JavaScript Array of the RecordBatch rows.
     * @returns An Array of RecordBatch rows.
     */
    toArray() {
      return [...this];
    }
    /**
     * Combines two or more RecordBatch of the same schema.
     * @param others Additional RecordBatch to add to the end of this RecordBatch.
     */
    concat(...others) {
      return new Table(this.schema, [this, ...others]);
    }
    /**
     * Return a zero-copy sub-section of this RecordBatch.
     * @param start The beginning of the specified portion of the RecordBatch.
     * @param end The end of the specified portion of the RecordBatch. This is exclusive of the element at the index 'end'.
     */
    slice(begin, end) {
      const [slice] = new Vector([this.data]).slice(begin, end).data;
      return new _RecordBatch(this.schema, slice);
    }
    /**
     * Returns a child Vector by name, or null if this Vector has no child with the given name.
     * @param name The name of the child to retrieve.
     */
    getChild(name2) {
      var _b2;
      return this.getChildAt((_b2 = this.schema.fields) === null || _b2 === void 0 ? void 0 : _b2.findIndex((f) => f.name === name2));
    }
    /**
     * Returns a child Vector by index, or null if this Vector has no child at the supplied index.
     * @param index The index of the child to retrieve.
     */
    getChildAt(index) {
      if (index > -1 && index < this.schema.fields.length) {
        return new Vector([this.data.children[index]]);
      }
      return null;
    }
    /**
     * Sets a child Vector by name.
     * @param name The name of the child to overwrite.
     * @returns A new RecordBatch with the new child for the specified name.
     */
    setChild(name2, child) {
      var _b2;
      return this.setChildAt((_b2 = this.schema.fields) === null || _b2 === void 0 ? void 0 : _b2.findIndex((f) => f.name === name2), child);
    }
    setChildAt(index, child) {
      let schema = this.schema;
      let data2 = this.data;
      if (index > -1 && index < this.numCols) {
        if (!child) {
          child = new Vector([makeData({ type: new Null(), length: this.numRows })]);
        }
        const fields = schema.fields.slice();
        const children = data2.children.slice();
        const field = fields[index].clone({ type: child.type });
        [fields[index], children[index]] = [field, child.data[0]];
        schema = new Schema2(fields, new Map(this.schema.metadata));
        data2 = makeData({ type: new Struct(fields), children });
      }
      return new _RecordBatch(schema, data2);
    }
    /**
     * Construct a new RecordBatch containing only specified columns.
     *
     * @param columnNames Names of columns to keep.
     * @returns A new RecordBatch of columns matching the specified names.
     */
    select(columnNames) {
      const schema = this.schema.select(columnNames);
      const type = new Struct(schema.fields);
      const children = [];
      for (const name2 of columnNames) {
        const index = this.schema.fields.findIndex((f) => f.name === name2);
        if (~index) {
          children[index] = this.data.children[index];
        }
      }
      return new _RecordBatch(schema, makeData({ type, length: this.numRows, children }));
    }
    /**
     * Construct a new RecordBatch containing only columns at the specified indices.
     *
     * @param columnIndices Indices of columns to keep.
     * @returns A new RecordBatch of columns matching at the specified indices.
     */
    selectAt(columnIndices) {
      const schema = this.schema.selectAt(columnIndices);
      const children = columnIndices.map((i2) => this.data.children[i2]).filter(Boolean);
      const subset = makeData({ type: new Struct(schema.fields), length: this.numRows, children });
      return new _RecordBatch(schema, subset);
    }
  };
  _a4 = Symbol.toStringTag;
  RecordBatch[_a4] = ((proto) => {
    proto._nullCount = -1;
    proto[Symbol.isConcatSpreadable] = true;
    return "RecordBatch";
  })(RecordBatch.prototype);
  function ensureSameLengthData(schema, chunks, maxLength = chunks.reduce((max, col) => Math.max(max, col.length), 0)) {
    var _b2;
    const fields = [...schema.fields];
    const children = [...chunks];
    const nullBitmapSize = (maxLength + 63 & ~63) >> 3;
    for (const [idx, field] of schema.fields.entries()) {
      const chunk = chunks[idx];
      if (!chunk || chunk.length !== maxLength) {
        fields[idx] = field.clone({ nullable: true });
        children[idx] = (_b2 = chunk === null || chunk === void 0 ? void 0 : chunk._changeLengthAndBackfillNullBitmap(maxLength)) !== null && _b2 !== void 0 ? _b2 : makeData({
          type: field.type,
          length: maxLength,
          nullCount: maxLength,
          nullBitmap: new Uint8Array(nullBitmapSize)
        });
      }
    }
    return [
      schema.assign(fields),
      makeData({ type: new Struct(fields), length: maxLength, children })
    ];
  }
  function collectDictionaries(fields, children, dictionaries = /* @__PURE__ */ new Map()) {
    var _b2, _c2;
    if (((_b2 = fields === null || fields === void 0 ? void 0 : fields.length) !== null && _b2 !== void 0 ? _b2 : 0) > 0 && (fields === null || fields === void 0 ? void 0 : fields.length) === (children === null || children === void 0 ? void 0 : children.length)) {
      for (let i2 = -1, n = fields.length; ++i2 < n; ) {
        const { type } = fields[i2];
        const data2 = children[i2];
        for (const next of [data2, ...((_c2 = data2 === null || data2 === void 0 ? void 0 : data2.dictionary) === null || _c2 === void 0 ? void 0 : _c2.data) || []]) {
          collectDictionaries(type.children, next === null || next === void 0 ? void 0 : next.children, dictionaries);
        }
        if (DataType.isDictionary(type)) {
          const { id } = type;
          if (!dictionaries.has(id)) {
            if (data2 === null || data2 === void 0 ? void 0 : data2.dictionary) {
              dictionaries.set(id, data2.dictionary);
            }
          } else if (dictionaries.get(id) !== data2.dictionary) {
            throw new Error(`Cannot create Schema containing two different dictionaries with the same Id`);
          }
        }
      }
    }
    return dictionaries;
  }
  var _InternalEmptyPlaceholderRecordBatch = class extends RecordBatch {
    constructor(schema) {
      const children = schema.fields.map((f) => makeData({ type: f.type }));
      const data2 = makeData({ type: new Struct(schema.fields), nullCount: 0, children });
      super(schema, data2);
    }
  };

  // ../../node_modules/apache-arrow/fb/body-compression-method.mjs
  var BodyCompressionMethod;
  (function(BodyCompressionMethod2) {
    BodyCompressionMethod2[BodyCompressionMethod2["BUFFER"] = 0] = "BUFFER";
  })(BodyCompressionMethod || (BodyCompressionMethod = {}));

  // ../../node_modules/apache-arrow/fb/compression-type.mjs
  var CompressionType;
  (function(CompressionType2) {
    CompressionType2[CompressionType2["LZ4_FRAME"] = 0] = "LZ4_FRAME";
    CompressionType2[CompressionType2["ZSTD"] = 1] = "ZSTD";
  })(CompressionType || (CompressionType = {}));

  // ../../node_modules/apache-arrow/fb/body-compression.mjs
  var BodyCompression = class _BodyCompression {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i2, bb) {
      this.bb_pos = i2;
      this.bb = bb;
      return this;
    }
    static getRootAsBodyCompression(bb, obj) {
      return (obj || new _BodyCompression()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsBodyCompression(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new _BodyCompression()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    /**
     * Compressor library.
     * For LZ4_FRAME, each compressed buffer must consist of a single frame.
     */
    codec() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt8(this.bb_pos + offset) : CompressionType.LZ4_FRAME;
    }
    /**
     * Indicates the way the record batch body was compressed
     */
    method() {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? this.bb.readInt8(this.bb_pos + offset) : BodyCompressionMethod.BUFFER;
    }
    static startBodyCompression(builder) {
      builder.startObject(2);
    }
    static addCodec(builder, codec) {
      builder.addFieldInt8(0, codec, CompressionType.LZ4_FRAME);
    }
    static addMethod(builder, method) {
      builder.addFieldInt8(1, method, BodyCompressionMethod.BUFFER);
    }
    static endBodyCompression(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createBodyCompression(builder, codec, method) {
      _BodyCompression.startBodyCompression(builder);
      _BodyCompression.addCodec(builder, codec);
      _BodyCompression.addMethod(builder, method);
      return _BodyCompression.endBodyCompression(builder);
    }
  };

  // ../../node_modules/apache-arrow/fb/buffer.mjs
  var Buffer2 = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i2, bb) {
      this.bb_pos = i2;
      this.bb = bb;
      return this;
    }
    /**
     * The relative offset into the shared memory page where the bytes for this
     * buffer starts
     */
    offset() {
      return this.bb.readInt64(this.bb_pos);
    }
    /**
     * The absolute length (in bytes) of the memory buffer. The memory is found
     * from offset (inclusive) to offset + length (non-inclusive). When building
     * messages using the encapsulated IPC message, padding bytes may be written
     * after a buffer, but such padding bytes do not need to be accounted for in
     * the size here.
     */
    length() {
      return this.bb.readInt64(this.bb_pos + 8);
    }
    static sizeOf() {
      return 16;
    }
    static createBuffer(builder, offset, length) {
      builder.prep(8, 16);
      builder.writeInt64(BigInt(length !== null && length !== void 0 ? length : 0));
      builder.writeInt64(BigInt(offset !== null && offset !== void 0 ? offset : 0));
      return builder.offset();
    }
  };

  // ../../node_modules/apache-arrow/fb/field-node.mjs
  var FieldNode = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i2, bb) {
      this.bb_pos = i2;
      this.bb = bb;
      return this;
    }
    /**
     * The number of value slots in the Arrow array at this level of a nested
     * tree
     */
    length() {
      return this.bb.readInt64(this.bb_pos);
    }
    /**
     * The number of observed nulls. Fields with null_count == 0 may choose not
     * to write their physical validity bitmap out as a materialized buffer,
     * instead setting the length of the bitmap buffer to 0.
     */
    nullCount() {
      return this.bb.readInt64(this.bb_pos + 8);
    }
    static sizeOf() {
      return 16;
    }
    static createFieldNode(builder, length, null_count) {
      builder.prep(8, 16);
      builder.writeInt64(BigInt(null_count !== null && null_count !== void 0 ? null_count : 0));
      builder.writeInt64(BigInt(length !== null && length !== void 0 ? length : 0));
      return builder.offset();
    }
  };

  // ../../node_modules/apache-arrow/fb/record-batch.mjs
  var RecordBatch2 = class _RecordBatch {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i2, bb) {
      this.bb_pos = i2;
      this.bb = bb;
      return this;
    }
    static getRootAsRecordBatch(bb, obj) {
      return (obj || new _RecordBatch()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsRecordBatch(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new _RecordBatch()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    /**
     * number of records / rows. The arrays in the batch should all have this
     * length
     */
    length() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt64(this.bb_pos + offset) : BigInt("0");
    }
    /**
     * Nodes correspond to the pre-ordered flattened logical schema
     */
    nodes(index, obj) {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? (obj || new FieldNode()).__init(this.bb.__vector(this.bb_pos + offset) + index * 16, this.bb) : null;
    }
    nodesLength() {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * Buffers correspond to the pre-ordered flattened buffer tree
     *
     * The number of buffers appended to this list depends on the schema. For
     * example, most primitive arrays will have 2 buffers, 1 for the validity
     * bitmap and 1 for the values. For struct arrays, there will only be a
     * single buffer for the validity (nulls) bitmap
     */
    buffers(index, obj) {
      const offset = this.bb.__offset(this.bb_pos, 8);
      return offset ? (obj || new Buffer2()).__init(this.bb.__vector(this.bb_pos + offset) + index * 16, this.bb) : null;
    }
    buffersLength() {
      const offset = this.bb.__offset(this.bb_pos, 8);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * Optional compression of the message body
     */
    compression(obj) {
      const offset = this.bb.__offset(this.bb_pos, 10);
      return offset ? (obj || new BodyCompression()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    static startRecordBatch(builder) {
      builder.startObject(4);
    }
    static addLength(builder, length) {
      builder.addFieldInt64(0, length, BigInt("0"));
    }
    static addNodes(builder, nodesOffset) {
      builder.addFieldOffset(1, nodesOffset, 0);
    }
    static startNodesVector(builder, numElems) {
      builder.startVector(16, numElems, 8);
    }
    static addBuffers(builder, buffersOffset) {
      builder.addFieldOffset(2, buffersOffset, 0);
    }
    static startBuffersVector(builder, numElems) {
      builder.startVector(16, numElems, 8);
    }
    static addCompression(builder, compressionOffset) {
      builder.addFieldOffset(3, compressionOffset, 0);
    }
    static endRecordBatch(builder) {
      const offset = builder.endObject();
      return offset;
    }
  };

  // ../../node_modules/apache-arrow/fb/dictionary-batch.mjs
  var DictionaryBatch = class _DictionaryBatch {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i2, bb) {
      this.bb_pos = i2;
      this.bb = bb;
      return this;
    }
    static getRootAsDictionaryBatch(bb, obj) {
      return (obj || new _DictionaryBatch()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsDictionaryBatch(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new _DictionaryBatch()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    id() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt64(this.bb_pos + offset) : BigInt("0");
    }
    data(obj) {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? (obj || new RecordBatch2()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    /**
     * If isDelta is true the values in the dictionary are to be appended to a
     * dictionary with the indicated id. If isDelta is false this dictionary
     * should replace the existing dictionary.
     */
    isDelta() {
      const offset = this.bb.__offset(this.bb_pos, 8);
      return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    static startDictionaryBatch(builder) {
      builder.startObject(3);
    }
    static addId(builder, id) {
      builder.addFieldInt64(0, id, BigInt("0"));
    }
    static addData(builder, dataOffset) {
      builder.addFieldOffset(1, dataOffset, 0);
    }
    static addIsDelta(builder, isDelta) {
      builder.addFieldInt8(2, +isDelta, 0);
    }
    static endDictionaryBatch(builder) {
      const offset = builder.endObject();
      return offset;
    }
  };

  // ../../node_modules/apache-arrow/fb/message-header.mjs
  var MessageHeader2;
  (function(MessageHeader3) {
    MessageHeader3[MessageHeader3["NONE"] = 0] = "NONE";
    MessageHeader3[MessageHeader3["Schema"] = 1] = "Schema";
    MessageHeader3[MessageHeader3["DictionaryBatch"] = 2] = "DictionaryBatch";
    MessageHeader3[MessageHeader3["RecordBatch"] = 3] = "RecordBatch";
    MessageHeader3[MessageHeader3["Tensor"] = 4] = "Tensor";
    MessageHeader3[MessageHeader3["SparseTensor"] = 5] = "SparseTensor";
  })(MessageHeader2 || (MessageHeader2 = {}));

  // ../../node_modules/apache-arrow/fb/message.mjs
  var Message = class _Message {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i2, bb) {
      this.bb_pos = i2;
      this.bb = bb;
      return this;
    }
    static getRootAsMessage(bb, obj) {
      return (obj || new _Message()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsMessage(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new _Message()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    version() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt16(this.bb_pos + offset) : MetadataVersion2.V1;
    }
    headerType() {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? this.bb.readUint8(this.bb_pos + offset) : MessageHeader2.NONE;
    }
    header(obj) {
      const offset = this.bb.__offset(this.bb_pos, 8);
      return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
    }
    bodyLength() {
      const offset = this.bb.__offset(this.bb_pos, 10);
      return offset ? this.bb.readInt64(this.bb_pos + offset) : BigInt("0");
    }
    customMetadata(index, obj) {
      const offset = this.bb.__offset(this.bb_pos, 12);
      return offset ? (obj || new KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    customMetadataLength() {
      const offset = this.bb.__offset(this.bb_pos, 12);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startMessage(builder) {
      builder.startObject(5);
    }
    static addVersion(builder, version) {
      builder.addFieldInt16(0, version, MetadataVersion2.V1);
    }
    static addHeaderType(builder, headerType) {
      builder.addFieldInt8(1, headerType, MessageHeader2.NONE);
    }
    static addHeader(builder, headerOffset) {
      builder.addFieldOffset(2, headerOffset, 0);
    }
    static addBodyLength(builder, bodyLength) {
      builder.addFieldInt64(3, bodyLength, BigInt("0"));
    }
    static addCustomMetadata(builder, customMetadataOffset) {
      builder.addFieldOffset(4, customMetadataOffset, 0);
    }
    static createCustomMetadataVector(builder, data2) {
      builder.startVector(4, data2.length, 4);
      for (let i2 = data2.length - 1; i2 >= 0; i2--) {
        builder.addOffset(data2[i2]);
      }
      return builder.endVector();
    }
    static startCustomMetadataVector(builder, numElems) {
      builder.startVector(4, numElems, 4);
    }
    static endMessage(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static finishMessageBuffer(builder, offset) {
      builder.finish(offset);
    }
    static finishSizePrefixedMessageBuffer(builder, offset) {
      builder.finish(offset, void 0, true);
    }
    static createMessage(builder, version, headerType, headerOffset, bodyLength, customMetadataOffset) {
      _Message.startMessage(builder);
      _Message.addVersion(builder, version);
      _Message.addHeaderType(builder, headerType);
      _Message.addHeader(builder, headerOffset);
      _Message.addBodyLength(builder, bodyLength);
      _Message.addCustomMetadata(builder, customMetadataOffset);
      return _Message.endMessage(builder);
    }
  };

  // ../../node_modules/apache-arrow/visitor/typeassembler.mjs
  var TypeAssembler = class extends Visitor {
    visit(node, builder) {
      return node == null || builder == null ? void 0 : super.visit(node, builder);
    }
    visitNull(_node, b) {
      Null2.startNull(b);
      return Null2.endNull(b);
    }
    visitInt(node, b) {
      Int.startInt(b);
      Int.addBitWidth(b, node.bitWidth);
      Int.addIsSigned(b, node.isSigned);
      return Int.endInt(b);
    }
    visitFloat(node, b) {
      FloatingPoint.startFloatingPoint(b);
      FloatingPoint.addPrecision(b, node.precision);
      return FloatingPoint.endFloatingPoint(b);
    }
    visitBinary(_node, b) {
      Binary2.startBinary(b);
      return Binary2.endBinary(b);
    }
    visitBool(_node, b) {
      Bool2.startBool(b);
      return Bool2.endBool(b);
    }
    visitUtf8(_node, b) {
      Utf82.startUtf8(b);
      return Utf82.endUtf8(b);
    }
    visitDecimal(node, b) {
      Decimal2.startDecimal(b);
      Decimal2.addScale(b, node.scale);
      Decimal2.addPrecision(b, node.precision);
      Decimal2.addBitWidth(b, node.bitWidth);
      return Decimal2.endDecimal(b);
    }
    visitDate(node, b) {
      Date2.startDate(b);
      Date2.addUnit(b, node.unit);
      return Date2.endDate(b);
    }
    visitTime(node, b) {
      Time.startTime(b);
      Time.addUnit(b, node.unit);
      Time.addBitWidth(b, node.bitWidth);
      return Time.endTime(b);
    }
    visitTimestamp(node, b) {
      const timezone = node.timezone && b.createString(node.timezone) || void 0;
      Timestamp.startTimestamp(b);
      Timestamp.addUnit(b, node.unit);
      if (timezone !== void 0) {
        Timestamp.addTimezone(b, timezone);
      }
      return Timestamp.endTimestamp(b);
    }
    visitInterval(node, b) {
      Interval.startInterval(b);
      Interval.addUnit(b, node.unit);
      return Interval.endInterval(b);
    }
    visitDuration(node, b) {
      Duration2.startDuration(b);
      Duration2.addUnit(b, node.unit);
      return Duration2.endDuration(b);
    }
    visitList(_node, b) {
      List2.startList(b);
      return List2.endList(b);
    }
    visitStruct(_node, b) {
      Struct_.startStruct_(b);
      return Struct_.endStruct_(b);
    }
    visitUnion(node, b) {
      Union.startTypeIdsVector(b, node.typeIds.length);
      const typeIds = Union.createTypeIdsVector(b, node.typeIds);
      Union.startUnion(b);
      Union.addMode(b, node.mode);
      Union.addTypeIds(b, typeIds);
      return Union.endUnion(b);
    }
    visitDictionary(node, b) {
      const indexType = this.visit(node.indices, b);
      DictionaryEncoding.startDictionaryEncoding(b);
      DictionaryEncoding.addId(b, BigInt(node.id));
      DictionaryEncoding.addIsOrdered(b, node.isOrdered);
      if (indexType !== void 0) {
        DictionaryEncoding.addIndexType(b, indexType);
      }
      return DictionaryEncoding.endDictionaryEncoding(b);
    }
    visitFixedSizeBinary(node, b) {
      FixedSizeBinary2.startFixedSizeBinary(b);
      FixedSizeBinary2.addByteWidth(b, node.byteWidth);
      return FixedSizeBinary2.endFixedSizeBinary(b);
    }
    visitFixedSizeList(node, b) {
      FixedSizeList2.startFixedSizeList(b);
      FixedSizeList2.addListSize(b, node.listSize);
      return FixedSizeList2.endFixedSizeList(b);
    }
    visitMap(node, b) {
      Map2.startMap(b);
      Map2.addKeysSorted(b, node.keysSorted);
      return Map2.endMap(b);
    }
  };
  var instance9 = new TypeAssembler();

  // ../../node_modules/apache-arrow/ipc/metadata/json.mjs
  function schemaFromJSON(_schema, dictionaries = /* @__PURE__ */ new Map()) {
    return new Schema2(schemaFieldsFromJSON(_schema, dictionaries), customMetadataFromJSON(_schema["metadata"]), dictionaries);
  }
  function recordBatchFromJSON(b) {
    return new RecordBatch3(b["count"], fieldNodesFromJSON(b["columns"]), buffersFromJSON(b["columns"]));
  }
  function dictionaryBatchFromJSON(b) {
    return new DictionaryBatch2(recordBatchFromJSON(b["data"]), b["id"], b["isDelta"]);
  }
  function schemaFieldsFromJSON(_schema, dictionaries) {
    return (_schema["fields"] || []).filter(Boolean).map((f) => Field2.fromJSON(f, dictionaries));
  }
  function fieldChildrenFromJSON(_field, dictionaries) {
    return (_field["children"] || []).filter(Boolean).map((f) => Field2.fromJSON(f, dictionaries));
  }
  function fieldNodesFromJSON(xs) {
    return (xs || []).reduce((fieldNodes, column) => [
      ...fieldNodes,
      new FieldNode2(column["count"], nullCountFromJSON(column["VALIDITY"])),
      ...fieldNodesFromJSON(column["children"])
    ], []);
  }
  function buffersFromJSON(xs, buffers = []) {
    for (let i2 = -1, n = (xs || []).length; ++i2 < n; ) {
      const column = xs[i2];
      column["VALIDITY"] && buffers.push(new BufferRegion(buffers.length, column["VALIDITY"].length));
      column["TYPE_ID"] && buffers.push(new BufferRegion(buffers.length, column["TYPE_ID"].length));
      column["OFFSET"] && buffers.push(new BufferRegion(buffers.length, column["OFFSET"].length));
      column["DATA"] && buffers.push(new BufferRegion(buffers.length, column["DATA"].length));
      buffers = buffersFromJSON(column["children"], buffers);
    }
    return buffers;
  }
  function nullCountFromJSON(validity) {
    return (validity || []).reduce((sum2, val) => sum2 + +(val === 0), 0);
  }
  function fieldFromJSON(_field, dictionaries) {
    let id;
    let keys;
    let field;
    let dictMeta;
    let type;
    let dictType;
    if (!dictionaries || !(dictMeta = _field["dictionary"])) {
      type = typeFromJSON(_field, fieldChildrenFromJSON(_field, dictionaries));
      field = new Field2(_field["name"], type, _field["nullable"], customMetadataFromJSON(_field["metadata"]));
    } else if (!dictionaries.has(id = dictMeta["id"])) {
      keys = (keys = dictMeta["indexType"]) ? indexTypeFromJSON(keys) : new Int32();
      dictionaries.set(id, type = typeFromJSON(_field, fieldChildrenFromJSON(_field, dictionaries)));
      dictType = new Dictionary(type, keys, id, dictMeta["isOrdered"]);
      field = new Field2(_field["name"], dictType, _field["nullable"], customMetadataFromJSON(_field["metadata"]));
    } else {
      keys = (keys = dictMeta["indexType"]) ? indexTypeFromJSON(keys) : new Int32();
      dictType = new Dictionary(dictionaries.get(id), keys, id, dictMeta["isOrdered"]);
      field = new Field2(_field["name"], dictType, _field["nullable"], customMetadataFromJSON(_field["metadata"]));
    }
    return field || null;
  }
  function customMetadataFromJSON(metadata2 = []) {
    return new Map(metadata2.map(({ key, value }) => [key, value]));
  }
  function indexTypeFromJSON(_type) {
    return new Int_(_type["isSigned"], _type["bitWidth"]);
  }
  function typeFromJSON(f, children) {
    const typeId = f["type"]["name"];
    switch (typeId) {
      case "NONE":
        return new Null();
      case "null":
        return new Null();
      case "binary":
        return new Binary();
      case "utf8":
        return new Utf8();
      case "bool":
        return new Bool();
      case "list":
        return new List((children || [])[0]);
      case "struct":
        return new Struct(children || []);
      case "struct_":
        return new Struct(children || []);
    }
    switch (typeId) {
      case "int": {
        const t = f["type"];
        return new Int_(t["isSigned"], t["bitWidth"]);
      }
      case "floatingpoint": {
        const t = f["type"];
        return new Float(Precision[t["precision"]]);
      }
      case "decimal": {
        const t = f["type"];
        return new Decimal(t["scale"], t["precision"], t["bitWidth"]);
      }
      case "date": {
        const t = f["type"];
        return new Date_(DateUnit[t["unit"]]);
      }
      case "time": {
        const t = f["type"];
        return new Time_(TimeUnit[t["unit"]], t["bitWidth"]);
      }
      case "timestamp": {
        const t = f["type"];
        return new Timestamp_(TimeUnit[t["unit"]], t["timezone"]);
      }
      case "interval": {
        const t = f["type"];
        return new Interval_(IntervalUnit[t["unit"]]);
      }
      case "duration": {
        const t = f["type"];
        return new Duration(TimeUnit[t["unit"]]);
      }
      case "union": {
        const t = f["type"];
        const [m, ...ms] = (t["mode"] + "").toLowerCase();
        const mode = m.toUpperCase() + ms.join("");
        return new Union_(UnionMode[mode], t["typeIds"] || [], children || []);
      }
      case "fixedsizebinary": {
        const t = f["type"];
        return new FixedSizeBinary(t["byteWidth"]);
      }
      case "fixedsizelist": {
        const t = f["type"];
        return new FixedSizeList(t["listSize"], (children || [])[0]);
      }
      case "map": {
        const t = f["type"];
        return new Map_((children || [])[0], t["keysSorted"]);
      }
    }
    throw new Error(`Unrecognized type: "${typeId}"`);
  }

  // ../../node_modules/apache-arrow/ipc/metadata/message.mjs
  var Builder4 = Builder2;
  var ByteBuffer3 = ByteBuffer;
  var Message2 = class _Message {
    /** @nocollapse */
    static fromJSON(msg, headerType) {
      const message = new _Message(0, MetadataVersion.V5, headerType);
      message._createHeader = messageHeaderFromJSON(msg, headerType);
      return message;
    }
    /** @nocollapse */
    static decode(buf) {
      buf = new ByteBuffer3(toUint8Array(buf));
      const _message = Message.getRootAsMessage(buf);
      const bodyLength = _message.bodyLength();
      const version = _message.version();
      const headerType = _message.headerType();
      const message = new _Message(bodyLength, version, headerType);
      message._createHeader = decodeMessageHeader(_message, headerType);
      return message;
    }
    /** @nocollapse */
    static encode(message) {
      const b = new Builder4();
      let headerOffset = -1;
      if (message.isSchema()) {
        headerOffset = Schema2.encode(b, message.header());
      } else if (message.isRecordBatch()) {
        headerOffset = RecordBatch3.encode(b, message.header());
      } else if (message.isDictionaryBatch()) {
        headerOffset = DictionaryBatch2.encode(b, message.header());
      }
      Message.startMessage(b);
      Message.addVersion(b, MetadataVersion.V5);
      Message.addHeader(b, headerOffset);
      Message.addHeaderType(b, message.headerType);
      Message.addBodyLength(b, BigInt(message.bodyLength));
      Message.finishMessageBuffer(b, Message.endMessage(b));
      return b.asUint8Array();
    }
    /** @nocollapse */
    static from(header, bodyLength = 0) {
      if (header instanceof Schema2) {
        return new _Message(0, MetadataVersion.V5, MessageHeader.Schema, header);
      }
      if (header instanceof RecordBatch3) {
        return new _Message(bodyLength, MetadataVersion.V5, MessageHeader.RecordBatch, header);
      }
      if (header instanceof DictionaryBatch2) {
        return new _Message(bodyLength, MetadataVersion.V5, MessageHeader.DictionaryBatch, header);
      }
      throw new Error(`Unrecognized Message header: ${header}`);
    }
    get type() {
      return this.headerType;
    }
    get version() {
      return this._version;
    }
    get headerType() {
      return this._headerType;
    }
    get bodyLength() {
      return this._bodyLength;
    }
    header() {
      return this._createHeader();
    }
    isSchema() {
      return this.headerType === MessageHeader.Schema;
    }
    isRecordBatch() {
      return this.headerType === MessageHeader.RecordBatch;
    }
    isDictionaryBatch() {
      return this.headerType === MessageHeader.DictionaryBatch;
    }
    constructor(bodyLength, version, headerType, header) {
      this._version = version;
      this._headerType = headerType;
      this.body = new Uint8Array(0);
      header && (this._createHeader = () => header);
      this._bodyLength = bigIntToNumber(bodyLength);
    }
  };
  var RecordBatch3 = class {
    get nodes() {
      return this._nodes;
    }
    get length() {
      return this._length;
    }
    get buffers() {
      return this._buffers;
    }
    constructor(length, nodes, buffers) {
      this._nodes = nodes;
      this._buffers = buffers;
      this._length = bigIntToNumber(length);
    }
  };
  var DictionaryBatch2 = class {
    get id() {
      return this._id;
    }
    get data() {
      return this._data;
    }
    get isDelta() {
      return this._isDelta;
    }
    get length() {
      return this.data.length;
    }
    get nodes() {
      return this.data.nodes;
    }
    get buffers() {
      return this.data.buffers;
    }
    constructor(data2, id, isDelta = false) {
      this._data = data2;
      this._isDelta = isDelta;
      this._id = bigIntToNumber(id);
    }
  };
  var BufferRegion = class {
    constructor(offset, length) {
      this.offset = bigIntToNumber(offset);
      this.length = bigIntToNumber(length);
    }
  };
  var FieldNode2 = class {
    constructor(length, nullCount) {
      this.length = bigIntToNumber(length);
      this.nullCount = bigIntToNumber(nullCount);
    }
  };
  function messageHeaderFromJSON(message, type) {
    return () => {
      switch (type) {
        case MessageHeader.Schema:
          return Schema2.fromJSON(message);
        case MessageHeader.RecordBatch:
          return RecordBatch3.fromJSON(message);
        case MessageHeader.DictionaryBatch:
          return DictionaryBatch2.fromJSON(message);
      }
      throw new Error(`Unrecognized Message type: { name: ${MessageHeader[type]}, type: ${type} }`);
    };
  }
  function decodeMessageHeader(message, type) {
    return () => {
      switch (type) {
        case MessageHeader.Schema:
          return Schema2.decode(message.header(new Schema()), /* @__PURE__ */ new Map(), message.version());
        case MessageHeader.RecordBatch:
          return RecordBatch3.decode(message.header(new RecordBatch2()), message.version());
        case MessageHeader.DictionaryBatch:
          return DictionaryBatch2.decode(message.header(new DictionaryBatch()), message.version());
      }
      throw new Error(`Unrecognized Message type: { name: ${MessageHeader[type]}, type: ${type} }`);
    };
  }
  Field2["encode"] = encodeField;
  Field2["decode"] = decodeField;
  Field2["fromJSON"] = fieldFromJSON;
  Schema2["encode"] = encodeSchema;
  Schema2["decode"] = decodeSchema;
  Schema2["fromJSON"] = schemaFromJSON;
  RecordBatch3["encode"] = encodeRecordBatch;
  RecordBatch3["decode"] = decodeRecordBatch;
  RecordBatch3["fromJSON"] = recordBatchFromJSON;
  DictionaryBatch2["encode"] = encodeDictionaryBatch;
  DictionaryBatch2["decode"] = decodeDictionaryBatch;
  DictionaryBatch2["fromJSON"] = dictionaryBatchFromJSON;
  FieldNode2["encode"] = encodeFieldNode;
  FieldNode2["decode"] = decodeFieldNode;
  BufferRegion["encode"] = encodeBufferRegion;
  BufferRegion["decode"] = decodeBufferRegion;
  function decodeSchema(_schema, dictionaries = /* @__PURE__ */ new Map(), version = MetadataVersion.V5) {
    const fields = decodeSchemaFields(_schema, dictionaries);
    return new Schema2(fields, decodeCustomMetadata(_schema), dictionaries, version);
  }
  function decodeRecordBatch(batch, version = MetadataVersion.V5) {
    if (batch.compression() !== null) {
      throw new Error("Record batch compression not implemented");
    }
    return new RecordBatch3(batch.length(), decodeFieldNodes(batch), decodeBuffers(batch, version));
  }
  function decodeDictionaryBatch(batch, version = MetadataVersion.V5) {
    return new DictionaryBatch2(RecordBatch3.decode(batch.data(), version), batch.id(), batch.isDelta());
  }
  function decodeBufferRegion(b) {
    return new BufferRegion(b.offset(), b.length());
  }
  function decodeFieldNode(f) {
    return new FieldNode2(f.length(), f.nullCount());
  }
  function decodeFieldNodes(batch) {
    const nodes = [];
    for (let f, i2 = -1, j = -1, n = batch.nodesLength(); ++i2 < n; ) {
      if (f = batch.nodes(i2)) {
        nodes[++j] = FieldNode2.decode(f);
      }
    }
    return nodes;
  }
  function decodeBuffers(batch, version) {
    const bufferRegions = [];
    for (let b, i2 = -1, j = -1, n = batch.buffersLength(); ++i2 < n; ) {
      if (b = batch.buffers(i2)) {
        if (version < MetadataVersion.V4) {
          b.bb_pos += 8 * (i2 + 1);
        }
        bufferRegions[++j] = BufferRegion.decode(b);
      }
    }
    return bufferRegions;
  }
  function decodeSchemaFields(schema, dictionaries) {
    const fields = [];
    for (let f, i2 = -1, j = -1, n = schema.fieldsLength(); ++i2 < n; ) {
      if (f = schema.fields(i2)) {
        fields[++j] = Field2.decode(f, dictionaries);
      }
    }
    return fields;
  }
  function decodeFieldChildren(field, dictionaries) {
    const children = [];
    for (let f, i2 = -1, j = -1, n = field.childrenLength(); ++i2 < n; ) {
      if (f = field.children(i2)) {
        children[++j] = Field2.decode(f, dictionaries);
      }
    }
    return children;
  }
  function decodeField(f, dictionaries) {
    let id;
    let field;
    let type;
    let keys;
    let dictType;
    let dictMeta;
    if (!dictionaries || !(dictMeta = f.dictionary())) {
      type = decodeFieldType(f, decodeFieldChildren(f, dictionaries));
      field = new Field2(f.name(), type, f.nullable(), decodeCustomMetadata(f));
    } else if (!dictionaries.has(id = bigIntToNumber(dictMeta.id()))) {
      keys = (keys = dictMeta.indexType()) ? decodeIndexType(keys) : new Int32();
      dictionaries.set(id, type = decodeFieldType(f, decodeFieldChildren(f, dictionaries)));
      dictType = new Dictionary(type, keys, id, dictMeta.isOrdered());
      field = new Field2(f.name(), dictType, f.nullable(), decodeCustomMetadata(f));
    } else {
      keys = (keys = dictMeta.indexType()) ? decodeIndexType(keys) : new Int32();
      dictType = new Dictionary(dictionaries.get(id), keys, id, dictMeta.isOrdered());
      field = new Field2(f.name(), dictType, f.nullable(), decodeCustomMetadata(f));
    }
    return field || null;
  }
  function decodeCustomMetadata(parent) {
    const data2 = /* @__PURE__ */ new Map();
    if (parent) {
      for (let entry, key, i2 = -1, n = Math.trunc(parent.customMetadataLength()); ++i2 < n; ) {
        if ((entry = parent.customMetadata(i2)) && (key = entry.key()) != null) {
          data2.set(key, entry.value());
        }
      }
    }
    return data2;
  }
  function decodeIndexType(_type) {
    return new Int_(_type.isSigned(), _type.bitWidth());
  }
  function decodeFieldType(f, children) {
    const typeId = f.typeType();
    switch (typeId) {
      case Type2["NONE"]:
        return new Null();
      case Type2["Null"]:
        return new Null();
      case Type2["Binary"]:
        return new Binary();
      case Type2["Utf8"]:
        return new Utf8();
      case Type2["Bool"]:
        return new Bool();
      case Type2["List"]:
        return new List((children || [])[0]);
      case Type2["Struct_"]:
        return new Struct(children || []);
    }
    switch (typeId) {
      case Type2["Int"]: {
        const t = f.type(new Int());
        return new Int_(t.isSigned(), t.bitWidth());
      }
      case Type2["FloatingPoint"]: {
        const t = f.type(new FloatingPoint());
        return new Float(t.precision());
      }
      case Type2["Decimal"]: {
        const t = f.type(new Decimal2());
        return new Decimal(t.scale(), t.precision(), t.bitWidth());
      }
      case Type2["Date"]: {
        const t = f.type(new Date2());
        return new Date_(t.unit());
      }
      case Type2["Time"]: {
        const t = f.type(new Time());
        return new Time_(t.unit(), t.bitWidth());
      }
      case Type2["Timestamp"]: {
        const t = f.type(new Timestamp());
        return new Timestamp_(t.unit(), t.timezone());
      }
      case Type2["Interval"]: {
        const t = f.type(new Interval());
        return new Interval_(t.unit());
      }
      case Type2["Duration"]: {
        const t = f.type(new Duration2());
        return new Duration(t.unit());
      }
      case Type2["Union"]: {
        const t = f.type(new Union());
        return new Union_(t.mode(), t.typeIdsArray() || [], children || []);
      }
      case Type2["FixedSizeBinary"]: {
        const t = f.type(new FixedSizeBinary2());
        return new FixedSizeBinary(t.byteWidth());
      }
      case Type2["FixedSizeList"]: {
        const t = f.type(new FixedSizeList2());
        return new FixedSizeList(t.listSize(), (children || [])[0]);
      }
      case Type2["Map"]: {
        const t = f.type(new Map2());
        return new Map_((children || [])[0], t.keysSorted());
      }
    }
    throw new Error(`Unrecognized type: "${Type2[typeId]}" (${typeId})`);
  }
  function encodeSchema(b, schema) {
    const fieldOffsets = schema.fields.map((f) => Field2.encode(b, f));
    Schema.startFieldsVector(b, fieldOffsets.length);
    const fieldsVectorOffset = Schema.createFieldsVector(b, fieldOffsets);
    const metadataOffset = !(schema.metadata && schema.metadata.size > 0) ? -1 : Schema.createCustomMetadataVector(b, [...schema.metadata].map(([k, v]) => {
      const key = b.createString(`${k}`);
      const val = b.createString(`${v}`);
      KeyValue.startKeyValue(b);
      KeyValue.addKey(b, key);
      KeyValue.addValue(b, val);
      return KeyValue.endKeyValue(b);
    }));
    Schema.startSchema(b);
    Schema.addFields(b, fieldsVectorOffset);
    Schema.addEndianness(b, platformIsLittleEndian ? Endianness.Little : Endianness.Big);
    if (metadataOffset !== -1) {
      Schema.addCustomMetadata(b, metadataOffset);
    }
    return Schema.endSchema(b);
  }
  function encodeField(b, field) {
    let nameOffset = -1;
    let typeOffset = -1;
    let dictionaryOffset = -1;
    const type = field.type;
    let typeId = field.typeId;
    if (!DataType.isDictionary(type)) {
      typeOffset = instance9.visit(type, b);
    } else {
      typeId = type.dictionary.typeId;
      dictionaryOffset = instance9.visit(type, b);
      typeOffset = instance9.visit(type.dictionary, b);
    }
    const childOffsets = (type.children || []).map((f) => Field2.encode(b, f));
    const childrenVectorOffset = Field.createChildrenVector(b, childOffsets);
    const metadataOffset = !(field.metadata && field.metadata.size > 0) ? -1 : Field.createCustomMetadataVector(b, [...field.metadata].map(([k, v]) => {
      const key = b.createString(`${k}`);
      const val = b.createString(`${v}`);
      KeyValue.startKeyValue(b);
      KeyValue.addKey(b, key);
      KeyValue.addValue(b, val);
      return KeyValue.endKeyValue(b);
    }));
    if (field.name) {
      nameOffset = b.createString(field.name);
    }
    Field.startField(b);
    Field.addType(b, typeOffset);
    Field.addTypeType(b, typeId);
    Field.addChildren(b, childrenVectorOffset);
    Field.addNullable(b, !!field.nullable);
    if (nameOffset !== -1) {
      Field.addName(b, nameOffset);
    }
    if (dictionaryOffset !== -1) {
      Field.addDictionary(b, dictionaryOffset);
    }
    if (metadataOffset !== -1) {
      Field.addCustomMetadata(b, metadataOffset);
    }
    return Field.endField(b);
  }
  function encodeRecordBatch(b, recordBatch) {
    const nodes = recordBatch.nodes || [];
    const buffers = recordBatch.buffers || [];
    RecordBatch2.startNodesVector(b, nodes.length);
    for (const n of nodes.slice().reverse())
      FieldNode2.encode(b, n);
    const nodesVectorOffset = b.endVector();
    RecordBatch2.startBuffersVector(b, buffers.length);
    for (const b_ of buffers.slice().reverse())
      BufferRegion.encode(b, b_);
    const buffersVectorOffset = b.endVector();
    RecordBatch2.startRecordBatch(b);
    RecordBatch2.addLength(b, BigInt(recordBatch.length));
    RecordBatch2.addNodes(b, nodesVectorOffset);
    RecordBatch2.addBuffers(b, buffersVectorOffset);
    return RecordBatch2.endRecordBatch(b);
  }
  function encodeDictionaryBatch(b, dictionaryBatch) {
    const dataOffset = RecordBatch3.encode(b, dictionaryBatch.data);
    DictionaryBatch.startDictionaryBatch(b);
    DictionaryBatch.addId(b, BigInt(dictionaryBatch.id));
    DictionaryBatch.addIsDelta(b, dictionaryBatch.isDelta);
    DictionaryBatch.addData(b, dataOffset);
    return DictionaryBatch.endDictionaryBatch(b);
  }
  function encodeFieldNode(b, node) {
    return FieldNode.createFieldNode(b, BigInt(node.length), BigInt(node.nullCount));
  }
  function encodeBufferRegion(b, node) {
    return Buffer2.createBuffer(b, BigInt(node.offset), BigInt(node.length));
  }
  var platformIsLittleEndian = (() => {
    const buffer = new ArrayBuffer(2);
    new DataView(buffer).setInt16(
      0,
      256,
      true
      /* littleEndian */
    );
    return new Int16Array(buffer)[0] === 256;
  })();

  // ../../node_modules/apache-arrow/ipc/message.mjs
  var invalidMessageType = (type) => `Expected ${MessageHeader[type]} Message in stream, but was null or length 0.`;
  var nullMessage = (type) => `Header pointer of flatbuffer-encoded ${MessageHeader[type]} Message is null or length 0.`;
  var invalidMessageMetadata = (expected, actual) => `Expected to read ${expected} metadata bytes, but only read ${actual}.`;
  var invalidMessageBodyLength = (expected, actual) => `Expected to read ${expected} bytes for message body, but only read ${actual}.`;
  var MessageReader = class {
    constructor(source) {
      this.source = source instanceof ByteStream ? source : new ByteStream(source);
    }
    [Symbol.iterator]() {
      return this;
    }
    next() {
      let r;
      if ((r = this.readMetadataLength()).done) {
        return ITERATOR_DONE;
      }
      if (r.value === -1 && (r = this.readMetadataLength()).done) {
        return ITERATOR_DONE;
      }
      if ((r = this.readMetadata(r.value)).done) {
        return ITERATOR_DONE;
      }
      return r;
    }
    throw(value) {
      return this.source.throw(value);
    }
    return(value) {
      return this.source.return(value);
    }
    readMessage(type) {
      let r;
      if ((r = this.next()).done) {
        return null;
      }
      if (type != null && r.value.headerType !== type) {
        throw new Error(invalidMessageType(type));
      }
      return r.value;
    }
    readMessageBody(bodyLength) {
      if (bodyLength <= 0) {
        return new Uint8Array(0);
      }
      const buf = toUint8Array(this.source.read(bodyLength));
      if (buf.byteLength < bodyLength) {
        throw new Error(invalidMessageBodyLength(bodyLength, buf.byteLength));
      }
      return (
        /* 1. */
        buf.byteOffset % 8 === 0 && /* 2. */
        buf.byteOffset + buf.byteLength <= buf.buffer.byteLength ? buf : buf.slice()
      );
    }
    readSchema(throwIfNull = false) {
      const type = MessageHeader.Schema;
      const message = this.readMessage(type);
      const schema = message === null || message === void 0 ? void 0 : message.header();
      if (throwIfNull && !schema) {
        throw new Error(nullMessage(type));
      }
      return schema;
    }
    readMetadataLength() {
      const buf = this.source.read(PADDING);
      const bb = buf && new ByteBuffer(buf);
      const len2 = (bb === null || bb === void 0 ? void 0 : bb.readInt32(0)) || 0;
      return { done: len2 === 0, value: len2 };
    }
    readMetadata(metadataLength) {
      const buf = this.source.read(metadataLength);
      if (!buf) {
        return ITERATOR_DONE;
      }
      if (buf.byteLength < metadataLength) {
        throw new Error(invalidMessageMetadata(metadataLength, buf.byteLength));
      }
      return { done: false, value: Message2.decode(buf) };
    }
  };
  var AsyncMessageReader = class {
    constructor(source, byteLength) {
      this.source = source instanceof AsyncByteStream ? source : isFileHandle(source) ? new AsyncRandomAccessFile(source, byteLength) : new AsyncByteStream(source);
    }
    [Symbol.asyncIterator]() {
      return this;
    }
    next() {
      return __awaiter(this, void 0, void 0, function* () {
        let r;
        if ((r = yield this.readMetadataLength()).done) {
          return ITERATOR_DONE;
        }
        if (r.value === -1 && (r = yield this.readMetadataLength()).done) {
          return ITERATOR_DONE;
        }
        if ((r = yield this.readMetadata(r.value)).done) {
          return ITERATOR_DONE;
        }
        return r;
      });
    }
    throw(value) {
      return __awaiter(this, void 0, void 0, function* () {
        return yield this.source.throw(value);
      });
    }
    return(value) {
      return __awaiter(this, void 0, void 0, function* () {
        return yield this.source.return(value);
      });
    }
    readMessage(type) {
      return __awaiter(this, void 0, void 0, function* () {
        let r;
        if ((r = yield this.next()).done) {
          return null;
        }
        if (type != null && r.value.headerType !== type) {
          throw new Error(invalidMessageType(type));
        }
        return r.value;
      });
    }
    readMessageBody(bodyLength) {
      return __awaiter(this, void 0, void 0, function* () {
        if (bodyLength <= 0) {
          return new Uint8Array(0);
        }
        const buf = toUint8Array(yield this.source.read(bodyLength));
        if (buf.byteLength < bodyLength) {
          throw new Error(invalidMessageBodyLength(bodyLength, buf.byteLength));
        }
        return (
          /* 1. */
          buf.byteOffset % 8 === 0 && /* 2. */
          buf.byteOffset + buf.byteLength <= buf.buffer.byteLength ? buf : buf.slice()
        );
      });
    }
    readSchema(throwIfNull = false) {
      return __awaiter(this, void 0, void 0, function* () {
        const type = MessageHeader.Schema;
        const message = yield this.readMessage(type);
        const schema = message === null || message === void 0 ? void 0 : message.header();
        if (throwIfNull && !schema) {
          throw new Error(nullMessage(type));
        }
        return schema;
      });
    }
    readMetadataLength() {
      return __awaiter(this, void 0, void 0, function* () {
        const buf = yield this.source.read(PADDING);
        const bb = buf && new ByteBuffer(buf);
        const len2 = (bb === null || bb === void 0 ? void 0 : bb.readInt32(0)) || 0;
        return { done: len2 === 0, value: len2 };
      });
    }
    readMetadata(metadataLength) {
      return __awaiter(this, void 0, void 0, function* () {
        const buf = yield this.source.read(metadataLength);
        if (!buf) {
          return ITERATOR_DONE;
        }
        if (buf.byteLength < metadataLength) {
          throw new Error(invalidMessageMetadata(metadataLength, buf.byteLength));
        }
        return { done: false, value: Message2.decode(buf) };
      });
    }
  };
  var JSONMessageReader = class extends MessageReader {
    constructor(source) {
      super(new Uint8Array(0));
      this._schema = false;
      this._body = [];
      this._batchIndex = 0;
      this._dictionaryIndex = 0;
      this._json = source instanceof ArrowJSON ? source : new ArrowJSON(source);
    }
    next() {
      const { _json } = this;
      if (!this._schema) {
        this._schema = true;
        const message = Message2.fromJSON(_json.schema, MessageHeader.Schema);
        return { done: false, value: message };
      }
      if (this._dictionaryIndex < _json.dictionaries.length) {
        const batch = _json.dictionaries[this._dictionaryIndex++];
        this._body = batch["data"]["columns"];
        const message = Message2.fromJSON(batch, MessageHeader.DictionaryBatch);
        return { done: false, value: message };
      }
      if (this._batchIndex < _json.batches.length) {
        const batch = _json.batches[this._batchIndex++];
        this._body = batch["columns"];
        const message = Message2.fromJSON(batch, MessageHeader.RecordBatch);
        return { done: false, value: message };
      }
      this._body = [];
      return ITERATOR_DONE;
    }
    readMessageBody(_bodyLength) {
      return flattenDataSources(this._body);
      function flattenDataSources(xs) {
        return (xs || []).reduce((buffers, column) => [
          ...buffers,
          ...column["VALIDITY"] && [column["VALIDITY"]] || [],
          ...column["TYPE_ID"] && [column["TYPE_ID"]] || [],
          ...column["OFFSET"] && [column["OFFSET"]] || [],
          ...column["DATA"] && [column["DATA"]] || [],
          ...flattenDataSources(column["children"])
        ], []);
      }
    }
    readMessage(type) {
      let r;
      if ((r = this.next()).done) {
        return null;
      }
      if (type != null && r.value.headerType !== type) {
        throw new Error(invalidMessageType(type));
      }
      return r.value;
    }
    readSchema() {
      const type = MessageHeader.Schema;
      const message = this.readMessage(type);
      const schema = message === null || message === void 0 ? void 0 : message.header();
      if (!message || !schema) {
        throw new Error(nullMessage(type));
      }
      return schema;
    }
  };
  var PADDING = 4;
  var MAGIC_STR = "ARROW1";
  var MAGIC = new Uint8Array(MAGIC_STR.length);
  for (let i2 = 0; i2 < MAGIC_STR.length; i2 += 1) {
    MAGIC[i2] = MAGIC_STR.codePointAt(i2);
  }
  function checkForMagicArrowString(buffer, index = 0) {
    for (let i2 = -1, n = MAGIC.length; ++i2 < n; ) {
      if (MAGIC[i2] !== buffer[index + i2]) {
        return false;
      }
    }
    return true;
  }
  var magicLength = MAGIC.length;
  var magicAndPadding = magicLength + PADDING;
  var magicX2AndPadding = magicLength * 2 + PADDING;

  // ../../node_modules/apache-arrow/ipc/reader.mjs
  var RecordBatchReader = class _RecordBatchReader extends ReadableInterop {
    constructor(impl) {
      super();
      this._impl = impl;
    }
    get closed() {
      return this._impl.closed;
    }
    get schema() {
      return this._impl.schema;
    }
    get autoDestroy() {
      return this._impl.autoDestroy;
    }
    get dictionaries() {
      return this._impl.dictionaries;
    }
    get numDictionaries() {
      return this._impl.numDictionaries;
    }
    get numRecordBatches() {
      return this._impl.numRecordBatches;
    }
    get footer() {
      return this._impl.isFile() ? this._impl.footer : null;
    }
    isSync() {
      return this._impl.isSync();
    }
    isAsync() {
      return this._impl.isAsync();
    }
    isFile() {
      return this._impl.isFile();
    }
    isStream() {
      return this._impl.isStream();
    }
    next() {
      return this._impl.next();
    }
    throw(value) {
      return this._impl.throw(value);
    }
    return(value) {
      return this._impl.return(value);
    }
    cancel() {
      return this._impl.cancel();
    }
    reset(schema) {
      this._impl.reset(schema);
      this._DOMStream = void 0;
      this._nodeStream = void 0;
      return this;
    }
    open(options) {
      const opening = this._impl.open(options);
      return isPromise(opening) ? opening.then(() => this) : this;
    }
    readRecordBatch(index) {
      return this._impl.isFile() ? this._impl.readRecordBatch(index) : null;
    }
    [Symbol.iterator]() {
      return this._impl[Symbol.iterator]();
    }
    [Symbol.asyncIterator]() {
      return this._impl[Symbol.asyncIterator]();
    }
    toDOMStream() {
      return adapters_default.toDOMStream(this.isSync() ? { [Symbol.iterator]: () => this } : { [Symbol.asyncIterator]: () => this });
    }
    toNodeStream() {
      return adapters_default.toNodeStream(this.isSync() ? { [Symbol.iterator]: () => this } : { [Symbol.asyncIterator]: () => this }, { objectMode: true });
    }
    /** @nocollapse */
    // @ts-ignore
    static throughNode(options) {
      throw new Error(`"throughNode" not available in this environment`);
    }
    /** @nocollapse */
    static throughDOM(writableStrategy, readableStrategy) {
      throw new Error(`"throughDOM" not available in this environment`);
    }
    /** @nocollapse */
    static from(source) {
      if (source instanceof _RecordBatchReader) {
        return source;
      } else if (isArrowJSON(source)) {
        return fromArrowJSON(source);
      } else if (isFileHandle(source)) {
        return fromFileHandle(source);
      } else if (isPromise(source)) {
        return (() => __awaiter(this, void 0, void 0, function* () {
          return yield _RecordBatchReader.from(yield source);
        }))();
      } else if (isFetchResponse(source) || isReadableDOMStream(source) || isReadableNodeStream(source) || isAsyncIterable(source)) {
        return fromAsyncByteStream(new AsyncByteStream(source));
      }
      return fromByteStream(new ByteStream(source));
    }
    /** @nocollapse */
    static readAll(source) {
      if (source instanceof _RecordBatchReader) {
        return source.isSync() ? readAllSync(source) : readAllAsync(source);
      } else if (isArrowJSON(source) || ArrayBuffer.isView(source) || isIterable(source) || isIteratorResult(source)) {
        return readAllSync(source);
      }
      return readAllAsync(source);
    }
  };
  var RecordBatchStreamReader = class extends RecordBatchReader {
    constructor(_impl) {
      super(_impl);
      this._impl = _impl;
    }
    readAll() {
      return [...this];
    }
    [Symbol.iterator]() {
      return this._impl[Symbol.iterator]();
    }
    [Symbol.asyncIterator]() {
      return __asyncGenerator(this, arguments, function* _a5() {
        yield __await(yield* __asyncDelegator(__asyncValues(this[Symbol.iterator]())));
      });
    }
  };
  var AsyncRecordBatchStreamReader = class extends RecordBatchReader {
    constructor(_impl) {
      super(_impl);
      this._impl = _impl;
    }
    readAll() {
      var _a5, e_1, _b2, _c2;
      return __awaiter(this, void 0, void 0, function* () {
        const batches = new Array();
        try {
          for (var _d2 = true, _e2 = __asyncValues(this), _f2; _f2 = yield _e2.next(), _a5 = _f2.done, !_a5; _d2 = true) {
            _c2 = _f2.value;
            _d2 = false;
            const batch = _c2;
            batches.push(batch);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (!_d2 && !_a5 && (_b2 = _e2.return))
              yield _b2.call(_e2);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        return batches;
      });
    }
    [Symbol.iterator]() {
      throw new Error(`AsyncRecordBatchStreamReader is not Iterable`);
    }
    [Symbol.asyncIterator]() {
      return this._impl[Symbol.asyncIterator]();
    }
  };
  var RecordBatchFileReader = class extends RecordBatchStreamReader {
    constructor(_impl) {
      super(_impl);
      this._impl = _impl;
    }
  };
  var AsyncRecordBatchFileReader = class extends AsyncRecordBatchStreamReader {
    constructor(_impl) {
      super(_impl);
      this._impl = _impl;
    }
  };
  var RecordBatchReaderImpl = class {
    get numDictionaries() {
      return this._dictionaryIndex;
    }
    get numRecordBatches() {
      return this._recordBatchIndex;
    }
    constructor(dictionaries = /* @__PURE__ */ new Map()) {
      this.closed = false;
      this.autoDestroy = true;
      this._dictionaryIndex = 0;
      this._recordBatchIndex = 0;
      this.dictionaries = dictionaries;
    }
    isSync() {
      return false;
    }
    isAsync() {
      return false;
    }
    isFile() {
      return false;
    }
    isStream() {
      return false;
    }
    reset(schema) {
      this._dictionaryIndex = 0;
      this._recordBatchIndex = 0;
      this.schema = schema;
      this.dictionaries = /* @__PURE__ */ new Map();
      return this;
    }
    _loadRecordBatch(header, body2) {
      const children = this._loadVectors(header, body2, this.schema.fields);
      const data2 = makeData({ type: new Struct(this.schema.fields), length: header.length, children });
      return new RecordBatch(this.schema, data2);
    }
    _loadDictionaryBatch(header, body2) {
      const { id, isDelta } = header;
      const { dictionaries, schema } = this;
      const dictionary = dictionaries.get(id);
      if (isDelta || !dictionary) {
        const type = schema.dictionaries.get(id);
        const data2 = this._loadVectors(header.data, body2, [type]);
        return (dictionary && isDelta ? dictionary.concat(new Vector(data2)) : new Vector(data2)).memoize();
      }
      return dictionary.memoize();
    }
    _loadVectors(header, body2, types) {
      return new VectorLoader(body2, header.nodes, header.buffers, this.dictionaries, this.schema.metadataVersion).visitMany(types);
    }
  };
  var RecordBatchStreamReaderImpl = class extends RecordBatchReaderImpl {
    constructor(source, dictionaries) {
      super(dictionaries);
      this._reader = !isArrowJSON(source) ? new MessageReader(this._handle = source) : new JSONMessageReader(this._handle = source);
    }
    isSync() {
      return true;
    }
    isStream() {
      return true;
    }
    [Symbol.iterator]() {
      return this;
    }
    cancel() {
      if (!this.closed && (this.closed = true)) {
        this.reset()._reader.return();
        this._reader = null;
        this.dictionaries = null;
      }
    }
    open(options) {
      if (!this.closed) {
        this.autoDestroy = shouldAutoDestroy(this, options);
        if (!(this.schema || (this.schema = this._reader.readSchema()))) {
          this.cancel();
        }
      }
      return this;
    }
    throw(value) {
      if (!this.closed && this.autoDestroy && (this.closed = true)) {
        return this.reset()._reader.throw(value);
      }
      return ITERATOR_DONE;
    }
    return(value) {
      if (!this.closed && this.autoDestroy && (this.closed = true)) {
        return this.reset()._reader.return(value);
      }
      return ITERATOR_DONE;
    }
    next() {
      if (this.closed) {
        return ITERATOR_DONE;
      }
      let message;
      const { _reader: reader } = this;
      while (message = this._readNextMessageAndValidate()) {
        if (message.isSchema()) {
          this.reset(message.header());
        } else if (message.isRecordBatch()) {
          this._recordBatchIndex++;
          const header = message.header();
          const buffer = reader.readMessageBody(message.bodyLength);
          const recordBatch = this._loadRecordBatch(header, buffer);
          return { done: false, value: recordBatch };
        } else if (message.isDictionaryBatch()) {
          this._dictionaryIndex++;
          const header = message.header();
          const buffer = reader.readMessageBody(message.bodyLength);
          const vector = this._loadDictionaryBatch(header, buffer);
          this.dictionaries.set(header.id, vector);
        }
      }
      if (this.schema && this._recordBatchIndex === 0) {
        this._recordBatchIndex++;
        return { done: false, value: new _InternalEmptyPlaceholderRecordBatch(this.schema) };
      }
      return this.return();
    }
    _readNextMessageAndValidate(type) {
      return this._reader.readMessage(type);
    }
  };
  var AsyncRecordBatchStreamReaderImpl = class extends RecordBatchReaderImpl {
    constructor(source, dictionaries) {
      super(dictionaries);
      this._reader = new AsyncMessageReader(this._handle = source);
    }
    isAsync() {
      return true;
    }
    isStream() {
      return true;
    }
    [Symbol.asyncIterator]() {
      return this;
    }
    cancel() {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.closed && (this.closed = true)) {
          yield this.reset()._reader.return();
          this._reader = null;
          this.dictionaries = null;
        }
      });
    }
    open(options) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.closed) {
          this.autoDestroy = shouldAutoDestroy(this, options);
          if (!(this.schema || (this.schema = yield this._reader.readSchema()))) {
            yield this.cancel();
          }
        }
        return this;
      });
    }
    throw(value) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.closed && this.autoDestroy && (this.closed = true)) {
          return yield this.reset()._reader.throw(value);
        }
        return ITERATOR_DONE;
      });
    }
    return(value) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.closed && this.autoDestroy && (this.closed = true)) {
          return yield this.reset()._reader.return(value);
        }
        return ITERATOR_DONE;
      });
    }
    next() {
      return __awaiter(this, void 0, void 0, function* () {
        if (this.closed) {
          return ITERATOR_DONE;
        }
        let message;
        const { _reader: reader } = this;
        while (message = yield this._readNextMessageAndValidate()) {
          if (message.isSchema()) {
            yield this.reset(message.header());
          } else if (message.isRecordBatch()) {
            this._recordBatchIndex++;
            const header = message.header();
            const buffer = yield reader.readMessageBody(message.bodyLength);
            const recordBatch = this._loadRecordBatch(header, buffer);
            return { done: false, value: recordBatch };
          } else if (message.isDictionaryBatch()) {
            this._dictionaryIndex++;
            const header = message.header();
            const buffer = yield reader.readMessageBody(message.bodyLength);
            const vector = this._loadDictionaryBatch(header, buffer);
            this.dictionaries.set(header.id, vector);
          }
        }
        if (this.schema && this._recordBatchIndex === 0) {
          this._recordBatchIndex++;
          return { done: false, value: new _InternalEmptyPlaceholderRecordBatch(this.schema) };
        }
        return yield this.return();
      });
    }
    _readNextMessageAndValidate(type) {
      return __awaiter(this, void 0, void 0, function* () {
        return yield this._reader.readMessage(type);
      });
    }
  };
  var RecordBatchFileReaderImpl = class extends RecordBatchStreamReaderImpl {
    get footer() {
      return this._footer;
    }
    get numDictionaries() {
      return this._footer ? this._footer.numDictionaries : 0;
    }
    get numRecordBatches() {
      return this._footer ? this._footer.numRecordBatches : 0;
    }
    constructor(source, dictionaries) {
      super(source instanceof RandomAccessFile ? source : new RandomAccessFile(source), dictionaries);
    }
    isSync() {
      return true;
    }
    isFile() {
      return true;
    }
    open(options) {
      if (!this.closed && !this._footer) {
        this.schema = (this._footer = this._readFooter()).schema;
        for (const block of this._footer.dictionaryBatches()) {
          block && this._readDictionaryBatch(this._dictionaryIndex++);
        }
      }
      return super.open(options);
    }
    readRecordBatch(index) {
      var _a5;
      if (this.closed) {
        return null;
      }
      if (!this._footer) {
        this.open();
      }
      const block = (_a5 = this._footer) === null || _a5 === void 0 ? void 0 : _a5.getRecordBatch(index);
      if (block && this._handle.seek(block.offset)) {
        const message = this._reader.readMessage(MessageHeader.RecordBatch);
        if (message === null || message === void 0 ? void 0 : message.isRecordBatch()) {
          const header = message.header();
          const buffer = this._reader.readMessageBody(message.bodyLength);
          const recordBatch = this._loadRecordBatch(header, buffer);
          return recordBatch;
        }
      }
      return null;
    }
    _readDictionaryBatch(index) {
      var _a5;
      const block = (_a5 = this._footer) === null || _a5 === void 0 ? void 0 : _a5.getDictionaryBatch(index);
      if (block && this._handle.seek(block.offset)) {
        const message = this._reader.readMessage(MessageHeader.DictionaryBatch);
        if (message === null || message === void 0 ? void 0 : message.isDictionaryBatch()) {
          const header = message.header();
          const buffer = this._reader.readMessageBody(message.bodyLength);
          const vector = this._loadDictionaryBatch(header, buffer);
          this.dictionaries.set(header.id, vector);
        }
      }
    }
    _readFooter() {
      const { _handle } = this;
      const offset = _handle.size - magicAndPadding;
      const length = _handle.readInt32(offset);
      const buffer = _handle.readAt(offset - length, length);
      return Footer_.decode(buffer);
    }
    _readNextMessageAndValidate(type) {
      var _a5;
      if (!this._footer) {
        this.open();
      }
      if (this._footer && this._recordBatchIndex < this.numRecordBatches) {
        const block = (_a5 = this._footer) === null || _a5 === void 0 ? void 0 : _a5.getRecordBatch(this._recordBatchIndex);
        if (block && this._handle.seek(block.offset)) {
          return this._reader.readMessage(type);
        }
      }
      return null;
    }
  };
  var AsyncRecordBatchFileReaderImpl = class extends AsyncRecordBatchStreamReaderImpl {
    get footer() {
      return this._footer;
    }
    get numDictionaries() {
      return this._footer ? this._footer.numDictionaries : 0;
    }
    get numRecordBatches() {
      return this._footer ? this._footer.numRecordBatches : 0;
    }
    constructor(source, ...rest) {
      const byteLength = typeof rest[0] !== "number" ? rest.shift() : void 0;
      const dictionaries = rest[0] instanceof Map ? rest.shift() : void 0;
      super(source instanceof AsyncRandomAccessFile ? source : new AsyncRandomAccessFile(source, byteLength), dictionaries);
    }
    isFile() {
      return true;
    }
    isAsync() {
      return true;
    }
    open(options) {
      const _super = Object.create(null, {
        open: { get: () => super.open }
      });
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.closed && !this._footer) {
          this.schema = (this._footer = yield this._readFooter()).schema;
          for (const block of this._footer.dictionaryBatches()) {
            block && (yield this._readDictionaryBatch(this._dictionaryIndex++));
          }
        }
        return yield _super.open.call(this, options);
      });
    }
    readRecordBatch(index) {
      var _a5;
      return __awaiter(this, void 0, void 0, function* () {
        if (this.closed) {
          return null;
        }
        if (!this._footer) {
          yield this.open();
        }
        const block = (_a5 = this._footer) === null || _a5 === void 0 ? void 0 : _a5.getRecordBatch(index);
        if (block && (yield this._handle.seek(block.offset))) {
          const message = yield this._reader.readMessage(MessageHeader.RecordBatch);
          if (message === null || message === void 0 ? void 0 : message.isRecordBatch()) {
            const header = message.header();
            const buffer = yield this._reader.readMessageBody(message.bodyLength);
            const recordBatch = this._loadRecordBatch(header, buffer);
            return recordBatch;
          }
        }
        return null;
      });
    }
    _readDictionaryBatch(index) {
      var _a5;
      return __awaiter(this, void 0, void 0, function* () {
        const block = (_a5 = this._footer) === null || _a5 === void 0 ? void 0 : _a5.getDictionaryBatch(index);
        if (block && (yield this._handle.seek(block.offset))) {
          const message = yield this._reader.readMessage(MessageHeader.DictionaryBatch);
          if (message === null || message === void 0 ? void 0 : message.isDictionaryBatch()) {
            const header = message.header();
            const buffer = yield this._reader.readMessageBody(message.bodyLength);
            const vector = this._loadDictionaryBatch(header, buffer);
            this.dictionaries.set(header.id, vector);
          }
        }
      });
    }
    _readFooter() {
      return __awaiter(this, void 0, void 0, function* () {
        const { _handle } = this;
        _handle._pending && (yield _handle._pending);
        const offset = _handle.size - magicAndPadding;
        const length = yield _handle.readInt32(offset);
        const buffer = yield _handle.readAt(offset - length, length);
        return Footer_.decode(buffer);
      });
    }
    _readNextMessageAndValidate(type) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this._footer) {
          yield this.open();
        }
        if (this._footer && this._recordBatchIndex < this.numRecordBatches) {
          const block = this._footer.getRecordBatch(this._recordBatchIndex);
          if (block && (yield this._handle.seek(block.offset))) {
            return yield this._reader.readMessage(type);
          }
        }
        return null;
      });
    }
  };
  var RecordBatchJSONReaderImpl = class extends RecordBatchStreamReaderImpl {
    constructor(source, dictionaries) {
      super(source, dictionaries);
    }
    _loadVectors(header, body2, types) {
      return new JSONVectorLoader(body2, header.nodes, header.buffers, this.dictionaries, this.schema.metadataVersion).visitMany(types);
    }
  };
  function shouldAutoDestroy(self2, options) {
    return options && typeof options["autoDestroy"] === "boolean" ? options["autoDestroy"] : self2["autoDestroy"];
  }
  function* readAllSync(source) {
    const reader = RecordBatchReader.from(source);
    try {
      if (!reader.open({ autoDestroy: false }).closed) {
        do {
          yield reader;
        } while (!reader.reset().open().closed);
      }
    } finally {
      reader.cancel();
    }
  }
  function readAllAsync(source) {
    return __asyncGenerator(this, arguments, function* readAllAsync_1() {
      const reader = yield __await(RecordBatchReader.from(source));
      try {
        if (!(yield __await(reader.open({ autoDestroy: false }))).closed) {
          do {
            yield yield __await(reader);
          } while (!(yield __await(reader.reset().open())).closed);
        }
      } finally {
        yield __await(reader.cancel());
      }
    });
  }
  function fromArrowJSON(source) {
    return new RecordBatchStreamReader(new RecordBatchJSONReaderImpl(source));
  }
  function fromByteStream(source) {
    const bytes = source.peek(magicLength + 7 & ~7);
    return bytes && bytes.byteLength >= 4 ? !checkForMagicArrowString(bytes) ? new RecordBatchStreamReader(new RecordBatchStreamReaderImpl(source)) : new RecordBatchFileReader(new RecordBatchFileReaderImpl(source.read())) : new RecordBatchStreamReader(new RecordBatchStreamReaderImpl(function* () {
    }()));
  }
  function fromAsyncByteStream(source) {
    return __awaiter(this, void 0, void 0, function* () {
      const bytes = yield source.peek(magicLength + 7 & ~7);
      return bytes && bytes.byteLength >= 4 ? !checkForMagicArrowString(bytes) ? new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(source)) : new RecordBatchFileReader(new RecordBatchFileReaderImpl(yield source.read())) : new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(function() {
        return __asyncGenerator(this, arguments, function* () {
        });
      }()));
    });
  }
  function fromFileHandle(source) {
    return __awaiter(this, void 0, void 0, function* () {
      const { size } = yield source.stat();
      const file = new AsyncRandomAccessFile(source, size);
      if (size >= magicX2AndPadding && checkForMagicArrowString(yield file.readAt(0, magicLength + 7 & ~7))) {
        return new AsyncRecordBatchFileReader(new AsyncRecordBatchFileReaderImpl(file));
      }
      return new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(file));
    });
  }

  // ../../node_modules/apache-arrow/visitor/vectorassembler.mjs
  var VectorAssembler = class _VectorAssembler extends Visitor {
    /** @nocollapse */
    static assemble(...args2) {
      const unwrap = (nodes) => nodes.flatMap((node) => Array.isArray(node) ? unwrap(node) : node instanceof RecordBatch ? node.data.children : node.data);
      const assembler = new _VectorAssembler();
      assembler.visitMany(unwrap(args2));
      return assembler;
    }
    constructor() {
      super();
      this._byteLength = 0;
      this._nodes = [];
      this._buffers = [];
      this._bufferRegions = [];
    }
    visit(data2) {
      if (data2 instanceof Vector) {
        this.visitMany(data2.data);
        return this;
      }
      const { type } = data2;
      if (!DataType.isDictionary(type)) {
        const { length } = data2;
        if (length > 2147483647) {
          throw new RangeError("Cannot write arrays larger than 2^31 - 1 in length");
        }
        if (DataType.isUnion(type)) {
          this.nodes.push(new FieldNode2(length, 0));
        } else {
          const { nullCount } = data2;
          if (!DataType.isNull(type)) {
            addBuffer.call(this, nullCount <= 0 ? new Uint8Array(0) : truncateBitmap(data2.offset, length, data2.nullBitmap));
          }
          this.nodes.push(new FieldNode2(length, nullCount));
        }
      }
      return super.visit(data2);
    }
    visitNull(_null) {
      return this;
    }
    visitDictionary(data2) {
      return this.visit(data2.clone(data2.type.indices));
    }
    get nodes() {
      return this._nodes;
    }
    get buffers() {
      return this._buffers;
    }
    get byteLength() {
      return this._byteLength;
    }
    get bufferRegions() {
      return this._bufferRegions;
    }
  };
  function addBuffer(values) {
    const byteLength = values.byteLength + 7 & ~7;
    this.buffers.push(values);
    this.bufferRegions.push(new BufferRegion(this._byteLength, byteLength));
    this._byteLength += byteLength;
    return this;
  }
  function assembleUnion(data2) {
    var _a5;
    const { type, length, typeIds, valueOffsets } = data2;
    addBuffer.call(this, typeIds);
    if (type.mode === UnionMode.Sparse) {
      return assembleNestedVector.call(this, data2);
    } else if (type.mode === UnionMode.Dense) {
      if (data2.offset <= 0) {
        addBuffer.call(this, valueOffsets);
        return assembleNestedVector.call(this, data2);
      } else {
        const shiftedOffsets = new Int32Array(length);
        const childOffsets = /* @__PURE__ */ Object.create(null);
        const childLengths = /* @__PURE__ */ Object.create(null);
        for (let typeId, shift, index = -1; ++index < length; ) {
          if ((typeId = typeIds[index]) === void 0) {
            continue;
          }
          if ((shift = childOffsets[typeId]) === void 0) {
            shift = childOffsets[typeId] = valueOffsets[index];
          }
          shiftedOffsets[index] = valueOffsets[index] - shift;
          childLengths[typeId] = ((_a5 = childLengths[typeId]) !== null && _a5 !== void 0 ? _a5 : 0) + 1;
        }
        addBuffer.call(this, shiftedOffsets);
        this.visitMany(data2.children.map((child, childIndex) => {
          const typeId = type.typeIds[childIndex];
          const childOffset = childOffsets[typeId];
          const childLength = childLengths[typeId];
          return child.slice(childOffset, Math.min(length, childLength));
        }));
      }
    }
    return this;
  }
  function assembleBoolVector(data2) {
    let values;
    if (data2.nullCount >= data2.length) {
      return addBuffer.call(this, new Uint8Array(0));
    } else if ((values = data2.values) instanceof Uint8Array) {
      return addBuffer.call(this, truncateBitmap(data2.offset, data2.length, values));
    }
    return addBuffer.call(this, packBools(data2.values));
  }
  function assembleFlatVector(data2) {
    return addBuffer.call(this, data2.values.subarray(0, data2.length * data2.stride));
  }
  function assembleFlatListVector(data2) {
    const { length, values, valueOffsets } = data2;
    const { [0]: begin, [length]: end } = valueOffsets;
    const byteLength = Math.min(end - begin, values.byteLength - begin);
    addBuffer.call(this, rebaseValueOffsets(-begin, length + 1, valueOffsets));
    addBuffer.call(this, values.subarray(begin, begin + byteLength));
    return this;
  }
  function assembleListVector(data2) {
    const { length, valueOffsets } = data2;
    if (valueOffsets) {
      const { [0]: begin, [length]: end } = valueOffsets;
      addBuffer.call(this, rebaseValueOffsets(-begin, length + 1, valueOffsets));
      return this.visit(data2.children[0].slice(begin, end - begin));
    }
    return this.visit(data2.children[0]);
  }
  function assembleNestedVector(data2) {
    return this.visitMany(data2.type.children.map((_, i2) => data2.children[i2]).filter(Boolean))[0];
  }
  VectorAssembler.prototype.visitBool = assembleBoolVector;
  VectorAssembler.prototype.visitInt = assembleFlatVector;
  VectorAssembler.prototype.visitFloat = assembleFlatVector;
  VectorAssembler.prototype.visitUtf8 = assembleFlatListVector;
  VectorAssembler.prototype.visitBinary = assembleFlatListVector;
  VectorAssembler.prototype.visitFixedSizeBinary = assembleFlatVector;
  VectorAssembler.prototype.visitDate = assembleFlatVector;
  VectorAssembler.prototype.visitTimestamp = assembleFlatVector;
  VectorAssembler.prototype.visitTime = assembleFlatVector;
  VectorAssembler.prototype.visitDecimal = assembleFlatVector;
  VectorAssembler.prototype.visitList = assembleListVector;
  VectorAssembler.prototype.visitStruct = assembleNestedVector;
  VectorAssembler.prototype.visitUnion = assembleUnion;
  VectorAssembler.prototype.visitInterval = assembleFlatVector;
  VectorAssembler.prototype.visitDuration = assembleFlatVector;
  VectorAssembler.prototype.visitFixedSizeList = assembleListVector;
  VectorAssembler.prototype.visitMap = assembleListVector;

  // ../../node_modules/apache-arrow/ipc/writer.mjs
  var RecordBatchWriter = class extends ReadableInterop {
    /** @nocollapse */
    // @ts-ignore
    static throughNode(options) {
      throw new Error(`"throughNode" not available in this environment`);
    }
    /** @nocollapse */
    static throughDOM(writableStrategy, readableStrategy) {
      throw new Error(`"throughDOM" not available in this environment`);
    }
    constructor(options) {
      super();
      this._position = 0;
      this._started = false;
      this._sink = new AsyncByteQueue();
      this._schema = null;
      this._dictionaryBlocks = [];
      this._recordBatchBlocks = [];
      this._dictionaryDeltaOffsets = /* @__PURE__ */ new Map();
      isObject(options) || (options = { autoDestroy: true, writeLegacyIpcFormat: false });
      this._autoDestroy = typeof options.autoDestroy === "boolean" ? options.autoDestroy : true;
      this._writeLegacyIpcFormat = typeof options.writeLegacyIpcFormat === "boolean" ? options.writeLegacyIpcFormat : false;
    }
    toString(sync = false) {
      return this._sink.toString(sync);
    }
    toUint8Array(sync = false) {
      return this._sink.toUint8Array(sync);
    }
    writeAll(input) {
      if (isPromise(input)) {
        return input.then((x) => this.writeAll(x));
      } else if (isAsyncIterable(input)) {
        return writeAllAsync(this, input);
      }
      return writeAll(this, input);
    }
    get closed() {
      return this._sink.closed;
    }
    [Symbol.asyncIterator]() {
      return this._sink[Symbol.asyncIterator]();
    }
    toDOMStream(options) {
      return this._sink.toDOMStream(options);
    }
    toNodeStream(options) {
      return this._sink.toNodeStream(options);
    }
    close() {
      return this.reset()._sink.close();
    }
    abort(reason) {
      return this.reset()._sink.abort(reason);
    }
    finish() {
      this._autoDestroy ? this.close() : this.reset(this._sink, this._schema);
      return this;
    }
    reset(sink = this._sink, schema = null) {
      if (sink === this._sink || sink instanceof AsyncByteQueue) {
        this._sink = sink;
      } else {
        this._sink = new AsyncByteQueue();
        if (sink && isWritableDOMStream(sink)) {
          this.toDOMStream({ type: "bytes" }).pipeTo(sink);
        } else if (sink && isWritableNodeStream(sink)) {
          this.toNodeStream({ objectMode: false }).pipe(sink);
        }
      }
      if (this._started && this._schema) {
        this._writeFooter(this._schema);
      }
      this._started = false;
      this._dictionaryBlocks = [];
      this._recordBatchBlocks = [];
      this._dictionaryDeltaOffsets = /* @__PURE__ */ new Map();
      if (!schema || !compareSchemas(schema, this._schema)) {
        if (schema == null) {
          this._position = 0;
          this._schema = null;
        } else {
          this._started = true;
          this._schema = schema;
          this._writeSchema(schema);
        }
      }
      return this;
    }
    write(payload) {
      let schema = null;
      if (!this._sink) {
        throw new Error(`RecordBatchWriter is closed`);
      } else if (payload == null) {
        return this.finish() && void 0;
      } else if (payload instanceof Table && !(schema = payload.schema)) {
        return this.finish() && void 0;
      } else if (payload instanceof RecordBatch && !(schema = payload.schema)) {
        return this.finish() && void 0;
      }
      if (schema && !compareSchemas(schema, this._schema)) {
        if (this._started && this._autoDestroy) {
          return this.close();
        }
        this.reset(this._sink, schema);
      }
      if (payload instanceof RecordBatch) {
        if (!(payload instanceof _InternalEmptyPlaceholderRecordBatch)) {
          this._writeRecordBatch(payload);
        }
      } else if (payload instanceof Table) {
        this.writeAll(payload.batches);
      } else if (isIterable(payload)) {
        this.writeAll(payload);
      }
    }
    _writeMessage(message, alignment = 8) {
      const a = alignment - 1;
      const buffer = Message2.encode(message);
      const flatbufferSize = buffer.byteLength;
      const prefixSize = !this._writeLegacyIpcFormat ? 8 : 4;
      const alignedSize = flatbufferSize + prefixSize + a & ~a;
      const nPaddingBytes = alignedSize - flatbufferSize - prefixSize;
      if (message.headerType === MessageHeader.RecordBatch) {
        this._recordBatchBlocks.push(new FileBlock(alignedSize, message.bodyLength, this._position));
      } else if (message.headerType === MessageHeader.DictionaryBatch) {
        this._dictionaryBlocks.push(new FileBlock(alignedSize, message.bodyLength, this._position));
      }
      if (!this._writeLegacyIpcFormat) {
        this._write(Int32Array.of(-1));
      }
      this._write(Int32Array.of(alignedSize - prefixSize));
      if (flatbufferSize > 0) {
        this._write(buffer);
      }
      return this._writePadding(nPaddingBytes);
    }
    _write(chunk) {
      if (this._started) {
        const buffer = toUint8Array(chunk);
        if (buffer && buffer.byteLength > 0) {
          this._sink.write(buffer);
          this._position += buffer.byteLength;
        }
      }
      return this;
    }
    _writeSchema(schema) {
      return this._writeMessage(Message2.from(schema));
    }
    // @ts-ignore
    _writeFooter(schema) {
      return this._writeLegacyIpcFormat ? this._write(Int32Array.of(0)) : this._write(Int32Array.of(-1, 0));
    }
    _writeMagic() {
      return this._write(MAGIC);
    }
    _writePadding(nBytes) {
      return nBytes > 0 ? this._write(new Uint8Array(nBytes)) : this;
    }
    _writeRecordBatch(batch) {
      const { byteLength, nodes, bufferRegions, buffers } = VectorAssembler.assemble(batch);
      const recordBatch = new RecordBatch3(batch.numRows, nodes, bufferRegions);
      const message = Message2.from(recordBatch, byteLength);
      return this._writeDictionaries(batch)._writeMessage(message)._writeBodyBuffers(buffers);
    }
    _writeDictionaryBatch(dictionary, id, isDelta = false) {
      this._dictionaryDeltaOffsets.set(id, dictionary.length + (this._dictionaryDeltaOffsets.get(id) || 0));
      const { byteLength, nodes, bufferRegions, buffers } = VectorAssembler.assemble(new Vector([dictionary]));
      const recordBatch = new RecordBatch3(dictionary.length, nodes, bufferRegions);
      const dictionaryBatch = new DictionaryBatch2(recordBatch, id, isDelta);
      const message = Message2.from(dictionaryBatch, byteLength);
      return this._writeMessage(message)._writeBodyBuffers(buffers);
    }
    _writeBodyBuffers(buffers) {
      let buffer;
      let size, padding;
      for (let i2 = -1, n = buffers.length; ++i2 < n; ) {
        if ((buffer = buffers[i2]) && (size = buffer.byteLength) > 0) {
          this._write(buffer);
          if ((padding = (size + 7 & ~7) - size) > 0) {
            this._writePadding(padding);
          }
        }
      }
      return this;
    }
    _writeDictionaries(batch) {
      for (let [id, dictionary] of batch.dictionaries) {
        let offset = this._dictionaryDeltaOffsets.get(id) || 0;
        if (offset === 0 || (dictionary = dictionary === null || dictionary === void 0 ? void 0 : dictionary.slice(offset)).length > 0) {
          for (const data2 of dictionary.data) {
            this._writeDictionaryBatch(data2, id, offset > 0);
            offset += data2.length;
          }
        }
      }
      return this;
    }
  };
  var RecordBatchStreamWriter = class _RecordBatchStreamWriter extends RecordBatchWriter {
    /** @nocollapse */
    static writeAll(input, options) {
      const writer = new _RecordBatchStreamWriter(options);
      if (isPromise(input)) {
        return input.then((x) => writer.writeAll(x));
      } else if (isAsyncIterable(input)) {
        return writeAllAsync(writer, input);
      }
      return writeAll(writer, input);
    }
  };
  var RecordBatchFileWriter = class _RecordBatchFileWriter extends RecordBatchWriter {
    /** @nocollapse */
    static writeAll(input) {
      const writer = new _RecordBatchFileWriter();
      if (isPromise(input)) {
        return input.then((x) => writer.writeAll(x));
      } else if (isAsyncIterable(input)) {
        return writeAllAsync(writer, input);
      }
      return writeAll(writer, input);
    }
    constructor() {
      super();
      this._autoDestroy = true;
    }
    // @ts-ignore
    _writeSchema(schema) {
      return this._writeMagic()._writePadding(2);
    }
    _writeFooter(schema) {
      const buffer = Footer_.encode(new Footer_(schema, MetadataVersion.V5, this._recordBatchBlocks, this._dictionaryBlocks));
      return super._writeFooter(schema)._write(buffer)._write(Int32Array.of(buffer.byteLength))._writeMagic();
    }
  };
  function writeAll(writer, input) {
    let chunks = input;
    if (input instanceof Table) {
      chunks = input.batches;
      writer.reset(void 0, input.schema);
    }
    for (const batch of chunks) {
      writer.write(batch);
    }
    return writer.finish();
  }
  function writeAllAsync(writer, batches) {
    var _a5, batches_1, batches_1_1;
    var _b2, e_1, _c2, _d2;
    return __awaiter(this, void 0, void 0, function* () {
      try {
        for (_a5 = true, batches_1 = __asyncValues(batches); batches_1_1 = yield batches_1.next(), _b2 = batches_1_1.done, !_b2; _a5 = true) {
          _d2 = batches_1_1.value;
          _a5 = false;
          const batch = _d2;
          writer.write(batch);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (!_a5 && !_b2 && (_c2 = batches_1.return))
            yield _c2.call(batches_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return writer.finish();
    });
  }

  // ../../node_modules/apache-arrow/io/whatwg/iterable.mjs
  function toDOMStream(source, options) {
    if (isAsyncIterable(source)) {
      return asyncIterableAsReadableDOMStream(source, options);
    }
    if (isIterable(source)) {
      return iterableAsReadableDOMStream(source, options);
    }
    throw new Error(`toDOMStream() must be called with an Iterable or AsyncIterable`);
  }
  function iterableAsReadableDOMStream(source, options) {
    let it2 = null;
    const bm = (options === null || options === void 0 ? void 0 : options.type) === "bytes" || false;
    const hwm = (options === null || options === void 0 ? void 0 : options.highWaterMark) || Math.pow(2, 24);
    return new ReadableStream(Object.assign(Object.assign({}, options), {
      start(controller) {
        next(controller, it2 || (it2 = source[Symbol.iterator]()));
      },
      pull(controller) {
        it2 ? next(controller, it2) : controller.close();
      },
      cancel() {
        ((it2 === null || it2 === void 0 ? void 0 : it2.return) && it2.return() || true) && (it2 = null);
      }
    }), Object.assign({ highWaterMark: bm ? hwm : void 0 }, options));
    function next(controller, it3) {
      let buf;
      let r = null;
      let size = controller.desiredSize || null;
      while (!(r = it3.next(bm ? size : null)).done) {
        if (ArrayBuffer.isView(r.value) && (buf = toUint8Array(r.value))) {
          size != null && bm && (size = size - buf.byteLength + 1);
          r.value = buf;
        }
        controller.enqueue(r.value);
        if (size != null && --size <= 0) {
          return;
        }
      }
      controller.close();
    }
  }
  function asyncIterableAsReadableDOMStream(source, options) {
    let it2 = null;
    const bm = (options === null || options === void 0 ? void 0 : options.type) === "bytes" || false;
    const hwm = (options === null || options === void 0 ? void 0 : options.highWaterMark) || Math.pow(2, 24);
    return new ReadableStream(Object.assign(Object.assign({}, options), {
      start(controller) {
        return __awaiter(this, void 0, void 0, function* () {
          yield next(controller, it2 || (it2 = source[Symbol.asyncIterator]()));
        });
      },
      pull(controller) {
        return __awaiter(this, void 0, void 0, function* () {
          it2 ? yield next(controller, it2) : controller.close();
        });
      },
      cancel() {
        return __awaiter(this, void 0, void 0, function* () {
          ((it2 === null || it2 === void 0 ? void 0 : it2.return) && (yield it2.return()) || true) && (it2 = null);
        });
      }
    }), Object.assign({ highWaterMark: bm ? hwm : void 0 }, options));
    function next(controller, it3) {
      return __awaiter(this, void 0, void 0, function* () {
        let buf;
        let r = null;
        let size = controller.desiredSize || null;
        while (!(r = yield it3.next(bm ? size : null)).done) {
          if (ArrayBuffer.isView(r.value) && (buf = toUint8Array(r.value))) {
            size != null && bm && (size = size - buf.byteLength + 1);
            r.value = buf;
          }
          controller.enqueue(r.value);
          if (size != null && --size <= 0) {
            return;
          }
        }
        controller.close();
      });
    }
  }

  // ../../node_modules/apache-arrow/io/whatwg/builder.mjs
  function builderThroughDOMStream(options) {
    return new BuilderTransform(options);
  }
  var BuilderTransform = class {
    constructor(options) {
      this._numChunks = 0;
      this._finished = false;
      this._bufferedSize = 0;
      const { ["readableStrategy"]: readableStrategy, ["writableStrategy"]: writableStrategy, ["queueingStrategy"]: queueingStrategy = "count" } = options, builderOptions = __rest(options, ["readableStrategy", "writableStrategy", "queueingStrategy"]);
      this._controller = null;
      this._builder = makeBuilder(builderOptions);
      this._getSize = queueingStrategy !== "bytes" ? chunkLength : chunkByteLength;
      const { ["highWaterMark"]: readableHighWaterMark = queueingStrategy === "bytes" ? Math.pow(2, 14) : 1e3 } = Object.assign({}, readableStrategy);
      const { ["highWaterMark"]: writableHighWaterMark = queueingStrategy === "bytes" ? Math.pow(2, 14) : 1e3 } = Object.assign({}, writableStrategy);
      this["readable"] = new ReadableStream({
        ["cancel"]: () => {
          this._builder.clear();
        },
        ["pull"]: (c) => {
          this._maybeFlush(this._builder, this._controller = c);
        },
        ["start"]: (c) => {
          this._maybeFlush(this._builder, this._controller = c);
        }
      }, {
        "highWaterMark": readableHighWaterMark,
        "size": queueingStrategy !== "bytes" ? chunkLength : chunkByteLength
      });
      this["writable"] = new WritableStream({
        ["abort"]: () => {
          this._builder.clear();
        },
        ["write"]: () => {
          this._maybeFlush(this._builder, this._controller);
        },
        ["close"]: () => {
          this._maybeFlush(this._builder.finish(), this._controller);
        }
      }, {
        "highWaterMark": writableHighWaterMark,
        "size": (value) => this._writeValueAndReturnChunkSize(value)
      });
    }
    _writeValueAndReturnChunkSize(value) {
      const bufferedSize = this._bufferedSize;
      this._bufferedSize = this._getSize(this._builder.append(value));
      return this._bufferedSize - bufferedSize;
    }
    _maybeFlush(builder, controller) {
      if (controller == null) {
        return;
      }
      if (this._bufferedSize >= controller.desiredSize) {
        ++this._numChunks && this._enqueue(controller, builder.toVector());
      }
      if (builder.finished) {
        if (builder.length > 0 || this._numChunks === 0) {
          ++this._numChunks && this._enqueue(controller, builder.toVector());
        }
        if (!this._finished && (this._finished = true)) {
          this._enqueue(controller, null);
        }
      }
    }
    _enqueue(controller, chunk) {
      this._bufferedSize = 0;
      this._controller = null;
      chunk == null ? controller.close() : controller.enqueue(chunk);
    }
  };
  var chunkLength = (chunk) => {
    var _a5;
    return (_a5 = chunk === null || chunk === void 0 ? void 0 : chunk.length) !== null && _a5 !== void 0 ? _a5 : 0;
  };
  var chunkByteLength = (chunk) => {
    var _a5;
    return (_a5 = chunk === null || chunk === void 0 ? void 0 : chunk.byteLength) !== null && _a5 !== void 0 ? _a5 : 0;
  };

  // ../../node_modules/apache-arrow/io/whatwg/reader.mjs
  function recordBatchReaderThroughDOMStream(writableStrategy, readableStrategy) {
    const queue = new AsyncByteQueue();
    let reader = null;
    const readable = new ReadableStream({
      cancel() {
        return __awaiter(this, void 0, void 0, function* () {
          yield queue.close();
        });
      },
      start(controller) {
        return __awaiter(this, void 0, void 0, function* () {
          yield next(controller, reader || (reader = yield open()));
        });
      },
      pull(controller) {
        return __awaiter(this, void 0, void 0, function* () {
          reader ? yield next(controller, reader) : controller.close();
        });
      }
    });
    return { writable: new WritableStream(queue, Object.assign({ "highWaterMark": Math.pow(2, 14) }, writableStrategy)), readable };
    function open() {
      return __awaiter(this, void 0, void 0, function* () {
        return yield (yield RecordBatchReader.from(queue)).open(readableStrategy);
      });
    }
    function next(controller, reader2) {
      return __awaiter(this, void 0, void 0, function* () {
        let size = controller.desiredSize;
        let r = null;
        while (!(r = yield reader2.next()).done) {
          controller.enqueue(r.value);
          if (size != null && --size <= 0) {
            return;
          }
        }
        controller.close();
      });
    }
  }

  // ../../node_modules/apache-arrow/io/whatwg/writer.mjs
  function recordBatchWriterThroughDOMStream(writableStrategy, readableStrategy) {
    const writer = new this(writableStrategy);
    const reader = new AsyncByteStream(writer);
    const readable = new ReadableStream({
      // type: 'bytes',
      cancel() {
        return __awaiter(this, void 0, void 0, function* () {
          yield reader.cancel();
        });
      },
      pull(controller) {
        return __awaiter(this, void 0, void 0, function* () {
          yield next(controller);
        });
      },
      start(controller) {
        return __awaiter(this, void 0, void 0, function* () {
          yield next(controller);
        });
      }
    }, Object.assign({ "highWaterMark": Math.pow(2, 14) }, readableStrategy));
    return { writable: new WritableStream(writer, writableStrategy), readable };
    function next(controller) {
      return __awaiter(this, void 0, void 0, function* () {
        let buf = null;
        let size = controller.desiredSize;
        while (buf = yield reader.read(size || null)) {
          controller.enqueue(buf);
          if (size != null && (size -= buf.byteLength) <= 0) {
            return;
          }
        }
        controller.close();
      });
    }
  }

  // ../../node_modules/apache-arrow/ipc/serialization.mjs
  function tableToIPC(table, type = "stream") {
    return (type === "stream" ? RecordBatchStreamWriter : RecordBatchFileWriter).writeAll(table).toUint8Array(true);
  }

  // ../../node_modules/apache-arrow/Arrow.mjs
  var util = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, bn_exports), int_exports), bit_exports), math_exports), buffer_exports), vector_exports), pretty_exports), {
    compareSchemas,
    compareFields,
    compareTypes
  });

  // ../../node_modules/apache-arrow/Arrow.dom.mjs
  adapters_default.toDOMStream = toDOMStream;
  Builder["throughDOM"] = builderThroughDOMStream;
  RecordBatchReader["throughDOM"] = recordBatchReaderThroughDOMStream;
  RecordBatchFileReader["throughDOM"] = recordBatchReaderThroughDOMStream;
  RecordBatchStreamReader["throughDOM"] = recordBatchReaderThroughDOMStream;
  RecordBatchWriter["throughDOM"] = recordBatchWriterThroughDOMStream;
  RecordBatchFileWriter["throughDOM"] = recordBatchWriterThroughDOMStream;
  RecordBatchStreamWriter["throughDOM"] = recordBatchWriterThroughDOMStream;

  // src/bindings/connection.ts
  var DuckDBConnection = class {
    /** Constructor */
    constructor(bindings, conn) {
      this._bindings = bindings;
      this._conn = conn;
    }
    /** Close a connection */
    close() {
      this._bindings.disconnect(this._conn);
    }
    /** Brave souls may use this function to consume the underlying connection id */
    useUnsafe(callback) {
      return callback(this._bindings, this._conn);
    }
    /** Run a query */
    query(text) {
      const buffer = this._bindings.runQuery(this._conn, text);
      const reader = RecordBatchReader.from(buffer);
      console.assert(reader.isSync());
      console.assert(reader.isFile());
      return new Table(reader);
    }
    /** Send a query */
    async send(text) {
      let header = this._bindings.startPendingQuery(this._conn, text);
      while (header == null) {
        header = await new Promise((resolve, reject) => {
          try {
            resolve(this._bindings.pollPendingQuery(this._conn));
          } catch (e) {
            console.log(e);
            reject(e);
          }
        });
      }
      const iter = new ResultStreamIterator(this._bindings, this._conn, header);
      const reader = RecordBatchReader.from(iter);
      console.assert(reader.isSync());
      console.assert(reader.isStream());
      return reader;
    }
    /** Cancel a query that was sent earlier */
    cancelSent() {
      return this._bindings.cancelPendingQuery(this._conn);
    }
    /** Get table names */
    getTableNames(query) {
      return this._bindings.getTableNames(this._conn, query);
    }
    /** Create a prepared statement */
    prepare(text) {
      const stmt = this._bindings.createPrepared(this._conn, text);
      return new PreparedStatement(this._bindings, this._conn, stmt);
    }
    /** Create a scalar function */
    createScalarFunction(name2, returns, func2) {
      this._bindings.createScalarFunction(this._conn, name2, returns, func2);
    }
    /** Insert an arrow table */
    insertArrowTable(table, options) {
      const buffer = tableToIPC(table, "stream");
      this.insertArrowFromIPCStream(buffer, options);
    }
    /** Insert an arrow table from an ipc stream */
    insertArrowFromIPCStream(buffer, options) {
      this._bindings.insertArrowFromIPCStream(this._conn, buffer, options);
    }
    /** Inesrt csv file from path */
    insertCSVFromPath(path, options) {
      this._bindings.insertCSVFromPath(this._conn, path, options);
    }
    /** Insert json file from path */
    insertJSONFromPath(path, options) {
      this._bindings.insertJSONFromPath(this._conn, path, options);
    }
  };
  var ResultStreamIterator = class {
    constructor(bindings, conn, header) {
      this.bindings = bindings;
      this.conn = conn;
      this.header = header;
      this._first = true;
      this._depleted = false;
    }
    next() {
      if (this._first) {
        this._first = false;
        return { done: false, value: this.header };
      }
      if (this._depleted) {
        return { done: true, value: null };
      }
      const bufferI8 = this.bindings.fetchQueryResults(this.conn);
      this._depleted = bufferI8.length == 0;
      return {
        done: this._depleted,
        value: bufferI8
      };
    }
    [Symbol.iterator]() {
      return this;
    }
  };
  var PreparedStatement = class {
    /** Constructor */
    constructor(bindings, connectionId, statementId) {
      this.bindings = bindings;
      this.connectionId = connectionId;
      this.statementId = statementId;
    }
    /** Close a prepared statement */
    close() {
      this.bindings.closePrepared(this.connectionId, this.statementId);
    }
    /** Run a prepared statement */
    query(...params) {
      const buffer = this.bindings.runPrepared(this.connectionId, this.statementId, params);
      const reader = RecordBatchReader.from(buffer);
      console.assert(reader.isSync());
      console.assert(reader.isFile());
      return new Table(reader);
    }
    /** Send a prepared statement */
    send(...params) {
      const header = this.bindings.sendPrepared(this.connectionId, this.statementId, params);
      const iter = new ResultStreamIterator(this.bindings, this.connectionId, header);
      const reader = RecordBatchReader.from(iter);
      console.assert(reader.isSync());
      console.assert(reader.isStream());
      return reader;
    }
  };

  // src/bindings/udf_runtime.ts
  var TEXT_ENCODER = new TextEncoder();
  var TEXT_DECODER = new TextDecoder("utf-8");
  function storeError(mod, response, message) {
    const msgBuffer = TEXT_ENCODER.encode(message);
    const heapAddr = mod._malloc(msgBuffer.byteLength);
    const heapArray = mod.HEAPU8.subarray(heapAddr, heapAddr + msgBuffer.byteLength);
    heapArray.set(msgBuffer);
    mod.HEAPF64[(response >> 3) + 0] = 1;
    mod.HEAPF64[(response >> 3) + 1] = heapAddr;
    mod.HEAPF64[(response >> 3) + 2] = heapArray.byteLength;
  }
  function getTypeSize(ptype) {
    switch (ptype) {
      case "UINT8":
      case "INT8":
        return 1;
      case "INT32":
      case "FLOAT":
        return 4;
      case "INT64":
      case "UINT64":
      case "DOUBLE":
      case "VARCHAR":
        return 8;
      default:
        return 0;
    }
  }
  function ptrToArray(mod, ptr2, ptype, n) {
    const heap = mod.HEAPU8.subarray(ptr2, ptr2 + n * getTypeSize(ptype));
    switch (ptype) {
      case "UINT8":
        return new Uint8Array(heap.buffer, heap.byteOffset, n);
      case "INT8":
        return new Int8Array(heap.buffer, heap.byteOffset, n);
      case "INT32":
        return new Int32Array(heap.buffer, heap.byteOffset, n);
      case "FLOAT":
        return new Float32Array(heap.buffer, heap.byteOffset, n);
      case "DOUBLE":
        return new Float64Array(heap.buffer, heap.byteOffset, n);
      case "VARCHAR":
        return new Float64Array(heap.buffer, heap.byteOffset, n);
      default:
        return new Array(0);
    }
  }
  function ptrToUint8Array(mod, ptr2, n) {
    const heap = mod.HEAPU8.subarray(ptr2, ptr2 + n);
    return new Uint8Array(heap.buffer, heap.byteOffset, n);
  }
  function ptrToFloat64Array(mod, ptr2, n) {
    const heap = mod.HEAPU8.subarray(ptr2, ptr2 + n * 8);
    return new Float64Array(heap.buffer, heap.byteOffset, n);
  }
  function callScalarUDF(runtime2, mod, response, funcId, descPtr, descSize, ptrsPtr, ptrsSize) {
    try {
      const udf = runtime2._udfFunctions.get(funcId);
      if (!udf) {
        storeError(mod, response, "Unknown UDF with id: " + funcId);
        return;
      }
      const rawDesc = TEXT_DECODER.decode(mod.HEAPU8.subarray(descPtr, descPtr + descSize));
      const desc = JSON.parse(rawDesc);
      const ptrs = ptrToFloat64Array(mod, ptrsPtr, ptrsSize / 8);
      const buildResolver = (arg) => {
        let validity = null;
        if (arg.validityBuffer !== void 0) {
          validity = ptrToUint8Array(mod, ptrs[arg.validityBuffer], desc.rows);
        }
        switch (arg.physicalType) {
          case "VARCHAR": {
            if (arg.dataBuffer === null || arg.dataBuffer === void 0) {
              throw new Error("malformed data view, expected data buffer for VARCHAR argument");
            }
            if (arg.lengthBuffer === null || arg.lengthBuffer === void 0) {
              throw new Error("malformed data view, expected data length buffer for VARCHAR argument");
            }
            const raw = ptrToArray(mod, ptrs[arg.dataBuffer], arg.physicalType, desc.rows);
            const strings = [];
            const stringLengths = ptrToFloat64Array(mod, ptrs[arg.lengthBuffer], desc.rows);
            for (let j = 0; j < desc.rows; ++j) {
              if (validity != null && !validity[j]) {
                strings.push(null);
                continue;
              }
              const subarray = mod.HEAPU8.subarray(
                raw[j],
                raw[j] + stringLengths[j]
              );
              const str = TEXT_DECODER.decode(subarray);
              strings.push(str);
            }
            return (row) => strings[row];
          }
          case "STRUCT": {
            const tmp2 = {};
            const children = [];
            for (let j = 0; j < (arg.children?.length || 0); ++j) {
              const attr = arg.children[j];
              const child = buildResolver(attr);
              children.push((row) => {
                tmp2[attr.name] = child(row);
              });
            }
            if (validity != null) {
              return (row) => {
                if (!validity[row]) {
                  return null;
                }
                for (const resolver of children) {
                  resolver(row);
                }
                return tmp2;
              };
            } else {
              return (row) => {
                for (const resolver of children) {
                  resolver(row);
                }
                return tmp2;
              };
            }
          }
          default: {
            if (arg.dataBuffer === void 0) {
              throw new Error(
                "malformed data view, expected data buffer for argument of type: " + arg.physicalType
              );
            }
            const data2 = ptrToArray(mod, ptrs[arg.dataBuffer], arg.physicalType, desc.rows);
            if (validity != null) {
              return (row) => !validity[row] ? null : data2[row];
            } else {
              return (row) => data2[row];
            }
          }
        }
      };
      const argResolvers = [];
      for (let i2 = 0; i2 < desc.args.length; ++i2) {
        argResolvers.push(buildResolver(desc.args[i2]));
      }
      const resultDataLen = desc.rows * getTypeSize(desc.ret.physicalType);
      const resultDataPtr = mod._malloc(resultDataLen);
      const resultData = ptrToArray(mod, resultDataPtr, desc.ret.physicalType, desc.rows);
      const resultValidityPtr = mod._malloc(desc.rows);
      const resultValidity = ptrToUint8Array(mod, resultValidityPtr, desc.rows);
      if (resultData.length == 0 || resultValidity.length == 0) {
        storeError(mod, response, "Can't create physical arrays for result");
        return;
      }
      let rawResultData = resultData;
      if (desc.ret.physicalType == "VARCHAR") {
        rawResultData = new Array(desc.rows);
      }
      const args2 = [];
      for (let i2 = 0; i2 < desc.args.length; ++i2) {
        args2.push(null);
      }
      for (let i2 = 0; i2 < desc.rows; ++i2) {
        for (let j = 0; j < desc.args.length; ++j) {
          args2[j] = argResolvers[j](i2);
        }
        const res = udf.func(...args2);
        rawResultData[i2] = res;
        resultValidity[i2] = res === void 0 || res === null ? 0 : 1;
      }
      let resultLengthsPtr = 0;
      switch (desc.ret.physicalType) {
        case "VARCHAR": {
          const resultDataUTF8 = new Array(0);
          resultLengthsPtr = mod._malloc(desc.rows * getTypeSize("DOUBLE"));
          const resultLengths = ptrToFloat64Array(mod, resultLengthsPtr, desc.rows);
          let totalLength = 0;
          for (let row = 0; row < desc.rows; ++row) {
            const utf8 = TEXT_ENCODER.encode(rawResultData[row] || "");
            resultDataUTF8.push(utf8);
            resultLengths[row] = utf8.length;
            totalLength += utf8.length;
          }
          const resultStringPtr = mod._malloc(totalLength);
          const resultStringBuf = mod.HEAPU8.subarray(resultStringPtr, resultStringPtr + totalLength);
          let writerOffset = 0;
          for (let row = 0; row < desc.rows; ++row) {
            resultData[row] = writerOffset;
            const resultUTF8 = resultDataUTF8[row];
            const writer = resultStringBuf.subarray(writerOffset, writerOffset + resultUTF8.length);
            writer.set(resultUTF8);
            writerOffset += resultUTF8.length;
          }
        }
      }
      const retLen = 3 * 8;
      const retPtr = mod._malloc(retLen);
      const retBuffer = ptrToFloat64Array(mod, retPtr, 3);
      retBuffer[0] = resultDataPtr;
      retBuffer[1] = resultValidityPtr;
      retBuffer[2] = resultLengthsPtr;
      mod.HEAPF64[(response >> 3) + 0] = 0;
      mod.HEAPF64[(response >> 3) + 1] = retPtr;
      mod.HEAPF64[(response >> 3) + 2] = 0;
    } catch (e) {
      storeError(mod, response, e.toString());
    }
  }

  // src/bindings/runtime.ts
  function TextDecoderWrapper() {
    const decoder3 = new TextDecoder();
    return (data2) => {
      if (typeof SharedArrayBuffer !== "undefined" && data2.buffer instanceof SharedArrayBuffer) {
        data2 = new Uint8Array(data2);
      }
      return decoder3.decode(data2);
    };
  }
  var decodeText = TextDecoderWrapper();
  function failWith(mod, msg) {
    console.error(`FAIL WITH: ${msg}`);
    mod.ccall("duckdb_web_fail_with", null, ["string"], [msg]);
  }
  function copyBuffer(mod, begin, length) {
    const buffer = mod.HEAPU8.subarray(begin, begin + length);
    const copy = new Uint8Array(new ArrayBuffer(buffer.byteLength));
    copy.set(buffer);
    return copy;
  }
  function readString(mod, begin, length) {
    return decodeText(mod.HEAPU8.subarray(begin, begin + length));
  }
  function callSRet(mod, funcName, argTypes, args2) {
    const stackPointer = mod.stackSave();
    const response = mod.stackAlloc(3 * 8);
    argTypes.unshift("number");
    args2.unshift(response);
    mod.ccall(funcName, null, argTypes, args2);
    const status = mod.HEAPF64[(response >> 3) + 0];
    const data2 = mod.HEAPF64[(response >> 3) + 1];
    const dataSize = mod.HEAPF64[(response >> 3) + 2];
    mod.stackRestore(stackPointer);
    return [status, data2, dataSize];
  }
  function dropResponseBuffers(mod) {
    mod.ccall("duckdb_web_clear_response", null, [], []);
  }

  // src/bindings/file_stats.ts
  var FileStatistics = class {
    constructor(u8array) {
      const f642 = new Float64Array(u8array.buffer, u8array.byteOffset, u8array.byteLength / 8);
      const blocks = new Uint8Array(new ArrayBuffer(u8array.byteLength));
      blocks.set(u8array.subarray(7 * 8));
      this.totalFileReadsCold = f642[0];
      this.totalFileReadsAhead = f642[1];
      this.totalFileReadsCached = f642[2];
      this.totalFileWrites = f642[3];
      this.totalPageAccesses = f642[4];
      this.totalPageLoads = f642[5];
      this.blockSize = f642[6];
      this.blockStats = blocks;
    }
    /** The block stats */
    getBlockStats(index, out2) {
      out2 = out2 || {
        file_reads_cold: 0,
        file_reads_ahead: 0,
        file_reads_cached: 0,
        file_writes: 0,
        page_accesses: 0,
        page_loads: 0
      };
      out2.file_writes = this.blockStats[index * 3 + 0] & 15;
      out2.file_reads_cold = this.blockStats[index * 3 + 0] >> 4;
      out2.file_reads_ahead = this.blockStats[index * 3 + 1] & 15;
      out2.file_reads_cached = this.blockStats[index * 3 + 1] >> 4;
      out2.page_accesses = this.blockStats[index * 3 + 1] & 15;
      out2.page_loads = this.blockStats[index * 3 + 1] >> 4;
      return out2;
    }
  };

  // src/json_typedef.ts
  function arrowToSQLType(type) {
    switch (type.typeId) {
      case Type.Binary:
        return { sqlType: "binary" };
      case Type.Bool:
        return { sqlType: "bool" };
      case Type.Date:
        return { sqlType: "date" };
      case Type.DateDay:
        return { sqlType: "date32[d]" };
      case Type.DateMillisecond:
        return { sqlType: "date64[ms]" };
      case Type.Decimal: {
        const dec = type;
        return { sqlType: "decimal", precision: dec.precision, scale: dec.scale };
      }
      case Type.Float:
        return { sqlType: "float" };
      case Type.Float16:
        return { sqlType: "float16" };
      case Type.Float32:
        return { sqlType: "float32" };
      case Type.Float64:
        return { sqlType: "float64" };
      case Type.Int:
        return { sqlType: "int32" };
      case Type.Int16:
        return { sqlType: "int16" };
      case Type.Int32:
        return { sqlType: "int32" };
      case Type.Int64:
        return { sqlType: "int64" };
      case Type.Uint16:
        return { sqlType: "uint16" };
      case Type.Uint32:
        return { sqlType: "uint32" };
      case Type.Uint64:
        return { sqlType: "uint64" };
      case Type.Uint8:
        return { sqlType: "uint8" };
      case Type.IntervalDayTime:
        return { sqlType: "interval[dt]" };
      case Type.IntervalYearMonth:
        return { sqlType: "interval[m]" };
      case Type.List: {
        const list = type;
        return {
          sqlType: "list",
          valueType: arrowToSQLType(list.valueType)
        };
      }
      case Type.FixedSizeBinary: {
        const bin = type;
        return { sqlType: "fixedsizebinary", byteWidth: bin.byteWidth };
      }
      case Type.Null:
        return { sqlType: "null" };
      case Type.Utf8:
        return { sqlType: "utf8" };
      case Type.Struct: {
        const struct_ = type;
        return {
          sqlType: "struct",
          fields: struct_.children.map((c) => arrowToSQLField(c.name, c.type))
        };
      }
      case Type.Map: {
        const map_ = type;
        return {
          sqlType: "map",
          keyType: arrowToSQLType(map_.keyType),
          valueType: arrowToSQLType(map_.valueType)
        };
      }
      case Type.Time:
        return { sqlType: "time[s]" };
      case Type.TimeMicrosecond:
        return { sqlType: "time[us]" };
      case Type.TimeMillisecond:
        return { sqlType: "time[ms]" };
      case Type.TimeNanosecond:
        return { sqlType: "time[ns]" };
      case Type.TimeSecond:
        return { sqlType: "time[s]" };
      case Type.Timestamp: {
        const ts = type;
        return { sqlType: "timestamp", timezone: ts.timezone || void 0 };
      }
      case Type.TimestampSecond: {
        const ts = type;
        return { sqlType: "timestamp[s]", timezone: ts.timezone || void 0 };
      }
      case Type.TimestampMicrosecond: {
        const ts = type;
        return { sqlType: "timestamp[us]", timezone: ts.timezone || void 0 };
      }
      case Type.TimestampNanosecond: {
        const ts = type;
        return { sqlType: "timestamp[ns]", timezone: ts.timezone || void 0 };
      }
      case Type.TimestampMillisecond: {
        const ts = type;
        return { sqlType: "timestamp[ms]", timezone: ts.timezone || void 0 };
      }
    }
    throw new Error(`unsupported arrow type: ${type.toString()}`);
  }
  function arrowToSQLField(name2, type) {
    const t = arrowToSQLType(type);
    t.name = name2;
    return t;
  }

  // src/bindings/bindings_base.ts
  var TEXT_ENCODER2 = new TextEncoder();
  var DuckDBBindingsBase = class {
    constructor(logger, runtime2) {
      /** The instance */
      this._instance = null;
      /** The loading promise */
      this._initPromise = null;
      /** The resolver for the open promise (called by onRuntimeInitialized) */
      this._initPromiseResolver = () => {
      };
      /** Instantiate the module */
      this.onInstantiationProgress = [];
      this._logger = logger;
      this._runtime = runtime2;
      this._nextUDFId = 1;
    }
    /** Get the logger */
    get logger() {
      return this._logger;
    }
    /** Get the instance */
    get mod() {
      return this._instance;
    }
    /** Get the instance */
    get pthread() {
      return this.mod.PThread || null;
    }
    /** Instantiate the database */
    async instantiate(onProgress = (_) => {
    }) {
      if (this._instance != null) {
        return this;
      }
      if (this._initPromise != null) {
        this.onInstantiationProgress.push(onProgress);
        await this._initPromise;
      }
      this._initPromise = new Promise((resolve) => {
        this._initPromiseResolver = resolve;
      });
      this.onInstantiationProgress = [onProgress];
      this._instance = await this.instantiateImpl({
        print: console.log.bind(console),
        printErr: console.log.bind(console),
        onRuntimeInitialized: this._initPromiseResolver
      });
      await this._initPromise;
      this._initPromise = null;
      this.onInstantiationProgress = this.onInstantiationProgress.filter((x) => x != onProgress);
      globalThis.DUCKDB_BINDINGS = this;
      return this;
    }
    /** Open a database with a config */
    open(config) {
      const [s2, d, n] = callSRet(this.mod, "duckdb_web_open", ["string"], [JSON.stringify(config)]);
      if (s2 !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      dropResponseBuffers(this.mod);
    }
    /** Reset the database */
    reset() {
      const [s2, d, n] = callSRet(this.mod, "duckdb_web_reset", [], []);
      if (s2 !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      dropResponseBuffers(this.mod);
    }
    /** Get the version */
    getVersion() {
      const [s2, d, n] = callSRet(this.mod, "duckdb_web_get_version", [], []);
      if (s2 !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      const version = readString(this.mod, d, n);
      dropResponseBuffers(this.mod);
      return version;
    }
    /** Get the feature flags */
    getFeatureFlags() {
      return this.mod.ccall("duckdb_web_get_feature_flags", "number", [], []);
    }
    /** Tokenize a script */
    tokenize(text) {
      const [s2, d, n] = callSRet(this.mod, "duckdb_web_tokenize", ["string"], [text]);
      if (s2 !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      const res = readString(this.mod, d, n);
      dropResponseBuffers(this.mod);
      return JSON.parse(res);
    }
    /** Connect to database */
    connect() {
      const conn = this.mod.ccall("duckdb_web_connect", "number", [], []);
      return new DuckDBConnection(this, conn);
    }
    /** Disconnect from database */
    disconnect(conn) {
      this.mod.ccall("duckdb_web_disconnect", null, ["number"], [conn]);
      if (this.pthread) {
        for (const worker2 of [...this.pthread.runningWorkers, ...this.pthread.unusedWorkers]) {
          worker2.postMessage({
            cmd: "dropUDFFunctions",
            connectionId: conn
          });
        }
      }
    }
    /** Send a query and return the full result */
    runQuery(conn, text) {
      const [s2, d, n] = callSRet(this.mod, "duckdb_web_query_run", ["number", "string"], [conn, text]);
      if (s2 !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      const res = copyBuffer(this.mod, d, n);
      dropResponseBuffers(this.mod);
      return res;
    }
    /**
     *  Start a pending query asynchronously.
     *  This method returns either the arrow ipc schema or null.
     *  On null, the query has to be executed using `pollPendingQuery` until that returns != null.
     *  Results can then be fetched using `fetchQueryResults`
     */
    startPendingQuery(conn, text) {
      const [s2, d, n] = callSRet(this.mod, "duckdb_web_pending_query_start", ["number", "string"], [conn, text]);
      if (s2 !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      if (d == 0) {
        return null;
      }
      const res = copyBuffer(this.mod, d, n);
      dropResponseBuffers(this.mod);
      return res;
    }
    /** Poll a pending query */
    pollPendingQuery(conn) {
      const [s2, d, n] = callSRet(this.mod, "duckdb_web_pending_query_poll", ["number"], [conn]);
      if (s2 !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      if (d == 0) {
        return null;
      }
      const res = copyBuffer(this.mod, d, n);
      dropResponseBuffers(this.mod);
      return res;
    }
    /** Cancel a pending query */
    cancelPendingQuery(conn) {
      return this.mod.ccall("duckdb_web_pending_query_cancel", "boolean", ["number"], [conn]);
    }
    /** Fetch query results */
    fetchQueryResults(conn) {
      const [s2, d, n] = callSRet(this.mod, "duckdb_web_query_fetch_results", ["number"], [conn]);
      if (s2 !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      const res = copyBuffer(this.mod, d, n);
      dropResponseBuffers(this.mod);
      return res;
    }
    /** Get table names */
    getTableNames(conn, text) {
      const [s2, d, n] = callSRet(this.mod, "duckdb_web_get_tablenames", ["number", "string"], [conn, text]);
      if (s2 !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      const res = readString(this.mod, d, n);
      dropResponseBuffers(this.mod);
      return JSON.parse(res);
    }
    /** Create a scalar function */
    createScalarFunction(conn, name2, returns, func2) {
      const decl = {
        functionId: this._nextUDFId,
        name: name2,
        returnType: arrowToSQLType(returns)
      };
      const def = {
        functionId: decl.functionId,
        connectionId: conn,
        name: name2,
        returnType: returns,
        func: func2
      };
      this._nextUDFId += 1;
      const [s2, d, n] = callSRet(
        this.mod,
        "duckdb_web_udf_scalar_create",
        ["number", "string"],
        [conn, JSON.stringify(decl)]
      );
      if (s2 !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      dropResponseBuffers(this.mod);
      globalThis.DUCKDB_RUNTIME._udfFunctions = (globalThis.DUCKDB_RUNTIME._udfFunctions || /* @__PURE__ */ new Map()).set(
        def.functionId,
        def
      );
      if (this.pthread) {
        for (const worker2 of [...this.pthread.runningWorkers, ...this.pthread.unusedWorkers]) {
          worker2.postMessage({
            cmd: "registerUDFFunction",
            udf: def
          });
        }
      }
    }
    /** Prepare a statement and return its identifier */
    createPrepared(conn, text) {
      const [s2, d, n] = callSRet(this.mod, "duckdb_web_prepared_create", ["number", "string"], [conn, text]);
      if (s2 !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      dropResponseBuffers(this.mod);
      return d;
    }
    /** Close a prepared statement */
    closePrepared(conn, statement) {
      const [s2, d, n] = callSRet(this.mod, "duckdb_web_prepared_close", ["number", "number"], [conn, statement]);
      if (s2 !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      dropResponseBuffers(this.mod);
    }
    /** Execute a prepared statement and return the full result */
    runPrepared(conn, statement, params) {
      const [s2, d, n] = callSRet(
        this.mod,
        "duckdb_web_prepared_run",
        ["number", "number", "string"],
        [conn, statement, JSON.stringify(params)]
      );
      if (s2 !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      const res = copyBuffer(this.mod, d, n);
      dropResponseBuffers(this.mod);
      return res;
    }
    /** Execute a prepared statement and stream the result */
    sendPrepared(conn, statement, params) {
      const [s2, d, n] = callSRet(
        this.mod,
        "duckdb_web_prepared_send",
        ["number", "number", "string"],
        [conn, statement, JSON.stringify(params)]
      );
      if (s2 !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      const res = copyBuffer(this.mod, d, n);
      dropResponseBuffers(this.mod);
      return res;
    }
    /** Insert record batches from an arrow ipc stream */
    insertArrowFromIPCStream(conn, buffer, options) {
      if (buffer.length == 0)
        return;
      const bufferPtr = this.mod._malloc(buffer.length);
      const bufferOfs = this.mod.HEAPU8.subarray(bufferPtr, bufferPtr + buffer.length);
      bufferOfs.set(buffer);
      const optJSON = options ? JSON.stringify(options) : "";
      const [s2, d, n] = callSRet(
        this.mod,
        "duckdb_web_insert_arrow_from_ipc_stream",
        ["number", "number", "number", "string"],
        [conn, bufferPtr, buffer.length, optJSON]
      );
      if (s2 !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
    }
    /** Insert csv from path */
    insertCSVFromPath(conn, path, options) {
      if (options.columns !== void 0) {
        options.columnsFlat = [];
        for (const k in options.columns) {
          options.columnsFlat.push(arrowToSQLField(k, options.columns[k]));
        }
      }
      const opt = { ...options };
      opt.columns = opt.columnsFlat;
      delete opt.columnsFlat;
      const optJSON = JSON.stringify(opt);
      const [s2, d, n] = callSRet(
        this.mod,
        "duckdb_web_insert_csv_from_path",
        ["number", "string", "string"],
        [conn, path, optJSON]
      );
      if (s2 !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
    }
    /** Insert json from path */
    insertJSONFromPath(conn, path, options) {
      if (options.columns !== void 0) {
        options.columnsFlat = [];
        for (const k in options.columns) {
          options.columnsFlat.push(arrowToSQLField(k, options.columns[k]));
        }
      }
      const opt = { ...options };
      opt.columns = opt.columnsFlat;
      delete opt.columnsFlat;
      const optJSON = JSON.stringify(opt);
      const [s2, d, n] = callSRet(
        this.mod,
        "duckdb_web_insert_json_from_path",
        ["number", "string", "string"],
        [conn, path, optJSON]
      );
      if (s2 !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
    }
    /** Glob file infos */
    globFiles(path) {
      const [s2, d, n] = callSRet(this.mod, "duckdb_web_fs_glob_file_infos", ["string"], [path]);
      if (s2 !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      const infoStr = readString(this.mod, d, n);
      dropResponseBuffers(this.mod);
      const info2 = JSON.parse(infoStr);
      if (info2 == null) {
        return [];
      }
      return info2;
    }
    /** Register a file object URL */
    registerFileURL(name2, url2, proto, directIO = false) {
      if (url2 === void 0) {
        url2 = name2;
      }
      const [s2, d, n] = callSRet(
        this.mod,
        "duckdb_web_fs_register_file_url",
        ["string", "string"],
        [name2, url2, proto, directIO]
      );
      if (s2 !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      dropResponseBuffers(this.mod);
    }
    /** Register file text */
    registerFileText(name2, text) {
      const buffer = TEXT_ENCODER2.encode(text);
      this.registerFileBuffer(name2, buffer);
    }
    /** Register a file buffer */
    registerFileBuffer(name2, buffer) {
      const ptr2 = this.mod._malloc(buffer.length);
      const dst = this.mod.HEAPU8.subarray(ptr2, ptr2 + buffer.length);
      dst.set(buffer);
      const [s2, d, n] = callSRet(
        this.mod,
        "duckdb_web_fs_register_file_buffer",
        ["string", "number", "number"],
        [name2, ptr2, buffer.length]
      );
      if (s2 !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      dropResponseBuffers(this.mod);
    }
    /** Register a file object URL */
    registerFileHandle(name2, handle2, protocol, directIO) {
      const [s2, d, n] = callSRet(
        this.mod,
        "duckdb_web_fs_register_file_url",
        ["string", "string", "number", "boolean"],
        [name2, name2, protocol, directIO]
      );
      if (s2 !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      dropResponseBuffers(this.mod);
      globalThis.DUCKDB_RUNTIME._files = (globalThis.DUCKDB_RUNTIME._files || /* @__PURE__ */ new Map()).set(name2, handle2);
      if (this.pthread) {
        for (const worker2 of this.pthread.runningWorkers) {
          worker2.postMessage({
            cmd: "registerFileHandle",
            fileName: name2,
            fileHandle: handle2
          });
        }
        for (const worker2 of this.pthread.unusedWorkers) {
          worker2.postMessage({
            cmd: "dropFileHandle",
            fileName: name2
          });
        }
      }
    }
    /** Drop file */
    dropFile(name2) {
      const [s2, d, n] = callSRet(this.mod, "duckdb_web_fs_drop_file", ["string"], [name2]);
      if (s2 !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      dropResponseBuffers(this.mod);
    }
    /** Drop files */
    dropFiles() {
      const [s2, d, n] = callSRet(this.mod, "duckdb_web_fs_drop_files", [], []);
      if (s2 !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      dropResponseBuffers(this.mod);
    }
    /** Flush all files */
    flushFiles() {
      this.mod.ccall("duckdb_web_flush_files", null, [], []);
    }
    /** Write a file to a path */
    copyFileToPath(name2, path) {
      const [s2, d, n] = callSRet(this.mod, "duckdb_web_copy_file_to_path", ["string", "string"], [name2, path]);
      if (s2 !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      dropResponseBuffers(this.mod);
    }
    /** Write a file to a buffer */
    copyFileToBuffer(name2) {
      const [s2, d, n] = callSRet(this.mod, "duckdb_web_copy_file_to_buffer", ["string"], [name2]);
      if (s2 !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      const buffer = this.mod.HEAPU8.subarray(d, d + n);
      const copy = new Uint8Array(buffer.length);
      copy.set(buffer);
      dropResponseBuffers(this.mod);
      return copy;
    }
    /** Enable tracking of file statistics */
    collectFileStatistics(file, enable) {
      const [s2, d, n] = callSRet(this.mod, "duckdb_web_collect_file_stats", ["string", "boolean"], [file, enable]);
      if (s2 !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
    }
    /** Export file statistics */
    exportFileStatistics(file) {
      const [s2, d, n] = callSRet(this.mod, "duckdb_web_export_file_stats", ["string"], [file]);
      if (s2 !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      return new FileStatistics(this.mod.HEAPU8.subarray(d, d + n));
    }
  };

  // src/log.ts
  var VoidLogger = class {
    log(_entry) {
    }
  };

  // ../../node_modules/wasm-feature-detect/dist/esm/index.js
  var bulkMemory = async () => WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 5, 3, 1, 0, 1, 10, 14, 1, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11]));
  var exceptions = async () => WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 8, 1, 6, 0, 6, 64, 25, 11, 11]));
  var simd = async () => WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 123, 3, 2, 1, 0, 10, 10, 1, 8, 0, 65, 0, 253, 15, 253, 98, 11]));
  var threads = () => (async (e) => {
    try {
      return "undefined" != typeof MessageChannel && new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)), WebAssembly.validate(e);
    } catch (e2) {
      return false;
    }
  })(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 5, 4, 1, 3, 1, 1, 10, 11, 1, 9, 0, 65, 0, 254, 16, 2, 0, 26, 11]));

  // src/platform.ts
  var isNode = () => typeof navigator === "undefined" ? true : false;
  var bigInt64Array = null;
  var wasmExceptions = null;
  var wasmThreads = null;
  var wasmSIMD = null;
  var wasmBulkMemory = null;
  async function getPlatformFeatures() {
    if (bigInt64Array == null) {
      bigInt64Array = typeof BigInt64Array != "undefined";
    }
    if (wasmExceptions == null) {
      wasmExceptions = await exceptions();
    }
    if (wasmThreads == null) {
      wasmThreads = await threads();
    }
    if (wasmSIMD == null) {
      wasmSIMD = await simd();
    }
    if (wasmBulkMemory == null) {
      wasmBulkMemory = await bulkMemory();
    }
    return {
      bigInt64Array,
      crossOriginIsolated: isNode() || globalThis.crossOriginIsolated || false,
      wasmExceptions,
      wasmSIMD,
      wasmThreads,
      wasmBulkMemory
    };
  }
  async function selectBundle(bundles) {
    const platform = await getPlatformFeatures();
    if (platform.wasmExceptions) {
      if (platform.wasmSIMD && platform.wasmThreads && platform.crossOriginIsolated && bundles.coi) {
        return {
          mainModule: bundles.coi.mainModule,
          mainWorker: bundles.coi.mainWorker,
          pthreadWorker: bundles.coi.pthreadWorker
        };
      }
      if (bundles.eh) {
        return {
          mainModule: bundles.eh.mainModule,
          mainWorker: bundles.eh.mainWorker,
          pthreadWorker: null
        };
      }
    }
    return {
      mainModule: bundles.mvp.mainModule,
      mainWorker: bundles.mvp.mainWorker,
      pthreadWorker: null
    };
  }

  // src/utils/s3_helper.ts
  var import_js_sha256 = __toESM(require_sha256());
  var getHTTPHost = function(config, url2, bucket) {
    if (config?.endpoint?.startsWith("http")) {
      const httpHost = `${config?.endpoint}`;
      const offset = httpHost.indexOf("://") + 3;
      return httpHost.substring(offset);
    } else if (config?.endpoint) {
      return `${bucket}.${config?.endpoint}`;
    } else {
      return `${bucket}.s3.amazonaws.com`;
    }
  };
  function getS3Params(config, url2, method) {
    const parsedS3Url = parseS3Url(url2);
    let path = parsedS3Url.path;
    if (isPathStyleAccess(config)) {
      path = `/${parsedS3Url.bucket}${path}`;
    }
    return {
      url: path,
      query: "",
      host: getHTTPHost(config, url2, parsedS3Url.bucket),
      region: config?.region ?? "",
      service: "s3",
      method,
      accessKeyId: config?.accessKeyId ?? "",
      secretAccessKey: config?.secretAccessKey ?? "",
      sessionToken: config?.sessionToken ?? "",
      dateNow: (/* @__PURE__ */ new Date()).toISOString().replace(/-/g, "").split("T")[0],
      datetimeNow: (/* @__PURE__ */ new Date()).toISOString().replace(/-/g, "").replace(/:/g, "").split(".")[0] + "Z"
    };
  }
  function uriEncode(input, encode_slash = false) {
    const hexDigit = "0123456789ABCDEF";
    let result = "";
    for (let i2 = 0; i2 < input.length; i2++) {
      const ch = input[i2];
      if (ch >= "A" && ch <= "Z" || ch >= "a" && ch <= "z" || ch >= "0" && ch <= "9" || ch == "_" || ch == "-" || ch == "~" || ch == ".") {
        result += ch;
      } else if (ch == "/") {
        if (encode_slash) {
          result += "%2F";
        } else {
          result += ch;
        }
      } else {
        result += "%";
        result += hexDigit[ch.charCodeAt(0) >> 4];
        result += hexDigit[ch.charCodeAt(0) & 15];
      }
    }
    return result;
  }
  function createS3Headers(params, payloadParams = null) {
    const payloadHash = payloadParams?.contentHash ?? "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
    const res = /* @__PURE__ */ new Map();
    res.set("x-amz-date", params.datetimeNow);
    res.set("x-amz-content-sha256", payloadHash);
    if (params.sessionToken) {
      res.set("x-amz-security-token", params.sessionToken);
    }
    let signedHeaders = "";
    if (payloadParams?.contentType) {
      signedHeaders += "content-type;";
    }
    signedHeaders += "host;x-amz-content-sha256;x-amz-date";
    if (params.sessionToken) {
      signedHeaders += ";x-amz-security-token";
    }
    let canonicalRequest = params.method + "\n" + uriEncode(params.url) + "\n" + params.query;
    if (payloadParams?.contentType) {
      canonicalRequest += "\ncontent-type:" + payloadParams?.contentType;
    }
    canonicalRequest += "\nhost:" + params.host + "\nx-amz-content-sha256:" + payloadHash + "\nx-amz-date:" + params.datetimeNow;
    if (params.sessionToken && params.sessionToken.length > 0) {
      canonicalRequest += "\nx-amz-security-token:" + params.sessionToken;
    }
    canonicalRequest += "\n\n" + signedHeaders + "\n" + payloadHash;
    const canonicalRequestHashStr = (0, import_js_sha256.sha256)(canonicalRequest);
    const stringToSign = "AWS4-HMAC-SHA256\n" + params.datetimeNow + "\n" + params.dateNow + "/" + params.region + "/" + params.service + "/aws4_request\n" + canonicalRequestHashStr;
    const signKey = "AWS4" + params.secretAccessKey;
    const kDate = import_js_sha256.sha256.hmac.arrayBuffer(signKey, params.dateNow);
    const kRegion = import_js_sha256.sha256.hmac.arrayBuffer(kDate, params.region);
    const kService = import_js_sha256.sha256.hmac.arrayBuffer(kRegion, params.service);
    const signingKey = import_js_sha256.sha256.hmac.arrayBuffer(kService, "aws4_request");
    const signature = import_js_sha256.sha256.hmac(signingKey, stringToSign);
    res.set("Authorization", "AWS4-HMAC-SHA256 Credential=" + params.accessKeyId + "/" + params.dateNow + "/" + params.region + "/" + params.service + "/aws4_request, SignedHeaders=" + signedHeaders + ", Signature=" + signature);
    return res;
  }
  var createS3HeadersFromS3Config = function(config, url2, method, contentType = null, payload = null) {
    const params = getS3Params(config, url2, method);
    const payloadParams = {
      contentType,
      contentHash: payload ? import_js_sha256.sha256.hex(payload) : null
    };
    return createS3Headers(params, payloadParams);
  };
  function addS3Headers(xhr, config, url2, method, contentType = null, payload = null) {
    if (config?.accessKeyId || config?.sessionToken) {
      const headers = createS3HeadersFromS3Config(config, url2, method, contentType, payload);
      headers.forEach((value, header) => {
        xhr.setRequestHeader(header, value);
      });
      if (contentType) {
        xhr.setRequestHeader("content-type", contentType);
      }
    }
  }
  function parseS3Url(url2) {
    if (url2.indexOf("s3://") != 0) {
      throw new Error("URL needs to start with s3://");
    }
    const slashPos = url2.indexOf("/", 5);
    if (slashPos == -1) {
      throw new Error("URL needs to contain a '/' after the host");
    }
    const bucket = url2.substring(5, slashPos);
    if (!bucket) {
      throw new Error("URL needs to contain a bucket name");
    }
    const path = url2.substring(slashPos);
    if (!path) {
      throw new Error("URL needs to contain key");
    }
    return { bucket, path };
  }
  function isPathStyleAccess(config) {
    if (config?.endpoint?.startsWith("http")) {
      return true;
    }
    return false;
  }
  function getHTTPUrl(config, url2) {
    const parsedUrl = parseS3Url(url2);
    if (isPathStyleAccess(config)) {
      return `${config?.endpoint}/${parsedUrl.bucket}` + parsedUrl.path;
    }
    return "https://" + getHTTPHost(config, url2, parsedUrl.bucket) + parsedUrl.path;
  }

  // src/bindings/runtime_browser.ts
  var BROWSER_RUNTIME = {
    _files: /* @__PURE__ */ new Map(),
    _fileInfoCache: /* @__PURE__ */ new Map(),
    _udfFunctions: /* @__PURE__ */ new Map(),
    _globalFileInfo: null,
    getFileInfo(mod, fileId) {
      try {
        const cached = BROWSER_RUNTIME._fileInfoCache.get(fileId);
        const [s2, d, n] = callSRet(
          mod,
          "duckdb_web_fs_get_file_info_by_id",
          ["number", "number"],
          [fileId, cached?.cacheEpoch || 0]
        );
        if (s2 !== 0 /* SUCCESS */) {
          return null;
        } else if (n === 0) {
          return cached;
        }
        const infoStr = readString(mod, d, n);
        dropResponseBuffers(mod);
        const info2 = JSON.parse(infoStr);
        if (info2 == null) {
          return null;
        }
        const file = { ...info2, blob: null };
        BROWSER_RUNTIME._fileInfoCache.set(fileId, file);
        return file;
      } catch (e) {
        console.log(e);
        return null;
      }
    },
    getGlobalFileInfo(mod) {
      try {
        const [s2, d, n] = callSRet(
          mod,
          "duckdb_web_get_global_file_info",
          ["number"],
          [BROWSER_RUNTIME._globalFileInfo?.cacheEpoch || 0]
        );
        if (s2 !== 0 /* SUCCESS */) {
          return null;
        } else if (n === 0) {
          return BROWSER_RUNTIME._globalFileInfo;
        }
        const infoStr = readString(mod, d, n);
        dropResponseBuffers(mod);
        const info2 = JSON.parse(infoStr);
        if (info2 == null) {
          return null;
        }
        BROWSER_RUNTIME._globalFileInfo = { ...info2, blob: null };
        return BROWSER_RUNTIME._globalFileInfo;
      } catch (e) {
        console.log(e);
        return null;
      }
    },
    testPlatformFeature: (_mod, feature) => {
      switch (feature) {
        case 1:
          return typeof BigInt64Array !== "undefined";
        default:
          console.warn(`test for unknown feature: ${feature}`);
          return false;
      }
    },
    getDefaultDataProtocol(mod) {
      return 2 /* BROWSER_FILEREADER */;
    },
    openFile: (mod, fileId, flags2) => {
      try {
        BROWSER_RUNTIME._fileInfoCache.delete(fileId);
        const file = BROWSER_RUNTIME.getFileInfo(mod, fileId);
        switch (file?.dataProtocol) {
          case 4 /* HTTP */:
          case 5 /* S3 */: {
            if (flags2 & 1 /* FILE_FLAGS_READ */ && flags2 & 2 /* FILE_FLAGS_WRITE */) {
              throw new Error(
                `Opening file ${file.fileName} failed: cannot open file with both read and write flags set`
              );
            } else if (flags2 & 32 /* FILE_FLAGS_APPEND */) {
              throw new Error(
                `Opening file ${file.fileName} failed: appending to HTTP/S3 files is not supported`
              );
            } else if (flags2 & 2 /* FILE_FLAGS_WRITE */) {
              const xhr = new XMLHttpRequest();
              if (file.dataProtocol == 5 /* S3 */) {
                xhr.open("HEAD", getHTTPUrl(file.s3Config, file.dataUrl), false);
                addS3Headers(xhr, file.s3Config, file.dataUrl, "HEAD");
              } else {
                xhr.open("HEAD", file.dataUrl, false);
              }
              xhr.send(null);
              if (xhr.status != 200 && xhr.status != 404) {
                throw new Error(
                  `Opening file ${file.fileName} failed: Unexpected return status from server (${xhr.status})`
                );
              } else if (xhr.status == 404 && !(flags2 & 8 /* FILE_FLAGS_FILE_CREATE */ || flags2 & 16 /* FILE_FLAGS_FILE_CREATE_NEW */)) {
                throw new Error(
                  `Opening file ${file.fileName} failed: Cannot write to non-existent file without FILE_FLAGS_FILE_CREATE or FILE_FLAGS_FILE_CREATE_NEW flag.`
                );
              }
              const data2 = mod._malloc(1);
              const src = new Uint8Array();
              mod.HEAPU8.set(src, data2);
              const result = mod._malloc(2 * 8);
              mod.HEAPF64[(result >> 3) + 0] = 1;
              mod.HEAPF64[(result >> 3) + 1] = data2;
              return result;
            } else if (flags2 != 1 /* FILE_FLAGS_READ */) {
              throw new Error(`Opening file ${file.fileName} failed: unsupported file flags: ${flags2}`);
            }
            let contentLength = null;
            let error = null;
            try {
              const xhr = new XMLHttpRequest();
              if (file.dataProtocol == 5 /* S3 */) {
                xhr.open("HEAD", getHTTPUrl(file.s3Config, file.dataUrl), false);
                addS3Headers(xhr, file.s3Config, file.dataUrl, "HEAD");
              } else {
                xhr.open("HEAD", file.dataUrl, false);
              }
              xhr.setRequestHeader("Range", `bytes=0-`);
              xhr.send(null);
              contentLength = xhr.getResponseHeader("Content-Length");
              if (contentLength !== null && xhr.status == 206) {
                const result = mod._malloc(2 * 8);
                mod.HEAPF64[(result >> 3) + 0] = +contentLength;
                mod.HEAPF64[(result >> 3) + 1] = 0;
                return result;
              }
            } catch (e) {
              error = e;
              console.warn(`HEAD request with range header failed: ${e}`);
            }
            if (file.allowFullHttpReads) {
              if (contentLength !== null && +contentLength > 1) {
                const xhr2 = new XMLHttpRequest();
                if (file.dataProtocol == 5 /* S3 */) {
                  xhr2.open("GET", getHTTPUrl(file.s3Config, file.dataUrl), false);
                  addS3Headers(xhr2, file.s3Config, file.dataUrl, "GET");
                } else {
                  xhr2.open("GET", file.dataUrl, false);
                }
                xhr2.responseType = "arraybuffer";
                xhr2.setRequestHeader("Range", `bytes=0-0`);
                xhr2.send(null);
                const contentLength2 = xhr2.getResponseHeader("Content-Length");
                if (xhr2.status == 206 && contentLength2 !== null && +contentLength2 == 1) {
                  const result = mod._malloc(2 * 8);
                  mod.HEAPF64[(result >> 3) + 0] = +contentLength;
                  mod.HEAPF64[(result >> 3) + 1] = 0;
                  return result;
                }
                if (xhr2.status == 200 && contentLength2 !== null && +contentLength2 == +contentLength) {
                  console.warn(`fall back to full HTTP read for: ${file.dataUrl}`);
                  const data2 = mod._malloc(xhr2.response.byteLength);
                  const src = new Uint8Array(xhr2.response, 0, xhr2.response.byteLength);
                  mod.HEAPU8.set(src, data2);
                  const result = mod._malloc(2 * 8);
                  mod.HEAPF64[(result >> 3) + 0] = xhr2.response.byteLength;
                  mod.HEAPF64[(result >> 3) + 1] = data2;
                  return result;
                }
              }
              console.warn(`falling back to full HTTP read for: ${file.dataUrl}`);
              const xhr = new XMLHttpRequest();
              if (file.dataProtocol == 5 /* S3 */) {
                xhr.open("GET", getHTTPUrl(file.s3Config, file.dataUrl), false);
                addS3Headers(xhr, file.s3Config, file.dataUrl, "GET");
              } else {
                xhr.open("GET", file.dataUrl, false);
              }
              xhr.responseType = "arraybuffer";
              xhr.send(null);
              if (xhr.status == 200) {
                const data2 = mod._malloc(xhr.response.byteLength);
                const src = new Uint8Array(xhr.response, 0, xhr.response.byteLength);
                mod.HEAPU8.set(src, data2);
                const result = mod._malloc(2 * 8);
                mod.HEAPF64[(result >> 3) + 0] = xhr.response.byteLength;
                mod.HEAPF64[(result >> 3) + 1] = data2;
                return result;
              }
            }
            if (error != null) {
              throw new Error(`Reading file ${file.fileName} failed with error: ${error}`);
            }
            return 0;
          }
          case 2 /* BROWSER_FILEREADER */: {
            const handle2 = BROWSER_RUNTIME._files?.get(file.fileName);
            if (handle2) {
              const result2 = mod._malloc(2 * 8);
              mod.HEAPF64[(result2 >> 3) + 0] = handle2.size;
              mod.HEAPF64[(result2 >> 3) + 1] = 0;
              return result2;
            }
            console.warn(`Buffering missing file: ${file.fileName}`);
            const result = mod._malloc(2 * 8);
            const buffer = mod._malloc(1);
            mod.HEAPF64[(result >> 3) + 0] = 1;
            mod.HEAPF64[(result >> 3) + 1] = buffer;
            return result;
          }
        }
      } catch (e) {
        console.error(e.toString());
        failWith(mod, e.toString());
      }
      return 0;
    },
    glob: (mod, pathPtr, pathLen) => {
      try {
        const path = readString(mod, pathPtr, pathLen);
        if (path.startsWith("http") || path.startsWith("s3://")) {
          const xhr = new XMLHttpRequest();
          if (path.startsWith("s3://")) {
            const globalInfo = BROWSER_RUNTIME.getGlobalFileInfo(mod);
            xhr.open("HEAD", getHTTPUrl(globalInfo?.s3Config, path), false);
            addS3Headers(xhr, globalInfo?.s3Config, path, "HEAD");
          } else {
            xhr.open("HEAD", path, false);
          }
          xhr.send(null);
          if (xhr.status != 200 && xhr.status !== 206) {
            if (!BROWSER_RUNTIME.getGlobalFileInfo(mod)?.allowFullHttpReads) {
              failWith(mod, `HEAD request failed: ${path}, with full http reads are disabled`);
              return;
            }
            const xhr2 = new XMLHttpRequest();
            if (path.startsWith("s3://")) {
              const globalInfo = BROWSER_RUNTIME.getGlobalFileInfo(mod);
              xhr2.open("GET", getHTTPUrl(globalInfo?.s3Config, path), false);
              addS3Headers(xhr2, globalInfo?.s3Config, path, "HEAD");
            } else {
              xhr2.open("GET", path, false);
            }
            xhr2.setRequestHeader("Range", `bytes=0-0`);
            xhr2.send(null);
            if (xhr2.status != 200 && xhr2.status !== 206) {
              failWith(mod, `HEAD and GET requests failed: ${path}`);
              return;
            }
            const contentLength = xhr2.getResponseHeader("Content-Length");
            if (contentLength && +contentLength > 1) {
              console.warn(`Range request for ${path} did not return a partial response: ${xhr2.status} "${xhr2.statusText}"`);
            }
          }
          mod.ccall("duckdb_web_fs_glob_add_path", null, ["string"], [path]);
        }
      } catch (e) {
        console.log(e);
        failWith(mod, e.toString());
        return 0;
      }
    },
    checkFile: (mod, pathPtr, pathLen) => {
      try {
        const path = readString(mod, pathPtr, pathLen);
        if (path.startsWith("http") || path.startsWith("s3://")) {
          const xhr = new XMLHttpRequest();
          if (path.startsWith("s3://")) {
            const globalInfo = BROWSER_RUNTIME.getGlobalFileInfo(mod);
            xhr.open("HEAD", getHTTPUrl(globalInfo?.s3Config, path), false);
            addS3Headers(xhr, globalInfo?.s3Config, path, "HEAD");
          } else {
            xhr.open("HEAD", path, false);
          }
          xhr.send(null);
          return xhr.status == 206 || xhr.status == 200;
        }
      } catch (e) {
        console.log(e);
        return false;
      }
      return false;
    },
    syncFile: (_mod, _fileId) => {
    },
    closeFile: (mod, fileId) => {
      const file = BROWSER_RUNTIME.getFileInfo(mod, fileId);
      BROWSER_RUNTIME._fileInfoCache.delete(fileId);
      switch (file?.dataProtocol) {
        case 0 /* BUFFER */:
        case 4 /* HTTP */:
        case 5 /* S3 */:
          break;
        case 1 /* NODE_FS */:
        case 2 /* BROWSER_FILEREADER */:
          return;
        case 3 /* BROWSER_FSACCESS */: {
          const handle2 = BROWSER_RUNTIME._files?.get(file.fileName);
          if (!handle2) {
            throw new Error(`No OPFS access handle registered with name: ${file.fileName}`);
          }
          return handle2.flush();
        }
      }
    },
    truncateFile: (mod, fileId, newSize) => {
      const file = BROWSER_RUNTIME.getFileInfo(mod, fileId);
      switch (file?.dataProtocol) {
        case 4 /* HTTP */:
          failWith(mod, `Cannot truncate a http file`);
          return;
        case 5 /* S3 */:
          failWith(mod, `Cannot truncate an s3 file`);
          return;
        case 0 /* BUFFER */:
        case 1 /* NODE_FS */:
        case 2 /* BROWSER_FILEREADER */:
          failWith(mod, `truncateFile not implemented`);
          return;
        case 3 /* BROWSER_FSACCESS */: {
          const handle2 = BROWSER_RUNTIME._files?.get(file.fileName);
          if (!handle2) {
            throw new Error(`No OPFS access handle registered with name: ${file.fileName}`);
          }
          return handle2.truncate(newSize);
        }
      }
      return 0;
    },
    readFile(mod, fileId, buf, bytes, location) {
      if (bytes == 0) {
        return 0;
      }
      try {
        const file = BROWSER_RUNTIME.getFileInfo(mod, fileId);
        switch (file?.dataProtocol) {
          case 4 /* HTTP */:
          case 5 /* S3 */: {
            if (!file.dataUrl) {
              throw new Error(`Missing data URL for file ${fileId}`);
            }
            try {
              const xhr = new XMLHttpRequest();
              if (file.dataProtocol == 5 /* S3 */) {
                xhr.open("GET", getHTTPUrl(file?.s3Config, file.dataUrl), false);
                addS3Headers(xhr, file?.s3Config, file.dataUrl, "GET");
              } else {
                xhr.open("GET", file.dataUrl, false);
              }
              xhr.responseType = "arraybuffer";
              xhr.setRequestHeader("Range", `bytes=${location}-${location + bytes - 1}`);
              xhr.send(null);
              if (xhr.status == 206 || xhr.status == 200 && bytes == xhr.response.byteLength && location == 0) {
                const src = new Uint8Array(xhr.response, 0, Math.min(xhr.response.byteLength, bytes));
                mod.HEAPU8.set(src, buf);
                return src.byteLength;
              } else if (xhr.status == 200) {
                console.warn(`Range request for ${file.dataUrl} did not return a partial response: ${xhr.status} "${xhr.statusText}"`);
                const src = new Uint8Array(xhr.response, location, Math.min(xhr.response.byteLength - location, bytes));
                mod.HEAPU8.set(src, buf);
                return src.byteLength;
              } else {
                throw new Error(
                  `Range request for ${file.dataUrl} did returned non-success status: ${xhr.status} "${xhr.statusText}"`
                );
              }
            } catch (e) {
              console.log(e);
              throw new Error(`Range request for ${file.dataUrl} failed with error: ${e}"`);
            }
          }
          case 2 /* BROWSER_FILEREADER */: {
            const handle2 = BROWSER_RUNTIME._files?.get(file.fileName);
            if (!handle2) {
              throw new Error(`No HTML5 file registered with name: ${file.fileName}`);
            }
            const sliced = handle2.slice(location, location + bytes);
            const data2 = new Uint8Array(new FileReaderSync().readAsArrayBuffer(sliced));
            mod.HEAPU8.set(data2, buf);
            return data2.byteLength;
          }
          case 3 /* BROWSER_FSACCESS */: {
            const handle2 = BROWSER_RUNTIME._files?.get(file.fileName);
            if (!handle2) {
              throw new Error(`No OPFS access handle registered with name: ${file.fileName}`);
            }
            const out2 = mod.HEAPU8.subarray(buf, buf + bytes);
            return handle2.read(out2, { at: location });
          }
        }
        return 0;
      } catch (e) {
        console.log(e);
        failWith(mod, e.toString());
        return 0;
      }
    },
    writeFile: (mod, fileId, buf, bytes, location) => {
      const file = BROWSER_RUNTIME.getFileInfo(mod, fileId);
      switch (file?.dataProtocol) {
        case 4 /* HTTP */:
          failWith(mod, "Cannot write to HTTP file");
          return 0;
        case 5 /* S3 */: {
          const buffer = mod.HEAPU8.subarray(buf, buf + bytes);
          const xhr = new XMLHttpRequest();
          xhr.open("PUT", getHTTPUrl(file?.s3Config, file.dataUrl), false);
          addS3Headers(xhr, file?.s3Config, file.dataUrl, "PUT", "", buffer);
          xhr.send(buffer);
          if (xhr.status !== 200) {
            failWith(mod, "Failed writing file: HTTP " + xhr.status);
            return 0;
          }
          return bytes;
        }
        case 2 /* BROWSER_FILEREADER */:
          failWith(mod, "cannot write using the html5 file reader api");
          return 0;
        case 3 /* BROWSER_FSACCESS */: {
          const handle2 = BROWSER_RUNTIME._files?.get(file.fileName);
          if (!handle2) {
            throw new Error(`No OPFS access handle registered with name: ${file.fileName}`);
          }
          const input = mod.HEAPU8.subarray(buf, buf + bytes);
          return handle2.write(input, { at: location });
        }
      }
      return 0;
    },
    getLastFileModificationTime: (mod, fileId) => {
      const file = BROWSER_RUNTIME.getFileInfo(mod, fileId);
      switch (file?.dataProtocol) {
        case 2 /* BROWSER_FILEREADER */: {
          const handle2 = BROWSER_RUNTIME._files?.get(file.fileName);
          if (!handle2) {
            throw Error(`No handle available for file: ${file.fileName}`);
          }
          return 0;
        }
        case 4 /* HTTP */:
        case 5 /* S3 */:
          return (/* @__PURE__ */ new Date()).getTime();
      }
      return 0;
    },
    checkDirectory: (mod, pathPtr, pathLen) => {
      const path = readString(mod, pathPtr, pathLen);
      console.log(`checkDirectory: ${path}`);
      return false;
    },
    createDirectory: (mod, pathPtr, pathLen) => {
      const path = readString(mod, pathPtr, pathLen);
      console.log(`createDirectory: ${path}`);
    },
    removeDirectory: (mod, pathPtr, pathLen) => {
      const path = readString(mod, pathPtr, pathLen);
      console.log(`removeDirectory: ${path}`);
    },
    listDirectoryEntries: (mod, pathPtr, pathLen) => {
      const path = readString(mod, pathPtr, pathLen);
      console.log(`listDirectoryEntries: ${path}`);
      return false;
    },
    moveFile: (mod, fromPtr, fromLen, toPtr, toLen) => {
      const from = readString(mod, fromPtr, fromLen);
      const to = readString(mod, toPtr, toLen);
      const handle2 = BROWSER_RUNTIME._files?.get(from);
      if (handle2 !== void 0) {
        BROWSER_RUNTIME._files.delete(handle2);
        BROWSER_RUNTIME._files.set(to, handle2);
      }
      for (const [key, value] of BROWSER_RUNTIME._fileInfoCache?.entries() || []) {
        if (value.dataUrl == from) {
          BROWSER_RUNTIME._fileInfoCache.delete(key);
          break;
        }
      }
      return true;
    },
    removeFile: (_mod, _pathPtr, _pathLen) => {
    },
    callScalarUDF: (mod, response, funcId, descPtr, descSize, ptrsPtr, ptrsSize) => {
      callScalarUDF(BROWSER_RUNTIME, mod, response, funcId, descPtr, descSize, ptrsPtr, ptrsSize);
    }
  };
  var runtime_browser_default = BROWSER_RUNTIME;

  // src/bindings/bindings_browser_mvp.ts
  var import_duckdb_mvp = __toESM(require_duckdb_mvp());

  // src/bindings/bindings_browser_base.ts
  var DuckDBBrowserBindings = class extends DuckDBBindingsBase {
    /** Constructor */
    constructor(logger, runtime2, mainModuleURL, pthreadWorkerURL) {
      super(logger, runtime2);
      this.mainModuleURL = mainModuleURL;
      this.pthreadWorkerURL = pthreadWorkerURL;
    }
    /** Locate a file */
    locateFile(path, prefix) {
      if (path.endsWith(".wasm")) {
        return this.mainModuleURL;
      }
      if (path.endsWith(".worker.js")) {
        if (!this.pthreadWorkerURL) {
          throw new Error("Missing DuckDB worker URL!");
        }
        return this.pthreadWorkerURL;
      }
      throw new Error(`WASM instantiation requested unexpected file: prefix=${prefix} path=${path}`);
    }
    /** Instantiate the wasm module */
    instantiateWasm(imports, success) {
      globalThis.DUCKDB_RUNTIME = this._runtime;
      const handlers = this.onInstantiationProgress;
      if (WebAssembly.instantiateStreaming) {
        if (typeof TransformStream === "function") {
          const fetchWithProgress = async () => {
            const request = new Request(this.mainModuleURL);
            const response2 = await fetch(request);
            const contentLengthHdr = response2.headers.get("content-length");
            const contentLength = contentLengthHdr ? parseInt(contentLengthHdr, 10) || 0 : 0;
            const start2 = /* @__PURE__ */ new Date();
            const progress = {
              startedAt: start2,
              updatedAt: start2,
              bytesTotal: contentLength || 0,
              bytesLoaded: 0
            };
            const tracker = {
              transform(chunk, ctrl) {
                progress.bytesLoaded += chunk.byteLength;
                const now = /* @__PURE__ */ new Date();
                if (now.getTime() - progress.updatedAt.getTime() < 20) {
                  progress.updatedAt = now;
                  ctrl.enqueue(chunk);
                  return;
                }
                for (const p of handlers) {
                  p(progress);
                }
                ctrl.enqueue(chunk);
              }
            };
            const ts = new TransformStream(tracker);
            return new Response(response2.body?.pipeThrough(ts), response2);
          };
          const response = fetchWithProgress();
          WebAssembly.instantiateStreaming(response, imports).then((output) => {
            success(output.instance, output.module);
          });
        } else {
          console.warn("instantiating without progress handler since transform streams are unavailable");
          const request = new Request(this.mainModuleURL);
          WebAssembly.instantiateStreaming(fetch(request), imports).then((output) => {
            success(output.instance, output.module);
          });
        }
      } else if (typeof XMLHttpRequest == "function") {
        const xhr = new XMLHttpRequest();
        const url2 = this.mainModuleURL;
        const start2 = /* @__PURE__ */ new Date();
        const progress = {
          startedAt: start2,
          updatedAt: start2,
          bytesTotal: 0,
          bytesLoaded: 0
        };
        xhr.open("GET", url2);
        xhr.responseType = "arraybuffer";
        xhr.onerror = (error) => {
          this.logger.log({
            timestamp: /* @__PURE__ */ new Date(),
            level: 4 /* ERROR */,
            origin: 3 /* BINDINGS */,
            topic: 5 /* INSTANTIATE */,
            event: 2 /* ERROR */,
            value: "Failed to load WASM: " + error
          });
          throw new Error(error.toString());
        };
        xhr.onprogress = (e) => {
          progress.bytesTotal = e.total;
          progress.bytesLoaded = e.loaded;
          const now = /* @__PURE__ */ new Date();
          if (now.getTime() - progress.updatedAt.getTime() < 20) {
            progress.updatedAt = now;
            return;
          }
          for (const p of handlers) {
            p(progress);
          }
        };
        xhr.onload = () => {
          WebAssembly.instantiate(xhr.response, imports).then((output) => {
            success(output.instance, output.module);
          }).catch((error) => {
            this.logger.log({
              timestamp: /* @__PURE__ */ new Date(),
              level: 4 /* ERROR */,
              origin: 3 /* BINDINGS */,
              topic: 5 /* INSTANTIATE */,
              event: 2 /* ERROR */,
              value: "Failed to instantiate WASM: " + error
            });
            throw new Error(error);
          });
        };
        xhr.send();
      } else {
        console.warn("instantiating with manual fetch since streaming instantiation and xhrs are unavailable");
        const run2 = async () => {
          const request = new Request(this.mainModuleURL);
          const response = await fetch(request);
          const buffer = await response.arrayBuffer();
          WebAssembly.instantiate(buffer, imports).then((output) => {
            success(output.instance, output.module);
          });
        };
        run2();
      }
      return [];
    }
  };

  // src/bindings/bindings_browser_mvp.ts
  var DuckDB2 = class extends DuckDBBrowserBindings {
    /** Constructor */
    constructor(logger, runtime2, mainModuleURL, pthreadWorkerURL = null) {
      super(logger, runtime2, mainModuleURL, pthreadWorkerURL);
    }
    /** Instantiate the bindings */
    instantiateImpl(moduleOverrides2) {
      return (0, import_duckdb_mvp.default)({
        ...moduleOverrides2,
        instantiateWasm: this.instantiateWasm.bind(this),
        locateFile: this.locateFile.bind(this)
      });
    }
  };

  // src/bindings/bindings_browser_eh.ts
  var import_duckdb_eh = __toESM(require_duckdb_eh());
  var DuckDB3 = class extends DuckDBBrowserBindings {
    /** Constructor */
    constructor(logger, runtime2, mainModuleURL, pthreadWorkerURL = null) {
      super(logger, runtime2, mainModuleURL, pthreadWorkerURL);
    }
    /** Instantiate the bindings */
    instantiateImpl(moduleOverrides2) {
      return (0, import_duckdb_eh.default)({
        ...moduleOverrides2,
        instantiateWasm: this.instantiateWasm.bind(this),
        locateFile: this.locateFile.bind(this)
      });
    }
  };

  // src/targets/duckdb-browser-blocking.ts
  async function createDuckDB(bundles, logger, runtime2) {
    const platform = await getPlatformFeatures();
    if (platform.wasmExceptions) {
      if (bundles.eh) {
        return new DuckDB3(logger, runtime2, bundles.eh.mainModule);
      }
    }
    return new DuckDB2(logger, runtime2, bundles.mvp.mainModule);
  }

  // src/parallel/async_connection.ts
  var AsyncDuckDBConnection = class {
    constructor(bindings, conn) {
      this._bindings = bindings;
      this._conn = conn;
    }
    /** Access the database bindings */
    get bindings() {
      return this._bindings;
    }
    /** Disconnect from the database */
    async close() {
      return this._bindings.disconnect(this._conn);
    }
    /** Brave souls may use this function to consume the underlying connection id */
    useUnsafe(callback) {
      return callback(this._bindings, this._conn);
    }
    /** Run a query */
    async query(text) {
      this._bindings.logger.log({
        timestamp: /* @__PURE__ */ new Date(),
        level: 2 /* INFO */,
        origin: 4 /* ASYNC_DUCKDB */,
        topic: 4 /* QUERY */,
        event: 4 /* RUN */,
        value: text
      });
      const buffer = await this._bindings.runQuery(this._conn, text);
      const reader = RecordBatchReader.from(buffer);
      console.assert(reader.isSync(), "Reader is not sync");
      console.assert(reader.isFile(), "Reader is not file");
      return new Table(reader);
    }
    /** Send a query */
    async send(text) {
      this._bindings.logger.log({
        timestamp: /* @__PURE__ */ new Date(),
        level: 2 /* INFO */,
        origin: 4 /* ASYNC_DUCKDB */,
        topic: 4 /* QUERY */,
        event: 4 /* RUN */,
        value: text
      });
      let header = await this._bindings.startPendingQuery(this._conn, text);
      while (header == null) {
        header = await this._bindings.pollPendingQuery(this._conn);
      }
      const iter = new AsyncResultStreamIterator(this._bindings, this._conn, header);
      const reader = await RecordBatchReader.from(iter);
      console.assert(reader.isAsync());
      console.assert(reader.isStream());
      return reader;
    }
    /** Cancel a query that was sent earlier */
    async cancelSent() {
      return await this._bindings.cancelPendingQuery(this._conn);
    }
    /** Get table names */
    async getTableNames(query) {
      return await this._bindings.getTableNames(this._conn, query);
    }
    /** Create a prepared statement */
    async prepare(text) {
      const stmt = await this._bindings.createPrepared(this._conn, text);
      return new AsyncPreparedStatement(this._bindings, this._conn, stmt);
    }
    /** Insert an arrow table */
    async insertArrowTable(table, options) {
      const buffer = tableToIPC(table, "stream");
      await this.insertArrowFromIPCStream(buffer, options);
    }
    /** Insert an arrow table from an ipc stream */
    async insertArrowFromIPCStream(buffer, options) {
      await this._bindings.insertArrowFromIPCStream(this._conn, buffer, options);
    }
    /** Insert csv file from path */
    async insertCSVFromPath(text, options) {
      await this._bindings.insertCSVFromPath(this._conn, text, options);
    }
    /** Insert json file from path */
    async insertJSONFromPath(text, options) {
      await this._bindings.insertJSONFromPath(this._conn, text, options);
    }
  };
  var AsyncResultStreamIterator = class {
    constructor(db2, conn, header) {
      this.db = db2;
      this.conn = conn;
      this.header = header;
      this._first = true;
      this._depleted = false;
      this._inFlight = null;
    }
    async next() {
      if (this._first) {
        this._first = false;
        return { done: false, value: this.header };
      }
      if (this._depleted) {
        return { done: true, value: null };
      }
      let buffer;
      if (this._inFlight != null) {
        buffer = await this._inFlight;
        this._inFlight = null;
      } else {
        buffer = await this.db.fetchQueryResults(this.conn);
      }
      this._depleted = buffer.length == 0;
      if (!this._depleted) {
        this._inFlight = this.db.fetchQueryResults(this.conn);
      }
      return {
        done: this._depleted,
        value: buffer
      };
    }
    [Symbol.asyncIterator]() {
      return this;
    }
  };
  var AsyncPreparedStatement = class {
    /** Constructor */
    constructor(bindings, connectionId, statementId) {
      this.bindings = bindings;
      this.connectionId = connectionId;
      this.statementId = statementId;
    }
    /** Close a prepared statement */
    async close() {
      await this.bindings.closePrepared(this.connectionId, this.statementId);
    }
    /** Run a prepared statement */
    async query(...params) {
      const buffer = await this.bindings.runPrepared(this.connectionId, this.statementId, params);
      const reader = RecordBatchReader.from(buffer);
      console.assert(reader.isSync());
      console.assert(reader.isFile());
      return new Table(reader);
    }
    /** Send a prepared statement */
    async send(...params) {
      const header = await this.bindings.sendPrepared(this.connectionId, this.statementId, params);
      const iter = new AsyncResultStreamIterator(this.bindings, this.connectionId, header);
      const reader = await RecordBatchReader.from(iter);
      console.assert(reader.isAsync());
      console.assert(reader.isStream());
      return reader;
    }
  };

  // src/parallel/worker_request.ts
  var WorkerTask = class {
    constructor(type, data2) {
      this.promiseResolver = () => {
      };
      this.promiseRejecter = () => {
      };
      this.type = type;
      this.data = data2;
      this.promise = new Promise(
        (resolve, reject) => {
          this.promiseResolver = resolve;
          this.promiseRejecter = reject;
        }
      );
    }
  };

  // src/parallel/async_bindings.ts
  var TEXT_ENCODER3 = new TextEncoder();
  var AsyncDuckDB = class {
    constructor(logger, worker2 = null) {
      /** Instantiate the module */
      this._onInstantiationProgress = [];
      /** The worker */
      this._worker = null;
      /** The promise for the worker shutdown */
      this._workerShutdownPromise = null;
      /** Make the worker as terminated */
      this._workerShutdownResolver = () => {
      };
      /** The next message id */
      this._nextMessageId = 0;
      /** The pending requests */
      this._pendingRequests = /* @__PURE__ */ new Map();
      this._logger = logger;
      this._onMessageHandler = this.onMessage.bind(this);
      this._onErrorHandler = this.onError.bind(this);
      this._onCloseHandler = this.onClose.bind(this);
      if (worker2 != null)
        this.attach(worker2);
    }
    /** Get the logger */
    get logger() {
      return this._logger;
    }
    /** Attach to worker */
    attach(worker2) {
      this._worker = worker2;
      this._worker.addEventListener("message", this._onMessageHandler);
      this._worker.addEventListener("error", this._onErrorHandler);
      this._worker.addEventListener("close", this._onCloseHandler);
      this._workerShutdownPromise = new Promise(
        (resolve, _reject) => {
          this._workerShutdownResolver = resolve;
        }
      );
    }
    /** Detach from worker */
    detach() {
      if (!this._worker)
        return;
      this._worker.removeEventListener("message", this._onMessageHandler);
      this._worker.removeEventListener("error", this._onErrorHandler);
      this._worker.removeEventListener("close", this._onCloseHandler);
      this._worker = null;
      this._workerShutdownResolver(null);
      this._workerShutdownPromise = null;
      this._workerShutdownResolver = () => {
      };
    }
    /** Kill the worker */
    async terminate() {
      if (!this._worker)
        return;
      this._worker.terminate();
      this._worker = null;
      this._workerShutdownPromise = null;
      this._workerShutdownResolver = () => {
      };
    }
    /** Post a task */
    async postTask(task, transfer = []) {
      if (!this._worker) {
        console.error("cannot send a message since the worker is not set!");
        return void 0;
      }
      const mid = this._nextMessageId++;
      this._pendingRequests.set(mid, task);
      this._worker.postMessage(
        {
          messageId: mid,
          type: task.type,
          data: task.data
        },
        transfer
      );
      return await task.promise;
    }
    /** Received a message */
    onMessage(event2) {
      const response = event2.data;
      switch (response.type) {
        case "LOG" /* LOG */: {
          this._logger.log(response.data);
          return;
        }
        case "INSTANTIATE_PROGRESS" /* INSTANTIATE_PROGRESS */: {
          for (const p of this._onInstantiationProgress) {
            p(response.data);
          }
          return;
        }
      }
      const task = this._pendingRequests.get(response.requestId);
      if (!task) {
        console.warn(`unassociated response: [${response.requestId}, ${response.type.toString()}]`);
        return;
      }
      this._pendingRequests.delete(response.requestId);
      if (response.type == "ERROR" /* ERROR */) {
        const e = new Error(response.data.message);
        e.name = response.data.name;
        if (Object.getOwnPropertyDescriptor(e, "stack")?.writable) {
          e.stack = response.data.stack;
        }
        task.promiseRejecter(e);
        return;
      }
      switch (task.type) {
        case "CLOSE_PREPARED" /* CLOSE_PREPARED */:
        case "COLLECT_FILE_STATISTICS" /* COLLECT_FILE_STATISTICS */:
        case "COPY_FILE_TO_PATH" /* COPY_FILE_TO_PATH */:
        case "DISCONNECT" /* DISCONNECT */:
        case "DROP_FILE" /* DROP_FILE */:
        case "DROP_FILES" /* DROP_FILES */:
        case "FLUSH_FILES" /* FLUSH_FILES */:
        case "INSERT_ARROW_FROM_IPC_STREAM" /* INSERT_ARROW_FROM_IPC_STREAM */:
        case "IMPORT_CSV_FROM_PATH" /* INSERT_CSV_FROM_PATH */:
        case "IMPORT_JSON_FROM_PATH" /* INSERT_JSON_FROM_PATH */:
        case "OPEN" /* OPEN */:
        case "PING" /* PING */:
        case "REGISTER_FILE_BUFFER" /* REGISTER_FILE_BUFFER */:
        case "REGISTER_FILE_HANDLE" /* REGISTER_FILE_HANDLE */:
        case "REGISTER_FILE_URL" /* REGISTER_FILE_URL */:
        case "RESET" /* RESET */:
          if (response.type == "OK" /* OK */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "INSTANTIATE" /* INSTANTIATE */:
          this._onInstantiationProgress = [];
          if (response.type == "OK" /* OK */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "GLOB_FILE_INFOS" /* GLOB_FILE_INFOS */:
          if (response.type == "FILE_INFOS" /* FILE_INFOS */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "GET_VERSION" /* GET_VERSION */:
          if (response.type == "VERSION_STRING" /* VERSION_STRING */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "GET_FEATURE_FLAGS" /* GET_FEATURE_FLAGS */:
          if (response.type == "FEATURE_FLAGS" /* FEATURE_FLAGS */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "GET_TABLE_NAMES" /* GET_TABLE_NAMES */:
          if (response.type == "TABLE_NAMES" /* TABLE_NAMES */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "TOKENIZE" /* TOKENIZE */:
          if (response.type == "SCRIPT_TOKENS" /* SCRIPT_TOKENS */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "COPY_FILE_TO_BUFFER" /* COPY_FILE_TO_BUFFER */:
          if (response.type == "FILE_BUFFER" /* FILE_BUFFER */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "EXPORT_FILE_STATISTICS" /* EXPORT_FILE_STATISTICS */:
          if (response.type == "FILE_STATISTICS" /* FILE_STATISTICS */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "CONNECT" /* CONNECT */:
          if (response.type == "CONNECTION_INFO" /* CONNECTION_INFO */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "RUN_PREPARED" /* RUN_PREPARED */:
        case "RUN_QUERY" /* RUN_QUERY */:
          if (response.type == "QUERY_RESULT" /* QUERY_RESULT */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "SEND_PREPARED" /* SEND_PREPARED */:
          if (response.type == "QUERY_RESULT_HEADER" /* QUERY_RESULT_HEADER */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "START_PENDING_QUERY" /* START_PENDING_QUERY */:
          if (response.type == "QUERY_RESULT_HEADER_OR_NULL" /* QUERY_RESULT_HEADER_OR_NULL */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "POLL_PENDING_QUERY" /* POLL_PENDING_QUERY */:
          if (response.type == "QUERY_RESULT_HEADER_OR_NULL" /* QUERY_RESULT_HEADER_OR_NULL */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "CANCEL_PENDING_QUERY" /* CANCEL_PENDING_QUERY */:
          this._onInstantiationProgress = [];
          if (response.type == "SUCCESS" /* SUCCESS */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "FETCH_QUERY_RESULTS" /* FETCH_QUERY_RESULTS */:
          if (response.type == "QUERY_RESULT_CHUNK" /* QUERY_RESULT_CHUNK */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "CREATE_PREPARED" /* CREATE_PREPARED */:
          if (response.type == "PREPARED_STATEMENT_ID" /* PREPARED_STATEMENT_ID */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
      }
      task.promiseRejecter(new Error(`unexpected response type: ${response.type.toString()}`));
    }
    /** Received an error */
    onError(event2) {
      console.error(event2);
      console.error(`error in duckdb worker: ${event2.message}`);
      this._pendingRequests.clear();
    }
    /** The worker was closed */
    onClose() {
      this._workerShutdownResolver(null);
      if (this._pendingRequests.size != 0) {
        console.warn(`worker terminated with ${this._pendingRequests.size} pending requests`);
        return;
      }
      this._pendingRequests.clear();
    }
    /** Reset the duckdb */
    async reset() {
      const task = new WorkerTask("RESET" /* RESET */, null);
      return await this.postTask(task);
    }
    /** Ping the worker thread */
    async ping() {
      const task = new WorkerTask("PING" /* PING */, null);
      await this.postTask(task);
    }
    /** Try to drop a file */
    async dropFile(name2) {
      const task = new WorkerTask("DROP_FILE" /* DROP_FILE */, name2);
      return await this.postTask(task);
    }
    /** Try to drop files */
    async dropFiles() {
      const task = new WorkerTask("DROP_FILES" /* DROP_FILES */, null);
      return await this.postTask(task);
    }
    /** Flush all files */
    async flushFiles() {
      const task = new WorkerTask("FLUSH_FILES" /* FLUSH_FILES */, null);
      return await this.postTask(task);
    }
    /** Open the database */
    async instantiate(mainModuleURL, pthreadWorkerURL = null, progress = (_p2) => {
    }) {
      this._onInstantiationProgress.push(progress);
      const task = new WorkerTask(
        "INSTANTIATE" /* INSTANTIATE */,
        [mainModuleURL, pthreadWorkerURL]
      );
      return await this.postTask(task);
    }
    /** Get the version */
    async getVersion() {
      const task = new WorkerTask("GET_VERSION" /* GET_VERSION */, null);
      const version = await this.postTask(task);
      return version;
    }
    /** Get the feature flags */
    async getFeatureFlags() {
      const task = new WorkerTask(
        "GET_FEATURE_FLAGS" /* GET_FEATURE_FLAGS */,
        null
      );
      const feature = await this.postTask(task);
      return feature;
    }
    /** Open a new database */
    async open(config) {
      const task = new WorkerTask("OPEN" /* OPEN */, config);
      await this.postTask(task);
    }
    /** Tokenize a script text */
    async tokenize(text) {
      const task = new WorkerTask("TOKENIZE" /* TOKENIZE */, text);
      const tokens = await this.postTask(task);
      return tokens;
    }
    /** Connect to the database */
    async connectInternal() {
      const task = new WorkerTask("CONNECT" /* CONNECT */, null);
      return await this.postTask(task);
    }
    /** Connect to the database */
    async connect() {
      const cid = await this.connectInternal();
      return new AsyncDuckDBConnection(this, cid);
    }
    /** Disconnect from the database */
    async disconnect(conn) {
      const task = new WorkerTask(
        "DISCONNECT" /* DISCONNECT */,
        conn
      );
      await this.postTask(task);
    }
    /** Run a query */
    async runQuery(conn, text) {
      const task = new WorkerTask(
        "RUN_QUERY" /* RUN_QUERY */,
        [conn, text]
      );
      return await this.postTask(task);
    }
    /** Start a pending query */
    async startPendingQuery(conn, text) {
      const task = new WorkerTask(
        "START_PENDING_QUERY" /* START_PENDING_QUERY */,
        [conn, text]
      );
      return await this.postTask(task);
    }
    /** Poll a pending query */
    async pollPendingQuery(conn) {
      const task = new WorkerTask(
        "POLL_PENDING_QUERY" /* POLL_PENDING_QUERY */,
        conn
      );
      return await this.postTask(task);
    }
    /** Cancel a pending query */
    async cancelPendingQuery(conn) {
      const task = new WorkerTask(
        "CANCEL_PENDING_QUERY" /* CANCEL_PENDING_QUERY */,
        conn
      );
      return await this.postTask(task);
    }
    /** Fetch query results */
    async fetchQueryResults(conn) {
      const task = new WorkerTask(
        "FETCH_QUERY_RESULTS" /* FETCH_QUERY_RESULTS */,
        conn
      );
      return await this.postTask(task);
    }
    /** Get table names */
    async getTableNames(conn, text) {
      const task = new WorkerTask(
        "GET_TABLE_NAMES" /* GET_TABLE_NAMES */,
        [conn, text]
      );
      return await this.postTask(task);
    }
    /** Prepare a statement and return its identifier */
    async createPrepared(conn, text) {
      const task = new WorkerTask(
        "CREATE_PREPARED" /* CREATE_PREPARED */,
        [conn, text]
      );
      return await this.postTask(task);
    }
    /** Close a prepared statement */
    async closePrepared(conn, statement) {
      const task = new WorkerTask(
        "CLOSE_PREPARED" /* CLOSE_PREPARED */,
        [conn, statement]
      );
      await this.postTask(task);
    }
    /** Execute a prepared statement and return the full result */
    async runPrepared(conn, statement, params) {
      const task = new WorkerTask(
        "RUN_PREPARED" /* RUN_PREPARED */,
        [conn, statement, params]
      );
      return await this.postTask(task);
    }
    /** Execute a prepared statement and stream the result */
    async sendPrepared(conn, statement, params) {
      const task = new WorkerTask(
        "SEND_PREPARED" /* SEND_PREPARED */,
        [conn, statement, params]
      );
      return await this.postTask(task);
    }
    /** Glob file infos */
    async globFiles(path) {
      const task = new WorkerTask(
        "GLOB_FILE_INFOS" /* GLOB_FILE_INFOS */,
        path
      );
      return await this.postTask(task);
    }
    /** Register file text */
    async registerFileText(name2, text) {
      const buffer = TEXT_ENCODER3.encode(text);
      await this.registerFileBuffer(name2, buffer);
    }
    /** Register a file path. */
    async registerFileURL(name2, url2, proto, directIO) {
      if (url2 === void 0) {
        url2 = name2;
      }
      const task = new WorkerTask("REGISTER_FILE_URL" /* REGISTER_FILE_URL */, [name2, url2, proto, directIO]);
      await this.postTask(task);
    }
    /** Register an empty file buffer. */
    async registerEmptyFileBuffer(name2) {
      const task = new WorkerTask(
        "REGISTER_FILE_BUFFER" /* REGISTER_FILE_BUFFER */,
        [name2, new Uint8Array()]
      );
      await this.postTask(task);
    }
    /** Register a file buffer. */
    async registerFileBuffer(name2, buffer) {
      const task = new WorkerTask(
        "REGISTER_FILE_BUFFER" /* REGISTER_FILE_BUFFER */,
        [name2, buffer]
      );
      await this.postTask(task, [buffer.buffer]);
    }
    /** Register a file handle. */
    async registerFileHandle(name2, handle2, protocol, directIO) {
      const task = new WorkerTask("REGISTER_FILE_HANDLE" /* REGISTER_FILE_HANDLE */, [name2, handle2, protocol, directIO]);
      await this.postTask(task, []);
    }
    /** Enable file statistics */
    async collectFileStatistics(name2, enable) {
      const task = new WorkerTask(
        "COLLECT_FILE_STATISTICS" /* COLLECT_FILE_STATISTICS */,
        [name2, enable]
      );
      await this.postTask(task, []);
    }
    /** Export file statistics */
    async exportFileStatistics(name2) {
      const task = new WorkerTask(
        "EXPORT_FILE_STATISTICS" /* EXPORT_FILE_STATISTICS */,
        name2
      );
      return await this.postTask(task, []);
    }
    /** Copy a file to a buffer. */
    async copyFileToBuffer(name2) {
      const task = new WorkerTask(
        "COPY_FILE_TO_BUFFER" /* COPY_FILE_TO_BUFFER */,
        name2
      );
      return await this.postTask(task);
    }
    /** Copy a file to a path. */
    async copyFileToPath(name2, path) {
      const task = new WorkerTask(
        "COPY_FILE_TO_PATH" /* COPY_FILE_TO_PATH */,
        [name2, path]
      );
      await this.postTask(task);
    }
    /** Insert arrow from an ipc stream */
    async insertArrowFromIPCStream(conn, buffer, options) {
      if (buffer.length == 0)
        return;
      const task = new WorkerTask("INSERT_ARROW_FROM_IPC_STREAM" /* INSERT_ARROW_FROM_IPC_STREAM */, [conn, buffer, options]);
      await this.postTask(task, [buffer.buffer]);
    }
    /** Insert a csv file */
    async insertCSVFromPath(conn, path, options) {
      if (options.columns !== void 0) {
        const out2 = [];
        for (const k in options.columns) {
          const type = options.columns[k];
          out2.push(arrowToSQLField(k, type));
        }
        options.columnsFlat = out2;
        delete options.columns;
      }
      const task = new WorkerTask(
        "IMPORT_CSV_FROM_PATH" /* INSERT_CSV_FROM_PATH */,
        [conn, path, options]
      );
      await this.postTask(task);
    }
    /** Insert a json file */
    async insertJSONFromPath(conn, path, options) {
      if (options.columns !== void 0) {
        const out2 = [];
        for (const k in options.columns) {
          const type = options.columns[k];
          out2.push(arrowToSQLField(k, type));
        }
        options.columnsFlat = out2;
        delete options.columns;
      }
      const task = new WorkerTask(
        "IMPORT_JSON_FROM_PATH" /* INSERT_JSON_FROM_PATH */,
        [conn, path, options]
      );
      await this.postTask(task);
    }
  };

  // src/worker.ts
  var import_web_worker = __toESM(require_browser2());
  async function createWorker(url2) {
    const request = new Request(url2);
    const workerScript = await fetch(request);
    const workerURL = URL.createObjectURL(await workerScript.blob());
    return new import_web_worker.default(workerURL);
  }

  // test/all_types.test.ts
  var MINIMUM_DATE_STR = "-271821-04-20";
  var MINIMUM_DATE = new Date(Date.UTC(-271821, 3, 20));
  var MAXIMUM_DATE_STR = "275760-09-13";
  var MAXIMUM_DATE = new Date(Date.UTC(275760, 8, 13));
  var NOT_IMPLEMENTED_TYPES = [
    "timestamp_s",
    "timestamp_ms",
    "timestamp_ns",
    "time_tz",
    "timestamp_tz",
    "hugeint",
    "dec_18_6",
    "dec38_10",
    "uuid",
    "map",
    "json",
    "date_array",
    "timestamp_array",
    "timestamptz_array"
  ];
  var PARTIALLY_IMPLEMENTED_TYPES = ["date", "timestamp"];
  var PARTIALLY_IMPLEMENTED_ANSWER_MAP = {
    date: [MINIMUM_DATE.valueOf(), MAXIMUM_DATE.valueOf(), null],
    timestamp: [MINIMUM_DATE.valueOf(), MAXIMUM_DATE.valueOf(), null]
  };
  var PARTIALLY_IMPLEMENTED_TYPES_SUBSTITUTIONS = [
    `(SELECT array_extract(['${MINIMUM_DATE_STR}'::Date,'${MAXIMUM_DATE_STR}'::Date,null],i + 1)) as date`,
    `(SELECT array_extract(['${MINIMUM_DATE_STR}'::Timestamp,'${MAXIMUM_DATE_STR}'::Timestamp,null],i + 1)) as timestamp`
  ];
  var TYPES_REQUIRING_CUSTOM_CONFIG = ["dec_4_1", "dec_9_4"];
  var FULLY_IMPLEMENTED_ANSWER_MAP = {
    bool: [false, true, null],
    tinyint: [-128, 127, null],
    smallint: [-32768, 32767, null],
    int: [-2147483648, 2147483647, null],
    utinyint: [0, 255, null],
    usmallint: [0, 65535, null],
    uint: [0, 4294967295, null],
    ubigint: [BigInt(0), BigInt("18446744073709551615"), null],
    bigint: [BigInt("-9223372036854775808"), BigInt("9223372036854775807"), null],
    // Note that we multiply by thousand (and add 999 for the max) because the value returned by DuckDB is in microseconds,
    // whereas the Date object is in milliseconds.
    time: [BigInt(0), BigInt((/* @__PURE__ */ new Date("1970-01-01T23:59:59.999+00:00")).valueOf()) * BigInt(1e3) + BigInt(999), null],
    interval: [new Int32Array([0, 0]), new Int32Array([0, 0]), null],
    float: [-34028234663852886e22, 34028234663852886e22, null],
    double: [-17976931348623157e292, 17976931348623157e292, null],
    varchar: ["\u{1F986}\u{1F986}\u{1F986}\u{1F986}\u{1F986}\u{1F986}", "goo\0se", null],
    small_enum: ["DUCK_DUCK_ENUM", "GOOSE", null],
    medium_enum: ["enum_0", "enum_299", null],
    large_enum: ["enum_0", "enum_69999", null],
    int_array: [[], [42, 999, null, null, -42], null],
    double_array: [[], [42, NaN, Infinity, -Infinity, null, -42], null],
    varchar_array: [[], ["\u{1F986}\u{1F986}\u{1F986}\u{1F986}\u{1F986}\u{1F986}", "goose", null, ""], null],
    nested_int_array: [[], [[], [42, 999, null, null, -42], null, [], [42, 999, null, null, -42]], null],
    struct: ['{"a":null,"b":null}', '{"a":42,"b":"\u{1F986}\u{1F986}\u{1F986}\u{1F986}\u{1F986}\u{1F986}"}', null],
    struct_of_arrays: [
      '{"a":null,"b":null}',
      '{"a":[42,999,null,null,-42],"b":["\u{1F986}\u{1F986}\u{1F986}\u{1F986}\u{1F986}\u{1F986}","goose",null,""]}',
      null
    ],
    array_of_structs: [[], ['{"a":null,"b":null}', '{"a":42,"b":"\u{1F986}\u{1F986}\u{1F986}\u{1F986}\u{1F986}\u{1F986}"}', null], null],
    // XXX sometimes throws
    // map: ['{}', '{"key1":"","key2":"goose"}', null],
    blob: [
      Uint8Array.from([
        116,
        104,
        105,
        115,
        105,
        115,
        97,
        108,
        111,
        110,
        103,
        98,
        108,
        111,
        98,
        0,
        119,
        105,
        116,
        104,
        110,
        117,
        108,
        108,
        98,
        121,
        116,
        101,
        115
      ]),
      Uint8Array.from([0, 0, 0, 97]),
      null
    ],
    union: ["Frank", 5, null]
  };
  var REPLACE_COLUMNS = PARTIALLY_IMPLEMENTED_TYPES.concat(NOT_IMPLEMENTED_TYPES).concat(TYPES_REQUIRING_CUSTOM_CONFIG);
  function unpack(v) {
    if (v === null)
      return null;
    if (v instanceof Vector) {
      const ret = Array.from(v.toArray());
      for (let i2 = 0; i2 < ret.length; i2++) {
        if (!v.isValid(i2)) {
          ret[i2] = null;
        }
      }
      return unpack(ret);
    } else if (v instanceof Array) {
      const ret = [];
      for (let i2 = 0; i2 < v.length; i2++) {
        ret[i2] = unpack(v[i2]);
      }
      return ret;
    } else if (v instanceof Uint8Array) {
      return v;
    } else if (v.toJSON instanceof Function) {
      return JSON.stringify(v.toJSON());
    }
    return v;
  }
  function getValue2(x) {
    if (typeof x?.valueOf === "function") {
      return x.valueOf();
    } else {
      return x;
    }
  }
  var ALL_TYPES_TEST = [
    {
      name: "fully supported types",
      query: `SELECT * REPLACE('not_implemented' as map) FROM test_all_types()`,
      skip: REPLACE_COLUMNS,
      answerMap: FULLY_IMPLEMENTED_ANSWER_MAP,
      answerCount: REPLACE_COLUMNS.length + Object.keys(FULLY_IMPLEMENTED_ANSWER_MAP).length,
      queryConfig: null
    },
    {
      name: "partially supported types",
      query: `SELECT ${PARTIALLY_IMPLEMENTED_TYPES_SUBSTITUTIONS.join(", ")}
                FROM range(0, 3) tbl(i)`,
      skip: [],
      answerMap: PARTIALLY_IMPLEMENTED_ANSWER_MAP,
      answerCount: PARTIALLY_IMPLEMENTED_TYPES.length,
      queryConfig: null
    },
    {
      name: "types with custom config",
      query: `SELECT ${TYPES_REQUIRING_CUSTOM_CONFIG.join(",")} FROM test_all_types()`,
      skip: [],
      answerMap: {
        dec_4_1: [-999.9000000000001, 999.9000000000001, null],
        dec_9_4: [-99999.99990000001, 99999.99990000001, null]
      },
      answerCount: TYPES_REQUIRING_CUSTOM_CONFIG.length,
      queryConfig: {
        castDecimalToDouble: true
      }
    }
  ];
  function testAllTypes(db2) {
    let conn;
    beforeEach(() => {
      db2().flushFiles();
    });
    afterEach(() => {
      if (conn) {
        conn.close();
        conn = null;
      }
      db2().flushFiles();
      db2().dropFiles();
    });
    describe("Test All Types", () => {
      for (const test of ALL_TYPES_TEST) {
        it(test.name, () => {
          if (test.queryConfig)
            db2().open({ query: test.queryConfig });
          conn = db2().connect();
          const results = conn.query(test.query);
          expect(results.numCols).toEqual(test.answerCount);
          const skip = /* @__PURE__ */ new Map();
          for (const s2 of test.skip) {
            skip.set(s2, true);
          }
          for (let i2 = 0; i2 < results.numCols; i2++) {
            const name2 = results.schema.fields[i2].name;
            if (name2 == "bit")
              continue;
            const col = results.getChildAt(i2);
            if (skip.get(name2))
              continue;
            expect(col).not.toBeNull();
            expect(col?.length).not.toEqual(0);
            expect(unpack(getValue2(col.get(0)))).withContext(name2).toEqual(test.answerMap[name2][0]);
            expect(unpack(getValue2(col.get(1)))).withContext(name2).toEqual(test.answerMap[name2][1]);
            expect(col.get(2)).withContext(name2).toEqual(test.answerMap[name2][2]);
          }
        });
      }
    });
  }
  function testAllTypesAsync(db2) {
    let conn = null;
    beforeEach(async () => {
      await db2().flushFiles();
    });
    afterEach(async () => {
      if (conn) {
        await conn.close();
        conn = null;
      }
      await db2().flushFiles();
      await db2().dropFiles();
    });
    describe("Test All Types Async", () => {
      for (const test of ALL_TYPES_TEST) {
        it(test.name, async () => {
          if (test.queryConfig)
            db2().open({ query: test.queryConfig });
          conn = await db2().connect();
          const results = await conn.query(test.query);
          expect(results.numCols).toEqual(test.answerCount);
          const skip = /* @__PURE__ */ new Map();
          for (const s2 of test.skip) {
            skip.set(s2, true);
          }
          for (let i2 = 0; i2 < results.numCols; i2++) {
            const name2 = results.schema.fields[i2].name;
            if (name2 == "bit")
              continue;
            const col = results.getChildAt(i2);
            if (skip.get(name2))
              continue;
            expect(col).not.toBeNull();
            expect(col?.length).not.toEqual(0);
            expect(Object.keys(test.answerMap)).toContain(name2);
            expect(unpack(getValue2(col.get(0)))).withContext(name2 + "|" + col?.toString() + "|[0]").toEqual(test.answerMap[name2][0]);
            expect(unpack(getValue2(col.get(1)))).withContext(name2 + "|" + col?.toString() + "|[1]").toEqual(test.answerMap[name2][1]);
            expect(col.get(2)).withContext(name2 + "|" + col?.toString() + "|[2]").toEqual(test.answerMap[name2][2]);
          }
        });
      }
    });
  }

  // test/httpfs_test.ts
  var BUCKET_NAME = "test-bucket";
  var ACCESS_KEY_ID = "S3RVER";
  var ACCESS_KEY_SECRET = "S3RVER";
  var S3_ENDPOINT = "http://localhost:4923";
  var S3_REGION = "eu-west-1";
  var setAwsConfig = async function(conn, type = 1 /* VALID */) {
    switch (type) {
      case 0 /* EMPTY */:
        await conn.query("SET s3_region='';");
        await conn.query("SET s3_access_key_id='';");
        await conn.query("SET s3_secret_access_key='';");
        await conn.query("SET s3_session_token='';");
        await conn.query(`SET s3_endpoint='${S3_ENDPOINT}';`);
        break;
      case 1 /* VALID */:
        await conn.query(`SET s3_region='${S3_REGION}';`);
        await conn.query(`SET s3_access_key_id='${ACCESS_KEY_ID}';`);
        await conn.query(`SET s3_secret_access_key='${ACCESS_KEY_SECRET}';`);
        await conn.query("SET s3_session_token='';");
        await conn.query(`SET s3_endpoint='${S3_ENDPOINT}';`);
        break;
      case 2 /* INVALID */:
        await conn.query("SET s3_region='a-very-remote-and-non-existent-s3-region';");
        await conn.query("SET s3_access_key_id='THISACCESSKEYIDISNOTVALID';");
        await conn.query("SET s3_secret_access_key='THISSECRETACCESSKEYISNOTVALID';");
        await conn.query("SET s3_session_token='INVALIDSESSIONTOKEN';");
        await conn.query(`SET s3_endpoint='${S3_ENDPOINT}';`);
        break;
    }
  };
  function testHTTPFS(sdb) {
    let conn;
    const getModule = function() {
      let module2 = null;
      conn.useUnsafe((bindings, con_number) => {
        module2 = bindings.mod;
      });
      expect(module2).toBeDefined();
      return module2;
    };
    const reset = async () => {
      sdb().reset();
      conn = sdb().connect();
    };
    beforeEach(async () => await reset());
    afterEach(async () => await reset());
    describe("HTTPFS", () => {
      it("s3 config is set correctly", async () => {
        const module2 = getModule();
        const globalFileInfo = runtime_browser_default.getGlobalFileInfo(module2);
        const cacheEpoch = globalFileInfo.cacheEpoch;
        expect(globalFileInfo?.s3Config).toBeDefined();
        expect(globalFileInfo?.s3Config?.region).toEqual("");
        expect(globalFileInfo?.s3Config?.accessKeyId).toEqual("");
        expect(globalFileInfo?.s3Config?.secretAccessKey).toEqual("");
        expect(globalFileInfo?.s3Config?.sessionToken).toEqual("");
        expect(globalFileInfo?.s3Config?.endpoint).toEqual("");
        conn.query("SET s3_region='a-very-remote-and-non-existent-s3-region';");
        conn.query("SET s3_access_key_id='THISACCESSKEYIDISNOTVALID';");
        conn.query("SET s3_secret_access_key='THISSECRETACCESSKEYISNOTVALID';");
        conn.query("SET s3_session_token='ANICESESSIONTOKEN';");
        conn.query("SET s3_endpoint='s3.some.sort.of.cloud';");
        const globalFileInfoUpdated = runtime_browser_default.getGlobalFileInfo(module2);
        expect(globalFileInfoUpdated?.s3Config).toBeDefined();
        expect(globalFileInfoUpdated?.cacheEpoch).toEqual(cacheEpoch + 5);
        const params = getS3Params(globalFileInfoUpdated?.s3Config, "s3://test-bucket/testfile.txt", "GET");
        expect(params.url).toEqual("/testfile.txt");
        expect(params.query).toEqual("");
        expect(params.host).toEqual("test-bucket.s3.some.sort.of.cloud");
        expect(params.region).toEqual("a-very-remote-and-non-existent-s3-region");
        expect(params.service).toEqual("s3");
        expect(params.method).toEqual("GET");
        expect(params.accessKeyId).toEqual("THISACCESSKEYIDISNOTVALID");
        expect(params.secretAccessKey).toEqual("THISSECRETACCESSKEYISNOTVALID");
        expect(params.sessionToken).toEqual("ANICESESSIONTOKEN");
        conn.query("SET s3_endpoint='http://localhost:1337';");
        const globalFileInfoFullHttpEndpoint = runtime_browser_default.getGlobalFileInfo(module2);
        const paramsFullHttpEndpoint = getS3Params(
          globalFileInfoFullHttpEndpoint?.s3Config,
          "s3://test-bucket/testfile.txt",
          "GET"
        );
        expect(paramsFullHttpEndpoint.host).toEqual("localhost:1337");
        await reset();
        const globalFileInfoCleared = runtime_browser_default.getGlobalFileInfo(module2);
        const paramsCleared = getS3Params(globalFileInfoCleared?.s3Config, "s3://test-bucket/testfile.txt", "GET");
        expect(paramsCleared.url).toEqual("/testfile.txt");
        expect(paramsCleared.query).toEqual("");
        expect(paramsCleared.host).toEqual("test-bucket.s3.amazonaws.com");
        expect(paramsCleared.region).toEqual("");
        expect(paramsCleared.service).toEqual("s3");
        expect(paramsCleared.method).toEqual("GET");
        expect(paramsCleared.accessKeyId).toEqual("");
        expect(paramsCleared.secretAccessKey).toEqual("");
        expect(paramsCleared.sessionToken).toEqual("");
      });
      it("url parsing is correct", () => {
        const module2 = getModule();
        conn.query("SET s3_endpoint='';");
        const globalFileInfoDefault = runtime_browser_default.getGlobalFileInfo(module2);
        expect(globalFileInfoDefault?.s3Config).toBeDefined();
        const defaultUrl = getHTTPUrl(globalFileInfoDefault?.s3Config, `s3://${BUCKET_NAME}/test-file.csv`);
        expect(defaultUrl).toEqual(`https://${BUCKET_NAME}.s3.amazonaws.com/test-file.csv`);
        conn.query("SET s3_endpoint='https://duckdblabs.com';");
        const globalFileInfoFullUrl = runtime_browser_default.getGlobalFileInfo(module2);
        expect(globalFileInfoFullUrl?.s3Config).toBeDefined();
        const fullUrl = getHTTPUrl(globalFileInfoFullUrl?.s3Config, `s3://${BUCKET_NAME}/test-file.csv`);
        expect(fullUrl).toEqual(`https://duckdblabs.com/${BUCKET_NAME}/test-file.csv`);
        conn.query("SET s3_endpoint='duckdblabs.com';");
        const globalFileInfoDomain = runtime_browser_default.getGlobalFileInfo(module2);
        expect(globalFileInfoDomain?.s3Config).toBeDefined();
        const domainOnlyUrl = getHTTPUrl(globalFileInfoDomain?.s3Config, `s3://${BUCKET_NAME}/test-file.csv`);
        expect(domainOnlyUrl).toEqual(`https://${BUCKET_NAME}.duckdblabs.com/test-file.csv`);
      });
      it("s3 helper passes validation", () => {
        const testParams1 = {
          url: "/",
          query: "",
          host: "my-precious-bucket.s3.amazonaws.com",
          region: "us-east-1",
          service: "s3",
          method: "GET",
          accessKeyId: "AKIAIOSFODNN7EXAMPLE",
          secretAccessKey: "wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY",
          sessionToken: "",
          dateNow: "20150915",
          datetimeNow: "20150915T124500Z"
        };
        const result = createS3Headers(testParams1).get("Authorization");
        expect(result).toEqual(
          "AWS4-HMAC-SHA256 Credential=AKIAIOSFODNN7EXAMPLE/20150915/us-east-1/s3/aws4_request, SignedHeaders=host;x-amz-content-sha256;x-amz-date, Signature=182072eb53d85c36b2d791a1fa46a12d23454ec1e921b02075c23aee40166d5a"
        );
        const canonical_query_string = "delimiter=%2F&encoding-type=url&list-type=2&prefix=";
        const testParams2 = {
          url: "/",
          query: canonical_query_string,
          host: "my-precious-bucket.s3.eu-west-1.amazonaws.com",
          region: "eu-west-1",
          service: "s3",
          method: "GET",
          accessKeyId: "ASIAYSPIOYDTHTBIITVC",
          secretAccessKey: "vs1BZPxSL2qVARBSg5vCMKJsavCoEPlo/HSHRaVe",
          sessionToken: "IQoJb3JpZ2luX2VjENX//////////wEaCWV1LXdlc3QtMSJHMEUCIQDfjzs9BYHrEXDMU/NR+PHV1uSTr7CSVSQdjKSfiPRLdgIgCCztF0VMbi9+uHHAfBVKhV4t9MlUrQg3VAOIsLxrWyoqlAIIHRAAGgw1ODk0MzQ4OTY2MTQiDOGl2DsYxENcKCbh+irxARe91faI+hwUhT60sMGRFg0GWefKnPclH4uRFzczrDOcJlAAaQRJ7KOsT8BrJlrY1jSgjkO7PkVjPp92vi6lJX77bg99MkUTJActiOKmd84XvAE5bFc/jFbqechtBjXzopAPkKsGuaqAhCenXnFt6cwq+LZikv/NJGVw7TRphLV+Aq9PSL9XwdzIgsW2qXwe1c3rxDNj53yStRZHVggdxJ0OgHx5v040c98gFphzSULHyg0OY6wmCMTYcswpb4kO2IIi6AiD9cY25TlwPKRKPi5CdBsTPnyTeW62u7PvwK0fTSy4ZuJUuGKQnH2cKmCXquEwoOHEiQY6nQH9fzY/EDGHMRxWWhxu0HiqIfsuFqC7GS0p0ToKQE+pzNsvVwMjZc+KILIDDQpdCWRIwu53I5PZy2Cvk+3y4XLvdZKQCsAKqeOc4c94UAS4NmUT7mCDOuRV0cLBVM8F0JYBGrUxyI+YoIvHhQWmnRLuKgTb5PkF7ZWrXBHFWG5/tZDOvBbbaCWTlRCL9b0Vpg5+BM/81xd8jChP4w83",
          dateNow: "20210904",
          datetimeNow: "20210904T121746Z"
        };
        const result2 = createS3Headers(testParams2).get("Authorization");
        expect(result2).toEqual(
          "AWS4-HMAC-SHA256 Credential=ASIAYSPIOYDTHTBIITVC/20210904/eu-west-1/s3/aws4_request, SignedHeaders=host;x-amz-content-sha256;x-amz-date;x-amz-security-token, Signature=4d9d6b59d7836b6485f6ad822de97be40287da30347d83042ea7fbed530dc4c0"
        );
        const testParams3 = {
          url: "/correct_auth_test.csv",
          query: "",
          host: "test-bucket-ceiveran.s3.amazonaws.com",
          region: "eu-west-1",
          service: "s3",
          method: "PUT",
          accessKeyId: "S3RVER",
          secretAccessKey: "S3RVER",
          sessionToken: "",
          dateNow: "20220121",
          datetimeNow: "20220121T141452Z"
        };
        const test3PayloadParams = {
          contentHash: "28a0cf6ac5c4cb73793091fe6ecc6a68bf90855ac9186158748158f50241bb0c",
          contentType: "text/data;charset=utf-8"
        };
        const result3 = createS3Headers(testParams3, test3PayloadParams).get("Authorization");
        expect(result3).toEqual(
          "AWS4-HMAC-SHA256 Credential=S3RVER/20220121/eu-west-1/s3/aws4_request, SignedHeaders=content-type;host;x-amz-content-sha256;x-amz-date, Signature=5d9a6cbfaa78a6d0f2ab7df0445e2f1cc9c80cd3655ac7de9e7219c036f23f02"
        );
        expect(uriEncode("/category=Books/")).toEqual("/category%3DBooks/");
        expect(uriEncode("/?category=Books&title=Ducks Retreat/")).toEqual(
          "/%3Fcategory%3DBooks%26title%3DDucks%20Retreat/"
        );
        expect(uriEncode("/?category=Books&title=Ducks Retreat/", true)).toEqual(
          "%2F%3Fcategory%3DBooks%26title%3DDucks%20Retreat%2F"
        );
      });
    });
  }
  function testHTTPFSAsync(adb2, resolveData2, baseDir) {
    let conn;
    const putTestFileToS3 = async function(fileName, format, test_data) {
      await adb2().registerFileBuffer("test_file.parquet", test_data);
      if (!conn) {
        conn = await adb2().connect();
      }
      await setAwsConfig(conn, 1 /* VALID */);
      await conn.query(`CREATE TABLE test_table AS (SELECT * FROM parquet_scan('test_file.parquet'));`);
      await conn.query(`COPY test_table TO 's3://${BUCKET_NAME}/${fileName}.${format}' (FORMAT '${format}');`);
      await adb2().flushFiles();
      await adb2().dropFiles();
    };
    const assertTestFileResultCorrect = async function(result, test_data) {
      await adb2().registerFileBuffer("test_file_baseline.parquet", test_data);
      await conn.query(`SELECT * FROM parquet_scan('test_file_baseline.parquet');`);
    };
    const reset = async () => {
      await adb2().reset();
      conn = await adb2().connect();
    };
    beforeEach(async () => await reset());
    afterEach(async () => await reset());
    describe("HTTPFS Async", () => {
      it("can fetch https file", async () => {
        const results = await conn.query(
          `select * from "https://raw.githubusercontent.com/duckdb/duckdb-wasm/main/data/test.csv";`
        );
        expect(BigInt(results.getChildAt(2)?.get(2))).toEqual(BigInt(9n));
      });
      it("can read and write csv file from S3 with correct auth credentials", async () => {
        let data2 = await resolveData2("/uni/studenten.parquet");
        await setAwsConfig(conn);
        await putTestFileToS3("correct_auth_test", "csv", data2);
        const results_with_auth = await conn.query(`select * from "s3://${BUCKET_NAME}/correct_auth_test.csv";`);
        data2 = await resolveData2("/uni/studenten.parquet");
        assertTestFileResultCorrect(results_with_auth, data2);
      });
      it("can read and write parquet file from S3 with correct auth credentials", async () => {
        let data2 = await resolveData2("/uni/studenten.parquet");
        await putTestFileToS3("correct_auth_test", "parquet", data2);
        await setAwsConfig(conn);
        const results_with_auth = await conn.query(
          `select * from "s3://${BUCKET_NAME}/correct_auth_test.parquet";`
        );
        data2 = await resolveData2("/uni/studenten.parquet");
        assertTestFileResultCorrect(results_with_auth, data2);
      });
      it("can not read a file with incorrect credentials", async () => {
        const data2 = await resolveData2("/uni/studenten.parquet");
        await putTestFileToS3("incorrect_auth_test", "parquet", data2);
        await setAwsConfig(conn, 2 /* INVALID */);
        await expectAsync(
          conn.query(`select * from "s3://${BUCKET_NAME}/incorrect_auth_test.csv";`)
        ).toBeRejected();
      });
      it("properly invalidates file caches on settings update.", async () => {
        const data2 = await resolveData2("/tpch/0_01/parquet/lineitem.parquet");
        await putTestFileToS3("file_cache_invalidation_test", "parquet", data2);
        await setAwsConfig(conn);
        const results_correct = await conn.query(
          `select l_partkey from "s3://${BUCKET_NAME}/file_cache_invalidation_test.parquet" limit 1;`
        );
        expect(results_correct.getChildAt(0)?.get(0)).toEqual(1552);
        await setAwsConfig(conn, 2 /* INVALID */);
        await expectAsync(
          conn.query(`select avg(l_partkey) from "s3://${BUCKET_NAME}/lineitem.parquet";`)
        ).toBeRejected();
      });
      it("write after read throws incorrect flag error without dropping files", async () => {
        await setAwsConfig(conn);
        await conn.query(
          `COPY (SELECT * FROM range(1000,1010) tbl(i)) TO 's3://${BUCKET_NAME}/test_written.csv' (FORMAT 'csv');`
        );
        const result = await conn.query(`SELECT * FROM "s3://${BUCKET_NAME}/test_written.csv";`);
        expect(Number(result.getChildAt(0)?.get(6))).toEqual(Number(1006));
        await expectAsync(
          conn.query(
            `COPY (SELECT * FROM range(2000,2010) tbl(i)) TO 's3://${BUCKET_NAME}/test_written.csv' (FORMAT 'csv');`
          )
        ).toBeRejectedWithError("Invalid Error: File is not opened in write mode");
      });
    });
  }

  // test/bindings.test.ts
  function testBindings(db2, baseURL2) {
    let conn;
    beforeEach(() => {
      conn = db2().connect();
    });
    afterEach(() => {
      conn.close();
      db2().flushFiles();
      db2().dropFiles();
    });
    describe("DuckDBBindings", () => {
      describe("error handling", () => {
        it("INVALID SQL", async () => {
          let error = null;
          try {
            await conn.send("INVALID");
          } catch (e) {
            error = e;
          }
          expect(error).not.toBe(null);
        });
      });
      describe("Check version", () => {
        it("Version check", async () => {
          await db2().reset();
          conn = db2().connect();
          const version = conn.query(
            "select * from (select version()) where version() != 'v0.0.1-dev0';"
          );
          const rows = version.toArray();
          expect(rows.length).toEqual(1);
          await db2().reset();
        });
      });
      describe("Check platform", () => {
        it("Platform check", async () => {
          await db2().reset();
          conn = db2().connect();
          const version = conn.query(
            "PRAGMA platform;"
          );
          const rows = version.getChildAt(0)?.toArray();
          expect(rows.length).toEqual(1);
          expect(rows[0].toString().substr(0, 5)).toEqual("wasm_");
          await db2().reset();
        });
      });
      describe("Reset", () => {
        it("table must disappear", async () => {
          await db2().reset();
          conn = db2().connect();
          conn.query("CREATE TABLE foo (a int)");
          let table = conn.query("PRAGMA show_tables;");
          let rows = table.toArray();
          expect(rows.length).toEqual(1);
          expect(rows[0]?.name).toEqual("foo");
          await db2().reset();
          conn = db2().connect();
          table = conn.query("PRAGMA show_tables;");
          rows = table.toArray();
          expect(rows.length).toEqual(0);
        });
      });
      describe("Prepared Statement", () => {
        it("Materialized", async () => {
          const stmt = conn.prepare("SELECT v::INTEGER + ? AS v FROM generate_series(0, 10000) as t(v);");
          const result = stmt.query(234);
          expect(result.numRows).toBe(10001);
          stmt.close();
        });
        it("Streaming", async () => {
          const stmt = conn.prepare("SELECT v::INTEGER + ? AS v FROM generate_series(0, 10000) as t(v);");
          const stream = stmt.send(234);
          let size = 0;
          for (const batch of stream) {
            size += batch.numRows;
          }
          expect(size).toBe(10001);
          conn.close();
        });
        it("Typecheck", async () => {
          conn.query(`CREATE TABLE typecheck (
                    a BOOLEAN DEFAULT NULL,
                    b TINYINT DEFAULT NULL,
                    c SMALLINT DEFAULT NULL,
                    d INTEGER DEFAULT NULL,
                    e BIGINT DEFAULT NULL,
                    f FLOAT DEFAULT NULL,
                    g DOUBLE DEFAULT NULL,
                    h CHAR(11) DEFAULT NULL,
                    i VARCHAR(11) DEFAULT NULL
                )`);
          const stmt = conn.prepare("INSERT INTO typecheck VALUES(?,?,?,?,?,?,?,?,?)");
          expect(
            () => stmt.query(true, 100, 1e4, 1e6, 5e9, 0.5, Math.PI, "hello world", "hi")
          ).not.toThrow();
          expect(
            () => stmt.query(
              "test",
              // varchar for bool
              100,
              1e4,
              1e6,
              5e9,
              0.5,
              Math.PI,
              "hello world",
              "hi"
            )
          ).toThrow();
          expect(
            () => stmt.query(
              true,
              1e4,
              // smallint for tinyint
              1e4,
              1e6,
              5e9,
              0.5,
              Math.PI,
              "hello world",
              "hi"
            )
          ).toThrow();
          expect(
            () => stmt.query(
              true,
              100,
              1e6,
              // int for smallint
              1e6,
              5e9,
              0.5,
              Math.PI,
              "hello world",
              "hi"
            )
          ).toThrow();
          expect(
            () => stmt.query(
              true,
              100,
              1e4,
              5e9,
              // bigint for int
              5e9,
              0.5,
              Math.PI,
              "hello world",
              "hi"
            )
          ).toThrow();
          conn.close();
        });
      });
    });
  }
  function testAsyncBindings(adb2, baseURL2, baseDirProto) {
    beforeEach(async () => {
    });
    afterEach(async () => {
      await adb2().flushFiles();
      await adb2().dropFiles();
      await adb2().open({
        path: ":memory:"
      });
    });
    describe("Bindings", () => {
      describe("Open", () => {
        it("Remote TPCH 0_01", async () => {
          await adb2().registerFileURL("tpch_0_01.db", `${baseURL2}/tpch/0_01/duckdb/db`, baseDirProto, false);
          await adb2().open({
            path: "tpch_0_01.db"
          });
        });
      });
      describe("Patching", () => {
        it("Count(*) Default", async () => {
          await adb2().open({
            path: ":memory:",
            query: {
              castBigIntToDouble: false
            }
          });
          const conn = await adb2().connect();
          const table = await conn.query("select 1::BIGINT");
          expect(table.schema.fields.length).toEqual(1);
          expect(table.schema.fields[0].typeId).toEqual(Type.Int);
        });
        it("Count(*) No BigInt", async () => {
          await adb2().open({
            path: ":memory:",
            query: {
              castBigIntToDouble: true
            }
          });
          const conn = await adb2().connect();
          const table = await conn.query("select 1::BIGINT");
          expect(table.schema.fields.length).toEqual(1);
          expect(table.schema.fields[0].typeId).toEqual(Type.Float);
        });
      });
      describe("Prepared Statement", () => {
        it("Materialized", async () => {
          const conn = await adb2().connect();
          const stmt = await conn.prepare("SELECT v + ? FROM generate_series(0, 10000) as t(v);");
          const result = await stmt.query(234);
          expect(result.numRows).toBe(10001);
          await stmt.close();
        });
        it("Streaming", async () => {
          const conn = await adb2().connect();
          const stmt = await conn.prepare("SELECT v::INTEGER + ? AS v FROM generate_series(0, 10000) as t(v);");
          const stream = await stmt.send(234);
          let size = 0;
          for await (const batch of stream) {
            size += batch.numRows;
          }
          expect(size).toBe(10001);
          await conn.close();
        });
        it("Typecheck", async () => {
          const conn = await adb2().connect();
          await conn.query(`CREATE TABLE typecheck (
                    a BOOLEAN DEFAULT NULL,
                    b TINYINT DEFAULT NULL,
                    c SMALLINT DEFAULT NULL,
                    d INTEGER DEFAULT NULL,
                    e BIGINT DEFAULT NULL,
                    f FLOAT DEFAULT NULL,
                    g DOUBLE DEFAULT NULL,
                    h CHAR(11) DEFAULT NULL,
                    i VARCHAR(11) DEFAULT NULL
                )`);
          const stmt = await conn.prepare("INSERT INTO typecheck VALUES(?,?,?,?,?,?,?,?,?)");
          const expectToThrow = async (fn) => {
            let throwed = false;
            try {
              await fn();
            } catch (e) {
              throwed = true;
            }
            expect(throwed).toBe(true);
          };
          expectToThrow(async () => {
            await stmt.query(
              "test",
              // varchar for bool
              100,
              1e4,
              1e6,
              5e9,
              0.5,
              Math.PI,
              "hello world",
              "hi"
            );
          });
          expectToThrow(async () => {
            await stmt.query(
              true,
              1e4,
              // smallint for tinyint
              1e4,
              1e6,
              5e9,
              0.5,
              Math.PI,
              "hello world",
              "hi"
            );
          });
          expectToThrow(async () => {
            await stmt.query(
              true,
              100,
              1e6,
              // int for smallint
              1e6,
              5e9,
              0.5,
              Math.PI,
              "hello world",
              "hi"
            );
          });
          expectToThrow(async () => {
            await stmt.query(
              true,
              100,
              1e4,
              5e9,
              // bigint for int
              5e9,
              0.5,
              Math.PI,
              "hello world",
              "hi"
            );
          });
          await conn.close();
        });
      });
      describe("AccessMode", () => {
        it("READ_ONLY", async () => {
          await expectAsync(
            adb2().open({
              accessMode: 2 /* READ_ONLY */
            })
          ).toBeRejectedWithError(/Cannot launch in-memory database in read-only mode/);
        });
        it("READ_WRITE", async () => {
          await expectAsync(
            adb2().open({
              accessMode: 3 /* READ_WRITE */
            })
          ).toBeResolved();
        });
      });
      describe("Cancellation", () => {
        it("hello cancel", async () => {
          await adb2().open({
            path: ":memory:",
            query: {
              queryPollingInterval: 0
            }
          });
          const conn = await adb2().connect();
          const result = await conn.useUnsafe(
            (db2, id) => db2.startPendingQuery(id, "SELECT SUM(i) FROM range(1000000) tbl(i);")
          );
          expect(result).toBeNull();
          const cancelOK = await conn.useUnsafe((db2, id) => db2.cancelPendingQuery(id));
          expect(cancelOK).toBeTrue();
          let polledHeader = null;
          let polledError = null;
          try {
            polledHeader = await conn.useUnsafe((db2, id) => db2.pollPendingQuery(id));
          } catch (e) {
            polledError = e;
          }
          expect(polledHeader).toBeNull();
          expect(polledError).not.toBeNull();
          expect(polledError.toString()).toEqual("Error: query was canceled");
          const canceledAgain = await conn.useUnsafe((db2, id) => db2.cancelPendingQuery(id));
          expect(canceledAgain).toBeFalse();
          const table = await conn.query("select 42::integer;");
          expect(table.schema.fields.length).toEqual(1);
        });
        it("noop cancel", async () => {
          await adb2().open({
            path: ":memory:",
            query: {
              queryPollingInterval: 0
            }
          });
          const conn = await adb2().connect();
          const result = await conn.useUnsafe(
            (db2, id) => db2.startPendingQuery(id, "SELECT SUM(i) FROM range(1000000) tbl(i);")
          );
          expect(result).toBeNull();
          let polledHeader = null;
          let polledError = null;
          try {
            while (polledHeader == null) {
              polledHeader = await conn.useUnsafe((db2, id) => db2.pollPendingQuery(id));
            }
          } catch (e) {
            polledError = e;
          }
          expect(polledHeader).not.toBeNull();
          expect(polledError).toBeNull();
          const cancelOK = await conn.useUnsafe((db2, id) => db2.cancelPendingQuery(id));
          expect(cancelOK).toBeFalse();
          const anotherOne = await conn.useUnsafe((db2, id) => db2.cancelPendingQuery(id));
          expect(anotherOne).toBeFalse();
        });
      });
    });
  }

  // test/batch_stream.test.ts
  var testRows = 1e4;
  function testBatchStream(db2) {
    let conn;
    beforeEach(() => {
      conn = db2().connect();
    });
    afterEach(() => {
      conn.close();
      db2().flushFiles();
      db2().dropFiles();
    });
    describe("Arrow Record-Batches Row-Major", () => {
      describe("single column", () => {
        it("TINYINT", async () => {
          const result = await conn.send(`
                    SELECT (v & 127)::TINYINT AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i2 = 0;
          for (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const row of batch) {
              expect(row.v).toBe(i2++ & 127);
            }
          }
          expect(i2).toBe(testRows + 1);
        });
        it("SMALLINT", async () => {
          const result = await conn.send(`
                    SELECT (v & 32767)::SMALLINT AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i2 = 0;
          for (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const row of batch) {
              expect(row.v).toBe(i2++ & 32767);
            }
          }
          expect(i2).toBe(testRows + 1);
        });
        it("INTEGER", async () => {
          const result = await conn.send(`
                    SELECT v::INTEGER AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i2 = 0;
          for (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const row of batch) {
              expect(row.v).toBe(i2++);
            }
          }
          expect(i2).toBe(testRows + 1);
        });
        it("BIGINT", async () => {
          const result = await conn.send(`
                    SELECT v::BIGINT AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i2 = 0;
          for (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const row of batch) {
              expect(row.v).toBe(BigInt(i2++));
            }
          }
          expect(i2).toBe(testRows + 1);
        });
        it("STRING", async () => {
          const result = await conn.send(`
                    SELECT v::VARCHAR AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i2 = 0;
          for (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const row of batch) {
              expect(row.v).toBe(String(i2++));
            }
          }
          expect(i2).toBe(testRows + 1);
        });
      });
    });
    describe("Arrow Record-Batches Column-Major", () => {
      describe("single column", () => {
        it("TINYINT", async () => {
          const result = await conn.send(`
                    SELECT (v & 127)::TINYINT AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i2 = 0;
          for (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const v of batch.getChildAt(0)) {
              expect(v).toBe(i2++ & 127);
            }
          }
          expect(i2).toBe(testRows + 1);
        });
        it("SMALLINT", async () => {
          const result = await conn.send(`
                    SELECT (v & 32767)::SMALLINT AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i2 = 0;
          for (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const v of batch.getChildAt(0)) {
              expect(v).toBe(i2++ & 32767);
            }
          }
          expect(i2).toBe(testRows + 1);
        });
        it("INTEGER", async () => {
          const result = await conn.send(`
                    SELECT v::INTEGER AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i2 = 0;
          for (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const v of batch.getChildAt(0)) {
              expect(v).toBe(i2++);
            }
          }
          expect(i2).toBe(testRows + 1);
        });
        it("BIGINT", async () => {
          const result = await conn.send(`
                    SELECT v::BIGINT AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i2 = 0;
          for (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const v of batch.getChildAt(0)) {
              expect(v).toBe(BigInt(i2++));
            }
          }
          expect(i2).toBe(testRows + 1);
        });
        it("STRING", async () => {
          const result = await conn.send(`
                    SELECT v::VARCHAR AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i2 = 0;
          for (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const v of batch.getChildAt(0)) {
              expect(v).toBe(String(i2++));
            }
          }
          expect(i2).toBe(testRows + 1);
        });
      });
    });
    describe("Arrow Table Row-Major", () => {
      describe("single column", () => {
        it("TINYINT", () => {
          const table = conn.query(`
                    SELECT (v & 127)::TINYINT AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i2 = 0;
          for (const row of table) {
            expect(row?.v).toBe(i2++ & 127);
          }
          expect(i2).toBe(testRows + 1);
        });
        it("SMALLINT", () => {
          const table = conn.query(`
                    SELECT (v & 32767)::SMALLINT AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i2 = 0;
          for (const row of table) {
            expect(row?.v).toBe(i2++ & 32767);
          }
          expect(i2).toBe(testRows + 1);
        });
        it("INTEGER", () => {
          const table = conn.query(`
                    SELECT v::INTEGER AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i2 = 0;
          for (const row of table) {
            expect(row?.v).toBe(i2++);
          }
          expect(i2).toBe(testRows + 1);
        });
        it("BIGINT", () => {
          const table = conn.query(`
                    SELECT v::BIGINT AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i2 = 0;
          for (const row of table) {
            expect(row?.v).toBe(BigInt(i2++));
          }
          expect(i2).toBe(testRows + 1);
        });
        it("STRING", () => {
          const table = conn.query(`
                    SELECT v::VARCHAR AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i2 = 0;
          for (const row of table) {
            expect(row?.v.valueOf()).toBe(String(i2++));
          }
          expect(i2).toBe(testRows + 1);
        });
      });
    });
    describe("Arrow Table Column-Major", () => {
      describe("single column", () => {
        it("TINYINT", () => {
          const table = conn.query(`
                    SELECT (v & 127)::TINYINT AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i2 = 0;
          for (const v of table.getChildAt(0)) {
            expect(v).toBe(i2++ & 127);
          }
          expect(i2).toBe(testRows + 1);
        });
        it("SMALLINT", () => {
          const table = conn.query(`
                    SELECT (v & 32767)::SMALLINT AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i2 = 0;
          for (const v of table.getChildAt(0)) {
            expect(v).toBe(i2++ & 32767);
          }
          expect(i2).toBe(testRows + 1);
        });
        it("INTEGER", () => {
          const table = conn.query(`
                    SELECT v::INTEGER AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i2 = 0;
          for (const v of table.getChildAt(0)) {
            expect(v).toBe(i2++);
          }
          expect(i2).toBe(testRows + 1);
        });
        it("BIGINT", () => {
          const table = conn.query(`
                    SELECT v::BIGINT AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i2 = 0;
          for (const v of table.getChildAt(0)) {
            expect(v).toBe(BigInt(i2++));
          }
          expect(i2).toBe(testRows + 1);
        });
        it("STRING", () => {
          const table = conn.query(`
                    SELECT v::VARCHAR AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i2 = 0;
          for (const v of table.getChildAt(0)) {
            expect(v).toBe(String(i2++));
          }
          expect(i2).toBe(testRows + 1);
        });
      });
    });
  }

  // test/batch_stream_async.test.ts
  var testRows2 = 1e4;
  function testAsyncBatchStream(db2) {
    let conn;
    beforeEach(async () => {
      conn = await db2().connect();
    });
    afterEach(async () => {
      await conn.close();
      await db2().flushFiles();
      await db2().dropFiles();
    });
    describe("AsyncDuckDB", () => {
      it("ping", async () => {
        await db2().ping();
      });
    });
    describe("Arrow Record-Batches Row-Major", () => {
      describe("single column", () => {
        it("TINYINT", async () => {
          const result = await conn.send(`
                    SELECT (v & 127)::TINYINT AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i2 = 0;
          for await (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const row of batch) {
              expect(row.v).toBe(i2++ & 127);
            }
          }
          expect(i2).toBe(testRows2 + 1);
        });
        it("SMALLINT", async () => {
          const result = await conn.send(`
                    SELECT (v & 32767)::SMALLINT AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i2 = 0;
          for await (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const v of batch.getChildAt(0)) {
              expect(v).toBe(i2++ & 32767);
            }
          }
          expect(i2).toBe(testRows2 + 1);
        });
        it("INTEGER", async () => {
          const result = await conn.send(`
                    SELECT v::INTEGER AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i2 = 0;
          for await (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const v of batch.getChildAt(0)) {
              expect(v).toBe(i2++);
            }
          }
          expect(i2).toBe(testRows2 + 1);
        });
        it("BIGINT", async () => {
          const result = await conn.send(`
                    SELECT v::BIGINT AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i2 = 0;
          for await (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const v of batch.getChildAt(0)) {
              expect(v).toBe(BigInt(i2++));
            }
          }
          expect(i2).toBe(testRows2 + 1);
        });
        it("STRING", async () => {
          const result = await conn.send(`
                    SELECT v::VARCHAR AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i2 = 0;
          for await (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const v of batch.getChildAt(0)) {
              expect(v).toBe(String(i2++));
            }
          }
          expect(i2).toBe(testRows2 + 1);
        });
      });
      describe("scripts", () => {
        it("test1", async () => {
          const result = await conn.send(`
                    SELECT v::INTEGER AS x, (sin(v) * 100 + 100)::INTEGER AS y FROM generate_series(0, ${testRows2}) as t(v)
                `);
          let i2 = 0;
          for await (const batch of result) {
            expect(batch.numCols).toBe(2);
            for (const row of batch) {
              expect(row.x).toBe(i2++);
            }
          }
          expect(i2).toBe(testRows2 + 1);
        });
      });
    });
    describe("Arrow Record-Batches Column-Major", () => {
      describe("single column", () => {
        it("TINYINT", async () => {
          const result = await conn.send(`
                    SELECT (v & 127)::TINYINT AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i2 = 0;
          for await (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const v of batch.getChildAt(0)) {
              expect(v).toBe(i2++ & 127);
            }
          }
          expect(i2).toBe(testRows2 + 1);
        });
        it("SMALLINT", async () => {
          const result = await conn.send(`
                    SELECT (v & 32767)::SMALLINT AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i2 = 0;
          for await (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const v of batch.getChildAt(0)) {
              expect(v).toBe(i2++ & 32767);
            }
          }
          expect(i2).toBe(testRows2 + 1);
        });
        it("INTEGER", async () => {
          const result = await conn.send(`
                    SELECT v::INTEGER AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i2 = 0;
          for await (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const v of batch.getChildAt(0)) {
              expect(v).toBe(i2++);
            }
          }
          expect(i2).toBe(testRows2 + 1);
        });
        it("BIGINT", async () => {
          const result = await conn.send(`
                    SELECT v::BIGINT AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i2 = 0;
          for await (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const v of batch.getChildAt(0)) {
              expect(v).toBe(BigInt(i2++));
            }
          }
          expect(i2).toBe(testRows2 + 1);
        });
        it("STRING", async () => {
          const result = await conn.send(`
                    SELECT v::VARCHAR AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i2 = 0;
          for await (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const v of batch.getChildAt(0)) {
              expect(v).toBe(String(i2++));
            }
          }
          expect(i2).toBe(testRows2 + 1);
        });
      });
    });
    describe("Arrow Table Row-Major", () => {
      describe("single column", () => {
        it("TINYINT", async () => {
          const table = await conn.query(`
                    SELECT (v & 127)::TINYINT AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i2 = 0;
          for (const row of table) {
            expect(row?.v).toBe(i2++ & 127);
          }
          expect(i2).toBe(testRows2 + 1);
        });
        it("SMALLINT", async () => {
          const table = await conn.query(`
                    SELECT (v & 32767)::SMALLINT AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i2 = 0;
          for (const row of table) {
            expect(row?.v).toBe(i2++ & 32767);
          }
          expect(i2).toBe(testRows2 + 1);
        });
        it("INTEGER", async () => {
          const table = await conn.query(`
                    SELECT v::INTEGER AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i2 = 0;
          for (const row of table) {
            expect(row?.v).toBe(i2++);
          }
          expect(i2).toBe(testRows2 + 1);
        });
        it("BIGINT", async () => {
          const table = await conn.query(`
                    SELECT v::BIGINT AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i2 = 0;
          for (const row of table) {
            expect(row?.v).toBe(BigInt(i2++));
          }
          expect(i2).toBe(testRows2 + 1);
        });
        it("STRING", async () => {
          const table = await conn.query(`
                    SELECT v::VARCHAR AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i2 = 0;
          for (const row of table) {
            expect(row?.v.valueOf()).toBe(String(i2++));
          }
          expect(i2).toBe(testRows2 + 1);
        });
      });
    });
    describe("Arrow Table Column-Major", () => {
      describe("single column", () => {
        it("TINYINT", async () => {
          const table = await conn.query(`
                    SELECT (v & 127)::TINYINT AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i2 = 0;
          for (const v of table.getChildAt(0)) {
            expect(v).toBe(i2++ & 127);
          }
          expect(i2).toBe(testRows2 + 1);
        });
        it("SMALLINT", async () => {
          const table = await conn.query(`
                    SELECT (v & 32767)::SMALLINT AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i2 = 0;
          for (const v of table.getChildAt(0)) {
            expect(v).toBe(i2++ & 32767);
          }
          expect(i2).toBe(testRows2 + 1);
        });
        it("INTEGER", async () => {
          const table = await conn.query(`
                    SELECT v::INTEGER AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i2 = 0;
          for (const v of table.getChildAt(0)) {
            expect(v).toBe(i2++);
          }
          expect(i2).toBe(testRows2 + 1);
        });
        it("BIGINT", async () => {
          const table = await conn.query(`
                    SELECT v::BIGINT AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i2 = 0;
          for (const v of table.getChildAt(0)) {
            expect(v).toBe(BigInt(i2++));
          }
          expect(i2).toBe(testRows2 + 1);
        });
        it("STRING", async () => {
          const table = await conn.query(`
                    SELECT v::VARCHAR AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i2 = 0;
          for (const v of table.getChildAt(0)) {
            expect(v).toBe(String(i2++));
          }
          expect(i2).toBe(testRows2 + 1);
        });
      });
    });
  }

  // test/filesystem.test.ts
  var decoder2 = new TextDecoder();
  function testFilesystem(db2, resolveData2, baseDir, baseDirProto) {
    let conn;
    beforeEach(async () => {
      conn = await db2().connect();
    });
    afterEach(async () => {
      await conn.close();
      await db2().flushFiles();
      await db2().dropFiles();
    });
    describe("File buffer registration", () => {
      const test = async () => {
        const result = await conn.send(`SELECT matrnr FROM parquet_scan('studenten.parquet');`);
        const batches = [];
        for await (const batch of result) {
          batches.push(batch);
        }
        const table = await new Table(batches);
        expect(table.getChildAt(0)?.toArray()).toEqual(
          new Int32Array([24002, 25403, 26120, 26830, 27550, 28106, 29120, 29555])
        );
      };
      it("File buffer used once", async () => {
        const students = await resolveData2("/uni/studenten.parquet");
        expect(students).not.toBeNull();
        await db2().registerFileBuffer("studenten.parquet", students);
        await test();
      });
      it("File buffer registered twice", async () => {
        const students0 = await resolveData2("/uni/studenten.parquet");
        const students1 = await resolveData2("/uni/studenten.parquet");
        expect(students0).not.toBeNull();
        expect(students1).not.toBeNull();
        await db2().registerFileBuffer("studenten.parquet", students0);
        await test();
        await db2().registerFileBuffer("studenten.parquet", students1);
        await test();
      });
      it("File buffer used twice", async () => {
        const students = await resolveData2("/uni/studenten.parquet");
        expect(students).not.toBeNull();
        await db2().registerFileBuffer("studenten.parquet", students);
        await test();
        await test();
      });
    });
    describe("Parquet Scans", () => {
      it("single table from buffer", async () => {
        const students = await resolveData2("/uni/studenten.parquet");
        expect(students).not.toBeNull();
        await db2().registerFileBuffer("studenten.parquet", students);
        const result = await conn.send(`SELECT matrnr FROM parquet_scan('studenten.parquet');`);
        const batches = [];
        for await (const batch of result) {
          batches.push(batch);
        }
        const table = await new Table(batches);
        expect(table.getChildAt(0)?.toArray()).toEqual(
          new Int32Array([24002, 25403, 26120, 26830, 27550, 28106, 29120, 29555])
        );
      });
      it("simple join", async () => {
        const students = await resolveData2("/uni/studenten.parquet");
        const hoeren = await resolveData2("/uni/hoeren.parquet");
        const vorlesungen = await resolveData2("/uni/vorlesungen.parquet");
        expect(students).not.toBeNull();
        expect(hoeren).not.toBeNull();
        expect(vorlesungen).not.toBeNull();
        await db2().registerFileBuffer("studenten.parquet", students);
        await db2().registerFileBuffer("hoeren.parquet", hoeren);
        await db2().registerFileBuffer("vorlesungen.parquet", vorlesungen);
        const result = await conn.send(`
                    SELECT students.matrnr, vorlesungen.titel
                    FROM parquet_scan('studenten.parquet') students
                    INNER JOIN parquet_scan('hoeren.parquet') hoeren ON (students.matrnr = hoeren.matrnr)
                    INNER JOIN parquet_scan('vorlesungen.parquet') vorlesungen ON (vorlesungen.vorlnr = hoeren.vorlnr);
                `);
        const batches = [];
        for await (const batch of result) {
          batches.push(batch);
        }
        const table = await new Table(batches);
        expect(table.numCols).toBe(2);
        const flat = [];
        for (const row of table) {
          flat.push({
            matrnr: row?.matrnr,
            titel: row?.titel?.toString()
          });
        }
        expect(flat).toEqual([
          { matrnr: 26120, titel: "Grundz\xFCge" },
          { matrnr: 27550, titel: "Grundz\xFCge" },
          { matrnr: 27550, titel: "Logik" },
          { matrnr: 28106, titel: "Ethik" },
          { matrnr: 28106, titel: "Wissenschaftstheorie" },
          { matrnr: 28106, titel: "Bioethik" },
          { matrnr: 28106, titel: "Der Wiener Kreis" },
          { matrnr: 29120, titel: "Grundz\xFCge" },
          { matrnr: 29120, titel: "Ethik" },
          { matrnr: 29120, titel: "M\xE4eutik" },
          { matrnr: 29555, titel: "Glaube und Wissen" },
          { matrnr: 25403, titel: "Glaube und Wissen" }
        ]);
      });
    });
    describe("Writing", () => {
      it("Copy To CSV Buffer", async () => {
        const students = await resolveData2("/uni/studenten.parquet");
        expect(students).not.toBeNull();
        await db2().registerFileBuffer("studenten.parquet", students);
        await db2().registerEmptyFileBuffer("students.csv");
        await conn.query(`CREATE TABLE students AS SELECT * FROM parquet_scan('studenten.parquet');`);
        await conn.query(`COPY students TO 'students.csv' WITH (HEADER 1, DELIMITER ';', FORMAT CSV);`);
        await conn.query(`DROP TABLE IF EXISTS students`);
        const outBuffer = await db2().copyFileToBuffer("students.csv");
        expect(outBuffer).not.toBeNull();
        const text = decoder2.decode(outBuffer);
        expect(text).toBe(`matrnr;name;semester
24002;Xenokrates;18
25403;Jonas;12
26120;Fichte;10
26830;Aristoxenos;8
27550;Schopenhauer;6
28106;Carnap;3
29120;Theophrastos;2
29555;Feuerbach;2
`);
      });
      it("Copy To Parquet", async () => {
        const students = await resolveData2("/uni/studenten.parquet");
        expect(students).not.toBeNull();
        await db2().registerFileBuffer("studenten.parquet", students);
        await db2().registerEmptyFileBuffer("students2.parquet");
        await conn.query(`CREATE TABLE students2 AS SELECT * FROM parquet_scan('studenten.parquet');`);
        await conn.query(`COPY students2 TO 'students2.parquet' (FORMAT PARQUET);`);
        const url2 = await db2().copyFileToBuffer("students2.parquet");
        expect(url2).not.toBeNull();
      });
      it("Copy To Parquet And Load Again", async () => {
        const students = await resolveData2("/uni/studenten.parquet");
        expect(students).not.toBeNull();
        await db2().registerFileBuffer("studenten.parquet", students);
        await db2().registerEmptyFileBuffer("students3.parquet");
        await conn.query(`CREATE TABLE students3 AS SELECT * FROM parquet_scan('studenten.parquet');`);
        await conn.query(`COPY students3 TO 'students3.parquet' (FORMAT PARQUET);`);
        const url2 = await db2().copyFileToBuffer("students3.parquet");
        expect(url2).not.toBeNull();
        await conn.query(`CREATE TABLE students4 AS SELECT * FROM parquet_scan('students3.parquet');`);
        const result = await conn.send(`SELECT matrnr FROM students4;`);
        const batches = [];
        for await (const batch of result) {
          batches.push(batch);
        }
        const table = await new Table(batches);
        expect(table.getChildAt(0)?.toArray()).toEqual(
          new Int32Array([24002, 25403, 26120, 26830, 27550, 28106, 29120, 29555])
        );
      });
    });
    describe("File access", () => {
      it("Small Parquet file", async () => {
        await db2().registerFileURL("studenten.parquet", `${baseDir}/uni/studenten.parquet`, baseDirProto, true);
        const result = await conn.send(`SELECT matrnr FROM parquet_scan('studenten.parquet');`);
        const batches = [];
        for await (const batch of result) {
          batches.push(batch);
        }
        const table = await new Table(batches);
        expect(table.getChildAt(0)?.toArray()).toEqual(
          new Int32Array([24002, 25403, 26120, 26830, 27550, 28106, 29120, 29555])
        );
      });
      it("Large Parquet file", async () => {
        await db2().registerFileURL(
          "lineitem.parquet",
          `${baseDir}/tpch/0_01/parquet/lineitem.parquet`,
          baseDirProto,
          true
        );
        const result = await conn.send(`SELECT count(*)::INTEGER as cnt FROM parquet_scan('lineitem.parquet');`);
        const batches = [];
        for await (const batch of result) {
          batches.push(batch);
        }
        const table = await new Table(batches);
        expect(table.getChildAt(0)?.get(0)).toBeGreaterThan(6e4);
      });
    });
    describe("Export", () => {
      it("Generate Series as CSV", async () => {
        await conn.query("CREATE TABLE foo AS SELECT * FROM generate_series(1, 5) t(v)");
        await conn.query(`EXPORT DATABASE '/tmp/duckdbexportcsv'`);
        const results = await db2().globFiles("/tmp/duckdbexportcsv/*");
        expect(results).not.toEqual([]);
        expect(results.length).toEqual(3);
        const filenames = results.map((file) => file.fileName).sort();
        expect(filenames).toEqual([
          "/tmp/duckdbexportcsv/foo.csv",
          "/tmp/duckdbexportcsv/load.sql",
          "/tmp/duckdbexportcsv/schema.sql"
        ]);
        const csv_buffer_utf8 = await db2().copyFileToBuffer("/tmp/duckdbexportcsv/foo.csv");
        const load_script_utf8 = await db2().copyFileToBuffer("/tmp/duckdbexportcsv/load.sql");
        const schema_script_utf8 = await db2().copyFileToBuffer("/tmp/duckdbexportcsv/schema.sql");
        expect(load_script_utf8.length).not.toEqual(0);
        expect(schema_script_utf8.length).not.toEqual(0);
        expect(csv_buffer_utf8.length).not.toEqual(0);
      });
      it("Generate Series as Parquet", async () => {
        await conn.query("CREATE TABLE foo AS SELECT * FROM generate_series(1, 5) t(v)");
        await conn.query(`EXPORT DATABASE '/tmp/duckdbexportparquet' (FORMAT PARQUET)`);
        const results = await db2().globFiles("/tmp/duckdbexportparquet/*");
        expect(results).not.toEqual([]);
        expect(results.length).toEqual(3);
        const filenames = results.map((file) => file.fileName).sort();
        expect(filenames).toEqual([
          "/tmp/duckdbexportparquet/foo.parquet",
          "/tmp/duckdbexportparquet/load.sql",
          "/tmp/duckdbexportparquet/schema.sql"
        ]);
        const parquet_buffer = await db2().copyFileToBuffer("/tmp/duckdbexportparquet/foo.parquet");
        const load_script_utf8 = await db2().copyFileToBuffer("/tmp/duckdbexportparquet/load.sql");
        const schema_script_utf8 = await db2().copyFileToBuffer("/tmp/duckdbexportparquet/schema.sql");
        expect(load_script_utf8.length).not.toEqual(0);
        expect(schema_script_utf8.length).not.toEqual(0);
        expect(parquet_buffer.length).not.toEqual(0);
        const content = await conn.query(
          `SELECT v::integer FROM parquet_scan('/tmp/duckdbexportparquet/foo.parquet')`
        );
        expect(content.nullCount).toEqual(0);
        expect(content.numRows).toEqual(5);
        expect(content.getChildAt(0)?.toArray()).toEqual(new Int32Array([1, 2, 3, 4, 5]));
      });
    });
    describe("Copy", () => {
      it("Generate Series as Parquet", async () => {
        await conn.query(
          `COPY (SELECT * FROM generate_series(1, 5) t(v)) TO '/tmp/duckdbcopytest.parquet' (FORMAT 'parquet')`
        );
        const results = await db2().globFiles("/tmp/duckdbcopytest*");
        expect(results).not.toEqual([]);
        expect(results.length).toEqual(1);
        const filenames = results.map((file) => file.fileName).sort();
        expect(filenames).toEqual(["/tmp/duckdbcopytest.parquet"]);
        const parquet_buffer = await db2().copyFileToBuffer("/tmp/duckdbcopytest.parquet");
        expect(parquet_buffer.length).not.toEqual(0);
        const content = await conn.query(`SELECT v::integer FROM parquet_scan('/tmp/duckdbcopytest.parquet')`);
        expect(content.numRows).toEqual(5);
        expect(content.getChildAt(0)?.toArray()).toEqual(new Int32Array([1, 2, 3, 4, 5]));
      });
    });
  }

  // test/table_test.ts
  function compareTable(table, expected) {
    const colCount = expected.length;
    expect(table.numCols).toEqual(colCount);
    if (colCount == 0)
      return;
    const rowCount = expected[0].values.length;
    for (let i2 = 0; i2 < colCount; ++i2) {
      expect(expected[i2].values.length).toEqual(rowCount);
      expect(table.getChildAt(i2)?.length).toEqual(rowCount);
      expect(table.schema.fields[i2]?.name).toEqual(expected[i2].name);
    }
    for (let i2 = 0; i2 < colCount; ++i2) {
      const col = table.getChildAt(i2);
      const have = [];
      for (let j = 0; j < rowCount; ++j) {
        have.push(col.get(j));
      }
      expect(Number(have)).toEqual(Number(expected[i2].values));
    }
  }

  // test/insert_arrow.test.ts
  var buildUtf8Array = (values) => {
    const builder = new Utf8Builder({
      type: new Utf8()
    });
    for (const v of values) {
      builder.append(v);
    }
    builder.finish();
    return builder.flush();
  };
  var ARROW_INSERT_TESTS = [
    {
      name: "integers_1",
      schema: new Schema2([
        new Field2("a", new Int32()),
        new Field2("b", new Int32()),
        new Field2("c", new Int32())
      ]),
      batches: [
        {
          numRows: 3,
          columns: [
            makeData({ type: new Int32(), data: new Int32Array([1, 4, 7]) }),
            makeData({ type: new Int32(), data: new Int32Array([2, 5, 8]) }),
            makeData({ type: new Int32(), data: new Int32Array([3, 6, 9]) })
          ]
        }
      ],
      options: {
        schema: "main",
        name: "foo"
      },
      query: "SELECT * FROM main.foo",
      expectedColumns: [
        { name: "a", values: [1, 4, 7] },
        { name: "b", values: [2, 5, 8] },
        { name: "c", values: [3, 6, 9] }
      ]
    },
    {
      name: "combined_1",
      schema: new Schema2([
        new Field2("a", new Int32()),
        new Field2("b", new Int16()),
        new Field2("c", new Utf8())
      ]),
      batches: [
        {
          numRows: 3,
          columns: [
            makeData({ type: new Int32(), data: new Int32Array([1, 4, 7]) }),
            makeData({ type: new Int16(), data: new Int16Array([2, 5, 8]) }),
            buildUtf8Array(["3", "6", "9"])
          ]
        }
      ],
      options: {
        schema: "main",
        name: "foo"
      },
      query: "SELECT * FROM main.foo",
      expectedColumns: [
        { name: "a", values: [1, 4, 7] },
        { name: "b", values: [2, 5, 8] },
        { name: "c", values: ["3", "6", "9"] }
      ]
    },
    {
      name: "combined_2",
      schema: new Schema2([
        new Field2("a", new Int32()),
        new Field2("b", new Int16()),
        new Field2("c", new Utf8())
      ]),
      batches: [
        {
          numRows: 3,
          columns: [
            makeData({ type: new Int32(), data: new Int32Array([1, 4, 7]) }),
            makeData({ type: new Int16(), data: new Int16Array([2, 5, 8]) }),
            buildUtf8Array(["3", "6", "9"])
          ]
        },
        {
          numRows: 2,
          columns: [
            makeData({ type: new Int32(), data: new Int32Array([10, 13]) }),
            makeData({ type: new Int16(), data: new Int16Array([11, 14]) }),
            buildUtf8Array(["12", "15"])
          ]
        }
      ],
      options: {
        schema: "main",
        name: "foo"
      },
      query: "SELECT * FROM main.foo",
      expectedColumns: [
        { name: "a", values: [1, 4, 7, 10, 13] },
        { name: "b", values: [2, 5, 8, 11, 14] },
        { name: "c", values: ["3", "6", "9", "12", "15"] }
      ]
    }
  ];
  function testArrowInsert(db2) {
    let conn;
    beforeEach(async () => {
      db2().flushFiles();
      conn = db2().connect();
    });
    afterEach(async () => {
      conn.close();
      await db2().flushFiles();
      await db2().dropFiles();
    });
    describe("Arrow insert from iterable", () => {
      for (const test of ARROW_INSERT_TESTS) {
        it(test.name, () => {
          conn.query(`DROP TABLE IF EXISTS ${test.options.schema || "main"}.${test.options.name}`);
          const batches = test.batches.map((b) => {
            const data2 = makeData({
              type: new Struct(test.schema.fields),
              children: b.columns
            });
            return new RecordBatch(test.schema, data2);
          });
          const table = new Table(test.schema, batches);
          conn.insertArrowTable(table, test.options);
          const results = conn.query(test.query);
          compareTable(results, test.expectedColumns);
        });
      }
    });
  }
  function testArrowInsertAsync(db2) {
    let conn;
    beforeEach(async () => {
      await db2().flushFiles();
      conn = await db2().connect();
    });
    afterEach(async () => {
      await conn.close();
      await db2().flushFiles();
      await db2().dropFiles();
    });
    describe("Arrow async insert from iterable", () => {
      for (const test of ARROW_INSERT_TESTS) {
        it(test.name, async () => {
          await conn.query(`DROP TABLE IF EXISTS ${test.options.schema || "main"}.${test.options.name}`);
          const batches = test.batches.map((b) => {
            const data2 = makeData({
              type: new Struct(test.schema.fields),
              children: b.columns
            });
            return new RecordBatch(test.schema, data2);
          });
          const table = new Table(test.schema, batches);
          await conn.insertArrowTable(table, test.options);
          const results = await conn.query(test.query);
          compareTable(results, test.expectedColumns);
        });
      }
    });
    describe("Arrow async insert from table", () => {
      it("simple integers", async () => {
        await conn.query(`DROP TABLE IF EXISTS insert_from_table`);
        const table = new Table({
          a: makeVector(new Int32Array([1, 4, 7])),
          b: makeVector(new Int32Array([2, 5, 8])),
          c: vectorFromArray(["3", "6", "9"])
        });
        await conn.insertArrowTable(table, {
          name: "insert_from_vectors"
        });
        const results = await conn.query("select * from insert_from_vectors");
        compareTable(results, [
          { name: "a", values: [1, 4, 7] },
          { name: "b", values: [2, 5, 8] },
          { name: "c", values: ["3", "6", "9"] }
        ]);
      });
    });
  }

  // test/insert_json.test.ts
  function describeBrowser(description, specDefinitions) {
    if (typeof window !== "undefined") {
      describe(description, specDefinitions);
    }
  }
  var encoder2 = new TextEncoder();
  var JSON_INSERT_TESTS = [
    {
      name: "rows_integers",
      input: `[
            {"a":1, "b":2, "c":3},
            {"a":4, "b":5, "c":6},
            {"a":7, "b":8, "c":9},
        ]`,
      options: {
        schema: "main",
        name: "foo"
      },
      query: "SELECT * FROM main.foo",
      expectedColumns: [
        { name: "a", values: [1, 4, 7] },
        { name: "b", values: [2, 5, 8] },
        { name: "c", values: [3, 6, 9] }
      ]
    },
    {
      name: "cols_integers",
      input: `{
            "a": [1, 4, 7],
            "b": [2, 5, 8],
            "c": [3, 6, 9]
        }`,
      options: {
        schema: "main",
        name: "foo"
      },
      query: "SELECT * FROM main.foo",
      expectedColumns: [
        { name: "a", values: [1, 4, 7] },
        { name: "b", values: [2, 5, 8] },
        { name: "c", values: [3, 6, 9] }
      ]
    },
    {
      name: "options_1",
      input: `[
            {"a":1, "b":2, "c":3},
            {"a":4, "b":5, "c":6},
            {"a":7, "b":8, "c":9},
        ]`,
      options: {
        schema: "main",
        name: "foo",
        shape: "row-array" /* ROW_ARRAY */,
        columns: {
          a: new Int16(),
          b: new Int32(),
          c: new Utf8()
        }
      },
      query: "SELECT * FROM main.foo",
      expectedColumns: [
        { name: "a", values: [1, 4, 7] },
        { name: "b", values: [2, 5, 8] },
        { name: "c", values: ["3", "6", "9"] }
      ]
    }
  ];
  var TEST_FILE = "TEST";
  function testJSONInsert(db2) {
    let conn;
    beforeEach(async () => {
      db2().flushFiles();
      conn = db2().connect();
    });
    afterEach(async () => {
      conn.close();
      await db2().flushFiles();
      await db2().dropFiles();
    });
    describe("JSON Insert Sync", () => {
      for (const test of JSON_INSERT_TESTS) {
        it(test.name, () => {
          conn.query(`DROP TABLE IF EXISTS ${test.options.schema || "main"}.${test.options.name}`);
          const buffer = encoder2.encode(test.input);
          db2().registerFileBuffer(TEST_FILE, buffer);
          conn.insertJSONFromPath(TEST_FILE, test.options);
          const results = conn.query(test.query);
          compareTable(results, test.expectedColumns);
        });
      }
    });
  }
  function testJSONInsertAsync(db2) {
    let conn;
    beforeEach(async () => {
      await db2().flushFiles();
      conn = await db2().connect();
    });
    afterEach(async () => {
      await conn.close();
      await db2().flushFiles();
      await db2().dropFiles();
    });
    describe("JSON Insert Buffer Async", () => {
      for (const test of JSON_INSERT_TESTS) {
        it(test.name, async () => {
          await conn.query(`DROP TABLE IF EXISTS ${test.options.schema || "main"}.${test.options.name}`);
          const buffer = encoder2.encode(test.input);
          await db2().registerFileBuffer(TEST_FILE, buffer);
          await conn.insertJSONFromPath(TEST_FILE, test.options);
          const results = await conn.query(test.query);
          compareTable(results, test.expectedColumns);
        });
      }
    });
    describeBrowser("JSON Insert Blob Async", () => {
      for (const test of JSON_INSERT_TESTS) {
        it(test.name, async () => {
          await conn.query(`DROP TABLE IF EXISTS ${test.options.schema || "main"}.${test.options.name}`);
          const buffer = encoder2.encode(test.input);
          const blob = new Blob([buffer]);
          await db2().registerFileHandle(TEST_FILE, blob, 2 /* BROWSER_FILEREADER */, false);
          await conn.insertJSONFromPath(TEST_FILE, test.options);
          const results = await conn.query(test.query);
          compareTable(results, test.expectedColumns);
        });
      }
    });
  }

  // test/insert_csv.test.ts
  function describeBrowser2(description, specDefinitions) {
    if (typeof window !== "undefined") {
      describe(description, specDefinitions);
    }
  }
  var encoder3 = new TextEncoder();
  var CSV_INSERT_TESTS = [
    {
      name: "integers_auto_1",
      input: `"a","b","c"
1,2,3
4,5,6
7,8,9
`,
      options: {
        schema: "main",
        name: "foo"
      },
      query: "SELECT * FROM main.foo",
      expectedColumns: [
        { name: "a", values: [1, 4, 7] },
        { name: "b", values: [2, 5, 8] },
        { name: "c", values: [3, 6, 9] }
      ]
    },
    {
      name: "integers_auto_2",
      input: `a,b,c
1,2,3
4,5,6
7,8,9
`,
      options: {
        schema: "main",
        name: "foo"
      },
      query: "SELECT * FROM main.foo",
      expectedColumns: [
        { name: "a", values: [1, 4, 7] },
        { name: "b", values: [2, 5, 8] },
        { name: "c", values: [3, 6, 9] }
      ]
    },
    {
      name: "integers_auto_3",
      input: `a,b,c`,
      options: {
        schema: "main",
        name: "foo"
      },
      query: "SELECT * FROM main.foo",
      expectedColumns: [
        { name: "column0", values: ["a"] },
        { name: "column1", values: ["b"] },
        { name: "column2", values: ["c"] }
      ]
    },
    {
      name: "integers_auto_2",
      input: `a
1
4
7
`,
      options: {
        schema: "main",
        name: "foo"
      },
      query: "SELECT * FROM main.foo",
      expectedColumns: [{ name: "a", values: [1, 4, 7] }]
    },
    {
      name: "options_1",
      input: `1,2,3
4,5,6
7,8,9
`,
      options: {
        schema: "main",
        name: "foo2",
        header: false,
        detect: false,
        columns: {
          a: new Int16(),
          b: new Int32(),
          c: new Utf8()
        }
      },
      query: "SELECT * FROM main.foo2",
      expectedColumns: [
        { name: "a", values: [1, 4, 7] },
        { name: "b", values: [2, 5, 8] },
        { name: "c", values: ["3", "6", "9"] }
      ]
    },
    {
      name: "options_2",
      input: `1|2|01/02/2020
4|5|01/03/2020
7|8|01/04/2020
`,
      options: {
        schema: "main",
        name: "foo",
        detect: false,
        header: false,
        delimiter: "|",
        dateFormat: "%m/%d/%Y",
        columns: {
          a: new Int16(),
          b: new Int32(),
          c: new DateDay()
        }
      },
      query: "SELECT * FROM main.foo",
      expectedColumns: [
        { name: "a", values: [1, 4, 7] },
        { name: "b", values: [2, 5, 8] },
        {
          name: "c",
          values: [
            new Date(Date.UTC(2020, 0, 2)),
            new Date(Date.UTC(2020, 0, 3)),
            new Date(Date.UTC(2020, 0, 4))
          ]
        }
      ]
    },
    {
      name: "options_3",
      input: `1|2|20:32:45 1992-03-02
4|5|20:32:50 1992-03-02
7|8|20:32:55 1992-03-02
`,
      options: {
        schema: "main",
        name: "foo",
        detect: false,
        header: false,
        delimiter: "|",
        quote: "'",
        timestampFormat: "%H:%M:%S %Y-%m-%d",
        columns: {
          a: new Int16(),
          b: new Int32(),
          c: new TimestampSecond()
        }
      },
      query: "SELECT * FROM main.foo",
      expectedColumns: [
        { name: "a", values: [1, 4, 7] },
        { name: "b", values: [2, 5, 8] },
        {
          name: "c",
          values: [
            new Date(Date.UTC(1992, 2, 2, 20, 32, 45)).getTime(),
            new Date(Date.UTC(1992, 2, 2, 20, 32, 50)).getTime(),
            new Date(Date.UTC(1992, 2, 2, 20, 32, 55)).getTime()
          ]
        }
      ]
    }
  ];
  var TEST_FILE2 = "TEST";
  function testCSVInsert(db2) {
    let conn;
    beforeEach(async () => {
      db2().flushFiles();
      conn = db2().connect();
    });
    afterEach(async () => {
      conn.close();
      await db2().flushFiles();
      await db2().dropFiles();
    });
    describe("CSV Insert Sync", () => {
      for (const test of CSV_INSERT_TESTS) {
        it(test.name, () => {
          conn.query(`DROP TABLE IF EXISTS ${test.options.schema || "main"}.${test.options.name}`);
          const buffer = encoder3.encode(test.input);
          db2().registerFileBuffer(TEST_FILE2, buffer);
          conn.insertCSVFromPath(TEST_FILE2, test.options);
          const results = conn.query(test.query);
          compareTable(results, test.expectedColumns);
        });
      }
    });
  }
  function testCSVInsertAsync(db2) {
    let conn;
    beforeEach(async () => {
      await db2().flushFiles();
      conn = await db2().connect();
    });
    afterEach(async () => {
      await conn.close();
      await db2().flushFiles();
      await db2().dropFiles();
    });
    describe("CSV Insert Buffer Async", () => {
      for (const test of CSV_INSERT_TESTS) {
        it(test.name, async () => {
          await conn.query(`DROP TABLE IF EXISTS ${test.options.schema || "main"}.${test.options.name}`);
          const buffer = encoder3.encode(test.input);
          await db2().registerFileBuffer(TEST_FILE2, buffer);
          await conn.insertCSVFromPath(TEST_FILE2, test.options);
          const results = await conn.query(test.query);
          compareTable(results, test.expectedColumns);
        });
      }
    });
    describeBrowser2("CSV Insert Blob Async", () => {
      for (const test of CSV_INSERT_TESTS) {
        it(test.name, async () => {
          await conn.query(`DROP TABLE IF EXISTS ${test.options.schema || "main"}.${test.options.name}`);
          const buffer = encoder3.encode(test.input);
          const blob = new Blob([buffer]);
          await db2().registerFileHandle(TEST_FILE2, blob, 2 /* BROWSER_FILEREADER */, false);
          await conn.insertCSVFromPath(TEST_FILE2, test.options);
          const results = await conn.query(test.query);
          compareTable(results, test.expectedColumns);
        });
      }
    });
  }

  // test/tokenizer.test.ts
  function testTokenization(db2) {
    describe("Tokenizer", () => {
      it("SELECT 1", async () => {
        expect(db2().tokenize("SELECT 1")).toEqual({
          offsets: [0, 7],
          types: [4, 1]
        });
      });
      it("SELECT * FROM region", async () => {
        expect(db2().tokenize("SELECT * FROM region")).toEqual({
          offsets: [0, 7, 9, 14],
          types: [4, 3, 4, 0]
        });
      });
    });
  }
  function testTokenizationAsync(db2) {
    describe("Tokenizer", () => {
      it("SELECT 1", async () => {
        expect(await db2().tokenize("SELECT 1")).toEqual({
          offsets: [0, 7],
          types: [4, 1]
        });
      });
      it("SELECT * FROM region", async () => {
        expect(await db2().tokenize("SELECT * FROM region")).toEqual({
          offsets: [0, 7, 9, 14],
          types: [4, 3, 4, 0]
        });
      });
    });
  }

  // test/tablenames.test.ts
  var TABLENAME_TESTS = [
    {
      name: "standard",
      input: "SELECT * FROM my_table",
      tables: ["my_table"]
    },
    {
      name: "fetch_specific",
      input: "SELECT col_a FROM my_table",
      tables: ["my_table"]
    },
    {
      name: "multiple_tables",
      input: "SELECT * FROM my_table1, my_table2, my_table3",
      tables: ["my_table1", "my_table2", "my_table3"]
    },
    {
      name: "same_table_multiple_times",
      input: "SELECT col_a FROM my_table, my_table m2, my_table m3",
      tables: ["my_table"]
    },
    {
      name: "subqueries",
      input: "SELECT * FROM (SELECT * FROM (SELECT * FROM my_table) bla) bla3",
      tables: ["my_table"]
    },
    {
      name: "join",
      input: "SELECT col_a FROM my_table JOIN my_table2 ON (my_table.col_b=my_table2.col_d)",
      tables: ["my_table", "my_table2"]
    },
    {
      name: "scalar_subquery",
      input: "SELECT (SELECT COUNT(*) FROM my_table)",
      tables: ["my_table"]
    },
    {
      name: "set_operations",
      input: "SELECT * FROM my_table UNION ALL SELECT * FROM my_table2 INTERSECT SELECT * FROM my_table3",
      tables: ["my_table", "my_table2", "my_table3"]
    },
    {
      name: "window_functions",
      input: "SELECT row_number() OVER (ORDER BY (SELECT i+j FROM my_table2)) FROM my_table",
      tables: ["my_table", "my_table2"]
    }
  ];
  function testTableNames(db2) {
    let conn;
    beforeEach(() => {
      conn = db2().connect();
    });
    afterEach(() => {
      conn.close();
    });
    describe("TableNames", () => {
      for (const test of TABLENAME_TESTS) {
        it(test.name, () => {
          const tables = conn.getTableNames(test.input);
          expect(tables).toEqual(test.tables);
        });
      }
    });
  }
  function testTableNamesAsync(db2) {
    let conn;
    beforeEach(async () => {
      conn = await db2().connect();
    });
    afterEach(async () => {
      await conn.close();
    });
    describe("TableNames Async", () => {
      for (const test of TABLENAME_TESTS) {
        it(test.name, async () => {
          const tables = await conn.getTableNames(test.input);
          expect(tables).toEqual(test.tables);
        });
      }
    });
  }

  // test/regression/github_332.test.ts
  function test332(db2) {
    let conn;
    beforeEach(async () => {
      await db2().flushFiles();
      conn = await db2().connect();
    });
    afterEach(async () => {
      await conn.close();
      await db2().flushFiles();
      await db2().dropFiles();
    });
    describe("GitHub issues", () => {
      it("332", async () => {
        await db2().registerFileText(
          "Products.csv",
          `ProductGroup,Product,Year,Quarter,Revenue,Units,Count,Product Key,Reseller,Product Info,QuarterAsNumber
Electronics,Phone,2018,Q1,103,7,1,2018-Q1,Sony,Format=XML; <Properties>\u2026,1
Electronics,Phone,2018,Q1,102,4,1,2018-Q1,Sony,Format=XML; <Properties>\u2026,1
Electronics,Phone,2019,Q1,98,12,1,2019-Q1,Sony,Format=XML; <Properties>\u2026,1
Electronics,Computer,2018,Q1,104,3,1,2018-Q1,Samsung,Format=XML; <Properties>\u2026,1
Electronics,Computer,2019,Q1,83,7,1,2019-Q1,Google,Format=XML; <Properties>\u2026,1
Media,Theater,2018,Q1,17,4,1,2018-Q1,Sony,Format=XML; <Properties>\u2026,1
Media,Theater,2019,Q1,20,7,1,2019-Q1,Sony,Format=XML; <Properties>\u2026,1
Media,Movies,2018,Q1,25,12,1,2018-Q1,Microsoft,Format=XML; <Properties>\u2026,1
Media,Movies,2019,Q1,26,13,1,2019-Q1,Sony,Format=XML; <Properties>\u2026,1
Electronics,Phone,2018,Q2,105,5,1,2018-Q2,Samsung,Format=XML; <Properties>\u2026,2
Electronics,Phone,2019,Q2,82,15,1,2019-Q2,LG,Format=XML; <Properties>\u2026,2
Electronics,Computer,2018,Q2,99,4,1,2018-Q2,LG,Format=XML; <Properties>\u2026,2
Electronics,Computer,2019,Q2,84,20,1,2019-Q2,Sony,Format=XML; <Properties>\u2026,2
Media,Theater,2018,Q2,17,4,1,2018-Q2,Microsoft,Format=XML; <Properties>\u2026,2
Media,Theater,2019,Q2,22,5,1,2019-Q2,Sony,Format=XML; <Properties>\u2026,2
Media,Movies,2018,Q2,25,12,1,2018-Q2,Samsung,Format=XML; <Properties>\u2026,2
Media,Movies,2019,Q2,26,14,1,2019-Q2,Google,Format=XML; <Properties>\u2026,2
Electronics,Phone,2000,Q1,103,7,1,2000-Q1,Sony,Format=XML; <Properties>\u2026,1
Electronics,Phone,2001,Q1,102,4,1,2001-Q1,Sony,Format=XML; <Properties>\u2026,1
Electronics,Phone,2002,Q1,98,12,1,2002-Q1,Microsoft,Format=XML; <Properties>\u2026,1
Electronics,Computer,2003,Q1,104,3,1,2003-Q1,Sony,Format=XML; <Properties>\u2026,1
Electronics,Computer,2004,Q1,83,7,1,2004-Q1,Samsung,Format=XML; <Properties>\u2026,1
Media,Theater,2005,Q1,17,4,1,2005-Q1,Google,Format=XML; <Properties>\u2026,1
Media,Theater,2006,Q1,20,7,1,2006-Q1,Sony,Format=XML; <Properties>\u2026,1
Media,Movies,2007,Q1,25,12,1,2007-Q1,Sony,Format=XML; <Properties>\u2026,1
Media,Movies,2008,Q1,26,13,1,2008-Q1,Microsoft,Format=XML; <Properties>\u2026,1
Electronics,Phone,2009,Q2,105,5,1,2009-Q2,Sony,Format=XML; <Properties>\u2026,2
Electronics,Phone,2010,Q2,82,15,1,2010-Q2,Sony,Format=XML; <Properties>\u2026,2
Electronics,Computer,2011,Q2,99,4,1,2011-Q2,Sony,Format=XML; <Properties>\u2026,2
Electronics,Computer,2012,Q2,84,20,1,2012-Q2,Sony,Format=XML; <Properties>\u2026,2
Media,Theater,2013,Q2,17,4,1,2013-Q2,Sony,Format=XML; <Properties>\u2026,2
Media,Theater,2014,Q2,22,5,1,2014-Q2,Sony,Format=XML; <Properties>\u2026,2
Media,Movies,2015,Q2,25,12,1,2015-Q2,Sony,Format=XML; <Properties>\u2026,2
Media,Movies,2016,Q2,26,14,1,2016-Q2,Samsung,Format=XML; <Properties>\u2026,2
Media,Movies,2017,Q1,26,13,1,2017-Q1,Google,Format=XML; <Properties>\u2026,1
Electronics,Phone,2018,Q2,105,5,1,2018-Q2,Sony,Format=XML; <Properties>\u2026,2
Electronics,Phone,2019,Q2,82,15,1,2019-Q2,Sony,Format=XML; <Properties>\u2026,2
Electronics,Computer,2020,Q2,99,4,1,2020-Q2,Microsoft,Format=XML; <Properties>\u2026,2
Electronics,Phone,2020,Q1,103,7,1,2020-Q1,Sony,Format=XML; <Properties>\u2026,1
Electronics,Phone,2020,Q2,102,4,1,2020-Q2,Samsung,Format=XML; <Properties>\u2026,2
Electronics,Phone,2020,Q3,98,12,1,2020-Q3,LG,Format=XML; <Properties>\u2026,3
Electronics,Computer,2020,Q4,104,3,1,2020-Q4,LG,Format=XML; <Properties>\u2026,4
Electronics,Computer,2020,Q1,83,7,1,2020-Q1,Sony,Format=XML; <Properties>\u2026,1
Media,Theater,2020,Q1,17,4,1,2020-Q1,Microsoft,Format=XML; <Properties>\u2026,1
Media,Theater,2020,Q1,20,7,1,2020-Q1,Sony,Format=XML; <Properties>\u2026,1
`
        );
        await conn.query("CREATE TABLE products AS SELECT * FROM 'Products.csv'");
        const all = await conn.query("SELECT * FROM products");
        expect(all.schema.fields.length).toBe(11);
        expect(all.schema.fields[0].name).toBe("ProductGroup");
        const insensitive = await conn.query("SELECT productgroup FROM products GROUP BY productgroup");
        expect(insensitive.schema.fields.length).toBe(1);
        expect(insensitive.schema.fields[0].name).toBe("ProductGroup");
        expect(insensitive.toArray().length).toEqual(2);
        await conn.query("DROP TABLE products");
      });
    });
  }

  // test/regression/github_334.test.ts
  function test334(adb2) {
    describe("GitHub issues", () => {
      describe("334", () => {
        it("CSV insert", async () => {
          await adb2().registerFileText(`data.csv`, "1|foo\n2|bar\n");
          const conn = await adb2().connect();
          await conn.insertCSVFromPath("data.csv", {
            schema: "main",
            name: "foo",
            detect: false,
            header: false,
            delimiter: "|",
            columns: {
              col1: new Int32(),
              col2: new Utf8()
            }
          });
          await conn.query("DROP TABLE IF EXISTS foo");
          await conn.close();
          await adb2().dropFile("data.csv");
        });
        it("JSON row insert", async () => {
          await adb2().registerFileText(
            "rows.json",
            `[
                    { "col1": 1, "col2": "foo" },
                    { "col1": 2, "col2": "bar" },
                ]`
          );
          const conn = await adb2().connect();
          await conn.insertJSONFromPath("rows.json", { name: "rows" });
          await conn.query("DROP TABLE IF EXISTS rows");
          await conn.close();
          await adb2().dropFile("rows.json");
        });
        it("JSON column insert", async () => {
          await adb2().registerFileText(
            "columns.json",
            `{
                    "col1": [1, 2],
                    "col2": ["foo", "bar"]
                }`
          );
          const conn = await adb2().connect();
          await conn.insertJSONFromPath("columns.json", { name: "columns" });
          await conn.query("DROP TABLE IF EXISTS columns");
          await conn.close();
          await adb2().dropFile("columns.json");
        });
        it("Query result materialized", async () => {
          const conn = await adb2().connect();
          await conn.query(`
                SELECT * FROM generate_series(1, 100) t(v)
            `);
          await conn.close();
        });
        it("Query result streamed", async () => {
          const conn = await adb2().connect();
          for await (const batch of await conn.send(`
                SELECT * FROM generate_series(1, 100) t(v)
            `)) {
            expect(batch.numRows).toBeGreaterThan(0);
          }
          await conn.close();
        });
        it("Prepared statement materialized", async () => {
          const conn = await adb2().connect();
          const stmt = await conn.prepare(`SELECT v + ? FROM generate_series(0, 10000) as t(v);`);
          await stmt.query(234);
          await stmt.close();
          await conn.close();
        });
        it("Prepared statement streamed", async () => {
          const conn = await adb2().connect();
          const stmt = await conn.prepare(`SELECT v + ? FROM generate_series(0, 10000) as t(v);`);
          for await (const batch of await stmt.send(234)) {
            expect(batch.numRows).toBeGreaterThan(0);
          }
          await stmt.close();
          await conn.close();
        });
      });
    });
  }

  // test/regression/github_393.test.ts
  function test393(db2) {
    let conn = null;
    beforeEach(async () => {
      await db2().flushFiles();
    });
    afterEach(async () => {
      if (conn) {
        await conn.close();
        conn = null;
      }
      await db2().flushFiles();
      await db2().dropFiles();
    });
    describe("GitHub issues", () => {
      it("393", async () => {
        await db2().open({
          path: ":memory:",
          query: {
            castTimestampToDate: false
          }
        });
        conn = await db2().connect();
        const resultWithoutCast = await conn.query(`SELECT TIMESTAMP '1992-03-22 01:02:03' as ts`);
        expect(resultWithoutCast.toArray()[0]?.ts).toEqual(new Date(Date.UTC(1992, 2, 22, 1, 2, 3)).getTime());
        await db2().open({
          path: ":memory:",
          query: {
            castTimestampToDate: true
          }
        });
        conn = await db2().connect();
        const resultWithCast = await conn.query(`SELECT TIMESTAMP '1992-03-22 01:02:03' as ts`);
        expect(resultWithCast.toArray()[0]?.ts).toEqual(new Date(Date.UTC(1992, 2, 22, 1, 2, 3)));
      });
    });
  }

  // test/regression/github_448.test.ts
  function test448(db2) {
    let conn = null;
    beforeEach(async () => {
      await db2().flushFiles();
    });
    afterEach(async () => {
      if (conn) {
        await conn.close();
        conn = null;
      }
      await db2().flushFiles();
      await db2().dropFiles();
    });
    describe("GitHub issues", () => {
      it("448", async () => {
        conn = await db2().connect();
        await conn.query(`create temp table test448(i integer)`);
        await conn.query(`insert into test448 values (1),(2),(1)`);
        let result = await conn.query(`select * from test448`);
        expect(result.numCols).toBe(1);
        expect(result.numRows).toBe(3);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Int32Array([1, 2, 1]));
        result = await conn.query(`select histogram(i) from test448`);
        expect(result.numCols).toBe(1);
        expect(result.numRows).toBe(1);
        const array = result.getChildAt(0).toArray();
        expect(array.length).toEqual(1);
        expect(array[0].toString()).toEqual("{1: 2, 2: 1}");
      });
    });
  }

  // test/regression/github_470.test.ts
  function test470(db2) {
    let conn = null;
    beforeEach(async () => {
      await db2().flushFiles();
    });
    afterEach(async () => {
      if (conn) {
        await conn.close();
        conn = null;
      }
      await db2().flushFiles();
      await db2().dropFiles();
    });
    describe("GitHub issues", () => {
      it("470", async () => {
        await db2().open({
          path: ":memory:",
          query: {
            castDurationToTime64: false
          }
        });
        conn = await db2().connect();
        const result1 = await conn.query(`SELECT INTERVAL '3' MONTH AS interval`);
        expect(result1.toArray()[0]?.interval?.toString()).toEqual("0,3");
        await db2().open({
          path: ":memory:",
          query: {
            castDurationToTime64: true
          }
        });
        conn = await db2().connect();
        const resultWithCast = await conn.query(`SELECT INTERVAL '3' MONTH AS interval`);
        expect(resultWithCast.toArray()[0]?.interval?.toString()).toEqual("0,3");
        await db2().open({
          path: ":memory:",
          query: {}
        });
        conn = await db2().connect();
        const resultWithDefault = await conn.query(`SELECT INTERVAL '3' MONTH AS interval`);
        expect(resultWithDefault.toArray()[0]?.interval?.toString()).toEqual("0,3");
      });
    });
  }

  // test/regression/github_477.test.ts
  function test477(db2) {
    let conn = null;
    beforeEach(async () => {
      await db2().flushFiles();
    });
    afterEach(async () => {
      if (conn) {
        await conn.close();
        conn = null;
      }
      await db2().flushFiles();
      await db2().dropFiles();
    });
    describe("GitHub issues", () => {
      it("477", async () => {
        await db2().open({
          path: ":memory:",
          query: {}
        });
        conn = await db2().connect();
        const resultWithoutCast = await conn.query(`SELECT (-1.9)::DECIMAL(2,1) as decimal`);
        expect(resultWithoutCast.schema.fields[0].type.scale).toEqual(1);
        expect(resultWithoutCast.schema.fields[0].type.precision).toEqual(2);
        expect(resultWithoutCast.toArray()[0]?.decimal == -19).toBe(true);
        await db2().open({
          path: ":memory:",
          query: {
            castDecimalToDouble: true
          }
        });
        conn = await db2().connect();
        const resultWithCast = await conn.query(`SELECT (-1.9)::DECIMAL(2,1) as decimal`);
        expect(resultWithCast.toArray()[0]?.decimal).toEqual(-1.9000000000000001);
      });
    });
  }

  // test/regression/github_1467.test.ts
  function test1467(db2) {
    let conn = null;
    beforeEach(async () => {
      await db2().flushFiles();
    });
    afterEach(async () => {
      if (conn) {
        await conn.close();
        conn = null;
      }
      await db2().flushFiles();
      await db2().dropFiles();
    });
    describe("GitHub issues", () => {
      it("1467", async () => {
        await db2().open({
          path: ":memory:",
          query: {}
        });
        conn = await db2().connect();
        const resultWithoutCast = await conn.query(`select substring('\u{1F986}\u{1F986}\u{1F986}' from 3) AS result;`);
        expect(resultWithoutCast.toArray()[0]?.result).toEqual("\u{1F986}");
      });
    });
  }

  // test/regression/index.ts
  function testRegressionAsync(adb2) {
    test332(adb2);
    test334(adb2);
    test393(adb2);
    test448(adb2);
    test470(adb2);
    test477(adb2);
    test1467(adb2);
  }

  // test/udf.test.ts
  function testUDF(db2) {
    let conn;
    beforeEach(() => {
      conn = db2().connect();
    });
    afterEach(() => {
      conn.close();
      db2().flushFiles();
      db2().dropFiles();
    });
    describe("UDF", () => {
      it("simple", async () => {
        conn.createScalarFunction("jsudf", new Int32(), (a) => a);
        const result = conn.query(
          "SELECT max(jsudf(v::INTEGER))::INTEGER as foo FROM generate_series(1, 10000) as t(v)"
        );
        expect(result.numRows).toEqual(1);
        expect(result.numCols).toEqual(1);
        expect(result.getChildAt(0)?.length).toEqual(1);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Int32Array([1e4]));
      });
      it("double", async () => {
        conn.createScalarFunction("jsudf2", new Float64(), (a) => a);
        const result = conn.query(
          "SELECT max(jsudf2(v::DOUBLE))::DOUBLE as foo FROM generate_series(1, 10000) as t(v)"
        );
        expect(result.numRows).toEqual(1);
        expect(result.numCols).toEqual(1);
        expect(result.getChildAt(0)?.length).toEqual(1);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Float64Array([1e4]));
      });
      it("2 args", async () => {
        conn.createScalarFunction("jsudf3", new Int32(), (a, b) => a + b);
        const result = conn.query(
          "SELECT max(jsudf3(v::INTEGER, v::INTEGER))::INTEGER as foo FROM generate_series(1, 10000) as t(v)"
        );
        expect(result.numRows).toEqual(1);
        expect(result.numCols).toEqual(1);
        expect(result.getChildAt(0)?.length).toEqual(1);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Int32Array([2e4]));
      });
      it("3 args", async () => {
        conn.createScalarFunction("jsudf3args", new Int32(), (a, b, c) => a + b + c);
        const result = conn.query(
          "SELECT max(jsudf3args(v::INTEGER, v::INTEGER, v::INTEGER))::INTEGER as foo FROM generate_series(1, 10000) as t(v)"
        );
        expect(result.numRows).toEqual(1);
        expect(result.numCols).toEqual(1);
        expect(result.getChildAt(0)?.length).toEqual(1);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Int32Array([3e4]));
      });
      it("4 args", async () => {
        conn.createScalarFunction("jsudf4args", new Int32(), (a, b, c, d) => a + b + c + d);
        const result = conn.query(
          "SELECT max(jsudf4args(v::INTEGER, v::INTEGER, v::INTEGER, v::INTEGER))::INTEGER as foo FROM generate_series(1, 10000) as t(v)"
        );
        expect(result.numRows).toEqual(1);
        expect(result.numCols).toEqual(1);
        expect(result.getChildAt(0)?.length).toEqual(1);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Int32Array([4e4]));
      });
      it("noargs", async () => {
        conn.createScalarFunction("jsudf4", new Int32(), () => 42);
        const result = conn.query("SELECT max(jsudf4())::INTEGER as foo FROM generate_series(1, 10000) as t(v)");
        expect(result.numRows).toEqual(1);
        expect(result.numCols).toEqual(1);
        expect(result.getChildAt(0)?.length).toEqual(1);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Int32Array([42]));
      });
      it("withnulls", async () => {
        conn.createScalarFunction("jsudf5", new Int32(), (a) => a == null ? -100 : a);
        const result = conn.query(
          "SELECT min(jsudf5((case when v % 2 = 0 then v else null end)::INTEGER))::INTEGER as foo FROM generate_series(1, 10000) as t(v)"
        );
        expect(result.numRows).toEqual(1);
        expect(result.numCols).toEqual(1);
        expect(result.getChildAt(0)?.length).toEqual(1);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Int32Array([-100]));
      });
      it("stringparam", async () => {
        function jsudf6(s2) {
          return s2.length;
        }
        conn.createScalarFunction("jsudf6", new Int32(), jsudf6);
        const result = conn.query(
          "SELECT max(jsudf6('str_' || v))::INTEGER as foo FROM generate_series(1, 10000) as t(v)"
        );
        expect(result.numRows).toEqual(1);
        expect(result.numCols).toEqual(1);
        expect(result.getChildAt(0)?.length).toEqual(1);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Int32Array([9]));
      });
      it("stringparamnulls", async () => {
        function jsudf7(s2) {
          if (s2 == void 0) {
            return 0;
          } else {
            return s2.length;
          }
        }
        conn.createScalarFunction("jsudf7", new Int32(), jsudf7);
        const result = conn.query(
          "SELECT max(jsudf7((case when v % 2 = 0 then 'str_' || v else null end)::VARCHAR))::INTEGER as foo FROM generate_series(1, 10000) as t(v)"
        );
        expect(result.numRows).toEqual(1);
        expect(result.numCols).toEqual(1);
        expect(result.getChildAt(0)?.length).toEqual(1);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Int32Array([9]));
      });
      it("nullintreturn", async () => {
        conn.createScalarFunction("jsudf8", new Int32(), (a) => void 0);
        const result = conn.query(
          "SELECT max(COALESCE(jsudf8(v::INTEGER), 42))::INTEGER as foo FROM generate_series(1, 10000) as t(v)"
        );
        expect(result.numRows).toEqual(1);
        expect(result.numCols).toEqual(1);
        expect(result.getChildAt(0)?.length).toEqual(1);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Int32Array([42]));
      });
      it("stringreturn", async () => {
        conn.createScalarFunction("jsudf9", new Utf8(), (a) => "Hello " + a);
        const result = conn.query(
          "SELECT max(LENGTH(jsudf9(v::INTEGER)))::INTEGER as foo FROM generate_series(1, 10000) as t(v)"
        );
        expect(result.numRows).toEqual(1);
        expect(result.numCols).toEqual(1);
        expect(result.getChildAt(0)?.length).toEqual(1);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Int32Array([11]));
      });
      it("nullstringreturn", async () => {
        conn.createScalarFunction("jsudf10", new Utf8(), (a) => a % 2 == 0 ? "Hello" : void 0);
        const result = conn.query(
          "SELECT COUNT(jsudf10(v::INTEGER))::INTEGER as foo FROM generate_series(1, 10000) as t(v)"
        );
        expect(result.numRows).toEqual(1);
        expect(result.numCols).toEqual(1);
        expect(result.getChildAt(0)?.length).toEqual(1);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Int32Array([5e3]));
      });
      it("struct", async () => {
        conn.createScalarFunction("jsudf11", new Int32(), (a) => a.x == null ? -100 : a.x);
        const result = conn.query(
          `SELECT min(jsudf11({'x': (case when v % 2 = 0 then v else null end)::INTEGER, 'y': 42}))::INTEGER as foo FROM generate_series(1, 10000) as t(v)`
        );
        expect(result.numRows).toEqual(1);
        expect(result.numCols).toEqual(1);
        expect(result.getChildAt(0)?.length).toEqual(1);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Int32Array([-100]));
      });
      it("structnested", async () => {
        conn.createScalarFunction("jsudf12", new Int32(), (a) => a.x.y == null ? -100 : a.x.y);
        const result = conn.query(
          `SELECT min(jsudf12({'x': {'y': (case when v % 2 = 0 then v else null end)::INTEGER }, 'z': 42}))::INTEGER as foo FROM generate_series(1, 10000) as t(v)`
        );
        expect(result.numRows).toEqual(1);
        expect(result.numCols).toEqual(1);
        expect(result.getChildAt(0)?.length).toEqual(1);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Int32Array([-100]));
      });
      it("structnestednull", async () => {
        conn.createScalarFunction("jsudf13", new Int32(), (a) => a.x?.y == null ? -100 : a.x.y);
        const result = conn.query(
          `SELECT min(jsudf13({'x': (case when v % 2 = 0 then {'y': v::INTEGER } else null end), 'z': 42}))::INTEGER as foo FROM generate_series(1, 10000) as t(v)`
        );
        expect(result.numRows).toEqual(1);
        expect(result.numCols).toEqual(1);
        expect(result.getChildAt(0)?.length).toEqual(1);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Int32Array([-100]));
      });
    });
  }

  // test/index_browser.ts
  var DUCKDB_BUNDLES = {
    mvp: {
      mainModule: new URL("/static/duckdb-mvp.wasm", window.location.href).href,
      mainWorker: new URL("/static/duckdb-browser-mvp.worker.js", window.location.href).href
    },
    eh: {
      mainModule: new URL("/static/duckdb-eh.wasm", window.location.href).href,
      mainWorker: new URL("/static/duckdb-browser-eh.worker.js", window.location.href).href
    },
    coi: {
      mainModule: new URL("/static/duckdb-coi.wasm", window.location.href).href,
      mainWorker: new URL("/static/duckdb-browser-coi.worker.js", window.location.href).href,
      pthreadWorker: new URL("/static/duckdb-browser-coi.pthread.worker.js", window.location.href).href
    }
  };
  var DUCKDB_BUNDLE = null;
  describe("wasm check", () => {
    it("worker and wasm urls", async () => {
      if ((await getPlatformFeatures()).crossOriginIsolated && await exceptions() && await threads()) {
        expect(DUCKDB_BUNDLE.mainModule).toEqual(DUCKDB_BUNDLES.coi.mainModule);
        expect(DUCKDB_BUNDLE.mainWorker).toEqual(DUCKDB_BUNDLES.coi.mainWorker);
        expect(DUCKDB_BUNDLE.pthreadWorker).toEqual(DUCKDB_BUNDLES.coi.pthreadWorker);
      }
      if (await exceptions() && !await threads()) {
        expect(DUCKDB_BUNDLE.mainModule).toEqual(DUCKDB_BUNDLES.eh.mainModule);
        expect(DUCKDB_BUNDLE.mainWorker).toEqual(DUCKDB_BUNDLES.eh.mainWorker);
        expect(DUCKDB_BUNDLE.pthreadWorker).toEqual(null);
      }
      if (!await exceptions()) {
        expect(DUCKDB_BUNDLE.mainModule).toEqual(DUCKDB_BUNDLES.mvp.mainModule);
        expect(DUCKDB_BUNDLE.mainWorker).toEqual(DUCKDB_BUNDLES.mvp.mainWorker);
        expect(DUCKDB_BUNDLE.pthreadWorker).toEqual(null);
      }
    });
  });
  jasmine.DEFAULT_TIMEOUT_INTERVAL = 6e4;
  var resolveBuffer = async (url2) => {
    const req = await fetch(`/data${url2}`);
    if (!req.ok)
      return null;
    return new Uint8Array(await req.arrayBuffer());
  };
  var resolveData = async (url2) => {
    switch (url2) {
      case "/uni/all.zip":
        return await resolveBuffer("/uni/all.zip");
      case "/uni/assistenten.parquet":
        return await resolveBuffer("/uni/assistenten.parquet");
      case "/uni/studenten.parquet":
        return await resolveBuffer("/uni/studenten.parquet");
      case "/uni/hoeren.parquet":
        return await resolveBuffer("/uni/hoeren.parquet");
      case "/uni/vorlesungen.parquet":
        return await resolveBuffer("/uni/vorlesungen.parquet");
      case "/tpch/0_01/parquet/lineitem.parquet":
        return await resolveBuffer("/tpch/0_01/parquet/lineitem.parquet");
      default:
        return null;
    }
  };
  var db = null;
  var adb = null;
  var worker = null;
  beforeAll(async () => {
    const logger = new VoidLogger();
    db = await createDuckDB(DUCKDB_BUNDLES, logger, BROWSER_RUNTIME);
    await db.instantiate((_) => {
    });
    DUCKDB_BUNDLE = await selectBundle(DUCKDB_BUNDLES);
    worker = await createWorker(DUCKDB_BUNDLE.mainWorker);
    adb = new AsyncDuckDB(logger, worker);
    await adb.instantiate(DUCKDB_BUNDLE.mainModule, DUCKDB_BUNDLE.pthreadWorker);
  });
  afterAll(async () => {
    if (worker)
      worker.terminate();
  });
  var baseURL = window.location.origin;
  var dataURL = `${baseURL}/data`;
  testHTTPFS(() => db);
  testHTTPFSAsync(() => adb, resolveData, dataURL);
  testUDF(() => db);
  testTableNames(() => db);
  testTableNamesAsync(() => adb);
  testRegressionAsync(() => adb);
  testAllTypes(() => db);
  testAllTypesAsync(() => adb);
  testBindings(() => db, dataURL);
  testAsyncBindings(() => adb, dataURL, 4 /* HTTP */);
  testBatchStream(() => db);
  testAsyncBatchStream(() => adb);
  testFilesystem(() => adb, resolveData, dataURL, 4 /* HTTP */);
  testArrowInsert(() => db);
  testArrowInsertAsync(() => adb);
  testJSONInsert(() => db);
  testJSONInsertAsync(() => adb);
  testCSVInsert(() => db);
  testCSVInsertAsync(() => adb);
  testTokenization(() => db);
  testTokenizationAsync(() => adb);
})();
/*! Bundled license information:

js-sha256/src/sha256.js:
  (**
   * [js-sha256]{@link https://github.com/emn178/js-sha256}
   *
   * @version 0.11.0
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2014-2024
   * @license MIT
   *)
*/
//# sourceMappingURL=tests-browser.js.map
