"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// ../../node_modules/fast-glob/out/utils/array.js
var require_array = __commonJS({
  "../../node_modules/fast-glob/out/utils/array.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.splitWhen = exports2.flatten = void 0;
    function flatten(items) {
      return items.reduce((collection, item) => [].concat(collection, item), []);
    }
    exports2.flatten = flatten;
    function splitWhen(items, predicate) {
      const result = [[]];
      let groupIndex = 0;
      for (const item of items) {
        if (predicate(item)) {
          groupIndex++;
          result[groupIndex] = [];
        } else {
          result[groupIndex].push(item);
        }
      }
      return result;
    }
    exports2.splitWhen = splitWhen;
  }
});

// ../../node_modules/fast-glob/out/utils/errno.js
var require_errno = __commonJS({
  "../../node_modules/fast-glob/out/utils/errno.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isEnoentCodeError = void 0;
    function isEnoentCodeError(error) {
      return error.code === "ENOENT";
    }
    exports2.isEnoentCodeError = isEnoentCodeError;
  }
});

// ../../node_modules/fast-glob/out/utils/fs.js
var require_fs = __commonJS({
  "../../node_modules/fast-glob/out/utils/fs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createDirentFromStats = void 0;
    var DirentFromStats = class {
      constructor(name2, stats) {
        this.name = name2;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
      }
    };
    function createDirentFromStats(name2, stats) {
      return new DirentFromStats(name2, stats);
    }
    exports2.createDirentFromStats = createDirentFromStats;
  }
});

// ../../node_modules/fast-glob/out/utils/path.js
var require_path = __commonJS({
  "../../node_modules/fast-glob/out/utils/path.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.convertPosixPathToPattern = exports2.convertWindowsPathToPattern = exports2.convertPathToPattern = exports2.escapePosixPath = exports2.escapeWindowsPath = exports2.escape = exports2.removeLeadingDotSegment = exports2.makeAbsolute = exports2.unixify = void 0;
    var os = require("os");
    var path2 = require("path");
    var IS_WINDOWS_PLATFORM = os.platform() === "win32";
    var LEADING_DOT_SEGMENT_CHARACTERS_COUNT = 2;
    var POSIX_UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([()*?[\]{|}]|^!|[!+@](?=\()|\\(?![!()*+?@[\]{|}]))/g;
    var WINDOWS_UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([()[\]{}]|^!|[!+@](?=\())/g;
    var DOS_DEVICE_PATH_RE = /^\\\\([.?])/;
    var WINDOWS_BACKSLASHES_RE = /\\(?![!()+@[\]{}])/g;
    function unixify(filepath) {
      return filepath.replace(/\\/g, "/");
    }
    exports2.unixify = unixify;
    function makeAbsolute(cwd, filepath) {
      return path2.resolve(cwd, filepath);
    }
    exports2.makeAbsolute = makeAbsolute;
    function removeLeadingDotSegment(entry) {
      if (entry.charAt(0) === ".") {
        const secondCharactery = entry.charAt(1);
        if (secondCharactery === "/" || secondCharactery === "\\") {
          return entry.slice(LEADING_DOT_SEGMENT_CHARACTERS_COUNT);
        }
      }
      return entry;
    }
    exports2.removeLeadingDotSegment = removeLeadingDotSegment;
    exports2.escape = IS_WINDOWS_PLATFORM ? escapeWindowsPath : escapePosixPath;
    function escapeWindowsPath(pattern) {
      return pattern.replace(WINDOWS_UNESCAPED_GLOB_SYMBOLS_RE, "\\$2");
    }
    exports2.escapeWindowsPath = escapeWindowsPath;
    function escapePosixPath(pattern) {
      return pattern.replace(POSIX_UNESCAPED_GLOB_SYMBOLS_RE, "\\$2");
    }
    exports2.escapePosixPath = escapePosixPath;
    exports2.convertPathToPattern = IS_WINDOWS_PLATFORM ? convertWindowsPathToPattern : convertPosixPathToPattern;
    function convertWindowsPathToPattern(filepath) {
      return escapeWindowsPath(filepath).replace(DOS_DEVICE_PATH_RE, "//$1").replace(WINDOWS_BACKSLASHES_RE, "/");
    }
    exports2.convertWindowsPathToPattern = convertWindowsPathToPattern;
    function convertPosixPathToPattern(filepath) {
      return escapePosixPath(filepath);
    }
    exports2.convertPosixPathToPattern = convertPosixPathToPattern;
  }
});

// ../../node_modules/is-extglob/index.js
var require_is_extglob = __commonJS({
  "../../node_modules/is-extglob/index.js"(exports2, module2) {
    module2.exports = function isExtglob(str) {
      if (typeof str !== "string" || str === "") {
        return false;
      }
      var match;
      while (match = /(\\).|([@?!+*]\(.*\))/g.exec(str)) {
        if (match[2])
          return true;
        str = str.slice(match.index + match[0].length);
      }
      return false;
    };
  }
});

// ../../node_modules/is-glob/index.js
var require_is_glob = __commonJS({
  "../../node_modules/is-glob/index.js"(exports2, module2) {
    var isExtglob = require_is_extglob();
    var chars = { "{": "}", "(": ")", "[": "]" };
    var strictCheck = function(str) {
      if (str[0] === "!") {
        return true;
      }
      var index = 0;
      var pipeIndex = -2;
      var closeSquareIndex = -2;
      var closeCurlyIndex = -2;
      var closeParenIndex = -2;
      var backSlashIndex = -2;
      while (index < str.length) {
        if (str[index] === "*") {
          return true;
        }
        if (str[index + 1] === "?" && /[\].+)]/.test(str[index])) {
          return true;
        }
        if (closeSquareIndex !== -1 && str[index] === "[" && str[index + 1] !== "]") {
          if (closeSquareIndex < index) {
            closeSquareIndex = str.indexOf("]", index);
          }
          if (closeSquareIndex > index) {
            if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
              return true;
            }
            backSlashIndex = str.indexOf("\\", index);
            if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
              return true;
            }
          }
        }
        if (closeCurlyIndex !== -1 && str[index] === "{" && str[index + 1] !== "}") {
          closeCurlyIndex = str.indexOf("}", index);
          if (closeCurlyIndex > index) {
            backSlashIndex = str.indexOf("\\", index);
            if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {
              return true;
            }
          }
        }
        if (closeParenIndex !== -1 && str[index] === "(" && str[index + 1] === "?" && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ")") {
          closeParenIndex = str.indexOf(")", index);
          if (closeParenIndex > index) {
            backSlashIndex = str.indexOf("\\", index);
            if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
              return true;
            }
          }
        }
        if (pipeIndex !== -1 && str[index] === "(" && str[index + 1] !== "|") {
          if (pipeIndex < index) {
            pipeIndex = str.indexOf("|", index);
          }
          if (pipeIndex !== -1 && str[pipeIndex + 1] !== ")") {
            closeParenIndex = str.indexOf(")", pipeIndex);
            if (closeParenIndex > pipeIndex) {
              backSlashIndex = str.indexOf("\\", pipeIndex);
              if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
                return true;
              }
            }
          }
        }
        if (str[index] === "\\") {
          var open = str[index + 1];
          index += 2;
          var close = chars[open];
          if (close) {
            var n = str.indexOf(close, index);
            if (n !== -1) {
              index = n + 1;
            }
          }
          if (str[index] === "!") {
            return true;
          }
        } else {
          index++;
        }
      }
      return false;
    };
    var relaxedCheck = function(str) {
      if (str[0] === "!") {
        return true;
      }
      var index = 0;
      while (index < str.length) {
        if (/[*?{}()[\]]/.test(str[index])) {
          return true;
        }
        if (str[index] === "\\") {
          var open = str[index + 1];
          index += 2;
          var close = chars[open];
          if (close) {
            var n = str.indexOf(close, index);
            if (n !== -1) {
              index = n + 1;
            }
          }
          if (str[index] === "!") {
            return true;
          }
        } else {
          index++;
        }
      }
      return false;
    };
    module2.exports = function isGlob(str, options) {
      if (typeof str !== "string" || str === "") {
        return false;
      }
      if (isExtglob(str)) {
        return true;
      }
      var check = strictCheck;
      if (options && options.strict === false) {
        check = relaxedCheck;
      }
      return check(str);
    };
  }
});

// ../../node_modules/glob-parent/index.js
var require_glob_parent = __commonJS({
  "../../node_modules/glob-parent/index.js"(exports2, module2) {
    "use strict";
    var isGlob = require_is_glob();
    var pathPosixDirname = require("path").posix.dirname;
    var isWin32 = require("os").platform() === "win32";
    var slash = "/";
    var backslash = /\\/g;
    var enclosure = /[\{\[].*[\}\]]$/;
    var globby = /(^|[^\\])([\{\[]|\([^\)]+$)/;
    var escaped = /\\([\!\*\?\|\[\]\(\)\{\}])/g;
    module2.exports = function globParent(str, opts) {
      var options = Object.assign({ flipBackslashes: true }, opts);
      if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {
        str = str.replace(backslash, slash);
      }
      if (enclosure.test(str)) {
        str += slash;
      }
      str += "a";
      do {
        str = pathPosixDirname(str);
      } while (isGlob(str) || globby.test(str));
      return str.replace(escaped, "$1");
    };
  }
});

// ../../node_modules/braces/lib/utils.js
var require_utils = __commonJS({
  "../../node_modules/braces/lib/utils.js"(exports2) {
    "use strict";
    exports2.isInteger = (num) => {
      if (typeof num === "number") {
        return Number.isInteger(num);
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isInteger(Number(num));
      }
      return false;
    };
    exports2.find = (node, type) => node.nodes.find((node2) => node2.type === type);
    exports2.exceedsLimit = (min, max, step = 1, limit) => {
      if (limit === false)
        return false;
      if (!exports2.isInteger(min) || !exports2.isInteger(max))
        return false;
      return (Number(max) - Number(min)) / Number(step) >= limit;
    };
    exports2.escapeNode = (block, n = 0, type) => {
      let node = block.nodes[n];
      if (!node)
        return;
      if (type && node.type === type || node.type === "open" || node.type === "close") {
        if (node.escaped !== true) {
          node.value = "\\" + node.value;
          node.escaped = true;
        }
      }
    };
    exports2.encloseBrace = (node) => {
      if (node.type !== "brace")
        return false;
      if (node.commas >> 0 + node.ranges >> 0 === 0) {
        node.invalid = true;
        return true;
      }
      return false;
    };
    exports2.isInvalidBrace = (block) => {
      if (block.type !== "brace")
        return false;
      if (block.invalid === true || block.dollar)
        return true;
      if (block.commas >> 0 + block.ranges >> 0 === 0) {
        block.invalid = true;
        return true;
      }
      if (block.open !== true || block.close !== true) {
        block.invalid = true;
        return true;
      }
      return false;
    };
    exports2.isOpenOrClose = (node) => {
      if (node.type === "open" || node.type === "close") {
        return true;
      }
      return node.open === true || node.close === true;
    };
    exports2.reduce = (nodes) => nodes.reduce((acc, node) => {
      if (node.type === "text")
        acc.push(node.value);
      if (node.type === "range")
        node.type = "text";
      return acc;
    }, []);
    exports2.flatten = (...args2) => {
      const result = [];
      const flat = (arr) => {
        for (let i2 = 0; i2 < arr.length; i2++) {
          let ele = arr[i2];
          Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);
        }
        return result;
      };
      flat(args2);
      return result;
    };
  }
});

// ../../node_modules/braces/lib/stringify.js
var require_stringify = __commonJS({
  "../../node_modules/braces/lib/stringify.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    module2.exports = (ast, options = {}) => {
      let stringify = (node, parent = {}) => {
        let invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);
        let invalidNode = node.invalid === true && options.escapeInvalid === true;
        let output = "";
        if (node.value) {
          if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {
            return "\\" + node.value;
          }
          return node.value;
        }
        if (node.value) {
          return node.value;
        }
        if (node.nodes) {
          for (let child of node.nodes) {
            output += stringify(child);
          }
        }
        return output;
      };
      return stringify(ast);
    };
  }
});

// ../../node_modules/is-number/index.js
var require_is_number = __commonJS({
  "../../node_modules/is-number/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function(num) {
      if (typeof num === "number") {
        return num - num === 0;
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
      }
      return false;
    };
  }
});

// ../../node_modules/to-regex-range/index.js
var require_to_regex_range = __commonJS({
  "../../node_modules/to-regex-range/index.js"(exports2, module2) {
    "use strict";
    var isNumber = require_is_number();
    var toRegexRange = (min, max, options) => {
      if (isNumber(min) === false) {
        throw new TypeError("toRegexRange: expected the first argument to be a number");
      }
      if (max === void 0 || min === max) {
        return String(min);
      }
      if (isNumber(max) === false) {
        throw new TypeError("toRegexRange: expected the second argument to be a number.");
      }
      let opts = { relaxZeros: true, ...options };
      if (typeof opts.strictZeros === "boolean") {
        opts.relaxZeros = opts.strictZeros === false;
      }
      let relax = String(opts.relaxZeros);
      let shorthand = String(opts.shorthand);
      let capture = String(opts.capture);
      let wrap = String(opts.wrap);
      let cacheKey = min + ":" + max + "=" + relax + shorthand + capture + wrap;
      if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
        return toRegexRange.cache[cacheKey].result;
      }
      let a = Math.min(min, max);
      let b = Math.max(min, max);
      if (Math.abs(a - b) === 1) {
        let result = min + "|" + max;
        if (opts.capture) {
          return `(${result})`;
        }
        if (opts.wrap === false) {
          return result;
        }
        return `(?:${result})`;
      }
      let isPadded = hasPadding(min) || hasPadding(max);
      let state = { min, max, a, b };
      let positives = [];
      let negatives = [];
      if (isPadded) {
        state.isPadded = isPadded;
        state.maxLen = String(state.max).length;
      }
      if (a < 0) {
        let newMin = b < 0 ? Math.abs(b) : 1;
        negatives = splitToPatterns(newMin, Math.abs(a), state, opts);
        a = state.a = 0;
      }
      if (b >= 0) {
        positives = splitToPatterns(a, b, state, opts);
      }
      state.negatives = negatives;
      state.positives = positives;
      state.result = collatePatterns(negatives, positives, opts);
      if (opts.capture === true) {
        state.result = `(${state.result})`;
      } else if (opts.wrap !== false && positives.length + negatives.length > 1) {
        state.result = `(?:${state.result})`;
      }
      toRegexRange.cache[cacheKey] = state;
      return state.result;
    };
    function collatePatterns(neg, pos, options) {
      let onlyNegative = filterPatterns(neg, pos, "-", false, options) || [];
      let onlyPositive = filterPatterns(pos, neg, "", false, options) || [];
      let intersected = filterPatterns(neg, pos, "-?", true, options) || [];
      let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
      return subpatterns.join("|");
    }
    function splitToRanges(min, max) {
      let nines = 1;
      let zeros = 1;
      let stop2 = countNines(min, nines);
      let stops = /* @__PURE__ */ new Set([max]);
      while (min <= stop2 && stop2 <= max) {
        stops.add(stop2);
        nines += 1;
        stop2 = countNines(min, nines);
      }
      stop2 = countZeros(max + 1, zeros) - 1;
      while (min < stop2 && stop2 <= max) {
        stops.add(stop2);
        zeros += 1;
        stop2 = countZeros(max + 1, zeros) - 1;
      }
      stops = [...stops];
      stops.sort(compare);
      return stops;
    }
    function rangeToPattern(start2, stop2, options) {
      if (start2 === stop2) {
        return { pattern: start2, count: [], digits: 0 };
      }
      let zipped = zip(start2, stop2);
      let digits = zipped.length;
      let pattern = "";
      let count = 0;
      for (let i2 = 0; i2 < digits; i2++) {
        let [startDigit, stopDigit] = zipped[i2];
        if (startDigit === stopDigit) {
          pattern += startDigit;
        } else if (startDigit !== "0" || stopDigit !== "9") {
          pattern += toCharacterClass(startDigit, stopDigit, options);
        } else {
          count++;
        }
      }
      if (count) {
        pattern += options.shorthand === true ? "\\d" : "[0-9]";
      }
      return { pattern, count: [count], digits };
    }
    function splitToPatterns(min, max, tok, options) {
      let ranges = splitToRanges(min, max);
      let tokens = [];
      let start2 = min;
      let prev;
      for (let i2 = 0; i2 < ranges.length; i2++) {
        let max2 = ranges[i2];
        let obj = rangeToPattern(String(start2), String(max2), options);
        let zeros = "";
        if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
          if (prev.count.length > 1) {
            prev.count.pop();
          }
          prev.count.push(obj.count[0]);
          prev.string = prev.pattern + toQuantifier(prev.count);
          start2 = max2 + 1;
          continue;
        }
        if (tok.isPadded) {
          zeros = padZeros(max2, tok, options);
        }
        obj.string = zeros + obj.pattern + toQuantifier(obj.count);
        tokens.push(obj);
        start2 = max2 + 1;
        prev = obj;
      }
      return tokens;
    }
    function filterPatterns(arr, comparison, prefix, intersection, options) {
      let result = [];
      for (let ele of arr) {
        let { string } = ele;
        if (!intersection && !contains(comparison, "string", string)) {
          result.push(prefix + string);
        }
        if (intersection && contains(comparison, "string", string)) {
          result.push(prefix + string);
        }
      }
      return result;
    }
    function zip(a, b) {
      let arr = [];
      for (let i2 = 0; i2 < a.length; i2++)
        arr.push([a[i2], b[i2]]);
      return arr;
    }
    function compare(a, b) {
      return a > b ? 1 : b > a ? -1 : 0;
    }
    function contains(arr, key, val) {
      return arr.some((ele) => ele[key] === val);
    }
    function countNines(min, len2) {
      return Number(String(min).slice(0, -len2) + "9".repeat(len2));
    }
    function countZeros(integer, zeros) {
      return integer - integer % Math.pow(10, zeros);
    }
    function toQuantifier(digits) {
      let [start2 = 0, stop2 = ""] = digits;
      if (stop2 || start2 > 1) {
        return `{${start2 + (stop2 ? "," + stop2 : "")}}`;
      }
      return "";
    }
    function toCharacterClass(a, b, options) {
      return `[${a}${b - a === 1 ? "" : "-"}${b}]`;
    }
    function hasPadding(str) {
      return /^-?(0+)\d/.test(str);
    }
    function padZeros(value, tok, options) {
      if (!tok.isPadded) {
        return value;
      }
      let diff = Math.abs(tok.maxLen - String(value).length);
      let relax = options.relaxZeros !== false;
      switch (diff) {
        case 0:
          return "";
        case 1:
          return relax ? "0?" : "0";
        case 2:
          return relax ? "0{0,2}" : "00";
        default: {
          return relax ? `0{0,${diff}}` : `0{${diff}}`;
        }
      }
    }
    toRegexRange.cache = {};
    toRegexRange.clearCache = () => toRegexRange.cache = {};
    module2.exports = toRegexRange;
  }
});

// ../../node_modules/fill-range/index.js
var require_fill_range = __commonJS({
  "../../node_modules/fill-range/index.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var toRegexRange = require_to_regex_range();
    var isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    var transform = (toNumber) => {
      return (value) => toNumber === true ? Number(value) : String(value);
    };
    var isValidValue = (value) => {
      return typeof value === "number" || typeof value === "string" && value !== "";
    };
    var isNumber = (num) => Number.isInteger(+num);
    var zeros = (input) => {
      let value = `${input}`;
      let index = -1;
      if (value[0] === "-")
        value = value.slice(1);
      if (value === "0")
        return false;
      while (value[++index] === "0")
        ;
      return index > 0;
    };
    var stringify = (start2, end, options) => {
      if (typeof start2 === "string" || typeof end === "string") {
        return true;
      }
      return options.stringify === true;
    };
    var pad = (input, maxLength, toNumber) => {
      if (maxLength > 0) {
        let dash = input[0] === "-" ? "-" : "";
        if (dash)
          input = input.slice(1);
        input = dash + input.padStart(dash ? maxLength - 1 : maxLength, "0");
      }
      if (toNumber === false) {
        return String(input);
      }
      return input;
    };
    var toMaxLen = (input, maxLength) => {
      let negative = input[0] === "-" ? "-" : "";
      if (negative) {
        input = input.slice(1);
        maxLength--;
      }
      while (input.length < maxLength)
        input = "0" + input;
      return negative ? "-" + input : input;
    };
    var toSequence = (parts2, options) => {
      parts2.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
      parts2.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
      let prefix = options.capture ? "" : "?:";
      let positives = "";
      let negatives = "";
      let result;
      if (parts2.positives.length) {
        positives = parts2.positives.join("|");
      }
      if (parts2.negatives.length) {
        negatives = `-(${prefix}${parts2.negatives.join("|")})`;
      }
      if (positives && negatives) {
        result = `${positives}|${negatives}`;
      } else {
        result = positives || negatives;
      }
      if (options.wrap) {
        return `(${prefix}${result})`;
      }
      return result;
    };
    var toRange = (a, b, isNumbers, options) => {
      if (isNumbers) {
        return toRegexRange(a, b, { wrap: false, ...options });
      }
      let start2 = String.fromCharCode(a);
      if (a === b)
        return start2;
      let stop2 = String.fromCharCode(b);
      return `[${start2}-${stop2}]`;
    };
    var toRegex = (start2, end, options) => {
      if (Array.isArray(start2)) {
        let wrap = options.wrap === true;
        let prefix = options.capture ? "" : "?:";
        return wrap ? `(${prefix}${start2.join("|")})` : start2.join("|");
      }
      return toRegexRange(start2, end, options);
    };
    var rangeError = (...args2) => {
      return new RangeError("Invalid range arguments: " + util.inspect(...args2));
    };
    var invalidRange = (start2, end, options) => {
      if (options.strictRanges === true)
        throw rangeError([start2, end]);
      return [];
    };
    var invalidStep = (step, options) => {
      if (options.strictRanges === true) {
        throw new TypeError(`Expected step "${step}" to be a number`);
      }
      return [];
    };
    var fillNumbers = (start2, end, step = 1, options = {}) => {
      let a = Number(start2);
      let b = Number(end);
      if (!Number.isInteger(a) || !Number.isInteger(b)) {
        if (options.strictRanges === true)
          throw rangeError([start2, end]);
        return [];
      }
      if (a === 0)
        a = 0;
      if (b === 0)
        b = 0;
      let descending = a > b;
      let startString = String(start2);
      let endString = String(end);
      let stepString = String(step);
      step = Math.max(Math.abs(step), 1);
      let padded = zeros(startString) || zeros(endString) || zeros(stepString);
      let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
      let toNumber = padded === false && stringify(start2, end, options) === false;
      let format = options.transform || transform(toNumber);
      if (options.toRegex && step === 1) {
        return toRange(toMaxLen(start2, maxLen), toMaxLen(end, maxLen), true, options);
      }
      let parts2 = { negatives: [], positives: [] };
      let push = (num) => parts2[num < 0 ? "negatives" : "positives"].push(Math.abs(num));
      let range = [];
      let index = 0;
      while (descending ? a >= b : a <= b) {
        if (options.toRegex === true && step > 1) {
          push(a);
        } else {
          range.push(pad(format(a, index), maxLen, toNumber));
        }
        a = descending ? a - step : a + step;
        index++;
      }
      if (options.toRegex === true) {
        return step > 1 ? toSequence(parts2, options) : toRegex(range, null, { wrap: false, ...options });
      }
      return range;
    };
    var fillLetters = (start2, end, step = 1, options = {}) => {
      if (!isNumber(start2) && start2.length > 1 || !isNumber(end) && end.length > 1) {
        return invalidRange(start2, end, options);
      }
      let format = options.transform || ((val) => String.fromCharCode(val));
      let a = `${start2}`.charCodeAt(0);
      let b = `${end}`.charCodeAt(0);
      let descending = a > b;
      let min = Math.min(a, b);
      let max = Math.max(a, b);
      if (options.toRegex && step === 1) {
        return toRange(min, max, false, options);
      }
      let range = [];
      let index = 0;
      while (descending ? a >= b : a <= b) {
        range.push(format(a, index));
        a = descending ? a - step : a + step;
        index++;
      }
      if (options.toRegex === true) {
        return toRegex(range, null, { wrap: false, options });
      }
      return range;
    };
    var fill = (start2, end, step, options = {}) => {
      if (end == null && isValidValue(start2)) {
        return [start2];
      }
      if (!isValidValue(start2) || !isValidValue(end)) {
        return invalidRange(start2, end, options);
      }
      if (typeof step === "function") {
        return fill(start2, end, 1, { transform: step });
      }
      if (isObject(step)) {
        return fill(start2, end, 0, step);
      }
      let opts = { ...options };
      if (opts.capture === true)
        opts.wrap = true;
      step = step || opts.step || 1;
      if (!isNumber(step)) {
        if (step != null && !isObject(step))
          return invalidStep(step, opts);
        return fill(start2, end, 1, step);
      }
      if (isNumber(start2) && isNumber(end)) {
        return fillNumbers(start2, end, step, opts);
      }
      return fillLetters(start2, end, Math.max(Math.abs(step), 1), opts);
    };
    module2.exports = fill;
  }
});

// ../../node_modules/braces/lib/compile.js
var require_compile = __commonJS({
  "../../node_modules/braces/lib/compile.js"(exports2, module2) {
    "use strict";
    var fill = require_fill_range();
    var utils = require_utils();
    var compile = (ast, options = {}) => {
      let walk = (node, parent = {}) => {
        let invalidBlock = utils.isInvalidBrace(parent);
        let invalidNode = node.invalid === true && options.escapeInvalid === true;
        let invalid = invalidBlock === true || invalidNode === true;
        let prefix = options.escapeInvalid === true ? "\\" : "";
        let output = "";
        if (node.isOpen === true) {
          return prefix + node.value;
        }
        if (node.isClose === true) {
          return prefix + node.value;
        }
        if (node.type === "open") {
          return invalid ? prefix + node.value : "(";
        }
        if (node.type === "close") {
          return invalid ? prefix + node.value : ")";
        }
        if (node.type === "comma") {
          return node.prev.type === "comma" ? "" : invalid ? node.value : "|";
        }
        if (node.value) {
          return node.value;
        }
        if (node.nodes && node.ranges > 0) {
          let args2 = utils.reduce(node.nodes);
          let range = fill(...args2, { ...options, wrap: false, toRegex: true });
          if (range.length !== 0) {
            return args2.length > 1 && range.length > 1 ? `(${range})` : range;
          }
        }
        if (node.nodes) {
          for (let child of node.nodes) {
            output += walk(child, node);
          }
        }
        return output;
      };
      return walk(ast);
    };
    module2.exports = compile;
  }
});

// ../../node_modules/braces/lib/expand.js
var require_expand = __commonJS({
  "../../node_modules/braces/lib/expand.js"(exports2, module2) {
    "use strict";
    var fill = require_fill_range();
    var stringify = require_stringify();
    var utils = require_utils();
    var append = (queue = "", stash = "", enclose = false) => {
      let result = [];
      queue = [].concat(queue);
      stash = [].concat(stash);
      if (!stash.length)
        return queue;
      if (!queue.length) {
        return enclose ? utils.flatten(stash).map((ele) => `{${ele}}`) : stash;
      }
      for (let item of queue) {
        if (Array.isArray(item)) {
          for (let value of item) {
            result.push(append(value, stash, enclose));
          }
        } else {
          for (let ele of stash) {
            if (enclose === true && typeof ele === "string")
              ele = `{${ele}}`;
            result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);
          }
        }
      }
      return utils.flatten(result);
    };
    var expand = (ast, options = {}) => {
      let rangeLimit = options.rangeLimit === void 0 ? 1e3 : options.rangeLimit;
      let walk = (node, parent = {}) => {
        node.queue = [];
        let p = parent;
        let q = parent.queue;
        while (p.type !== "brace" && p.type !== "root" && p.parent) {
          p = p.parent;
          q = p.queue;
        }
        if (node.invalid || node.dollar) {
          q.push(append(q.pop(), stringify(node, options)));
          return;
        }
        if (node.type === "brace" && node.invalid !== true && node.nodes.length === 2) {
          q.push(append(q.pop(), ["{}"]));
          return;
        }
        if (node.nodes && node.ranges > 0) {
          let args2 = utils.reduce(node.nodes);
          if (utils.exceedsLimit(...args2, options.step, rangeLimit)) {
            throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
          }
          let range = fill(...args2, options);
          if (range.length === 0) {
            range = stringify(node, options);
          }
          q.push(append(q.pop(), range));
          node.nodes = [];
          return;
        }
        let enclose = utils.encloseBrace(node);
        let queue = node.queue;
        let block = node;
        while (block.type !== "brace" && block.type !== "root" && block.parent) {
          block = block.parent;
          queue = block.queue;
        }
        for (let i2 = 0; i2 < node.nodes.length; i2++) {
          let child = node.nodes[i2];
          if (child.type === "comma" && node.type === "brace") {
            if (i2 === 1)
              queue.push("");
            queue.push("");
            continue;
          }
          if (child.type === "close") {
            q.push(append(q.pop(), queue, enclose));
            continue;
          }
          if (child.value && child.type !== "open") {
            queue.push(append(queue.pop(), child.value));
            continue;
          }
          if (child.nodes) {
            walk(child, node);
          }
        }
        return queue;
      };
      return utils.flatten(walk(ast));
    };
    module2.exports = expand;
  }
});

// ../../node_modules/braces/lib/constants.js
var require_constants = __commonJS({
  "../../node_modules/braces/lib/constants.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      MAX_LENGTH: 1024 * 64,
      // Digits
      CHAR_0: "0",
      /* 0 */
      CHAR_9: "9",
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: "A",
      /* A */
      CHAR_LOWERCASE_A: "a",
      /* a */
      CHAR_UPPERCASE_Z: "Z",
      /* Z */
      CHAR_LOWERCASE_Z: "z",
      /* z */
      CHAR_LEFT_PARENTHESES: "(",
      /* ( */
      CHAR_RIGHT_PARENTHESES: ")",
      /* ) */
      CHAR_ASTERISK: "*",
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: "&",
      /* & */
      CHAR_AT: "@",
      /* @ */
      CHAR_BACKSLASH: "\\",
      /* \ */
      CHAR_BACKTICK: "`",
      /* ` */
      CHAR_CARRIAGE_RETURN: "\r",
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: "^",
      /* ^ */
      CHAR_COLON: ":",
      /* : */
      CHAR_COMMA: ",",
      /* , */
      CHAR_DOLLAR: "$",
      /* . */
      CHAR_DOT: ".",
      /* . */
      CHAR_DOUBLE_QUOTE: '"',
      /* " */
      CHAR_EQUAL: "=",
      /* = */
      CHAR_EXCLAMATION_MARK: "!",
      /* ! */
      CHAR_FORM_FEED: "\f",
      /* \f */
      CHAR_FORWARD_SLASH: "/",
      /* / */
      CHAR_HASH: "#",
      /* # */
      CHAR_HYPHEN_MINUS: "-",
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: "<",
      /* < */
      CHAR_LEFT_CURLY_BRACE: "{",
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: "[",
      /* [ */
      CHAR_LINE_FEED: "\n",
      /* \n */
      CHAR_NO_BREAK_SPACE: "\xA0",
      /* \u00A0 */
      CHAR_PERCENT: "%",
      /* % */
      CHAR_PLUS: "+",
      /* + */
      CHAR_QUESTION_MARK: "?",
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: ">",
      /* > */
      CHAR_RIGHT_CURLY_BRACE: "}",
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: "]",
      /* ] */
      CHAR_SEMICOLON: ";",
      /* ; */
      CHAR_SINGLE_QUOTE: "'",
      /* ' */
      CHAR_SPACE: " ",
      /*   */
      CHAR_TAB: "	",
      /* \t */
      CHAR_UNDERSCORE: "_",
      /* _ */
      CHAR_VERTICAL_LINE: "|",
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
      /* \uFEFF */
    };
  }
});

// ../../node_modules/braces/lib/parse.js
var require_parse = __commonJS({
  "../../node_modules/braces/lib/parse.js"(exports2, module2) {
    "use strict";
    var stringify = require_stringify();
    var {
      MAX_LENGTH,
      CHAR_BACKSLASH,
      /* \ */
      CHAR_BACKTICK,
      /* ` */
      CHAR_COMMA,
      /* , */
      CHAR_DOT,
      /* . */
      CHAR_LEFT_PARENTHESES,
      /* ( */
      CHAR_RIGHT_PARENTHESES,
      /* ) */
      CHAR_LEFT_CURLY_BRACE,
      /* { */
      CHAR_RIGHT_CURLY_BRACE,
      /* } */
      CHAR_LEFT_SQUARE_BRACKET,
      /* [ */
      CHAR_RIGHT_SQUARE_BRACKET,
      /* ] */
      CHAR_DOUBLE_QUOTE,
      /* " */
      CHAR_SINGLE_QUOTE,
      /* ' */
      CHAR_NO_BREAK_SPACE,
      CHAR_ZERO_WIDTH_NOBREAK_SPACE
    } = require_constants();
    var parse = (input, options = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      let opts = options || {};
      let max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      if (input.length > max) {
        throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);
      }
      let ast = { type: "root", input, nodes: [] };
      let stack = [ast];
      let block = ast;
      let prev = ast;
      let brackets = 0;
      let length = input.length;
      let index = 0;
      let depth = 0;
      let value;
      let memo = {};
      const advance = () => input[index++];
      const push = (node) => {
        if (node.type === "text" && prev.type === "dot") {
          prev.type = "text";
        }
        if (prev && prev.type === "text" && node.type === "text") {
          prev.value += node.value;
          return;
        }
        block.nodes.push(node);
        node.parent = block;
        node.prev = prev;
        prev = node;
        return node;
      };
      push({ type: "bos" });
      while (index < length) {
        block = stack[stack.length - 1];
        value = advance();
        if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
          continue;
        }
        if (value === CHAR_BACKSLASH) {
          push({ type: "text", value: (options.keepEscaping ? value : "") + advance() });
          continue;
        }
        if (value === CHAR_RIGHT_SQUARE_BRACKET) {
          push({ type: "text", value: "\\" + value });
          continue;
        }
        if (value === CHAR_LEFT_SQUARE_BRACKET) {
          brackets++;
          let closed = true;
          let next;
          while (index < length && (next = advance())) {
            value += next;
            if (next === CHAR_LEFT_SQUARE_BRACKET) {
              brackets++;
              continue;
            }
            if (next === CHAR_BACKSLASH) {
              value += advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              brackets--;
              if (brackets === 0) {
                break;
              }
            }
          }
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_LEFT_PARENTHESES) {
          block = push({ type: "paren", nodes: [] });
          stack.push(block);
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_RIGHT_PARENTHESES) {
          if (block.type !== "paren") {
            push({ type: "text", value });
            continue;
          }
          block = stack.pop();
          push({ type: "text", value });
          block = stack[stack.length - 1];
          continue;
        }
        if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
          let open = value;
          let next;
          if (options.keepQuotes !== true) {
            value = "";
          }
          while (index < length && (next = advance())) {
            if (next === CHAR_BACKSLASH) {
              value += next + advance();
              continue;
            }
            if (next === open) {
              if (options.keepQuotes === true)
                value += next;
              break;
            }
            value += next;
          }
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_LEFT_CURLY_BRACE) {
          depth++;
          let dollar = prev.value && prev.value.slice(-1) === "$" || block.dollar === true;
          let brace = {
            type: "brace",
            open: true,
            close: false,
            dollar,
            depth,
            commas: 0,
            ranges: 0,
            nodes: []
          };
          block = push(brace);
          stack.push(block);
          push({ type: "open", value });
          continue;
        }
        if (value === CHAR_RIGHT_CURLY_BRACE) {
          if (block.type !== "brace") {
            push({ type: "text", value });
            continue;
          }
          let type = "close";
          block = stack.pop();
          block.close = true;
          push({ type, value });
          depth--;
          block = stack[stack.length - 1];
          continue;
        }
        if (value === CHAR_COMMA && depth > 0) {
          if (block.ranges > 0) {
            block.ranges = 0;
            let open = block.nodes.shift();
            block.nodes = [open, { type: "text", value: stringify(block) }];
          }
          push({ type: "comma", value });
          block.commas++;
          continue;
        }
        if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
          let siblings = block.nodes;
          if (depth === 0 || siblings.length === 0) {
            push({ type: "text", value });
            continue;
          }
          if (prev.type === "dot") {
            block.range = [];
            prev.value += value;
            prev.type = "range";
            if (block.nodes.length !== 3 && block.nodes.length !== 5) {
              block.invalid = true;
              block.ranges = 0;
              prev.type = "text";
              continue;
            }
            block.ranges++;
            block.args = [];
            continue;
          }
          if (prev.type === "range") {
            siblings.pop();
            let before = siblings[siblings.length - 1];
            before.value += prev.value + value;
            prev = before;
            block.ranges--;
            continue;
          }
          push({ type: "dot", value });
          continue;
        }
        push({ type: "text", value });
      }
      do {
        block = stack.pop();
        if (block.type !== "root") {
          block.nodes.forEach((node) => {
            if (!node.nodes) {
              if (node.type === "open")
                node.isOpen = true;
              if (node.type === "close")
                node.isClose = true;
              if (!node.nodes)
                node.type = "text";
              node.invalid = true;
            }
          });
          let parent = stack[stack.length - 1];
          let index2 = parent.nodes.indexOf(block);
          parent.nodes.splice(index2, 1, ...block.nodes);
        }
      } while (stack.length > 0);
      push({ type: "eos" });
      return ast;
    };
    module2.exports = parse;
  }
});

// ../../node_modules/braces/index.js
var require_braces = __commonJS({
  "../../node_modules/braces/index.js"(exports2, module2) {
    "use strict";
    var stringify = require_stringify();
    var compile = require_compile();
    var expand = require_expand();
    var parse = require_parse();
    var braces = (input, options = {}) => {
      let output = [];
      if (Array.isArray(input)) {
        for (let pattern of input) {
          let result = braces.create(pattern, options);
          if (Array.isArray(result)) {
            output.push(...result);
          } else {
            output.push(result);
          }
        }
      } else {
        output = [].concat(braces.create(input, options));
      }
      if (options && options.expand === true && options.nodupes === true) {
        output = [...new Set(output)];
      }
      return output;
    };
    braces.parse = (input, options = {}) => parse(input, options);
    braces.stringify = (input, options = {}) => {
      if (typeof input === "string") {
        return stringify(braces.parse(input, options), options);
      }
      return stringify(input, options);
    };
    braces.compile = (input, options = {}) => {
      if (typeof input === "string") {
        input = braces.parse(input, options);
      }
      return compile(input, options);
    };
    braces.expand = (input, options = {}) => {
      if (typeof input === "string") {
        input = braces.parse(input, options);
      }
      let result = expand(input, options);
      if (options.noempty === true) {
        result = result.filter(Boolean);
      }
      if (options.nodupes === true) {
        result = [...new Set(result)];
      }
      return result;
    };
    braces.create = (input, options = {}) => {
      if (input === "" || input.length < 3) {
        return [input];
      }
      return options.expand !== true ? braces.compile(input, options) : braces.expand(input, options);
    };
    module2.exports = braces;
  }
});

// ../../node_modules/picomatch/lib/constants.js
var require_constants2 = __commonJS({
  "../../node_modules/picomatch/lib/constants.js"(exports2, module2) {
    "use strict";
    var path2 = require("path");
    var WIN_SLASH = "\\\\/";
    var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
    var DOT_LITERAL = "\\.";
    var PLUS_LITERAL = "\\+";
    var QMARK_LITERAL = "\\?";
    var SLASH_LITERAL = "\\/";
    var ONE_CHAR = "(?=.)";
    var QMARK = "[^/]";
    var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
    var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
    var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
    var NO_DOT = `(?!${DOT_LITERAL})`;
    var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
    var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
    var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
    var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
    var STAR = `${QMARK}*?`;
    var POSIX_CHARS = {
      DOT_LITERAL,
      PLUS_LITERAL,
      QMARK_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      QMARK,
      END_ANCHOR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR
    };
    var WINDOWS_CHARS = {
      ...POSIX_CHARS,
      SLASH_LITERAL: `[${WIN_SLASH}]`,
      QMARK: WIN_NO_SLASH,
      STAR: `${WIN_NO_SLASH}*?`,
      DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
      NO_DOT: `(?!${DOT_LITERAL})`,
      NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
      NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
      START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
      END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
    };
    var POSIX_REGEX_SOURCE = {
      alnum: "a-zA-Z0-9",
      alpha: "a-zA-Z",
      ascii: "\\x00-\\x7F",
      blank: " \\t",
      cntrl: "\\x00-\\x1F\\x7F",
      digit: "0-9",
      graph: "\\x21-\\x7E",
      lower: "a-z",
      print: "\\x20-\\x7E ",
      punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
      space: " \\t\\r\\n\\v\\f",
      upper: "A-Z",
      word: "A-Za-z0-9_",
      xdigit: "A-Fa-f0-9"
    };
    module2.exports = {
      MAX_LENGTH: 1024 * 64,
      POSIX_REGEX_SOURCE,
      // regular expressions
      REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
      REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
      REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
      REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
      REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
      REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
      // Replace globs with equivalent patterns to reduce parsing time.
      REPLACEMENTS: {
        "***": "*",
        "**/**": "**",
        "**/**/**": "**"
      },
      // Digits
      CHAR_0: 48,
      /* 0 */
      CHAR_9: 57,
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: 65,
      /* A */
      CHAR_LOWERCASE_A: 97,
      /* a */
      CHAR_UPPERCASE_Z: 90,
      /* Z */
      CHAR_LOWERCASE_Z: 122,
      /* z */
      CHAR_LEFT_PARENTHESES: 40,
      /* ( */
      CHAR_RIGHT_PARENTHESES: 41,
      /* ) */
      CHAR_ASTERISK: 42,
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: 38,
      /* & */
      CHAR_AT: 64,
      /* @ */
      CHAR_BACKWARD_SLASH: 92,
      /* \ */
      CHAR_CARRIAGE_RETURN: 13,
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: 94,
      /* ^ */
      CHAR_COLON: 58,
      /* : */
      CHAR_COMMA: 44,
      /* , */
      CHAR_DOT: 46,
      /* . */
      CHAR_DOUBLE_QUOTE: 34,
      /* " */
      CHAR_EQUAL: 61,
      /* = */
      CHAR_EXCLAMATION_MARK: 33,
      /* ! */
      CHAR_FORM_FEED: 12,
      /* \f */
      CHAR_FORWARD_SLASH: 47,
      /* / */
      CHAR_GRAVE_ACCENT: 96,
      /* ` */
      CHAR_HASH: 35,
      /* # */
      CHAR_HYPHEN_MINUS: 45,
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: 60,
      /* < */
      CHAR_LEFT_CURLY_BRACE: 123,
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: 91,
      /* [ */
      CHAR_LINE_FEED: 10,
      /* \n */
      CHAR_NO_BREAK_SPACE: 160,
      /* \u00A0 */
      CHAR_PERCENT: 37,
      /* % */
      CHAR_PLUS: 43,
      /* + */
      CHAR_QUESTION_MARK: 63,
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: 62,
      /* > */
      CHAR_RIGHT_CURLY_BRACE: 125,
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: 93,
      /* ] */
      CHAR_SEMICOLON: 59,
      /* ; */
      CHAR_SINGLE_QUOTE: 39,
      /* ' */
      CHAR_SPACE: 32,
      /*   */
      CHAR_TAB: 9,
      /* \t */
      CHAR_UNDERSCORE: 95,
      /* _ */
      CHAR_VERTICAL_LINE: 124,
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
      /* \uFEFF */
      SEP: path2.sep,
      /**
       * Create EXTGLOB_CHARS
       */
      extglobChars(chars) {
        return {
          "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})` },
          "?": { type: "qmark", open: "(?:", close: ")?" },
          "+": { type: "plus", open: "(?:", close: ")+" },
          "*": { type: "star", open: "(?:", close: ")*" },
          "@": { type: "at", open: "(?:", close: ")" }
        };
      },
      /**
       * Create GLOB_CHARS
       */
      globChars(win32) {
        return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
      }
    };
  }
});

// ../../node_modules/picomatch/lib/utils.js
var require_utils2 = __commonJS({
  "../../node_modules/picomatch/lib/utils.js"(exports2) {
    "use strict";
    var path2 = require("path");
    var win32 = process.platform === "win32";
    var {
      REGEX_BACKSLASH,
      REGEX_REMOVE_BACKSLASH,
      REGEX_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_GLOBAL
    } = require_constants2();
    exports2.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    exports2.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
    exports2.isRegexChar = (str) => str.length === 1 && exports2.hasRegexChars(str);
    exports2.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
    exports2.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
    exports2.removeBackslashes = (str) => {
      return str.replace(REGEX_REMOVE_BACKSLASH, (match) => {
        return match === "\\" ? "" : match;
      });
    };
    exports2.supportsLookbehinds = () => {
      const segs = process.version.slice(1).split(".").map(Number);
      if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
        return true;
      }
      return false;
    };
    exports2.isWindows = (options) => {
      if (options && typeof options.windows === "boolean") {
        return options.windows;
      }
      return win32 === true || path2.sep === "\\";
    };
    exports2.escapeLast = (input, char, lastIdx) => {
      const idx = input.lastIndexOf(char, lastIdx);
      if (idx === -1)
        return input;
      if (input[idx - 1] === "\\")
        return exports2.escapeLast(input, char, idx - 1);
      return `${input.slice(0, idx)}\\${input.slice(idx)}`;
    };
    exports2.removePrefix = (input, state = {}) => {
      let output = input;
      if (output.startsWith("./")) {
        output = output.slice(2);
        state.prefix = "./";
      }
      return output;
    };
    exports2.wrapOutput = (input, state = {}, options = {}) => {
      const prepend = options.contains ? "" : "^";
      const append = options.contains ? "" : "$";
      let output = `${prepend}(?:${input})${append}`;
      if (state.negated === true) {
        output = `(?:^(?!${output}).*$)`;
      }
      return output;
    };
  }
});

// ../../node_modules/picomatch/lib/scan.js
var require_scan = __commonJS({
  "../../node_modules/picomatch/lib/scan.js"(exports2, module2) {
    "use strict";
    var utils = require_utils2();
    var {
      CHAR_ASTERISK,
      /* * */
      CHAR_AT,
      /* @ */
      CHAR_BACKWARD_SLASH,
      /* \ */
      CHAR_COMMA,
      /* , */
      CHAR_DOT,
      /* . */
      CHAR_EXCLAMATION_MARK,
      /* ! */
      CHAR_FORWARD_SLASH,
      /* / */
      CHAR_LEFT_CURLY_BRACE,
      /* { */
      CHAR_LEFT_PARENTHESES,
      /* ( */
      CHAR_LEFT_SQUARE_BRACKET,
      /* [ */
      CHAR_PLUS,
      /* + */
      CHAR_QUESTION_MARK,
      /* ? */
      CHAR_RIGHT_CURLY_BRACE,
      /* } */
      CHAR_RIGHT_PARENTHESES,
      /* ) */
      CHAR_RIGHT_SQUARE_BRACKET
      /* ] */
    } = require_constants2();
    var isPathSeparator = (code) => {
      return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
    };
    var depth = (token) => {
      if (token.isPrefix !== true) {
        token.depth = token.isGlobstar ? Infinity : 1;
      }
    };
    var scan = (input, options) => {
      const opts = options || {};
      const length = input.length - 1;
      const scanToEnd = opts.parts === true || opts.scanToEnd === true;
      const slashes = [];
      const tokens = [];
      const parts2 = [];
      let str = input;
      let index = -1;
      let start2 = 0;
      let lastIndex = 0;
      let isBrace = false;
      let isBracket = false;
      let isGlob = false;
      let isExtglob = false;
      let isGlobstar = false;
      let braceEscaped = false;
      let backslashes = false;
      let negated = false;
      let negatedExtglob = false;
      let finished = false;
      let braces = 0;
      let prev;
      let code;
      let token = { value: "", depth: 0, isGlob: false };
      const eos = () => index >= length;
      const peek = () => str.charCodeAt(index + 1);
      const advance = () => {
        prev = code;
        return str.charCodeAt(++index);
      };
      while (index < length) {
        code = advance();
        let next;
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          code = advance();
          if (code === CHAR_LEFT_CURLY_BRACE) {
            braceEscaped = true;
          }
          continue;
        }
        if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
          braces++;
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (code === CHAR_LEFT_CURLY_BRACE) {
              braces++;
              continue;
            }
            if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (braceEscaped !== true && code === CHAR_COMMA) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (code === CHAR_RIGHT_CURLY_BRACE) {
              braces--;
              if (braces === 0) {
                braceEscaped = false;
                isBrace = token.isBrace = true;
                finished = true;
                break;
              }
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_FORWARD_SLASH) {
          slashes.push(index);
          tokens.push(token);
          token = { value: "", depth: 0, isGlob: false };
          if (finished === true)
            continue;
          if (prev === CHAR_DOT && index === start2 + 1) {
            start2 += 2;
            continue;
          }
          lastIndex = index + 1;
          continue;
        }
        if (opts.noext !== true) {
          const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
          if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
            isGlob = token.isGlob = true;
            isExtglob = token.isExtglob = true;
            finished = true;
            if (code === CHAR_EXCLAMATION_MARK && index === start2) {
              negatedExtglob = true;
            }
            if (scanToEnd === true) {
              while (eos() !== true && (code = advance())) {
                if (code === CHAR_BACKWARD_SLASH) {
                  backslashes = token.backslashes = true;
                  code = advance();
                  continue;
                }
                if (code === CHAR_RIGHT_PARENTHESES) {
                  isGlob = token.isGlob = true;
                  finished = true;
                  break;
                }
              }
              continue;
            }
            break;
          }
        }
        if (code === CHAR_ASTERISK) {
          if (prev === CHAR_ASTERISK)
            isGlobstar = token.isGlobstar = true;
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_QUESTION_MARK) {
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_LEFT_SQUARE_BRACKET) {
          while (eos() !== true && (next = advance())) {
            if (next === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              isBracket = token.isBracket = true;
              isGlob = token.isGlob = true;
              finished = true;
              break;
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start2) {
          negated = token.negated = true;
          start2++;
          continue;
        }
        if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
          isGlob = token.isGlob = true;
          if (scanToEnd === true) {
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_LEFT_PARENTHESES) {
                backslashes = token.backslashes = true;
                code = advance();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES) {
                finished = true;
                break;
              }
            }
            continue;
          }
          break;
        }
        if (isGlob === true) {
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
      }
      if (opts.noext === true) {
        isExtglob = false;
        isGlob = false;
      }
      let base = str;
      let prefix = "";
      let glob = "";
      if (start2 > 0) {
        prefix = str.slice(0, start2);
        str = str.slice(start2);
        lastIndex -= start2;
      }
      if (base && isGlob === true && lastIndex > 0) {
        base = str.slice(0, lastIndex);
        glob = str.slice(lastIndex);
      } else if (isGlob === true) {
        base = "";
        glob = str;
      } else {
        base = str;
      }
      if (base && base !== "" && base !== "/" && base !== str) {
        if (isPathSeparator(base.charCodeAt(base.length - 1))) {
          base = base.slice(0, -1);
        }
      }
      if (opts.unescape === true) {
        if (glob)
          glob = utils.removeBackslashes(glob);
        if (base && backslashes === true) {
          base = utils.removeBackslashes(base);
        }
      }
      const state = {
        prefix,
        input,
        start: start2,
        base,
        glob,
        isBrace,
        isBracket,
        isGlob,
        isExtglob,
        isGlobstar,
        negated,
        negatedExtglob
      };
      if (opts.tokens === true) {
        state.maxDepth = 0;
        if (!isPathSeparator(code)) {
          tokens.push(token);
        }
        state.tokens = tokens;
      }
      if (opts.parts === true || opts.tokens === true) {
        let prevIndex;
        for (let idx = 0; idx < slashes.length; idx++) {
          const n = prevIndex ? prevIndex + 1 : start2;
          const i2 = slashes[idx];
          const value = input.slice(n, i2);
          if (opts.tokens) {
            if (idx === 0 && start2 !== 0) {
              tokens[idx].isPrefix = true;
              tokens[idx].value = prefix;
            } else {
              tokens[idx].value = value;
            }
            depth(tokens[idx]);
            state.maxDepth += tokens[idx].depth;
          }
          if (idx !== 0 || value !== "") {
            parts2.push(value);
          }
          prevIndex = i2;
        }
        if (prevIndex && prevIndex + 1 < input.length) {
          const value = input.slice(prevIndex + 1);
          parts2.push(value);
          if (opts.tokens) {
            tokens[tokens.length - 1].value = value;
            depth(tokens[tokens.length - 1]);
            state.maxDepth += tokens[tokens.length - 1].depth;
          }
        }
        state.slashes = slashes;
        state.parts = parts2;
      }
      return state;
    };
    module2.exports = scan;
  }
});

// ../../node_modules/picomatch/lib/parse.js
var require_parse2 = __commonJS({
  "../../node_modules/picomatch/lib/parse.js"(exports2, module2) {
    "use strict";
    var constants = require_constants2();
    var utils = require_utils2();
    var {
      MAX_LENGTH,
      POSIX_REGEX_SOURCE,
      REGEX_NON_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_BACKREF,
      REPLACEMENTS
    } = constants;
    var expandRange = (args2, options) => {
      if (typeof options.expandRange === "function") {
        return options.expandRange(...args2, options);
      }
      args2.sort();
      const value = `[${args2.join("-")}]`;
      try {
        new RegExp(value);
      } catch (ex) {
        return args2.map((v) => utils.escapeRegex(v)).join("..");
      }
      return value;
    };
    var syntaxError = (type, char) => {
      return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
    };
    var parse = (input, options) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      input = REPLACEMENTS[input] || input;
      const opts = { ...options };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      let len2 = input.length;
      if (len2 > max) {
        throw new SyntaxError(`Input length: ${len2}, exceeds maximum allowed length: ${max}`);
      }
      const bos = { type: "bos", value: "", output: opts.prepend || "" };
      const tokens = [bos];
      const capture = opts.capture ? "" : "?:";
      const win32 = utils.isWindows(options);
      const PLATFORM_CHARS = constants.globChars(win32);
      const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);
      const {
        DOT_LITERAL,
        PLUS_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOT_SLASH,
        NO_DOTS_SLASH,
        QMARK,
        QMARK_NO_DOT,
        STAR,
        START_ANCHOR
      } = PLATFORM_CHARS;
      const globstar = (opts2) => {
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const nodot = opts.dot ? "" : NO_DOT;
      const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
      let star = opts.bash === true ? globstar(opts) : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      if (typeof opts.noext === "boolean") {
        opts.noextglob = opts.noext;
      }
      const state = {
        input,
        index: -1,
        start: 0,
        dot: opts.dot === true,
        consumed: "",
        output: "",
        prefix: "",
        backtrack: false,
        negated: false,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        globstar: false,
        tokens
      };
      input = utils.removePrefix(input, state);
      len2 = input.length;
      const extglobs = [];
      const braces = [];
      const stack = [];
      let prev = bos;
      let value;
      const eos = () => state.index === len2 - 1;
      const peek = state.peek = (n = 1) => input[state.index + n];
      const advance = state.advance = () => input[++state.index] || "";
      const remaining = () => input.slice(state.index + 1);
      const consume = (value2 = "", num = 0) => {
        state.consumed += value2;
        state.index += num;
      };
      const append = (token) => {
        state.output += token.output != null ? token.output : token.value;
        consume(token.value);
      };
      const negate = () => {
        let count = 1;
        while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
          advance();
          state.start++;
          count++;
        }
        if (count % 2 === 0) {
          return false;
        }
        state.negated = true;
        state.start++;
        return true;
      };
      const increment = (type) => {
        state[type]++;
        stack.push(type);
      };
      const decrement = (type) => {
        state[type]--;
        stack.pop();
      };
      const push = (tok) => {
        if (prev.type === "globstar") {
          const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
          const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
          if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
            state.output = state.output.slice(0, -prev.output.length);
            prev.type = "star";
            prev.value = "*";
            prev.output = star;
            state.output += prev.output;
          }
        }
        if (extglobs.length && tok.type !== "paren") {
          extglobs[extglobs.length - 1].inner += tok.value;
        }
        if (tok.value || tok.output)
          append(tok);
        if (prev && prev.type === "text" && tok.type === "text") {
          prev.value += tok.value;
          prev.output = (prev.output || "") + tok.value;
          return;
        }
        tok.prev = prev;
        tokens.push(tok);
        prev = tok;
      };
      const extglobOpen = (type, value2) => {
        const token = { ...EXTGLOB_CHARS[value2], conditions: 1, inner: "" };
        token.prev = prev;
        token.parens = state.parens;
        token.output = state.output;
        const output = (opts.capture ? "(" : "") + token.open;
        increment("parens");
        push({ type, value: value2, output: state.output ? "" : ONE_CHAR });
        push({ type: "paren", extglob: true, value: advance(), output });
        extglobs.push(token);
      };
      const extglobClose = (token) => {
        let output = token.close + (opts.capture ? ")" : "");
        let rest;
        if (token.type === "negate") {
          let extglobStar = star;
          if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
            extglobStar = globstar(opts);
          }
          if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
            output = token.close = `)$))${extglobStar}`;
          }
          if (token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
            output = token.close = `)${rest})${extglobStar})`;
          }
          if (token.prev.type === "bos") {
            state.negatedExtglob = true;
          }
        }
        push({ type: "paren", extglob: true, value, output });
        decrement("parens");
      };
      if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
        let backslashes = false;
        let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {
          if (first === "\\") {
            backslashes = true;
            return m;
          }
          if (first === "?") {
            if (esc) {
              return esc + first + (rest ? QMARK.repeat(rest.length) : "");
            }
            if (index === 0) {
              return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "");
            }
            return QMARK.repeat(chars.length);
          }
          if (first === ".") {
            return DOT_LITERAL.repeat(chars.length);
          }
          if (first === "*") {
            if (esc) {
              return esc + first + (rest ? star : "");
            }
            return star;
          }
          return esc ? m : `\\${m}`;
        });
        if (backslashes === true) {
          if (opts.unescape === true) {
            output = output.replace(/\\/g, "");
          } else {
            output = output.replace(/\\+/g, (m) => {
              return m.length % 2 === 0 ? "\\\\" : m ? "\\" : "";
            });
          }
        }
        if (output === input && opts.contains === true) {
          state.output = input;
          return state;
        }
        state.output = utils.wrapOutput(output, state, options);
        return state;
      }
      while (!eos()) {
        value = advance();
        if (value === "\0") {
          continue;
        }
        if (value === "\\") {
          const next = peek();
          if (next === "/" && opts.bash !== true) {
            continue;
          }
          if (next === "." || next === ";") {
            continue;
          }
          if (!next) {
            value += "\\";
            push({ type: "text", value });
            continue;
          }
          const match = /^\\+/.exec(remaining());
          let slashes = 0;
          if (match && match[0].length > 2) {
            slashes = match[0].length;
            state.index += slashes;
            if (slashes % 2 !== 0) {
              value += "\\";
            }
          }
          if (opts.unescape === true) {
            value = advance();
          } else {
            value += advance();
          }
          if (state.brackets === 0) {
            push({ type: "text", value });
            continue;
          }
        }
        if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
          if (opts.posix !== false && value === ":") {
            const inner = prev.value.slice(1);
            if (inner.includes("[")) {
              prev.posix = true;
              if (inner.includes(":")) {
                const idx = prev.value.lastIndexOf("[");
                const pre = prev.value.slice(0, idx);
                const rest2 = prev.value.slice(idx + 2);
                const posix = POSIX_REGEX_SOURCE[rest2];
                if (posix) {
                  prev.value = pre + posix;
                  state.backtrack = true;
                  advance();
                  if (!bos.output && tokens.indexOf(prev) === 1) {
                    bos.output = ONE_CHAR;
                  }
                  continue;
                }
              }
            }
          }
          if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") {
            value = `\\${value}`;
          }
          if (value === "]" && (prev.value === "[" || prev.value === "[^")) {
            value = `\\${value}`;
          }
          if (opts.posix === true && value === "!" && prev.value === "[") {
            value = "^";
          }
          prev.value += value;
          append({ value });
          continue;
        }
        if (state.quotes === 1 && value !== '"') {
          value = utils.escapeRegex(value);
          prev.value += value;
          append({ value });
          continue;
        }
        if (value === '"') {
          state.quotes = state.quotes === 1 ? 0 : 1;
          if (opts.keepQuotes === true) {
            push({ type: "text", value });
          }
          continue;
        }
        if (value === "(") {
          increment("parens");
          push({ type: "paren", value });
          continue;
        }
        if (value === ")") {
          if (state.parens === 0 && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("opening", "("));
          }
          const extglob = extglobs[extglobs.length - 1];
          if (extglob && state.parens === extglob.parens + 1) {
            extglobClose(extglobs.pop());
            continue;
          }
          push({ type: "paren", value, output: state.parens ? ")" : "\\)" });
          decrement("parens");
          continue;
        }
        if (value === "[") {
          if (opts.nobracket === true || !remaining().includes("]")) {
            if (opts.nobracket !== true && opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("closing", "]"));
            }
            value = `\\${value}`;
          } else {
            increment("brackets");
          }
          push({ type: "bracket", value });
          continue;
        }
        if (value === "]") {
          if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          if (state.brackets === 0) {
            if (opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("opening", "["));
            }
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          decrement("brackets");
          const prevValue = prev.value.slice(1);
          if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
            value = `/${value}`;
          }
          prev.value += value;
          append({ value });
          if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
            continue;
          }
          const escaped = utils.escapeRegex(prev.value);
          state.output = state.output.slice(0, -prev.value.length);
          if (opts.literalBrackets === true) {
            state.output += escaped;
            prev.value = escaped;
            continue;
          }
          prev.value = `(${capture}${escaped}|${prev.value})`;
          state.output += prev.value;
          continue;
        }
        if (value === "{" && opts.nobrace !== true) {
          increment("braces");
          const open = {
            type: "brace",
            value,
            output: "(",
            outputIndex: state.output.length,
            tokensIndex: state.tokens.length
          };
          braces.push(open);
          push(open);
          continue;
        }
        if (value === "}") {
          const brace = braces[braces.length - 1];
          if (opts.nobrace === true || !brace) {
            push({ type: "text", value, output: value });
            continue;
          }
          let output = ")";
          if (brace.dots === true) {
            const arr = tokens.slice();
            const range = [];
            for (let i2 = arr.length - 1; i2 >= 0; i2--) {
              tokens.pop();
              if (arr[i2].type === "brace") {
                break;
              }
              if (arr[i2].type !== "dots") {
                range.unshift(arr[i2].value);
              }
            }
            output = expandRange(range, opts);
            state.backtrack = true;
          }
          if (brace.comma !== true && brace.dots !== true) {
            const out2 = state.output.slice(0, brace.outputIndex);
            const toks = state.tokens.slice(brace.tokensIndex);
            brace.value = brace.output = "\\{";
            value = output = "\\}";
            state.output = out2;
            for (const t of toks) {
              state.output += t.output || t.value;
            }
          }
          push({ type: "brace", value, output });
          decrement("braces");
          braces.pop();
          continue;
        }
        if (value === "|") {
          if (extglobs.length > 0) {
            extglobs[extglobs.length - 1].conditions++;
          }
          push({ type: "text", value });
          continue;
        }
        if (value === ",") {
          let output = value;
          const brace = braces[braces.length - 1];
          if (brace && stack[stack.length - 1] === "braces") {
            brace.comma = true;
            output = "|";
          }
          push({ type: "comma", value, output });
          continue;
        }
        if (value === "/") {
          if (prev.type === "dot" && state.index === state.start + 1) {
            state.start = state.index + 1;
            state.consumed = "";
            state.output = "";
            tokens.pop();
            prev = bos;
            continue;
          }
          push({ type: "slash", value, output: SLASH_LITERAL });
          continue;
        }
        if (value === ".") {
          if (state.braces > 0 && prev.type === "dot") {
            if (prev.value === ".")
              prev.output = DOT_LITERAL;
            const brace = braces[braces.length - 1];
            prev.type = "dots";
            prev.output += value;
            prev.value += value;
            brace.dots = true;
            continue;
          }
          if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
            push({ type: "text", value, output: DOT_LITERAL });
            continue;
          }
          push({ type: "dot", value, output: DOT_LITERAL });
          continue;
        }
        if (value === "?") {
          const isGroup = prev && prev.value === "(";
          if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("qmark", value);
            continue;
          }
          if (prev && prev.type === "paren") {
            const next = peek();
            let output = value;
            if (next === "<" && !utils.supportsLookbehinds()) {
              throw new Error("Node.js v10 or higher is required for regex lookbehinds");
            }
            if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
              output = `\\${value}`;
            }
            push({ type: "text", value, output });
            continue;
          }
          if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
            push({ type: "qmark", value, output: QMARK_NO_DOT });
            continue;
          }
          push({ type: "qmark", value, output: QMARK });
          continue;
        }
        if (value === "!") {
          if (opts.noextglob !== true && peek() === "(") {
            if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
              extglobOpen("negate", value);
              continue;
            }
          }
          if (opts.nonegate !== true && state.index === 0) {
            negate();
            continue;
          }
        }
        if (value === "+") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("plus", value);
            continue;
          }
          if (prev && prev.value === "(" || opts.regex === false) {
            push({ type: "plus", value, output: PLUS_LITERAL });
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
            push({ type: "plus", value });
            continue;
          }
          push({ type: "plus", value: PLUS_LITERAL });
          continue;
        }
        if (value === "@") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            push({ type: "at", extglob: true, value, output: "" });
            continue;
          }
          push({ type: "text", value });
          continue;
        }
        if (value !== "*") {
          if (value === "$" || value === "^") {
            value = `\\${value}`;
          }
          const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
          if (match) {
            value += match[0];
            state.index += match[0].length;
          }
          push({ type: "text", value });
          continue;
        }
        if (prev && (prev.type === "globstar" || prev.star === true)) {
          prev.type = "star";
          prev.star = true;
          prev.value += value;
          prev.output = star;
          state.backtrack = true;
          state.globstar = true;
          consume(value);
          continue;
        }
        let rest = remaining();
        if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
          extglobOpen("star", value);
          continue;
        }
        if (prev.type === "star") {
          if (opts.noglobstar === true) {
            consume(value);
            continue;
          }
          const prior = prev.prev;
          const before = prior.prev;
          const isStart = prior.type === "slash" || prior.type === "bos";
          const afterStar = before && (before.type === "star" || before.type === "globstar");
          if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
            push({ type: "star", value, output: "" });
            continue;
          }
          const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
          const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
          if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
            push({ type: "star", value, output: "" });
            continue;
          }
          while (rest.slice(0, 3) === "/**") {
            const after = input[state.index + 4];
            if (after && after !== "/") {
              break;
            }
            rest = rest.slice(3);
            consume("/**", 3);
          }
          if (prior.type === "bos" && eos()) {
            prev.type = "globstar";
            prev.value += value;
            prev.output = globstar(opts);
            state.output = prev.output;
            state.globstar = true;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
            prev.value += value;
            state.globstar = true;
            state.output += prior.output + prev.output;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
            const end = rest[1] !== void 0 ? "|$" : "";
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
            prev.value += value;
            state.output += prior.output + prev.output;
            state.globstar = true;
            consume(value + advance());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          if (prior.type === "bos" && rest[0] === "/") {
            prev.type = "globstar";
            prev.value += value;
            prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
            state.output = prev.output;
            state.globstar = true;
            consume(value + advance());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = "globstar";
          prev.output = globstar(opts);
          prev.value += value;
          state.output += prev.output;
          state.globstar = true;
          consume(value);
          continue;
        }
        const token = { type: "star", value, output: star };
        if (opts.bash === true) {
          token.output = ".*?";
          if (prev.type === "bos" || prev.type === "slash") {
            token.output = nodot + token.output;
          }
          push(token);
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
          token.output = value;
          push(token);
          continue;
        }
        if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
          if (prev.type === "dot") {
            state.output += NO_DOT_SLASH;
            prev.output += NO_DOT_SLASH;
          } else if (opts.dot === true) {
            state.output += NO_DOTS_SLASH;
            prev.output += NO_DOTS_SLASH;
          } else {
            state.output += nodot;
            prev.output += nodot;
          }
          if (peek() !== "*") {
            state.output += ONE_CHAR;
            prev.output += ONE_CHAR;
          }
        }
        push(token);
      }
      while (state.brackets > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "]"));
        state.output = utils.escapeLast(state.output, "[");
        decrement("brackets");
      }
      while (state.parens > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", ")"));
        state.output = utils.escapeLast(state.output, "(");
        decrement("parens");
      }
      while (state.braces > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "}"));
        state.output = utils.escapeLast(state.output, "{");
        decrement("braces");
      }
      if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
        push({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?` });
      }
      if (state.backtrack === true) {
        state.output = "";
        for (const token of state.tokens) {
          state.output += token.output != null ? token.output : token.value;
          if (token.suffix) {
            state.output += token.suffix;
          }
        }
      }
      return state;
    };
    parse.fastpaths = (input, options) => {
      const opts = { ...options };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      const len2 = input.length;
      if (len2 > max) {
        throw new SyntaxError(`Input length: ${len2}, exceeds maximum allowed length: ${max}`);
      }
      input = REPLACEMENTS[input] || input;
      const win32 = utils.isWindows(options);
      const {
        DOT_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOTS,
        NO_DOTS_SLASH,
        STAR,
        START_ANCHOR
      } = constants.globChars(win32);
      const nodot = opts.dot ? NO_DOTS : NO_DOT;
      const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
      const capture = opts.capture ? "" : "?:";
      const state = { negated: false, prefix: "" };
      let star = opts.bash === true ? ".*?" : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      const globstar = (opts2) => {
        if (opts2.noglobstar === true)
          return star;
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const create = (str) => {
        switch (str) {
          case "*":
            return `${nodot}${ONE_CHAR}${star}`;
          case ".*":
            return `${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*.*":
            return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*/*":
            return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
          case "**":
            return nodot + globstar(opts);
          case "**/*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
          case "**/*.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "**/.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
          default: {
            const match = /^(.*?)\.(\w+)$/.exec(str);
            if (!match)
              return;
            const source2 = create(match[1]);
            if (!source2)
              return;
            return source2 + DOT_LITERAL + match[2];
          }
        }
      };
      const output = utils.removePrefix(input, state);
      let source = create(output);
      if (source && opts.strictSlashes !== true) {
        source += `${SLASH_LITERAL}?`;
      }
      return source;
    };
    module2.exports = parse;
  }
});

// ../../node_modules/picomatch/lib/picomatch.js
var require_picomatch = __commonJS({
  "../../node_modules/picomatch/lib/picomatch.js"(exports2, module2) {
    "use strict";
    var path2 = require("path");
    var scan = require_scan();
    var parse = require_parse2();
    var utils = require_utils2();
    var constants = require_constants2();
    var isObject = (val) => val && typeof val === "object" && !Array.isArray(val);
    var picomatch = (glob, options, returnState = false) => {
      if (Array.isArray(glob)) {
        const fns = glob.map((input) => picomatch(input, options, returnState));
        const arrayMatcher = (str) => {
          for (const isMatch of fns) {
            const state2 = isMatch(str);
            if (state2)
              return state2;
          }
          return false;
        };
        return arrayMatcher;
      }
      const isState = isObject(glob) && glob.tokens && glob.input;
      if (glob === "" || typeof glob !== "string" && !isState) {
        throw new TypeError("Expected pattern to be a non-empty string");
      }
      const opts = options || {};
      const posix = utils.isWindows(options);
      const regex = isState ? picomatch.compileRe(glob, options) : picomatch.makeRe(glob, options, false, true);
      const state = regex.state;
      delete regex.state;
      let isIgnored = () => false;
      if (opts.ignore) {
        const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
        isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
      }
      const matcher = (input, returnObject = false) => {
        const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });
        const result = { glob, state, regex, posix, input, output, match, isMatch };
        if (typeof opts.onResult === "function") {
          opts.onResult(result);
        }
        if (isMatch === false) {
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (isIgnored(input)) {
          if (typeof opts.onIgnore === "function") {
            opts.onIgnore(result);
          }
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (typeof opts.onMatch === "function") {
          opts.onMatch(result);
        }
        return returnObject ? result : true;
      };
      if (returnState) {
        matcher.state = state;
      }
      return matcher;
    };
    picomatch.test = (input, regex, options, { glob, posix } = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected input to be a string");
      }
      if (input === "") {
        return { isMatch: false, output: "" };
      }
      const opts = options || {};
      const format = opts.format || (posix ? utils.toPosixSlashes : null);
      let match = input === glob;
      let output = match && format ? format(input) : input;
      if (match === false) {
        output = format ? format(input) : input;
        match = output === glob;
      }
      if (match === false || opts.capture === true) {
        if (opts.matchBase === true || opts.basename === true) {
          match = picomatch.matchBase(input, regex, options, posix);
        } else {
          match = regex.exec(output);
        }
      }
      return { isMatch: Boolean(match), match, output };
    };
    picomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {
      const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
      return regex.test(path2.basename(input));
    };
    picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
    picomatch.parse = (pattern, options) => {
      if (Array.isArray(pattern))
        return pattern.map((p) => picomatch.parse(p, options));
      return parse(pattern, { ...options, fastpaths: false });
    };
    picomatch.scan = (input, options) => scan(input, options);
    picomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {
      if (returnOutput === true) {
        return state.output;
      }
      const opts = options || {};
      const prepend = opts.contains ? "" : "^";
      const append = opts.contains ? "" : "$";
      let source = `${prepend}(?:${state.output})${append}`;
      if (state && state.negated === true) {
        source = `^(?!${source}).*$`;
      }
      const regex = picomatch.toRegex(source, options);
      if (returnState === true) {
        regex.state = state;
      }
      return regex;
    };
    picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
      if (!input || typeof input !== "string") {
        throw new TypeError("Expected a non-empty string");
      }
      let parsed = { negated: false, fastpaths: true };
      if (options.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
        parsed.output = parse.fastpaths(input, options);
      }
      if (!parsed.output) {
        parsed = parse(input, options);
      }
      return picomatch.compileRe(parsed, options, returnOutput, returnState);
    };
    picomatch.toRegex = (source, options) => {
      try {
        const opts = options || {};
        return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
      } catch (err2) {
        if (options && options.debug === true)
          throw err2;
        return /$^/;
      }
    };
    picomatch.constants = constants;
    module2.exports = picomatch;
  }
});

// ../../node_modules/picomatch/index.js
var require_picomatch2 = __commonJS({
  "../../node_modules/picomatch/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_picomatch();
  }
});

// ../../node_modules/micromatch/index.js
var require_micromatch = __commonJS({
  "../../node_modules/micromatch/index.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var braces = require_braces();
    var picomatch = require_picomatch2();
    var utils = require_utils2();
    var isEmptyString = (val) => val === "" || val === "./";
    var micromatch = (list, patterns, options) => {
      patterns = [].concat(patterns);
      list = [].concat(list);
      let omit = /* @__PURE__ */ new Set();
      let keep = /* @__PURE__ */ new Set();
      let items = /* @__PURE__ */ new Set();
      let negatives = 0;
      let onResult = (state) => {
        items.add(state.output);
        if (options && options.onResult) {
          options.onResult(state);
        }
      };
      for (let i2 = 0; i2 < patterns.length; i2++) {
        let isMatch = picomatch(String(patterns[i2]), { ...options, onResult }, true);
        let negated = isMatch.state.negated || isMatch.state.negatedExtglob;
        if (negated)
          negatives++;
        for (let item of list) {
          let matched = isMatch(item, true);
          let match = negated ? !matched.isMatch : matched.isMatch;
          if (!match)
            continue;
          if (negated) {
            omit.add(matched.output);
          } else {
            omit.delete(matched.output);
            keep.add(matched.output);
          }
        }
      }
      let result = negatives === patterns.length ? [...items] : [...keep];
      let matches = result.filter((item) => !omit.has(item));
      if (options && matches.length === 0) {
        if (options.failglob === true) {
          throw new Error(`No matches found for "${patterns.join(", ")}"`);
        }
        if (options.nonull === true || options.nullglob === true) {
          return options.unescape ? patterns.map((p) => p.replace(/\\/g, "")) : patterns;
        }
      }
      return matches;
    };
    micromatch.match = micromatch;
    micromatch.matcher = (pattern, options) => picomatch(pattern, options);
    micromatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
    micromatch.any = micromatch.isMatch;
    micromatch.not = (list, patterns, options = {}) => {
      patterns = [].concat(patterns).map(String);
      let result = /* @__PURE__ */ new Set();
      let items = [];
      let onResult = (state) => {
        if (options.onResult)
          options.onResult(state);
        items.push(state.output);
      };
      let matches = micromatch(list, patterns, { ...options, onResult });
      for (let item of items) {
        if (!matches.includes(item)) {
          result.add(item);
        }
      }
      return [...result];
    };
    micromatch.contains = (str, pattern, options) => {
      if (typeof str !== "string") {
        throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
      }
      if (Array.isArray(pattern)) {
        return pattern.some((p) => micromatch.contains(str, p, options));
      }
      if (typeof pattern === "string") {
        if (isEmptyString(str) || isEmptyString(pattern)) {
          return false;
        }
        if (str.includes(pattern) || str.startsWith("./") && str.slice(2).includes(pattern)) {
          return true;
        }
      }
      return micromatch.isMatch(str, pattern, { ...options, contains: true });
    };
    micromatch.matchKeys = (obj, patterns, options) => {
      if (!utils.isObject(obj)) {
        throw new TypeError("Expected the first argument to be an object");
      }
      let keys = micromatch(Object.keys(obj), patterns, options);
      let res = {};
      for (let key of keys)
        res[key] = obj[key];
      return res;
    };
    micromatch.some = (list, patterns, options) => {
      let items = [].concat(list);
      for (let pattern of [].concat(patterns)) {
        let isMatch = picomatch(String(pattern), options);
        if (items.some((item) => isMatch(item))) {
          return true;
        }
      }
      return false;
    };
    micromatch.every = (list, patterns, options) => {
      let items = [].concat(list);
      for (let pattern of [].concat(patterns)) {
        let isMatch = picomatch(String(pattern), options);
        if (!items.every((item) => isMatch(item))) {
          return false;
        }
      }
      return true;
    };
    micromatch.all = (str, patterns, options) => {
      if (typeof str !== "string") {
        throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
      }
      return [].concat(patterns).every((p) => picomatch(p, options)(str));
    };
    micromatch.capture = (glob, input, options) => {
      let posix = utils.isWindows(options);
      let regex = picomatch.makeRe(String(glob), { ...options, capture: true });
      let match = regex.exec(posix ? utils.toPosixSlashes(input) : input);
      if (match) {
        return match.slice(1).map((v) => v === void 0 ? "" : v);
      }
    };
    micromatch.makeRe = (...args2) => picomatch.makeRe(...args2);
    micromatch.scan = (...args2) => picomatch.scan(...args2);
    micromatch.parse = (patterns, options) => {
      let res = [];
      for (let pattern of [].concat(patterns || [])) {
        for (let str of braces(String(pattern), options)) {
          res.push(picomatch.parse(str, options));
        }
      }
      return res;
    };
    micromatch.braces = (pattern, options) => {
      if (typeof pattern !== "string")
        throw new TypeError("Expected a string");
      if (options && options.nobrace === true || !/\{.*\}/.test(pattern)) {
        return [pattern];
      }
      return braces(pattern, options);
    };
    micromatch.braceExpand = (pattern, options) => {
      if (typeof pattern !== "string")
        throw new TypeError("Expected a string");
      return micromatch.braces(pattern, { ...options, expand: true });
    };
    module2.exports = micromatch;
  }
});

// ../../node_modules/fast-glob/out/utils/pattern.js
var require_pattern = __commonJS({
  "../../node_modules/fast-glob/out/utils/pattern.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.removeDuplicateSlashes = exports2.matchAny = exports2.convertPatternsToRe = exports2.makeRe = exports2.getPatternParts = exports2.expandBraceExpansion = exports2.expandPatternsWithBraceExpansion = exports2.isAffectDepthOfReadingPattern = exports2.endsWithSlashGlobStar = exports2.hasGlobStar = exports2.getBaseDirectory = exports2.isPatternRelatedToParentDirectory = exports2.getPatternsOutsideCurrentDirectory = exports2.getPatternsInsideCurrentDirectory = exports2.getPositivePatterns = exports2.getNegativePatterns = exports2.isPositivePattern = exports2.isNegativePattern = exports2.convertToNegativePattern = exports2.convertToPositivePattern = exports2.isDynamicPattern = exports2.isStaticPattern = void 0;
    var path2 = require("path");
    var globParent = require_glob_parent();
    var micromatch = require_micromatch();
    var GLOBSTAR = "**";
    var ESCAPE_SYMBOL = "\\";
    var COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;
    var REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\[[^[]*]/;
    var REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\([^(]*\|[^|]*\)/;
    var GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\([^(]*\)/;
    var BRACE_EXPANSION_SEPARATORS_RE = /,|\.\./;
    var DOUBLE_SLASH_RE = /(?!^)\/{2,}/g;
    function isStaticPattern(pattern, options = {}) {
      return !isDynamicPattern(pattern, options);
    }
    exports2.isStaticPattern = isStaticPattern;
    function isDynamicPattern(pattern, options = {}) {
      if (pattern === "") {
        return false;
      }
      if (options.caseSensitiveMatch === false || pattern.includes(ESCAPE_SYMBOL)) {
        return true;
      }
      if (COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern)) {
        return true;
      }
      if (options.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern)) {
        return true;
      }
      if (options.braceExpansion !== false && hasBraceExpansion(pattern)) {
        return true;
      }
      return false;
    }
    exports2.isDynamicPattern = isDynamicPattern;
    function hasBraceExpansion(pattern) {
      const openingBraceIndex = pattern.indexOf("{");
      if (openingBraceIndex === -1) {
        return false;
      }
      const closingBraceIndex = pattern.indexOf("}", openingBraceIndex + 1);
      if (closingBraceIndex === -1) {
        return false;
      }
      const braceContent = pattern.slice(openingBraceIndex, closingBraceIndex);
      return BRACE_EXPANSION_SEPARATORS_RE.test(braceContent);
    }
    function convertToPositivePattern(pattern) {
      return isNegativePattern(pattern) ? pattern.slice(1) : pattern;
    }
    exports2.convertToPositivePattern = convertToPositivePattern;
    function convertToNegativePattern(pattern) {
      return "!" + pattern;
    }
    exports2.convertToNegativePattern = convertToNegativePattern;
    function isNegativePattern(pattern) {
      return pattern.startsWith("!") && pattern[1] !== "(";
    }
    exports2.isNegativePattern = isNegativePattern;
    function isPositivePattern(pattern) {
      return !isNegativePattern(pattern);
    }
    exports2.isPositivePattern = isPositivePattern;
    function getNegativePatterns(patterns) {
      return patterns.filter(isNegativePattern);
    }
    exports2.getNegativePatterns = getNegativePatterns;
    function getPositivePatterns(patterns) {
      return patterns.filter(isPositivePattern);
    }
    exports2.getPositivePatterns = getPositivePatterns;
    function getPatternsInsideCurrentDirectory(patterns) {
      return patterns.filter((pattern) => !isPatternRelatedToParentDirectory(pattern));
    }
    exports2.getPatternsInsideCurrentDirectory = getPatternsInsideCurrentDirectory;
    function getPatternsOutsideCurrentDirectory(patterns) {
      return patterns.filter(isPatternRelatedToParentDirectory);
    }
    exports2.getPatternsOutsideCurrentDirectory = getPatternsOutsideCurrentDirectory;
    function isPatternRelatedToParentDirectory(pattern) {
      return pattern.startsWith("..") || pattern.startsWith("./..");
    }
    exports2.isPatternRelatedToParentDirectory = isPatternRelatedToParentDirectory;
    function getBaseDirectory(pattern) {
      return globParent(pattern, { flipBackslashes: false });
    }
    exports2.getBaseDirectory = getBaseDirectory;
    function hasGlobStar(pattern) {
      return pattern.includes(GLOBSTAR);
    }
    exports2.hasGlobStar = hasGlobStar;
    function endsWithSlashGlobStar(pattern) {
      return pattern.endsWith("/" + GLOBSTAR);
    }
    exports2.endsWithSlashGlobStar = endsWithSlashGlobStar;
    function isAffectDepthOfReadingPattern(pattern) {
      const basename = path2.basename(pattern);
      return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);
    }
    exports2.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;
    function expandPatternsWithBraceExpansion(patterns) {
      return patterns.reduce((collection, pattern) => {
        return collection.concat(expandBraceExpansion(pattern));
      }, []);
    }
    exports2.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;
    function expandBraceExpansion(pattern) {
      const patterns = micromatch.braces(pattern, { expand: true, nodupes: true, keepEscaping: true });
      patterns.sort((a, b) => a.length - b.length);
      return patterns.filter((pattern2) => pattern2 !== "");
    }
    exports2.expandBraceExpansion = expandBraceExpansion;
    function getPatternParts(pattern, options) {
      let { parts: parts2 } = micromatch.scan(pattern, Object.assign(Object.assign({}, options), { parts: true }));
      if (parts2.length === 0) {
        parts2 = [pattern];
      }
      if (parts2[0].startsWith("/")) {
        parts2[0] = parts2[0].slice(1);
        parts2.unshift("");
      }
      return parts2;
    }
    exports2.getPatternParts = getPatternParts;
    function makeRe(pattern, options) {
      return micromatch.makeRe(pattern, options);
    }
    exports2.makeRe = makeRe;
    function convertPatternsToRe(patterns, options) {
      return patterns.map((pattern) => makeRe(pattern, options));
    }
    exports2.convertPatternsToRe = convertPatternsToRe;
    function matchAny(entry, patternsRe) {
      return patternsRe.some((patternRe) => patternRe.test(entry));
    }
    exports2.matchAny = matchAny;
    function removeDuplicateSlashes(pattern) {
      return pattern.replace(DOUBLE_SLASH_RE, "/");
    }
    exports2.removeDuplicateSlashes = removeDuplicateSlashes;
  }
});

// ../../node_modules/merge2/index.js
var require_merge2 = __commonJS({
  "../../node_modules/merge2/index.js"(exports2, module2) {
    "use strict";
    var Stream = require("stream");
    var PassThrough = Stream.PassThrough;
    var slice = Array.prototype.slice;
    module2.exports = merge2;
    function merge2() {
      const streamsQueue = [];
      const args2 = slice.call(arguments);
      let merging = false;
      let options = args2[args2.length - 1];
      if (options && !Array.isArray(options) && options.pipe == null) {
        args2.pop();
      } else {
        options = {};
      }
      const doEnd = options.end !== false;
      const doPipeError = options.pipeError === true;
      if (options.objectMode == null) {
        options.objectMode = true;
      }
      if (options.highWaterMark == null) {
        options.highWaterMark = 64 * 1024;
      }
      const mergedStream = PassThrough(options);
      function addStream() {
        for (let i2 = 0, len2 = arguments.length; i2 < len2; i2++) {
          streamsQueue.push(pauseStreams(arguments[i2], options));
        }
        mergeStream();
        return this;
      }
      function mergeStream() {
        if (merging) {
          return;
        }
        merging = true;
        let streams = streamsQueue.shift();
        if (!streams) {
          process.nextTick(endStream);
          return;
        }
        if (!Array.isArray(streams)) {
          streams = [streams];
        }
        let pipesCount = streams.length + 1;
        function next() {
          if (--pipesCount > 0) {
            return;
          }
          merging = false;
          mergeStream();
        }
        function pipe(stream) {
          function onend() {
            stream.removeListener("merge2UnpipeEnd", onend);
            stream.removeListener("end", onend);
            if (doPipeError) {
              stream.removeListener("error", onerror2);
            }
            next();
          }
          function onerror2(err2) {
            mergedStream.emit("error", err2);
          }
          if (stream._readableState.endEmitted) {
            return next();
          }
          stream.on("merge2UnpipeEnd", onend);
          stream.on("end", onend);
          if (doPipeError) {
            stream.on("error", onerror2);
          }
          stream.pipe(mergedStream, { end: false });
          stream.resume();
        }
        for (let i2 = 0; i2 < streams.length; i2++) {
          pipe(streams[i2]);
        }
        next();
      }
      function endStream() {
        merging = false;
        mergedStream.emit("queueDrain");
        if (doEnd) {
          mergedStream.end();
        }
      }
      mergedStream.setMaxListeners(0);
      mergedStream.add = addStream;
      mergedStream.on("unpipe", function(stream) {
        stream.emit("merge2UnpipeEnd");
      });
      if (args2.length) {
        addStream.apply(null, args2);
      }
      return mergedStream;
    }
    function pauseStreams(streams, options) {
      if (!Array.isArray(streams)) {
        if (!streams._readableState && streams.pipe) {
          streams = streams.pipe(PassThrough(options));
        }
        if (!streams._readableState || !streams.pause || !streams.pipe) {
          throw new Error("Only readable stream can be merged.");
        }
        streams.pause();
      } else {
        for (let i2 = 0, len2 = streams.length; i2 < len2; i2++) {
          streams[i2] = pauseStreams(streams[i2], options);
        }
      }
      return streams;
    }
  }
});

// ../../node_modules/fast-glob/out/utils/stream.js
var require_stream = __commonJS({
  "../../node_modules/fast-glob/out/utils/stream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.merge = void 0;
    var merge2 = require_merge2();
    function merge(streams) {
      const mergedStream = merge2(streams);
      streams.forEach((stream) => {
        stream.once("error", (error) => mergedStream.emit("error", error));
      });
      mergedStream.once("close", () => propagateCloseEventToSources(streams));
      mergedStream.once("end", () => propagateCloseEventToSources(streams));
      return mergedStream;
    }
    exports2.merge = merge;
    function propagateCloseEventToSources(streams) {
      streams.forEach((stream) => stream.emit("close"));
    }
  }
});

// ../../node_modules/fast-glob/out/utils/string.js
var require_string = __commonJS({
  "../../node_modules/fast-glob/out/utils/string.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isEmpty = exports2.isString = void 0;
    function isString(input) {
      return typeof input === "string";
    }
    exports2.isString = isString;
    function isEmpty(input) {
      return input === "";
    }
    exports2.isEmpty = isEmpty;
  }
});

// ../../node_modules/fast-glob/out/utils/index.js
var require_utils3 = __commonJS({
  "../../node_modules/fast-glob/out/utils/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.string = exports2.stream = exports2.pattern = exports2.path = exports2.fs = exports2.errno = exports2.array = void 0;
    var array = require_array();
    exports2.array = array;
    var errno = require_errno();
    exports2.errno = errno;
    var fs5 = require_fs();
    exports2.fs = fs5;
    var path2 = require_path();
    exports2.path = path2;
    var pattern = require_pattern();
    exports2.pattern = pattern;
    var stream = require_stream();
    exports2.stream = stream;
    var string = require_string();
    exports2.string = string;
  }
});

// ../../node_modules/fast-glob/out/managers/tasks.js
var require_tasks = __commonJS({
  "../../node_modules/fast-glob/out/managers/tasks.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.convertPatternGroupToTask = exports2.convertPatternGroupsToTasks = exports2.groupPatternsByBaseDirectory = exports2.getNegativePatternsAsPositive = exports2.getPositivePatterns = exports2.convertPatternsToTasks = exports2.generate = void 0;
    var utils = require_utils3();
    function generate(input, settings) {
      const patterns = processPatterns(input, settings);
      const ignore = processPatterns(settings.ignore, settings);
      const positivePatterns = getPositivePatterns(patterns);
      const negativePatterns = getNegativePatternsAsPositive(patterns, ignore);
      const staticPatterns = positivePatterns.filter((pattern) => utils.pattern.isStaticPattern(pattern, settings));
      const dynamicPatterns = positivePatterns.filter((pattern) => utils.pattern.isDynamicPattern(pattern, settings));
      const staticTasks = convertPatternsToTasks(
        staticPatterns,
        negativePatterns,
        /* dynamic */
        false
      );
      const dynamicTasks = convertPatternsToTasks(
        dynamicPatterns,
        negativePatterns,
        /* dynamic */
        true
      );
      return staticTasks.concat(dynamicTasks);
    }
    exports2.generate = generate;
    function processPatterns(input, settings) {
      let patterns = input;
      if (settings.braceExpansion) {
        patterns = utils.pattern.expandPatternsWithBraceExpansion(patterns);
      }
      if (settings.baseNameMatch) {
        patterns = patterns.map((pattern) => pattern.includes("/") ? pattern : `**/${pattern}`);
      }
      return patterns.map((pattern) => utils.pattern.removeDuplicateSlashes(pattern));
    }
    function convertPatternsToTasks(positive, negative, dynamic) {
      const tasks = [];
      const patternsOutsideCurrentDirectory = utils.pattern.getPatternsOutsideCurrentDirectory(positive);
      const patternsInsideCurrentDirectory = utils.pattern.getPatternsInsideCurrentDirectory(positive);
      const outsideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsOutsideCurrentDirectory);
      const insideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsInsideCurrentDirectory);
      tasks.push(...convertPatternGroupsToTasks(outsideCurrentDirectoryGroup, negative, dynamic));
      if ("." in insideCurrentDirectoryGroup) {
        tasks.push(convertPatternGroupToTask(".", patternsInsideCurrentDirectory, negative, dynamic));
      } else {
        tasks.push(...convertPatternGroupsToTasks(insideCurrentDirectoryGroup, negative, dynamic));
      }
      return tasks;
    }
    exports2.convertPatternsToTasks = convertPatternsToTasks;
    function getPositivePatterns(patterns) {
      return utils.pattern.getPositivePatterns(patterns);
    }
    exports2.getPositivePatterns = getPositivePatterns;
    function getNegativePatternsAsPositive(patterns, ignore) {
      const negative = utils.pattern.getNegativePatterns(patterns).concat(ignore);
      const positive = negative.map(utils.pattern.convertToPositivePattern);
      return positive;
    }
    exports2.getNegativePatternsAsPositive = getNegativePatternsAsPositive;
    function groupPatternsByBaseDirectory(patterns) {
      const group = {};
      return patterns.reduce((collection, pattern) => {
        const base = utils.pattern.getBaseDirectory(pattern);
        if (base in collection) {
          collection[base].push(pattern);
        } else {
          collection[base] = [pattern];
        }
        return collection;
      }, group);
    }
    exports2.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory;
    function convertPatternGroupsToTasks(positive, negative, dynamic) {
      return Object.keys(positive).map((base) => {
        return convertPatternGroupToTask(base, positive[base], negative, dynamic);
      });
    }
    exports2.convertPatternGroupsToTasks = convertPatternGroupsToTasks;
    function convertPatternGroupToTask(base, positive, negative, dynamic) {
      return {
        dynamic,
        positive,
        negative,
        base,
        patterns: [].concat(positive, negative.map(utils.pattern.convertToNegativePattern))
      };
    }
    exports2.convertPatternGroupToTask = convertPatternGroupToTask;
  }
});

// ../../node_modules/@nodelib/fs.stat/out/providers/async.js
var require_async = __commonJS({
  "../../node_modules/@nodelib/fs.stat/out/providers/async.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.read = void 0;
    function read(path2, settings, callback) {
      settings.fs.lstat(path2, (lstatError, lstat) => {
        if (lstatError !== null) {
          callFailureCallback(callback, lstatError);
          return;
        }
        if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
          callSuccessCallback(callback, lstat);
          return;
        }
        settings.fs.stat(path2, (statError, stat) => {
          if (statError !== null) {
            if (settings.throwErrorOnBrokenSymbolicLink) {
              callFailureCallback(callback, statError);
              return;
            }
            callSuccessCallback(callback, lstat);
            return;
          }
          if (settings.markSymbolicLink) {
            stat.isSymbolicLink = () => true;
          }
          callSuccessCallback(callback, stat);
        });
      });
    }
    exports2.read = read;
    function callFailureCallback(callback, error) {
      callback(error);
    }
    function callSuccessCallback(callback, result) {
      callback(null, result);
    }
  }
});

// ../../node_modules/@nodelib/fs.stat/out/providers/sync.js
var require_sync = __commonJS({
  "../../node_modules/@nodelib/fs.stat/out/providers/sync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.read = void 0;
    function read(path2, settings) {
      const lstat = settings.fs.lstatSync(path2);
      if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
        return lstat;
      }
      try {
        const stat = settings.fs.statSync(path2);
        if (settings.markSymbolicLink) {
          stat.isSymbolicLink = () => true;
        }
        return stat;
      } catch (error) {
        if (!settings.throwErrorOnBrokenSymbolicLink) {
          return lstat;
        }
        throw error;
      }
    }
    exports2.read = read;
  }
});

// ../../node_modules/@nodelib/fs.stat/out/adapters/fs.js
var require_fs2 = __commonJS({
  "../../node_modules/@nodelib/fs.stat/out/adapters/fs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createFileSystemAdapter = exports2.FILE_SYSTEM_ADAPTER = void 0;
    var fs5 = require("fs");
    exports2.FILE_SYSTEM_ADAPTER = {
      lstat: fs5.lstat,
      stat: fs5.stat,
      lstatSync: fs5.lstatSync,
      statSync: fs5.statSync
    };
    function createFileSystemAdapter(fsMethods) {
      if (fsMethods === void 0) {
        return exports2.FILE_SYSTEM_ADAPTER;
      }
      return Object.assign(Object.assign({}, exports2.FILE_SYSTEM_ADAPTER), fsMethods);
    }
    exports2.createFileSystemAdapter = createFileSystemAdapter;
  }
});

// ../../node_modules/@nodelib/fs.stat/out/settings.js
var require_settings = __commonJS({
  "../../node_modules/@nodelib/fs.stat/out/settings.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var fs5 = require_fs2();
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, true);
        this.fs = fs5.createFileSystemAdapter(this._options.fs);
        this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
      }
      _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
      }
    };
    exports2.default = Settings;
  }
});

// ../../node_modules/@nodelib/fs.stat/out/index.js
var require_out = __commonJS({
  "../../node_modules/@nodelib/fs.stat/out/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.statSync = exports2.stat = exports2.Settings = void 0;
    var async = require_async();
    var sync2 = require_sync();
    var settings_1 = require_settings();
    exports2.Settings = settings_1.default;
    function stat(path2, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        async.read(path2, getSettings(), optionsOrSettingsOrCallback);
        return;
      }
      async.read(path2, getSettings(optionsOrSettingsOrCallback), callback);
    }
    exports2.stat = stat;
    function statSync(path2, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      return sync2.read(path2, settings);
    }
    exports2.statSync = statSync;
    function getSettings(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
      }
      return new settings_1.default(settingsOrOptions);
    }
  }
});

// ../../node_modules/queue-microtask/index.js
var require_queue_microtask = __commonJS({
  "../../node_modules/queue-microtask/index.js"(exports2, module2) {
    var promise;
    module2.exports = typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : global) : (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err2) => setTimeout(() => {
      throw err2;
    }, 0));
  }
});

// ../../node_modules/run-parallel/index.js
var require_run_parallel = __commonJS({
  "../../node_modules/run-parallel/index.js"(exports2, module2) {
    module2.exports = runParallel;
    var queueMicrotask2 = require_queue_microtask();
    function runParallel(tasks, cb) {
      let results, pending, keys;
      let isSync = true;
      if (Array.isArray(tasks)) {
        results = [];
        pending = tasks.length;
      } else {
        keys = Object.keys(tasks);
        results = {};
        pending = keys.length;
      }
      function done(err2) {
        function end() {
          if (cb)
            cb(err2, results);
          cb = null;
        }
        if (isSync)
          queueMicrotask2(end);
        else
          end();
      }
      function each(i2, err2, result) {
        results[i2] = result;
        if (--pending === 0 || err2) {
          done(err2);
        }
      }
      if (!pending) {
        done(null);
      } else if (keys) {
        keys.forEach(function(key) {
          tasks[key](function(err2, result) {
            each(key, err2, result);
          });
        });
      } else {
        tasks.forEach(function(task, i2) {
          task(function(err2, result) {
            each(i2, err2, result);
          });
        });
      }
      isSync = false;
    }
  }
});

// ../../node_modules/@nodelib/fs.scandir/out/constants.js
var require_constants3 = __commonJS({
  "../../node_modules/@nodelib/fs.scandir/out/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IS_SUPPORT_READDIR_WITH_FILE_TYPES = void 0;
    var NODE_PROCESS_VERSION_PARTS = process.versions.node.split(".");
    if (NODE_PROCESS_VERSION_PARTS[0] === void 0 || NODE_PROCESS_VERSION_PARTS[1] === void 0) {
      throw new Error(`Unexpected behavior. The 'process.versions.node' variable has invalid value: ${process.versions.node}`);
    }
    var MAJOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[0], 10);
    var MINOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[1], 10);
    var SUPPORTED_MAJOR_VERSION = 10;
    var SUPPORTED_MINOR_VERSION = 10;
    var IS_MATCHED_BY_MAJOR = MAJOR_VERSION > SUPPORTED_MAJOR_VERSION;
    var IS_MATCHED_BY_MAJOR_AND_MINOR = MAJOR_VERSION === SUPPORTED_MAJOR_VERSION && MINOR_VERSION >= SUPPORTED_MINOR_VERSION;
    exports2.IS_SUPPORT_READDIR_WITH_FILE_TYPES = IS_MATCHED_BY_MAJOR || IS_MATCHED_BY_MAJOR_AND_MINOR;
  }
});

// ../../node_modules/@nodelib/fs.scandir/out/utils/fs.js
var require_fs3 = __commonJS({
  "../../node_modules/@nodelib/fs.scandir/out/utils/fs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createDirentFromStats = void 0;
    var DirentFromStats = class {
      constructor(name2, stats) {
        this.name = name2;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
      }
    };
    function createDirentFromStats(name2, stats) {
      return new DirentFromStats(name2, stats);
    }
    exports2.createDirentFromStats = createDirentFromStats;
  }
});

// ../../node_modules/@nodelib/fs.scandir/out/utils/index.js
var require_utils4 = __commonJS({
  "../../node_modules/@nodelib/fs.scandir/out/utils/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fs = void 0;
    var fs5 = require_fs3();
    exports2.fs = fs5;
  }
});

// ../../node_modules/@nodelib/fs.scandir/out/providers/common.js
var require_common = __commonJS({
  "../../node_modules/@nodelib/fs.scandir/out/providers/common.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.joinPathSegments = void 0;
    function joinPathSegments(a, b, separator) {
      if (a.endsWith(separator)) {
        return a + b;
      }
      return a + separator + b;
    }
    exports2.joinPathSegments = joinPathSegments;
  }
});

// ../../node_modules/@nodelib/fs.scandir/out/providers/async.js
var require_async2 = __commonJS({
  "../../node_modules/@nodelib/fs.scandir/out/providers/async.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.readdir = exports2.readdirWithFileTypes = exports2.read = void 0;
    var fsStat = require_out();
    var rpl = require_run_parallel();
    var constants_1 = require_constants3();
    var utils = require_utils4();
    var common = require_common();
    function read(directory, settings, callback) {
      if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        readdirWithFileTypes(directory, settings, callback);
        return;
      }
      readdir(directory, settings, callback);
    }
    exports2.read = read;
    function readdirWithFileTypes(directory, settings, callback) {
      settings.fs.readdir(directory, { withFileTypes: true }, (readdirError, dirents) => {
        if (readdirError !== null) {
          callFailureCallback(callback, readdirError);
          return;
        }
        const entries = dirents.map((dirent) => ({
          dirent,
          name: dirent.name,
          path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
        }));
        if (!settings.followSymbolicLinks) {
          callSuccessCallback(callback, entries);
          return;
        }
        const tasks = entries.map((entry) => makeRplTaskEntry(entry, settings));
        rpl(tasks, (rplError, rplEntries) => {
          if (rplError !== null) {
            callFailureCallback(callback, rplError);
            return;
          }
          callSuccessCallback(callback, rplEntries);
        });
      });
    }
    exports2.readdirWithFileTypes = readdirWithFileTypes;
    function makeRplTaskEntry(entry, settings) {
      return (done) => {
        if (!entry.dirent.isSymbolicLink()) {
          done(null, entry);
          return;
        }
        settings.fs.stat(entry.path, (statError, stats) => {
          if (statError !== null) {
            if (settings.throwErrorOnBrokenSymbolicLink) {
              done(statError);
              return;
            }
            done(null, entry);
            return;
          }
          entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
          done(null, entry);
        });
      };
    }
    function readdir(directory, settings, callback) {
      settings.fs.readdir(directory, (readdirError, names) => {
        if (readdirError !== null) {
          callFailureCallback(callback, readdirError);
          return;
        }
        const tasks = names.map((name2) => {
          const path2 = common.joinPathSegments(directory, name2, settings.pathSegmentSeparator);
          return (done) => {
            fsStat.stat(path2, settings.fsStatSettings, (error, stats) => {
              if (error !== null) {
                done(error);
                return;
              }
              const entry = {
                name: name2,
                path: path2,
                dirent: utils.fs.createDirentFromStats(name2, stats)
              };
              if (settings.stats) {
                entry.stats = stats;
              }
              done(null, entry);
            });
          };
        });
        rpl(tasks, (rplError, entries) => {
          if (rplError !== null) {
            callFailureCallback(callback, rplError);
            return;
          }
          callSuccessCallback(callback, entries);
        });
      });
    }
    exports2.readdir = readdir;
    function callFailureCallback(callback, error) {
      callback(error);
    }
    function callSuccessCallback(callback, result) {
      callback(null, result);
    }
  }
});

// ../../node_modules/@nodelib/fs.scandir/out/providers/sync.js
var require_sync2 = __commonJS({
  "../../node_modules/@nodelib/fs.scandir/out/providers/sync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.readdir = exports2.readdirWithFileTypes = exports2.read = void 0;
    var fsStat = require_out();
    var constants_1 = require_constants3();
    var utils = require_utils4();
    var common = require_common();
    function read(directory, settings) {
      if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        return readdirWithFileTypes(directory, settings);
      }
      return readdir(directory, settings);
    }
    exports2.read = read;
    function readdirWithFileTypes(directory, settings) {
      const dirents = settings.fs.readdirSync(directory, { withFileTypes: true });
      return dirents.map((dirent) => {
        const entry = {
          dirent,
          name: dirent.name,
          path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
        };
        if (entry.dirent.isSymbolicLink() && settings.followSymbolicLinks) {
          try {
            const stats = settings.fs.statSync(entry.path);
            entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
          } catch (error) {
            if (settings.throwErrorOnBrokenSymbolicLink) {
              throw error;
            }
          }
        }
        return entry;
      });
    }
    exports2.readdirWithFileTypes = readdirWithFileTypes;
    function readdir(directory, settings) {
      const names = settings.fs.readdirSync(directory);
      return names.map((name2) => {
        const entryPath = common.joinPathSegments(directory, name2, settings.pathSegmentSeparator);
        const stats = fsStat.statSync(entryPath, settings.fsStatSettings);
        const entry = {
          name: name2,
          path: entryPath,
          dirent: utils.fs.createDirentFromStats(name2, stats)
        };
        if (settings.stats) {
          entry.stats = stats;
        }
        return entry;
      });
    }
    exports2.readdir = readdir;
  }
});

// ../../node_modules/@nodelib/fs.scandir/out/adapters/fs.js
var require_fs4 = __commonJS({
  "../../node_modules/@nodelib/fs.scandir/out/adapters/fs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createFileSystemAdapter = exports2.FILE_SYSTEM_ADAPTER = void 0;
    var fs5 = require("fs");
    exports2.FILE_SYSTEM_ADAPTER = {
      lstat: fs5.lstat,
      stat: fs5.stat,
      lstatSync: fs5.lstatSync,
      statSync: fs5.statSync,
      readdir: fs5.readdir,
      readdirSync: fs5.readdirSync
    };
    function createFileSystemAdapter(fsMethods) {
      if (fsMethods === void 0) {
        return exports2.FILE_SYSTEM_ADAPTER;
      }
      return Object.assign(Object.assign({}, exports2.FILE_SYSTEM_ADAPTER), fsMethods);
    }
    exports2.createFileSystemAdapter = createFileSystemAdapter;
  }
});

// ../../node_modules/@nodelib/fs.scandir/out/settings.js
var require_settings2 = __commonJS({
  "../../node_modules/@nodelib/fs.scandir/out/settings.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var path2 = require("path");
    var fsStat = require_out();
    var fs5 = require_fs4();
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, false);
        this.fs = fs5.createFileSystemAdapter(this._options.fs);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path2.sep);
        this.stats = this._getValue(this._options.stats, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
        this.fsStatSettings = new fsStat.Settings({
          followSymbolicLink: this.followSymbolicLinks,
          fs: this.fs,
          throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink
        });
      }
      _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
      }
    };
    exports2.default = Settings;
  }
});

// ../../node_modules/@nodelib/fs.scandir/out/index.js
var require_out2 = __commonJS({
  "../../node_modules/@nodelib/fs.scandir/out/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Settings = exports2.scandirSync = exports2.scandir = void 0;
    var async = require_async2();
    var sync2 = require_sync2();
    var settings_1 = require_settings2();
    exports2.Settings = settings_1.default;
    function scandir(path2, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        async.read(path2, getSettings(), optionsOrSettingsOrCallback);
        return;
      }
      async.read(path2, getSettings(optionsOrSettingsOrCallback), callback);
    }
    exports2.scandir = scandir;
    function scandirSync(path2, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      return sync2.read(path2, settings);
    }
    exports2.scandirSync = scandirSync;
    function getSettings(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
      }
      return new settings_1.default(settingsOrOptions);
    }
  }
});

// ../../node_modules/reusify/reusify.js
var require_reusify = __commonJS({
  "../../node_modules/reusify/reusify.js"(exports2, module2) {
    "use strict";
    function reusify(Constructor) {
      var head = new Constructor();
      var tail = head;
      function get() {
        var current = head;
        if (current.next) {
          head = current.next;
        } else {
          head = new Constructor();
          tail = head;
        }
        current.next = null;
        return current;
      }
      function release(obj) {
        tail.next = obj;
        tail = obj;
      }
      return {
        get,
        release
      };
    }
    module2.exports = reusify;
  }
});

// ../../node_modules/fastq/queue.js
var require_queue = __commonJS({
  "../../node_modules/fastq/queue.js"(exports2, module2) {
    "use strict";
    var reusify = require_reusify();
    function fastqueue(context, worker2, concurrency) {
      if (typeof context === "function") {
        concurrency = worker2;
        worker2 = context;
        context = null;
      }
      if (concurrency < 1) {
        throw new Error("fastqueue concurrency must be greater than 1");
      }
      var cache = reusify(Task);
      var queueHead = null;
      var queueTail = null;
      var _running = 0;
      var errorHandler = null;
      var self2 = {
        push,
        drain: noop,
        saturated: noop,
        pause,
        paused: false,
        concurrency,
        running,
        resume,
        idle,
        length,
        getQueue,
        unshift,
        empty: noop,
        kill,
        killAndDrain,
        error
      };
      return self2;
      function running() {
        return _running;
      }
      function pause() {
        self2.paused = true;
      }
      function length() {
        var current = queueHead;
        var counter = 0;
        while (current) {
          current = current.next;
          counter++;
        }
        return counter;
      }
      function getQueue() {
        var current = queueHead;
        var tasks = [];
        while (current) {
          tasks.push(current.value);
          current = current.next;
        }
        return tasks;
      }
      function resume() {
        if (!self2.paused)
          return;
        self2.paused = false;
        for (var i2 = 0; i2 < self2.concurrency; i2++) {
          _running++;
          release();
        }
      }
      function idle() {
        return _running === 0 && self2.length() === 0;
      }
      function push(value, done) {
        var current = cache.get();
        current.context = context;
        current.release = release;
        current.value = value;
        current.callback = done || noop;
        current.errorHandler = errorHandler;
        if (_running === self2.concurrency || self2.paused) {
          if (queueTail) {
            queueTail.next = current;
            queueTail = current;
          } else {
            queueHead = current;
            queueTail = current;
            self2.saturated();
          }
        } else {
          _running++;
          worker2.call(context, current.value, current.worked);
        }
      }
      function unshift(value, done) {
        var current = cache.get();
        current.context = context;
        current.release = release;
        current.value = value;
        current.callback = done || noop;
        if (_running === self2.concurrency || self2.paused) {
          if (queueHead) {
            current.next = queueHead;
            queueHead = current;
          } else {
            queueHead = current;
            queueTail = current;
            self2.saturated();
          }
        } else {
          _running++;
          worker2.call(context, current.value, current.worked);
        }
      }
      function release(holder) {
        if (holder) {
          cache.release(holder);
        }
        var next = queueHead;
        if (next) {
          if (!self2.paused) {
            if (queueTail === queueHead) {
              queueTail = null;
            }
            queueHead = next.next;
            next.next = null;
            worker2.call(context, next.value, next.worked);
            if (queueTail === null) {
              self2.empty();
            }
          } else {
            _running--;
          }
        } else if (--_running === 0) {
          self2.drain();
        }
      }
      function kill() {
        queueHead = null;
        queueTail = null;
        self2.drain = noop;
      }
      function killAndDrain() {
        queueHead = null;
        queueTail = null;
        self2.drain();
        self2.drain = noop;
      }
      function error(handler) {
        errorHandler = handler;
      }
    }
    function noop() {
    }
    function Task() {
      this.value = null;
      this.callback = noop;
      this.next = null;
      this.release = noop;
      this.context = null;
      this.errorHandler = null;
      var self2 = this;
      this.worked = function worked(err2, result) {
        var callback = self2.callback;
        var errorHandler = self2.errorHandler;
        var val = self2.value;
        self2.value = null;
        self2.callback = noop;
        if (self2.errorHandler) {
          errorHandler(err2, val);
        }
        callback.call(self2.context, err2, result);
        self2.release(self2);
      };
    }
    function queueAsPromised(context, worker2, concurrency) {
      if (typeof context === "function") {
        concurrency = worker2;
        worker2 = context;
        context = null;
      }
      function asyncWrapper(arg, cb) {
        worker2.call(this, arg).then(function(res) {
          cb(null, res);
        }, cb);
      }
      var queue = fastqueue(context, asyncWrapper, concurrency);
      var pushCb = queue.push;
      var unshiftCb = queue.unshift;
      queue.push = push;
      queue.unshift = unshift;
      queue.drained = drained;
      return queue;
      function push(value) {
        var p = new Promise(function(resolve, reject) {
          pushCb(value, function(err2, result) {
            if (err2) {
              reject(err2);
              return;
            }
            resolve(result);
          });
        });
        p.catch(noop);
        return p;
      }
      function unshift(value) {
        var p = new Promise(function(resolve, reject) {
          unshiftCb(value, function(err2, result) {
            if (err2) {
              reject(err2);
              return;
            }
            resolve(result);
          });
        });
        p.catch(noop);
        return p;
      }
      function drained() {
        var previousDrain = queue.drain;
        var p = new Promise(function(resolve) {
          queue.drain = function() {
            previousDrain();
            resolve();
          };
        });
        return p;
      }
    }
    module2.exports = fastqueue;
    module2.exports.promise = queueAsPromised;
  }
});

// ../../node_modules/@nodelib/fs.walk/out/readers/common.js
var require_common2 = __commonJS({
  "../../node_modules/@nodelib/fs.walk/out/readers/common.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.joinPathSegments = exports2.replacePathSegmentSeparator = exports2.isAppliedFilter = exports2.isFatalError = void 0;
    function isFatalError(settings, error) {
      if (settings.errorFilter === null) {
        return true;
      }
      return !settings.errorFilter(error);
    }
    exports2.isFatalError = isFatalError;
    function isAppliedFilter(filter, value) {
      return filter === null || filter(value);
    }
    exports2.isAppliedFilter = isAppliedFilter;
    function replacePathSegmentSeparator(filepath, separator) {
      return filepath.split(/[/\\]/).join(separator);
    }
    exports2.replacePathSegmentSeparator = replacePathSegmentSeparator;
    function joinPathSegments(a, b, separator) {
      if (a === "") {
        return b;
      }
      if (a.endsWith(separator)) {
        return a + b;
      }
      return a + separator + b;
    }
    exports2.joinPathSegments = joinPathSegments;
  }
});

// ../../node_modules/@nodelib/fs.walk/out/readers/reader.js
var require_reader = __commonJS({
  "../../node_modules/@nodelib/fs.walk/out/readers/reader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var common = require_common2();
    var Reader = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._root = common.replacePathSegmentSeparator(_root, _settings.pathSegmentSeparator);
      }
    };
    exports2.default = Reader;
  }
});

// ../../node_modules/@nodelib/fs.walk/out/readers/async.js
var require_async3 = __commonJS({
  "../../node_modules/@nodelib/fs.walk/out/readers/async.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var events_1 = require("events");
    var fsScandir = require_out2();
    var fastq = require_queue();
    var common = require_common2();
    var reader_1 = require_reader();
    var AsyncReader = class extends reader_1.default {
      constructor(_root, _settings) {
        super(_root, _settings);
        this._settings = _settings;
        this._scandir = fsScandir.scandir;
        this._emitter = new events_1.EventEmitter();
        this._queue = fastq(this._worker.bind(this), this._settings.concurrency);
        this._isFatalError = false;
        this._isDestroyed = false;
        this._queue.drain = () => {
          if (!this._isFatalError) {
            this._emitter.emit("end");
          }
        };
      }
      read() {
        this._isFatalError = false;
        this._isDestroyed = false;
        setImmediate(() => {
          this._pushToQueue(this._root, this._settings.basePath);
        });
        return this._emitter;
      }
      get isDestroyed() {
        return this._isDestroyed;
      }
      destroy() {
        if (this._isDestroyed) {
          throw new Error("The reader is already destroyed");
        }
        this._isDestroyed = true;
        this._queue.killAndDrain();
      }
      onEntry(callback) {
        this._emitter.on("entry", callback);
      }
      onError(callback) {
        this._emitter.once("error", callback);
      }
      onEnd(callback) {
        this._emitter.once("end", callback);
      }
      _pushToQueue(directory, base) {
        const queueItem = { directory, base };
        this._queue.push(queueItem, (error) => {
          if (error !== null) {
            this._handleError(error);
          }
        });
      }
      _worker(item, done) {
        this._scandir(item.directory, this._settings.fsScandirSettings, (error, entries) => {
          if (error !== null) {
            done(error, void 0);
            return;
          }
          for (const entry of entries) {
            this._handleEntry(entry, item.base);
          }
          done(null, void 0);
        });
      }
      _handleError(error) {
        if (this._isDestroyed || !common.isFatalError(this._settings, error)) {
          return;
        }
        this._isFatalError = true;
        this._isDestroyed = true;
        this._emitter.emit("error", error);
      }
      _handleEntry(entry, base) {
        if (this._isDestroyed || this._isFatalError) {
          return;
        }
        const fullpath = entry.path;
        if (base !== void 0) {
          entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
        }
        if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
          this._emitEntry(entry);
        }
        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
          this._pushToQueue(fullpath, base === void 0 ? void 0 : entry.path);
        }
      }
      _emitEntry(entry) {
        this._emitter.emit("entry", entry);
      }
    };
    exports2.default = AsyncReader;
  }
});

// ../../node_modules/@nodelib/fs.walk/out/providers/async.js
var require_async4 = __commonJS({
  "../../node_modules/@nodelib/fs.walk/out/providers/async.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var async_1 = require_async3();
    var AsyncProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_1.default(this._root, this._settings);
        this._storage = [];
      }
      read(callback) {
        this._reader.onError((error) => {
          callFailureCallback(callback, error);
        });
        this._reader.onEntry((entry) => {
          this._storage.push(entry);
        });
        this._reader.onEnd(() => {
          callSuccessCallback(callback, this._storage);
        });
        this._reader.read();
      }
    };
    exports2.default = AsyncProvider;
    function callFailureCallback(callback, error) {
      callback(error);
    }
    function callSuccessCallback(callback, entries) {
      callback(null, entries);
    }
  }
});

// ../../node_modules/@nodelib/fs.walk/out/providers/stream.js
var require_stream2 = __commonJS({
  "../../node_modules/@nodelib/fs.walk/out/providers/stream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var stream_1 = require("stream");
    var async_1 = require_async3();
    var StreamProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_1.default(this._root, this._settings);
        this._stream = new stream_1.Readable({
          objectMode: true,
          read: () => {
          },
          destroy: () => {
            if (!this._reader.isDestroyed) {
              this._reader.destroy();
            }
          }
        });
      }
      read() {
        this._reader.onError((error) => {
          this._stream.emit("error", error);
        });
        this._reader.onEntry((entry) => {
          this._stream.push(entry);
        });
        this._reader.onEnd(() => {
          this._stream.push(null);
        });
        this._reader.read();
        return this._stream;
      }
    };
    exports2.default = StreamProvider;
  }
});

// ../../node_modules/@nodelib/fs.walk/out/readers/sync.js
var require_sync3 = __commonJS({
  "../../node_modules/@nodelib/fs.walk/out/readers/sync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var fsScandir = require_out2();
    var common = require_common2();
    var reader_1 = require_reader();
    var SyncReader = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._scandir = fsScandir.scandirSync;
        this._storage = [];
        this._queue = /* @__PURE__ */ new Set();
      }
      read() {
        this._pushToQueue(this._root, this._settings.basePath);
        this._handleQueue();
        return this._storage;
      }
      _pushToQueue(directory, base) {
        this._queue.add({ directory, base });
      }
      _handleQueue() {
        for (const item of this._queue.values()) {
          this._handleDirectory(item.directory, item.base);
        }
      }
      _handleDirectory(directory, base) {
        try {
          const entries = this._scandir(directory, this._settings.fsScandirSettings);
          for (const entry of entries) {
            this._handleEntry(entry, base);
          }
        } catch (error) {
          this._handleError(error);
        }
      }
      _handleError(error) {
        if (!common.isFatalError(this._settings, error)) {
          return;
        }
        throw error;
      }
      _handleEntry(entry, base) {
        const fullpath = entry.path;
        if (base !== void 0) {
          entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
        }
        if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
          this._pushToStorage(entry);
        }
        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
          this._pushToQueue(fullpath, base === void 0 ? void 0 : entry.path);
        }
      }
      _pushToStorage(entry) {
        this._storage.push(entry);
      }
    };
    exports2.default = SyncReader;
  }
});

// ../../node_modules/@nodelib/fs.walk/out/providers/sync.js
var require_sync4 = __commonJS({
  "../../node_modules/@nodelib/fs.walk/out/providers/sync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var sync_1 = require_sync3();
    var SyncProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new sync_1.default(this._root, this._settings);
      }
      read() {
        return this._reader.read();
      }
    };
    exports2.default = SyncProvider;
  }
});

// ../../node_modules/@nodelib/fs.walk/out/settings.js
var require_settings3 = __commonJS({
  "../../node_modules/@nodelib/fs.walk/out/settings.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var path2 = require("path");
    var fsScandir = require_out2();
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.basePath = this._getValue(this._options.basePath, void 0);
        this.concurrency = this._getValue(this._options.concurrency, Number.POSITIVE_INFINITY);
        this.deepFilter = this._getValue(this._options.deepFilter, null);
        this.entryFilter = this._getValue(this._options.entryFilter, null);
        this.errorFilter = this._getValue(this._options.errorFilter, null);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path2.sep);
        this.fsScandirSettings = new fsScandir.Settings({
          followSymbolicLinks: this._options.followSymbolicLinks,
          fs: this._options.fs,
          pathSegmentSeparator: this._options.pathSegmentSeparator,
          stats: this._options.stats,
          throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink
        });
      }
      _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
      }
    };
    exports2.default = Settings;
  }
});

// ../../node_modules/@nodelib/fs.walk/out/index.js
var require_out3 = __commonJS({
  "../../node_modules/@nodelib/fs.walk/out/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Settings = exports2.walkStream = exports2.walkSync = exports2.walk = void 0;
    var async_1 = require_async4();
    var stream_1 = require_stream2();
    var sync_1 = require_sync4();
    var settings_1 = require_settings3();
    exports2.Settings = settings_1.default;
    function walk(directory, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        new async_1.default(directory, getSettings()).read(optionsOrSettingsOrCallback);
        return;
      }
      new async_1.default(directory, getSettings(optionsOrSettingsOrCallback)).read(callback);
    }
    exports2.walk = walk;
    function walkSync(directory, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      const provider = new sync_1.default(directory, settings);
      return provider.read();
    }
    exports2.walkSync = walkSync;
    function walkStream(directory, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      const provider = new stream_1.default(directory, settings);
      return provider.read();
    }
    exports2.walkStream = walkStream;
    function getSettings(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
      }
      return new settings_1.default(settingsOrOptions);
    }
  }
});

// ../../node_modules/fast-glob/out/readers/reader.js
var require_reader2 = __commonJS({
  "../../node_modules/fast-glob/out/readers/reader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var path2 = require("path");
    var fsStat = require_out();
    var utils = require_utils3();
    var Reader = class {
      constructor(_settings) {
        this._settings = _settings;
        this._fsStatSettings = new fsStat.Settings({
          followSymbolicLink: this._settings.followSymbolicLinks,
          fs: this._settings.fs,
          throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks
        });
      }
      _getFullEntryPath(filepath) {
        return path2.resolve(this._settings.cwd, filepath);
      }
      _makeEntry(stats, pattern) {
        const entry = {
          name: pattern,
          path: pattern,
          dirent: utils.fs.createDirentFromStats(pattern, stats)
        };
        if (this._settings.stats) {
          entry.stats = stats;
        }
        return entry;
      }
      _isFatalError(error) {
        return !utils.errno.isEnoentCodeError(error) && !this._settings.suppressErrors;
      }
    };
    exports2.default = Reader;
  }
});

// ../../node_modules/fast-glob/out/readers/stream.js
var require_stream3 = __commonJS({
  "../../node_modules/fast-glob/out/readers/stream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var stream_1 = require("stream");
    var fsStat = require_out();
    var fsWalk = require_out3();
    var reader_1 = require_reader2();
    var ReaderStream = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._walkStream = fsWalk.walkStream;
        this._stat = fsStat.stat;
      }
      dynamic(root, options) {
        return this._walkStream(root, options);
      }
      static(patterns, options) {
        const filepaths = patterns.map(this._getFullEntryPath, this);
        const stream = new stream_1.PassThrough({ objectMode: true });
        stream._write = (index, _enc, done) => {
          return this._getEntry(filepaths[index], patterns[index], options).then((entry) => {
            if (entry !== null && options.entryFilter(entry)) {
              stream.push(entry);
            }
            if (index === filepaths.length - 1) {
              stream.end();
            }
            done();
          }).catch(done);
        };
        for (let i2 = 0; i2 < filepaths.length; i2++) {
          stream.write(i2);
        }
        return stream;
      }
      _getEntry(filepath, pattern, options) {
        return this._getStat(filepath).then((stats) => this._makeEntry(stats, pattern)).catch((error) => {
          if (options.errorFilter(error)) {
            return null;
          }
          throw error;
        });
      }
      _getStat(filepath) {
        return new Promise((resolve, reject) => {
          this._stat(filepath, this._fsStatSettings, (error, stats) => {
            return error === null ? resolve(stats) : reject(error);
          });
        });
      }
    };
    exports2.default = ReaderStream;
  }
});

// ../../node_modules/fast-glob/out/readers/async.js
var require_async5 = __commonJS({
  "../../node_modules/fast-glob/out/readers/async.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var fsWalk = require_out3();
    var reader_1 = require_reader2();
    var stream_1 = require_stream3();
    var ReaderAsync = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._walkAsync = fsWalk.walk;
        this._readerStream = new stream_1.default(this._settings);
      }
      dynamic(root, options) {
        return new Promise((resolve, reject) => {
          this._walkAsync(root, options, (error, entries) => {
            if (error === null) {
              resolve(entries);
            } else {
              reject(error);
            }
          });
        });
      }
      async static(patterns, options) {
        const entries = [];
        const stream = this._readerStream.static(patterns, options);
        return new Promise((resolve, reject) => {
          stream.once("error", reject);
          stream.on("data", (entry) => entries.push(entry));
          stream.once("end", () => resolve(entries));
        });
      }
    };
    exports2.default = ReaderAsync;
  }
});

// ../../node_modules/fast-glob/out/providers/matchers/matcher.js
var require_matcher = __commonJS({
  "../../node_modules/fast-glob/out/providers/matchers/matcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils = require_utils3();
    var Matcher = class {
      constructor(_patterns, _settings, _micromatchOptions) {
        this._patterns = _patterns;
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this._storage = [];
        this._fillStorage();
      }
      _fillStorage() {
        for (const pattern of this._patterns) {
          const segments = this._getPatternSegments(pattern);
          const sections = this._splitSegmentsIntoSections(segments);
          this._storage.push({
            complete: sections.length <= 1,
            pattern,
            segments,
            sections
          });
        }
      }
      _getPatternSegments(pattern) {
        const parts2 = utils.pattern.getPatternParts(pattern, this._micromatchOptions);
        return parts2.map((part) => {
          const dynamic = utils.pattern.isDynamicPattern(part, this._settings);
          if (!dynamic) {
            return {
              dynamic: false,
              pattern: part
            };
          }
          return {
            dynamic: true,
            pattern: part,
            patternRe: utils.pattern.makeRe(part, this._micromatchOptions)
          };
        });
      }
      _splitSegmentsIntoSections(segments) {
        return utils.array.splitWhen(segments, (segment) => segment.dynamic && utils.pattern.hasGlobStar(segment.pattern));
      }
    };
    exports2.default = Matcher;
  }
});

// ../../node_modules/fast-glob/out/providers/matchers/partial.js
var require_partial = __commonJS({
  "../../node_modules/fast-glob/out/providers/matchers/partial.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var matcher_1 = require_matcher();
    var PartialMatcher = class extends matcher_1.default {
      match(filepath) {
        const parts2 = filepath.split("/");
        const levels = parts2.length;
        const patterns = this._storage.filter((info2) => !info2.complete || info2.segments.length > levels);
        for (const pattern of patterns) {
          const section = pattern.sections[0];
          if (!pattern.complete && levels > section.length) {
            return true;
          }
          const match = parts2.every((part, index) => {
            const segment = pattern.segments[index];
            if (segment.dynamic && segment.patternRe.test(part)) {
              return true;
            }
            if (!segment.dynamic && segment.pattern === part) {
              return true;
            }
            return false;
          });
          if (match) {
            return true;
          }
        }
        return false;
      }
    };
    exports2.default = PartialMatcher;
  }
});

// ../../node_modules/fast-glob/out/providers/filters/deep.js
var require_deep = __commonJS({
  "../../node_modules/fast-glob/out/providers/filters/deep.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils = require_utils3();
    var partial_1 = require_partial();
    var DeepFilter = class {
      constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
      }
      getFilter(basePath, positive, negative) {
        const matcher = this._getMatcher(positive);
        const negativeRe = this._getNegativePatternsRe(negative);
        return (entry) => this._filter(basePath, entry, matcher, negativeRe);
      }
      _getMatcher(patterns) {
        return new partial_1.default(patterns, this._settings, this._micromatchOptions);
      }
      _getNegativePatternsRe(patterns) {
        const affectDepthOfReadingPatterns = patterns.filter(utils.pattern.isAffectDepthOfReadingPattern);
        return utils.pattern.convertPatternsToRe(affectDepthOfReadingPatterns, this._micromatchOptions);
      }
      _filter(basePath, entry, matcher, negativeRe) {
        if (this._isSkippedByDeep(basePath, entry.path)) {
          return false;
        }
        if (this._isSkippedSymbolicLink(entry)) {
          return false;
        }
        const filepath = utils.path.removeLeadingDotSegment(entry.path);
        if (this._isSkippedByPositivePatterns(filepath, matcher)) {
          return false;
        }
        return this._isSkippedByNegativePatterns(filepath, negativeRe);
      }
      _isSkippedByDeep(basePath, entryPath) {
        if (this._settings.deep === Infinity) {
          return false;
        }
        return this._getEntryLevel(basePath, entryPath) >= this._settings.deep;
      }
      _getEntryLevel(basePath, entryPath) {
        const entryPathDepth = entryPath.split("/").length;
        if (basePath === "") {
          return entryPathDepth;
        }
        const basePathDepth = basePath.split("/").length;
        return entryPathDepth - basePathDepth;
      }
      _isSkippedSymbolicLink(entry) {
        return !this._settings.followSymbolicLinks && entry.dirent.isSymbolicLink();
      }
      _isSkippedByPositivePatterns(entryPath, matcher) {
        return !this._settings.baseNameMatch && !matcher.match(entryPath);
      }
      _isSkippedByNegativePatterns(entryPath, patternsRe) {
        return !utils.pattern.matchAny(entryPath, patternsRe);
      }
    };
    exports2.default = DeepFilter;
  }
});

// ../../node_modules/fast-glob/out/providers/filters/entry.js
var require_entry = __commonJS({
  "../../node_modules/fast-glob/out/providers/filters/entry.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils = require_utils3();
    var EntryFilter = class {
      constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this.index = /* @__PURE__ */ new Map();
      }
      getFilter(positive, negative) {
        const positiveRe = utils.pattern.convertPatternsToRe(positive, this._micromatchOptions);
        const negativeRe = utils.pattern.convertPatternsToRe(negative, Object.assign(Object.assign({}, this._micromatchOptions), { dot: true }));
        return (entry) => this._filter(entry, positiveRe, negativeRe);
      }
      _filter(entry, positiveRe, negativeRe) {
        const filepath = utils.path.removeLeadingDotSegment(entry.path);
        if (this._settings.unique && this._isDuplicateEntry(filepath)) {
          return false;
        }
        if (this._onlyFileFilter(entry) || this._onlyDirectoryFilter(entry)) {
          return false;
        }
        if (this._isSkippedByAbsoluteNegativePatterns(filepath, negativeRe)) {
          return false;
        }
        const isDirectory = entry.dirent.isDirectory();
        const isMatched = this._isMatchToPatterns(filepath, positiveRe, isDirectory) && !this._isMatchToPatterns(filepath, negativeRe, isDirectory);
        if (this._settings.unique && isMatched) {
          this._createIndexRecord(filepath);
        }
        return isMatched;
      }
      _isDuplicateEntry(filepath) {
        return this.index.has(filepath);
      }
      _createIndexRecord(filepath) {
        this.index.set(filepath, void 0);
      }
      _onlyFileFilter(entry) {
        return this._settings.onlyFiles && !entry.dirent.isFile();
      }
      _onlyDirectoryFilter(entry) {
        return this._settings.onlyDirectories && !entry.dirent.isDirectory();
      }
      _isSkippedByAbsoluteNegativePatterns(entryPath, patternsRe) {
        if (!this._settings.absolute) {
          return false;
        }
        const fullpath = utils.path.makeAbsolute(this._settings.cwd, entryPath);
        return utils.pattern.matchAny(fullpath, patternsRe);
      }
      _isMatchToPatterns(filepath, patternsRe, isDirectory) {
        const isMatched = utils.pattern.matchAny(filepath, patternsRe);
        if (!isMatched && isDirectory) {
          return utils.pattern.matchAny(filepath + "/", patternsRe);
        }
        return isMatched;
      }
    };
    exports2.default = EntryFilter;
  }
});

// ../../node_modules/fast-glob/out/providers/filters/error.js
var require_error = __commonJS({
  "../../node_modules/fast-glob/out/providers/filters/error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils = require_utils3();
    var ErrorFilter = class {
      constructor(_settings) {
        this._settings = _settings;
      }
      getFilter() {
        return (error) => this._isNonFatalError(error);
      }
      _isNonFatalError(error) {
        return utils.errno.isEnoentCodeError(error) || this._settings.suppressErrors;
      }
    };
    exports2.default = ErrorFilter;
  }
});

// ../../node_modules/fast-glob/out/providers/transformers/entry.js
var require_entry2 = __commonJS({
  "../../node_modules/fast-glob/out/providers/transformers/entry.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils = require_utils3();
    var EntryTransformer = class {
      constructor(_settings) {
        this._settings = _settings;
      }
      getTransformer() {
        return (entry) => this._transform(entry);
      }
      _transform(entry) {
        let filepath = entry.path;
        if (this._settings.absolute) {
          filepath = utils.path.makeAbsolute(this._settings.cwd, filepath);
          filepath = utils.path.unixify(filepath);
        }
        if (this._settings.markDirectories && entry.dirent.isDirectory()) {
          filepath += "/";
        }
        if (!this._settings.objectMode) {
          return filepath;
        }
        return Object.assign(Object.assign({}, entry), { path: filepath });
      }
    };
    exports2.default = EntryTransformer;
  }
});

// ../../node_modules/fast-glob/out/providers/provider.js
var require_provider = __commonJS({
  "../../node_modules/fast-glob/out/providers/provider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var path2 = require("path");
    var deep_1 = require_deep();
    var entry_1 = require_entry();
    var error_1 = require_error();
    var entry_2 = require_entry2();
    var Provider = class {
      constructor(_settings) {
        this._settings = _settings;
        this.errorFilter = new error_1.default(this._settings);
        this.entryFilter = new entry_1.default(this._settings, this._getMicromatchOptions());
        this.deepFilter = new deep_1.default(this._settings, this._getMicromatchOptions());
        this.entryTransformer = new entry_2.default(this._settings);
      }
      _getRootDirectory(task) {
        return path2.resolve(this._settings.cwd, task.base);
      }
      _getReaderOptions(task) {
        const basePath = task.base === "." ? "" : task.base;
        return {
          basePath,
          pathSegmentSeparator: "/",
          concurrency: this._settings.concurrency,
          deepFilter: this.deepFilter.getFilter(basePath, task.positive, task.negative),
          entryFilter: this.entryFilter.getFilter(task.positive, task.negative),
          errorFilter: this.errorFilter.getFilter(),
          followSymbolicLinks: this._settings.followSymbolicLinks,
          fs: this._settings.fs,
          stats: this._settings.stats,
          throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink,
          transform: this.entryTransformer.getTransformer()
        };
      }
      _getMicromatchOptions() {
        return {
          dot: this._settings.dot,
          matchBase: this._settings.baseNameMatch,
          nobrace: !this._settings.braceExpansion,
          nocase: !this._settings.caseSensitiveMatch,
          noext: !this._settings.extglob,
          noglobstar: !this._settings.globstar,
          posix: true,
          strictSlashes: false
        };
      }
    };
    exports2.default = Provider;
  }
});

// ../../node_modules/fast-glob/out/providers/async.js
var require_async6 = __commonJS({
  "../../node_modules/fast-glob/out/providers/async.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var async_1 = require_async5();
    var provider_1 = require_provider();
    var ProviderAsync = class extends provider_1.default {
      constructor() {
        super(...arguments);
        this._reader = new async_1.default(this._settings);
      }
      async read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const entries = await this.api(root, task, options);
        return entries.map((entry) => options.transform(entry));
      }
      api(root, task, options) {
        if (task.dynamic) {
          return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
      }
    };
    exports2.default = ProviderAsync;
  }
});

// ../../node_modules/fast-glob/out/providers/stream.js
var require_stream4 = __commonJS({
  "../../node_modules/fast-glob/out/providers/stream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var stream_1 = require("stream");
    var stream_2 = require_stream3();
    var provider_1 = require_provider();
    var ProviderStream = class extends provider_1.default {
      constructor() {
        super(...arguments);
        this._reader = new stream_2.default(this._settings);
      }
      read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const source = this.api(root, task, options);
        const destination = new stream_1.Readable({ objectMode: true, read: () => {
        } });
        source.once("error", (error) => destination.emit("error", error)).on("data", (entry) => destination.emit("data", options.transform(entry))).once("end", () => destination.emit("end"));
        destination.once("close", () => source.destroy());
        return destination;
      }
      api(root, task, options) {
        if (task.dynamic) {
          return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
      }
    };
    exports2.default = ProviderStream;
  }
});

// ../../node_modules/fast-glob/out/readers/sync.js
var require_sync5 = __commonJS({
  "../../node_modules/fast-glob/out/readers/sync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var fsStat = require_out();
    var fsWalk = require_out3();
    var reader_1 = require_reader2();
    var ReaderSync = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._walkSync = fsWalk.walkSync;
        this._statSync = fsStat.statSync;
      }
      dynamic(root, options) {
        return this._walkSync(root, options);
      }
      static(patterns, options) {
        const entries = [];
        for (const pattern of patterns) {
          const filepath = this._getFullEntryPath(pattern);
          const entry = this._getEntry(filepath, pattern, options);
          if (entry === null || !options.entryFilter(entry)) {
            continue;
          }
          entries.push(entry);
        }
        return entries;
      }
      _getEntry(filepath, pattern, options) {
        try {
          const stats = this._getStat(filepath);
          return this._makeEntry(stats, pattern);
        } catch (error) {
          if (options.errorFilter(error)) {
            return null;
          }
          throw error;
        }
      }
      _getStat(filepath) {
        return this._statSync(filepath, this._fsStatSettings);
      }
    };
    exports2.default = ReaderSync;
  }
});

// ../../node_modules/fast-glob/out/providers/sync.js
var require_sync6 = __commonJS({
  "../../node_modules/fast-glob/out/providers/sync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var sync_1 = require_sync5();
    var provider_1 = require_provider();
    var ProviderSync = class extends provider_1.default {
      constructor() {
        super(...arguments);
        this._reader = new sync_1.default(this._settings);
      }
      read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const entries = this.api(root, task, options);
        return entries.map(options.transform);
      }
      api(root, task, options) {
        if (task.dynamic) {
          return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
      }
    };
    exports2.default = ProviderSync;
  }
});

// ../../node_modules/fast-glob/out/settings.js
var require_settings4 = __commonJS({
  "../../node_modules/fast-glob/out/settings.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DEFAULT_FILE_SYSTEM_ADAPTER = void 0;
    var fs5 = require("fs");
    var os = require("os");
    var CPU_COUNT = Math.max(os.cpus().length, 1);
    exports2.DEFAULT_FILE_SYSTEM_ADAPTER = {
      lstat: fs5.lstat,
      lstatSync: fs5.lstatSync,
      stat: fs5.stat,
      statSync: fs5.statSync,
      readdir: fs5.readdir,
      readdirSync: fs5.readdirSync
    };
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.absolute = this._getValue(this._options.absolute, false);
        this.baseNameMatch = this._getValue(this._options.baseNameMatch, false);
        this.braceExpansion = this._getValue(this._options.braceExpansion, true);
        this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch, true);
        this.concurrency = this._getValue(this._options.concurrency, CPU_COUNT);
        this.cwd = this._getValue(this._options.cwd, process.cwd());
        this.deep = this._getValue(this._options.deep, Infinity);
        this.dot = this._getValue(this._options.dot, false);
        this.extglob = this._getValue(this._options.extglob, true);
        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, true);
        this.fs = this._getFileSystemMethods(this._options.fs);
        this.globstar = this._getValue(this._options.globstar, true);
        this.ignore = this._getValue(this._options.ignore, []);
        this.markDirectories = this._getValue(this._options.markDirectories, false);
        this.objectMode = this._getValue(this._options.objectMode, false);
        this.onlyDirectories = this._getValue(this._options.onlyDirectories, false);
        this.onlyFiles = this._getValue(this._options.onlyFiles, true);
        this.stats = this._getValue(this._options.stats, false);
        this.suppressErrors = this._getValue(this._options.suppressErrors, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, false);
        this.unique = this._getValue(this._options.unique, true);
        if (this.onlyDirectories) {
          this.onlyFiles = false;
        }
        if (this.stats) {
          this.objectMode = true;
        }
        this.ignore = [].concat(this.ignore);
      }
      _getValue(option, value) {
        return option === void 0 ? value : option;
      }
      _getFileSystemMethods(methods = {}) {
        return Object.assign(Object.assign({}, exports2.DEFAULT_FILE_SYSTEM_ADAPTER), methods);
      }
    };
    exports2.default = Settings;
  }
});

// ../../node_modules/fast-glob/out/index.js
var require_out4 = __commonJS({
  "../../node_modules/fast-glob/out/index.js"(exports2, module2) {
    "use strict";
    var taskManager = require_tasks();
    var async_1 = require_async6();
    var stream_1 = require_stream4();
    var sync_1 = require_sync6();
    var settings_1 = require_settings4();
    var utils = require_utils3();
    async function FastGlob(source, options) {
      assertPatternsInput(source);
      const works = getWorks(source, async_1.default, options);
      const result = await Promise.all(works);
      return utils.array.flatten(result);
    }
    (function(FastGlob2) {
      FastGlob2.glob = FastGlob2;
      FastGlob2.globSync = sync2;
      FastGlob2.globStream = stream;
      FastGlob2.async = FastGlob2;
      function sync2(source, options) {
        assertPatternsInput(source);
        const works = getWorks(source, sync_1.default, options);
        return utils.array.flatten(works);
      }
      FastGlob2.sync = sync2;
      function stream(source, options) {
        assertPatternsInput(source);
        const works = getWorks(source, stream_1.default, options);
        return utils.stream.merge(works);
      }
      FastGlob2.stream = stream;
      function generateTasks(source, options) {
        assertPatternsInput(source);
        const patterns = [].concat(source);
        const settings = new settings_1.default(options);
        return taskManager.generate(patterns, settings);
      }
      FastGlob2.generateTasks = generateTasks;
      function isDynamicPattern(source, options) {
        assertPatternsInput(source);
        const settings = new settings_1.default(options);
        return utils.pattern.isDynamicPattern(source, settings);
      }
      FastGlob2.isDynamicPattern = isDynamicPattern;
      function escapePath(source) {
        assertPatternsInput(source);
        return utils.path.escape(source);
      }
      FastGlob2.escapePath = escapePath;
      function convertPathToPattern(source) {
        assertPatternsInput(source);
        return utils.path.convertPathToPattern(source);
      }
      FastGlob2.convertPathToPattern = convertPathToPattern;
      let posix;
      (function(posix2) {
        function escapePath2(source) {
          assertPatternsInput(source);
          return utils.path.escapePosixPath(source);
        }
        posix2.escapePath = escapePath2;
        function convertPathToPattern2(source) {
          assertPatternsInput(source);
          return utils.path.convertPosixPathToPattern(source);
        }
        posix2.convertPathToPattern = convertPathToPattern2;
      })(posix = FastGlob2.posix || (FastGlob2.posix = {}));
      let win32;
      (function(win322) {
        function escapePath2(source) {
          assertPatternsInput(source);
          return utils.path.escapeWindowsPath(source);
        }
        win322.escapePath = escapePath2;
        function convertPathToPattern2(source) {
          assertPatternsInput(source);
          return utils.path.convertWindowsPathToPattern(source);
        }
        win322.convertPathToPattern = convertPathToPattern2;
      })(win32 = FastGlob2.win32 || (FastGlob2.win32 = {}));
    })(FastGlob || (FastGlob = {}));
    function getWorks(source, _Provider, options) {
      const patterns = [].concat(source);
      const settings = new settings_1.default(options);
      const tasks = taskManager.generate(patterns, settings);
      const provider = new _Provider(settings);
      return tasks.map(provider.read, provider);
    }
    function assertPatternsInput(input) {
      const source = [].concat(input);
      const isValidSource = source.every((item) => utils.string.isString(item) && !utils.string.isEmpty(item));
      if (!isValidSource) {
        throw new TypeError("Patterns must be a string (non empty) or an array of strings");
      }
    }
    module2.exports = FastGlob;
  }
});

// ../../node_modules/ws/lib/constants.js
var require_constants4 = __commonJS({
  "../../node_modules/ws/lib/constants.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      BINARY_TYPES: ["nodebuffer", "arraybuffer", "fragments"],
      GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
      kStatusCode: Symbol("status-code"),
      kWebSocket: Symbol("websocket"),
      EMPTY_BUFFER: Buffer.alloc(0),
      NOOP: () => {
      }
    };
  }
});

// ../../node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS({
  "../../node_modules/ws/lib/buffer-util.js"(exports2, module2) {
    "use strict";
    var { EMPTY_BUFFER } = require_constants4();
    function concat(list, totalLength) {
      if (list.length === 0)
        return EMPTY_BUFFER;
      if (list.length === 1)
        return list[0];
      const target = Buffer.allocUnsafe(totalLength);
      let offset = 0;
      for (let i2 = 0; i2 < list.length; i2++) {
        const buf = list[i2];
        target.set(buf, offset);
        offset += buf.length;
      }
      if (offset < totalLength)
        return target.slice(0, offset);
      return target;
    }
    function _mask(source, mask, output, offset, length) {
      for (let i2 = 0; i2 < length; i2++) {
        output[offset + i2] = source[i2] ^ mask[i2 & 3];
      }
    }
    function _unmask(buffer, mask) {
      const length = buffer.length;
      for (let i2 = 0; i2 < length; i2++) {
        buffer[i2] ^= mask[i2 & 3];
      }
    }
    function toArrayBuffer(buf) {
      if (buf.byteLength === buf.buffer.byteLength) {
        return buf.buffer;
      }
      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
    }
    function toBuffer(data2) {
      toBuffer.readOnly = true;
      if (Buffer.isBuffer(data2))
        return data2;
      let buf;
      if (data2 instanceof ArrayBuffer) {
        buf = Buffer.from(data2);
      } else if (ArrayBuffer.isView(data2)) {
        buf = Buffer.from(data2.buffer, data2.byteOffset, data2.byteLength);
      } else {
        buf = Buffer.from(data2);
        toBuffer.readOnly = false;
      }
      return buf;
    }
    try {
      const bufferUtil = require("bufferutil");
      const bu = bufferUtil.BufferUtil || bufferUtil;
      module2.exports = {
        concat,
        mask(source, mask, output, offset, length) {
          if (length < 48)
            _mask(source, mask, output, offset, length);
          else
            bu.mask(source, mask, output, offset, length);
        },
        toArrayBuffer,
        toBuffer,
        unmask(buffer, mask) {
          if (buffer.length < 32)
            _unmask(buffer, mask);
          else
            bu.unmask(buffer, mask);
        }
      };
    } catch (e) {
      module2.exports = {
        concat,
        mask: _mask,
        toArrayBuffer,
        toBuffer,
        unmask: _unmask
      };
    }
  }
});

// ../../node_modules/ws/lib/limiter.js
var require_limiter = __commonJS({
  "../../node_modules/ws/lib/limiter.js"(exports2, module2) {
    "use strict";
    var kDone = Symbol("kDone");
    var kRun = Symbol("kRun");
    var Limiter = class {
      /**
       * Creates a new `Limiter`.
       *
       * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
       *     to run concurrently
       */
      constructor(concurrency) {
        this[kDone] = () => {
          this.pending--;
          this[kRun]();
        };
        this.concurrency = concurrency || Infinity;
        this.jobs = [];
        this.pending = 0;
      }
      /**
       * Adds a job to the queue.
       *
       * @param {Function} job The job to run
       * @public
       */
      add(job) {
        this.jobs.push(job);
        this[kRun]();
      }
      /**
       * Removes a job from the queue and runs it if possible.
       *
       * @private
       */
      [kRun]() {
        if (this.pending === this.concurrency)
          return;
        if (this.jobs.length) {
          const job = this.jobs.shift();
          this.pending++;
          job(this[kDone]);
        }
      }
    };
    module2.exports = Limiter;
  }
});

// ../../node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = __commonJS({
  "../../node_modules/ws/lib/permessage-deflate.js"(exports2, module2) {
    "use strict";
    var zlib = require("zlib");
    var bufferUtil = require_buffer_util();
    var Limiter = require_limiter();
    var { kStatusCode, NOOP } = require_constants4();
    var TRAILER = Buffer.from([0, 0, 255, 255]);
    var kPerMessageDeflate = Symbol("permessage-deflate");
    var kTotalLength = Symbol("total-length");
    var kCallback = Symbol("callback");
    var kBuffers = Symbol("buffers");
    var kError = Symbol("error");
    var zlibLimiter;
    var PerMessageDeflate = class {
      /**
       * Creates a PerMessageDeflate instance.
       *
       * @param {Object} [options] Configuration options
       * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
       *     disabling of server context takeover
       * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
       *     acknowledge disabling of client context takeover
       * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
       *     use of a custom server window size
       * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
       *     for, or request, a custom client window size
       * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
       *     deflate
       * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
       *     inflate
       * @param {Number} [options.threshold=1024] Size (in bytes) below which
       *     messages should not be compressed
       * @param {Number} [options.concurrencyLimit=10] The number of concurrent
       *     calls to zlib
       * @param {Boolean} [isServer=false] Create the instance in either server or
       *     client mode
       * @param {Number} [maxPayload=0] The maximum allowed message length
       */
      constructor(options, isServer, maxPayload) {
        this._maxPayload = maxPayload | 0;
        this._options = options || {};
        this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
        this._isServer = !!isServer;
        this._deflate = null;
        this._inflate = null;
        this.params = null;
        if (!zlibLimiter) {
          const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
          zlibLimiter = new Limiter(concurrency);
        }
      }
      /**
       * @type {String}
       */
      static get extensionName() {
        return "permessage-deflate";
      }
      /**
       * Create an extension negotiation offer.
       *
       * @return {Object} Extension parameters
       * @public
       */
      offer() {
        const params = {};
        if (this._options.serverNoContextTakeover) {
          params.server_no_context_takeover = true;
        }
        if (this._options.clientNoContextTakeover) {
          params.client_no_context_takeover = true;
        }
        if (this._options.serverMaxWindowBits) {
          params.server_max_window_bits = this._options.serverMaxWindowBits;
        }
        if (this._options.clientMaxWindowBits) {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        } else if (this._options.clientMaxWindowBits == null) {
          params.client_max_window_bits = true;
        }
        return params;
      }
      /**
       * Accept an extension negotiation offer/response.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Object} Accepted configuration
       * @public
       */
      accept(configurations) {
        configurations = this.normalizeParams(configurations);
        this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
        return this.params;
      }
      /**
       * Releases all resources used by the extension.
       *
       * @public
       */
      cleanup() {
        if (this._inflate) {
          this._inflate.close();
          this._inflate = null;
        }
        if (this._deflate) {
          const callback = this._deflate[kCallback];
          this._deflate.close();
          this._deflate = null;
          if (callback) {
            callback(
              new Error(
                "The deflate stream was closed while data was being processed"
              )
            );
          }
        }
      }
      /**
       *  Accept an extension negotiation offer.
       *
       * @param {Array} offers The extension negotiation offers
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsServer(offers) {
        const opts = this._options;
        const accepted = offers.find((params) => {
          if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
            return false;
          }
          return true;
        });
        if (!accepted) {
          throw new Error("None of the extension offers can be accepted");
        }
        if (opts.serverNoContextTakeover) {
          accepted.server_no_context_takeover = true;
        }
        if (opts.clientNoContextTakeover) {
          accepted.client_no_context_takeover = true;
        }
        if (typeof opts.serverMaxWindowBits === "number") {
          accepted.server_max_window_bits = opts.serverMaxWindowBits;
        }
        if (typeof opts.clientMaxWindowBits === "number") {
          accepted.client_max_window_bits = opts.clientMaxWindowBits;
        } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
          delete accepted.client_max_window_bits;
        }
        return accepted;
      }
      /**
       * Accept the extension negotiation response.
       *
       * @param {Array} response The extension negotiation response
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsClient(response) {
        const params = response[0];
        if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
          throw new Error('Unexpected parameter "client_no_context_takeover"');
        }
        if (!params.client_max_window_bits) {
          if (typeof this._options.clientMaxWindowBits === "number") {
            params.client_max_window_bits = this._options.clientMaxWindowBits;
          }
        } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
          throw new Error(
            'Unexpected or invalid parameter "client_max_window_bits"'
          );
        }
        return params;
      }
      /**
       * Normalize parameters.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Array} The offers/response with normalized parameters
       * @private
       */
      normalizeParams(configurations) {
        configurations.forEach((params) => {
          Object.keys(params).forEach((key) => {
            let value = params[key];
            if (value.length > 1) {
              throw new Error(`Parameter "${key}" must have only a single value`);
            }
            value = value[0];
            if (key === "client_max_window_bits") {
              if (value !== true) {
                const num = +value;
                if (!Number.isInteger(num) || num < 8 || num > 15) {
                  throw new TypeError(
                    `Invalid value for parameter "${key}": ${value}`
                  );
                }
                value = num;
              } else if (!this._isServer) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else if (key === "server_max_window_bits") {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
              value = num;
            } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
              if (value !== true) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else {
              throw new Error(`Unknown parameter "${key}"`);
            }
            params[key] = value;
          });
        });
        return configurations;
      }
      /**
       * Decompress data. Concurrency limited.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      decompress(data2, fin, callback) {
        zlibLimiter.add((done) => {
          this._decompress(data2, fin, (err2, result) => {
            done();
            callback(err2, result);
          });
        });
      }
      /**
       * Compress data. Concurrency limited.
       *
       * @param {Buffer} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      compress(data2, fin, callback) {
        zlibLimiter.add((done) => {
          this._compress(data2, fin, (err2, result) => {
            done();
            callback(err2, result);
          });
        });
      }
      /**
       * Decompress data.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _decompress(data2, fin, callback) {
        const endpoint = this._isServer ? "client" : "server";
        if (!this._inflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._inflate = zlib.createInflateRaw({
            ...this._options.zlibInflateOptions,
            windowBits
          });
          this._inflate[kPerMessageDeflate] = this;
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          this._inflate.on("error", inflateOnError);
          this._inflate.on("data", inflateOnData);
        }
        this._inflate[kCallback] = callback;
        this._inflate.write(data2);
        if (fin)
          this._inflate.write(TRAILER);
        this._inflate.flush(() => {
          const err2 = this._inflate[kError];
          if (err2) {
            this._inflate.close();
            this._inflate = null;
            callback(err2);
            return;
          }
          const data3 = bufferUtil.concat(
            this._inflate[kBuffers],
            this._inflate[kTotalLength]
          );
          if (this._inflate._readableState.endEmitted) {
            this._inflate.close();
            this._inflate = null;
          } else {
            this._inflate[kTotalLength] = 0;
            this._inflate[kBuffers] = [];
            if (fin && this.params[`${endpoint}_no_context_takeover`]) {
              this._inflate.reset();
            }
          }
          callback(null, data3);
        });
      }
      /**
       * Compress data.
       *
       * @param {Buffer} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _compress(data2, fin, callback) {
        const endpoint = this._isServer ? "server" : "client";
        if (!this._deflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._deflate = zlib.createDeflateRaw({
            ...this._options.zlibDeflateOptions,
            windowBits
          });
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          this._deflate.on("error", NOOP);
          this._deflate.on("data", deflateOnData);
        }
        this._deflate[kCallback] = callback;
        this._deflate.write(data2);
        this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
          if (!this._deflate) {
            return;
          }
          let data3 = bufferUtil.concat(
            this._deflate[kBuffers],
            this._deflate[kTotalLength]
          );
          if (fin)
            data3 = data3.slice(0, data3.length - 4);
          this._deflate[kCallback] = null;
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._deflate.reset();
          }
          callback(null, data3);
        });
      }
    };
    module2.exports = PerMessageDeflate;
    function deflateOnData(chunk) {
      this[kBuffers].push(chunk);
      this[kTotalLength] += chunk.length;
    }
    function inflateOnData(chunk) {
      this[kTotalLength] += chunk.length;
      if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
        this[kBuffers].push(chunk);
        return;
      }
      this[kError] = new RangeError("Max payload size exceeded");
      this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
      this[kError][kStatusCode] = 1009;
      this.removeListener("data", inflateOnData);
      this.reset();
    }
    function inflateOnError(err2) {
      this[kPerMessageDeflate]._inflate = null;
      err2[kStatusCode] = 1007;
      this[kCallback](err2);
    }
  }
});

// ../../node_modules/ws/lib/validation.js
var require_validation = __commonJS({
  "../../node_modules/ws/lib/validation.js"(exports2, module2) {
    "use strict";
    function isValidStatusCode(code) {
      return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;
    }
    function _isValidUTF8(buf) {
      const len2 = buf.length;
      let i2 = 0;
      while (i2 < len2) {
        if ((buf[i2] & 128) === 0) {
          i2++;
        } else if ((buf[i2] & 224) === 192) {
          if (i2 + 1 === len2 || (buf[i2 + 1] & 192) !== 128 || (buf[i2] & 254) === 192) {
            return false;
          }
          i2 += 2;
        } else if ((buf[i2] & 240) === 224) {
          if (i2 + 2 >= len2 || (buf[i2 + 1] & 192) !== 128 || (buf[i2 + 2] & 192) !== 128 || buf[i2] === 224 && (buf[i2 + 1] & 224) === 128 || // Overlong
          buf[i2] === 237 && (buf[i2 + 1] & 224) === 160) {
            return false;
          }
          i2 += 3;
        } else if ((buf[i2] & 248) === 240) {
          if (i2 + 3 >= len2 || (buf[i2 + 1] & 192) !== 128 || (buf[i2 + 2] & 192) !== 128 || (buf[i2 + 3] & 192) !== 128 || buf[i2] === 240 && (buf[i2 + 1] & 240) === 128 || // Overlong
          buf[i2] === 244 && buf[i2 + 1] > 143 || buf[i2] > 244) {
            return false;
          }
          i2 += 4;
        } else {
          return false;
        }
      }
      return true;
    }
    try {
      let isValidUTF8 = require("utf-8-validate");
      if (typeof isValidUTF8 === "object") {
        isValidUTF8 = isValidUTF8.Validation.isValidUTF8;
      }
      module2.exports = {
        isValidStatusCode,
        isValidUTF8(buf) {
          return buf.length < 150 ? _isValidUTF8(buf) : isValidUTF8(buf);
        }
      };
    } catch (e) {
      module2.exports = {
        isValidStatusCode,
        isValidUTF8: _isValidUTF8
      };
    }
  }
});

// ../../node_modules/ws/lib/receiver.js
var require_receiver = __commonJS({
  "../../node_modules/ws/lib/receiver.js"(exports2, module2) {
    "use strict";
    var { Writable } = require("stream");
    var PerMessageDeflate = require_permessage_deflate();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      kStatusCode,
      kWebSocket
    } = require_constants4();
    var { concat, toArrayBuffer, unmask } = require_buffer_util();
    var { isValidStatusCode, isValidUTF8 } = require_validation();
    var GET_INFO = 0;
    var GET_PAYLOAD_LENGTH_16 = 1;
    var GET_PAYLOAD_LENGTH_64 = 2;
    var GET_MASK = 3;
    var GET_DATA = 4;
    var INFLATING = 5;
    var Receiver = class extends Writable {
      /**
       * Creates a Receiver instance.
       *
       * @param {String} [binaryType=nodebuffer] The type for binary data
       * @param {Object} [extensions] An object containing the negotiated extensions
       * @param {Boolean} [isServer=false] Specifies whether to operate in client or
       *     server mode
       * @param {Number} [maxPayload=0] The maximum allowed message length
       */
      constructor(binaryType, extensions, isServer, maxPayload) {
        super();
        this._binaryType = binaryType || BINARY_TYPES[0];
        this[kWebSocket] = void 0;
        this._extensions = extensions || {};
        this._isServer = !!isServer;
        this._maxPayload = maxPayload | 0;
        this._bufferedBytes = 0;
        this._buffers = [];
        this._compressed = false;
        this._payloadLength = 0;
        this._mask = void 0;
        this._fragmented = 0;
        this._masked = false;
        this._fin = false;
        this._opcode = 0;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragments = [];
        this._state = GET_INFO;
        this._loop = false;
      }
      /**
       * Implements `Writable.prototype._write()`.
       *
       * @param {Buffer} chunk The chunk of data to write
       * @param {String} encoding The character encoding of `chunk`
       * @param {Function} cb Callback
       * @private
       */
      _write(chunk, encoding, cb) {
        if (this._opcode === 8 && this._state == GET_INFO)
          return cb();
        this._bufferedBytes += chunk.length;
        this._buffers.push(chunk);
        this.startLoop(cb);
      }
      /**
       * Consumes `n` bytes from the buffered data.
       *
       * @param {Number} n The number of bytes to consume
       * @return {Buffer} The consumed bytes
       * @private
       */
      consume(n) {
        this._bufferedBytes -= n;
        if (n === this._buffers[0].length)
          return this._buffers.shift();
        if (n < this._buffers[0].length) {
          const buf = this._buffers[0];
          this._buffers[0] = buf.slice(n);
          return buf.slice(0, n);
        }
        const dst = Buffer.allocUnsafe(n);
        do {
          const buf = this._buffers[0];
          const offset = dst.length - n;
          if (n >= buf.length) {
            dst.set(this._buffers.shift(), offset);
          } else {
            dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
            this._buffers[0] = buf.slice(n);
          }
          n -= buf.length;
        } while (n > 0);
        return dst;
      }
      /**
       * Starts the parsing loop.
       *
       * @param {Function} cb Callback
       * @private
       */
      startLoop(cb) {
        let err2;
        this._loop = true;
        do {
          switch (this._state) {
            case GET_INFO:
              err2 = this.getInfo();
              break;
            case GET_PAYLOAD_LENGTH_16:
              err2 = this.getPayloadLength16();
              break;
            case GET_PAYLOAD_LENGTH_64:
              err2 = this.getPayloadLength64();
              break;
            case GET_MASK:
              this.getMask();
              break;
            case GET_DATA:
              err2 = this.getData(cb);
              break;
            default:
              this._loop = false;
              return;
          }
        } while (this._loop);
        cb(err2);
      }
      /**
       * Reads the first two bytes of a frame.
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      getInfo() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        const buf = this.consume(2);
        if ((buf[0] & 48) !== 0) {
          this._loop = false;
          return error(
            RangeError,
            "RSV2 and RSV3 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_2_3"
          );
        }
        const compressed = (buf[0] & 64) === 64;
        if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
          this._loop = false;
          return error(
            RangeError,
            "RSV1 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_1"
          );
        }
        this._fin = (buf[0] & 128) === 128;
        this._opcode = buf[0] & 15;
        this._payloadLength = buf[1] & 127;
        if (this._opcode === 0) {
          if (compressed) {
            this._loop = false;
            return error(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
          }
          if (!this._fragmented) {
            this._loop = false;
            return error(
              RangeError,
              "invalid opcode 0",
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
          }
          this._opcode = this._fragmented;
        } else if (this._opcode === 1 || this._opcode === 2) {
          if (this._fragmented) {
            this._loop = false;
            return error(
              RangeError,
              `invalid opcode ${this._opcode}`,
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
          }
          this._compressed = compressed;
        } else if (this._opcode > 7 && this._opcode < 11) {
          if (!this._fin) {
            this._loop = false;
            return error(
              RangeError,
              "FIN must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_FIN"
            );
          }
          if (compressed) {
            this._loop = false;
            return error(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
          }
          if (this._payloadLength > 125) {
            this._loop = false;
            return error(
              RangeError,
              `invalid payload length ${this._payloadLength}`,
              true,
              1002,
              "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"
            );
          }
        } else {
          this._loop = false;
          return error(
            RangeError,
            `invalid opcode ${this._opcode}`,
            true,
            1002,
            "WS_ERR_INVALID_OPCODE"
          );
        }
        if (!this._fin && !this._fragmented)
          this._fragmented = this._opcode;
        this._masked = (buf[1] & 128) === 128;
        if (this._isServer) {
          if (!this._masked) {
            this._loop = false;
            return error(
              RangeError,
              "MASK must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_MASK"
            );
          }
        } else if (this._masked) {
          this._loop = false;
          return error(
            RangeError,
            "MASK must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_MASK"
          );
        }
        if (this._payloadLength === 126)
          this._state = GET_PAYLOAD_LENGTH_16;
        else if (this._payloadLength === 127)
          this._state = GET_PAYLOAD_LENGTH_64;
        else
          return this.haveLength();
      }
      /**
       * Gets extended payload length (7+16).
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      getPayloadLength16() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        this._payloadLength = this.consume(2).readUInt16BE(0);
        return this.haveLength();
      }
      /**
       * Gets extended payload length (7+64).
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      getPayloadLength64() {
        if (this._bufferedBytes < 8) {
          this._loop = false;
          return;
        }
        const buf = this.consume(8);
        const num = buf.readUInt32BE(0);
        if (num > Math.pow(2, 53 - 32) - 1) {
          this._loop = false;
          return error(
            RangeError,
            "Unsupported WebSocket frame: payload length > 2^53 - 1",
            false,
            1009,
            "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH"
          );
        }
        this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
        return this.haveLength();
      }
      /**
       * Payload length has been read.
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      haveLength() {
        if (this._payloadLength && this._opcode < 8) {
          this._totalPayloadLength += this._payloadLength;
          if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
            this._loop = false;
            return error(
              RangeError,
              "Max payload size exceeded",
              false,
              1009,
              "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
            );
          }
        }
        if (this._masked)
          this._state = GET_MASK;
        else
          this._state = GET_DATA;
      }
      /**
       * Reads mask bytes.
       *
       * @private
       */
      getMask() {
        if (this._bufferedBytes < 4) {
          this._loop = false;
          return;
        }
        this._mask = this.consume(4);
        this._state = GET_DATA;
      }
      /**
       * Reads data bytes.
       *
       * @param {Function} cb Callback
       * @return {(Error|RangeError|undefined)} A possible error
       * @private
       */
      getData(cb) {
        let data2 = EMPTY_BUFFER;
        if (this._payloadLength) {
          if (this._bufferedBytes < this._payloadLength) {
            this._loop = false;
            return;
          }
          data2 = this.consume(this._payloadLength);
          if (this._masked)
            unmask(data2, this._mask);
        }
        if (this._opcode > 7)
          return this.controlMessage(data2);
        if (this._compressed) {
          this._state = INFLATING;
          this.decompress(data2, cb);
          return;
        }
        if (data2.length) {
          this._messageLength = this._totalPayloadLength;
          this._fragments.push(data2);
        }
        return this.dataMessage();
      }
      /**
       * Decompresses data.
       *
       * @param {Buffer} data Compressed data
       * @param {Function} cb Callback
       * @private
       */
      decompress(data2, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        perMessageDeflate.decompress(data2, this._fin, (err2, buf) => {
          if (err2)
            return cb(err2);
          if (buf.length) {
            this._messageLength += buf.length;
            if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
              return cb(
                error(
                  RangeError,
                  "Max payload size exceeded",
                  false,
                  1009,
                  "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
                )
              );
            }
            this._fragments.push(buf);
          }
          const er = this.dataMessage();
          if (er)
            return cb(er);
          this.startLoop(cb);
        });
      }
      /**
       * Handles a data message.
       *
       * @return {(Error|undefined)} A possible error
       * @private
       */
      dataMessage() {
        if (this._fin) {
          const messageLength = this._messageLength;
          const fragments = this._fragments;
          this._totalPayloadLength = 0;
          this._messageLength = 0;
          this._fragmented = 0;
          this._fragments = [];
          if (this._opcode === 2) {
            let data2;
            if (this._binaryType === "nodebuffer") {
              data2 = concat(fragments, messageLength);
            } else if (this._binaryType === "arraybuffer") {
              data2 = toArrayBuffer(concat(fragments, messageLength));
            } else {
              data2 = fragments;
            }
            this.emit("message", data2);
          } else {
            const buf = concat(fragments, messageLength);
            if (!isValidUTF8(buf)) {
              this._loop = false;
              return error(
                Error,
                "invalid UTF-8 sequence",
                true,
                1007,
                "WS_ERR_INVALID_UTF8"
              );
            }
            this.emit("message", buf.toString());
          }
        }
        this._state = GET_INFO;
      }
      /**
       * Handles a control message.
       *
       * @param {Buffer} data Data to handle
       * @return {(Error|RangeError|undefined)} A possible error
       * @private
       */
      controlMessage(data2) {
        if (this._opcode === 8) {
          this._loop = false;
          if (data2.length === 0) {
            this.emit("conclude", 1005, "");
            this.end();
          } else if (data2.length === 1) {
            return error(
              RangeError,
              "invalid payload length 1",
              true,
              1002,
              "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"
            );
          } else {
            const code = data2.readUInt16BE(0);
            if (!isValidStatusCode(code)) {
              return error(
                RangeError,
                `invalid status code ${code}`,
                true,
                1002,
                "WS_ERR_INVALID_CLOSE_CODE"
              );
            }
            const buf = data2.slice(2);
            if (!isValidUTF8(buf)) {
              return error(
                Error,
                "invalid UTF-8 sequence",
                true,
                1007,
                "WS_ERR_INVALID_UTF8"
              );
            }
            this.emit("conclude", code, buf.toString());
            this.end();
          }
        } else if (this._opcode === 9) {
          this.emit("ping", data2);
        } else {
          this.emit("pong", data2);
        }
        this._state = GET_INFO;
      }
    };
    module2.exports = Receiver;
    function error(ErrorCtor, message, prefix, statusCode, errorCode) {
      const err2 = new ErrorCtor(
        prefix ? `Invalid WebSocket frame: ${message}` : message
      );
      Error.captureStackTrace(err2, error);
      err2.code = errorCode;
      err2[kStatusCode] = statusCode;
      return err2;
    }
  }
});

// ../../node_modules/ws/lib/sender.js
var require_sender = __commonJS({
  "../../node_modules/ws/lib/sender.js"(exports2, module2) {
    "use strict";
    var net = require("net");
    var tls = require("tls");
    var { randomFillSync } = require("crypto");
    var PerMessageDeflate = require_permessage_deflate();
    var { EMPTY_BUFFER } = require_constants4();
    var { isValidStatusCode } = require_validation();
    var { mask: applyMask, toBuffer } = require_buffer_util();
    var mask = Buffer.alloc(4);
    var Sender = class _Sender {
      /**
       * Creates a Sender instance.
       *
       * @param {(net.Socket|tls.Socket)} socket The connection socket
       * @param {Object} [extensions] An object containing the negotiated extensions
       */
      constructor(socket, extensions) {
        this._extensions = extensions || {};
        this._socket = socket;
        this._firstFragment = true;
        this._compress = false;
        this._bufferedBytes = 0;
        this._deflating = false;
        this._queue = [];
      }
      /**
       * Frames a piece of data according to the HyBi WebSocket protocol.
       *
       * @param {Buffer} data The data to frame
       * @param {Object} options Options object
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @return {Buffer[]} The framed data as a list of `Buffer` instances
       * @public
       */
      static frame(data2, options) {
        const merge = options.mask && options.readOnly;
        let offset = options.mask ? 6 : 2;
        let payloadLength = data2.length;
        if (data2.length >= 65536) {
          offset += 8;
          payloadLength = 127;
        } else if (data2.length > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const target = Buffer.allocUnsafe(merge ? data2.length + offset : offset);
        target[0] = options.fin ? options.opcode | 128 : options.opcode;
        if (options.rsv1)
          target[0] |= 64;
        target[1] = payloadLength;
        if (payloadLength === 126) {
          target.writeUInt16BE(data2.length, 2);
        } else if (payloadLength === 127) {
          target.writeUInt32BE(0, 2);
          target.writeUInt32BE(data2.length, 6);
        }
        if (!options.mask)
          return [target, data2];
        randomFillSync(mask, 0, 4);
        target[1] |= 128;
        target[offset - 4] = mask[0];
        target[offset - 3] = mask[1];
        target[offset - 2] = mask[2];
        target[offset - 1] = mask[3];
        if (merge) {
          applyMask(data2, mask, target, offset, data2.length);
          return [target];
        }
        applyMask(data2, mask, data2, 0, data2.length);
        return [target, data2];
      }
      /**
       * Sends a close message to the other peer.
       *
       * @param {Number} [code] The status code component of the body
       * @param {String} [data] The message component of the body
       * @param {Boolean} [mask=false] Specifies whether or not to mask the message
       * @param {Function} [cb] Callback
       * @public
       */
      close(code, data2, mask2, cb) {
        let buf;
        if (code === void 0) {
          buf = EMPTY_BUFFER;
        } else if (typeof code !== "number" || !isValidStatusCode(code)) {
          throw new TypeError("First argument must be a valid error code number");
        } else if (data2 === void 0 || data2 === "") {
          buf = Buffer.allocUnsafe(2);
          buf.writeUInt16BE(code, 0);
        } else {
          const length = Buffer.byteLength(data2);
          if (length > 123) {
            throw new RangeError("The message must not be greater than 123 bytes");
          }
          buf = Buffer.allocUnsafe(2 + length);
          buf.writeUInt16BE(code, 0);
          buf.write(data2, 2);
        }
        if (this._deflating) {
          this.enqueue([this.doClose, buf, mask2, cb]);
        } else {
          this.doClose(buf, mask2, cb);
        }
      }
      /**
       * Frames and sends a close message.
       *
       * @param {Buffer} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @private
       */
      doClose(data2, mask2, cb) {
        this.sendFrame(
          _Sender.frame(data2, {
            fin: true,
            rsv1: false,
            opcode: 8,
            mask: mask2,
            readOnly: false
          }),
          cb
        );
      }
      /**
       * Sends a ping message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      ping(data2, mask2, cb) {
        const buf = toBuffer(data2);
        if (buf.length > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        if (this._deflating) {
          this.enqueue([this.doPing, buf, mask2, toBuffer.readOnly, cb]);
        } else {
          this.doPing(buf, mask2, toBuffer.readOnly, cb);
        }
      }
      /**
       * Frames and sends a ping message.
       *
       * @param {Buffer} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Boolean} [readOnly=false] Specifies whether `data` can be modified
       * @param {Function} [cb] Callback
       * @private
       */
      doPing(data2, mask2, readOnly, cb) {
        this.sendFrame(
          _Sender.frame(data2, {
            fin: true,
            rsv1: false,
            opcode: 9,
            mask: mask2,
            readOnly
          }),
          cb
        );
      }
      /**
       * Sends a pong message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      pong(data2, mask2, cb) {
        const buf = toBuffer(data2);
        if (buf.length > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        if (this._deflating) {
          this.enqueue([this.doPong, buf, mask2, toBuffer.readOnly, cb]);
        } else {
          this.doPong(buf, mask2, toBuffer.readOnly, cb);
        }
      }
      /**
       * Frames and sends a pong message.
       *
       * @param {Buffer} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Boolean} [readOnly=false] Specifies whether `data` can be modified
       * @param {Function} [cb] Callback
       * @private
       */
      doPong(data2, mask2, readOnly, cb) {
        this.sendFrame(
          _Sender.frame(data2, {
            fin: true,
            rsv1: false,
            opcode: 10,
            mask: mask2,
            readOnly
          }),
          cb
        );
      }
      /**
       * Sends a data message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Object} options Options object
       * @param {Boolean} [options.compress=false] Specifies whether or not to
       *     compress `data`
       * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
       *     or text
       * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Function} [cb] Callback
       * @public
       */
      send(data2, options, cb) {
        const buf = toBuffer(data2);
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        let opcode = options.binary ? 2 : 1;
        let rsv1 = options.compress;
        if (this._firstFragment) {
          this._firstFragment = false;
          if (rsv1 && perMessageDeflate) {
            rsv1 = buf.length >= perMessageDeflate._threshold;
          }
          this._compress = rsv1;
        } else {
          rsv1 = false;
          opcode = 0;
        }
        if (options.fin)
          this._firstFragment = true;
        if (perMessageDeflate) {
          const opts = {
            fin: options.fin,
            rsv1,
            opcode,
            mask: options.mask,
            readOnly: toBuffer.readOnly
          };
          if (this._deflating) {
            this.enqueue([this.dispatch, buf, this._compress, opts, cb]);
          } else {
            this.dispatch(buf, this._compress, opts, cb);
          }
        } else {
          this.sendFrame(
            _Sender.frame(buf, {
              fin: options.fin,
              rsv1: false,
              opcode,
              mask: options.mask,
              readOnly: toBuffer.readOnly
            }),
            cb
          );
        }
      }
      /**
       * Dispatches a data message.
       *
       * @param {Buffer} data The message to send
       * @param {Boolean} [compress=false] Specifies whether or not to compress
       *     `data`
       * @param {Object} options Options object
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @param {Function} [cb] Callback
       * @private
       */
      dispatch(data2, compress, options, cb) {
        if (!compress) {
          this.sendFrame(_Sender.frame(data2, options), cb);
          return;
        }
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        this._bufferedBytes += data2.length;
        this._deflating = true;
        perMessageDeflate.compress(data2, options.fin, (_, buf) => {
          if (this._socket.destroyed) {
            const err2 = new Error(
              "The socket was closed while data was being compressed"
            );
            if (typeof cb === "function")
              cb(err2);
            for (let i2 = 0; i2 < this._queue.length; i2++) {
              const callback = this._queue[i2][4];
              if (typeof callback === "function")
                callback(err2);
            }
            return;
          }
          this._bufferedBytes -= data2.length;
          this._deflating = false;
          options.readOnly = false;
          this.sendFrame(_Sender.frame(buf, options), cb);
          this.dequeue();
        });
      }
      /**
       * Executes queued send operations.
       *
       * @private
       */
      dequeue() {
        while (!this._deflating && this._queue.length) {
          const params = this._queue.shift();
          this._bufferedBytes -= params[1].length;
          Reflect.apply(params[0], this, params.slice(1));
        }
      }
      /**
       * Enqueues a send operation.
       *
       * @param {Array} params Send operation parameters.
       * @private
       */
      enqueue(params) {
        this._bufferedBytes += params[1].length;
        this._queue.push(params);
      }
      /**
       * Sends a frame.
       *
       * @param {Buffer[]} list The frame to send
       * @param {Function} [cb] Callback
       * @private
       */
      sendFrame(list, cb) {
        if (list.length === 2) {
          this._socket.cork();
          this._socket.write(list[0]);
          this._socket.write(list[1], cb);
          this._socket.uncork();
        } else {
          this._socket.write(list[0], cb);
        }
      }
    };
    module2.exports = Sender;
  }
});

// ../../node_modules/ws/lib/event-target.js
var require_event_target = __commonJS({
  "../../node_modules/ws/lib/event-target.js"(exports2, module2) {
    "use strict";
    var Event = class {
      /**
       * Create a new `Event`.
       *
       * @param {String} type The name of the event
       * @param {Object} target A reference to the target to which the event was
       *     dispatched
       */
      constructor(type, target) {
        this.target = target;
        this.type = type;
      }
    };
    var MessageEvent = class extends Event {
      /**
       * Create a new `MessageEvent`.
       *
       * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The received data
       * @param {WebSocket} target A reference to the target to which the event was
       *     dispatched
       */
      constructor(data2, target) {
        super("message", target);
        this.data = data2;
      }
    };
    var CloseEvent = class extends Event {
      /**
       * Create a new `CloseEvent`.
       *
       * @param {Number} code The status code explaining why the connection is being
       *     closed
       * @param {String} reason A human-readable string explaining why the
       *     connection is closing
       * @param {WebSocket} target A reference to the target to which the event was
       *     dispatched
       */
      constructor(code, reason, target) {
        super("close", target);
        this.wasClean = target._closeFrameReceived && target._closeFrameSent;
        this.reason = reason;
        this.code = code;
      }
    };
    var OpenEvent = class extends Event {
      /**
       * Create a new `OpenEvent`.
       *
       * @param {WebSocket} target A reference to the target to which the event was
       *     dispatched
       */
      constructor(target) {
        super("open", target);
      }
    };
    var ErrorEvent = class extends Event {
      /**
       * Create a new `ErrorEvent`.
       *
       * @param {Object} error The error that generated this event
       * @param {WebSocket} target A reference to the target to which the event was
       *     dispatched
       */
      constructor(error, target) {
        super("error", target);
        this.message = error.message;
        this.error = error;
      }
    };
    var EventTarget = {
      /**
       * Register an event listener.
       *
       * @param {String} type A string representing the event type to listen for
       * @param {Function} listener The listener to add
       * @param {Object} [options] An options object specifies characteristics about
       *     the event listener
       * @param {Boolean} [options.once=false] A `Boolean`` indicating that the
       *     listener should be invoked at most once after being added. If `true`,
       *     the listener would be automatically removed when invoked.
       * @public
       */
      addEventListener(type, listener, options) {
        if (typeof listener !== "function")
          return;
        function onMessage(data2) {
          listener.call(this, new MessageEvent(data2, this));
        }
        function onClose(code, message) {
          listener.call(this, new CloseEvent(code, message, this));
        }
        function onError(error) {
          listener.call(this, new ErrorEvent(error, this));
        }
        function onOpen() {
          listener.call(this, new OpenEvent(this));
        }
        const method = options && options.once ? "once" : "on";
        if (type === "message") {
          onMessage._listener = listener;
          this[method](type, onMessage);
        } else if (type === "close") {
          onClose._listener = listener;
          this[method](type, onClose);
        } else if (type === "error") {
          onError._listener = listener;
          this[method](type, onError);
        } else if (type === "open") {
          onOpen._listener = listener;
          this[method](type, onOpen);
        } else {
          this[method](type, listener);
        }
      },
      /**
       * Remove an event listener.
       *
       * @param {String} type A string representing the event type to remove
       * @param {Function} listener The listener to remove
       * @public
       */
      removeEventListener(type, listener) {
        const listeners = this.listeners(type);
        for (let i2 = 0; i2 < listeners.length; i2++) {
          if (listeners[i2] === listener || listeners[i2]._listener === listener) {
            this.removeListener(type, listeners[i2]);
          }
        }
      }
    };
    module2.exports = EventTarget;
  }
});

// ../../node_modules/ws/lib/extension.js
var require_extension = __commonJS({
  "../../node_modules/ws/lib/extension.js"(exports2, module2) {
    "use strict";
    var tokenChars = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 0 - 15
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 16 - 31
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      0,
      // 32 - 47
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      // 48 - 63
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 64 - 79
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      // 80 - 95
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 96 - 111
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      0
      // 112 - 127
    ];
    function push(dest, name2, elem) {
      if (dest[name2] === void 0)
        dest[name2] = [elem];
      else
        dest[name2].push(elem);
    }
    function parse(header) {
      const offers = /* @__PURE__ */ Object.create(null);
      if (header === void 0 || header === "")
        return offers;
      let params = /* @__PURE__ */ Object.create(null);
      let mustUnescape = false;
      let isEscaping = false;
      let inQuotes = false;
      let extensionName;
      let paramName;
      let start2 = -1;
      let end = -1;
      let i2 = 0;
      for (; i2 < header.length; i2++) {
        const code = header.charCodeAt(i2);
        if (extensionName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start2 === -1)
              start2 = i2;
          } else if (code === 32 || code === 9) {
            if (end === -1 && start2 !== -1)
              end = i2;
          } else if (code === 59 || code === 44) {
            if (start2 === -1) {
              throw new SyntaxError(`Unexpected character at index ${i2}`);
            }
            if (end === -1)
              end = i2;
            const name2 = header.slice(start2, end);
            if (code === 44) {
              push(offers, name2, params);
              params = /* @__PURE__ */ Object.create(null);
            } else {
              extensionName = name2;
            }
            start2 = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i2}`);
          }
        } else if (paramName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start2 === -1)
              start2 = i2;
          } else if (code === 32 || code === 9) {
            if (end === -1 && start2 !== -1)
              end = i2;
          } else if (code === 59 || code === 44) {
            if (start2 === -1) {
              throw new SyntaxError(`Unexpected character at index ${i2}`);
            }
            if (end === -1)
              end = i2;
            push(params, header.slice(start2, end), true);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            start2 = end = -1;
          } else if (code === 61 && start2 !== -1 && end === -1) {
            paramName = header.slice(start2, i2);
            start2 = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i2}`);
          }
        } else {
          if (isEscaping) {
            if (tokenChars[code] !== 1) {
              throw new SyntaxError(`Unexpected character at index ${i2}`);
            }
            if (start2 === -1)
              start2 = i2;
            else if (!mustUnescape)
              mustUnescape = true;
            isEscaping = false;
          } else if (inQuotes) {
            if (tokenChars[code] === 1) {
              if (start2 === -1)
                start2 = i2;
            } else if (code === 34 && start2 !== -1) {
              inQuotes = false;
              end = i2;
            } else if (code === 92) {
              isEscaping = true;
            } else {
              throw new SyntaxError(`Unexpected character at index ${i2}`);
            }
          } else if (code === 34 && header.charCodeAt(i2 - 1) === 61) {
            inQuotes = true;
          } else if (end === -1 && tokenChars[code] === 1) {
            if (start2 === -1)
              start2 = i2;
          } else if (start2 !== -1 && (code === 32 || code === 9)) {
            if (end === -1)
              end = i2;
          } else if (code === 59 || code === 44) {
            if (start2 === -1) {
              throw new SyntaxError(`Unexpected character at index ${i2}`);
            }
            if (end === -1)
              end = i2;
            let value = header.slice(start2, end);
            if (mustUnescape) {
              value = value.replace(/\\/g, "");
              mustUnescape = false;
            }
            push(params, paramName, value);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            paramName = void 0;
            start2 = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i2}`);
          }
        }
      }
      if (start2 === -1 || inQuotes) {
        throw new SyntaxError("Unexpected end of input");
      }
      if (end === -1)
        end = i2;
      const token = header.slice(start2, end);
      if (extensionName === void 0) {
        push(offers, token, params);
      } else {
        if (paramName === void 0) {
          push(params, token, true);
        } else if (mustUnescape) {
          push(params, paramName, token.replace(/\\/g, ""));
        } else {
          push(params, paramName, token);
        }
        push(offers, extensionName, params);
      }
      return offers;
    }
    function format(extensions) {
      return Object.keys(extensions).map((extension) => {
        let configurations = extensions[extension];
        if (!Array.isArray(configurations))
          configurations = [configurations];
        return configurations.map((params) => {
          return [extension].concat(
            Object.keys(params).map((k) => {
              let values = params[k];
              if (!Array.isArray(values))
                values = [values];
              return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
            })
          ).join("; ");
        }).join(", ");
      }).join(", ");
    }
    module2.exports = { format, parse };
  }
});

// ../../node_modules/ws/lib/websocket.js
var require_websocket = __commonJS({
  "../../node_modules/ws/lib/websocket.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var https = require("https");
    var http = require("http");
    var net = require("net");
    var tls = require("tls");
    var { randomBytes, createHash } = require("crypto");
    var { Readable } = require("stream");
    var { URL: URL2 } = require("url");
    var PerMessageDeflate = require_permessage_deflate();
    var Receiver = require_receiver();
    var Sender = require_sender();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      GUID,
      kStatusCode,
      kWebSocket,
      NOOP
    } = require_constants4();
    var { addEventListener: addEventListener2, removeEventListener: removeEventListener2 } = require_event_target();
    var { format, parse } = require_extension();
    var { toBuffer } = require_buffer_util();
    var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
    var protocolVersions = [8, 13];
    var closeTimeout = 30 * 1e3;
    var WebSocket2 = class _WebSocket extends EventEmitter {
      /**
       * Create a new `WebSocket`.
       *
       * @param {(String|URL)} address The URL to which to connect
       * @param {(String|String[])} [protocols] The subprotocols
       * @param {Object} [options] Connection options
       */
      constructor(address, protocols, options) {
        super();
        this._binaryType = BINARY_TYPES[0];
        this._closeCode = 1006;
        this._closeFrameReceived = false;
        this._closeFrameSent = false;
        this._closeMessage = "";
        this._closeTimer = null;
        this._extensions = {};
        this._protocol = "";
        this._readyState = _WebSocket.CONNECTING;
        this._receiver = null;
        this._sender = null;
        this._socket = null;
        if (address !== null) {
          this._bufferedAmount = 0;
          this._isServer = false;
          this._redirects = 0;
          if (Array.isArray(protocols)) {
            protocols = protocols.join(", ");
          } else if (typeof protocols === "object" && protocols !== null) {
            options = protocols;
            protocols = void 0;
          }
          initAsClient(this, address, protocols, options);
        } else {
          this._isServer = true;
        }
      }
      /**
       * This deviates from the WHATWG interface since ws doesn't support the
       * required default "blob" type (instead we define a custom "nodebuffer"
       * type).
       *
       * @type {String}
       */
      get binaryType() {
        return this._binaryType;
      }
      set binaryType(type) {
        if (!BINARY_TYPES.includes(type))
          return;
        this._binaryType = type;
        if (this._receiver)
          this._receiver._binaryType = type;
      }
      /**
       * @type {Number}
       */
      get bufferedAmount() {
        if (!this._socket)
          return this._bufferedAmount;
        return this._socket._writableState.length + this._sender._bufferedBytes;
      }
      /**
       * @type {String}
       */
      get extensions() {
        return Object.keys(this._extensions).join();
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onclose() {
        return void 0;
      }
      /* istanbul ignore next */
      set onclose(listener) {
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onerror() {
        return void 0;
      }
      /* istanbul ignore next */
      set onerror(listener) {
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onopen() {
        return void 0;
      }
      /* istanbul ignore next */
      set onopen(listener) {
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onmessage() {
        return void 0;
      }
      /* istanbul ignore next */
      set onmessage(listener) {
      }
      /**
       * @type {String}
       */
      get protocol() {
        return this._protocol;
      }
      /**
       * @type {Number}
       */
      get readyState() {
        return this._readyState;
      }
      /**
       * @type {String}
       */
      get url() {
        return this._url;
      }
      /**
       * Set up the socket and the internal resources.
       *
       * @param {(net.Socket|tls.Socket)} socket The network socket between the
       *     server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Number} [maxPayload=0] The maximum allowed message size
       * @private
       */
      setSocket(socket, head, maxPayload) {
        const receiver = new Receiver(
          this.binaryType,
          this._extensions,
          this._isServer,
          maxPayload
        );
        this._sender = new Sender(socket, this._extensions);
        this._receiver = receiver;
        this._socket = socket;
        receiver[kWebSocket] = this;
        socket[kWebSocket] = this;
        receiver.on("conclude", receiverOnConclude);
        receiver.on("drain", receiverOnDrain);
        receiver.on("error", receiverOnError);
        receiver.on("message", receiverOnMessage);
        receiver.on("ping", receiverOnPing);
        receiver.on("pong", receiverOnPong);
        socket.setTimeout(0);
        socket.setNoDelay();
        if (head.length > 0)
          socket.unshift(head);
        socket.on("close", socketOnClose);
        socket.on("data", socketOnData);
        socket.on("end", socketOnEnd);
        socket.on("error", socketOnError);
        this._readyState = _WebSocket.OPEN;
        this.emit("open");
      }
      /**
       * Emit the `'close'` event.
       *
       * @private
       */
      emitClose() {
        if (!this._socket) {
          this._readyState = _WebSocket.CLOSED;
          this.emit("close", this._closeCode, this._closeMessage);
          return;
        }
        if (this._extensions[PerMessageDeflate.extensionName]) {
          this._extensions[PerMessageDeflate.extensionName].cleanup();
        }
        this._receiver.removeAllListeners();
        this._readyState = _WebSocket.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
      }
      /**
       * Start a closing handshake.
       *
       *          +----------+   +-----------+   +----------+
       *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
       *    |     +----------+   +-----------+   +----------+     |
       *          +----------+   +-----------+         |
       * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
       *          +----------+   +-----------+   |
       *    |           |                        |   +---+        |
       *                +------------------------+-->|fin| - - - -
       *    |         +---+                      |   +---+
       *     - - - - -|fin|<---------------------+
       *              +---+
       *
       * @param {Number} [code] Status code explaining why the connection is closing
       * @param {String} [data] A string explaining why the connection is closing
       * @public
       */
      close(code, data2) {
        if (this.readyState === _WebSocket.CLOSED)
          return;
        if (this.readyState === _WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          return abortHandshake(this, this._req, msg);
        }
        if (this.readyState === _WebSocket.CLOSING) {
          if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
            this._socket.end();
          }
          return;
        }
        this._readyState = _WebSocket.CLOSING;
        this._sender.close(code, data2, !this._isServer, (err2) => {
          if (err2)
            return;
          this._closeFrameSent = true;
          if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
            this._socket.end();
          }
        });
        this._closeTimer = setTimeout(
          this._socket.destroy.bind(this._socket),
          closeTimeout
        );
      }
      /**
       * Send a ping.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the ping is sent
       * @public
       */
      ping(data2, mask, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data2 === "function") {
          cb = data2;
          data2 = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data2 === "number")
          data2 = data2.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data2, cb);
          return;
        }
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.ping(data2 || EMPTY_BUFFER, mask, cb);
      }
      /**
       * Send a pong.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the pong is sent
       * @public
       */
      pong(data2, mask, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data2 === "function") {
          cb = data2;
          data2 = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data2 === "number")
          data2 = data2.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data2, cb);
          return;
        }
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.pong(data2 || EMPTY_BUFFER, mask, cb);
      }
      /**
       * Send a data message.
       *
       * @param {*} data The message to send
       * @param {Object} [options] Options object
       * @param {Boolean} [options.compress] Specifies whether or not to compress
       *     `data`
       * @param {Boolean} [options.binary] Specifies whether `data` is binary or
       *     text
       * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when data is written out
       * @public
       */
      send(data2, options, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof options === "function") {
          cb = options;
          options = {};
        }
        if (typeof data2 === "number")
          data2 = data2.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data2, cb);
          return;
        }
        const opts = {
          binary: typeof data2 !== "string",
          mask: !this._isServer,
          compress: true,
          fin: true,
          ...options
        };
        if (!this._extensions[PerMessageDeflate.extensionName]) {
          opts.compress = false;
        }
        this._sender.send(data2 || EMPTY_BUFFER, opts, cb);
      }
      /**
       * Forcibly close the connection.
       *
       * @public
       */
      terminate() {
        if (this.readyState === _WebSocket.CLOSED)
          return;
        if (this.readyState === _WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          return abortHandshake(this, this._req, msg);
        }
        if (this._socket) {
          this._readyState = _WebSocket.CLOSING;
          this._socket.destroy();
        }
      }
    };
    Object.defineProperty(WebSocket2, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket2.prototype, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket2, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket2.prototype, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket2, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket2.prototype, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket2, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    Object.defineProperty(WebSocket2.prototype, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    [
      "binaryType",
      "bufferedAmount",
      "extensions",
      "protocol",
      "readyState",
      "url"
    ].forEach((property) => {
      Object.defineProperty(WebSocket2.prototype, property, { enumerable: true });
    });
    ["open", "error", "close", "message"].forEach((method) => {
      Object.defineProperty(WebSocket2.prototype, `on${method}`, {
        enumerable: true,
        get() {
          const listeners = this.listeners(method);
          for (let i2 = 0; i2 < listeners.length; i2++) {
            if (listeners[i2]._listener)
              return listeners[i2]._listener;
          }
          return void 0;
        },
        set(listener) {
          const listeners = this.listeners(method);
          for (let i2 = 0; i2 < listeners.length; i2++) {
            if (listeners[i2]._listener)
              this.removeListener(method, listeners[i2]);
          }
          this.addEventListener(method, listener);
        }
      });
    });
    WebSocket2.prototype.addEventListener = addEventListener2;
    WebSocket2.prototype.removeEventListener = removeEventListener2;
    module2.exports = WebSocket2;
    function initAsClient(websocket, address, protocols, options) {
      const opts = {
        protocolVersion: protocolVersions[1],
        maxPayload: 100 * 1024 * 1024,
        perMessageDeflate: true,
        followRedirects: false,
        maxRedirects: 10,
        ...options,
        createConnection: void 0,
        socketPath: void 0,
        hostname: void 0,
        protocol: void 0,
        timeout: void 0,
        method: void 0,
        host: void 0,
        path: void 0,
        port: void 0
      };
      if (!protocolVersions.includes(opts.protocolVersion)) {
        throw new RangeError(
          `Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`
        );
      }
      let parsedUrl;
      if (address instanceof URL2) {
        parsedUrl = address;
        websocket._url = address.href;
      } else {
        parsedUrl = new URL2(address);
        websocket._url = address;
      }
      const isUnixSocket = parsedUrl.protocol === "ws+unix:";
      if (!parsedUrl.host && (!isUnixSocket || !parsedUrl.pathname)) {
        throw new Error(`Invalid URL: ${websocket.url}`);
      }
      const isSecure = parsedUrl.protocol === "wss:" || parsedUrl.protocol === "https:";
      const defaultPort = isSecure ? 443 : 80;
      const key = randomBytes(16).toString("base64");
      const get = isSecure ? https.get : http.get;
      let perMessageDeflate;
      opts.createConnection = isSecure ? tlsConnect : netConnect;
      opts.defaultPort = opts.defaultPort || defaultPort;
      opts.port = parsedUrl.port || defaultPort;
      opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
      opts.headers = {
        "Sec-WebSocket-Version": opts.protocolVersion,
        "Sec-WebSocket-Key": key,
        Connection: "Upgrade",
        Upgrade: "websocket",
        ...opts.headers
      };
      opts.path = parsedUrl.pathname + parsedUrl.search;
      opts.timeout = opts.handshakeTimeout;
      if (opts.perMessageDeflate) {
        perMessageDeflate = new PerMessageDeflate(
          opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
          false,
          opts.maxPayload
        );
        opts.headers["Sec-WebSocket-Extensions"] = format({
          [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
        });
      }
      if (protocols) {
        opts.headers["Sec-WebSocket-Protocol"] = protocols;
      }
      if (opts.origin) {
        if (opts.protocolVersion < 13) {
          opts.headers["Sec-WebSocket-Origin"] = opts.origin;
        } else {
          opts.headers.Origin = opts.origin;
        }
      }
      if (parsedUrl.username || parsedUrl.password) {
        opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
      }
      if (isUnixSocket) {
        const parts2 = opts.path.split(":");
        opts.socketPath = parts2[0];
        opts.path = parts2[1];
      }
      let req = websocket._req = get(opts);
      if (opts.timeout) {
        req.on("timeout", () => {
          abortHandshake(websocket, req, "Opening handshake has timed out");
        });
      }
      req.on("error", (err2) => {
        if (req === null || req.aborted)
          return;
        req = websocket._req = null;
        websocket._readyState = WebSocket2.CLOSING;
        websocket.emit("error", err2);
        websocket.emitClose();
      });
      req.on("response", (res) => {
        const location = res.headers.location;
        const statusCode = res.statusCode;
        if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
          if (++websocket._redirects > opts.maxRedirects) {
            abortHandshake(websocket, req, "Maximum redirects exceeded");
            return;
          }
          req.abort();
          const addr2 = new URL2(location, address);
          initAsClient(websocket, addr2, protocols, options);
        } else if (!websocket.emit("unexpected-response", req, res)) {
          abortHandshake(
            websocket,
            req,
            `Unexpected server response: ${res.statusCode}`
          );
        }
      });
      req.on("upgrade", (res, socket, head) => {
        websocket.emit("upgrade", res);
        if (websocket.readyState !== WebSocket2.CONNECTING)
          return;
        req = websocket._req = null;
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        if (res.headers["sec-websocket-accept"] !== digest) {
          abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
          return;
        }
        const serverProt = res.headers["sec-websocket-protocol"];
        const protList = (protocols || "").split(/, */);
        let protError;
        if (!protocols && serverProt) {
          protError = "Server sent a subprotocol but none was requested";
        } else if (protocols && !serverProt) {
          protError = "Server sent no subprotocol";
        } else if (serverProt && !protList.includes(serverProt)) {
          protError = "Server sent an invalid subprotocol";
        }
        if (protError) {
          abortHandshake(websocket, socket, protError);
          return;
        }
        if (serverProt)
          websocket._protocol = serverProt;
        const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
        if (secWebSocketExtensions !== void 0) {
          if (!perMessageDeflate) {
            const message = "Server sent a Sec-WebSocket-Extensions header but no extension was requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          let extensions;
          try {
            extensions = parse(secWebSocketExtensions);
          } catch (err2) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          const extensionNames = Object.keys(extensions);
          if (extensionNames.length) {
            if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
              const message = "Server indicated an extension that was not requested";
              abortHandshake(websocket, socket, message);
              return;
            }
            try {
              perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
            } catch (err2) {
              const message = "Invalid Sec-WebSocket-Extensions header";
              abortHandshake(websocket, socket, message);
              return;
            }
            websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
          }
        }
        websocket.setSocket(socket, head, opts.maxPayload);
      });
    }
    function netConnect(options) {
      options.path = options.socketPath;
      return net.connect(options);
    }
    function tlsConnect(options) {
      options.path = void 0;
      if (!options.servername && options.servername !== "") {
        options.servername = net.isIP(options.host) ? "" : options.host;
      }
      return tls.connect(options);
    }
    function abortHandshake(websocket, stream, message) {
      websocket._readyState = WebSocket2.CLOSING;
      const err2 = new Error(message);
      Error.captureStackTrace(err2, abortHandshake);
      if (stream.setHeader) {
        stream.abort();
        if (stream.socket && !stream.socket.destroyed) {
          stream.socket.destroy();
        }
        stream.once("abort", websocket.emitClose.bind(websocket));
        websocket.emit("error", err2);
      } else {
        stream.destroy(err2);
        stream.once("error", websocket.emit.bind(websocket, "error"));
        stream.once("close", websocket.emitClose.bind(websocket));
      }
    }
    function sendAfterClose(websocket, data2, cb) {
      if (data2) {
        const length = toBuffer(data2).length;
        if (websocket._socket)
          websocket._sender._bufferedBytes += length;
        else
          websocket._bufferedAmount += length;
      }
      if (cb) {
        const err2 = new Error(
          `WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`
        );
        cb(err2);
      }
    }
    function receiverOnConclude(code, reason) {
      const websocket = this[kWebSocket];
      websocket._closeFrameReceived = true;
      websocket._closeMessage = reason;
      websocket._closeCode = code;
      if (websocket._socket[kWebSocket] === void 0)
        return;
      websocket._socket.removeListener("data", socketOnData);
      process.nextTick(resume, websocket._socket);
      if (code === 1005)
        websocket.close();
      else
        websocket.close(code, reason);
    }
    function receiverOnDrain() {
      this[kWebSocket]._socket.resume();
    }
    function receiverOnError(err2) {
      const websocket = this[kWebSocket];
      if (websocket._socket[kWebSocket] !== void 0) {
        websocket._socket.removeListener("data", socketOnData);
        process.nextTick(resume, websocket._socket);
        websocket.close(err2[kStatusCode]);
      }
      websocket.emit("error", err2);
    }
    function receiverOnFinish() {
      this[kWebSocket].emitClose();
    }
    function receiverOnMessage(data2) {
      this[kWebSocket].emit("message", data2);
    }
    function receiverOnPing(data2) {
      const websocket = this[kWebSocket];
      websocket.pong(data2, !websocket._isServer, NOOP);
      websocket.emit("ping", data2);
    }
    function receiverOnPong(data2) {
      this[kWebSocket].emit("pong", data2);
    }
    function resume(stream) {
      stream.resume();
    }
    function socketOnClose() {
      const websocket = this[kWebSocket];
      this.removeListener("close", socketOnClose);
      this.removeListener("data", socketOnData);
      this.removeListener("end", socketOnEnd);
      websocket._readyState = WebSocket2.CLOSING;
      let chunk;
      if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {
        websocket._receiver.write(chunk);
      }
      websocket._receiver.end();
      this[kWebSocket] = void 0;
      clearTimeout(websocket._closeTimer);
      if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
        websocket.emitClose();
      } else {
        websocket._receiver.on("error", receiverOnFinish);
        websocket._receiver.on("finish", receiverOnFinish);
      }
    }
    function socketOnData(chunk) {
      if (!this[kWebSocket]._receiver.write(chunk)) {
        this.pause();
      }
    }
    function socketOnEnd() {
      const websocket = this[kWebSocket];
      websocket._readyState = WebSocket2.CLOSING;
      websocket._receiver.end();
      this.end();
    }
    function socketOnError() {
      const websocket = this[kWebSocket];
      this.removeListener("error", socketOnError);
      this.on("error", NOOP);
      if (websocket) {
        websocket._readyState = WebSocket2.CLOSING;
        this.destroy();
      }
    }
  }
});

// ../../node_modules/ws/lib/stream.js
var require_stream5 = __commonJS({
  "../../node_modules/ws/lib/stream.js"(exports2, module2) {
    "use strict";
    var { Duplex } = require("stream");
    function emitClose(stream) {
      stream.emit("close");
    }
    function duplexOnEnd() {
      if (!this.destroyed && this._writableState.finished) {
        this.destroy();
      }
    }
    function duplexOnError(err2) {
      this.removeListener("error", duplexOnError);
      this.destroy();
      if (this.listenerCount("error") === 0) {
        this.emit("error", err2);
      }
    }
    function createWebSocketStream(ws, options) {
      let resumeOnReceiverDrain = true;
      let terminateOnDestroy = true;
      function receiverOnDrain() {
        if (resumeOnReceiverDrain)
          ws._socket.resume();
      }
      if (ws.readyState === ws.CONNECTING) {
        ws.once("open", function open() {
          ws._receiver.removeAllListeners("drain");
          ws._receiver.on("drain", receiverOnDrain);
        });
      } else {
        ws._receiver.removeAllListeners("drain");
        ws._receiver.on("drain", receiverOnDrain);
      }
      const duplex = new Duplex({
        ...options,
        autoDestroy: false,
        emitClose: false,
        objectMode: false,
        writableObjectMode: false
      });
      ws.on("message", function message(msg) {
        if (!duplex.push(msg)) {
          resumeOnReceiverDrain = false;
          ws._socket.pause();
        }
      });
      ws.once("error", function error(err2) {
        if (duplex.destroyed)
          return;
        terminateOnDestroy = false;
        duplex.destroy(err2);
      });
      ws.once("close", function close() {
        if (duplex.destroyed)
          return;
        duplex.push(null);
      });
      duplex._destroy = function(err2, callback) {
        if (ws.readyState === ws.CLOSED) {
          callback(err2);
          process.nextTick(emitClose, duplex);
          return;
        }
        let called = false;
        ws.once("error", function error(err3) {
          called = true;
          callback(err3);
        });
        ws.once("close", function close() {
          if (!called)
            callback(err2);
          process.nextTick(emitClose, duplex);
        });
        if (terminateOnDestroy)
          ws.terminate();
      };
      duplex._final = function(callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._final(callback);
          });
          return;
        }
        if (ws._socket === null)
          return;
        if (ws._socket._writableState.finished) {
          callback();
          if (duplex._readableState.endEmitted)
            duplex.destroy();
        } else {
          ws._socket.once("finish", function finish() {
            callback();
          });
          ws.close();
        }
      };
      duplex._read = function() {
        if (ws.readyState === ws.OPEN && !resumeOnReceiverDrain) {
          resumeOnReceiverDrain = true;
          if (!ws._receiver._writableState.needDrain)
            ws._socket.resume();
        }
      };
      duplex._write = function(chunk, encoding, callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._write(chunk, encoding, callback);
          });
          return;
        }
        ws.send(chunk, callback);
      };
      duplex.on("end", duplexOnEnd);
      duplex.on("error", duplexOnError);
      return duplex;
    }
    module2.exports = createWebSocketStream;
  }
});

// ../../node_modules/ws/lib/websocket-server.js
var require_websocket_server = __commonJS({
  "../../node_modules/ws/lib/websocket-server.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var http = require("http");
    var https = require("https");
    var net = require("net");
    var tls = require("tls");
    var { createHash } = require("crypto");
    var PerMessageDeflate = require_permessage_deflate();
    var WebSocket2 = require_websocket();
    var { format, parse } = require_extension();
    var { GUID, kWebSocket } = require_constants4();
    var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
    var RUNNING = 0;
    var CLOSING = 1;
    var CLOSED = 2;
    var WebSocketServer = class extends EventEmitter {
      /**
       * Create a `WebSocketServer` instance.
       *
       * @param {Object} options Configuration options
       * @param {Number} [options.backlog=511] The maximum length of the queue of
       *     pending connections
       * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
       *     track clients
       * @param {Function} [options.handleProtocols] A hook to handle protocols
       * @param {String} [options.host] The hostname where to bind the server
       * @param {Number} [options.maxPayload=104857600] The maximum allowed message
       *     size
       * @param {Boolean} [options.noServer=false] Enable no server mode
       * @param {String} [options.path] Accept only connections matching this path
       * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
       *     permessage-deflate
       * @param {Number} [options.port] The port where to bind the server
       * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
       *     server to use
       * @param {Function} [options.verifyClient] A hook to reject connections
       * @param {Function} [callback] A listener for the `listening` event
       */
      constructor(options, callback) {
        super();
        options = {
          maxPayload: 100 * 1024 * 1024,
          perMessageDeflate: false,
          handleProtocols: null,
          clientTracking: true,
          verifyClient: null,
          noServer: false,
          backlog: null,
          // use default (511 as implemented in net.js)
          server: null,
          host: null,
          path: null,
          port: null,
          ...options
        };
        if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {
          throw new TypeError(
            'One and only one of the "port", "server", or "noServer" options must be specified'
          );
        }
        if (options.port != null) {
          this._server = http.createServer((req, res) => {
            const body2 = http.STATUS_CODES[426];
            res.writeHead(426, {
              "Content-Length": body2.length,
              "Content-Type": "text/plain"
            });
            res.end(body2);
          });
          this._server.listen(
            options.port,
            options.host,
            options.backlog,
            callback
          );
        } else if (options.server) {
          this._server = options.server;
        }
        if (this._server) {
          const emitConnection = this.emit.bind(this, "connection");
          this._removeListeners = addListeners(this._server, {
            listening: this.emit.bind(this, "listening"),
            error: this.emit.bind(this, "error"),
            upgrade: (req, socket, head) => {
              this.handleUpgrade(req, socket, head, emitConnection);
            }
          });
        }
        if (options.perMessageDeflate === true)
          options.perMessageDeflate = {};
        if (options.clientTracking)
          this.clients = /* @__PURE__ */ new Set();
        this.options = options;
        this._state = RUNNING;
      }
      /**
       * Returns the bound address, the address family name, and port of the server
       * as reported by the operating system if listening on an IP socket.
       * If the server is listening on a pipe or UNIX domain socket, the name is
       * returned as a string.
       *
       * @return {(Object|String|null)} The address of the server
       * @public
       */
      address() {
        if (this.options.noServer) {
          throw new Error('The server is operating in "noServer" mode');
        }
        if (!this._server)
          return null;
        return this._server.address();
      }
      /**
       * Close the server.
       *
       * @param {Function} [cb] Callback
       * @public
       */
      close(cb) {
        if (cb)
          this.once("close", cb);
        if (this._state === CLOSED) {
          process.nextTick(emitClose, this);
          return;
        }
        if (this._state === CLOSING)
          return;
        this._state = CLOSING;
        if (this.clients) {
          for (const client of this.clients)
            client.terminate();
        }
        const server = this._server;
        if (server) {
          this._removeListeners();
          this._removeListeners = this._server = null;
          if (this.options.port != null) {
            server.close(emitClose.bind(void 0, this));
            return;
          }
        }
        process.nextTick(emitClose, this);
      }
      /**
       * See if a given request should be handled by this server instance.
       *
       * @param {http.IncomingMessage} req Request object to inspect
       * @return {Boolean} `true` if the request is valid, else `false`
       * @public
       */
      shouldHandle(req) {
        if (this.options.path) {
          const index = req.url.indexOf("?");
          const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
          if (pathname !== this.options.path)
            return false;
        }
        return true;
      }
      /**
       * Handle a HTTP Upgrade request.
       *
       * @param {http.IncomingMessage} req The request object
       * @param {(net.Socket|tls.Socket)} socket The network socket between the
       *     server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @public
       */
      handleUpgrade(req, socket, head, cb) {
        socket.on("error", socketOnError);
        const key = req.headers["sec-websocket-key"] !== void 0 ? req.headers["sec-websocket-key"].trim() : false;
        const version = +req.headers["sec-websocket-version"];
        const extensions = {};
        if (req.method !== "GET" || req.headers.upgrade.toLowerCase() !== "websocket" || !key || !keyRegex.test(key) || version !== 8 && version !== 13 || !this.shouldHandle(req)) {
          return abortHandshake(socket, 400);
        }
        if (this.options.perMessageDeflate) {
          const perMessageDeflate = new PerMessageDeflate(
            this.options.perMessageDeflate,
            true,
            this.options.maxPayload
          );
          try {
            const offers = parse(req.headers["sec-websocket-extensions"]);
            if (offers[PerMessageDeflate.extensionName]) {
              perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
              extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
            }
          } catch (err2) {
            return abortHandshake(socket, 400);
          }
        }
        if (this.options.verifyClient) {
          const info2 = {
            origin: req.headers[`${version === 8 ? "sec-websocket-origin" : "origin"}`],
            secure: !!(req.socket.authorized || req.socket.encrypted),
            req
          };
          if (this.options.verifyClient.length === 2) {
            this.options.verifyClient(info2, (verified, code, message, headers) => {
              if (!verified) {
                return abortHandshake(socket, code || 401, message, headers);
              }
              this.completeUpgrade(key, extensions, req, socket, head, cb);
            });
            return;
          }
          if (!this.options.verifyClient(info2))
            return abortHandshake(socket, 401);
        }
        this.completeUpgrade(key, extensions, req, socket, head, cb);
      }
      /**
       * Upgrade the connection to WebSocket.
       *
       * @param {String} key The value of the `Sec-WebSocket-Key` header
       * @param {Object} extensions The accepted extensions
       * @param {http.IncomingMessage} req The request object
       * @param {(net.Socket|tls.Socket)} socket The network socket between the
       *     server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @throws {Error} If called more than once with the same socket
       * @private
       */
      completeUpgrade(key, extensions, req, socket, head, cb) {
        if (!socket.readable || !socket.writable)
          return socket.destroy();
        if (socket[kWebSocket]) {
          throw new Error(
            "server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration"
          );
        }
        if (this._state > RUNNING)
          return abortHandshake(socket, 503);
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        const headers = [
          "HTTP/1.1 101 Switching Protocols",
          "Upgrade: websocket",
          "Connection: Upgrade",
          `Sec-WebSocket-Accept: ${digest}`
        ];
        const ws = new WebSocket2(null);
        let protocol = req.headers["sec-websocket-protocol"];
        if (protocol) {
          protocol = protocol.split(",").map(trim);
          if (this.options.handleProtocols) {
            protocol = this.options.handleProtocols(protocol, req);
          } else {
            protocol = protocol[0];
          }
          if (protocol) {
            headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
            ws._protocol = protocol;
          }
        }
        if (extensions[PerMessageDeflate.extensionName]) {
          const params = extensions[PerMessageDeflate.extensionName].params;
          const value = format({
            [PerMessageDeflate.extensionName]: [params]
          });
          headers.push(`Sec-WebSocket-Extensions: ${value}`);
          ws._extensions = extensions;
        }
        this.emit("headers", headers, req);
        socket.write(headers.concat("\r\n").join("\r\n"));
        socket.removeListener("error", socketOnError);
        ws.setSocket(socket, head, this.options.maxPayload);
        if (this.clients) {
          this.clients.add(ws);
          ws.on("close", () => this.clients.delete(ws));
        }
        cb(ws, req);
      }
    };
    module2.exports = WebSocketServer;
    function addListeners(server, map) {
      for (const event2 of Object.keys(map))
        server.on(event2, map[event2]);
      return function removeListeners() {
        for (const event2 of Object.keys(map)) {
          server.removeListener(event2, map[event2]);
        }
      };
    }
    function emitClose(server) {
      server._state = CLOSED;
      server.emit("close");
    }
    function socketOnError() {
      this.destroy();
    }
    function abortHandshake(socket, code, message, headers) {
      if (socket.writable) {
        message = message || http.STATUS_CODES[code];
        headers = {
          Connection: "close",
          "Content-Type": "text/html",
          "Content-Length": Buffer.byteLength(message),
          ...headers
        };
        socket.write(
          `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r
` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join("\r\n") + "\r\n\r\n" + message
        );
      }
      socket.removeListener("error", socketOnError);
      socket.destroy();
    }
    function trim(str) {
      return str.trim();
    }
  }
});

// ../../node_modules/ws/index.js
var require_ws = __commonJS({
  "../../node_modules/ws/index.js"(exports2, module2) {
    "use strict";
    var WebSocket2 = require_websocket();
    WebSocket2.createWebSocketStream = require_stream5();
    WebSocket2.Server = require_websocket_server();
    WebSocket2.Receiver = require_receiver();
    WebSocket2.Sender = require_sender();
    module2.exports = WebSocket2;
  }
});

// src/bindings/duckdb-mvp.js
var require_duckdb_mvp = __commonJS({
  "src/bindings/duckdb-mvp.js"(exports, module) {
    "use strict";
    var DuckDB = (() => {
      var _scriptDir = typeof document !== "undefined" && document.currentScript ? document.currentScript.src : void 0;
      if (typeof __filename !== "undefined")
        _scriptDir || (_scriptDir = __filename);
      return function(moduleArg = {}) {
        var Module = moduleArg;
        var readyPromiseResolve, readyPromiseReject;
        Module["ready"] = new Promise((resolve, reject) => {
          readyPromiseResolve = resolve;
          readyPromiseReject = reject;
        });
        var moduleOverrides = Object.assign({}, Module);
        var arguments_ = [];
        var thisProgram = "./this.program";
        var quit_ = (status, toThrow) => {
          throw toThrow;
        };
        var ENVIRONMENT_IS_WEB = typeof window == "object";
        var ENVIRONMENT_IS_WORKER = typeof importScripts == "function";
        var ENVIRONMENT_IS_NODE = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string";
        var ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;
        var scriptDirectory = "";
        function locateFile(path2) {
          if (Module["locateFile"]) {
            return Module["locateFile"](path2, scriptDirectory);
          }
          return scriptDirectory + path2;
        }
        var read_, readAsync, readBinary;
        if (ENVIRONMENT_IS_NODE) {
          var fs = require("fs");
          var nodePath = require("path");
          if (ENVIRONMENT_IS_WORKER) {
            scriptDirectory = nodePath.dirname(scriptDirectory) + "/";
          } else {
            scriptDirectory = __dirname + "/";
          }
          read_ = (filename, binary2) => {
            filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
            return fs.readFileSync(filename, binary2 ? void 0 : "utf8");
          };
          readBinary = (filename) => {
            var ret = read_(filename, true);
            if (!ret.buffer) {
              ret = new Uint8Array(ret);
            }
            return ret;
          };
          readAsync = (filename, onload2, onerror2, binary2 = true) => {
            filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
            fs.readFile(filename, binary2 ? void 0 : "utf8", (err2, data2) => {
              if (err2)
                onerror2(err2);
              else
                onload2(binary2 ? data2.buffer : data2);
            });
          };
          if (!Module["thisProgram"] && process.argv.length > 1) {
            thisProgram = process.argv[1].replace(/\\/g, "/");
          }
          arguments_ = process.argv.slice(2);
          quit_ = (status, toThrow) => {
            process.exitCode = status;
            throw toThrow;
          };
        } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
          if (ENVIRONMENT_IS_WORKER) {
            scriptDirectory = self.location.href;
          } else if (typeof document != "undefined" && document.currentScript) {
            scriptDirectory = document.currentScript.src;
          }
          if (_scriptDir) {
            scriptDirectory = _scriptDir;
          }
          if (scriptDirectory.indexOf("blob:") !== 0) {
            scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, "").lastIndexOf("/") + 1);
          } else {
            scriptDirectory = "";
          }
          {
            read_ = (url2) => {
              var xhr = new XMLHttpRequest();
              xhr.open("GET", url2, false);
              xhr.send(null);
              return xhr.responseText;
            };
            if (ENVIRONMENT_IS_WORKER) {
              readBinary = (url2) => {
                var xhr = new XMLHttpRequest();
                xhr.open("GET", url2, false);
                xhr.responseType = "arraybuffer";
                xhr.send(null);
                return new Uint8Array(xhr.response);
              };
            }
            readAsync = (url2, onload2, onerror2) => {
              var xhr = new XMLHttpRequest();
              xhr.open("GET", url2, true);
              xhr.responseType = "arraybuffer";
              xhr.onload = () => {
                if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
                  onload2(xhr.response);
                  return;
                }
                onerror2();
              };
              xhr.onerror = onerror2;
              xhr.send(null);
            };
          }
        } else {
        }
        var out = Module["print"] || console.log.bind(console);
        var err = Module["printErr"] || console.error.bind(console);
        Object.assign(Module, moduleOverrides);
        moduleOverrides = null;
        if (Module["arguments"])
          arguments_ = Module["arguments"];
        if (Module["thisProgram"])
          thisProgram = Module["thisProgram"];
        if (Module["quit"])
          quit_ = Module["quit"];
        var dynamicLibraries = Module["dynamicLibraries"] || [];
        var wasmBinary;
        if (Module["wasmBinary"])
          wasmBinary = Module["wasmBinary"];
        if (typeof WebAssembly != "object") {
          abort("no native wasm support detected");
        }
        var wasmMemory;
        var ABORT = false;
        var EXITSTATUS;
        function assert(condition, text) {
          if (!condition) {
            abort(text);
          }
        }
        var HEAP, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
        function updateMemoryViews() {
          var b = wasmMemory.buffer;
          Module["HEAP8"] = HEAP8 = new Int8Array(b);
          Module["HEAP16"] = HEAP16 = new Int16Array(b);
          Module["HEAPU8"] = HEAPU8 = new Uint8Array(b);
          Module["HEAPU16"] = HEAPU16 = new Uint16Array(b);
          Module["HEAP32"] = HEAP32 = new Int32Array(b);
          Module["HEAPU32"] = HEAPU32 = new Uint32Array(b);
          Module["HEAPF32"] = HEAPF32 = new Float32Array(b);
          Module["HEAPF64"] = HEAPF64 = new Float64Array(b);
        }
        var INITIAL_MEMORY = Module["INITIAL_MEMORY"] || 16777216;
        if (Module["wasmMemory"]) {
          wasmMemory = Module["wasmMemory"];
        } else {
          wasmMemory = new WebAssembly.Memory({
            "initial": INITIAL_MEMORY / 65536,
            "maximum": 4294967296 / 65536
          });
        }
        updateMemoryViews();
        INITIAL_MEMORY = wasmMemory.buffer.byteLength;
        var __ATPRERUN__ = [];
        var __ATINIT__ = [];
        var __ATMAIN__ = [];
        var __ATEXIT__ = [];
        var __ATPOSTRUN__ = [];
        var __RELOC_FUNCS__ = [];
        var runtimeInitialized = false;
        function preRun() {
          if (Module["preRun"]) {
            if (typeof Module["preRun"] == "function")
              Module["preRun"] = [Module["preRun"]];
            while (Module["preRun"].length) {
              addOnPreRun(Module["preRun"].shift());
            }
          }
          callRuntimeCallbacks(__ATPRERUN__);
        }
        function initRuntime() {
          runtimeInitialized = true;
          callRuntimeCallbacks(__RELOC_FUNCS__);
          if (!Module["noFSInit"] && !FS.init.initialized)
            FS.init();
          FS.ignorePermissions = false;
          TTY.init();
          SOCKFS.root = FS.mount(SOCKFS, {}, null);
          PIPEFS.root = FS.mount(PIPEFS, {}, null);
          callRuntimeCallbacks(__ATINIT__);
        }
        function preMain() {
          callRuntimeCallbacks(__ATMAIN__);
        }
        function postRun() {
          if (Module["postRun"]) {
            if (typeof Module["postRun"] == "function")
              Module["postRun"] = [Module["postRun"]];
            while (Module["postRun"].length) {
              addOnPostRun(Module["postRun"].shift());
            }
          }
          callRuntimeCallbacks(__ATPOSTRUN__);
        }
        function addOnPreRun(cb) {
          __ATPRERUN__.unshift(cb);
        }
        function addOnInit(cb) {
          __ATINIT__.unshift(cb);
        }
        function addOnPreMain(cb) {
          __ATMAIN__.unshift(cb);
        }
        function addOnExit(cb) {
        }
        function addOnPostRun(cb) {
          __ATPOSTRUN__.unshift(cb);
        }
        var runDependencies = 0;
        var runDependencyWatcher = null;
        var dependenciesFulfilled = null;
        function getUniqueRunDependency(id) {
          return id;
        }
        function addRunDependency(id) {
          var _a;
          runDependencies++;
          (_a = Module["monitorRunDependencies"]) == null ? void 0 : _a.call(Module, runDependencies);
        }
        function removeRunDependency(id) {
          var _a;
          runDependencies--;
          (_a = Module["monitorRunDependencies"]) == null ? void 0 : _a.call(Module, runDependencies);
          if (runDependencies == 0) {
            if (runDependencyWatcher !== null) {
              clearInterval(runDependencyWatcher);
              runDependencyWatcher = null;
            }
            if (dependenciesFulfilled) {
              var callback = dependenciesFulfilled;
              dependenciesFulfilled = null;
              callback();
            }
          }
        }
        function abort(what) {
          var _a;
          (_a = Module["onAbort"]) == null ? void 0 : _a.call(Module, what);
          what = "Aborted(" + what + ")";
          err(what);
          ABORT = true;
          EXITSTATUS = 1;
          what += ". Build with -sASSERTIONS for more info.";
          var e = new WebAssembly.RuntimeError(what);
          readyPromiseReject(e);
          throw e;
        }
        var dataURIPrefix = "data:application/octet-stream;base64,";
        var isDataURI = (filename) => filename.startsWith(dataURIPrefix);
        var isFileURI = (filename) => filename.startsWith("file://");
        var wasmBinaryFile;
        wasmBinaryFile = "./duckdb-mvp.wasm";
        if (!isDataURI(wasmBinaryFile)) {
          wasmBinaryFile = locateFile(wasmBinaryFile);
        }
        function getBinarySync(file) {
          if (file == wasmBinaryFile && wasmBinary) {
            return new Uint8Array(wasmBinary);
          }
          if (readBinary) {
            return readBinary(file);
          }
          throw "both async and sync fetching of the wasm failed";
        }
        function getBinaryPromise(binaryFile) {
          if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
            if (typeof fetch == "function") {
              return fetch(binaryFile, {
                credentials: "same-origin"
              }).then((response) => {
                if (!response["ok"]) {
                  throw "failed to load wasm binary file at '" + binaryFile + "'";
                }
                return response["arrayBuffer"]();
              }).catch(() => getBinarySync(binaryFile));
            }
          }
          return Promise.resolve().then(() => getBinarySync(binaryFile));
        }
        function instantiateArrayBuffer(binaryFile, imports, receiver) {
          return getBinaryPromise(binaryFile).then((binary2) => WebAssembly.instantiate(binary2, imports)).then((instance2) => instance2).then(receiver, (reason) => {
            err(`failed to asynchronously prepare wasm: ${reason}`);
            abort(reason);
          });
        }
        function instantiateAsync(binary2, binaryFile, imports, callback) {
          if (!binary2 && typeof WebAssembly.instantiateStreaming == "function" && !isDataURI(binaryFile) && !ENVIRONMENT_IS_NODE && typeof fetch == "function") {
            return fetch(binaryFile, {
              credentials: "same-origin"
            }).then((response) => {
              var result = WebAssembly.instantiateStreaming(response, imports);
              return result.then(callback, function(reason) {
                err(`wasm streaming compile failed: ${reason}`);
                err("falling back to ArrayBuffer instantiation");
                return instantiateArrayBuffer(binaryFile, imports, callback);
              });
            });
          }
          return instantiateArrayBuffer(binaryFile, imports, callback);
        }
        function createWasm() {
          var info2 = {
            "env": wasmImports,
            "wasi_snapshot_preview1": wasmImports,
            "GOT.mem": new Proxy(wasmImports, GOTHandler),
            "GOT.func": new Proxy(wasmImports, GOTHandler)
          };
          function receiveInstance(instance2, module2) {
            wasmExports = instance2.exports;
            wasmExports = relocateExports(wasmExports, 1024);
            var metadata2 = getDylinkMetadata(module2);
            if (metadata2.neededDynlibs) {
              dynamicLibraries = metadata2.neededDynlibs.concat(dynamicLibraries);
            }
            mergeLibSymbols(wasmExports, "main");
            LDSO.init();
            loadDylibs();
            wasmExports = applySignatureConversions(wasmExports);
            addOnInit(wasmExports["__wasm_call_ctors"]);
            __RELOC_FUNCS__.push(wasmExports["__wasm_apply_data_relocs"]);
            removeRunDependency("wasm-instantiate");
            return wasmExports;
          }
          addRunDependency("wasm-instantiate");
          function receiveInstantiationResult(result) {
            receiveInstance(result["instance"], result["module"]);
          }
          if (Module["instantiateWasm"]) {
            try {
              return Module["instantiateWasm"](info2, receiveInstance);
            } catch (e) {
              err(`Module.instantiateWasm callback failed with error: ${e}`);
              readyPromiseReject(e);
            }
          }
          instantiateAsync(wasmBinary, wasmBinaryFile, info2, receiveInstantiationResult).catch(readyPromiseReject);
          return {};
        }
        var tempDouble;
        var tempI64;
        var ASM_CONSTS = {
          2132064: ($0, $1) => {
            var jsString2 = typeof runtime == "object" && runtime && typeof runtime.whereToLoad == "function" && runtime.whereToLoad ? runtime.whereToLoad(UTF8ToString($0)) : UTF8ToString($1);
            var lengthBytes = lengthBytesUTF8(jsString2) + 1;
            var stringOnWasmHeap = _malloc(lengthBytes);
            stringToUTF8(jsString2, stringOnWasmHeap, lengthBytes);
            return stringOnWasmHeap;
          },
          2132430: ($0, $1) => {
            var url2 = UTF8ToString($0);
            if (typeof XMLHttpRequest === "undefined") {
              const os = require("os");
              const path2 = require("path");
              const fs5 = require("fs");
              var array = url2.split("/");
              var l = array.length;
              var folder = path2.join(os.homedir(), ".duckdb/extensions/" + array[l - 4] + "/" + array[l - 3] + "/" + array[l - 2] + "/");
              var filePath = path2.join(folder, array[l - 1]);
              try {
                if (!fs5.existsSync(folder)) {
                  fs5.mkdirSync(folder, {
                    recursive: true
                  });
                }
                if (!fs5.existsSync(filePath)) {
                  const int32 = new Int32Array(new SharedArrayBuffer(8));
                  var Worker3 = require("worker_threads").Worker;
                  var worker2 = new Worker3("const {Worker,isMainThread,parentPort,workerData,} = require('node:worker_threads');var times = 0;var SAB = 23;var Z = 0;async function ZZZ(e) {var x = await fetch(e);var res = await x.arrayBuffer();Atomics.store(SAB, 1, res.byteLength);Atomics.store(SAB, 0, 1);Atomics.notify(SAB, 1);Atomics.notify(SAB, 0);Z = res;};parentPort.on('message', function(event) {if (times == 0) {times++;SAB = event;} else if (times == 1) {times++;ZZZ(event);} else {const a = new Uint8Array(Z);const b = new Uint8Array(event.buffer);var K = Z.byteLength;for (var i = 0; i < K; i++) {b[i] = a[i];}Atomics.notify(event, 0);Atomics.store(SAB, 0, 2);Atomics.notify(SAB, 0);}});", {
                    eval: true
                  });
                  var uInt8Array;
                  int32[0] = 0;
                  int32[2] = 4;
                  worker2.postMessage(int32);
                  worker2.postMessage(url2);
                  Atomics.wait(int32, 0, 0);
                  const int32_2 = new Int32Array(new SharedArrayBuffer(int32[1] + 3 - (int32[1] + 3) % 4));
                  worker2.postMessage(int32_2);
                  Atomics.wait(int32, 0, 1);
                  var x = new Uint8Array(int32_2.buffer, 0, int32[1]);
                  uInt8Array = x;
                  worker2.terminate();
                  fs5.writeFileSync(filePath, uInt8Array);
                } else {
                  uInt8Array = fs5.readFileSync(filePath);
                }
              } catch (e) {
                console.log("Error fetching module", e);
                return 0;
              }
            } else {
              const xhr = new XMLHttpRequest();
              xhr.open("GET", url2, false);
              xhr.responseType = "arraybuffer";
              xhr.send(null);
              if (xhr.status != 200)
                return 0;
              uInt8Array = xhr.response;
            }
            var valid = WebAssembly.validate(uInt8Array);
            var len2 = uInt8Array.byteLength;
            var fileOnWasmHeap = _malloc(len2 + 4);
            var properArray = new Uint8Array(uInt8Array);
            for (var iii = 0; iii < len2; iii++) {
              Module.HEAPU8[iii + fileOnWasmHeap + 4] = properArray[iii];
            }
            var LEN123 = new Uint8Array(4);
            LEN123[0] = len2 % 256;
            len2 -= LEN123[0];
            len2 /= 256;
            LEN123[1] = len2 % 256;
            len2 -= LEN123[1];
            len2 /= 256;
            LEN123[2] = len2 % 256;
            len2 -= LEN123[2];
            len2 /= 256;
            LEN123[3] = len2 % 256;
            len2 -= LEN123[3];
            len2 /= 256;
            Module.HEAPU8.set(LEN123, fileOnWasmHeap);
            FS.writeFile(UTF8ToString($1), new Uint8Array(uInt8Array));
            return fileOnWasmHeap;
          },
          2135069: ($0) => {
            if (!$0) {
              AL.alcErr = 40964;
              return 1;
            }
          },
          2135117: ($0) => {
            if (!AL.currentCtx) {
              err("alGetProcAddress() called without a valid context");
              return 1;
            }
            if (!$0) {
              AL.currentCtx.err = 40963;
              return 1;
            }
          }
        };
        function ExitStatus(status) {
          this.name = "ExitStatus";
          this.message = `Program terminated with exit(${status})`;
          this.status = status;
        }
        var GOT = {};
        var currentModuleWeakSymbols = /* @__PURE__ */ new Set([]);
        var GOTHandler = {
          get(obj, symName) {
            var rtn = GOT[symName];
            if (!rtn) {
              rtn = GOT[symName] = new WebAssembly.Global({
                "value": "i32",
                "mutable": true
              });
            }
            if (!currentModuleWeakSymbols.has(symName)) {
              rtn.required = true;
            }
            return rtn;
          }
        };
        var callRuntimeCallbacks = (callbacks) => {
          while (callbacks.length > 0) {
            callbacks.shift()(Module);
          }
        };
        var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : void 0;
        var UTF8ArrayToString = (heapOrArray, idx, maxBytesToRead) => {
          idx >>>= 0;
          var endIdx = idx + maxBytesToRead;
          var endPtr = idx;
          while (heapOrArray[endPtr] && !(endPtr >= endIdx))
            ++endPtr;
          if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
            return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
          }
          var str = "";
          while (idx < endPtr) {
            var u0 = heapOrArray[idx++];
            if (!(u0 & 128)) {
              str += String.fromCharCode(u0);
              continue;
            }
            var u1 = heapOrArray[idx++] & 63;
            if ((u0 & 224) == 192) {
              str += String.fromCharCode((u0 & 31) << 6 | u1);
              continue;
            }
            var u2 = heapOrArray[idx++] & 63;
            if ((u0 & 240) == 224) {
              u0 = (u0 & 15) << 12 | u1 << 6 | u2;
            } else {
              u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
            }
            if (u0 < 65536) {
              str += String.fromCharCode(u0);
            } else {
              var ch = u0 - 65536;
              str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
            }
          }
          return str;
        };
        var getDylinkMetadata = (binary2) => {
          var offset = 0;
          var end = 0;
          function getU8() {
            return binary2[offset++];
          }
          function getLEB() {
            var ret = 0;
            var mul = 1;
            while (1) {
              var byte = binary2[offset++];
              ret += (byte & 127) * mul;
              mul *= 128;
              if (!(byte & 128))
                break;
            }
            return ret;
          }
          function getString() {
            var len2 = getLEB();
            offset += len2;
            return UTF8ArrayToString(binary2, offset - len2, len2);
          }
          function failIf(condition, message) {
            if (condition)
              throw new Error(message);
          }
          var name2 = "dylink.0";
          if (binary2 instanceof WebAssembly.Module) {
            var dylinkSection = WebAssembly.Module.customSections(binary2, name2);
            if (dylinkSection.length === 0) {
              name2 = "dylink";
              dylinkSection = WebAssembly.Module.customSections(binary2, name2);
            }
            failIf(dylinkSection.length === 0, "need dylink section");
            binary2 = new Uint8Array(dylinkSection[0]);
            end = binary2.length;
          } else {
            var int32View = new Uint32Array(new Uint8Array(binary2.subarray(0, 24)).buffer);
            var magicNumberFound = int32View[0] == 1836278016;
            failIf(!magicNumberFound, "need to see wasm magic number");
            failIf(binary2[8] !== 0, "need the dylink section to be first");
            offset = 9;
            var section_size = getLEB();
            end = offset + section_size;
            name2 = getString();
          }
          var customSection = {
            neededDynlibs: [],
            tlsExports: /* @__PURE__ */ new Set(),
            weakImports: /* @__PURE__ */ new Set()
          };
          if (name2 == "dylink") {
            customSection.memorySize = getLEB();
            customSection.memoryAlign = getLEB();
            customSection.tableSize = getLEB();
            customSection.tableAlign = getLEB();
            var neededDynlibsCount = getLEB();
            for (var i2 = 0; i2 < neededDynlibsCount; ++i2) {
              var libname = getString();
              customSection.neededDynlibs.push(libname);
            }
          } else {
            failIf(name2 !== "dylink.0");
            var WASM_DYLINK_MEM_INFO = 1;
            var WASM_DYLINK_NEEDED = 2;
            var WASM_DYLINK_EXPORT_INFO = 3;
            var WASM_DYLINK_IMPORT_INFO = 4;
            var WASM_SYMBOL_TLS = 256;
            var WASM_SYMBOL_BINDING_MASK = 3;
            var WASM_SYMBOL_BINDING_WEAK = 1;
            while (offset < end) {
              var subsectionType = getU8();
              var subsectionSize = getLEB();
              if (subsectionType === WASM_DYLINK_MEM_INFO) {
                customSection.memorySize = getLEB();
                customSection.memoryAlign = getLEB();
                customSection.tableSize = getLEB();
                customSection.tableAlign = getLEB();
              } else if (subsectionType === WASM_DYLINK_NEEDED) {
                var neededDynlibsCount = getLEB();
                for (var i2 = 0; i2 < neededDynlibsCount; ++i2) {
                  libname = getString();
                  customSection.neededDynlibs.push(libname);
                }
              } else if (subsectionType === WASM_DYLINK_EXPORT_INFO) {
                var count = getLEB();
                while (count--) {
                  var symname = getString();
                  var flags2 = getLEB();
                  if (flags2 & WASM_SYMBOL_TLS) {
                    customSection.tlsExports.add(symname);
                  }
                }
              } else if (subsectionType === WASM_DYLINK_IMPORT_INFO) {
                var count = getLEB();
                while (count--) {
                  var modname = getString();
                  var symname = getString();
                  var flags2 = getLEB();
                  if ((flags2 & WASM_SYMBOL_BINDING_MASK) == WASM_SYMBOL_BINDING_WEAK) {
                    customSection.weakImports.add(symname);
                  }
                }
              } else {
                offset += subsectionSize;
              }
            }
          }
          return customSection;
        };
        function getValue(ptr2, type = "i8") {
          if (type.endsWith("*"))
            type = "*";
          switch (type) {
            case "i1":
              return HEAP8[ptr2 >>> 0 >>> 0];
            case "i8":
              return HEAP8[ptr2 >>> 0 >>> 0];
            case "i16":
              return HEAP16[ptr2 >>> 1 >>> 0];
            case "i32":
              return HEAP32[ptr2 >>> 2 >>> 0];
            case "i64":
              abort("to do getValue(i64) use WASM_BIGINT");
            case "float":
              return HEAPF32[ptr2 >>> 2 >>> 0];
            case "double":
              return HEAPF64[ptr2 >>> 3 >>> 0];
            case "*":
              return HEAPU32[ptr2 >>> 2 >>> 0];
            default:
              abort(`invalid type for getValue: ${type}`);
          }
        }
        var newDSO = (name2, handle2, syms) => {
          var dso = {
            refcount: Infinity,
            name: name2,
            exports: syms,
            global: true
          };
          LDSO.loadedLibsByName[name2] = dso;
          if (handle2 != void 0) {
            LDSO.loadedLibsByHandle[handle2] = dso;
          }
          return dso;
        };
        var LDSO = {
          loadedLibsByName: {},
          loadedLibsByHandle: {},
          init() {
            newDSO("__main__", 0, wasmImports);
          }
        };
        var ___heap_base = 2277632;
        var zeroMemory = (address, size) => {
          HEAPU8.fill(0, address, address + size);
          return address;
        };
        var alignMemory = (size, alignment) => Math.ceil(size / alignment) * alignment;
        var getMemory = (size) => {
          if (runtimeInitialized) {
            return zeroMemory(_malloc(size), size);
          }
          var ret = ___heap_base;
          var end = ret + alignMemory(size, 16);
          ___heap_base = end;
          GOT["__heap_base"].value = end;
          return ret;
        };
        var isInternalSym = (symName) => ["__cpp_exception", "__c_longjmp", "__wasm_apply_data_relocs", "__dso_handle", "__tls_size", "__tls_align", "__set_stack_limits", "_emscripten_tls_init", "__wasm_init_tls", "__wasm_call_ctors", "__start_em_asm", "__stop_em_asm", "__start_em_js", "__stop_em_js"].includes(symName) || symName.startsWith("__em_js__");
        var uleb128Encode = (n, target) => {
          if (n < 128) {
            target.push(n);
          } else {
            target.push(n % 128 | 128, n >> 7);
          }
        };
        var sigToWasmTypes = (sig) => {
          var typeNames = {
            "i": "i32",
            "j": "i64",
            "f": "f32",
            "d": "f64",
            "e": "externref",
            "p": "i32"
          };
          var type = {
            parameters: [],
            results: sig[0] == "v" ? [] : [typeNames[sig[0]]]
          };
          for (var i2 = 1; i2 < sig.length; ++i2) {
            type.parameters.push(typeNames[sig[i2]]);
          }
          return type;
        };
        var generateFuncType = (sig, target) => {
          var sigRet = sig.slice(0, 1);
          var sigParam = sig.slice(1);
          var typeCodes = {
            "i": 127,
            "p": 127,
            "j": 126,
            "f": 125,
            "d": 124,
            "e": 111
          };
          target.push(96);
          uleb128Encode(sigParam.length, target);
          for (var i2 = 0; i2 < sigParam.length; ++i2) {
            target.push(typeCodes[sigParam[i2]]);
          }
          if (sigRet == "v") {
            target.push(0);
          } else {
            target.push(1, typeCodes[sigRet]);
          }
        };
        var convertJsFunctionToWasm = (func2, sig) => {
          if (typeof WebAssembly.Function == "function") {
            return new WebAssembly.Function(sigToWasmTypes(sig), func2);
          }
          var typeSectionBody = [1];
          generateFuncType(sig, typeSectionBody);
          var bytes = [0, 97, 115, 109, 1, 0, 0, 0, 1];
          uleb128Encode(typeSectionBody.length, bytes);
          bytes.push.apply(bytes, typeSectionBody);
          bytes.push(2, 7, 1, 1, 101, 1, 102, 0, 0, 7, 5, 1, 1, 102, 0, 0);
          var module2 = new WebAssembly.Module(new Uint8Array(bytes));
          var instance2 = new WebAssembly.Instance(module2, {
            "e": {
              "f": func2
            }
          });
          var wrappedFunc = instance2.exports["f"];
          return wrappedFunc;
        };
        var wasmTable = new WebAssembly.Table({
          "initial": 36736,
          "element": "anyfunc"
        });
        var getWasmTableEntry = (funcPtr) => wasmTable.get(funcPtr);
        var updateTableMap = (offset, count) => {
          if (functionsInTableMap) {
            for (var i2 = offset; i2 < offset + count; i2++) {
              var item = getWasmTableEntry(i2);
              if (item) {
                functionsInTableMap.set(item, i2);
              }
            }
          }
        };
        var functionsInTableMap;
        var getFunctionAddress = (func2) => {
          if (!functionsInTableMap) {
            functionsInTableMap = /* @__PURE__ */ new WeakMap();
            updateTableMap(0, wasmTable.length);
          }
          return functionsInTableMap.get(func2) || 0;
        };
        var freeTableIndexes = [];
        var getEmptyTableSlot = () => {
          if (freeTableIndexes.length) {
            return freeTableIndexes.pop();
          }
          try {
            wasmTable.grow(1);
          } catch (err2) {
            if (!(err2 instanceof RangeError)) {
              throw err2;
            }
            throw "Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.";
          }
          return wasmTable.length - 1;
        };
        var setWasmTableEntry = (idx, func2) => wasmTable.set(idx, func2);
        var addFunction = (func2, sig) => {
          var rtn = getFunctionAddress(func2);
          if (rtn) {
            return rtn;
          }
          var ret = getEmptyTableSlot();
          try {
            setWasmTableEntry(ret, func2);
          } catch (err2) {
            if (!(err2 instanceof TypeError)) {
              throw err2;
            }
            var wrapped = convertJsFunctionToWasm(func2, sig);
            setWasmTableEntry(ret, wrapped);
          }
          functionsInTableMap.set(func2, ret);
          return ret;
        };
        var updateGOT = (exports2, replace) => {
          for (var symName in exports2) {
            if (isInternalSym(symName)) {
              continue;
            }
            var value = exports2[symName];
            if (symName.startsWith("orig$")) {
              symName = symName.split("$")[1];
              replace = true;
            }
            GOT[symName] || (GOT[symName] = new WebAssembly.Global({
              "value": "i32",
              "mutable": true
            }));
            if (replace || GOT[symName].value == 0) {
              if (typeof value == "function") {
                GOT[symName].value = addFunction(value);
              } else if (typeof value == "number") {
                GOT[symName].value = value;
              } else {
                err(`unhandled export type for '${symName}': ${typeof value}`);
              }
            }
          }
        };
        var relocateExports = (exports2, memoryBase2, replace) => {
          var relocated = {};
          for (var e in exports2) {
            var value = exports2[e];
            if (typeof value == "object") {
              value = value.value;
            }
            if (typeof value == "number") {
              value += memoryBase2;
            }
            relocated[e] = value;
          }
          updateGOT(relocated, replace);
          return relocated;
        };
        var isSymbolDefined = (symName) => {
          var existing = wasmImports[symName];
          if (!existing || existing.stub) {
            return false;
          }
          return true;
        };
        var createDyncallWrapper = (sig) => {
          var sections = [];
          var prelude = [0, 97, 115, 109, 1, 0, 0, 0];
          sections.push(prelude);
          var wrappersig = [sig[0].replace("j", "i"), "i", sig.slice(1).replace(/j/g, "ii")].join("");
          var typeSectionBody = [3];
          generateFuncType(wrappersig, typeSectionBody);
          generateFuncType(sig, typeSectionBody);
          generateFuncType("vi", typeSectionBody);
          var typeSection = [1];
          uleb128Encode(typeSectionBody.length, typeSection);
          typeSection.push.apply(typeSection, typeSectionBody);
          sections.push(typeSection);
          var importSection = [2, 15, 2, 1, 101, 1, 116, 1, 112, 0, 0, 1, 101, 1, 114, 0, 2];
          sections.push(importSection);
          var functionSection = [3, 2, 1, 0];
          sections.push(functionSection);
          var exportSection = [7, 5, 1, 1, 102, 0, 1];
          sections.push(exportSection);
          var convert_code = [];
          if (sig[0] === "j") {
            convert_code = [1, 1, 126];
          } else {
            convert_code.push(0);
          }
          function localGet(j2) {
            convert_code.push(32);
            uleb128Encode(j2, convert_code);
          }
          var j = 1;
          for (var i2 = 1; i2 < sig.length; i2++) {
            if (sig[i2] == "j") {
              localGet(j + 1);
              convert_code.push(173, 66, 32, 134);
              localGet(j);
              convert_code.push(172, 132);
              j += 2;
            } else {
              localGet(j);
              j++;
            }
          }
          convert_code.push(32, 0, 17, 1, 0);
          if (sig[0] === "j") {
            convert_code.push(34);
            uleb128Encode(j, convert_code);
            convert_code.push(66, 32, 136, 167, 16, 0);
            localGet(j);
            convert_code.push(167);
          }
          convert_code.push(11);
          var codeBody = [1];
          uleb128Encode(convert_code.length, codeBody);
          codeBody.push.apply(codeBody, convert_code);
          var codeSection = [10];
          uleb128Encode(codeBody.length, codeSection);
          codeSection.push.apply(codeSection, codeBody);
          sections.push(codeSection);
          var bytes = new Uint8Array([].concat.apply([], sections));
          var module2 = new WebAssembly.Module(bytes);
          var instance2 = new WebAssembly.Instance(module2, {
            "e": {
              "t": wasmTable,
              "r": setTempRet0
            }
          });
          var wrappedFunc = instance2.exports["f"];
          return wrappedFunc;
        };
        var dynCallLegacy = (sig, ptr2, args2) => {
          if (!("dynCall_" + sig in Module)) {
            Module["dynCall_" + sig] = createDyncallWrapper(sig);
          }
          var f = Module["dynCall_" + sig];
          return args2 && args2.length ? f.apply(null, [ptr2].concat(args2)) : f.call(null, ptr2);
        };
        var dynCall = (sig, ptr2, args2) => {
          if (sig.includes("j")) {
            return dynCallLegacy(sig, ptr2, args2);
          }
          var rtn = getWasmTableEntry(ptr2).apply(null, args2);
          return rtn;
        };
        var createInvokeFunction = (sig) => function() {
          var sp = stackSave();
          try {
            return dynCall(sig, arguments[0], Array.prototype.slice.call(arguments, 1));
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        };
        var resolveGlobalSymbol = (symName, direct = false) => {
          var sym;
          if (direct && "orig$" + symName in wasmImports) {
            symName = "orig$" + symName;
          }
          if (isSymbolDefined(symName)) {
            sym = wasmImports[symName];
          } else if (symName.startsWith("invoke_")) {
            sym = wasmImports[symName] = createInvokeFunction(symName.split("_")[1]);
          } else if (symName.startsWith("__cxa_find_matching_catch_")) {
            sym = wasmImports[symName] = function() {
              var args2 = Array.from(arguments);
              var rtn = findMatchingCatch(args2);
              return rtn;
            };
          }
          return {
            sym,
            name: symName
          };
        };
        var UTF8ToString = (ptr2, maxBytesToRead) => {
          ptr2 >>>= 0;
          return ptr2 ? UTF8ArrayToString(HEAPU8, ptr2, maxBytesToRead) : "";
        };
        var loadWebAssemblyModule = (binary, flags, libName, localScope, handle) => {
          var metadata = getDylinkMetadata(binary);
          currentModuleWeakSymbols = metadata.weakImports;
          function loadModule() {
            var firstLoad = !handle || !HEAP8[handle + 8 >>> 0 >>> 0];
            if (firstLoad) {
              var memAlign = Math.pow(2, metadata.memoryAlign);
              var memoryBase = metadata.memorySize ? alignMemory(getMemory(metadata.memorySize + memAlign), memAlign) : 0;
              var tableBase = metadata.tableSize ? wasmTable.length : 0;
              if (handle) {
                HEAP8[handle + 8 >>> 0 >>> 0] = 1;
                HEAPU32[handle + 12 >>> 2 >>> 0] = memoryBase;
                HEAP32[handle + 16 >>> 2 >>> 0] = metadata.memorySize;
                HEAPU32[handle + 20 >>> 2 >>> 0] = tableBase;
                HEAP32[handle + 24 >>> 2 >>> 0] = metadata.tableSize;
              }
            } else {
              memoryBase = HEAPU32[handle + 12 >>> 2 >>> 0];
              tableBase = HEAPU32[handle + 20 >>> 2 >>> 0];
            }
            var tableGrowthNeeded = tableBase + metadata.tableSize - wasmTable.length;
            if (tableGrowthNeeded > 0) {
              wasmTable.grow(tableGrowthNeeded);
            }
            var moduleExports;
            function resolveSymbol(sym) {
              var resolved = resolveGlobalSymbol(sym).sym;
              if (!resolved && localScope) {
                resolved = localScope[sym];
              }
              if (!resolved) {
                resolved = moduleExports[sym];
              }
              return resolved;
            }
            var proxyHandler = {
              get(stubs, prop) {
                switch (prop) {
                  case "__memory_base":
                    return memoryBase;
                  case "__table_base":
                    return tableBase;
                }
                if (prop in wasmImports && !wasmImports[prop].stub) {
                  return wasmImports[prop];
                }
                if (!(prop in stubs)) {
                  var resolved;
                  stubs[prop] = function() {
                    resolved || (resolved = resolveSymbol(prop));
                    return resolved.apply(null, arguments);
                  };
                }
                return stubs[prop];
              }
            };
            var proxy = new Proxy({}, proxyHandler);
            var info = {
              "GOT.mem": new Proxy({}, GOTHandler),
              "GOT.func": new Proxy({}, GOTHandler),
              "env": proxy,
              "wasi_snapshot_preview1": proxy
            };
            function postInstantiation(module, instance) {
              updateTableMap(tableBase, metadata.tableSize);
              moduleExports = relocateExports(instance.exports, memoryBase);
              if (!flags.allowUndefined) {
                reportUndefinedSymbols();
              }
              function addEmAsm(addr, body) {
                var args = [];
                var arity = 0;
                for (; arity < 16; arity++) {
                  if (body.indexOf("$" + arity) != -1) {
                    args.push("$" + arity);
                  } else {
                    break;
                  }
                }
                args = args.join(",");
                var func = `(${args}) => { ${body} };`;
                ASM_CONSTS[start] = eval(func);
              }
              if ("__start_em_asm" in moduleExports) {
                var start = moduleExports["__start_em_asm"];
                var stop = moduleExports["__stop_em_asm"];
                while (start < stop) {
                  var jsString = UTF8ToString(start);
                  addEmAsm(start, jsString);
                  start = HEAPU8.indexOf(0, start) + 1;
                }
              }
              function addEmJs(name, cSig, body) {
                var jsArgs = [];
                cSig = cSig.slice(1, -1);
                if (cSig != "void") {
                  cSig = cSig.split(",");
                  for (var i in cSig) {
                    var jsArg = cSig[i].split(" ").pop();
                    jsArgs.push(jsArg.replace("*", ""));
                  }
                }
                var func = `(${jsArgs}) => ${body};`;
                moduleExports[name] = eval(func);
              }
              for (var name in moduleExports) {
                if (name.startsWith("__em_js__")) {
                  var start = moduleExports[name];
                  var jsString = UTF8ToString(start);
                  var parts = jsString.split("<::>");
                  addEmJs(name.replace("__em_js__", ""), parts[0], parts[1]);
                  delete moduleExports[name];
                }
              }
              var applyRelocs = moduleExports["__wasm_apply_data_relocs"];
              if (applyRelocs) {
                if (runtimeInitialized) {
                  applyRelocs();
                } else {
                  __RELOC_FUNCS__.push(applyRelocs);
                }
              }
              var init = moduleExports["__wasm_call_ctors"];
              if (init) {
                if (runtimeInitialized) {
                  init();
                } else {
                  __ATINIT__.push(init);
                }
              }
              return moduleExports;
            }
            if (flags.loadAsync) {
              if (binary instanceof WebAssembly.Module) {
                var instance = new WebAssembly.Instance(binary, info);
                return Promise.resolve(postInstantiation(binary, instance));
              }
              return WebAssembly.instantiate(binary, info).then((result) => postInstantiation(result.module, result.instance));
            }
            var module = binary instanceof WebAssembly.Module ? binary : new WebAssembly.Module(binary);
            var instance = new WebAssembly.Instance(module, info);
            return postInstantiation(module, instance);
          }
          if (flags.loadAsync) {
            return metadata.neededDynlibs.reduce((chain, dynNeeded) => chain.then(() => loadDynamicLibrary(dynNeeded, flags)), Promise.resolve()).then(loadModule);
          }
          metadata.neededDynlibs.forEach((needed) => loadDynamicLibrary(needed, flags, localScope));
          return loadModule();
        };
        var mergeLibSymbols = (exports2, libName2) => {
          for (var [sym, exp] of Object.entries(exports2)) {
            const setImport = (target) => {
              if (!isSymbolDefined(target)) {
                wasmImports[target] = exp;
              }
            };
            setImport(sym);
            if (sym.startsWith("dynCall_") && !Module.hasOwnProperty(sym)) {
              Module[sym] = exp;
            }
          }
        };
        var asyncLoad = (url2, onload2, onerror2, noRunDep) => {
          var dep = !noRunDep ? getUniqueRunDependency(`al ${url2}`) : "";
          readAsync(url2, (arrayBuffer) => {
            onload2(new Uint8Array(arrayBuffer));
            if (dep)
              removeRunDependency(dep);
          }, (event2) => {
            if (onerror2) {
              onerror2();
            } else {
              throw `Loading data file "${url2}" failed.`;
            }
          });
          if (dep)
            addRunDependency(dep);
        };
        var preloadPlugins = Module["preloadPlugins"] || [];
        var registerWasmPlugin = () => {
          var wasmPlugin = {
            "promiseChainEnd": Promise.resolve(),
            "canHandle": (name2) => !Module.noWasmDecoding && name2.endsWith(".so"),
            "handle": (byteArray, name2, onload2, onerror2) => {
              wasmPlugin["promiseChainEnd"] = wasmPlugin["promiseChainEnd"].then(() => loadWebAssemblyModule(byteArray, {
                loadAsync: true,
                nodelete: true
              }, name2)).then((exports2) => {
                preloadedWasm[name2] = exports2;
                onload2(byteArray);
              }, (error) => {
                err(`failed to instantiate wasm: ${name2}: ${error}`);
                onerror2();
              });
            }
          };
          preloadPlugins.push(wasmPlugin);
        };
        var preloadedWasm = {};
        function loadDynamicLibrary(libName2, flags2 = {
          global: true,
          nodelete: true
        }, localScope2, handle2) {
          var dso = LDSO.loadedLibsByName[libName2];
          if (dso) {
            if (!flags2.global) {
              if (localScope2) {
                Object.assign(localScope2, dso.exports);
              }
            } else if (!dso.global) {
              dso.global = true;
              mergeLibSymbols(dso.exports, libName2);
            }
            if (flags2.nodelete && dso.refcount !== Infinity) {
              dso.refcount = Infinity;
            }
            dso.refcount++;
            if (handle2) {
              LDSO.loadedLibsByHandle[handle2] = dso;
            }
            return flags2.loadAsync ? Promise.resolve(true) : true;
          }
          dso = newDSO(libName2, handle2, "loading");
          dso.refcount = flags2.nodelete ? Infinity : 1;
          dso.global = flags2.global;
          function loadLibData() {
            if (handle2) {
              var data2 = HEAPU32[handle2 + 28 >>> 2 >>> 0];
              var dataSize = HEAPU32[handle2 + 32 >>> 2 >>> 0];
              if (data2 && dataSize) {
                var libData = HEAP8.slice(data2, data2 + dataSize);
                return flags2.loadAsync ? Promise.resolve(libData) : libData;
              }
            }
            var libFile = locateFile(libName2);
            if (flags2.loadAsync) {
              return new Promise(function(resolve, reject) {
                asyncLoad(libFile, resolve, reject);
              });
            }
            if (!readBinary) {
              throw new Error(`${libFile}: file not found, and synchronous loading of external files is not available`);
            }
            return readBinary(libFile);
          }
          function getExports() {
            var preloaded = preloadedWasm[libName2];
            if (preloaded) {
              return flags2.loadAsync ? Promise.resolve(preloaded) : preloaded;
            }
            if (flags2.loadAsync) {
              return loadLibData().then((libData) => loadWebAssemblyModule(libData, flags2, libName2, localScope2, handle2));
            }
            return loadWebAssemblyModule(loadLibData(), flags2, libName2, localScope2, handle2);
          }
          function moduleLoaded(exports2) {
            if (dso.global) {
              mergeLibSymbols(exports2, libName2);
            } else if (localScope2) {
              Object.assign(localScope2, exports2);
            }
            dso.exports = exports2;
          }
          if (flags2.loadAsync) {
            return getExports().then((exports2) => {
              moduleLoaded(exports2);
              return true;
            });
          }
          moduleLoaded(getExports());
          return true;
        }
        var reportUndefinedSymbols = () => {
          for (var [symName, entry] of Object.entries(GOT)) {
            if (entry.value == 0) {
              var value = resolveGlobalSymbol(symName, true).sym;
              if (!value && !entry.required) {
                continue;
              }
              if (typeof value == "function") {
                entry.value = addFunction(value, value.sig);
              } else if (typeof value == "number") {
                entry.value = value;
              } else {
                throw new Error(`bad export type for '${symName}': ${typeof value}`);
              }
            }
          }
        };
        var loadDylibs = () => {
          if (!dynamicLibraries.length) {
            reportUndefinedSymbols();
            return;
          }
          addRunDependency("loadDylibs");
          dynamicLibraries.reduce((chain, lib) => chain.then(() => loadDynamicLibrary(lib, {
            loadAsync: true,
            global: true,
            nodelete: true,
            allowUndefined: true
          })), Promise.resolve()).then(() => {
            reportUndefinedSymbols();
            removeRunDependency("loadDylibs");
          });
        };
        var noExitRuntime = Module["noExitRuntime"] || true;
        function setValue(ptr2, value, type = "i8") {
          if (type.endsWith("*"))
            type = "*";
          switch (type) {
            case "i1":
              HEAP8[ptr2 >>> 0 >>> 0] = value;
              break;
            case "i8":
              HEAP8[ptr2 >>> 0 >>> 0] = value;
              break;
            case "i16":
              HEAP16[ptr2 >>> 1 >>> 0] = value;
              break;
            case "i32":
              HEAP32[ptr2 >>> 2 >>> 0] = value;
              break;
            case "i64":
              abort("to do setValue(i64) use WASM_BIGINT");
            case "float":
              HEAPF32[ptr2 >>> 2 >>> 0] = value;
              break;
            case "double":
              HEAPF64[ptr2 >>> 3 >>> 0] = value;
              break;
            case "*":
              HEAPU32[ptr2 >>> 2 >>> 0] = value;
              break;
            default:
              abort(`invalid type for setValue: ${type}`);
          }
        }
        var convertI32PairToI53Checked = (lo, hi) => hi + 2097152 >>> 0 < 4194305 - !!lo ? (lo >>> 0) + hi * 4294967296 : NaN;
        function ___assert_fail(condition, filename, line, func2) {
          condition >>>= 0;
          filename >>>= 0;
          func2 >>>= 0;
          abort(`Assertion failed: ${UTF8ToString(condition)}, at: ` + [filename ? UTF8ToString(filename) : "unknown filename", line, func2 ? UTF8ToString(func2) : "unknown function"]);
        }
        ___assert_fail.sig = "vppip";
        function ___call_sighandler(fp, sig) {
          fp >>>= 0;
          return getWasmTableEntry(fp)(sig);
        }
        ___call_sighandler.sig = "vpi";
        var exceptionCaught = [];
        var uncaughtExceptionCount = 0;
        function ___cxa_begin_catch(ptr2) {
          ptr2 >>>= 0;
          var info2 = new ExceptionInfo(ptr2);
          if (!info2.get_caught()) {
            info2.set_caught(true);
            uncaughtExceptionCount--;
          }
          info2.set_rethrown(false);
          exceptionCaught.push(info2);
          ___cxa_increment_exception_refcount(info2.excPtr);
          return info2.get_exception_ptr();
        }
        ___cxa_begin_catch.sig = "pp";
        function ___cxa_current_primary_exception() {
          if (!exceptionCaught.length) {
            return 0;
          }
          var info2 = exceptionCaught[exceptionCaught.length - 1];
          ___cxa_increment_exception_refcount(info2.excPtr);
          return info2.excPtr;
        }
        ___cxa_current_primary_exception.sig = "p";
        var exceptionLast = 0;
        var ___cxa_end_catch = () => {
          _setThrew(0, 0);
          var info2 = exceptionCaught.pop();
          ___cxa_decrement_exception_refcount(info2.excPtr);
          exceptionLast = 0;
        };
        ___cxa_end_catch.sig = "v";
        class ExceptionInfo {
          constructor(excPtr) {
            this.excPtr = excPtr;
            this.ptr = excPtr - 24;
          }
          set_type(type) {
            HEAPU32[this.ptr + 4 >>> 2 >>> 0] = type;
          }
          get_type() {
            return HEAPU32[this.ptr + 4 >>> 2 >>> 0];
          }
          set_destructor(destructor) {
            HEAPU32[this.ptr + 8 >>> 2 >>> 0] = destructor;
          }
          get_destructor() {
            return HEAPU32[this.ptr + 8 >>> 2 >>> 0];
          }
          set_caught(caught) {
            caught = caught ? 1 : 0;
            HEAP8[this.ptr + 12 >>> 0 >>> 0] = caught;
          }
          get_caught() {
            return HEAP8[this.ptr + 12 >>> 0 >>> 0] != 0;
          }
          set_rethrown(rethrown) {
            rethrown = rethrown ? 1 : 0;
            HEAP8[this.ptr + 13 >>> 0 >>> 0] = rethrown;
          }
          get_rethrown() {
            return HEAP8[this.ptr + 13 >>> 0 >>> 0] != 0;
          }
          init(type, destructor) {
            this.set_adjusted_ptr(0);
            this.set_type(type);
            this.set_destructor(destructor);
          }
          set_adjusted_ptr(adjustedPtr) {
            HEAPU32[this.ptr + 16 >>> 2 >>> 0] = adjustedPtr;
          }
          get_adjusted_ptr() {
            return HEAPU32[this.ptr + 16 >>> 2 >>> 0];
          }
          get_exception_ptr() {
            var isPointer = ___cxa_is_pointer_type(this.get_type());
            if (isPointer) {
              return HEAPU32[this.excPtr >>> 2 >>> 0];
            }
            var adjusted = this.get_adjusted_ptr();
            if (adjusted !== 0)
              return adjusted;
            return this.excPtr;
          }
        }
        function ___resumeException(ptr2) {
          ptr2 >>>= 0;
          if (!exceptionLast) {
            exceptionLast = ptr2;
          }
          throw exceptionLast;
        }
        ___resumeException.sig = "vp";
        var findMatchingCatch = (args2) => {
          var thrown = exceptionLast;
          if (!thrown) {
            setTempRet0(0);
            return 0;
          }
          var info2 = new ExceptionInfo(thrown);
          info2.set_adjusted_ptr(thrown);
          var thrownType = info2.get_type();
          if (!thrownType) {
            setTempRet0(0);
            return thrown;
          }
          for (var arg in args2) {
            var caughtType = args2[arg];
            if (caughtType === 0 || caughtType === thrownType) {
              break;
            }
            var adjusted_ptr_addr = info2.ptr + 16;
            if (___cxa_can_catch(caughtType, thrownType, adjusted_ptr_addr)) {
              setTempRet0(caughtType);
              return thrown;
            }
          }
          setTempRet0(thrownType);
          return thrown;
        };
        function ___cxa_find_matching_catch_2() {
          return findMatchingCatch([]);
        }
        ___cxa_find_matching_catch_2.sig = "p";
        function ___cxa_find_matching_catch_3(arg0) {
          arg0 >>>= 0;
          return findMatchingCatch([arg0]);
        }
        ___cxa_find_matching_catch_3.sig = "pp";
        function ___cxa_find_matching_catch_4(arg0, arg1) {
          arg0 >>>= 0;
          arg1 >>>= 0;
          return findMatchingCatch([arg0, arg1]);
        }
        ___cxa_find_matching_catch_4.sig = "ppp";
        function ___cxa_find_matching_catch_5(arg0, arg1, arg2) {
          arg0 >>>= 0;
          arg1 >>>= 0;
          arg2 >>>= 0;
          return findMatchingCatch([arg0, arg1, arg2]);
        }
        ___cxa_find_matching_catch_5.sig = "pppp";
        function ___cxa_find_matching_catch_6(arg0, arg1, arg2, arg3) {
          arg0 >>>= 0;
          arg1 >>>= 0;
          arg2 >>>= 0;
          arg3 >>>= 0;
          return findMatchingCatch([arg0, arg1, arg2, arg3]);
        }
        ___cxa_find_matching_catch_6.sig = "ppppp";
        function ___cxa_find_matching_catch_7(arg0, arg1, arg2, arg3, arg4) {
          arg0 >>>= 0;
          arg1 >>>= 0;
          arg2 >>>= 0;
          arg3 >>>= 0;
          arg4 >>>= 0;
          return findMatchingCatch([arg0, arg1, arg2, arg3, arg4]);
        }
        ___cxa_find_matching_catch_7.sig = "pppppp";
        var ___cxa_rethrow = () => {
          var info2 = exceptionCaught.pop();
          if (!info2) {
            abort("no exception to throw");
          }
          var ptr2 = info2.excPtr;
          if (!info2.get_rethrown()) {
            exceptionCaught.push(info2);
            info2.set_rethrown(true);
            info2.set_caught(false);
            uncaughtExceptionCount++;
          }
          exceptionLast = ptr2;
          throw exceptionLast;
        };
        ___cxa_rethrow.sig = "v";
        function ___cxa_rethrow_primary_exception(ptr2) {
          ptr2 >>>= 0;
          if (!ptr2)
            return;
          var info2 = new ExceptionInfo(ptr2);
          exceptionCaught.push(info2);
          info2.set_rethrown(true);
          ___cxa_rethrow();
        }
        ___cxa_rethrow_primary_exception.sig = "vp";
        function ___cxa_throw(ptr2, type, destructor) {
          ptr2 >>>= 0;
          type >>>= 0;
          destructor >>>= 0;
          var info2 = new ExceptionInfo(ptr2);
          info2.init(type, destructor);
          exceptionLast = ptr2;
          uncaughtExceptionCount++;
          throw exceptionLast;
        }
        ___cxa_throw.sig = "vppp";
        var ___cxa_uncaught_exceptions = () => uncaughtExceptionCount;
        ___cxa_uncaught_exceptions.sig = "i";
        var ___memory_base = new WebAssembly.Global({
          "value": "i32",
          "mutable": false
        }, 1024);
        var ___stack_high = 2277632;
        var ___stack_low = 2212096;
        var ___stack_pointer = new WebAssembly.Global({
          "value": "i32",
          "mutable": true
        }, 2277632);
        var PATH = {
          isAbs: (path2) => path2.charAt(0) === "/",
          splitPath: (filename) => {
            var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
            return splitPathRe.exec(filename).slice(1);
          },
          normalizeArray: (parts2, allowAboveRoot) => {
            var up = 0;
            for (var i2 = parts2.length - 1; i2 >= 0; i2--) {
              var last = parts2[i2];
              if (last === ".") {
                parts2.splice(i2, 1);
              } else if (last === "..") {
                parts2.splice(i2, 1);
                up++;
              } else if (up) {
                parts2.splice(i2, 1);
                up--;
              }
            }
            if (allowAboveRoot) {
              for (; up; up--) {
                parts2.unshift("..");
              }
            }
            return parts2;
          },
          normalize: (path2) => {
            var isAbsolute = PATH.isAbs(path2), trailingSlash = path2.substr(-1) === "/";
            path2 = PATH.normalizeArray(path2.split("/").filter((p) => !!p), !isAbsolute).join("/");
            if (!path2 && !isAbsolute) {
              path2 = ".";
            }
            if (path2 && trailingSlash) {
              path2 += "/";
            }
            return (isAbsolute ? "/" : "") + path2;
          },
          dirname: (path2) => {
            var result = PATH.splitPath(path2), root = result[0], dir = result[1];
            if (!root && !dir) {
              return ".";
            }
            if (dir) {
              dir = dir.substr(0, dir.length - 1);
            }
            return root + dir;
          },
          basename: (path2) => {
            if (path2 === "/")
              return "/";
            path2 = PATH.normalize(path2);
            path2 = path2.replace(/\/$/, "");
            var lastSlash = path2.lastIndexOf("/");
            if (lastSlash === -1)
              return path2;
            return path2.substr(lastSlash + 1);
          },
          join: function() {
            var paths = Array.prototype.slice.call(arguments);
            return PATH.normalize(paths.join("/"));
          },
          join2: (l, r) => PATH.normalize(l + "/" + r)
        };
        var initRandomFill = () => {
          if (typeof crypto == "object" && typeof crypto["getRandomValues"] == "function") {
            return (view) => crypto.getRandomValues(view);
          } else if (ENVIRONMENT_IS_NODE) {
            try {
              var crypto_module = require("crypto");
              var randomFillSync = crypto_module["randomFillSync"];
              if (randomFillSync) {
                return (view) => crypto_module["randomFillSync"](view);
              }
              var randomBytes = crypto_module["randomBytes"];
              return (view) => (view.set(randomBytes(view.byteLength)), view);
            } catch (e) {
            }
          }
          abort("initRandomDevice");
        };
        var randomFill = (view) => (randomFill = initRandomFill())(view);
        var PATH_FS = {
          resolve: function() {
            var resolvedPath = "", resolvedAbsolute = false;
            for (var i2 = arguments.length - 1; i2 >= -1 && !resolvedAbsolute; i2--) {
              var path2 = i2 >= 0 ? arguments[i2] : FS.cwd();
              if (typeof path2 != "string") {
                throw new TypeError("Arguments to path.resolve must be strings");
              } else if (!path2) {
                return "";
              }
              resolvedPath = path2 + "/" + resolvedPath;
              resolvedAbsolute = PATH.isAbs(path2);
            }
            resolvedPath = PATH.normalizeArray(resolvedPath.split("/").filter((p) => !!p), !resolvedAbsolute).join("/");
            return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
          },
          relative: (from, to) => {
            from = PATH_FS.resolve(from).substr(1);
            to = PATH_FS.resolve(to).substr(1);
            function trim(arr) {
              var start2 = 0;
              for (; start2 < arr.length; start2++) {
                if (arr[start2] !== "")
                  break;
              }
              var end = arr.length - 1;
              for (; end >= 0; end--) {
                if (arr[end] !== "")
                  break;
              }
              if (start2 > end)
                return [];
              return arr.slice(start2, end - start2 + 1);
            }
            var fromParts = trim(from.split("/"));
            var toParts = trim(to.split("/"));
            var length = Math.min(fromParts.length, toParts.length);
            var samePartsLength = length;
            for (var i2 = 0; i2 < length; i2++) {
              if (fromParts[i2] !== toParts[i2]) {
                samePartsLength = i2;
                break;
              }
            }
            var outputParts = [];
            for (var i2 = samePartsLength; i2 < fromParts.length; i2++) {
              outputParts.push("..");
            }
            outputParts = outputParts.concat(toParts.slice(samePartsLength));
            return outputParts.join("/");
          }
        };
        var FS_stdin_getChar_buffer = [];
        var lengthBytesUTF8 = (str) => {
          var len2 = 0;
          for (var i2 = 0; i2 < str.length; ++i2) {
            var c = str.charCodeAt(i2);
            if (c <= 127) {
              len2++;
            } else if (c <= 2047) {
              len2 += 2;
            } else if (c >= 55296 && c <= 57343) {
              len2 += 4;
              ++i2;
            } else {
              len2 += 3;
            }
          }
          return len2;
        };
        var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {
          outIdx >>>= 0;
          if (!(maxBytesToWrite > 0))
            return 0;
          var startIdx = outIdx;
          var endIdx = outIdx + maxBytesToWrite - 1;
          for (var i2 = 0; i2 < str.length; ++i2) {
            var u = str.charCodeAt(i2);
            if (u >= 55296 && u <= 57343) {
              var u1 = str.charCodeAt(++i2);
              u = 65536 + ((u & 1023) << 10) | u1 & 1023;
            }
            if (u <= 127) {
              if (outIdx >= endIdx)
                break;
              heap[outIdx++ >>> 0] = u;
            } else if (u <= 2047) {
              if (outIdx + 1 >= endIdx)
                break;
              heap[outIdx++ >>> 0] = 192 | u >> 6;
              heap[outIdx++ >>> 0] = 128 | u & 63;
            } else if (u <= 65535) {
              if (outIdx + 2 >= endIdx)
                break;
              heap[outIdx++ >>> 0] = 224 | u >> 12;
              heap[outIdx++ >>> 0] = 128 | u >> 6 & 63;
              heap[outIdx++ >>> 0] = 128 | u & 63;
            } else {
              if (outIdx + 3 >= endIdx)
                break;
              heap[outIdx++ >>> 0] = 240 | u >> 18;
              heap[outIdx++ >>> 0] = 128 | u >> 12 & 63;
              heap[outIdx++ >>> 0] = 128 | u >> 6 & 63;
              heap[outIdx++ >>> 0] = 128 | u & 63;
            }
          }
          heap[outIdx >>> 0] = 0;
          return outIdx - startIdx;
        };
        function intArrayFromString(stringy, dontAddNull, length) {
          var len2 = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
          var u8array = new Array(len2);
          var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
          if (dontAddNull)
            u8array.length = numBytesWritten;
          return u8array;
        }
        var FS_stdin_getChar = () => {
          if (!FS_stdin_getChar_buffer.length) {
            var result = null;
            if (ENVIRONMENT_IS_NODE) {
              var BUFSIZE = 256;
              var buf = Buffer.alloc(BUFSIZE);
              var bytesRead = 0;
              var fd = process.stdin.fd;
              try {
                bytesRead = fs.readSync(fd, buf);
              } catch (e) {
                if (e.toString().includes("EOF"))
                  bytesRead = 0;
                else
                  throw e;
              }
              if (bytesRead > 0) {
                result = buf.slice(0, bytesRead).toString("utf-8");
              } else {
                result = null;
              }
            } else if (typeof window != "undefined" && typeof window.prompt == "function") {
              result = window.prompt("Input: ");
              if (result !== null) {
                result += "\n";
              }
            } else if (typeof readline == "function") {
              result = readline();
              if (result !== null) {
                result += "\n";
              }
            }
            if (!result) {
              return null;
            }
            FS_stdin_getChar_buffer = intArrayFromString(result, true);
          }
          return FS_stdin_getChar_buffer.shift();
        };
        var TTY = {
          ttys: [],
          init() {
          },
          shutdown() {
          },
          register(dev, ops) {
            TTY.ttys[dev] = {
              input: [],
              output: [],
              ops
            };
            FS.registerDevice(dev, TTY.stream_ops);
          },
          stream_ops: {
            open(stream) {
              var tty = TTY.ttys[stream.node.rdev];
              if (!tty) {
                throw new FS.ErrnoError(43);
              }
              stream.tty = tty;
              stream.seekable = false;
            },
            close(stream) {
              stream.tty.ops.fsync(stream.tty);
            },
            fsync(stream) {
              stream.tty.ops.fsync(stream.tty);
            },
            read(stream, buffer, offset, length, pos) {
              if (!stream.tty || !stream.tty.ops.get_char) {
                throw new FS.ErrnoError(60);
              }
              var bytesRead = 0;
              for (var i2 = 0; i2 < length; i2++) {
                var result;
                try {
                  result = stream.tty.ops.get_char(stream.tty);
                } catch (e) {
                  throw new FS.ErrnoError(29);
                }
                if (result === void 0 && bytesRead === 0) {
                  throw new FS.ErrnoError(6);
                }
                if (result === null || result === void 0)
                  break;
                bytesRead++;
                buffer[offset + i2] = result;
              }
              if (bytesRead) {
                stream.node.timestamp = Date.now();
              }
              return bytesRead;
            },
            write(stream, buffer, offset, length, pos) {
              if (!stream.tty || !stream.tty.ops.put_char) {
                throw new FS.ErrnoError(60);
              }
              try {
                for (var i2 = 0; i2 < length; i2++) {
                  stream.tty.ops.put_char(stream.tty, buffer[offset + i2]);
                }
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
              if (length) {
                stream.node.timestamp = Date.now();
              }
              return i2;
            }
          },
          default_tty_ops: {
            get_char(tty) {
              return FS_stdin_getChar();
            },
            put_char(tty, val) {
              if (val === null || val === 10) {
                out(UTF8ArrayToString(tty.output, 0));
                tty.output = [];
              } else {
                if (val != 0)
                  tty.output.push(val);
              }
            },
            fsync(tty) {
              if (tty.output && tty.output.length > 0) {
                out(UTF8ArrayToString(tty.output, 0));
                tty.output = [];
              }
            },
            ioctl_tcgets(tty) {
              return {
                c_iflag: 25856,
                c_oflag: 5,
                c_cflag: 191,
                c_lflag: 35387,
                c_cc: [3, 28, 127, 21, 4, 0, 1, 0, 17, 19, 26, 0, 18, 15, 23, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
              };
            },
            ioctl_tcsets(tty, optional_actions, data2) {
              return 0;
            },
            ioctl_tiocgwinsz(tty) {
              return [24, 80];
            }
          },
          default_tty1_ops: {
            put_char(tty, val) {
              if (val === null || val === 10) {
                err(UTF8ArrayToString(tty.output, 0));
                tty.output = [];
              } else {
                if (val != 0)
                  tty.output.push(val);
              }
            },
            fsync(tty) {
              if (tty.output && tty.output.length > 0) {
                err(UTF8ArrayToString(tty.output, 0));
                tty.output = [];
              }
            }
          }
        };
        var mmapAlloc = (size) => {
          size = alignMemory(size, 65536);
          var ptr2 = _emscripten_builtin_memalign(65536, size);
          if (!ptr2)
            return 0;
          return zeroMemory(ptr2, size);
        };
        var MEMFS = {
          ops_table: null,
          mount(mount) {
            return MEMFS.createNode(null, "/", 16384 | 511, 0);
          },
          createNode(parent, name2, mode, dev) {
            if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
              throw new FS.ErrnoError(63);
            }
            MEMFS.ops_table || (MEMFS.ops_table = {
              dir: {
                node: {
                  getattr: MEMFS.node_ops.getattr,
                  setattr: MEMFS.node_ops.setattr,
                  lookup: MEMFS.node_ops.lookup,
                  mknod: MEMFS.node_ops.mknod,
                  rename: MEMFS.node_ops.rename,
                  unlink: MEMFS.node_ops.unlink,
                  rmdir: MEMFS.node_ops.rmdir,
                  readdir: MEMFS.node_ops.readdir,
                  symlink: MEMFS.node_ops.symlink
                },
                stream: {
                  llseek: MEMFS.stream_ops.llseek
                }
              },
              file: {
                node: {
                  getattr: MEMFS.node_ops.getattr,
                  setattr: MEMFS.node_ops.setattr
                },
                stream: {
                  llseek: MEMFS.stream_ops.llseek,
                  read: MEMFS.stream_ops.read,
                  write: MEMFS.stream_ops.write,
                  allocate: MEMFS.stream_ops.allocate,
                  mmap: MEMFS.stream_ops.mmap,
                  msync: MEMFS.stream_ops.msync
                }
              },
              link: {
                node: {
                  getattr: MEMFS.node_ops.getattr,
                  setattr: MEMFS.node_ops.setattr,
                  readlink: MEMFS.node_ops.readlink
                },
                stream: {}
              },
              chrdev: {
                node: {
                  getattr: MEMFS.node_ops.getattr,
                  setattr: MEMFS.node_ops.setattr
                },
                stream: FS.chrdev_stream_ops
              }
            });
            var node = FS.createNode(parent, name2, mode, dev);
            if (FS.isDir(node.mode)) {
              node.node_ops = MEMFS.ops_table.dir.node;
              node.stream_ops = MEMFS.ops_table.dir.stream;
              node.contents = {};
            } else if (FS.isFile(node.mode)) {
              node.node_ops = MEMFS.ops_table.file.node;
              node.stream_ops = MEMFS.ops_table.file.stream;
              node.usedBytes = 0;
              node.contents = null;
            } else if (FS.isLink(node.mode)) {
              node.node_ops = MEMFS.ops_table.link.node;
              node.stream_ops = MEMFS.ops_table.link.stream;
            } else if (FS.isChrdev(node.mode)) {
              node.node_ops = MEMFS.ops_table.chrdev.node;
              node.stream_ops = MEMFS.ops_table.chrdev.stream;
            }
            node.timestamp = Date.now();
            if (parent) {
              parent.contents[name2] = node;
              parent.timestamp = node.timestamp;
            }
            return node;
          },
          getFileDataAsTypedArray(node) {
            if (!node.contents)
              return new Uint8Array(0);
            if (node.contents.subarray)
              return node.contents.subarray(0, node.usedBytes);
            return new Uint8Array(node.contents);
          },
          expandFileStorage(node, newCapacity) {
            var prevCapacity = node.contents ? node.contents.length : 0;
            if (prevCapacity >= newCapacity)
              return;
            var CAPACITY_DOUBLING_MAX = 1024 * 1024;
            newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0);
            if (prevCapacity != 0)
              newCapacity = Math.max(newCapacity, 256);
            var oldContents = node.contents;
            node.contents = new Uint8Array(newCapacity);
            if (node.usedBytes > 0)
              node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
          },
          resizeFileStorage(node, newSize) {
            if (node.usedBytes == newSize)
              return;
            if (newSize == 0) {
              node.contents = null;
              node.usedBytes = 0;
            } else {
              var oldContents = node.contents;
              node.contents = new Uint8Array(newSize);
              if (oldContents) {
                node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));
              }
              node.usedBytes = newSize;
            }
          },
          node_ops: {
            getattr(node) {
              var attr = {};
              attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
              attr.ino = node.id;
              attr.mode = node.mode;
              attr.nlink = 1;
              attr.uid = 0;
              attr.gid = 0;
              attr.rdev = node.rdev;
              if (FS.isDir(node.mode)) {
                attr.size = 4096;
              } else if (FS.isFile(node.mode)) {
                attr.size = node.usedBytes;
              } else if (FS.isLink(node.mode)) {
                attr.size = node.link.length;
              } else {
                attr.size = 0;
              }
              attr.atime = new Date(node.timestamp);
              attr.mtime = new Date(node.timestamp);
              attr.ctime = new Date(node.timestamp);
              attr.blksize = 4096;
              attr.blocks = Math.ceil(attr.size / attr.blksize);
              return attr;
            },
            setattr(node, attr) {
              if (attr.mode !== void 0) {
                node.mode = attr.mode;
              }
              if (attr.timestamp !== void 0) {
                node.timestamp = attr.timestamp;
              }
              if (attr.size !== void 0) {
                MEMFS.resizeFileStorage(node, attr.size);
              }
            },
            lookup(parent, name2) {
              throw FS.genericErrors[44];
            },
            mknod(parent, name2, mode, dev) {
              return MEMFS.createNode(parent, name2, mode, dev);
            },
            rename(old_node, new_dir, new_name) {
              if (FS.isDir(old_node.mode)) {
                var new_node;
                try {
                  new_node = FS.lookupNode(new_dir, new_name);
                } catch (e) {
                }
                if (new_node) {
                  for (var i2 in new_node.contents) {
                    throw new FS.ErrnoError(55);
                  }
                }
              }
              delete old_node.parent.contents[old_node.name];
              old_node.parent.timestamp = Date.now();
              old_node.name = new_name;
              new_dir.contents[new_name] = old_node;
              new_dir.timestamp = old_node.parent.timestamp;
              old_node.parent = new_dir;
            },
            unlink(parent, name2) {
              delete parent.contents[name2];
              parent.timestamp = Date.now();
            },
            rmdir(parent, name2) {
              var node = FS.lookupNode(parent, name2);
              for (var i2 in node.contents) {
                throw new FS.ErrnoError(55);
              }
              delete parent.contents[name2];
              parent.timestamp = Date.now();
            },
            readdir(node) {
              var entries = [".", ".."];
              for (var key of Object.keys(node.contents)) {
                entries.push(key);
              }
              return entries;
            },
            symlink(parent, newname, oldpath) {
              var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
              node.link = oldpath;
              return node;
            },
            readlink(node) {
              if (!FS.isLink(node.mode)) {
                throw new FS.ErrnoError(28);
              }
              return node.link;
            }
          },
          stream_ops: {
            read(stream, buffer, offset, length, position) {
              var contents = stream.node.contents;
              if (position >= stream.node.usedBytes)
                return 0;
              var size = Math.min(stream.node.usedBytes - position, length);
              if (size > 8 && contents.subarray) {
                buffer.set(contents.subarray(position, position + size), offset);
              } else {
                for (var i2 = 0; i2 < size; i2++)
                  buffer[offset + i2] = contents[position + i2];
              }
              return size;
            },
            write(stream, buffer, offset, length, position, canOwn) {
              if (buffer.buffer === HEAP8.buffer) {
                canOwn = false;
              }
              if (!length)
                return 0;
              var node = stream.node;
              node.timestamp = Date.now();
              if (buffer.subarray && (!node.contents || node.contents.subarray)) {
                if (canOwn) {
                  node.contents = buffer.subarray(offset, offset + length);
                  node.usedBytes = length;
                  return length;
                } else if (node.usedBytes === 0 && position === 0) {
                  node.contents = buffer.slice(offset, offset + length);
                  node.usedBytes = length;
                  return length;
                } else if (position + length <= node.usedBytes) {
                  node.contents.set(buffer.subarray(offset, offset + length), position);
                  return length;
                }
              }
              MEMFS.expandFileStorage(node, position + length);
              if (node.contents.subarray && buffer.subarray) {
                node.contents.set(buffer.subarray(offset, offset + length), position);
              } else {
                for (var i2 = 0; i2 < length; i2++) {
                  node.contents[position + i2] = buffer[offset + i2];
                }
              }
              node.usedBytes = Math.max(node.usedBytes, position + length);
              return length;
            },
            llseek(stream, offset, whence) {
              var position = offset;
              if (whence === 1) {
                position += stream.position;
              } else if (whence === 2) {
                if (FS.isFile(stream.node.mode)) {
                  position += stream.node.usedBytes;
                }
              }
              if (position < 0) {
                throw new FS.ErrnoError(28);
              }
              return position;
            },
            allocate(stream, offset, length) {
              MEMFS.expandFileStorage(stream.node, offset + length);
              stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
            },
            mmap(stream, length, position, prot, flags2) {
              if (!FS.isFile(stream.node.mode)) {
                throw new FS.ErrnoError(43);
              }
              var ptr2;
              var allocated;
              var contents = stream.node.contents;
              if (!(flags2 & 2) && contents.buffer === HEAP8.buffer) {
                allocated = false;
                ptr2 = contents.byteOffset;
              } else {
                if (position > 0 || position + length < contents.length) {
                  if (contents.subarray) {
                    contents = contents.subarray(position, position + length);
                  } else {
                    contents = Array.prototype.slice.call(contents, position, position + length);
                  }
                }
                allocated = true;
                ptr2 = mmapAlloc(length);
                if (!ptr2) {
                  throw new FS.ErrnoError(48);
                }
                HEAP8.set(contents, ptr2 >>> 0);
              }
              return {
                ptr: ptr2,
                allocated
              };
            },
            msync(stream, buffer, offset, length, mmapFlags) {
              MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);
              return 0;
            }
          }
        };
        var FS_createDataFile = (parent, name2, fileData, canRead, canWrite, canOwn) => {
          FS.createDataFile(parent, name2, fileData, canRead, canWrite, canOwn);
        };
        var FS_handledByPreloadPlugin = (byteArray, fullname, finish, onerror2) => {
          if (typeof Browser != "undefined")
            Browser.init();
          var handled = false;
          preloadPlugins.forEach((plugin) => {
            if (handled)
              return;
            if (plugin["canHandle"](fullname)) {
              plugin["handle"](byteArray, fullname, finish, onerror2);
              handled = true;
            }
          });
          return handled;
        };
        var FS_createPreloadedFile = (parent, name2, url2, canRead, canWrite, onload2, onerror2, dontCreateFile, canOwn, preFinish) => {
          var fullname = name2 ? PATH_FS.resolve(PATH.join2(parent, name2)) : parent;
          var dep = getUniqueRunDependency(`cp ${fullname}`);
          function processData(byteArray) {
            function finish(byteArray2) {
              preFinish == null ? void 0 : preFinish();
              if (!dontCreateFile) {
                FS_createDataFile(parent, name2, byteArray2, canRead, canWrite, canOwn);
              }
              onload2 == null ? void 0 : onload2();
              removeRunDependency(dep);
            }
            if (FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {
              onerror2 == null ? void 0 : onerror2();
              removeRunDependency(dep);
            })) {
              return;
            }
            finish(byteArray);
          }
          addRunDependency(dep);
          if (typeof url2 == "string") {
            asyncLoad(url2, processData, onerror2);
          } else {
            processData(url2);
          }
        };
        var FS_modeStringToFlags = (str) => {
          var flagModes = {
            "r": 0,
            "r+": 2,
            "w": 512 | 64 | 1,
            "w+": 512 | 64 | 2,
            "a": 1024 | 64 | 1,
            "a+": 1024 | 64 | 2
          };
          var flags2 = flagModes[str];
          if (typeof flags2 == "undefined") {
            throw new Error(`Unknown file open mode: ${str}`);
          }
          return flags2;
        };
        var FS_getMode = (canRead, canWrite) => {
          var mode = 0;
          if (canRead)
            mode |= 292 | 73;
          if (canWrite)
            mode |= 146;
          return mode;
        };
        var FS = {
          root: null,
          mounts: [],
          devices: {},
          streams: [],
          nextInode: 1,
          nameTable: null,
          currentPath: "/",
          initialized: false,
          ignorePermissions: true,
          ErrnoError: null,
          genericErrors: {},
          filesystems: null,
          syncFSRequests: 0,
          lookupPath(path2, opts = {}) {
            path2 = PATH_FS.resolve(path2);
            if (!path2)
              return {
                path: "",
                node: null
              };
            var defaults = {
              follow_mount: true,
              recurse_count: 0
            };
            opts = Object.assign(defaults, opts);
            if (opts.recurse_count > 8) {
              throw new FS.ErrnoError(32);
            }
            var parts2 = path2.split("/").filter((p) => !!p);
            var current = FS.root;
            var current_path = "/";
            for (var i2 = 0; i2 < parts2.length; i2++) {
              var islast = i2 === parts2.length - 1;
              if (islast && opts.parent) {
                break;
              }
              current = FS.lookupNode(current, parts2[i2]);
              current_path = PATH.join2(current_path, parts2[i2]);
              if (FS.isMountpoint(current)) {
                if (!islast || islast && opts.follow_mount) {
                  current = current.mounted.root;
                }
              }
              if (!islast || opts.follow) {
                var count = 0;
                while (FS.isLink(current.mode)) {
                  var link = FS.readlink(current_path);
                  current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
                  var lookup = FS.lookupPath(current_path, {
                    recurse_count: opts.recurse_count + 1
                  });
                  current = lookup.node;
                  if (count++ > 40) {
                    throw new FS.ErrnoError(32);
                  }
                }
              }
            }
            return {
              path: current_path,
              node: current
            };
          },
          getPath(node) {
            var path2;
            while (true) {
              if (FS.isRoot(node)) {
                var mount = node.mount.mountpoint;
                if (!path2)
                  return mount;
                return mount[mount.length - 1] !== "/" ? `${mount}/${path2}` : mount + path2;
              }
              path2 = path2 ? `${node.name}/${path2}` : node.name;
              node = node.parent;
            }
          },
          hashName(parentid, name2) {
            var hash = 0;
            for (var i2 = 0; i2 < name2.length; i2++) {
              hash = (hash << 5) - hash + name2.charCodeAt(i2) | 0;
            }
            return (parentid + hash >>> 0) % FS.nameTable.length;
          },
          hashAddNode(node) {
            var hash = FS.hashName(node.parent.id, node.name);
            node.name_next = FS.nameTable[hash];
            FS.nameTable[hash] = node;
          },
          hashRemoveNode(node) {
            var hash = FS.hashName(node.parent.id, node.name);
            if (FS.nameTable[hash] === node) {
              FS.nameTable[hash] = node.name_next;
            } else {
              var current = FS.nameTable[hash];
              while (current) {
                if (current.name_next === node) {
                  current.name_next = node.name_next;
                  break;
                }
                current = current.name_next;
              }
            }
          },
          lookupNode(parent, name2) {
            var errCode = FS.mayLookup(parent);
            if (errCode) {
              throw new FS.ErrnoError(errCode, parent);
            }
            var hash = FS.hashName(parent.id, name2);
            for (var node = FS.nameTable[hash]; node; node = node.name_next) {
              var nodeName = node.name;
              if (node.parent.id === parent.id && nodeName === name2) {
                return node;
              }
            }
            return FS.lookup(parent, name2);
          },
          createNode(parent, name2, mode, rdev) {
            var node = new FS.FSNode(parent, name2, mode, rdev);
            FS.hashAddNode(node);
            return node;
          },
          destroyNode(node) {
            FS.hashRemoveNode(node);
          },
          isRoot(node) {
            return node === node.parent;
          },
          isMountpoint(node) {
            return !!node.mounted;
          },
          isFile(mode) {
            return (mode & 61440) === 32768;
          },
          isDir(mode) {
            return (mode & 61440) === 16384;
          },
          isLink(mode) {
            return (mode & 61440) === 40960;
          },
          isChrdev(mode) {
            return (mode & 61440) === 8192;
          },
          isBlkdev(mode) {
            return (mode & 61440) === 24576;
          },
          isFIFO(mode) {
            return (mode & 61440) === 4096;
          },
          isSocket(mode) {
            return (mode & 49152) === 49152;
          },
          flagsToPermissionString(flag) {
            var perms = ["r", "w", "rw"][flag & 3];
            if (flag & 512) {
              perms += "w";
            }
            return perms;
          },
          nodePermissions(node, perms) {
            if (FS.ignorePermissions) {
              return 0;
            }
            if (perms.includes("r") && !(node.mode & 292)) {
              return 2;
            } else if (perms.includes("w") && !(node.mode & 146)) {
              return 2;
            } else if (perms.includes("x") && !(node.mode & 73)) {
              return 2;
            }
            return 0;
          },
          mayLookup(dir) {
            var errCode = FS.nodePermissions(dir, "x");
            if (errCode)
              return errCode;
            if (!dir.node_ops.lookup)
              return 2;
            return 0;
          },
          mayCreate(dir, name2) {
            try {
              var node = FS.lookupNode(dir, name2);
              return 20;
            } catch (e) {
            }
            return FS.nodePermissions(dir, "wx");
          },
          mayDelete(dir, name2, isdir) {
            var node;
            try {
              node = FS.lookupNode(dir, name2);
            } catch (e) {
              return e.errno;
            }
            var errCode = FS.nodePermissions(dir, "wx");
            if (errCode) {
              return errCode;
            }
            if (isdir) {
              if (!FS.isDir(node.mode)) {
                return 54;
              }
              if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
                return 10;
              }
            } else {
              if (FS.isDir(node.mode)) {
                return 31;
              }
            }
            return 0;
          },
          mayOpen(node, flags2) {
            if (!node) {
              return 44;
            }
            if (FS.isLink(node.mode)) {
              return 32;
            } else if (FS.isDir(node.mode)) {
              if (FS.flagsToPermissionString(flags2) !== "r" || flags2 & 512) {
                return 31;
              }
            }
            return FS.nodePermissions(node, FS.flagsToPermissionString(flags2));
          },
          MAX_OPEN_FDS: 4096,
          nextfd() {
            for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {
              if (!FS.streams[fd]) {
                return fd;
              }
            }
            throw new FS.ErrnoError(33);
          },
          getStreamChecked(fd) {
            var stream = FS.getStream(fd);
            if (!stream) {
              throw new FS.ErrnoError(8);
            }
            return stream;
          },
          getStream: (fd) => FS.streams[fd],
          createStream(stream, fd = -1) {
            if (!FS.FSStream) {
              FS.FSStream = function() {
                this.shared = {};
              };
              FS.FSStream.prototype = {};
              Object.defineProperties(FS.FSStream.prototype, {
                object: {
                  get() {
                    return this.node;
                  },
                  set(val) {
                    this.node = val;
                  }
                },
                isRead: {
                  get() {
                    return (this.flags & 2097155) !== 1;
                  }
                },
                isWrite: {
                  get() {
                    return (this.flags & 2097155) !== 0;
                  }
                },
                isAppend: {
                  get() {
                    return this.flags & 1024;
                  }
                },
                flags: {
                  get() {
                    return this.shared.flags;
                  },
                  set(val) {
                    this.shared.flags = val;
                  }
                },
                position: {
                  get() {
                    return this.shared.position;
                  },
                  set(val) {
                    this.shared.position = val;
                  }
                }
              });
            }
            stream = Object.assign(new FS.FSStream(), stream);
            if (fd == -1) {
              fd = FS.nextfd();
            }
            stream.fd = fd;
            FS.streams[fd] = stream;
            return stream;
          },
          closeStream(fd) {
            FS.streams[fd] = null;
          },
          chrdev_stream_ops: {
            open(stream) {
              var _a, _b;
              var device = FS.getDevice(stream.node.rdev);
              stream.stream_ops = device.stream_ops;
              (_b = (_a = stream.stream_ops).open) == null ? void 0 : _b.call(_a, stream);
            },
            llseek() {
              throw new FS.ErrnoError(70);
            }
          },
          major: (dev) => dev >> 8,
          minor: (dev) => dev & 255,
          makedev: (ma, mi) => ma << 8 | mi,
          registerDevice(dev, ops) {
            FS.devices[dev] = {
              stream_ops: ops
            };
          },
          getDevice: (dev) => FS.devices[dev],
          getMounts(mount) {
            var mounts = [];
            var check = [mount];
            while (check.length) {
              var m = check.pop();
              mounts.push(m);
              check.push.apply(check, m.mounts);
            }
            return mounts;
          },
          syncfs(populate, callback) {
            if (typeof populate == "function") {
              callback = populate;
              populate = false;
            }
            FS.syncFSRequests++;
            if (FS.syncFSRequests > 1) {
              err(`warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`);
            }
            var mounts = FS.getMounts(FS.root.mount);
            var completed = 0;
            function doCallback(errCode) {
              FS.syncFSRequests--;
              return callback(errCode);
            }
            function done(errCode) {
              if (errCode) {
                if (!done.errored) {
                  done.errored = true;
                  return doCallback(errCode);
                }
                return;
              }
              if (++completed >= mounts.length) {
                doCallback(null);
              }
            }
            mounts.forEach((mount) => {
              if (!mount.type.syncfs) {
                return done(null);
              }
              mount.type.syncfs(mount, populate, done);
            });
          },
          mount(type, opts, mountpoint) {
            var root = mountpoint === "/";
            var pseudo = !mountpoint;
            var node;
            if (root && FS.root) {
              throw new FS.ErrnoError(10);
            } else if (!root && !pseudo) {
              var lookup = FS.lookupPath(mountpoint, {
                follow_mount: false
              });
              mountpoint = lookup.path;
              node = lookup.node;
              if (FS.isMountpoint(node)) {
                throw new FS.ErrnoError(10);
              }
              if (!FS.isDir(node.mode)) {
                throw new FS.ErrnoError(54);
              }
            }
            var mount = {
              type,
              opts,
              mountpoint,
              mounts: []
            };
            var mountRoot = type.mount(mount);
            mountRoot.mount = mount;
            mount.root = mountRoot;
            if (root) {
              FS.root = mountRoot;
            } else if (node) {
              node.mounted = mount;
              if (node.mount) {
                node.mount.mounts.push(mount);
              }
            }
            return mountRoot;
          },
          unmount(mountpoint) {
            var lookup = FS.lookupPath(mountpoint, {
              follow_mount: false
            });
            if (!FS.isMountpoint(lookup.node)) {
              throw new FS.ErrnoError(28);
            }
            var node = lookup.node;
            var mount = node.mounted;
            var mounts = FS.getMounts(mount);
            Object.keys(FS.nameTable).forEach((hash) => {
              var current = FS.nameTable[hash];
              while (current) {
                var next = current.name_next;
                if (mounts.includes(current.mount)) {
                  FS.destroyNode(current);
                }
                current = next;
              }
            });
            node.mounted = null;
            var idx = node.mount.mounts.indexOf(mount);
            node.mount.mounts.splice(idx, 1);
          },
          lookup(parent, name2) {
            return parent.node_ops.lookup(parent, name2);
          },
          mknod(path2, mode, dev) {
            var lookup = FS.lookupPath(path2, {
              parent: true
            });
            var parent = lookup.node;
            var name2 = PATH.basename(path2);
            if (!name2 || name2 === "." || name2 === "..") {
              throw new FS.ErrnoError(28);
            }
            var errCode = FS.mayCreate(parent, name2);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            if (!parent.node_ops.mknod) {
              throw new FS.ErrnoError(63);
            }
            return parent.node_ops.mknod(parent, name2, mode, dev);
          },
          create(path2, mode) {
            mode = mode !== void 0 ? mode : 438;
            mode &= 4095;
            mode |= 32768;
            return FS.mknod(path2, mode, 0);
          },
          mkdir(path2, mode) {
            mode = mode !== void 0 ? mode : 511;
            mode &= 511 | 512;
            mode |= 16384;
            return FS.mknod(path2, mode, 0);
          },
          mkdirTree(path2, mode) {
            var dirs = path2.split("/");
            var d = "";
            for (var i2 = 0; i2 < dirs.length; ++i2) {
              if (!dirs[i2])
                continue;
              d += "/" + dirs[i2];
              try {
                FS.mkdir(d, mode);
              } catch (e) {
                if (e.errno != 20)
                  throw e;
              }
            }
          },
          mkdev(path2, mode, dev) {
            if (typeof dev == "undefined") {
              dev = mode;
              mode = 438;
            }
            mode |= 8192;
            return FS.mknod(path2, mode, dev);
          },
          symlink(oldpath, newpath) {
            if (!PATH_FS.resolve(oldpath)) {
              throw new FS.ErrnoError(44);
            }
            var lookup = FS.lookupPath(newpath, {
              parent: true
            });
            var parent = lookup.node;
            if (!parent) {
              throw new FS.ErrnoError(44);
            }
            var newname = PATH.basename(newpath);
            var errCode = FS.mayCreate(parent, newname);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            if (!parent.node_ops.symlink) {
              throw new FS.ErrnoError(63);
            }
            return parent.node_ops.symlink(parent, newname, oldpath);
          },
          rename(old_path, new_path) {
            var old_dirname = PATH.dirname(old_path);
            var new_dirname = PATH.dirname(new_path);
            var old_name = PATH.basename(old_path);
            var new_name = PATH.basename(new_path);
            var lookup, old_dir, new_dir;
            lookup = FS.lookupPath(old_path, {
              parent: true
            });
            old_dir = lookup.node;
            lookup = FS.lookupPath(new_path, {
              parent: true
            });
            new_dir = lookup.node;
            if (!old_dir || !new_dir)
              throw new FS.ErrnoError(44);
            if (old_dir.mount !== new_dir.mount) {
              throw new FS.ErrnoError(75);
            }
            var old_node = FS.lookupNode(old_dir, old_name);
            var relative = PATH_FS.relative(old_path, new_dirname);
            if (relative.charAt(0) !== ".") {
              throw new FS.ErrnoError(28);
            }
            relative = PATH_FS.relative(new_path, old_dirname);
            if (relative.charAt(0) !== ".") {
              throw new FS.ErrnoError(55);
            }
            var new_node;
            try {
              new_node = FS.lookupNode(new_dir, new_name);
            } catch (e) {
            }
            if (old_node === new_node) {
              return;
            }
            var isdir = FS.isDir(old_node.mode);
            var errCode = FS.mayDelete(old_dir, old_name, isdir);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            if (!old_dir.node_ops.rename) {
              throw new FS.ErrnoError(63);
            }
            if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
              throw new FS.ErrnoError(10);
            }
            if (new_dir !== old_dir) {
              errCode = FS.nodePermissions(old_dir, "w");
              if (errCode) {
                throw new FS.ErrnoError(errCode);
              }
            }
            FS.hashRemoveNode(old_node);
            try {
              old_dir.node_ops.rename(old_node, new_dir, new_name);
            } catch (e) {
              throw e;
            } finally {
              FS.hashAddNode(old_node);
            }
          },
          rmdir(path2) {
            var lookup = FS.lookupPath(path2, {
              parent: true
            });
            var parent = lookup.node;
            var name2 = PATH.basename(path2);
            var node = FS.lookupNode(parent, name2);
            var errCode = FS.mayDelete(parent, name2, true);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            if (!parent.node_ops.rmdir) {
              throw new FS.ErrnoError(63);
            }
            if (FS.isMountpoint(node)) {
              throw new FS.ErrnoError(10);
            }
            parent.node_ops.rmdir(parent, name2);
            FS.destroyNode(node);
          },
          readdir(path2) {
            var lookup = FS.lookupPath(path2, {
              follow: true
            });
            var node = lookup.node;
            if (!node.node_ops.readdir) {
              throw new FS.ErrnoError(54);
            }
            return node.node_ops.readdir(node);
          },
          unlink(path2) {
            var lookup = FS.lookupPath(path2, {
              parent: true
            });
            var parent = lookup.node;
            if (!parent) {
              throw new FS.ErrnoError(44);
            }
            var name2 = PATH.basename(path2);
            var node = FS.lookupNode(parent, name2);
            var errCode = FS.mayDelete(parent, name2, false);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            if (!parent.node_ops.unlink) {
              throw new FS.ErrnoError(63);
            }
            if (FS.isMountpoint(node)) {
              throw new FS.ErrnoError(10);
            }
            parent.node_ops.unlink(parent, name2);
            FS.destroyNode(node);
          },
          readlink(path2) {
            var lookup = FS.lookupPath(path2);
            var link = lookup.node;
            if (!link) {
              throw new FS.ErrnoError(44);
            }
            if (!link.node_ops.readlink) {
              throw new FS.ErrnoError(28);
            }
            return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
          },
          stat(path2, dontFollow) {
            var lookup = FS.lookupPath(path2, {
              follow: !dontFollow
            });
            var node = lookup.node;
            if (!node) {
              throw new FS.ErrnoError(44);
            }
            if (!node.node_ops.getattr) {
              throw new FS.ErrnoError(63);
            }
            return node.node_ops.getattr(node);
          },
          lstat(path2) {
            return FS.stat(path2, true);
          },
          chmod(path2, mode, dontFollow) {
            var node;
            if (typeof path2 == "string") {
              var lookup = FS.lookupPath(path2, {
                follow: !dontFollow
              });
              node = lookup.node;
            } else {
              node = path2;
            }
            if (!node.node_ops.setattr) {
              throw new FS.ErrnoError(63);
            }
            node.node_ops.setattr(node, {
              mode: mode & 4095 | node.mode & ~4095,
              timestamp: Date.now()
            });
          },
          lchmod(path2, mode) {
            FS.chmod(path2, mode, true);
          },
          fchmod(fd, mode) {
            var stream = FS.getStreamChecked(fd);
            FS.chmod(stream.node, mode);
          },
          chown(path2, uid, gid, dontFollow) {
            var node;
            if (typeof path2 == "string") {
              var lookup = FS.lookupPath(path2, {
                follow: !dontFollow
              });
              node = lookup.node;
            } else {
              node = path2;
            }
            if (!node.node_ops.setattr) {
              throw new FS.ErrnoError(63);
            }
            node.node_ops.setattr(node, {
              timestamp: Date.now()
            });
          },
          lchown(path2, uid, gid) {
            FS.chown(path2, uid, gid, true);
          },
          fchown(fd, uid, gid) {
            var stream = FS.getStreamChecked(fd);
            FS.chown(stream.node, uid, gid);
          },
          truncate(path2, len2) {
            if (len2 < 0) {
              throw new FS.ErrnoError(28);
            }
            var node;
            if (typeof path2 == "string") {
              var lookup = FS.lookupPath(path2, {
                follow: true
              });
              node = lookup.node;
            } else {
              node = path2;
            }
            if (!node.node_ops.setattr) {
              throw new FS.ErrnoError(63);
            }
            if (FS.isDir(node.mode)) {
              throw new FS.ErrnoError(31);
            }
            if (!FS.isFile(node.mode)) {
              throw new FS.ErrnoError(28);
            }
            var errCode = FS.nodePermissions(node, "w");
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            node.node_ops.setattr(node, {
              size: len2,
              timestamp: Date.now()
            });
          },
          ftruncate(fd, len2) {
            var stream = FS.getStreamChecked(fd);
            if ((stream.flags & 2097155) === 0) {
              throw new FS.ErrnoError(28);
            }
            FS.truncate(stream.node, len2);
          },
          utime(path2, atime, mtime) {
            var lookup = FS.lookupPath(path2, {
              follow: true
            });
            var node = lookup.node;
            node.node_ops.setattr(node, {
              timestamp: Math.max(atime, mtime)
            });
          },
          open(path2, flags2, mode) {
            if (path2 === "") {
              throw new FS.ErrnoError(44);
            }
            flags2 = typeof flags2 == "string" ? FS_modeStringToFlags(flags2) : flags2;
            mode = typeof mode == "undefined" ? 438 : mode;
            if (flags2 & 64) {
              mode = mode & 4095 | 32768;
            } else {
              mode = 0;
            }
            var node;
            if (typeof path2 == "object") {
              node = path2;
            } else {
              path2 = PATH.normalize(path2);
              try {
                var lookup = FS.lookupPath(path2, {
                  follow: !(flags2 & 131072)
                });
                node = lookup.node;
              } catch (e) {
              }
            }
            var created = false;
            if (flags2 & 64) {
              if (node) {
                if (flags2 & 128) {
                  throw new FS.ErrnoError(20);
                }
              } else {
                node = FS.mknod(path2, mode, 0);
                created = true;
              }
            }
            if (!node) {
              throw new FS.ErrnoError(44);
            }
            if (FS.isChrdev(node.mode)) {
              flags2 &= ~512;
            }
            if (flags2 & 65536 && !FS.isDir(node.mode)) {
              throw new FS.ErrnoError(54);
            }
            if (!created) {
              var errCode = FS.mayOpen(node, flags2);
              if (errCode) {
                throw new FS.ErrnoError(errCode);
              }
            }
            if (flags2 & 512 && !created) {
              FS.truncate(node, 0);
            }
            flags2 &= ~(128 | 512 | 131072);
            var stream = FS.createStream({
              node,
              path: FS.getPath(node),
              flags: flags2,
              seekable: true,
              position: 0,
              stream_ops: node.stream_ops,
              ungotten: [],
              error: false
            });
            if (stream.stream_ops.open) {
              stream.stream_ops.open(stream);
            }
            if (Module["logReadFiles"] && !(flags2 & 1)) {
              if (!FS.readFiles)
                FS.readFiles = {};
              if (!(path2 in FS.readFiles)) {
                FS.readFiles[path2] = 1;
              }
            }
            return stream;
          },
          close(stream) {
            if (FS.isClosed(stream)) {
              throw new FS.ErrnoError(8);
            }
            if (stream.getdents)
              stream.getdents = null;
            try {
              if (stream.stream_ops.close) {
                stream.stream_ops.close(stream);
              }
            } catch (e) {
              throw e;
            } finally {
              FS.closeStream(stream.fd);
            }
            stream.fd = null;
          },
          isClosed(stream) {
            return stream.fd === null;
          },
          llseek(stream, offset, whence) {
            if (FS.isClosed(stream)) {
              throw new FS.ErrnoError(8);
            }
            if (!stream.seekable || !stream.stream_ops.llseek) {
              throw new FS.ErrnoError(70);
            }
            if (whence != 0 && whence != 1 && whence != 2) {
              throw new FS.ErrnoError(28);
            }
            stream.position = stream.stream_ops.llseek(stream, offset, whence);
            stream.ungotten = [];
            return stream.position;
          },
          read(stream, buffer, offset, length, position) {
            if (length < 0 || position < 0) {
              throw new FS.ErrnoError(28);
            }
            if (FS.isClosed(stream)) {
              throw new FS.ErrnoError(8);
            }
            if ((stream.flags & 2097155) === 1) {
              throw new FS.ErrnoError(8);
            }
            if (FS.isDir(stream.node.mode)) {
              throw new FS.ErrnoError(31);
            }
            if (!stream.stream_ops.read) {
              throw new FS.ErrnoError(28);
            }
            var seeking = typeof position != "undefined";
            if (!seeking) {
              position = stream.position;
            } else if (!stream.seekable) {
              throw new FS.ErrnoError(70);
            }
            var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
            if (!seeking)
              stream.position += bytesRead;
            return bytesRead;
          },
          write(stream, buffer, offset, length, position, canOwn) {
            if (length < 0 || position < 0) {
              throw new FS.ErrnoError(28);
            }
            if (FS.isClosed(stream)) {
              throw new FS.ErrnoError(8);
            }
            if ((stream.flags & 2097155) === 0) {
              throw new FS.ErrnoError(8);
            }
            if (FS.isDir(stream.node.mode)) {
              throw new FS.ErrnoError(31);
            }
            if (!stream.stream_ops.write) {
              throw new FS.ErrnoError(28);
            }
            if (stream.seekable && stream.flags & 1024) {
              FS.llseek(stream, 0, 2);
            }
            var seeking = typeof position != "undefined";
            if (!seeking) {
              position = stream.position;
            } else if (!stream.seekable) {
              throw new FS.ErrnoError(70);
            }
            var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
            if (!seeking)
              stream.position += bytesWritten;
            return bytesWritten;
          },
          allocate(stream, offset, length) {
            if (FS.isClosed(stream)) {
              throw new FS.ErrnoError(8);
            }
            if (offset < 0 || length <= 0) {
              throw new FS.ErrnoError(28);
            }
            if ((stream.flags & 2097155) === 0) {
              throw new FS.ErrnoError(8);
            }
            if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
              throw new FS.ErrnoError(43);
            }
            if (!stream.stream_ops.allocate) {
              throw new FS.ErrnoError(138);
            }
            stream.stream_ops.allocate(stream, offset, length);
          },
          mmap(stream, length, position, prot, flags2) {
            if ((prot & 2) !== 0 && (flags2 & 2) === 0 && (stream.flags & 2097155) !== 2) {
              throw new FS.ErrnoError(2);
            }
            if ((stream.flags & 2097155) === 1) {
              throw new FS.ErrnoError(2);
            }
            if (!stream.stream_ops.mmap) {
              throw new FS.ErrnoError(43);
            }
            return stream.stream_ops.mmap(stream, length, position, prot, flags2);
          },
          msync(stream, buffer, offset, length, mmapFlags) {
            if (!stream.stream_ops.msync) {
              return 0;
            }
            return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);
          },
          munmap: (stream) => 0,
          ioctl(stream, cmd, arg) {
            if (!stream.stream_ops.ioctl) {
              throw new FS.ErrnoError(59);
            }
            return stream.stream_ops.ioctl(stream, cmd, arg);
          },
          readFile(path2, opts = {}) {
            opts.flags = opts.flags || 0;
            opts.encoding = opts.encoding || "binary";
            if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
              throw new Error(`Invalid encoding type "${opts.encoding}"`);
            }
            var ret;
            var stream = FS.open(path2, opts.flags);
            var stat = FS.stat(path2);
            var length = stat.size;
            var buf = new Uint8Array(length);
            FS.read(stream, buf, 0, length, 0);
            if (opts.encoding === "utf8") {
              ret = UTF8ArrayToString(buf, 0);
            } else if (opts.encoding === "binary") {
              ret = buf;
            }
            FS.close(stream);
            return ret;
          },
          writeFile(path2, data2, opts = {}) {
            opts.flags = opts.flags || 577;
            var stream = FS.open(path2, opts.flags, opts.mode);
            if (typeof data2 == "string") {
              var buf = new Uint8Array(lengthBytesUTF8(data2) + 1);
              var actualNumBytes = stringToUTF8Array(data2, buf, 0, buf.length);
              FS.write(stream, buf, 0, actualNumBytes, void 0, opts.canOwn);
            } else if (ArrayBuffer.isView(data2)) {
              FS.write(stream, data2, 0, data2.byteLength, void 0, opts.canOwn);
            } else {
              throw new Error("Unsupported data type");
            }
            FS.close(stream);
          },
          cwd: () => FS.currentPath,
          chdir(path2) {
            var lookup = FS.lookupPath(path2, {
              follow: true
            });
            if (lookup.node === null) {
              throw new FS.ErrnoError(44);
            }
            if (!FS.isDir(lookup.node.mode)) {
              throw new FS.ErrnoError(54);
            }
            var errCode = FS.nodePermissions(lookup.node, "x");
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            FS.currentPath = lookup.path;
          },
          createDefaultDirectories() {
            FS.mkdir("/tmp");
            FS.mkdir("/home");
            FS.mkdir("/home/web_user");
          },
          createDefaultDevices() {
            FS.mkdir("/dev");
            FS.registerDevice(FS.makedev(1, 3), {
              read: () => 0,
              write: (stream, buffer, offset, length, pos) => length
            });
            FS.mkdev("/dev/null", FS.makedev(1, 3));
            TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
            TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
            FS.mkdev("/dev/tty", FS.makedev(5, 0));
            FS.mkdev("/dev/tty1", FS.makedev(6, 0));
            var randomBuffer = new Uint8Array(1024), randomLeft = 0;
            var randomByte = () => {
              if (randomLeft === 0) {
                randomLeft = randomFill(randomBuffer).byteLength;
              }
              return randomBuffer[--randomLeft];
            };
            FS.createDevice("/dev", "random", randomByte);
            FS.createDevice("/dev", "urandom", randomByte);
            FS.mkdir("/dev/shm");
            FS.mkdir("/dev/shm/tmp");
          },
          createSpecialDirectories() {
            FS.mkdir("/proc");
            var proc_self = FS.mkdir("/proc/self");
            FS.mkdir("/proc/self/fd");
            FS.mount({
              mount() {
                var node = FS.createNode(proc_self, "fd", 16384 | 511, 73);
                node.node_ops = {
                  lookup(parent, name2) {
                    var fd = +name2;
                    var stream = FS.getStreamChecked(fd);
                    var ret = {
                      parent: null,
                      mount: {
                        mountpoint: "fake"
                      },
                      node_ops: {
                        readlink: () => stream.path
                      }
                    };
                    ret.parent = ret;
                    return ret;
                  }
                };
                return node;
              }
            }, {}, "/proc/self/fd");
          },
          createStandardStreams() {
            if (Module["stdin"]) {
              FS.createDevice("/dev", "stdin", Module["stdin"]);
            } else {
              FS.symlink("/dev/tty", "/dev/stdin");
            }
            if (Module["stdout"]) {
              FS.createDevice("/dev", "stdout", null, Module["stdout"]);
            } else {
              FS.symlink("/dev/tty", "/dev/stdout");
            }
            if (Module["stderr"]) {
              FS.createDevice("/dev", "stderr", null, Module["stderr"]);
            } else {
              FS.symlink("/dev/tty1", "/dev/stderr");
            }
            var stdin = FS.open("/dev/stdin", 0);
            var stdout = FS.open("/dev/stdout", 1);
            var stderr = FS.open("/dev/stderr", 1);
          },
          ensureErrnoError() {
            if (FS.ErrnoError)
              return;
            FS.ErrnoError = function ErrnoError(errno, node) {
              this.name = "ErrnoError";
              this.node = node;
              this.setErrno = function(errno2) {
                this.errno = errno2;
              };
              this.setErrno(errno);
              this.message = "FS error";
            };
            FS.ErrnoError.prototype = new Error();
            FS.ErrnoError.prototype.constructor = FS.ErrnoError;
            [44].forEach((code) => {
              FS.genericErrors[code] = new FS.ErrnoError(code);
              FS.genericErrors[code].stack = "<generic error, no stack>";
            });
          },
          staticInit() {
            FS.ensureErrnoError();
            FS.nameTable = new Array(4096);
            FS.mount(MEMFS, {}, "/");
            FS.createDefaultDirectories();
            FS.createDefaultDevices();
            FS.createSpecialDirectories();
            FS.filesystems = {
              "MEMFS": MEMFS
            };
          },
          init(input, output, error) {
            FS.init.initialized = true;
            FS.ensureErrnoError();
            Module["stdin"] = input || Module["stdin"];
            Module["stdout"] = output || Module["stdout"];
            Module["stderr"] = error || Module["stderr"];
            FS.createStandardStreams();
          },
          quit() {
            FS.init.initialized = false;
            _fflush(0);
            for (var i2 = 0; i2 < FS.streams.length; i2++) {
              var stream = FS.streams[i2];
              if (!stream) {
                continue;
              }
              FS.close(stream);
            }
          },
          findObject(path2, dontResolveLastLink) {
            var ret = FS.analyzePath(path2, dontResolveLastLink);
            if (!ret.exists) {
              return null;
            }
            return ret.object;
          },
          analyzePath(path2, dontResolveLastLink) {
            try {
              var lookup = FS.lookupPath(path2, {
                follow: !dontResolveLastLink
              });
              path2 = lookup.path;
            } catch (e) {
            }
            var ret = {
              isRoot: false,
              exists: false,
              error: 0,
              name: null,
              path: null,
              object: null,
              parentExists: false,
              parentPath: null,
              parentObject: null
            };
            try {
              var lookup = FS.lookupPath(path2, {
                parent: true
              });
              ret.parentExists = true;
              ret.parentPath = lookup.path;
              ret.parentObject = lookup.node;
              ret.name = PATH.basename(path2);
              lookup = FS.lookupPath(path2, {
                follow: !dontResolveLastLink
              });
              ret.exists = true;
              ret.path = lookup.path;
              ret.object = lookup.node;
              ret.name = lookup.node.name;
              ret.isRoot = lookup.path === "/";
            } catch (e) {
              ret.error = e.errno;
            }
            return ret;
          },
          createPath(parent, path2, canRead, canWrite) {
            parent = typeof parent == "string" ? parent : FS.getPath(parent);
            var parts2 = path2.split("/").reverse();
            while (parts2.length) {
              var part = parts2.pop();
              if (!part)
                continue;
              var current = PATH.join2(parent, part);
              try {
                FS.mkdir(current);
              } catch (e) {
              }
              parent = current;
            }
            return current;
          },
          createFile(parent, name2, properties, canRead, canWrite) {
            var path2 = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name2);
            var mode = FS_getMode(canRead, canWrite);
            return FS.create(path2, mode);
          },
          createDataFile(parent, name2, data2, canRead, canWrite, canOwn) {
            var path2 = name2;
            if (parent) {
              parent = typeof parent == "string" ? parent : FS.getPath(parent);
              path2 = name2 ? PATH.join2(parent, name2) : parent;
            }
            var mode = FS_getMode(canRead, canWrite);
            var node = FS.create(path2, mode);
            if (data2) {
              if (typeof data2 == "string") {
                var arr = new Array(data2.length);
                for (var i2 = 0, len2 = data2.length; i2 < len2; ++i2)
                  arr[i2] = data2.charCodeAt(i2);
                data2 = arr;
              }
              FS.chmod(node, mode | 146);
              var stream = FS.open(node, 577);
              FS.write(stream, data2, 0, data2.length, 0, canOwn);
              FS.close(stream);
              FS.chmod(node, mode);
            }
          },
          createDevice(parent, name2, input, output) {
            var path2 = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name2);
            var mode = FS_getMode(!!input, !!output);
            if (!FS.createDevice.major)
              FS.createDevice.major = 64;
            var dev = FS.makedev(FS.createDevice.major++, 0);
            FS.registerDevice(dev, {
              open(stream) {
                stream.seekable = false;
              },
              close(stream) {
                var _a;
                if ((_a = output == null ? void 0 : output.buffer) == null ? void 0 : _a.length) {
                  output(10);
                }
              },
              read(stream, buffer, offset, length, pos) {
                var bytesRead = 0;
                for (var i2 = 0; i2 < length; i2++) {
                  var result;
                  try {
                    result = input();
                  } catch (e) {
                    throw new FS.ErrnoError(29);
                  }
                  if (result === void 0 && bytesRead === 0) {
                    throw new FS.ErrnoError(6);
                  }
                  if (result === null || result === void 0)
                    break;
                  bytesRead++;
                  buffer[offset + i2] = result;
                }
                if (bytesRead) {
                  stream.node.timestamp = Date.now();
                }
                return bytesRead;
              },
              write(stream, buffer, offset, length, pos) {
                for (var i2 = 0; i2 < length; i2++) {
                  try {
                    output(buffer[offset + i2]);
                  } catch (e) {
                    throw new FS.ErrnoError(29);
                  }
                }
                if (length) {
                  stream.node.timestamp = Date.now();
                }
                return i2;
              }
            });
            return FS.mkdev(path2, mode, dev);
          },
          forceLoadFile(obj) {
            if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
              return true;
            if (typeof XMLHttpRequest != "undefined") {
              throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
            } else if (read_) {
              try {
                obj.contents = intArrayFromString(read_(obj.url), true);
                obj.usedBytes = obj.contents.length;
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
            } else {
              throw new Error("Cannot load without read() or XMLHttpRequest.");
            }
          },
          createLazyFile(parent, name2, url2, canRead, canWrite) {
            function LazyUint8Array() {
              this.lengthKnown = false;
              this.chunks = [];
            }
            LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {
              if (idx > this.length - 1 || idx < 0) {
                return void 0;
              }
              var chunkOffset = idx % this.chunkSize;
              var chunkNum = idx / this.chunkSize | 0;
              return this.getter(chunkNum)[chunkOffset];
            };
            LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
              this.getter = getter;
            };
            LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
              var xhr = new XMLHttpRequest();
              xhr.open("HEAD", url2, false);
              xhr.send(null);
              if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))
                throw new Error("Couldn't load " + url2 + ". Status: " + xhr.status);
              var datalength = Number(xhr.getResponseHeader("Content-length"));
              var header;
              var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
              var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
              var chunkSize = 1024 * 1024;
              if (!hasByteServing)
                chunkSize = datalength;
              var doXHR = (from, to) => {
                if (from > to)
                  throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
                if (to > datalength - 1)
                  throw new Error("only " + datalength + " bytes available! programmer error!");
                var xhr2 = new XMLHttpRequest();
                xhr2.open("GET", url2, false);
                if (datalength !== chunkSize)
                  xhr2.setRequestHeader("Range", "bytes=" + from + "-" + to);
                xhr2.responseType = "arraybuffer";
                if (xhr2.overrideMimeType) {
                  xhr2.overrideMimeType("text/plain; charset=x-user-defined");
                }
                xhr2.send(null);
                if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))
                  throw new Error("Couldn't load " + url2 + ". Status: " + xhr2.status);
                if (xhr2.response !== void 0) {
                  return new Uint8Array(xhr2.response || []);
                }
                return intArrayFromString(xhr2.responseText || "", true);
              };
              var lazyArray2 = this;
              lazyArray2.setDataGetter((chunkNum) => {
                var start2 = chunkNum * chunkSize;
                var end = (chunkNum + 1) * chunkSize - 1;
                end = Math.min(end, datalength - 1);
                if (typeof lazyArray2.chunks[chunkNum] == "undefined") {
                  lazyArray2.chunks[chunkNum] = doXHR(start2, end);
                }
                if (typeof lazyArray2.chunks[chunkNum] == "undefined")
                  throw new Error("doXHR failed!");
                return lazyArray2.chunks[chunkNum];
              });
              if (usesGzip || !datalength) {
                chunkSize = datalength = 1;
                datalength = this.getter(0).length;
                chunkSize = datalength;
                out("LazyFiles on gzip forces download of the whole file when length is accessed");
              }
              this._length = datalength;
              this._chunkSize = chunkSize;
              this.lengthKnown = true;
            };
            if (typeof XMLHttpRequest != "undefined") {
              if (!ENVIRONMENT_IS_WORKER)
                throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
              var lazyArray = new LazyUint8Array();
              Object.defineProperties(lazyArray, {
                length: {
                  get: function() {
                    if (!this.lengthKnown) {
                      this.cacheLength();
                    }
                    return this._length;
                  }
                },
                chunkSize: {
                  get: function() {
                    if (!this.lengthKnown) {
                      this.cacheLength();
                    }
                    return this._chunkSize;
                  }
                }
              });
              var properties = {
                isDevice: false,
                contents: lazyArray
              };
            } else {
              var properties = {
                isDevice: false,
                url: url2
              };
            }
            var node = FS.createFile(parent, name2, properties, canRead, canWrite);
            if (properties.contents) {
              node.contents = properties.contents;
            } else if (properties.url) {
              node.contents = null;
              node.url = properties.url;
            }
            Object.defineProperties(node, {
              usedBytes: {
                get: function() {
                  return this.contents.length;
                }
              }
            });
            var stream_ops = {};
            var keys = Object.keys(node.stream_ops);
            keys.forEach((key) => {
              var fn = node.stream_ops[key];
              stream_ops[key] = function forceLoadLazyFile() {
                FS.forceLoadFile(node);
                return fn.apply(null, arguments);
              };
            });
            function writeChunks(stream, buffer, offset, length, position) {
              var contents = stream.node.contents;
              if (position >= contents.length)
                return 0;
              var size = Math.min(contents.length - position, length);
              if (contents.slice) {
                for (var i2 = 0; i2 < size; i2++) {
                  buffer[offset + i2] = contents[position + i2];
                }
              } else {
                for (var i2 = 0; i2 < size; i2++) {
                  buffer[offset + i2] = contents.get(position + i2);
                }
              }
              return size;
            }
            stream_ops.read = (stream, buffer, offset, length, position) => {
              FS.forceLoadFile(node);
              return writeChunks(stream, buffer, offset, length, position);
            };
            stream_ops.mmap = (stream, length, position, prot, flags2) => {
              FS.forceLoadFile(node);
              var ptr2 = mmapAlloc(length);
              if (!ptr2) {
                throw new FS.ErrnoError(48);
              }
              writeChunks(stream, HEAP8, ptr2, length, position);
              return {
                ptr: ptr2,
                allocated: true
              };
            };
            node.stream_ops = stream_ops;
            return node;
          }
        };
        var SYSCALLS = {
          DEFAULT_POLLMASK: 5,
          calculateAt(dirfd, path2, allowEmpty) {
            if (PATH.isAbs(path2)) {
              return path2;
            }
            var dir;
            if (dirfd === -100) {
              dir = FS.cwd();
            } else {
              var dirstream = SYSCALLS.getStreamFromFD(dirfd);
              dir = dirstream.path;
            }
            if (path2.length == 0) {
              if (!allowEmpty) {
                throw new FS.ErrnoError(44);
              }
              return dir;
            }
            return PATH.join2(dir, path2);
          },
          doStat(func2, path2, buf) {
            try {
              var stat = func2(path2);
            } catch (e) {
              if (e && e.node && PATH.normalize(path2) !== PATH.normalize(FS.getPath(e.node))) {
                return -54;
              }
              throw e;
            }
            HEAP32[buf >>> 2 >>> 0] = stat.dev;
            HEAP32[buf + 4 >>> 2 >>> 0] = stat.mode;
            HEAPU32[buf + 8 >>> 2 >>> 0] = stat.nlink;
            HEAP32[buf + 12 >>> 2 >>> 0] = stat.uid;
            HEAP32[buf + 16 >>> 2 >>> 0] = stat.gid;
            HEAP32[buf + 20 >>> 2 >>> 0] = stat.rdev;
            tempI64 = [stat.size >>> 0, (tempDouble = stat.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 24 >>> 2 >>> 0] = tempI64[0], HEAP32[buf + 28 >>> 2 >>> 0] = tempI64[1];
            HEAP32[buf + 32 >>> 2 >>> 0] = 4096;
            HEAP32[buf + 36 >>> 2 >>> 0] = stat.blocks;
            var atime = stat.atime.getTime();
            var mtime = stat.mtime.getTime();
            var ctime = stat.ctime.getTime();
            tempI64 = [Math.floor(atime / 1e3) >>> 0, (tempDouble = Math.floor(atime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 40 >>> 2 >>> 0] = tempI64[0], HEAP32[buf + 44 >>> 2 >>> 0] = tempI64[1];
            HEAPU32[buf + 48 >>> 2 >>> 0] = atime % 1e3 * 1e3;
            tempI64 = [Math.floor(mtime / 1e3) >>> 0, (tempDouble = Math.floor(mtime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 56 >>> 2 >>> 0] = tempI64[0], HEAP32[buf + 60 >>> 2 >>> 0] = tempI64[1];
            HEAPU32[buf + 64 >>> 2 >>> 0] = mtime % 1e3 * 1e3;
            tempI64 = [Math.floor(ctime / 1e3) >>> 0, (tempDouble = Math.floor(ctime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 72 >>> 2 >>> 0] = tempI64[0], HEAP32[buf + 76 >>> 2 >>> 0] = tempI64[1];
            HEAPU32[buf + 80 >>> 2 >>> 0] = ctime % 1e3 * 1e3;
            tempI64 = [stat.ino >>> 0, (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 88 >>> 2 >>> 0] = tempI64[0], HEAP32[buf + 92 >>> 2 >>> 0] = tempI64[1];
            return 0;
          },
          doMsync(addr2, stream, len2, flags2, offset) {
            if (!FS.isFile(stream.node.mode)) {
              throw new FS.ErrnoError(43);
            }
            if (flags2 & 2) {
              return 0;
            }
            var buffer = HEAPU8.slice(addr2, addr2 + len2);
            FS.msync(stream, buffer, offset, len2, flags2);
          },
          varargs: void 0,
          get() {
            var ret = HEAP32[+SYSCALLS.varargs >>> 2 >>> 0];
            SYSCALLS.varargs += 4;
            return ret;
          },
          getp() {
            return SYSCALLS.get();
          },
          getStr(ptr2) {
            var ret = UTF8ToString(ptr2);
            return ret;
          },
          getStreamFromFD(fd) {
            var stream = FS.getStreamChecked(fd);
            return stream;
          }
        };
        function ___syscall__newselect(nfds, readfds, writefds, exceptfds, timeout) {
          readfds >>>= 0;
          writefds >>>= 0;
          exceptfds >>>= 0;
          timeout >>>= 0;
          try {
            var total = 0;
            var srcReadLow = readfds ? HEAP32[readfds >>> 2 >>> 0] : 0, srcReadHigh = readfds ? HEAP32[readfds + 4 >>> 2 >>> 0] : 0;
            var srcWriteLow = writefds ? HEAP32[writefds >>> 2 >>> 0] : 0, srcWriteHigh = writefds ? HEAP32[writefds + 4 >>> 2 >>> 0] : 0;
            var srcExceptLow = exceptfds ? HEAP32[exceptfds >>> 2 >>> 0] : 0, srcExceptHigh = exceptfds ? HEAP32[exceptfds + 4 >>> 2 >>> 0] : 0;
            var dstReadLow = 0, dstReadHigh = 0;
            var dstWriteLow = 0, dstWriteHigh = 0;
            var dstExceptLow = 0, dstExceptHigh = 0;
            var allLow = (readfds ? HEAP32[readfds >>> 2 >>> 0] : 0) | (writefds ? HEAP32[writefds >>> 2 >>> 0] : 0) | (exceptfds ? HEAP32[exceptfds >>> 2 >>> 0] : 0);
            var allHigh = (readfds ? HEAP32[readfds + 4 >>> 2 >>> 0] : 0) | (writefds ? HEAP32[writefds + 4 >>> 2 >>> 0] : 0) | (exceptfds ? HEAP32[exceptfds + 4 >>> 2 >>> 0] : 0);
            var check = function(fd2, low, high, val) {
              return fd2 < 32 ? low & val : high & val;
            };
            for (var fd = 0; fd < nfds; fd++) {
              var mask = 1 << fd % 32;
              if (!check(fd, allLow, allHigh, mask)) {
                continue;
              }
              var stream = SYSCALLS.getStreamFromFD(fd);
              var flags2 = SYSCALLS.DEFAULT_POLLMASK;
              if (stream.stream_ops.poll) {
                var timeoutInMillis = -1;
                if (timeout) {
                  var tv_sec = readfds ? HEAP32[timeout >>> 2 >>> 0] : 0, tv_usec = readfds ? HEAP32[timeout + 4 >>> 2 >>> 0] : 0;
                  timeoutInMillis = (tv_sec + tv_usec / 1e6) * 1e3;
                }
                flags2 = stream.stream_ops.poll(stream, timeoutInMillis);
              }
              if (flags2 & 1 && check(fd, srcReadLow, srcReadHigh, mask)) {
                fd < 32 ? dstReadLow = dstReadLow | mask : dstReadHigh = dstReadHigh | mask;
                total++;
              }
              if (flags2 & 4 && check(fd, srcWriteLow, srcWriteHigh, mask)) {
                fd < 32 ? dstWriteLow = dstWriteLow | mask : dstWriteHigh = dstWriteHigh | mask;
                total++;
              }
              if (flags2 & 2 && check(fd, srcExceptLow, srcExceptHigh, mask)) {
                fd < 32 ? dstExceptLow = dstExceptLow | mask : dstExceptHigh = dstExceptHigh | mask;
                total++;
              }
            }
            if (readfds) {
              HEAP32[readfds >>> 2 >>> 0] = dstReadLow;
              HEAP32[readfds + 4 >>> 2 >>> 0] = dstReadHigh;
            }
            if (writefds) {
              HEAP32[writefds >>> 2 >>> 0] = dstWriteLow;
              HEAP32[writefds + 4 >>> 2 >>> 0] = dstWriteHigh;
            }
            if (exceptfds) {
              HEAP32[exceptfds >>> 2 >>> 0] = dstExceptLow;
              HEAP32[exceptfds + 4 >>> 2 >>> 0] = dstExceptHigh;
            }
            return total;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall__newselect.sig = "iipppp";
        var SOCKFS = {
          mount(mount) {
            Module["websocket"] = Module["websocket"] && "object" === typeof Module["websocket"] ? Module["websocket"] : {};
            Module["websocket"]._callbacks = {};
            Module["websocket"]["on"] = function(event2, callback) {
              if ("function" === typeof callback) {
                this._callbacks[event2] = callback;
              }
              return this;
            };
            Module["websocket"].emit = function(event2, param) {
              if ("function" === typeof this._callbacks[event2]) {
                this._callbacks[event2].call(this, param);
              }
            };
            return FS.createNode(null, "/", 16384 | 511, 0);
          },
          createSocket(family, type, protocol) {
            type &= ~526336;
            var streaming = type == 1;
            if (streaming && protocol && protocol != 6) {
              throw new FS.ErrnoError(66);
            }
            var sock = {
              family,
              type,
              protocol,
              server: null,
              error: null,
              peers: {},
              pending: [],
              recv_queue: [],
              sock_ops: SOCKFS.websocket_sock_ops
            };
            var name2 = SOCKFS.nextname();
            var node = FS.createNode(SOCKFS.root, name2, 49152, 0);
            node.sock = sock;
            var stream = FS.createStream({
              path: name2,
              node,
              flags: 2,
              seekable: false,
              stream_ops: SOCKFS.stream_ops
            });
            sock.stream = stream;
            return sock;
          },
          getSocket(fd) {
            var stream = FS.getStream(fd);
            if (!stream || !FS.isSocket(stream.node.mode)) {
              return null;
            }
            return stream.node.sock;
          },
          stream_ops: {
            poll(stream) {
              var sock = stream.node.sock;
              return sock.sock_ops.poll(sock);
            },
            ioctl(stream, request, varargs) {
              var sock = stream.node.sock;
              return sock.sock_ops.ioctl(sock, request, varargs);
            },
            read(stream, buffer, offset, length, position) {
              var sock = stream.node.sock;
              var msg = sock.sock_ops.recvmsg(sock, length);
              if (!msg) {
                return 0;
              }
              buffer.set(msg.buffer, offset);
              return msg.buffer.length;
            },
            write(stream, buffer, offset, length, position) {
              var sock = stream.node.sock;
              return sock.sock_ops.sendmsg(sock, buffer, offset, length);
            },
            close(stream) {
              var sock = stream.node.sock;
              sock.sock_ops.close(sock);
            }
          },
          nextname() {
            if (!SOCKFS.nextname.current) {
              SOCKFS.nextname.current = 0;
            }
            return "socket[" + SOCKFS.nextname.current++ + "]";
          },
          websocket_sock_ops: {
            createPeer(sock, addr2, port) {
              var ws;
              if (typeof addr2 == "object") {
                ws = addr2;
                addr2 = null;
                port = null;
              }
              if (ws) {
                if (ws._socket) {
                  addr2 = ws._socket.remoteAddress;
                  port = ws._socket.remotePort;
                } else {
                  var result = /ws[s]?:\/\/([^:]+):(\d+)/.exec(ws.url);
                  if (!result) {
                    throw new Error("WebSocket URL must be in the format ws(s)://address:port");
                  }
                  addr2 = result[1];
                  port = parseInt(result[2], 10);
                }
              } else {
                try {
                  var runtimeConfig = Module["websocket"] && "object" === typeof Module["websocket"];
                  var url2 = "ws:#".replace("#", "//");
                  if (runtimeConfig) {
                    if ("string" === typeof Module["websocket"]["url"]) {
                      url2 = Module["websocket"]["url"];
                    }
                  }
                  if (url2 === "ws://" || url2 === "wss://") {
                    var parts2 = addr2.split("/");
                    url2 = url2 + parts2[0] + ":" + port + "/" + parts2.slice(1).join("/");
                  }
                  var subProtocols = "binary";
                  if (runtimeConfig) {
                    if ("string" === typeof Module["websocket"]["subprotocol"]) {
                      subProtocols = Module["websocket"]["subprotocol"];
                    }
                  }
                  var opts = void 0;
                  if (subProtocols !== "null") {
                    subProtocols = subProtocols.replace(/^ +| +$/g, "").split(/ *, */);
                    opts = subProtocols;
                  }
                  if (runtimeConfig && null === Module["websocket"]["subprotocol"]) {
                    subProtocols = "null";
                    opts = void 0;
                  }
                  var WebSocketConstructor;
                  if (ENVIRONMENT_IS_NODE) {
                    WebSocketConstructor = require_ws();
                  } else {
                    WebSocketConstructor = WebSocket;
                  }
                  ws = new WebSocketConstructor(url2, opts);
                  ws.binaryType = "arraybuffer";
                } catch (e) {
                  throw new FS.ErrnoError(23);
                }
              }
              var peer = {
                addr: addr2,
                port,
                socket: ws,
                dgram_send_queue: []
              };
              SOCKFS.websocket_sock_ops.addPeer(sock, peer);
              SOCKFS.websocket_sock_ops.handlePeerEvents(sock, peer);
              if (sock.type === 2 && typeof sock.sport != "undefined") {
                peer.dgram_send_queue.push(new Uint8Array([255, 255, 255, 255, "p".charCodeAt(0), "o".charCodeAt(0), "r".charCodeAt(0), "t".charCodeAt(0), (sock.sport & 65280) >> 8, sock.sport & 255]));
              }
              return peer;
            },
            getPeer(sock, addr2, port) {
              return sock.peers[addr2 + ":" + port];
            },
            addPeer(sock, peer) {
              sock.peers[peer.addr + ":" + peer.port] = peer;
            },
            removePeer(sock, peer) {
              delete sock.peers[peer.addr + ":" + peer.port];
            },
            handlePeerEvents(sock, peer) {
              var first = true;
              var handleOpen = function() {
                Module["websocket"].emit("open", sock.stream.fd);
                try {
                  var queued = peer.dgram_send_queue.shift();
                  while (queued) {
                    peer.socket.send(queued);
                    queued = peer.dgram_send_queue.shift();
                  }
                } catch (e) {
                  peer.socket.close();
                }
              };
              function handleMessage(data2) {
                if (typeof data2 == "string") {
                  var encoder3 = new TextEncoder();
                  data2 = encoder3.encode(data2);
                } else {
                  assert(data2.byteLength !== void 0);
                  if (data2.byteLength == 0) {
                    return;
                  }
                  data2 = new Uint8Array(data2);
                }
                var wasfirst = first;
                first = false;
                if (wasfirst && data2.length === 10 && data2[0] === 255 && data2[1] === 255 && data2[2] === 255 && data2[3] === 255 && data2[4] === "p".charCodeAt(0) && data2[5] === "o".charCodeAt(0) && data2[6] === "r".charCodeAt(0) && data2[7] === "t".charCodeAt(0)) {
                  var newport = data2[8] << 8 | data2[9];
                  SOCKFS.websocket_sock_ops.removePeer(sock, peer);
                  peer.port = newport;
                  SOCKFS.websocket_sock_ops.addPeer(sock, peer);
                  return;
                }
                sock.recv_queue.push({
                  addr: peer.addr,
                  port: peer.port,
                  data: data2
                });
                Module["websocket"].emit("message", sock.stream.fd);
              }
              if (ENVIRONMENT_IS_NODE) {
                peer.socket.on("open", handleOpen);
                peer.socket.on("message", function(data2, isBinary) {
                  if (!isBinary) {
                    return;
                  }
                  handleMessage(new Uint8Array(data2).buffer);
                });
                peer.socket.on("close", function() {
                  Module["websocket"].emit("close", sock.stream.fd);
                });
                peer.socket.on("error", function(error) {
                  sock.error = 14;
                  Module["websocket"].emit("error", [sock.stream.fd, sock.error, "ECONNREFUSED: Connection refused"]);
                });
              } else {
                peer.socket.onopen = handleOpen;
                peer.socket.onclose = function() {
                  Module["websocket"].emit("close", sock.stream.fd);
                };
                peer.socket.onmessage = function peer_socket_onmessage(event2) {
                  handleMessage(event2.data);
                };
                peer.socket.onerror = function(error) {
                  sock.error = 14;
                  Module["websocket"].emit("error", [sock.stream.fd, sock.error, "ECONNREFUSED: Connection refused"]);
                };
              }
            },
            poll(sock) {
              if (sock.type === 1 && sock.server) {
                return sock.pending.length ? 64 | 1 : 0;
              }
              var mask = 0;
              var dest = sock.type === 1 ? SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport) : null;
              if (sock.recv_queue.length || !dest || dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
                mask |= 64 | 1;
              }
              if (!dest || dest && dest.socket.readyState === dest.socket.OPEN) {
                mask |= 4;
              }
              if (dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
                mask |= 16;
              }
              return mask;
            },
            ioctl(sock, request, arg) {
              switch (request) {
                case 21531:
                  var bytes = 0;
                  if (sock.recv_queue.length) {
                    bytes = sock.recv_queue[0].data.length;
                  }
                  HEAP32[arg >>> 2 >>> 0] = bytes;
                  return 0;
                default:
                  return 28;
              }
            },
            close(sock) {
              if (sock.server) {
                try {
                  sock.server.close();
                } catch (e) {
                }
                sock.server = null;
              }
              var peers = Object.keys(sock.peers);
              for (var i2 = 0; i2 < peers.length; i2++) {
                var peer = sock.peers[peers[i2]];
                try {
                  peer.socket.close();
                } catch (e) {
                }
                SOCKFS.websocket_sock_ops.removePeer(sock, peer);
              }
              return 0;
            },
            bind(sock, addr2, port) {
              if (typeof sock.saddr != "undefined" || typeof sock.sport != "undefined") {
                throw new FS.ErrnoError(28);
              }
              sock.saddr = addr2;
              sock.sport = port;
              if (sock.type === 2) {
                if (sock.server) {
                  sock.server.close();
                  sock.server = null;
                }
                try {
                  sock.sock_ops.listen(sock, 0);
                } catch (e) {
                  if (!(e.name === "ErrnoError"))
                    throw e;
                  if (e.errno !== 138)
                    throw e;
                }
              }
            },
            connect(sock, addr2, port) {
              if (sock.server) {
                throw new FS.ErrnoError(138);
              }
              if (typeof sock.daddr != "undefined" && typeof sock.dport != "undefined") {
                var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
                if (dest) {
                  if (dest.socket.readyState === dest.socket.CONNECTING) {
                    throw new FS.ErrnoError(7);
                  } else {
                    throw new FS.ErrnoError(30);
                  }
                }
              }
              var peer = SOCKFS.websocket_sock_ops.createPeer(sock, addr2, port);
              sock.daddr = peer.addr;
              sock.dport = peer.port;
              throw new FS.ErrnoError(26);
            },
            listen(sock, backlog) {
              if (!ENVIRONMENT_IS_NODE) {
                throw new FS.ErrnoError(138);
              }
              if (sock.server) {
                throw new FS.ErrnoError(28);
              }
              var WebSocketServer = require_ws().Server;
              var host = sock.saddr;
              sock.server = new WebSocketServer({
                host,
                port: sock.sport
              });
              Module["websocket"].emit("listen", sock.stream.fd);
              sock.server.on("connection", function(ws) {
                if (sock.type === 1) {
                  var newsock = SOCKFS.createSocket(sock.family, sock.type, sock.protocol);
                  var peer = SOCKFS.websocket_sock_ops.createPeer(newsock, ws);
                  newsock.daddr = peer.addr;
                  newsock.dport = peer.port;
                  sock.pending.push(newsock);
                  Module["websocket"].emit("connection", newsock.stream.fd);
                } else {
                  SOCKFS.websocket_sock_ops.createPeer(sock, ws);
                  Module["websocket"].emit("connection", sock.stream.fd);
                }
              });
              sock.server.on("close", function() {
                Module["websocket"].emit("close", sock.stream.fd);
                sock.server = null;
              });
              sock.server.on("error", function(error) {
                sock.error = 23;
                Module["websocket"].emit("error", [sock.stream.fd, sock.error, "EHOSTUNREACH: Host is unreachable"]);
              });
            },
            accept(listensock) {
              if (!listensock.server || !listensock.pending.length) {
                throw new FS.ErrnoError(28);
              }
              var newsock = listensock.pending.shift();
              newsock.stream.flags = listensock.stream.flags;
              return newsock;
            },
            getname(sock, peer) {
              var addr2, port;
              if (peer) {
                if (sock.daddr === void 0 || sock.dport === void 0) {
                  throw new FS.ErrnoError(53);
                }
                addr2 = sock.daddr;
                port = sock.dport;
              } else {
                addr2 = sock.saddr || 0;
                port = sock.sport || 0;
              }
              return {
                addr: addr2,
                port
              };
            },
            sendmsg(sock, buffer, offset, length, addr2, port) {
              if (sock.type === 2) {
                if (addr2 === void 0 || port === void 0) {
                  addr2 = sock.daddr;
                  port = sock.dport;
                }
                if (addr2 === void 0 || port === void 0) {
                  throw new FS.ErrnoError(17);
                }
              } else {
                addr2 = sock.daddr;
                port = sock.dport;
              }
              var dest = SOCKFS.websocket_sock_ops.getPeer(sock, addr2, port);
              if (sock.type === 1) {
                if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
                  throw new FS.ErrnoError(53);
                } else if (dest.socket.readyState === dest.socket.CONNECTING) {
                  throw new FS.ErrnoError(6);
                }
              }
              if (ArrayBuffer.isView(buffer)) {
                offset += buffer.byteOffset;
                buffer = buffer.buffer;
              }
              var data2;
              data2 = buffer.slice(offset, offset + length);
              if (sock.type === 2) {
                if (!dest || dest.socket.readyState !== dest.socket.OPEN) {
                  if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
                    dest = SOCKFS.websocket_sock_ops.createPeer(sock, addr2, port);
                  }
                  dest.dgram_send_queue.push(data2);
                  return length;
                }
              }
              try {
                dest.socket.send(data2);
                return length;
              } catch (e) {
                throw new FS.ErrnoError(28);
              }
            },
            recvmsg(sock, length) {
              if (sock.type === 1 && sock.server) {
                throw new FS.ErrnoError(53);
              }
              var queued = sock.recv_queue.shift();
              if (!queued) {
                if (sock.type === 1) {
                  var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
                  if (!dest) {
                    throw new FS.ErrnoError(53);
                  }
                  if (dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
                    return null;
                  }
                  throw new FS.ErrnoError(6);
                }
                throw new FS.ErrnoError(6);
              }
              var queuedLength = queued.data.byteLength || queued.data.length;
              var queuedOffset = queued.data.byteOffset || 0;
              var queuedBuffer = queued.data.buffer || queued.data;
              var bytesRead = Math.min(length, queuedLength);
              var res = {
                buffer: new Uint8Array(queuedBuffer, queuedOffset, bytesRead),
                addr: queued.addr,
                port: queued.port
              };
              if (sock.type === 1 && bytesRead < queuedLength) {
                var bytesRemaining = queuedLength - bytesRead;
                queued.data = new Uint8Array(queuedBuffer, queuedOffset + bytesRead, bytesRemaining);
                sock.recv_queue.unshift(queued);
              }
              return res;
            }
          }
        };
        var getSocketFromFD = (fd) => {
          var socket = SOCKFS.getSocket(fd);
          if (!socket)
            throw new FS.ErrnoError(8);
          return socket;
        };
        var Sockets = {
          BUFFER_SIZE: 10240,
          MAX_BUFFER_SIZE: 10485760,
          nextFd: 1,
          fds: {},
          nextport: 1,
          maxport: 65535,
          peer: null,
          connections: {},
          portmap: {},
          localAddr: 4261412874,
          addrPool: [33554442, 50331658, 67108874, 83886090, 100663306, 117440522, 134217738, 150994954, 167772170, 184549386, 201326602, 218103818, 234881034]
        };
        var inetPton4 = (str) => {
          var b = str.split(".");
          for (var i2 = 0; i2 < 4; i2++) {
            var tmp = Number(b[i2]);
            if (isNaN(tmp))
              return null;
            b[i2] = tmp;
          }
          return (b[0] | b[1] << 8 | b[2] << 16 | b[3] << 24) >>> 0;
        };
        var jstoi_q = (str) => parseInt(str);
        var inetPton6 = (str) => {
          var words;
          var w, offset, z, i2;
          var valid6regx = /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i;
          var parts2 = [];
          if (!valid6regx.test(str)) {
            return null;
          }
          if (str === "::") {
            return [0, 0, 0, 0, 0, 0, 0, 0];
          }
          if (str.startsWith("::")) {
            str = str.replace("::", "Z:");
          } else {
            str = str.replace("::", ":Z:");
          }
          if (str.indexOf(".") > 0) {
            str = str.replace(new RegExp("[.]", "g"), ":");
            words = str.split(":");
            words[words.length - 4] = jstoi_q(words[words.length - 4]) + jstoi_q(words[words.length - 3]) * 256;
            words[words.length - 3] = jstoi_q(words[words.length - 2]) + jstoi_q(words[words.length - 1]) * 256;
            words = words.slice(0, words.length - 2);
          } else {
            words = str.split(":");
          }
          offset = 0;
          z = 0;
          for (w = 0; w < words.length; w++) {
            if (typeof words[w] == "string") {
              if (words[w] === "Z") {
                for (z = 0; z < 8 - words.length + 1; z++) {
                  parts2[w + z] = 0;
                }
                offset = z - 1;
              } else {
                parts2[w + offset] = _htons(parseInt(words[w], 16));
              }
            } else {
              parts2[w + offset] = words[w];
            }
          }
          return [parts2[1] << 16 | parts2[0], parts2[3] << 16 | parts2[2], parts2[5] << 16 | parts2[4], parts2[7] << 16 | parts2[6]];
        };
        var writeSockaddr = (sa, family, addr2, port, addrlen) => {
          switch (family) {
            case 2:
              addr2 = inetPton4(addr2);
              zeroMemory(sa, 16);
              if (addrlen) {
                HEAP32[addrlen >>> 2 >>> 0] = 16;
              }
              HEAP16[sa >>> 1 >>> 0] = family;
              HEAP32[sa + 4 >>> 2 >>> 0] = addr2;
              HEAP16[sa + 2 >>> 1 >>> 0] = _htons(port);
              break;
            case 10:
              addr2 = inetPton6(addr2);
              zeroMemory(sa, 28);
              if (addrlen) {
                HEAP32[addrlen >>> 2 >>> 0] = 28;
              }
              HEAP32[sa >>> 2 >>> 0] = family;
              HEAP32[sa + 8 >>> 2 >>> 0] = addr2[0];
              HEAP32[sa + 12 >>> 2 >>> 0] = addr2[1];
              HEAP32[sa + 16 >>> 2 >>> 0] = addr2[2];
              HEAP32[sa + 20 >>> 2 >>> 0] = addr2[3];
              HEAP16[sa + 2 >>> 1 >>> 0] = _htons(port);
              break;
            default:
              return 5;
          }
          return 0;
        };
        var DNS = {
          address_map: {
            id: 1,
            addrs: {},
            names: {}
          },
          lookup_name(name2) {
            var res = inetPton4(name2);
            if (res !== null) {
              return name2;
            }
            res = inetPton6(name2);
            if (res !== null) {
              return name2;
            }
            var addr2;
            if (DNS.address_map.addrs[name2]) {
              addr2 = DNS.address_map.addrs[name2];
            } else {
              var id = DNS.address_map.id++;
              assert(id < 65535, "exceeded max address mappings of 65535");
              addr2 = "172.29." + (id & 255) + "." + (id & 65280);
              DNS.address_map.names[addr2] = name2;
              DNS.address_map.addrs[name2] = addr2;
            }
            return addr2;
          },
          lookup_addr(addr2) {
            if (DNS.address_map.names[addr2]) {
              return DNS.address_map.names[addr2];
            }
            return null;
          }
        };
        function ___syscall_accept4(fd, addr2, addrlen, flags2, d1, d2) {
          addr2 >>>= 0;
          addrlen >>>= 0;
          try {
            var sock = getSocketFromFD(fd);
            var newsock = sock.sock_ops.accept(sock);
            if (addr2) {
              var errno = writeSockaddr(addr2, newsock.family, DNS.lookup_name(newsock.daddr), newsock.dport, addrlen);
            }
            return newsock.stream.fd;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_accept4.sig = "iippiii";
        var inetNtop4 = (addr2) => (addr2 & 255) + "." + (addr2 >> 8 & 255) + "." + (addr2 >> 16 & 255) + "." + (addr2 >> 24 & 255);
        var inetNtop6 = (ints) => {
          var str = "";
          var word = 0;
          var longest = 0;
          var lastzero = 0;
          var zstart = 0;
          var len2 = 0;
          var i2 = 0;
          var parts2 = [ints[0] & 65535, ints[0] >> 16, ints[1] & 65535, ints[1] >> 16, ints[2] & 65535, ints[2] >> 16, ints[3] & 65535, ints[3] >> 16];
          var hasipv4 = true;
          var v4part = "";
          for (i2 = 0; i2 < 5; i2++) {
            if (parts2[i2] !== 0) {
              hasipv4 = false;
              break;
            }
          }
          if (hasipv4) {
            v4part = inetNtop4(parts2[6] | parts2[7] << 16);
            if (parts2[5] === -1) {
              str = "::ffff:";
              str += v4part;
              return str;
            }
            if (parts2[5] === 0) {
              str = "::";
              if (v4part === "0.0.0.0")
                v4part = "";
              if (v4part === "0.0.0.1")
                v4part = "1";
              str += v4part;
              return str;
            }
          }
          for (word = 0; word < 8; word++) {
            if (parts2[word] === 0) {
              if (word - lastzero > 1) {
                len2 = 0;
              }
              lastzero = word;
              len2++;
            }
            if (len2 > longest) {
              longest = len2;
              zstart = word - longest + 1;
            }
          }
          for (word = 0; word < 8; word++) {
            if (longest > 1) {
              if (parts2[word] === 0 && word >= zstart && word < zstart + longest) {
                if (word === zstart) {
                  str += ":";
                  if (zstart === 0)
                    str += ":";
                }
                continue;
              }
            }
            str += Number(_ntohs(parts2[word] & 65535)).toString(16);
            str += word < 7 ? ":" : "";
          }
          return str;
        };
        var readSockaddr = (sa, salen) => {
          var family = HEAP16[sa >>> 1 >>> 0];
          var port = _ntohs(HEAPU16[sa + 2 >>> 1 >>> 0]);
          var addr2;
          switch (family) {
            case 2:
              if (salen !== 16) {
                return {
                  errno: 28
                };
              }
              addr2 = HEAP32[sa + 4 >>> 2 >>> 0];
              addr2 = inetNtop4(addr2);
              break;
            case 10:
              if (salen !== 28) {
                return {
                  errno: 28
                };
              }
              addr2 = [HEAP32[sa + 8 >>> 2 >>> 0], HEAP32[sa + 12 >>> 2 >>> 0], HEAP32[sa + 16 >>> 2 >>> 0], HEAP32[sa + 20 >>> 2 >>> 0]];
              addr2 = inetNtop6(addr2);
              break;
            default:
              return {
                errno: 5
              };
          }
          return {
            family,
            addr: addr2,
            port
          };
        };
        var getSocketAddress = (addrp, addrlen, allowNull) => {
          if (allowNull && addrp === 0)
            return null;
          var info2 = readSockaddr(addrp, addrlen);
          if (info2.errno)
            throw new FS.ErrnoError(info2.errno);
          info2.addr = DNS.lookup_addr(info2.addr) || info2.addr;
          return info2;
        };
        function ___syscall_bind(fd, addr2, addrlen, d1, d2, d3) {
          addr2 >>>= 0;
          addrlen >>>= 0;
          try {
            var sock = getSocketFromFD(fd);
            var info2 = getSocketAddress(addr2, addrlen);
            sock.sock_ops.bind(sock, info2.addr, info2.port);
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_bind.sig = "iippiii";
        function ___syscall_chdir(path2) {
          path2 >>>= 0;
          try {
            path2 = SYSCALLS.getStr(path2);
            FS.chdir(path2);
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_chdir.sig = "ip";
        function ___syscall_chmod(path2, mode) {
          path2 >>>= 0;
          try {
            path2 = SYSCALLS.getStr(path2);
            FS.chmod(path2, mode);
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_chmod.sig = "ipi";
        function ___syscall_connect(fd, addr2, addrlen, d1, d2, d3) {
          addr2 >>>= 0;
          addrlen >>>= 0;
          try {
            var sock = getSocketFromFD(fd);
            var info2 = getSocketAddress(addr2, addrlen);
            sock.sock_ops.connect(sock, info2.addr, info2.port);
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_connect.sig = "iippiii";
        function ___syscall_dup(fd) {
          try {
            var old = SYSCALLS.getStreamFromFD(fd);
            return FS.createStream(old).fd;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_dup.sig = "ii";
        function ___syscall_dup3(fd, newfd, flags2) {
          try {
            var old = SYSCALLS.getStreamFromFD(fd);
            if (old.fd === newfd)
              return -28;
            var existing = FS.getStream(newfd);
            if (existing)
              FS.close(existing);
            return FS.createStream(old, newfd).fd;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_dup3.sig = "iiii";
        function ___syscall_faccessat(dirfd, path2, amode, flags2) {
          path2 >>>= 0;
          try {
            path2 = SYSCALLS.getStr(path2);
            path2 = SYSCALLS.calculateAt(dirfd, path2);
            if (amode & ~7) {
              return -28;
            }
            var lookup = FS.lookupPath(path2, {
              follow: true
            });
            var node = lookup.node;
            if (!node) {
              return -44;
            }
            var perms = "";
            if (amode & 4)
              perms += "r";
            if (amode & 2)
              perms += "w";
            if (amode & 1)
              perms += "x";
            if (perms && FS.nodePermissions(node, perms)) {
              return -2;
            }
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_faccessat.sig = "iipii";
        var ___syscall_fadvise64 = (fd, offset, len2, advice) => 0;
        ___syscall_fadvise64.sig = "iiiiiii";
        function ___syscall_fallocate(fd, mode, offset_low, offset_high, len_low, len_high) {
          var offset = convertI32PairToI53Checked(offset_low, offset_high);
          var len2 = convertI32PairToI53Checked(len_low, len_high);
          try {
            if (isNaN(offset))
              return 61;
            var stream = SYSCALLS.getStreamFromFD(fd);
            FS.allocate(stream, offset, len2);
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_fallocate.sig = "iiiiiii";
        function ___syscall_fchdir(fd) {
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            FS.chdir(stream.path);
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_fchdir.sig = "ii";
        function ___syscall_fchmod(fd, mode) {
          try {
            FS.fchmod(fd, mode);
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_fchmod.sig = "iii";
        function ___syscall_fchmodat(dirfd, path2, mode, varargs) {
          path2 >>>= 0;
          varargs >>>= 0;
          SYSCALLS.varargs = varargs;
          try {
            path2 = SYSCALLS.getStr(path2);
            path2 = SYSCALLS.calculateAt(dirfd, path2);
            FS.chmod(path2, mode);
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_fchmodat.sig = "iipip";
        function ___syscall_fchown32(fd, owner, group) {
          try {
            FS.fchown(fd, owner, group);
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_fchown32.sig = "iiii";
        function ___syscall_fchownat(dirfd, path2, owner, group, flags2) {
          path2 >>>= 0;
          try {
            path2 = SYSCALLS.getStr(path2);
            var nofollow = flags2 & 256;
            flags2 = flags2 & ~256;
            path2 = SYSCALLS.calculateAt(dirfd, path2);
            (nofollow ? FS.lchown : FS.chown)(path2, owner, group);
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_fchownat.sig = "iipiii";
        function ___syscall_fcntl64(fd, cmd, varargs) {
          varargs >>>= 0;
          SYSCALLS.varargs = varargs;
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            switch (cmd) {
              case 0: {
                var arg = SYSCALLS.get();
                if (arg < 0) {
                  return -28;
                }
                while (FS.streams[arg]) {
                  arg++;
                }
                var newStream;
                newStream = FS.createStream(stream, arg);
                return newStream.fd;
              }
              case 1:
              case 2:
                return 0;
              case 3:
                return stream.flags;
              case 4: {
                var arg = SYSCALLS.get();
                stream.flags |= arg;
                return 0;
              }
              case 12: {
                var arg = SYSCALLS.getp();
                var offset = 0;
                HEAP16[arg + offset >>> 1 >>> 0] = 2;
                return 0;
              }
              case 13:
              case 14:
                return 0;
            }
            return -28;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_fcntl64.sig = "iiip";
        function ___syscall_fdatasync(fd) {
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_fdatasync.sig = "ii";
        function ___syscall_fstat64(fd, buf) {
          buf >>>= 0;
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            return SYSCALLS.doStat(FS.stat, stream.path, buf);
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_fstat64.sig = "iip";
        function ___syscall_statfs64(path2, size, buf) {
          path2 >>>= 0;
          size >>>= 0;
          buf >>>= 0;
          try {
            path2 = SYSCALLS.getStr(path2);
            HEAP32[buf + 4 >>> 2 >>> 0] = 4096;
            HEAP32[buf + 40 >>> 2 >>> 0] = 4096;
            HEAP32[buf + 8 >>> 2 >>> 0] = 1e6;
            HEAP32[buf + 12 >>> 2 >>> 0] = 5e5;
            HEAP32[buf + 16 >>> 2 >>> 0] = 5e5;
            HEAP32[buf + 20 >>> 2 >>> 0] = FS.nextInode;
            HEAP32[buf + 24 >>> 2 >>> 0] = 1e6;
            HEAP32[buf + 28 >>> 2 >>> 0] = 42;
            HEAP32[buf + 44 >>> 2 >>> 0] = 2;
            HEAP32[buf + 36 >>> 2 >>> 0] = 255;
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_statfs64.sig = "ippp";
        function ___syscall_fstatfs64(fd, size, buf) {
          size >>>= 0;
          buf >>>= 0;
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            return ___syscall_statfs64(0, size, buf);
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_fstatfs64.sig = "iipp";
        function ___syscall_ftruncate64(fd, length_low, length_high) {
          var length = convertI32PairToI53Checked(length_low, length_high);
          try {
            if (isNaN(length))
              return 61;
            FS.ftruncate(fd, length);
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_ftruncate64.sig = "iiii";
        var stringToUTF8 = (str, outPtr, maxBytesToWrite) => stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
        function ___syscall_getcwd(buf, size) {
          buf >>>= 0;
          size >>>= 0;
          try {
            if (size === 0)
              return -28;
            var cwd = FS.cwd();
            var cwdLengthInBytes = lengthBytesUTF8(cwd) + 1;
            if (size < cwdLengthInBytes)
              return -68;
            stringToUTF8(cwd, buf, size);
            return cwdLengthInBytes;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_getcwd.sig = "ipp";
        function ___syscall_getdents64(fd, dirp, count) {
          dirp >>>= 0;
          count >>>= 0;
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            stream.getdents || (stream.getdents = FS.readdir(stream.path));
            var struct_size = 280;
            var pos = 0;
            var off = FS.llseek(stream, 0, 1);
            var idx = Math.floor(off / struct_size);
            while (idx < stream.getdents.length && pos + struct_size <= count) {
              var id;
              var type;
              var name2 = stream.getdents[idx];
              if (name2 === ".") {
                id = stream.node.id;
                type = 4;
              } else if (name2 === "..") {
                var lookup = FS.lookupPath(stream.path, {
                  parent: true
                });
                id = lookup.node.id;
                type = 4;
              } else {
                var child = FS.lookupNode(stream.node, name2);
                id = child.id;
                type = FS.isChrdev(child.mode) ? 2 : FS.isDir(child.mode) ? 4 : FS.isLink(child.mode) ? 10 : 8;
              }
              tempI64 = [id >>> 0, (tempDouble = id, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[dirp + pos >>> 2 >>> 0] = tempI64[0], HEAP32[dirp + pos + 4 >>> 2 >>> 0] = tempI64[1];
              tempI64 = [(idx + 1) * struct_size >>> 0, (tempDouble = (idx + 1) * struct_size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[dirp + pos + 8 >>> 2 >>> 0] = tempI64[0], HEAP32[dirp + pos + 12 >>> 2 >>> 0] = tempI64[1];
              HEAP16[dirp + pos + 16 >>> 1 >>> 0] = 280;
              HEAP8[dirp + pos + 18 >>> 0 >>> 0] = type;
              stringToUTF8(name2, dirp + pos + 19, 256);
              pos += struct_size;
              idx += 1;
            }
            FS.llseek(stream, idx * struct_size, 0);
            return pos;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_getdents64.sig = "iipp";
        function ___syscall_getpeername(fd, addr2, addrlen, d1, d2, d3) {
          addr2 >>>= 0;
          addrlen >>>= 0;
          try {
            var sock = getSocketFromFD(fd);
            if (!sock.daddr) {
              return -53;
            }
            var errno = writeSockaddr(addr2, sock.family, DNS.lookup_name(sock.daddr), sock.dport, addrlen);
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_getpeername.sig = "iippiii";
        function ___syscall_getsockname(fd, addr2, addrlen, d1, d2, d3) {
          addr2 >>>= 0;
          addrlen >>>= 0;
          try {
            var sock = getSocketFromFD(fd);
            var errno = writeSockaddr(addr2, sock.family, DNS.lookup_name(sock.saddr || "0.0.0.0"), sock.sport, addrlen);
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_getsockname.sig = "iippiii";
        function ___syscall_getsockopt(fd, level, optname, optval, optlen, d1) {
          optval >>>= 0;
          optlen >>>= 0;
          try {
            var sock = getSocketFromFD(fd);
            if (level === 1) {
              if (optname === 4) {
                HEAP32[optval >>> 2 >>> 0] = sock.error;
                HEAP32[optlen >>> 2 >>> 0] = 4;
                sock.error = null;
                return 0;
              }
            }
            return -50;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_getsockopt.sig = "iiiippi";
        function ___syscall_ioctl(fd, op, varargs) {
          varargs >>>= 0;
          SYSCALLS.varargs = varargs;
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            switch (op) {
              case 21509: {
                if (!stream.tty)
                  return -59;
                return 0;
              }
              case 21505: {
                if (!stream.tty)
                  return -59;
                if (stream.tty.ops.ioctl_tcgets) {
                  var termios = stream.tty.ops.ioctl_tcgets(stream);
                  var argp = SYSCALLS.getp();
                  HEAP32[argp >>> 2 >>> 0] = termios.c_iflag || 0;
                  HEAP32[argp + 4 >>> 2 >>> 0] = termios.c_oflag || 0;
                  HEAP32[argp + 8 >>> 2 >>> 0] = termios.c_cflag || 0;
                  HEAP32[argp + 12 >>> 2 >>> 0] = termios.c_lflag || 0;
                  for (var i2 = 0; i2 < 32; i2++) {
                    HEAP8[argp + i2 + 17 >>> 0 >>> 0] = termios.c_cc[i2] || 0;
                  }
                  return 0;
                }
                return 0;
              }
              case 21510:
              case 21511:
              case 21512: {
                if (!stream.tty)
                  return -59;
                return 0;
              }
              case 21506:
              case 21507:
              case 21508: {
                if (!stream.tty)
                  return -59;
                if (stream.tty.ops.ioctl_tcsets) {
                  var argp = SYSCALLS.getp();
                  var c_iflag = HEAP32[argp >>> 2 >>> 0];
                  var c_oflag = HEAP32[argp + 4 >>> 2 >>> 0];
                  var c_cflag = HEAP32[argp + 8 >>> 2 >>> 0];
                  var c_lflag = HEAP32[argp + 12 >>> 2 >>> 0];
                  var c_cc = [];
                  for (var i2 = 0; i2 < 32; i2++) {
                    c_cc.push(HEAP8[argp + i2 + 17 >>> 0 >>> 0]);
                  }
                  return stream.tty.ops.ioctl_tcsets(stream.tty, op, {
                    c_iflag,
                    c_oflag,
                    c_cflag,
                    c_lflag,
                    c_cc
                  });
                }
                return 0;
              }
              case 21519: {
                if (!stream.tty)
                  return -59;
                var argp = SYSCALLS.getp();
                HEAP32[argp >>> 2 >>> 0] = 0;
                return 0;
              }
              case 21520: {
                if (!stream.tty)
                  return -59;
                return -28;
              }
              case 21531: {
                var argp = SYSCALLS.getp();
                return FS.ioctl(stream, op, argp);
              }
              case 21523: {
                if (!stream.tty)
                  return -59;
                if (stream.tty.ops.ioctl_tiocgwinsz) {
                  var winsize = stream.tty.ops.ioctl_tiocgwinsz(stream.tty);
                  var argp = SYSCALLS.getp();
                  HEAP16[argp >>> 1 >>> 0] = winsize[0];
                  HEAP16[argp + 2 >>> 1 >>> 0] = winsize[1];
                }
                return 0;
              }
              case 21524: {
                if (!stream.tty)
                  return -59;
                return 0;
              }
              case 21515: {
                if (!stream.tty)
                  return -59;
                return 0;
              }
              default:
                return -28;
            }
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_ioctl.sig = "iiip";
        function ___syscall_listen(fd, backlog) {
          try {
            var sock = getSocketFromFD(fd);
            sock.sock_ops.listen(sock, backlog);
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_listen.sig = "iiiiiii";
        function ___syscall_lstat64(path2, buf) {
          path2 >>>= 0;
          buf >>>= 0;
          try {
            path2 = SYSCALLS.getStr(path2);
            return SYSCALLS.doStat(FS.lstat, path2, buf);
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_lstat64.sig = "ipp";
        function ___syscall_mkdirat(dirfd, path2, mode) {
          path2 >>>= 0;
          try {
            path2 = SYSCALLS.getStr(path2);
            path2 = SYSCALLS.calculateAt(dirfd, path2);
            path2 = PATH.normalize(path2);
            if (path2[path2.length - 1] === "/")
              path2 = path2.substr(0, path2.length - 1);
            FS.mkdir(path2, mode, 0);
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_mkdirat.sig = "iipi";
        function ___syscall_mknodat(dirfd, path2, mode, dev) {
          path2 >>>= 0;
          try {
            path2 = SYSCALLS.getStr(path2);
            path2 = SYSCALLS.calculateAt(dirfd, path2);
            switch (mode & 61440) {
              case 32768:
              case 8192:
              case 24576:
              case 4096:
              case 49152:
                break;
              default:
                return -28;
            }
            FS.mknod(path2, mode, dev);
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_mknodat.sig = "iipii";
        function ___syscall_newfstatat(dirfd, path2, buf, flags2) {
          path2 >>>= 0;
          buf >>>= 0;
          try {
            path2 = SYSCALLS.getStr(path2);
            var nofollow = flags2 & 256;
            var allowEmpty = flags2 & 4096;
            flags2 = flags2 & ~6400;
            path2 = SYSCALLS.calculateAt(dirfd, path2, allowEmpty);
            return SYSCALLS.doStat(nofollow ? FS.lstat : FS.stat, path2, buf);
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_newfstatat.sig = "iippi";
        function ___syscall_openat(dirfd, path2, flags2, varargs) {
          path2 >>>= 0;
          varargs >>>= 0;
          SYSCALLS.varargs = varargs;
          try {
            path2 = SYSCALLS.getStr(path2);
            path2 = SYSCALLS.calculateAt(dirfd, path2);
            var mode = varargs ? SYSCALLS.get() : 0;
            return FS.open(path2, flags2, mode).fd;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_openat.sig = "iipip";
        var PIPEFS = {
          BUCKET_BUFFER_SIZE: 8192,
          mount(mount) {
            return FS.createNode(null, "/", 16384 | 511, 0);
          },
          createPipe() {
            var pipe = {
              buckets: [],
              refcnt: 2
            };
            pipe.buckets.push({
              buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
              offset: 0,
              roffset: 0
            });
            var rName = PIPEFS.nextname();
            var wName = PIPEFS.nextname();
            var rNode = FS.createNode(PIPEFS.root, rName, 4096, 0);
            var wNode = FS.createNode(PIPEFS.root, wName, 4096, 0);
            rNode.pipe = pipe;
            wNode.pipe = pipe;
            var readableStream = FS.createStream({
              path: rName,
              node: rNode,
              flags: 0,
              seekable: false,
              stream_ops: PIPEFS.stream_ops
            });
            rNode.stream = readableStream;
            var writableStream = FS.createStream({
              path: wName,
              node: wNode,
              flags: 1,
              seekable: false,
              stream_ops: PIPEFS.stream_ops
            });
            wNode.stream = writableStream;
            return {
              readable_fd: readableStream.fd,
              writable_fd: writableStream.fd
            };
          },
          stream_ops: {
            poll(stream) {
              var pipe = stream.node.pipe;
              if ((stream.flags & 2097155) === 1) {
                return 256 | 4;
              }
              if (pipe.buckets.length > 0) {
                for (var i2 = 0; i2 < pipe.buckets.length; i2++) {
                  var bucket = pipe.buckets[i2];
                  if (bucket.offset - bucket.roffset > 0) {
                    return 64 | 1;
                  }
                }
              }
              return 0;
            },
            ioctl(stream, request, varargs) {
              return 28;
            },
            fsync(stream) {
              return 28;
            },
            read(stream, buffer, offset, length, position) {
              var pipe = stream.node.pipe;
              var currentLength = 0;
              for (var i2 = 0; i2 < pipe.buckets.length; i2++) {
                var bucket = pipe.buckets[i2];
                currentLength += bucket.offset - bucket.roffset;
              }
              var data2 = buffer.subarray(offset, offset + length);
              if (length <= 0) {
                return 0;
              }
              if (currentLength == 0) {
                throw new FS.ErrnoError(6);
              }
              var toRead = Math.min(currentLength, length);
              var totalRead = toRead;
              var toRemove = 0;
              for (var i2 = 0; i2 < pipe.buckets.length; i2++) {
                var currBucket = pipe.buckets[i2];
                var bucketSize = currBucket.offset - currBucket.roffset;
                if (toRead <= bucketSize) {
                  var tmpSlice = currBucket.buffer.subarray(currBucket.roffset, currBucket.offset);
                  if (toRead < bucketSize) {
                    tmpSlice = tmpSlice.subarray(0, toRead);
                    currBucket.roffset += toRead;
                  } else {
                    toRemove++;
                  }
                  data2.set(tmpSlice);
                  break;
                } else {
                  var tmpSlice = currBucket.buffer.subarray(currBucket.roffset, currBucket.offset);
                  data2.set(tmpSlice);
                  data2 = data2.subarray(tmpSlice.byteLength);
                  toRead -= tmpSlice.byteLength;
                  toRemove++;
                }
              }
              if (toRemove && toRemove == pipe.buckets.length) {
                toRemove--;
                pipe.buckets[toRemove].offset = 0;
                pipe.buckets[toRemove].roffset = 0;
              }
              pipe.buckets.splice(0, toRemove);
              return totalRead;
            },
            write(stream, buffer, offset, length, position) {
              var pipe = stream.node.pipe;
              var data2 = buffer.subarray(offset, offset + length);
              var dataLen = data2.byteLength;
              if (dataLen <= 0) {
                return 0;
              }
              var currBucket = null;
              if (pipe.buckets.length == 0) {
                currBucket = {
                  buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
                  offset: 0,
                  roffset: 0
                };
                pipe.buckets.push(currBucket);
              } else {
                currBucket = pipe.buckets[pipe.buckets.length - 1];
              }
              assert(currBucket.offset <= PIPEFS.BUCKET_BUFFER_SIZE);
              var freeBytesInCurrBuffer = PIPEFS.BUCKET_BUFFER_SIZE - currBucket.offset;
              if (freeBytesInCurrBuffer >= dataLen) {
                currBucket.buffer.set(data2, currBucket.offset);
                currBucket.offset += dataLen;
                return dataLen;
              } else if (freeBytesInCurrBuffer > 0) {
                currBucket.buffer.set(data2.subarray(0, freeBytesInCurrBuffer), currBucket.offset);
                currBucket.offset += freeBytesInCurrBuffer;
                data2 = data2.subarray(freeBytesInCurrBuffer, data2.byteLength);
              }
              var numBuckets = data2.byteLength / PIPEFS.BUCKET_BUFFER_SIZE | 0;
              var remElements = data2.byteLength % PIPEFS.BUCKET_BUFFER_SIZE;
              for (var i2 = 0; i2 < numBuckets; i2++) {
                var newBucket = {
                  buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
                  offset: PIPEFS.BUCKET_BUFFER_SIZE,
                  roffset: 0
                };
                pipe.buckets.push(newBucket);
                newBucket.buffer.set(data2.subarray(0, PIPEFS.BUCKET_BUFFER_SIZE));
                data2 = data2.subarray(PIPEFS.BUCKET_BUFFER_SIZE, data2.byteLength);
              }
              if (remElements > 0) {
                var newBucket = {
                  buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
                  offset: data2.byteLength,
                  roffset: 0
                };
                pipe.buckets.push(newBucket);
                newBucket.buffer.set(data2);
              }
              return dataLen;
            },
            close(stream) {
              var pipe = stream.node.pipe;
              pipe.refcnt--;
              if (pipe.refcnt === 0) {
                pipe.buckets = null;
              }
            }
          },
          nextname() {
            if (!PIPEFS.nextname.current) {
              PIPEFS.nextname.current = 0;
            }
            return "pipe[" + PIPEFS.nextname.current++ + "]";
          }
        };
        function ___syscall_pipe(fdPtr) {
          fdPtr >>>= 0;
          try {
            if (fdPtr == 0) {
              throw new FS.ErrnoError(21);
            }
            var res = PIPEFS.createPipe();
            HEAP32[fdPtr >>> 2 >>> 0] = res.readable_fd;
            HEAP32[fdPtr + 4 >>> 2 >>> 0] = res.writable_fd;
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_pipe.sig = "ip";
        function ___syscall_poll(fds, nfds, timeout) {
          fds >>>= 0;
          try {
            var nonzero = 0;
            for (var i2 = 0; i2 < nfds; i2++) {
              var pollfd = fds + 8 * i2;
              var fd = HEAP32[pollfd >>> 2 >>> 0];
              var events = HEAP16[pollfd + 4 >>> 1 >>> 0];
              var mask = 32;
              var stream = FS.getStream(fd);
              if (stream) {
                mask = SYSCALLS.DEFAULT_POLLMASK;
                if (stream.stream_ops.poll) {
                  mask = stream.stream_ops.poll(stream, -1);
                }
              }
              mask &= events | 8 | 16;
              if (mask)
                nonzero++;
              HEAP16[pollfd + 6 >>> 1 >>> 0] = mask;
            }
            return nonzero;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_poll.sig = "ipii";
        function ___syscall_readlinkat(dirfd, path2, buf, bufsize) {
          path2 >>>= 0;
          buf >>>= 0;
          bufsize >>>= 0;
          try {
            path2 = SYSCALLS.getStr(path2);
            path2 = SYSCALLS.calculateAt(dirfd, path2);
            if (bufsize <= 0)
              return -28;
            var ret = FS.readlink(path2);
            var len2 = Math.min(bufsize, lengthBytesUTF8(ret));
            var endChar = HEAP8[buf + len2 >>> 0];
            stringToUTF8(ret, buf, bufsize + 1);
            HEAP8[buf + len2 >>> 0] = endChar;
            return len2;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_readlinkat.sig = "iippp";
        function ___syscall_recvfrom(fd, buf, len2, flags2, addr2, addrlen) {
          buf >>>= 0;
          len2 >>>= 0;
          addr2 >>>= 0;
          addrlen >>>= 0;
          try {
            var sock = getSocketFromFD(fd);
            var msg = sock.sock_ops.recvmsg(sock, len2);
            if (!msg)
              return 0;
            if (addr2) {
              var errno = writeSockaddr(addr2, sock.family, DNS.lookup_name(msg.addr), msg.port, addrlen);
            }
            HEAPU8.set(msg.buffer, buf >>> 0);
            return msg.buffer.byteLength;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_recvfrom.sig = "iippipp";
        function ___syscall_recvmsg(fd, message, flags2, d1, d2, d3) {
          message >>>= 0;
          try {
            var sock = getSocketFromFD(fd);
            var iov = HEAPU32[message + 8 >>> 2 >>> 0];
            var num = HEAP32[message + 12 >>> 2 >>> 0];
            var total = 0;
            for (var i2 = 0; i2 < num; i2++) {
              total += HEAP32[iov + (8 * i2 + 4) >>> 2 >>> 0];
            }
            var msg = sock.sock_ops.recvmsg(sock, total);
            if (!msg)
              return 0;
            var name2 = HEAPU32[message >>> 2 >>> 0];
            if (name2) {
              var errno = writeSockaddr(name2, sock.family, DNS.lookup_name(msg.addr), msg.port);
            }
            var bytesRead = 0;
            var bytesRemaining = msg.buffer.byteLength;
            for (var i2 = 0; bytesRemaining > 0 && i2 < num; i2++) {
              var iovbase = HEAPU32[iov + (8 * i2 + 0) >>> 2 >>> 0];
              var iovlen = HEAP32[iov + (8 * i2 + 4) >>> 2 >>> 0];
              if (!iovlen) {
                continue;
              }
              var length = Math.min(iovlen, bytesRemaining);
              var buf = msg.buffer.subarray(bytesRead, bytesRead + length);
              HEAPU8.set(buf, iovbase + bytesRead >>> 0);
              bytesRead += length;
              bytesRemaining -= length;
            }
            return bytesRead;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_recvmsg.sig = "iipiiii";
        function ___syscall_renameat(olddirfd, oldpath, newdirfd, newpath) {
          oldpath >>>= 0;
          newpath >>>= 0;
          try {
            oldpath = SYSCALLS.getStr(oldpath);
            newpath = SYSCALLS.getStr(newpath);
            oldpath = SYSCALLS.calculateAt(olddirfd, oldpath);
            newpath = SYSCALLS.calculateAt(newdirfd, newpath);
            FS.rename(oldpath, newpath);
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_renameat.sig = "iipip";
        function ___syscall_rmdir(path2) {
          path2 >>>= 0;
          try {
            path2 = SYSCALLS.getStr(path2);
            FS.rmdir(path2);
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_rmdir.sig = "ip";
        function ___syscall_sendmsg(fd, message, flags2, d1, d2, d3) {
          message >>>= 0;
          d1 >>>= 0;
          d2 >>>= 0;
          try {
            var sock = getSocketFromFD(fd);
            var iov = HEAPU32[message + 8 >>> 2 >>> 0];
            var num = HEAP32[message + 12 >>> 2 >>> 0];
            var addr2, port;
            var name2 = HEAPU32[message >>> 2 >>> 0];
            var namelen = HEAP32[message + 4 >>> 2 >>> 0];
            if (name2) {
              var info2 = readSockaddr(name2, namelen);
              if (info2.errno)
                return -info2.errno;
              port = info2.port;
              addr2 = DNS.lookup_addr(info2.addr) || info2.addr;
            }
            var total = 0;
            for (var i2 = 0; i2 < num; i2++) {
              total += HEAP32[iov + (8 * i2 + 4) >>> 2 >>> 0];
            }
            var view = new Uint8Array(total);
            var offset = 0;
            for (var i2 = 0; i2 < num; i2++) {
              var iovbase = HEAPU32[iov + (8 * i2 + 0) >>> 2 >>> 0];
              var iovlen = HEAP32[iov + (8 * i2 + 4) >>> 2 >>> 0];
              for (var j = 0; j < iovlen; j++) {
                view[offset++] = HEAP8[iovbase + j >>> 0 >>> 0];
              }
            }
            return sock.sock_ops.sendmsg(sock, view, 0, total, addr2, port);
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_sendmsg.sig = "iipippi";
        function ___syscall_sendto(fd, message, length, flags2, addr2, addr_len) {
          message >>>= 0;
          length >>>= 0;
          addr2 >>>= 0;
          addr_len >>>= 0;
          try {
            var sock = getSocketFromFD(fd);
            var dest = getSocketAddress(addr2, addr_len, true);
            if (!dest) {
              return FS.write(sock.stream, HEAP8, message, length);
            }
            return sock.sock_ops.sendmsg(sock, HEAP8, message, length, dest.addr, dest.port);
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_sendto.sig = "iippipp";
        function ___syscall_socket(domain, type, protocol) {
          try {
            var sock = SOCKFS.createSocket(domain, type, protocol);
            return sock.stream.fd;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_socket.sig = "iiiiiii";
        function ___syscall_stat64(path2, buf) {
          path2 >>>= 0;
          buf >>>= 0;
          try {
            path2 = SYSCALLS.getStr(path2);
            return SYSCALLS.doStat(FS.stat, path2, buf);
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_stat64.sig = "ipp";
        function ___syscall_symlink(target, linkpath) {
          target >>>= 0;
          linkpath >>>= 0;
          try {
            target = SYSCALLS.getStr(target);
            linkpath = SYSCALLS.getStr(linkpath);
            FS.symlink(target, linkpath);
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_symlink.sig = "ipp";
        function ___syscall_symlinkat(target, newdirfd, linkpath) {
          target >>>= 0;
          linkpath >>>= 0;
          try {
            linkpath = SYSCALLS.calculateAt(newdirfd, linkpath);
            FS.symlink(target, linkpath);
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_symlinkat.sig = "ipip";
        function ___syscall_truncate64(path2, length_low, length_high) {
          path2 >>>= 0;
          var length = convertI32PairToI53Checked(length_low, length_high);
          try {
            if (isNaN(length))
              return 61;
            path2 = SYSCALLS.getStr(path2);
            FS.truncate(path2, length);
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_truncate64.sig = "ipii";
        function ___syscall_unlinkat(dirfd, path2, flags2) {
          path2 >>>= 0;
          try {
            path2 = SYSCALLS.getStr(path2);
            path2 = SYSCALLS.calculateAt(dirfd, path2);
            if (flags2 === 0) {
              FS.unlink(path2);
            } else if (flags2 === 512) {
              FS.rmdir(path2);
            } else {
              abort("Invalid flags passed to unlinkat");
            }
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_unlinkat.sig = "iipi";
        var readI53FromI64 = (ptr2) => HEAPU32[ptr2 >>> 2 >>> 0] + HEAP32[ptr2 + 4 >>> 2 >>> 0] * 4294967296;
        function ___syscall_utimensat(dirfd, path2, times, flags2) {
          path2 >>>= 0;
          times >>>= 0;
          try {
            path2 = SYSCALLS.getStr(path2);
            path2 = SYSCALLS.calculateAt(dirfd, path2, true);
            if (!times) {
              var atime = Date.now();
              var mtime = atime;
            } else {
              var seconds = readI53FromI64(times);
              var nanoseconds = HEAP32[times + 8 >>> 2 >>> 0];
              atime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
              times += 16;
              seconds = readI53FromI64(times);
              nanoseconds = HEAP32[times + 8 >>> 2 >>> 0];
              mtime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
            }
            FS.utime(path2, atime, mtime);
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_utimensat.sig = "iippi";
        var ___table_base = new WebAssembly.Global({
          "value": "i32",
          "mutable": false
        }, 1);
        var ENV = {};
        var stringToUTF8OnStack = (str) => {
          var size = lengthBytesUTF8(str) + 1;
          var ret = stackAlloc(size);
          stringToUTF8(str, ret, size);
          return ret;
        };
        var withStackSave = (f) => {
          var stack = stackSave();
          var ret = f();
          stackRestore(stack);
          return ret;
        };
        var dlSetError = (msg) => {
          withStackSave(() => {
            var cmsg = stringToUTF8OnStack(msg);
            ___dl_seterr(cmsg, 0);
          });
        };
        var dlopenInternal = (handle2, jsflags) => {
          var filename = UTF8ToString(handle2 + 36);
          var flags2 = HEAP32[handle2 + 4 >>> 2 >>> 0];
          filename = PATH.normalize(filename);
          var searchpaths = [];
          var global2 = Boolean(flags2 & 256);
          var localScope2 = global2 ? null : {};
          var combinedFlags = {
            global: global2,
            nodelete: Boolean(flags2 & 4096),
            loadAsync: jsflags.loadAsync
          };
          if (jsflags.loadAsync) {
            return loadDynamicLibrary(filename, combinedFlags, localScope2, handle2);
          }
          try {
            return loadDynamicLibrary(filename, combinedFlags, localScope2, handle2);
          } catch (e) {
            dlSetError(`Could not load dynamic lib: ${filename}
${e}`);
            return 0;
          }
        };
        function __dlopen_js(handle2) {
          handle2 >>>= 0;
          return dlopenInternal(handle2, {
            loadAsync: false
          });
        }
        __dlopen_js.sig = "pp";
        function __dlsym_js(handle2, symbol, symbolIndex) {
          handle2 >>>= 0;
          symbol >>>= 0;
          symbolIndex >>>= 0;
          symbol = UTF8ToString(symbol);
          var result;
          var newSymIndex;
          var lib = LDSO.loadedLibsByHandle[handle2];
          if (!lib.exports.hasOwnProperty(symbol) || lib.exports[symbol].stub) {
            dlSetError(`Tried to lookup unknown symbol "${symbol}" in dynamic lib: ${lib.name}`);
            return 0;
          }
          newSymIndex = Object.keys(lib.exports).indexOf(symbol);
          var origSym = "orig$" + symbol;
          result = lib.exports[origSym];
          if (result) {
            newSymIndex = Object.keys(lib.exports).indexOf(origSym);
          } else
            result = lib.exports[symbol];
          if (typeof result == "function") {
            var addr2 = getFunctionAddress(result);
            if (addr2) {
              result = addr2;
            } else {
              result = addFunction(result, result.sig);
              HEAPU32[symbolIndex >>> 2 >>> 0] = newSymIndex;
            }
          }
          return result;
        }
        __dlsym_js.sig = "pppp";
        function __embind_register_bigint(primitiveType, name2, size, minRange, maxRange) {
          primitiveType >>>= 0;
          name2 >>>= 0;
          size >>>= 0;
        }
        __embind_register_bigint.sig = "vpppiiii";
        var embind_init_charCodes = () => {
          var codes = new Array(256);
          for (var i2 = 0; i2 < 256; ++i2) {
            codes[i2] = String.fromCharCode(i2);
          }
          embind_charCodes = codes;
        };
        var embind_charCodes;
        var readLatin1String = (ptr2) => {
          var ret = "";
          var c = ptr2;
          while (HEAPU8[c >>> 0]) {
            ret += embind_charCodes[HEAPU8[c++ >>> 0]];
          }
          return ret;
        };
        var awaitingDependencies = {};
        var registeredTypes = {};
        var typeDependencies = {};
        var BindingError;
        var throwBindingError = (message) => {
          throw new BindingError(message);
        };
        var InternalError;
        var throwInternalError = (message) => {
          throw new InternalError(message);
        };
        var whenDependentTypesAreResolved = (myTypes, dependentTypes, getTypeConverters) => {
          myTypes.forEach(function(type) {
            typeDependencies[type] = dependentTypes;
          });
          function onComplete(typeConverters2) {
            var myTypeConverters = getTypeConverters(typeConverters2);
            if (myTypeConverters.length !== myTypes.length) {
              throwInternalError("Mismatched type converter count");
            }
            for (var i2 = 0; i2 < myTypes.length; ++i2) {
              registerType(myTypes[i2], myTypeConverters[i2]);
            }
          }
          var typeConverters = new Array(dependentTypes.length);
          var unregisteredTypes = [];
          var registered = 0;
          dependentTypes.forEach((dt, i2) => {
            if (registeredTypes.hasOwnProperty(dt)) {
              typeConverters[i2] = registeredTypes[dt];
            } else {
              unregisteredTypes.push(dt);
              if (!awaitingDependencies.hasOwnProperty(dt)) {
                awaitingDependencies[dt] = [];
              }
              awaitingDependencies[dt].push(() => {
                typeConverters[i2] = registeredTypes[dt];
                ++registered;
                if (registered === unregisteredTypes.length) {
                  onComplete(typeConverters);
                }
              });
            }
          });
          if (0 === unregisteredTypes.length) {
            onComplete(typeConverters);
          }
        };
        function sharedRegisterType(rawType, registeredInstance, options = {}) {
          var name2 = registeredInstance.name;
          if (!rawType) {
            throwBindingError(`type "${name2}" must have a positive integer typeid pointer`);
          }
          if (registeredTypes.hasOwnProperty(rawType)) {
            if (options.ignoreDuplicateRegistrations) {
              return;
            } else {
              throwBindingError(`Cannot register type '${name2}' twice`);
            }
          }
          registeredTypes[rawType] = registeredInstance;
          delete typeDependencies[rawType];
          if (awaitingDependencies.hasOwnProperty(rawType)) {
            var callbacks = awaitingDependencies[rawType];
            delete awaitingDependencies[rawType];
            callbacks.forEach((cb) => cb());
          }
        }
        function registerType(rawType, registeredInstance, options = {}) {
          if (!("argPackAdvance" in registeredInstance)) {
            throw new TypeError("registerType registeredInstance requires argPackAdvance");
          }
          return sharedRegisterType(rawType, registeredInstance, options);
        }
        var GenericWireTypeSize = 8;
        function __embind_register_bool(rawType, name2, trueValue, falseValue) {
          rawType >>>= 0;
          name2 >>>= 0;
          name2 = readLatin1String(name2);
          registerType(rawType, {
            name: name2,
            "fromWireType": function(wt) {
              return !!wt;
            },
            "toWireType": function(destructors, o) {
              return o ? trueValue : falseValue;
            },
            "argPackAdvance": GenericWireTypeSize,
            "readValueFromPointer": function(pointer) {
              return this["fromWireType"](HEAPU8[pointer >>> 0]);
            },
            destructorFunction: null
          });
        }
        __embind_register_bool.sig = "vppii";
        class HandleAllocator {
          constructor() {
            this.allocated = [void 0];
            this.freelist = [];
          }
          get(id) {
            return this.allocated[id];
          }
          has(id) {
            return this.allocated[id] !== void 0;
          }
          allocate(handle2) {
            var id = this.freelist.pop() || this.allocated.length;
            this.allocated[id] = handle2;
            return id;
          }
          free(id) {
            this.allocated[id] = void 0;
            this.freelist.push(id);
          }
        }
        var emval_handles = new HandleAllocator();
        function __emval_decref(handle2) {
          handle2 >>>= 0;
          if (handle2 >= emval_handles.reserved && 0 === --emval_handles.get(handle2).refcount) {
            emval_handles.free(handle2);
          }
        }
        __emval_decref.sig = "vp";
        var count_emval_handles = () => {
          var count = 0;
          for (var i2 = emval_handles.reserved; i2 < emval_handles.allocated.length; ++i2) {
            if (emval_handles.allocated[i2] !== void 0) {
              ++count;
            }
          }
          return count;
        };
        var init_emval = () => {
          emval_handles.allocated.push({
            value: void 0
          }, {
            value: null
          }, {
            value: true
          }, {
            value: false
          });
          Object.assign(emval_handles, {
            reserved: emval_handles.allocated.length
          }), Module["count_emval_handles"] = count_emval_handles;
        };
        var Emval = {
          toValue: (handle2) => {
            if (!handle2) {
              throwBindingError("Cannot use deleted val. handle = " + handle2);
            }
            return emval_handles.get(handle2).value;
          },
          toHandle: (value) => {
            switch (value) {
              case void 0:
                return 1;
              case null:
                return 2;
              case true:
                return 3;
              case false:
                return 4;
              default: {
                return emval_handles.allocate({
                  refcount: 1,
                  value
                });
              }
            }
          }
        };
        function simpleReadValueFromPointer(pointer) {
          return this["fromWireType"](HEAP32[pointer >>> 2 >>> 0]);
        }
        var EmValType = {
          name: "emscripten::val",
          "fromWireType": (handle2) => {
            var rv = Emval.toValue(handle2);
            __emval_decref(handle2);
            return rv;
          },
          "toWireType": (destructors, value) => Emval.toHandle(value),
          "argPackAdvance": GenericWireTypeSize,
          "readValueFromPointer": simpleReadValueFromPointer,
          destructorFunction: null
        };
        function __embind_register_emval(rawType) {
          rawType >>>= 0;
          return registerType(rawType, EmValType);
        }
        __embind_register_emval.sig = "vp";
        var embindRepr = (v) => {
          if (v === null) {
            return "null";
          }
          var t = typeof v;
          if (t === "object" || t === "array" || t === "function") {
            return v.toString();
          } else {
            return "" + v;
          }
        };
        var floatReadValueFromPointer = (name2, width) => {
          switch (width) {
            case 4:
              return function(pointer) {
                return this["fromWireType"](HEAPF32[pointer >>> 2 >>> 0]);
              };
            case 8:
              return function(pointer) {
                return this["fromWireType"](HEAPF64[pointer >>> 3 >>> 0]);
              };
            default:
              throw new TypeError(`invalid float width (${width}): ${name2}`);
          }
        };
        var __embind_register_float = function(rawType, name2, size) {
          rawType >>>= 0;
          name2 >>>= 0;
          size >>>= 0;
          name2 = readLatin1String(name2);
          registerType(rawType, {
            name: name2,
            "fromWireType": (value) => value,
            "toWireType": (destructors, value) => value,
            "argPackAdvance": GenericWireTypeSize,
            "readValueFromPointer": floatReadValueFromPointer(name2, size),
            destructorFunction: null
          });
        };
        __embind_register_float.sig = "vppp";
        var integerReadValueFromPointer = (name2, width, signed) => {
          switch (width) {
            case 1:
              return signed ? (pointer) => HEAP8[pointer >>> 0 >>> 0] : (pointer) => HEAPU8[pointer >>> 0 >>> 0];
            case 2:
              return signed ? (pointer) => HEAP16[pointer >>> 1 >>> 0] : (pointer) => HEAPU16[pointer >>> 1 >>> 0];
            case 4:
              return signed ? (pointer) => HEAP32[pointer >>> 2 >>> 0] : (pointer) => HEAPU32[pointer >>> 2 >>> 0];
            default:
              throw new TypeError(`invalid integer width (${width}): ${name2}`);
          }
        };
        function __embind_register_integer(primitiveType, name2, size, minRange, maxRange) {
          primitiveType >>>= 0;
          name2 >>>= 0;
          size >>>= 0;
          name2 = readLatin1String(name2);
          if (maxRange === -1) {
            maxRange = 4294967295;
          }
          var fromWireType = (value) => value;
          if (minRange === 0) {
            var bitshift = 32 - 8 * size;
            fromWireType = (value) => value << bitshift >>> bitshift;
          }
          var isUnsignedType = name2.includes("unsigned");
          var checkAssertions = (value, toTypeName) => {
          };
          var toWireType;
          if (isUnsignedType) {
            toWireType = function(destructors, value) {
              checkAssertions(value, this.name);
              return value >>> 0;
            };
          } else {
            toWireType = function(destructors, value) {
              checkAssertions(value, this.name);
              return value;
            };
          }
          registerType(primitiveType, {
            name: name2,
            "fromWireType": fromWireType,
            "toWireType": toWireType,
            "argPackAdvance": GenericWireTypeSize,
            "readValueFromPointer": integerReadValueFromPointer(name2, size, minRange !== 0),
            destructorFunction: null
          });
        }
        __embind_register_integer.sig = "vpppii";
        function __embind_register_memory_view(rawType, dataTypeIndex, name2) {
          rawType >>>= 0;
          name2 >>>= 0;
          var typeMapping = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
          var TA = typeMapping[dataTypeIndex];
          function decodeMemoryView(handle2) {
            var size = HEAPU32[handle2 >>> 2 >>> 0];
            var data2 = HEAPU32[handle2 + 4 >>> 2 >>> 0];
            return new TA(HEAP8.buffer, data2, size);
          }
          name2 = readLatin1String(name2);
          registerType(rawType, {
            name: name2,
            "fromWireType": decodeMemoryView,
            "argPackAdvance": GenericWireTypeSize,
            "readValueFromPointer": decodeMemoryView
          }, {
            ignoreDuplicateRegistrations: true
          });
        }
        __embind_register_memory_view.sig = "vpip";
        function readPointer(pointer) {
          return this["fromWireType"](HEAPU32[pointer >>> 2 >>> 0]);
        }
        function __embind_register_std_string(rawType, name2) {
          rawType >>>= 0;
          name2 >>>= 0;
          name2 = readLatin1String(name2);
          var stdStringIsUTF8 = name2 === "std::string";
          registerType(rawType, {
            name: name2,
            "fromWireType"(value) {
              var length = HEAPU32[value >>> 2 >>> 0];
              var payload = value + 4;
              var str;
              if (stdStringIsUTF8) {
                var decodeStartPtr = payload;
                for (var i2 = 0; i2 <= length; ++i2) {
                  var currentBytePtr = payload + i2;
                  if (i2 == length || HEAPU8[currentBytePtr >>> 0] == 0) {
                    var maxRead = currentBytePtr - decodeStartPtr;
                    var stringSegment = UTF8ToString(decodeStartPtr, maxRead);
                    if (str === void 0) {
                      str = stringSegment;
                    } else {
                      str += String.fromCharCode(0);
                      str += stringSegment;
                    }
                    decodeStartPtr = currentBytePtr + 1;
                  }
                }
              } else {
                var a = new Array(length);
                for (var i2 = 0; i2 < length; ++i2) {
                  a[i2] = String.fromCharCode(HEAPU8[payload + i2 >>> 0]);
                }
                str = a.join("");
              }
              _free(value);
              return str;
            },
            "toWireType"(destructors, value) {
              if (value instanceof ArrayBuffer) {
                value = new Uint8Array(value);
              }
              var length;
              var valueIsOfTypeString = typeof value == "string";
              if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) {
                throwBindingError("Cannot pass non-string to std::string");
              }
              if (stdStringIsUTF8 && valueIsOfTypeString) {
                length = lengthBytesUTF8(value);
              } else {
                length = value.length;
              }
              var base = _malloc(4 + length + 1);
              var ptr2 = base + 4;
              HEAPU32[base >>> 2 >>> 0] = length;
              if (stdStringIsUTF8 && valueIsOfTypeString) {
                stringToUTF8(value, ptr2, length + 1);
              } else {
                if (valueIsOfTypeString) {
                  for (var i2 = 0; i2 < length; ++i2) {
                    var charCode = value.charCodeAt(i2);
                    if (charCode > 255) {
                      _free(ptr2);
                      throwBindingError("String has UTF-16 code units that do not fit in 8 bits");
                    }
                    HEAPU8[ptr2 + i2 >>> 0] = charCode;
                  }
                } else {
                  for (var i2 = 0; i2 < length; ++i2) {
                    HEAPU8[ptr2 + i2 >>> 0] = value[i2];
                  }
                }
              }
              if (destructors !== null) {
                destructors.push(_free, base);
              }
              return base;
            },
            "argPackAdvance": GenericWireTypeSize,
            "readValueFromPointer": readPointer,
            destructorFunction(ptr2) {
              _free(ptr2);
            }
          });
        }
        __embind_register_std_string.sig = "vpp";
        var UTF16Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf-16le") : void 0;
        var UTF16ToString = (ptr2, maxBytesToRead) => {
          var endPtr = ptr2;
          var idx = endPtr >> 1;
          var maxIdx = idx + maxBytesToRead / 2;
          while (!(idx >= maxIdx) && HEAPU16[idx >>> 0])
            ++idx;
          endPtr = idx << 1;
          if (endPtr - ptr2 > 32 && UTF16Decoder)
            return UTF16Decoder.decode(HEAPU8.subarray(ptr2 >>> 0, endPtr >>> 0));
          var str = "";
          for (var i2 = 0; !(i2 >= maxBytesToRead / 2); ++i2) {
            var codeUnit = HEAP16[ptr2 + i2 * 2 >>> 1 >>> 0];
            if (codeUnit == 0)
              break;
            str += String.fromCharCode(codeUnit);
          }
          return str;
        };
        var stringToUTF16 = (str, outPtr, maxBytesToWrite) => {
          maxBytesToWrite ?? (maxBytesToWrite = 2147483647);
          if (maxBytesToWrite < 2)
            return 0;
          maxBytesToWrite -= 2;
          var startPtr = outPtr;
          var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;
          for (var i2 = 0; i2 < numCharsToWrite; ++i2) {
            var codeUnit = str.charCodeAt(i2);
            HEAP16[outPtr >>> 1 >>> 0] = codeUnit;
            outPtr += 2;
          }
          HEAP16[outPtr >>> 1 >>> 0] = 0;
          return outPtr - startPtr;
        };
        var lengthBytesUTF16 = (str) => str.length * 2;
        var UTF32ToString = (ptr2, maxBytesToRead) => {
          var i2 = 0;
          var str = "";
          while (!(i2 >= maxBytesToRead / 4)) {
            var utf32 = HEAP32[ptr2 + i2 * 4 >>> 2 >>> 0];
            if (utf32 == 0)
              break;
            ++i2;
            if (utf32 >= 65536) {
              var ch = utf32 - 65536;
              str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
            } else {
              str += String.fromCharCode(utf32);
            }
          }
          return str;
        };
        var stringToUTF32 = (str, outPtr, maxBytesToWrite) => {
          outPtr >>>= 0;
          maxBytesToWrite ?? (maxBytesToWrite = 2147483647);
          if (maxBytesToWrite < 4)
            return 0;
          var startPtr = outPtr;
          var endPtr = startPtr + maxBytesToWrite - 4;
          for (var i2 = 0; i2 < str.length; ++i2) {
            var codeUnit = str.charCodeAt(i2);
            if (codeUnit >= 55296 && codeUnit <= 57343) {
              var trailSurrogate = str.charCodeAt(++i2);
              codeUnit = 65536 + ((codeUnit & 1023) << 10) | trailSurrogate & 1023;
            }
            HEAP32[outPtr >>> 2 >>> 0] = codeUnit;
            outPtr += 4;
            if (outPtr + 4 > endPtr)
              break;
          }
          HEAP32[outPtr >>> 2 >>> 0] = 0;
          return outPtr - startPtr;
        };
        var lengthBytesUTF32 = (str) => {
          var len2 = 0;
          for (var i2 = 0; i2 < str.length; ++i2) {
            var codeUnit = str.charCodeAt(i2);
            if (codeUnit >= 55296 && codeUnit <= 57343)
              ++i2;
            len2 += 4;
          }
          return len2;
        };
        var __embind_register_std_wstring = function(rawType, charSize, name2) {
          rawType >>>= 0;
          charSize >>>= 0;
          name2 >>>= 0;
          name2 = readLatin1String(name2);
          var decodeString, encodeString, getHeap, lengthBytesUTF, shift;
          if (charSize === 2) {
            decodeString = UTF16ToString;
            encodeString = stringToUTF16;
            lengthBytesUTF = lengthBytesUTF16;
            getHeap = () => HEAPU16;
            shift = 1;
          } else if (charSize === 4) {
            decodeString = UTF32ToString;
            encodeString = stringToUTF32;
            lengthBytesUTF = lengthBytesUTF32;
            getHeap = () => HEAPU32;
            shift = 2;
          }
          registerType(rawType, {
            name: name2,
            "fromWireType": (value) => {
              var length = HEAPU32[value >>> 2 >>> 0];
              var HEAP2 = getHeap();
              var str;
              var decodeStartPtr = value + 4;
              for (var i2 = 0; i2 <= length; ++i2) {
                var currentBytePtr = value + 4 + i2 * charSize;
                if (i2 == length || HEAP2[currentBytePtr >>> shift] == 0) {
                  var maxReadBytes = currentBytePtr - decodeStartPtr;
                  var stringSegment = decodeString(decodeStartPtr, maxReadBytes);
                  if (str === void 0) {
                    str = stringSegment;
                  } else {
                    str += String.fromCharCode(0);
                    str += stringSegment;
                  }
                  decodeStartPtr = currentBytePtr + charSize;
                }
              }
              _free(value);
              return str;
            },
            "toWireType": (destructors, value) => {
              if (!(typeof value == "string")) {
                throwBindingError(`Cannot pass non-string to C++ string type ${name2}`);
              }
              var length = lengthBytesUTF(value);
              var ptr2 = _malloc(4 + length + charSize);
              HEAPU32[ptr2 >>> 2 >>> 0] = length >> shift;
              encodeString(value, ptr2 + 4, length + charSize);
              if (destructors !== null) {
                destructors.push(_free, ptr2);
              }
              return ptr2;
            },
            "argPackAdvance": GenericWireTypeSize,
            "readValueFromPointer": simpleReadValueFromPointer,
            destructorFunction(ptr2) {
              _free(ptr2);
            }
          });
        };
        __embind_register_std_wstring.sig = "vppp";
        var __embind_register_void = function(rawType, name2) {
          rawType >>>= 0;
          name2 >>>= 0;
          name2 = readLatin1String(name2);
          registerType(rawType, {
            isVoid: true,
            name: name2,
            "argPackAdvance": 0,
            "fromWireType": () => void 0,
            "toWireType": (destructors, o) => void 0
          });
        };
        __embind_register_void.sig = "vpp";
        var handleException = (e) => {
          if (e instanceof ExitStatus || e == "unwind") {
            return EXITSTATUS;
          }
          quit_(1, e);
        };
        var runtimeKeepaliveCounter = 0;
        var keepRuntimeAlive = () => noExitRuntime || runtimeKeepaliveCounter > 0;
        var _proc_exit = (code) => {
          var _a;
          EXITSTATUS = code;
          if (!keepRuntimeAlive()) {
            (_a = Module["onExit"]) == null ? void 0 : _a.call(Module, code);
            ABORT = true;
          }
          quit_(code, new ExitStatus(code));
        };
        _proc_exit.sig = "vi";
        var exitJS = (status, implicit) => {
          EXITSTATUS = status;
          _proc_exit(status);
        };
        var _exit = exitJS;
        _exit.sig = "vi";
        var maybeExit = () => {
          if (!keepRuntimeAlive()) {
            try {
              _exit(EXITSTATUS);
            } catch (e) {
              handleException(e);
            }
          }
        };
        var callUserCallback = (func2) => {
          if (ABORT) {
            return;
          }
          try {
            func2();
            maybeExit();
          } catch (e) {
            handleException(e);
          }
        };
        function __emscripten_dlopen_js(handle2, onsuccess, onerror2, user_data) {
          handle2 >>>= 0;
          onsuccess >>>= 0;
          onerror2 >>>= 0;
          user_data >>>= 0;
          function errorCallback(e) {
            var filename = UTF8ToString(handle2 + 36);
            dlSetError(`'Could not load dynamic lib: ${filename}
${e}`);
            callUserCallback(() => getWasmTableEntry(onerror2)(handle2, user_data));
          }
          function successCallback() {
            callUserCallback(() => getWasmTableEntry(onsuccess)(handle2, user_data));
          }
          var promise = dlopenInternal(handle2, {
            loadAsync: true
          });
          if (promise) {
            promise.then(successCallback, errorCallback);
          } else {
            errorCallback();
          }
        }
        __emscripten_dlopen_js.sig = "vpppp";
        var nowIsMonotonic = 1;
        var __emscripten_get_now_is_monotonic = () => nowIsMonotonic;
        __emscripten_get_now_is_monotonic.sig = "i";
        function __emscripten_get_progname(str, len2) {
          str >>>= 0;
          stringToUTF8(thisProgram, str, len2);
        }
        __emscripten_get_progname.sig = "vpi";
        function __emscripten_lookup_name(name2) {
          name2 >>>= 0;
          var nameString = UTF8ToString(name2);
          return inetPton4(DNS.lookup_name(nameString));
        }
        __emscripten_lookup_name.sig = "ip";
        var __emscripten_runtime_keepalive_clear = () => {
          noExitRuntime = false;
          runtimeKeepaliveCounter = 0;
        };
        __emscripten_runtime_keepalive_clear.sig = "v";
        function __emscripten_set_offscreencanvas_size(target, width, height) {
          target >>>= 0;
          return -1;
        }
        __emscripten_set_offscreencanvas_size.sig = "ipii";
        function __emscripten_system(command) {
          command >>>= 0;
          if (ENVIRONMENT_IS_NODE) {
            if (!command)
              return 1;
            var cmdstr = UTF8ToString(command);
            if (!cmdstr.length)
              return 0;
            var cp = ["child_process"].map(require);
            var ret = cp.spawnSync(cmdstr, [], {
              shell: true,
              stdio: "inherit"
            });
            var _W_EXITCODE = (ret2, sig) => ret2 << 8 | sig;
            if (ret.status === null) {
              var signalToNumber = (sig) => {
                switch (sig) {
                  case "SIGHUP":
                    return 1;
                  case "SIGINT":
                    return 2;
                  case "SIGQUIT":
                    return 3;
                  case "SIGFPE":
                    return 8;
                  case "SIGKILL":
                    return 9;
                  case "SIGALRM":
                    return 14;
                  case "SIGTERM":
                    return 15;
                }
                return 2;
              };
              return _W_EXITCODE(0, signalToNumber(ret.signal));
            }
            return _W_EXITCODE(ret.status, 0);
          }
          if (!command)
            return 0;
          return -52;
        }
        __emscripten_system.sig = "ip";
        var __emscripten_throw_longjmp = () => {
          throw Infinity;
        };
        __emscripten_throw_longjmp.sig = "v";
        function __gmtime_js(time_low, time_high, tmPtr) {
          var time = convertI32PairToI53Checked(time_low, time_high);
          tmPtr >>>= 0;
          var date = new Date(time * 1e3);
          HEAP32[tmPtr >>> 2 >>> 0] = date.getUTCSeconds();
          HEAP32[tmPtr + 4 >>> 2 >>> 0] = date.getUTCMinutes();
          HEAP32[tmPtr + 8 >>> 2 >>> 0] = date.getUTCHours();
          HEAP32[tmPtr + 12 >>> 2 >>> 0] = date.getUTCDate();
          HEAP32[tmPtr + 16 >>> 2 >>> 0] = date.getUTCMonth();
          HEAP32[tmPtr + 20 >>> 2 >>> 0] = date.getUTCFullYear() - 1900;
          HEAP32[tmPtr + 24 >>> 2 >>> 0] = date.getUTCDay();
          var start2 = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
          var yday = (date.getTime() - start2) / (1e3 * 60 * 60 * 24) | 0;
          HEAP32[tmPtr + 28 >>> 2 >>> 0] = yday;
        }
        __gmtime_js.sig = "viip";
        var isLeapYear = (year) => year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
        var MONTH_DAYS_LEAP_CUMULATIVE = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
        var MONTH_DAYS_REGULAR_CUMULATIVE = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
        var ydayFromDate = (date) => {
          var leap = isLeapYear(date.getFullYear());
          var monthDaysCumulative = leap ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE;
          var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1;
          return yday;
        };
        function __localtime_js(time_low, time_high, tmPtr) {
          var time = convertI32PairToI53Checked(time_low, time_high);
          tmPtr >>>= 0;
          var date = new Date(time * 1e3);
          HEAP32[tmPtr >>> 2 >>> 0] = date.getSeconds();
          HEAP32[tmPtr + 4 >>> 2 >>> 0] = date.getMinutes();
          HEAP32[tmPtr + 8 >>> 2 >>> 0] = date.getHours();
          HEAP32[tmPtr + 12 >>> 2 >>> 0] = date.getDate();
          HEAP32[tmPtr + 16 >>> 2 >>> 0] = date.getMonth();
          HEAP32[tmPtr + 20 >>> 2 >>> 0] = date.getFullYear() - 1900;
          HEAP32[tmPtr + 24 >>> 2 >>> 0] = date.getDay();
          var yday = ydayFromDate(date) | 0;
          HEAP32[tmPtr + 28 >>> 2 >>> 0] = yday;
          HEAP32[tmPtr + 36 >>> 2 >>> 0] = -(date.getTimezoneOffset() * 60);
          var start2 = new Date(date.getFullYear(), 0, 1);
          var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
          var winterOffset = start2.getTimezoneOffset();
          var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;
          HEAP32[tmPtr + 32 >>> 2 >>> 0] = dst;
        }
        __localtime_js.sig = "viip";
        var __mktime_js = function(tmPtr) {
          tmPtr >>>= 0;
          var ret = (() => {
            var date = new Date(HEAP32[tmPtr + 20 >>> 2 >>> 0] + 1900, HEAP32[tmPtr + 16 >>> 2 >>> 0], HEAP32[tmPtr + 12 >>> 2 >>> 0], HEAP32[tmPtr + 8 >>> 2 >>> 0], HEAP32[tmPtr + 4 >>> 2 >>> 0], HEAP32[tmPtr >>> 2 >>> 0], 0);
            var dst = HEAP32[tmPtr + 32 >>> 2 >>> 0];
            var guessedOffset = date.getTimezoneOffset();
            var start2 = new Date(date.getFullYear(), 0, 1);
            var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
            var winterOffset = start2.getTimezoneOffset();
            var dstOffset = Math.min(winterOffset, summerOffset);
            if (dst < 0) {
              HEAP32[tmPtr + 32 >>> 2 >>> 0] = Number(summerOffset != winterOffset && dstOffset == guessedOffset);
            } else if (dst > 0 != (dstOffset == guessedOffset)) {
              var nonDstOffset = Math.max(winterOffset, summerOffset);
              var trueOffset = dst > 0 ? dstOffset : nonDstOffset;
              date.setTime(date.getTime() + (trueOffset - guessedOffset) * 6e4);
            }
            HEAP32[tmPtr + 24 >>> 2 >>> 0] = date.getDay();
            var yday = ydayFromDate(date) | 0;
            HEAP32[tmPtr + 28 >>> 2 >>> 0] = yday;
            HEAP32[tmPtr >>> 2 >>> 0] = date.getSeconds();
            HEAP32[tmPtr + 4 >>> 2 >>> 0] = date.getMinutes();
            HEAP32[tmPtr + 8 >>> 2 >>> 0] = date.getHours();
            HEAP32[tmPtr + 12 >>> 2 >>> 0] = date.getDate();
            HEAP32[tmPtr + 16 >>> 2 >>> 0] = date.getMonth();
            HEAP32[tmPtr + 20 >>> 2 >>> 0] = date.getYear();
            var timeMs = date.getTime();
            if (isNaN(timeMs)) {
              return -1;
            }
            return timeMs / 1e3;
          })();
          return setTempRet0((tempDouble = ret, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)), ret >>> 0;
        };
        __mktime_js.sig = "ip";
        function __mmap_js(len2, prot, flags2, fd, offset_low, offset_high, allocated, addr2) {
          len2 >>>= 0;
          var offset = convertI32PairToI53Checked(offset_low, offset_high);
          allocated >>>= 0;
          addr2 >>>= 0;
          try {
            if (isNaN(offset))
              return 61;
            var stream = SYSCALLS.getStreamFromFD(fd);
            var res = FS.mmap(stream, len2, offset, prot, flags2);
            var ptr2 = res.ptr;
            HEAP32[allocated >>> 2 >>> 0] = res.allocated;
            HEAPU32[addr2 >>> 2 >>> 0] = ptr2;
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        __mmap_js.sig = "ipiiiiipp";
        function __msync_js(addr2, len2, prot, flags2, fd, offset_low, offset_high) {
          addr2 >>>= 0;
          len2 >>>= 0;
          var offset = convertI32PairToI53Checked(offset_low, offset_high);
          try {
            if (isNaN(offset))
              return 61;
            SYSCALLS.doMsync(addr2, SYSCALLS.getStreamFromFD(fd), len2, flags2, offset);
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        __msync_js.sig = "ippiiiii";
        function __munmap_js(addr2, len2, prot, flags2, fd, offset_low, offset_high) {
          addr2 >>>= 0;
          len2 >>>= 0;
          var offset = convertI32PairToI53Checked(offset_low, offset_high);
          try {
            if (isNaN(offset))
              return 61;
            var stream = SYSCALLS.getStreamFromFD(fd);
            if (prot & 2) {
              SYSCALLS.doMsync(addr2, stream, len2, flags2, offset);
            }
            FS.munmap(stream);
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        __munmap_js.sig = "ippiiiii";
        var timers = {};
        var _emscripten_get_now;
        _emscripten_get_now = () => performance.now();
        _emscripten_get_now.sig = "d";
        var __setitimer_js = (which, timeout_ms) => {
          if (timers[which]) {
            clearTimeout(timers[which].id);
            delete timers[which];
          }
          if (!timeout_ms)
            return 0;
          var id = setTimeout(() => {
            delete timers[which];
            callUserCallback(() => __emscripten_timeout(which, _emscripten_get_now()));
          }, timeout_ms);
          timers[which] = {
            id,
            timeout_ms
          };
          return 0;
        };
        __setitimer_js.sig = "iid";
        var __timegm_js = function(tmPtr) {
          tmPtr >>>= 0;
          var ret = (() => {
            var time = Date.UTC(HEAP32[tmPtr + 20 >>> 2 >>> 0] + 1900, HEAP32[tmPtr + 16 >>> 2 >>> 0], HEAP32[tmPtr + 12 >>> 2 >>> 0], HEAP32[tmPtr + 8 >>> 2 >>> 0], HEAP32[tmPtr + 4 >>> 2 >>> 0], HEAP32[tmPtr >>> 2 >>> 0], 0);
            var date = new Date(time);
            HEAP32[tmPtr + 24 >>> 2 >>> 0] = date.getUTCDay();
            var start2 = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
            var yday = (date.getTime() - start2) / (1e3 * 60 * 60 * 24) | 0;
            HEAP32[tmPtr + 28 >>> 2 >>> 0] = yday;
            return date.getTime() / 1e3;
          })();
          return setTempRet0((tempDouble = ret, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)), ret >>> 0;
        };
        __timegm_js.sig = "ip";
        var stringToNewUTF8 = (str) => {
          var size = lengthBytesUTF8(str) + 1;
          var ret = _malloc(size);
          if (ret)
            stringToUTF8(str, ret, size);
          return ret;
        };
        function __tzset_js(timezone, daylight, tzname) {
          timezone >>>= 0;
          daylight >>>= 0;
          tzname >>>= 0;
          var currentYear = (/* @__PURE__ */ new Date()).getFullYear();
          var winter = new Date(currentYear, 0, 1);
          var summer = new Date(currentYear, 6, 1);
          var winterOffset = winter.getTimezoneOffset();
          var summerOffset = summer.getTimezoneOffset();
          var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
          HEAPU32[timezone >>> 2 >>> 0] = stdTimezoneOffset * 60;
          HEAP32[daylight >>> 2 >>> 0] = Number(winterOffset != summerOffset);
          function extractZone(date) {
            var match = date.toTimeString().match(/\(([A-Za-z ]+)\)$/);
            return match ? match[1] : "GMT";
          }
          var winterName = extractZone(winter);
          var summerName = extractZone(summer);
          var winterNamePtr = stringToNewUTF8(winterName);
          var summerNamePtr = stringToNewUTF8(summerName);
          if (summerOffset < winterOffset) {
            HEAPU32[tzname >>> 2 >>> 0] = winterNamePtr;
            HEAPU32[tzname + 4 >>> 2 >>> 0] = summerNamePtr;
          } else {
            HEAPU32[tzname >>> 2 >>> 0] = summerNamePtr;
            HEAPU32[tzname + 4 >>> 2 >>> 0] = winterNamePtr;
          }
        }
        __tzset_js.sig = "vppp";
        var _abort = () => {
          abort("");
        };
        _abort.sig = "v";
        var _emscripten_set_main_loop_timing = (mode, value) => {
          Browser.mainLoop.timingMode = mode;
          Browser.mainLoop.timingValue = value;
          if (!Browser.mainLoop.func) {
            return 1;
          }
          if (!Browser.mainLoop.running) {
            Browser.mainLoop.running = true;
          }
          if (mode == 0) {
            Browser.mainLoop.scheduler = function Browser_mainLoop_scheduler_setTimeout() {
              var timeUntilNextTick = Math.max(0, Browser.mainLoop.tickStartTime + value - _emscripten_get_now()) | 0;
              setTimeout(Browser.mainLoop.runner, timeUntilNextTick);
            };
            Browser.mainLoop.method = "timeout";
          } else if (mode == 1) {
            Browser.mainLoop.scheduler = function Browser_mainLoop_scheduler_rAF() {
              Browser.requestAnimationFrame(Browser.mainLoop.runner);
            };
            Browser.mainLoop.method = "rAF";
          } else if (mode == 2) {
            if (typeof Browser.setImmediate == "undefined") {
              if (typeof setImmediate == "undefined") {
                var setImmediates = [];
                var emscriptenMainLoopMessageId = "setimmediate";
                var Browser_setImmediate_messageHandler = (event2) => {
                  if (event2.data === emscriptenMainLoopMessageId || event2.data.target === emscriptenMainLoopMessageId) {
                    event2.stopPropagation();
                    setImmediates.shift()();
                  }
                };
                addEventListener("message", Browser_setImmediate_messageHandler, true);
                Browser.setImmediate = function Browser_emulated_setImmediate(func2) {
                  setImmediates.push(func2);
                  if (ENVIRONMENT_IS_WORKER) {
                    if (Module["setImmediates"] === void 0)
                      Module["setImmediates"] = [];
                    Module["setImmediates"].push(func2);
                    postMessage({
                      target: emscriptenMainLoopMessageId
                    });
                  } else
                    postMessage(emscriptenMainLoopMessageId, "*");
                };
              } else {
                Browser.setImmediate = setImmediate;
              }
            }
            Browser.mainLoop.scheduler = function Browser_mainLoop_scheduler_setImmediate() {
              Browser.setImmediate(Browser.mainLoop.runner);
            };
            Browser.mainLoop.method = "immediate";
          }
          return 0;
        };
        _emscripten_set_main_loop_timing.sig = "iii";
        var setMainLoop = (browserIterationFunc, fps, simulateInfiniteLoop, arg, noSetTiming) => {
          assert(!Browser.mainLoop.func, "emscripten_set_main_loop: there can only be one main loop function at once: call emscripten_cancel_main_loop to cancel the previous one before setting a new one with different parameters.");
          Browser.mainLoop.func = browserIterationFunc;
          Browser.mainLoop.arg = arg;
          var thisMainLoopId = Browser.mainLoop.currentlyRunningMainloop;
          function checkIsRunning() {
            if (thisMainLoopId < Browser.mainLoop.currentlyRunningMainloop) {
              return false;
            }
            return true;
          }
          Browser.mainLoop.running = false;
          Browser.mainLoop.runner = function Browser_mainLoop_runner() {
            var _a, _b;
            if (ABORT)
              return;
            if (Browser.mainLoop.queue.length > 0) {
              var start2 = Date.now();
              var blocker = Browser.mainLoop.queue.shift();
              blocker.func(blocker.arg);
              if (Browser.mainLoop.remainingBlockers) {
                var remaining = Browser.mainLoop.remainingBlockers;
                var next = remaining % 1 == 0 ? remaining - 1 : Math.floor(remaining);
                if (blocker.counted) {
                  Browser.mainLoop.remainingBlockers = next;
                } else {
                  next = next + 0.5;
                  Browser.mainLoop.remainingBlockers = (8 * remaining + next) / 9;
                }
              }
              Browser.mainLoop.updateStatus();
              if (!checkIsRunning())
                return;
              setTimeout(Browser.mainLoop.runner, 0);
              return;
            }
            if (!checkIsRunning())
              return;
            Browser.mainLoop.currentFrameNumber = Browser.mainLoop.currentFrameNumber + 1 | 0;
            if (Browser.mainLoop.timingMode == 1 && Browser.mainLoop.timingValue > 1 && Browser.mainLoop.currentFrameNumber % Browser.mainLoop.timingValue != 0) {
              Browser.mainLoop.scheduler();
              return;
            } else if (Browser.mainLoop.timingMode == 0) {
              Browser.mainLoop.tickStartTime = _emscripten_get_now();
            }
            Browser.mainLoop.runIter(browserIterationFunc);
            if (!checkIsRunning())
              return;
            if (typeof SDL == "object")
              (_b = (_a = SDL.audio) == null ? void 0 : _a.queueNewAudioData) == null ? void 0 : _b.call(_a);
            Browser.mainLoop.scheduler();
          };
          if (!noSetTiming) {
            if (fps && fps > 0) {
              _emscripten_set_main_loop_timing(0, 1e3 / fps);
            } else {
              _emscripten_set_main_loop_timing(1, 1);
            }
            Browser.mainLoop.scheduler();
          }
          if (simulateInfiniteLoop) {
            throw "unwind";
          }
        };
        var safeSetTimeout = (func2, timeout) => setTimeout(() => {
          callUserCallback(func2);
        }, timeout);
        var warnOnce = (text) => {
          warnOnce.shown || (warnOnce.shown = {});
          if (!warnOnce.shown[text]) {
            warnOnce.shown[text] = 1;
            if (ENVIRONMENT_IS_NODE)
              text = "warning: " + text;
            err(text);
          }
        };
        var Browser = {
          mainLoop: {
            running: false,
            scheduler: null,
            method: "",
            currentlyRunningMainloop: 0,
            func: null,
            arg: 0,
            timingMode: 0,
            timingValue: 0,
            currentFrameNumber: 0,
            queue: [],
            pause() {
              Browser.mainLoop.scheduler = null;
              Browser.mainLoop.currentlyRunningMainloop++;
            },
            resume() {
              Browser.mainLoop.currentlyRunningMainloop++;
              var timingMode = Browser.mainLoop.timingMode;
              var timingValue = Browser.mainLoop.timingValue;
              var func2 = Browser.mainLoop.func;
              Browser.mainLoop.func = null;
              setMainLoop(func2, 0, false, Browser.mainLoop.arg, true);
              _emscripten_set_main_loop_timing(timingMode, timingValue);
              Browser.mainLoop.scheduler();
            },
            updateStatus() {
              if (Module["setStatus"]) {
                var message = Module["statusMessage"] || "Please wait...";
                var remaining = Browser.mainLoop.remainingBlockers;
                var expected = Browser.mainLoop.expectedBlockers;
                if (remaining) {
                  if (remaining < expected) {
                    Module["setStatus"](message + " (" + (expected - remaining) + "/" + expected + ")");
                  } else {
                    Module["setStatus"](message);
                  }
                } else {
                  Module["setStatus"]("");
                }
              }
            },
            runIter(func2) {
              var _a;
              if (ABORT)
                return;
              if (Module["preMainLoop"]) {
                var preRet = Module["preMainLoop"]();
                if (preRet === false) {
                  return;
                }
              }
              callUserCallback(func2);
              (_a = Module["postMainLoop"]) == null ? void 0 : _a.call(Module);
            }
          },
          isFullscreen: false,
          pointerLock: false,
          moduleContextCreatedCallbacks: [],
          workers: [],
          init() {
            if (Browser.initted)
              return;
            Browser.initted = true;
            var imagePlugin = {};
            imagePlugin["canHandle"] = function imagePlugin_canHandle(name2) {
              return !Module.noImageDecoding && /\.(jpg|jpeg|png|bmp)$/i.test(name2);
            };
            imagePlugin["handle"] = function imagePlugin_handle(byteArray, name2, onload2, onerror2) {
              var b = new Blob([byteArray], {
                type: Browser.getMimetype(name2)
              });
              if (b.size !== byteArray.length) {
                b = new Blob([new Uint8Array(byteArray).buffer], {
                  type: Browser.getMimetype(name2)
                });
              }
              var url2 = URL.createObjectURL(b);
              var img = new Image();
              img.onload = () => {
                assert(img.complete, `Image ${name2} could not be decoded`);
                var canvas2 = document.createElement("canvas");
                canvas2.width = img.width;
                canvas2.height = img.height;
                var ctx = canvas2.getContext("2d");
                ctx.drawImage(img, 0, 0);
                preloadedImages[name2] = canvas2;
                URL.revokeObjectURL(url2);
                onload2 == null ? void 0 : onload2(byteArray);
              };
              img.onerror = (event2) => {
                err(`Image ${url2} could not be decoded`);
                onerror2 == null ? void 0 : onerror2();
              };
              img.src = url2;
            };
            preloadPlugins.push(imagePlugin);
            var audioPlugin = {};
            audioPlugin["canHandle"] = function audioPlugin_canHandle(name2) {
              return !Module.noAudioDecoding && name2.substr(-4) in {
                ".ogg": 1,
                ".wav": 1,
                ".mp3": 1
              };
            };
            audioPlugin["handle"] = function audioPlugin_handle(byteArray, name2, onload2, onerror2) {
              var done = false;
              function finish(audio2) {
                if (done)
                  return;
                done = true;
                preloadedAudios[name2] = audio2;
                onload2 == null ? void 0 : onload2(byteArray);
              }
              function fail() {
                if (done)
                  return;
                done = true;
                preloadedAudios[name2] = new Audio();
                onerror2 == null ? void 0 : onerror2();
              }
              var b = new Blob([byteArray], {
                type: Browser.getMimetype(name2)
              });
              var url2 = URL.createObjectURL(b);
              var audio = new Audio();
              audio.addEventListener("canplaythrough", () => finish(audio), false);
              audio.onerror = function audio_onerror(event2) {
                if (done)
                  return;
                err(`warning: browser could not fully decode audio ${name2}, trying slower base64 approach`);
                function encode64(data2) {
                  var BASE = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
                  var PAD = "=";
                  var ret = "";
                  var leftchar = 0;
                  var leftbits = 0;
                  for (var i2 = 0; i2 < data2.length; i2++) {
                    leftchar = leftchar << 8 | data2[i2];
                    leftbits += 8;
                    while (leftbits >= 6) {
                      var curr = leftchar >> leftbits - 6 & 63;
                      leftbits -= 6;
                      ret += BASE[curr];
                    }
                  }
                  if (leftbits == 2) {
                    ret += BASE[(leftchar & 3) << 4];
                    ret += PAD + PAD;
                  } else if (leftbits == 4) {
                    ret += BASE[(leftchar & 15) << 2];
                    ret += PAD;
                  }
                  return ret;
                }
                audio.src = "data:audio/x-" + name2.substr(-3) + ";base64," + encode64(byteArray);
                finish(audio);
              };
              audio.src = url2;
              safeSetTimeout(() => {
                finish(audio);
              }, 1e4);
            };
            preloadPlugins.push(audioPlugin);
            function pointerLockChange() {
              Browser.pointerLock = document["pointerLockElement"] === Module["canvas"] || document["mozPointerLockElement"] === Module["canvas"] || document["webkitPointerLockElement"] === Module["canvas"] || document["msPointerLockElement"] === Module["canvas"];
            }
            var canvas = Module["canvas"];
            if (canvas) {
              canvas.requestPointerLock = canvas["requestPointerLock"] || canvas["mozRequestPointerLock"] || canvas["webkitRequestPointerLock"] || canvas["msRequestPointerLock"] || (() => {
              });
              canvas.exitPointerLock = document["exitPointerLock"] || document["mozExitPointerLock"] || document["webkitExitPointerLock"] || document["msExitPointerLock"] || (() => {
              });
              canvas.exitPointerLock = canvas.exitPointerLock.bind(document);
              document.addEventListener("pointerlockchange", pointerLockChange, false);
              document.addEventListener("mozpointerlockchange", pointerLockChange, false);
              document.addEventListener("webkitpointerlockchange", pointerLockChange, false);
              document.addEventListener("mspointerlockchange", pointerLockChange, false);
              if (Module["elementPointerLock"]) {
                canvas.addEventListener("click", (ev) => {
                  if (!Browser.pointerLock && Module["canvas"].requestPointerLock) {
                    Module["canvas"].requestPointerLock();
                    ev.preventDefault();
                  }
                }, false);
              }
            }
          },
          createContext(canvas, useWebGL, setInModule, webGLContextAttributes) {
            if (useWebGL && Module.ctx && canvas == Module.canvas)
              return Module.ctx;
            var ctx;
            var contextHandle;
            if (useWebGL) {
              var contextAttributes = {
                antialias: false,
                alpha: false,
                majorVersion: 1
              };
              if (webGLContextAttributes) {
                for (var attribute in webGLContextAttributes) {
                  contextAttributes[attribute] = webGLContextAttributes[attribute];
                }
              }
              if (typeof GL != "undefined") {
                contextHandle = GL.createContext(canvas, contextAttributes);
                if (contextHandle) {
                  ctx = GL.getContext(contextHandle).GLctx;
                }
              }
            } else {
              ctx = canvas.getContext("2d");
            }
            if (!ctx)
              return null;
            if (setInModule) {
              if (!useWebGL)
                assert(typeof GLctx == "undefined", "cannot set in module if GLctx is used, but we are a non-GL context that would replace it");
              Module.ctx = ctx;
              if (useWebGL)
                GL.makeContextCurrent(contextHandle);
              Module.useWebGL = useWebGL;
              Browser.moduleContextCreatedCallbacks.forEach((callback) => callback());
              Browser.init();
            }
            return ctx;
          },
          destroyContext(canvas, useWebGL, setInModule) {
          },
          fullscreenHandlersInstalled: false,
          lockPointer: void 0,
          resizeCanvas: void 0,
          requestFullscreen(lockPointer, resizeCanvas) {
            Browser.lockPointer = lockPointer;
            Browser.resizeCanvas = resizeCanvas;
            if (typeof Browser.lockPointer == "undefined")
              Browser.lockPointer = true;
            if (typeof Browser.resizeCanvas == "undefined")
              Browser.resizeCanvas = false;
            var canvas = Module["canvas"];
            function fullscreenChange() {
              var _a, _b;
              Browser.isFullscreen = false;
              var canvasContainer2 = canvas.parentNode;
              if ((document["fullscreenElement"] || document["mozFullScreenElement"] || document["msFullscreenElement"] || document["webkitFullscreenElement"] || document["webkitCurrentFullScreenElement"]) === canvasContainer2) {
                canvas.exitFullscreen = Browser.exitFullscreen;
                if (Browser.lockPointer)
                  canvas.requestPointerLock();
                Browser.isFullscreen = true;
                if (Browser.resizeCanvas) {
                  Browser.setFullscreenCanvasSize();
                } else {
                  Browser.updateCanvasDimensions(canvas);
                }
              } else {
                canvasContainer2.parentNode.insertBefore(canvas, canvasContainer2);
                canvasContainer2.parentNode.removeChild(canvasContainer2);
                if (Browser.resizeCanvas) {
                  Browser.setWindowedCanvasSize();
                } else {
                  Browser.updateCanvasDimensions(canvas);
                }
              }
              (_a = Module["onFullScreen"]) == null ? void 0 : _a.call(Module, Browser.isFullscreen);
              (_b = Module["onFullscreen"]) == null ? void 0 : _b.call(Module, Browser.isFullscreen);
            }
            if (!Browser.fullscreenHandlersInstalled) {
              Browser.fullscreenHandlersInstalled = true;
              document.addEventListener("fullscreenchange", fullscreenChange, false);
              document.addEventListener("mozfullscreenchange", fullscreenChange, false);
              document.addEventListener("webkitfullscreenchange", fullscreenChange, false);
              document.addEventListener("MSFullscreenChange", fullscreenChange, false);
            }
            var canvasContainer = document.createElement("div");
            canvas.parentNode.insertBefore(canvasContainer, canvas);
            canvasContainer.appendChild(canvas);
            canvasContainer.requestFullscreen = canvasContainer["requestFullscreen"] || canvasContainer["mozRequestFullScreen"] || canvasContainer["msRequestFullscreen"] || (canvasContainer["webkitRequestFullscreen"] ? () => canvasContainer["webkitRequestFullscreen"](Element["ALLOW_KEYBOARD_INPUT"]) : null) || (canvasContainer["webkitRequestFullScreen"] ? () => canvasContainer["webkitRequestFullScreen"](Element["ALLOW_KEYBOARD_INPUT"]) : null);
            canvasContainer.requestFullscreen();
          },
          exitFullscreen() {
            if (!Browser.isFullscreen) {
              return false;
            }
            var CFS = document["exitFullscreen"] || document["cancelFullScreen"] || document["mozCancelFullScreen"] || document["msExitFullscreen"] || document["webkitCancelFullScreen"] || (() => {
            });
            CFS.apply(document, []);
            return true;
          },
          nextRAF: 0,
          fakeRequestAnimationFrame(func2) {
            var now = Date.now();
            if (Browser.nextRAF === 0) {
              Browser.nextRAF = now + 1e3 / 60;
            } else {
              while (now + 2 >= Browser.nextRAF) {
                Browser.nextRAF += 1e3 / 60;
              }
            }
            var delay = Math.max(Browser.nextRAF - now, 0);
            setTimeout(func2, delay);
          },
          requestAnimationFrame(func2) {
            if (typeof requestAnimationFrame == "function") {
              requestAnimationFrame(func2);
              return;
            }
            var RAF = Browser.fakeRequestAnimationFrame;
            RAF(func2);
          },
          safeSetTimeout(func2, timeout) {
            return safeSetTimeout(func2, timeout);
          },
          safeRequestAnimationFrame(func2) {
            return Browser.requestAnimationFrame(() => {
              callUserCallback(func2);
            });
          },
          getMimetype(name2) {
            return {
              "jpg": "image/jpeg",
              "jpeg": "image/jpeg",
              "png": "image/png",
              "bmp": "image/bmp",
              "ogg": "audio/ogg",
              "wav": "audio/wav",
              "mp3": "audio/mpeg"
            }[name2.substr(name2.lastIndexOf(".") + 1)];
          },
          getUserMedia(func2) {
            window.getUserMedia || (window.getUserMedia = navigator["getUserMedia"] || navigator["mozGetUserMedia"]);
            window.getUserMedia(func2);
          },
          getMovementX(event2) {
            return event2["movementX"] || event2["mozMovementX"] || event2["webkitMovementX"] || 0;
          },
          getMovementY(event2) {
            return event2["movementY"] || event2["mozMovementY"] || event2["webkitMovementY"] || 0;
          },
          getMouseWheelDelta(event2) {
            var delta = 0;
            switch (event2.type) {
              case "DOMMouseScroll":
                delta = event2.detail / 3;
                break;
              case "mousewheel":
                delta = event2.wheelDelta / 120;
                break;
              case "wheel":
                delta = event2.deltaY;
                switch (event2.deltaMode) {
                  case 0:
                    delta /= 100;
                    break;
                  case 1:
                    delta /= 3;
                    break;
                  case 2:
                    delta *= 80;
                    break;
                  default:
                    throw "unrecognized mouse wheel delta mode: " + event2.deltaMode;
                }
                break;
              default:
                throw "unrecognized mouse wheel event: " + event2.type;
            }
            return delta;
          },
          mouseX: 0,
          mouseY: 0,
          mouseMovementX: 0,
          mouseMovementY: 0,
          touches: {},
          lastTouches: {},
          calculateMouseCoords(pageX, pageY) {
            var rect = Module["canvas"].getBoundingClientRect();
            var cw = Module["canvas"].width;
            var ch = Module["canvas"].height;
            var scrollX = typeof window.scrollX != "undefined" ? window.scrollX : window.pageXOffset;
            var scrollY = typeof window.scrollY != "undefined" ? window.scrollY : window.pageYOffset;
            var adjustedX = pageX - (scrollX + rect.left);
            var adjustedY = pageY - (scrollY + rect.top);
            adjustedX = adjustedX * (cw / rect.width);
            adjustedY = adjustedY * (ch / rect.height);
            return {
              x: adjustedX,
              y: adjustedY
            };
          },
          setMouseCoords(pageX, pageY) {
            const {
              x,
              y
            } = Browser.calculateMouseCoords(pageX, pageY);
            Browser.mouseMovementX = x - Browser.mouseX;
            Browser.mouseMovementY = y - Browser.mouseY;
            Browser.mouseX = x;
            Browser.mouseY = y;
          },
          calculateMouseEvent(event2) {
            if (Browser.pointerLock) {
              if (event2.type != "mousemove" && "mozMovementX" in event2) {
                Browser.mouseMovementX = Browser.mouseMovementY = 0;
              } else {
                Browser.mouseMovementX = Browser.getMovementX(event2);
                Browser.mouseMovementY = Browser.getMovementY(event2);
              }
              if (typeof SDL != "undefined") {
                Browser.mouseX = SDL.mouseX + Browser.mouseMovementX;
                Browser.mouseY = SDL.mouseY + Browser.mouseMovementY;
              } else {
                Browser.mouseX += Browser.mouseMovementX;
                Browser.mouseY += Browser.mouseMovementY;
              }
            } else {
              if (event2.type === "touchstart" || event2.type === "touchend" || event2.type === "touchmove") {
                var touch = event2.touch;
                if (touch === void 0) {
                  return;
                }
                var coords = Browser.calculateMouseCoords(touch.pageX, touch.pageY);
                if (event2.type === "touchstart") {
                  Browser.lastTouches[touch.identifier] = coords;
                  Browser.touches[touch.identifier] = coords;
                } else if (event2.type === "touchend" || event2.type === "touchmove") {
                  var last = Browser.touches[touch.identifier];
                  last || (last = coords);
                  Browser.lastTouches[touch.identifier] = last;
                  Browser.touches[touch.identifier] = coords;
                }
                return;
              }
              Browser.setMouseCoords(event2.pageX, event2.pageY);
            }
          },
          resizeListeners: [],
          updateResizeListeners() {
            var canvas = Module["canvas"];
            Browser.resizeListeners.forEach((listener) => listener(canvas.width, canvas.height));
          },
          setCanvasSize(width, height, noUpdates) {
            var canvas = Module["canvas"];
            Browser.updateCanvasDimensions(canvas, width, height);
            if (!noUpdates)
              Browser.updateResizeListeners();
          },
          windowedWidth: 0,
          windowedHeight: 0,
          setFullscreenCanvasSize() {
            if (typeof SDL != "undefined") {
              var flags2 = HEAPU32[SDL.screen >>> 2 >>> 0];
              flags2 = flags2 | 8388608;
              HEAP32[SDL.screen >>> 2 >>> 0] = flags2;
            }
            Browser.updateCanvasDimensions(Module["canvas"]);
            Browser.updateResizeListeners();
          },
          setWindowedCanvasSize() {
            if (typeof SDL != "undefined") {
              var flags2 = HEAPU32[SDL.screen >>> 2 >>> 0];
              flags2 = flags2 & ~8388608;
              HEAP32[SDL.screen >>> 2 >>> 0] = flags2;
            }
            Browser.updateCanvasDimensions(Module["canvas"]);
            Browser.updateResizeListeners();
          },
          updateCanvasDimensions(canvas, wNative, hNative) {
            if (wNative && hNative) {
              canvas.widthNative = wNative;
              canvas.heightNative = hNative;
            } else {
              wNative = canvas.widthNative;
              hNative = canvas.heightNative;
            }
            var w = wNative;
            var h = hNative;
            if (Module["forcedAspectRatio"] && Module["forcedAspectRatio"] > 0) {
              if (w / h < Module["forcedAspectRatio"]) {
                w = Math.round(h * Module["forcedAspectRatio"]);
              } else {
                h = Math.round(w / Module["forcedAspectRatio"]);
              }
            }
            if ((document["fullscreenElement"] || document["mozFullScreenElement"] || document["msFullscreenElement"] || document["webkitFullscreenElement"] || document["webkitCurrentFullScreenElement"]) === canvas.parentNode && typeof screen != "undefined") {
              var factor = Math.min(screen.width / w, screen.height / h);
              w = Math.round(w * factor);
              h = Math.round(h * factor);
            }
            if (Browser.resizeCanvas) {
              if (canvas.width != w)
                canvas.width = w;
              if (canvas.height != h)
                canvas.height = h;
              if (typeof canvas.style != "undefined") {
                canvas.style.removeProperty("width");
                canvas.style.removeProperty("height");
              }
            } else {
              if (canvas.width != wNative)
                canvas.width = wNative;
              if (canvas.height != hNative)
                canvas.height = hNative;
              if (typeof canvas.style != "undefined") {
                if (w != wNative || h != hNative) {
                  canvas.style.setProperty("width", w + "px", "important");
                  canvas.style.setProperty("height", h + "px", "important");
                } else {
                  canvas.style.removeProperty("width");
                  canvas.style.removeProperty("height");
                }
              }
            }
          }
        };
        var AL = {
          QUEUE_INTERVAL: 25,
          QUEUE_LOOKAHEAD: 0.1,
          DEVICE_NAME: "Emscripten OpenAL",
          CAPTURE_DEVICE_NAME: "Emscripten OpenAL capture",
          ALC_EXTENSIONS: {
            ALC_SOFT_pause_device: true,
            ALC_SOFT_HRTF: true
          },
          AL_EXTENSIONS: {
            AL_EXT_float32: true,
            AL_SOFT_loop_points: true,
            AL_SOFT_source_length: true,
            AL_EXT_source_distance_model: true,
            AL_SOFT_source_spatialize: true
          },
          _alcErr: 0,
          alcErr: 0,
          deviceRefCounts: {},
          alcStringCache: {},
          paused: false,
          stringCache: {},
          contexts: {},
          currentCtx: null,
          buffers: {
            0: {
              id: 0,
              refCount: 0,
              audioBuf: null,
              frequency: 0,
              bytesPerSample: 2,
              channels: 1,
              length: 0
            }
          },
          paramArray: [],
          _nextId: 1,
          newId: () => AL.freeIds.length > 0 ? AL.freeIds.pop() : AL._nextId++,
          freeIds: [],
          scheduleContextAudio: (ctx) => {
            if (Browser.mainLoop.timingMode === 1 && document["visibilityState"] != "visible") {
              return;
            }
            for (var i2 in ctx.sources) {
              AL.scheduleSourceAudio(ctx.sources[i2]);
            }
          },
          scheduleSourceAudio: (src, lookahead) => {
            if (Browser.mainLoop.timingMode === 1 && document["visibilityState"] != "visible") {
              return;
            }
            if (src.state !== 4114) {
              return;
            }
            var currentTime = AL.updateSourceTime(src);
            var startTime = src.bufStartTime;
            var startOffset = src.bufOffset;
            var bufCursor = src.bufsProcessed;
            for (var i2 = 0; i2 < src.audioQueue.length; i2++) {
              var audioSrc = src.audioQueue[i2];
              startTime = audioSrc._startTime + audioSrc._duration;
              startOffset = 0;
              bufCursor += audioSrc._skipCount + 1;
            }
            if (!lookahead) {
              lookahead = AL.QUEUE_LOOKAHEAD;
            }
            var lookaheadTime = currentTime + lookahead;
            var skipCount = 0;
            while (startTime < lookaheadTime) {
              if (bufCursor >= src.bufQueue.length) {
                if (src.looping) {
                  bufCursor %= src.bufQueue.length;
                } else {
                  break;
                }
              }
              var buf = src.bufQueue[bufCursor % src.bufQueue.length];
              if (buf.length === 0) {
                skipCount++;
                if (skipCount === src.bufQueue.length) {
                  break;
                }
              } else {
                var audioSrc = src.context.audioCtx.createBufferSource();
                audioSrc.buffer = buf.audioBuf;
                audioSrc.playbackRate.value = src.playbackRate;
                if (buf.audioBuf._loopStart || buf.audioBuf._loopEnd) {
                  audioSrc.loopStart = buf.audioBuf._loopStart;
                  audioSrc.loopEnd = buf.audioBuf._loopEnd;
                }
                var duration = 0;
                if (src.type === 4136 && src.looping) {
                  duration = Number.POSITIVE_INFINITY;
                  audioSrc.loop = true;
                  if (buf.audioBuf._loopStart) {
                    audioSrc.loopStart = buf.audioBuf._loopStart;
                  }
                  if (buf.audioBuf._loopEnd) {
                    audioSrc.loopEnd = buf.audioBuf._loopEnd;
                  }
                } else {
                  duration = (buf.audioBuf.duration - startOffset) / src.playbackRate;
                }
                audioSrc._startOffset = startOffset;
                audioSrc._duration = duration;
                audioSrc._skipCount = skipCount;
                skipCount = 0;
                audioSrc.connect(src.gain);
                if (typeof audioSrc.start != "undefined") {
                  startTime = Math.max(startTime, src.context.audioCtx.currentTime);
                  audioSrc.start(startTime, startOffset);
                } else if (typeof audioSrc.noteOn != "undefined") {
                  startTime = Math.max(startTime, src.context.audioCtx.currentTime);
                  audioSrc.noteOn(startTime);
                }
                audioSrc._startTime = startTime;
                src.audioQueue.push(audioSrc);
                startTime += duration;
              }
              startOffset = 0;
              bufCursor++;
            }
          },
          updateSourceTime: (src) => {
            var currentTime = src.context.audioCtx.currentTime;
            if (src.state !== 4114) {
              return currentTime;
            }
            if (!isFinite(src.bufStartTime)) {
              src.bufStartTime = currentTime - src.bufOffset / src.playbackRate;
              src.bufOffset = 0;
            }
            var nextStartTime = 0;
            while (src.audioQueue.length) {
              var audioSrc = src.audioQueue[0];
              src.bufsProcessed += audioSrc._skipCount;
              nextStartTime = audioSrc._startTime + audioSrc._duration;
              if (currentTime < nextStartTime) {
                break;
              }
              src.audioQueue.shift();
              src.bufStartTime = nextStartTime;
              src.bufOffset = 0;
              src.bufsProcessed++;
            }
            if (src.bufsProcessed >= src.bufQueue.length && !src.looping) {
              AL.setSourceState(src, 4116);
            } else if (src.type === 4136 && src.looping) {
              var buf = src.bufQueue[0];
              if (buf.length === 0) {
                src.bufOffset = 0;
              } else {
                var delta = (currentTime - src.bufStartTime) * src.playbackRate;
                var loopStart = buf.audioBuf._loopStart || 0;
                var loopEnd = buf.audioBuf._loopEnd || buf.audioBuf.duration;
                if (loopEnd <= loopStart) {
                  loopEnd = buf.audioBuf.duration;
                }
                if (delta < loopEnd) {
                  src.bufOffset = delta;
                } else {
                  src.bufOffset = loopStart + (delta - loopStart) % (loopEnd - loopStart);
                }
              }
            } else if (src.audioQueue[0]) {
              src.bufOffset = (currentTime - src.audioQueue[0]._startTime) * src.playbackRate;
            } else {
              if (src.type !== 4136 && src.looping) {
                var srcDuration = AL.sourceDuration(src) / src.playbackRate;
                if (srcDuration > 0) {
                  src.bufStartTime += Math.floor((currentTime - src.bufStartTime) / srcDuration) * srcDuration;
                }
              }
              for (var i2 = 0; i2 < src.bufQueue.length; i2++) {
                if (src.bufsProcessed >= src.bufQueue.length) {
                  if (src.looping) {
                    src.bufsProcessed %= src.bufQueue.length;
                  } else {
                    AL.setSourceState(src, 4116);
                    break;
                  }
                }
                var buf = src.bufQueue[src.bufsProcessed];
                if (buf.length > 0) {
                  nextStartTime = src.bufStartTime + buf.audioBuf.duration / src.playbackRate;
                  if (currentTime < nextStartTime) {
                    src.bufOffset = (currentTime - src.bufStartTime) * src.playbackRate;
                    break;
                  }
                  src.bufStartTime = nextStartTime;
                }
                src.bufOffset = 0;
                src.bufsProcessed++;
              }
            }
            return currentTime;
          },
          cancelPendingSourceAudio: (src) => {
            AL.updateSourceTime(src);
            for (var i2 = 1; i2 < src.audioQueue.length; i2++) {
              var audioSrc = src.audioQueue[i2];
              audioSrc.stop();
            }
            if (src.audioQueue.length > 1) {
              src.audioQueue.length = 1;
            }
          },
          stopSourceAudio: (src) => {
            for (var i2 = 0; i2 < src.audioQueue.length; i2++) {
              src.audioQueue[i2].stop();
            }
            src.audioQueue.length = 0;
          },
          setSourceState: (src, state) => {
            if (state === 4114) {
              if (src.state === 4114 || src.state == 4116) {
                src.bufsProcessed = 0;
                src.bufOffset = 0;
              } else {
              }
              AL.stopSourceAudio(src);
              src.state = 4114;
              src.bufStartTime = Number.NEGATIVE_INFINITY;
              AL.scheduleSourceAudio(src);
            } else if (state === 4115) {
              if (src.state === 4114) {
                AL.updateSourceTime(src);
                AL.stopSourceAudio(src);
                src.state = 4115;
              }
            } else if (state === 4116) {
              if (src.state !== 4113) {
                src.state = 4116;
                src.bufsProcessed = src.bufQueue.length;
                src.bufStartTime = Number.NEGATIVE_INFINITY;
                src.bufOffset = 0;
                AL.stopSourceAudio(src);
              }
            } else if (state === 4113) {
              if (src.state !== 4113) {
                src.state = 4113;
                src.bufsProcessed = 0;
                src.bufStartTime = Number.NEGATIVE_INFINITY;
                src.bufOffset = 0;
                AL.stopSourceAudio(src);
              }
            }
          },
          initSourcePanner: (src) => {
            if (src.type === 4144) {
              return;
            }
            var templateBuf = AL.buffers[0];
            for (var i2 = 0; i2 < src.bufQueue.length; i2++) {
              if (src.bufQueue[i2].id !== 0) {
                templateBuf = src.bufQueue[i2];
                break;
              }
            }
            if (src.spatialize === 1 || src.spatialize === 2 && templateBuf.channels === 1) {
              if (src.panner) {
                return;
              }
              src.panner = src.context.audioCtx.createPanner();
              AL.updateSourceGlobal(src);
              AL.updateSourceSpace(src);
              src.panner.connect(src.context.gain);
              src.gain.disconnect();
              src.gain.connect(src.panner);
            } else {
              if (!src.panner) {
                return;
              }
              src.panner.disconnect();
              src.gain.disconnect();
              src.gain.connect(src.context.gain);
              src.panner = null;
            }
          },
          updateContextGlobal: (ctx) => {
            for (var i2 in ctx.sources) {
              AL.updateSourceGlobal(ctx.sources[i2]);
            }
          },
          updateSourceGlobal: (src) => {
            var panner = src.panner;
            if (!panner) {
              return;
            }
            panner.refDistance = src.refDistance;
            panner.maxDistance = src.maxDistance;
            panner.rolloffFactor = src.rolloffFactor;
            panner.panningModel = src.context.hrtf ? "HRTF" : "equalpower";
            var distanceModel = src.context.sourceDistanceModel ? src.distanceModel : src.context.distanceModel;
            switch (distanceModel) {
              case 0:
                panner.distanceModel = "inverse";
                panner.refDistance = 340282e33;
                break;
              case 53249:
              case 53250:
                panner.distanceModel = "inverse";
                break;
              case 53251:
              case 53252:
                panner.distanceModel = "linear";
                break;
              case 53253:
              case 53254:
                panner.distanceModel = "exponential";
                break;
            }
          },
          updateListenerSpace: (ctx) => {
            var listener = ctx.audioCtx.listener;
            if (listener.positionX) {
              listener.positionX.value = ctx.listener.position[0];
              listener.positionY.value = ctx.listener.position[1];
              listener.positionZ.value = ctx.listener.position[2];
            } else {
              listener.setPosition(ctx.listener.position[0], ctx.listener.position[1], ctx.listener.position[2]);
            }
            if (listener.forwardX) {
              listener.forwardX.value = ctx.listener.direction[0];
              listener.forwardY.value = ctx.listener.direction[1];
              listener.forwardZ.value = ctx.listener.direction[2];
              listener.upX.value = ctx.listener.up[0];
              listener.upY.value = ctx.listener.up[1];
              listener.upZ.value = ctx.listener.up[2];
            } else {
              listener.setOrientation(ctx.listener.direction[0], ctx.listener.direction[1], ctx.listener.direction[2], ctx.listener.up[0], ctx.listener.up[1], ctx.listener.up[2]);
            }
            for (var i2 in ctx.sources) {
              AL.updateSourceSpace(ctx.sources[i2]);
            }
          },
          updateSourceSpace: (src) => {
            if (!src.panner) {
              return;
            }
            var panner = src.panner;
            var posX = src.position[0];
            var posY = src.position[1];
            var posZ = src.position[2];
            var dirX = src.direction[0];
            var dirY = src.direction[1];
            var dirZ = src.direction[2];
            var listener = src.context.listener;
            var lPosX = listener.position[0];
            var lPosY = listener.position[1];
            var lPosZ = listener.position[2];
            if (src.relative) {
              var lBackX = -listener.direction[0];
              var lBackY = -listener.direction[1];
              var lBackZ = -listener.direction[2];
              var lUpX = listener.up[0];
              var lUpY = listener.up[1];
              var lUpZ = listener.up[2];
              var inverseMagnitude = (x, y, z) => {
                var length = Math.sqrt(x * x + y * y + z * z);
                if (length < Number.EPSILON) {
                  return 0;
                }
                return 1 / length;
              };
              var invMag = inverseMagnitude(lBackX, lBackY, lBackZ);
              lBackX *= invMag;
              lBackY *= invMag;
              lBackZ *= invMag;
              invMag = inverseMagnitude(lUpX, lUpY, lUpZ);
              lUpX *= invMag;
              lUpY *= invMag;
              lUpZ *= invMag;
              var lRightX = lUpY * lBackZ - lUpZ * lBackY;
              var lRightY = lUpZ * lBackX - lUpX * lBackZ;
              var lRightZ = lUpX * lBackY - lUpY * lBackX;
              invMag = inverseMagnitude(lRightX, lRightY, lRightZ);
              lRightX *= invMag;
              lRightY *= invMag;
              lRightZ *= invMag;
              lUpX = lBackY * lRightZ - lBackZ * lRightY;
              lUpY = lBackZ * lRightX - lBackX * lRightZ;
              lUpZ = lBackX * lRightY - lBackY * lRightX;
              var oldX = dirX;
              var oldY = dirY;
              var oldZ = dirZ;
              dirX = oldX * lRightX + oldY * lUpX + oldZ * lBackX;
              dirY = oldX * lRightY + oldY * lUpY + oldZ * lBackY;
              dirZ = oldX * lRightZ + oldY * lUpZ + oldZ * lBackZ;
              oldX = posX;
              oldY = posY;
              oldZ = posZ;
              posX = oldX * lRightX + oldY * lUpX + oldZ * lBackX;
              posY = oldX * lRightY + oldY * lUpY + oldZ * lBackY;
              posZ = oldX * lRightZ + oldY * lUpZ + oldZ * lBackZ;
              posX += lPosX;
              posY += lPosY;
              posZ += lPosZ;
            }
            if (panner.positionX) {
              if (posX != panner.positionX.value)
                panner.positionX.value = posX;
              if (posY != panner.positionY.value)
                panner.positionY.value = posY;
              if (posZ != panner.positionZ.value)
                panner.positionZ.value = posZ;
            } else {
              panner.setPosition(posX, posY, posZ);
            }
            if (panner.orientationX) {
              if (dirX != panner.orientationX.value)
                panner.orientationX.value = dirX;
              if (dirY != panner.orientationY.value)
                panner.orientationY.value = dirY;
              if (dirZ != panner.orientationZ.value)
                panner.orientationZ.value = dirZ;
            } else {
              panner.setOrientation(dirX, dirY, dirZ);
            }
            var oldShift = src.dopplerShift;
            var velX = src.velocity[0];
            var velY = src.velocity[1];
            var velZ = src.velocity[2];
            var lVelX = listener.velocity[0];
            var lVelY = listener.velocity[1];
            var lVelZ = listener.velocity[2];
            if (posX === lPosX && posY === lPosY && posZ === lPosZ || velX === lVelX && velY === lVelY && velZ === lVelZ) {
              src.dopplerShift = 1;
            } else {
              var speedOfSound = src.context.speedOfSound;
              var dopplerFactor = src.context.dopplerFactor;
              var slX = lPosX - posX;
              var slY = lPosY - posY;
              var slZ = lPosZ - posZ;
              var magSl = Math.sqrt(slX * slX + slY * slY + slZ * slZ);
              var vls = (slX * lVelX + slY * lVelY + slZ * lVelZ) / magSl;
              var vss = (slX * velX + slY * velY + slZ * velZ) / magSl;
              vls = Math.min(vls, speedOfSound / dopplerFactor);
              vss = Math.min(vss, speedOfSound / dopplerFactor);
              src.dopplerShift = (speedOfSound - dopplerFactor * vls) / (speedOfSound - dopplerFactor * vss);
            }
            if (src.dopplerShift !== oldShift) {
              AL.updateSourceRate(src);
            }
          },
          updateSourceRate: (src) => {
            if (src.state === 4114) {
              AL.cancelPendingSourceAudio(src);
              var audioSrc = src.audioQueue[0];
              if (!audioSrc) {
                return;
              }
              var duration;
              if (src.type === 4136 && src.looping) {
                duration = Number.POSITIVE_INFINITY;
              } else {
                duration = (audioSrc.buffer.duration - audioSrc._startOffset) / src.playbackRate;
              }
              audioSrc._duration = duration;
              audioSrc.playbackRate.value = src.playbackRate;
              AL.scheduleSourceAudio(src);
            }
          },
          sourceDuration: (src) => {
            var length = 0;
            for (var i2 = 0; i2 < src.bufQueue.length; i2++) {
              var audioBuf = src.bufQueue[i2].audioBuf;
              length += audioBuf ? audioBuf.duration : 0;
            }
            return length;
          },
          sourceTell: (src) => {
            AL.updateSourceTime(src);
            var offset = 0;
            for (var i2 = 0; i2 < src.bufsProcessed; i2++) {
              if (src.bufQueue[i2].audioBuf) {
                offset += src.bufQueue[i2].audioBuf.duration;
              }
            }
            offset += src.bufOffset;
            return offset;
          },
          sourceSeek: (src, offset) => {
            var playing = src.state == 4114;
            if (playing) {
              AL.setSourceState(src, 4113);
            }
            if (src.bufQueue[src.bufsProcessed].audioBuf !== null) {
              src.bufsProcessed = 0;
              while (offset > src.bufQueue[src.bufsProcessed].audioBuf.duration) {
                offset -= src.bufQueue[src.bufsProcessed].audiobuf.duration;
                src.bufsProcessed++;
              }
              src.bufOffset = offset;
            }
            if (playing) {
              AL.setSourceState(src, 4114);
            }
          },
          getGlobalParam: (funcname, param) => {
            if (!AL.currentCtx) {
              return null;
            }
            switch (param) {
              case 49152:
                return AL.currentCtx.dopplerFactor;
              case 49155:
                return AL.currentCtx.speedOfSound;
              case 53248:
                return AL.currentCtx.distanceModel;
              default:
                AL.currentCtx.err = 40962;
                return null;
            }
          },
          setGlobalParam: (funcname, param, value) => {
            if (!AL.currentCtx) {
              return;
            }
            switch (param) {
              case 49152:
                if (!Number.isFinite(value) || value < 0) {
                  AL.currentCtx.err = 40963;
                  return;
                }
                AL.currentCtx.dopplerFactor = value;
                AL.updateListenerSpace(AL.currentCtx);
                break;
              case 49155:
                if (!Number.isFinite(value) || value <= 0) {
                  AL.currentCtx.err = 40963;
                  return;
                }
                AL.currentCtx.speedOfSound = value;
                AL.updateListenerSpace(AL.currentCtx);
                break;
              case 53248:
                switch (value) {
                  case 0:
                  case 53249:
                  case 53250:
                  case 53251:
                  case 53252:
                  case 53253:
                  case 53254:
                    AL.currentCtx.distanceModel = value;
                    AL.updateContextGlobal(AL.currentCtx);
                    break;
                  default:
                    AL.currentCtx.err = 40963;
                    return;
                }
                break;
              default:
                AL.currentCtx.err = 40962;
                return;
            }
          },
          getListenerParam: (funcname, param) => {
            if (!AL.currentCtx) {
              return null;
            }
            switch (param) {
              case 4100:
                return AL.currentCtx.listener.position;
              case 4102:
                return AL.currentCtx.listener.velocity;
              case 4111:
                return AL.currentCtx.listener.direction.concat(AL.currentCtx.listener.up);
              case 4106:
                return AL.currentCtx.gain.gain.value;
              default:
                AL.currentCtx.err = 40962;
                return null;
            }
          },
          setListenerParam: (funcname, param, value) => {
            if (!AL.currentCtx) {
              return;
            }
            if (value === null) {
              AL.currentCtx.err = 40962;
              return;
            }
            var listener = AL.currentCtx.listener;
            switch (param) {
              case 4100:
                if (!Number.isFinite(value[0]) || !Number.isFinite(value[1]) || !Number.isFinite(value[2])) {
                  AL.currentCtx.err = 40963;
                  return;
                }
                listener.position[0] = value[0];
                listener.position[1] = value[1];
                listener.position[2] = value[2];
                AL.updateListenerSpace(AL.currentCtx);
                break;
              case 4102:
                if (!Number.isFinite(value[0]) || !Number.isFinite(value[1]) || !Number.isFinite(value[2])) {
                  AL.currentCtx.err = 40963;
                  return;
                }
                listener.velocity[0] = value[0];
                listener.velocity[1] = value[1];
                listener.velocity[2] = value[2];
                AL.updateListenerSpace(AL.currentCtx);
                break;
              case 4106:
                if (!Number.isFinite(value) || value < 0) {
                  AL.currentCtx.err = 40963;
                  return;
                }
                AL.currentCtx.gain.gain.value = value;
                break;
              case 4111:
                if (!Number.isFinite(value[0]) || !Number.isFinite(value[1]) || !Number.isFinite(value[2]) || !Number.isFinite(value[3]) || !Number.isFinite(value[4]) || !Number.isFinite(value[5])) {
                  AL.currentCtx.err = 40963;
                  return;
                }
                listener.direction[0] = value[0];
                listener.direction[1] = value[1];
                listener.direction[2] = value[2];
                listener.up[0] = value[3];
                listener.up[1] = value[4];
                listener.up[2] = value[5];
                AL.updateListenerSpace(AL.currentCtx);
                break;
              default:
                AL.currentCtx.err = 40962;
                return;
            }
          },
          getBufferParam: (funcname, bufferId, param) => {
            if (!AL.currentCtx) {
              return;
            }
            var buf = AL.buffers[bufferId];
            if (!buf || bufferId === 0) {
              AL.currentCtx.err = 40961;
              return;
            }
            switch (param) {
              case 8193:
                return buf.frequency;
              case 8194:
                return buf.bytesPerSample * 8;
              case 8195:
                return buf.channels;
              case 8196:
                return buf.length * buf.bytesPerSample * buf.channels;
              case 8213:
                if (buf.length === 0) {
                  return [0, 0];
                }
                return [(buf.audioBuf._loopStart || 0) * buf.frequency, (buf.audioBuf._loopEnd || buf.length) * buf.frequency];
              default:
                AL.currentCtx.err = 40962;
                return null;
            }
          },
          setBufferParam: (funcname, bufferId, param, value) => {
            if (!AL.currentCtx) {
              return;
            }
            var buf = AL.buffers[bufferId];
            if (!buf || bufferId === 0) {
              AL.currentCtx.err = 40961;
              return;
            }
            if (value === null) {
              AL.currentCtx.err = 40962;
              return;
            }
            switch (param) {
              case 8196:
                if (value !== 0) {
                  AL.currentCtx.err = 40963;
                  return;
                }
                break;
              case 8213:
                if (value[0] < 0 || value[0] > buf.length || value[1] < 0 || value[1] > buf.Length || value[0] >= value[1]) {
                  AL.currentCtx.err = 40963;
                  return;
                }
                if (buf.refCount > 0) {
                  AL.currentCtx.err = 40964;
                  return;
                }
                if (buf.audioBuf) {
                  buf.audioBuf._loopStart = value[0] / buf.frequency;
                  buf.audioBuf._loopEnd = value[1] / buf.frequency;
                }
                break;
              default:
                AL.currentCtx.err = 40962;
                return;
            }
          },
          getSourceParam: (funcname, sourceId, param) => {
            if (!AL.currentCtx) {
              return null;
            }
            var src = AL.currentCtx.sources[sourceId];
            if (!src) {
              AL.currentCtx.err = 40961;
              return null;
            }
            switch (param) {
              case 514:
                return src.relative;
              case 4097:
                return src.coneInnerAngle;
              case 4098:
                return src.coneOuterAngle;
              case 4099:
                return src.pitch;
              case 4100:
                return src.position;
              case 4101:
                return src.direction;
              case 4102:
                return src.velocity;
              case 4103:
                return src.looping;
              case 4105:
                if (src.type === 4136) {
                  return src.bufQueue[0].id;
                }
                return 0;
              case 4106:
                return src.gain.gain.value;
              case 4109:
                return src.minGain;
              case 4110:
                return src.maxGain;
              case 4112:
                return src.state;
              case 4117:
                if (src.bufQueue.length === 1 && src.bufQueue[0].id === 0) {
                  return 0;
                }
                return src.bufQueue.length;
              case 4118:
                if (src.bufQueue.length === 1 && src.bufQueue[0].id === 0 || src.looping) {
                  return 0;
                }
                return src.bufsProcessed;
              case 4128:
                return src.refDistance;
              case 4129:
                return src.rolloffFactor;
              case 4130:
                return src.coneOuterGain;
              case 4131:
                return src.maxDistance;
              case 4132:
                return AL.sourceTell(src);
              case 4133:
                var offset = AL.sourceTell(src);
                if (offset > 0) {
                  offset *= src.bufQueue[0].frequency;
                }
                return offset;
              case 4134:
                var offset = AL.sourceTell(src);
                if (offset > 0) {
                  offset *= src.bufQueue[0].frequency * src.bufQueue[0].bytesPerSample;
                }
                return offset;
              case 4135:
                return src.type;
              case 4628:
                return src.spatialize;
              case 8201:
                var length = 0;
                var bytesPerFrame = 0;
                for (var i2 = 0; i2 < src.bufQueue.length; i2++) {
                  length += src.bufQueue[i2].length;
                  if (src.bufQueue[i2].id !== 0) {
                    bytesPerFrame = src.bufQueue[i2].bytesPerSample * src.bufQueue[i2].channels;
                  }
                }
                return length * bytesPerFrame;
              case 8202:
                var length = 0;
                for (var i2 = 0; i2 < src.bufQueue.length; i2++) {
                  length += src.bufQueue[i2].length;
                }
                return length;
              case 8203:
                return AL.sourceDuration(src);
              case 53248:
                return src.distanceModel;
              default:
                AL.currentCtx.err = 40962;
                return null;
            }
          },
          setSourceParam: (funcname, sourceId, param, value) => {
            if (!AL.currentCtx) {
              return;
            }
            var src = AL.currentCtx.sources[sourceId];
            if (!src) {
              AL.currentCtx.err = 40961;
              return;
            }
            if (value === null) {
              AL.currentCtx.err = 40962;
              return;
            }
            switch (param) {
              case 514:
                if (value === 1) {
                  src.relative = true;
                  AL.updateSourceSpace(src);
                } else if (value === 0) {
                  src.relative = false;
                  AL.updateSourceSpace(src);
                } else {
                  AL.currentCtx.err = 40963;
                  return;
                }
                break;
              case 4097:
                if (!Number.isFinite(value)) {
                  AL.currentCtx.err = 40963;
                  return;
                }
                src.coneInnerAngle = value;
                if (src.panner) {
                  src.panner.coneInnerAngle = value % 360;
                }
                break;
              case 4098:
                if (!Number.isFinite(value)) {
                  AL.currentCtx.err = 40963;
                  return;
                }
                src.coneOuterAngle = value;
                if (src.panner) {
                  src.panner.coneOuterAngle = value % 360;
                }
                break;
              case 4099:
                if (!Number.isFinite(value) || value <= 0) {
                  AL.currentCtx.err = 40963;
                  return;
                }
                if (src.pitch === value) {
                  break;
                }
                src.pitch = value;
                AL.updateSourceRate(src);
                break;
              case 4100:
                if (!Number.isFinite(value[0]) || !Number.isFinite(value[1]) || !Number.isFinite(value[2])) {
                  AL.currentCtx.err = 40963;
                  return;
                }
                src.position[0] = value[0];
                src.position[1] = value[1];
                src.position[2] = value[2];
                AL.updateSourceSpace(src);
                break;
              case 4101:
                if (!Number.isFinite(value[0]) || !Number.isFinite(value[1]) || !Number.isFinite(value[2])) {
                  AL.currentCtx.err = 40963;
                  return;
                }
                src.direction[0] = value[0];
                src.direction[1] = value[1];
                src.direction[2] = value[2];
                AL.updateSourceSpace(src);
                break;
              case 4102:
                if (!Number.isFinite(value[0]) || !Number.isFinite(value[1]) || !Number.isFinite(value[2])) {
                  AL.currentCtx.err = 40963;
                  return;
                }
                src.velocity[0] = value[0];
                src.velocity[1] = value[1];
                src.velocity[2] = value[2];
                AL.updateSourceSpace(src);
                break;
              case 4103:
                if (value === 1) {
                  src.looping = true;
                  AL.updateSourceTime(src);
                  if (src.type === 4136 && src.audioQueue.length > 0) {
                    var audioSrc = src.audioQueue[0];
                    audioSrc.loop = true;
                    audioSrc._duration = Number.POSITIVE_INFINITY;
                  }
                } else if (value === 0) {
                  src.looping = false;
                  var currentTime = AL.updateSourceTime(src);
                  if (src.type === 4136 && src.audioQueue.length > 0) {
                    var audioSrc = src.audioQueue[0];
                    audioSrc.loop = false;
                    audioSrc._duration = src.bufQueue[0].audioBuf.duration / src.playbackRate;
                    audioSrc._startTime = currentTime - src.bufOffset / src.playbackRate;
                  }
                } else {
                  AL.currentCtx.err = 40963;
                  return;
                }
                break;
              case 4105:
                if (src.state === 4114 || src.state === 4115) {
                  AL.currentCtx.err = 40964;
                  return;
                }
                if (value === 0) {
                  for (var i2 in src.bufQueue) {
                    src.bufQueue[i2].refCount--;
                  }
                  src.bufQueue.length = 1;
                  src.bufQueue[0] = AL.buffers[0];
                  src.bufsProcessed = 0;
                  src.type = 4144;
                } else {
                  var buf = AL.buffers[value];
                  if (!buf) {
                    AL.currentCtx.err = 40963;
                    return;
                  }
                  for (var i2 in src.bufQueue) {
                    src.bufQueue[i2].refCount--;
                  }
                  src.bufQueue.length = 0;
                  buf.refCount++;
                  src.bufQueue = [buf];
                  src.bufsProcessed = 0;
                  src.type = 4136;
                }
                AL.initSourcePanner(src);
                AL.scheduleSourceAudio(src);
                break;
              case 4106:
                if (!Number.isFinite(value) || value < 0) {
                  AL.currentCtx.err = 40963;
                  return;
                }
                src.gain.gain.value = value;
                break;
              case 4109:
                if (!Number.isFinite(value) || value < 0 || value > Math.min(src.maxGain, 1)) {
                  AL.currentCtx.err = 40963;
                  return;
                }
                src.minGain = value;
                break;
              case 4110:
                if (!Number.isFinite(value) || value < Math.max(0, src.minGain) || value > 1) {
                  AL.currentCtx.err = 40963;
                  return;
                }
                src.maxGain = value;
                break;
              case 4128:
                if (!Number.isFinite(value) || value < 0) {
                  AL.currentCtx.err = 40963;
                  return;
                }
                src.refDistance = value;
                if (src.panner) {
                  src.panner.refDistance = value;
                }
                break;
              case 4129:
                if (!Number.isFinite(value) || value < 0) {
                  AL.currentCtx.err = 40963;
                  return;
                }
                src.rolloffFactor = value;
                if (src.panner) {
                  src.panner.rolloffFactor = value;
                }
                break;
              case 4130:
                if (!Number.isFinite(value) || value < 0 || value > 1) {
                  AL.currentCtx.err = 40963;
                  return;
                }
                src.coneOuterGain = value;
                if (src.panner) {
                  src.panner.coneOuterGain = value;
                }
                break;
              case 4131:
                if (!Number.isFinite(value) || value < 0) {
                  AL.currentCtx.err = 40963;
                  return;
                }
                src.maxDistance = value;
                if (src.panner) {
                  src.panner.maxDistance = value;
                }
                break;
              case 4132:
                if (value < 0 || value > AL.sourceDuration(src)) {
                  AL.currentCtx.err = 40963;
                  return;
                }
                AL.sourceSeek(src, value);
                break;
              case 4133:
                var srcLen = AL.sourceDuration(src);
                if (srcLen > 0) {
                  var frequency;
                  for (var bufId in src.bufQueue) {
                    if (bufId) {
                      frequency = src.bufQueue[bufId].frequency;
                      break;
                    }
                  }
                  value /= frequency;
                }
                if (value < 0 || value > srcLen) {
                  AL.currentCtx.err = 40963;
                  return;
                }
                AL.sourceSeek(src, value);
                break;
              case 4134:
                var srcLen = AL.sourceDuration(src);
                if (srcLen > 0) {
                  var bytesPerSec;
                  for (var bufId in src.bufQueue) {
                    if (bufId) {
                      var buf = src.bufQueue[bufId];
                      bytesPerSec = buf.frequency * buf.bytesPerSample * buf.channels;
                      break;
                    }
                  }
                  value /= bytesPerSec;
                }
                if (value < 0 || value > srcLen) {
                  AL.currentCtx.err = 40963;
                  return;
                }
                AL.sourceSeek(src, value);
                break;
              case 4628:
                if (value !== 0 && value !== 1 && value !== 2) {
                  AL.currentCtx.err = 40963;
                  return;
                }
                src.spatialize = value;
                AL.initSourcePanner(src);
                break;
              case 8201:
              case 8202:
              case 8203:
                AL.currentCtx.err = 40964;
                break;
              case 53248:
                switch (value) {
                  case 0:
                  case 53249:
                  case 53250:
                  case 53251:
                  case 53252:
                  case 53253:
                  case 53254:
                    src.distanceModel = value;
                    if (AL.currentCtx.sourceDistanceModel) {
                      AL.updateContextGlobal(AL.currentCtx);
                    }
                    break;
                  default:
                    AL.currentCtx.err = 40963;
                    return;
                }
                break;
              default:
                AL.currentCtx.err = 40962;
                return;
            }
          },
          captures: {},
          sharedCaptureAudioCtx: null,
          requireValidCaptureDevice: (deviceId, funcname) => {
            if (deviceId === 0) {
              AL.alcErr = 40961;
              return null;
            }
            var c = AL.captures[deviceId];
            if (!c) {
              AL.alcErr = 40961;
              return null;
            }
            var err2 = c.mediaStreamError;
            if (err2) {
              AL.alcErr = 40961;
              return null;
            }
            return c;
          }
        };
        var _alBuffer3f = (bufferId, param, value0, value1, value2) => {
          AL.setBufferParam("alBuffer3f", bufferId, param, null);
        };
        _alBuffer3f.sig = "viifff";
        var _alBuffer3i = (bufferId, param, value0, value1, value2) => {
          AL.setBufferParam("alBuffer3i", bufferId, param, null);
        };
        _alBuffer3i.sig = "viiiii";
        function _alBufferData(bufferId, format, pData, size, freq) {
          pData >>>= 0;
          if (!AL.currentCtx) {
            return;
          }
          var buf = AL.buffers[bufferId];
          if (!buf) {
            AL.currentCtx.err = 40963;
            return;
          }
          if (freq <= 0) {
            AL.currentCtx.err = 40963;
            return;
          }
          var audioBuf = null;
          try {
            switch (format) {
              case 4352:
                if (size > 0) {
                  audioBuf = AL.currentCtx.audioCtx.createBuffer(1, size, freq);
                  var channel0 = audioBuf.getChannelData(0);
                  for (var i2 = 0; i2 < size; ++i2) {
                    channel0[i2] = HEAPU8[pData++ >>> 0] * 78125e-7 - 1;
                  }
                }
                buf.bytesPerSample = 1;
                buf.channels = 1;
                buf.length = size;
                break;
              case 4353:
                if (size > 0) {
                  audioBuf = AL.currentCtx.audioCtx.createBuffer(1, size >> 1, freq);
                  var channel0 = audioBuf.getChannelData(0);
                  pData >>= 1;
                  for (var i2 = 0; i2 < size >> 1; ++i2) {
                    channel0[i2] = HEAP16[pData++ >>> 0] * 30517578125e-15;
                  }
                }
                buf.bytesPerSample = 2;
                buf.channels = 1;
                buf.length = size >> 1;
                break;
              case 4354:
                if (size > 0) {
                  audioBuf = AL.currentCtx.audioCtx.createBuffer(2, size >> 1, freq);
                  var channel0 = audioBuf.getChannelData(0);
                  var channel1 = audioBuf.getChannelData(1);
                  for (var i2 = 0; i2 < size >> 1; ++i2) {
                    channel0[i2] = HEAPU8[pData++ >>> 0] * 78125e-7 - 1;
                    channel1[i2] = HEAPU8[pData++ >>> 0] * 78125e-7 - 1;
                  }
                }
                buf.bytesPerSample = 1;
                buf.channels = 2;
                buf.length = size >> 1;
                break;
              case 4355:
                if (size > 0) {
                  audioBuf = AL.currentCtx.audioCtx.createBuffer(2, size >> 2, freq);
                  var channel0 = audioBuf.getChannelData(0);
                  var channel1 = audioBuf.getChannelData(1);
                  pData >>= 1;
                  for (var i2 = 0; i2 < size >> 2; ++i2) {
                    channel0[i2] = HEAP16[pData++ >>> 0] * 30517578125e-15;
                    channel1[i2] = HEAP16[pData++ >>> 0] * 30517578125e-15;
                  }
                }
                buf.bytesPerSample = 2;
                buf.channels = 2;
                buf.length = size >> 2;
                break;
              case 65552:
                if (size > 0) {
                  audioBuf = AL.currentCtx.audioCtx.createBuffer(1, size >> 2, freq);
                  var channel0 = audioBuf.getChannelData(0);
                  pData >>= 2;
                  for (var i2 = 0; i2 < size >> 2; ++i2) {
                    channel0[i2] = HEAPF32[pData++ >>> 0];
                  }
                }
                buf.bytesPerSample = 4;
                buf.channels = 1;
                buf.length = size >> 2;
                break;
              case 65553:
                if (size > 0) {
                  audioBuf = AL.currentCtx.audioCtx.createBuffer(2, size >> 3, freq);
                  var channel0 = audioBuf.getChannelData(0);
                  var channel1 = audioBuf.getChannelData(1);
                  pData >>= 2;
                  for (var i2 = 0; i2 < size >> 3; ++i2) {
                    channel0[i2] = HEAPF32[pData++ >>> 0];
                    channel1[i2] = HEAPF32[pData++ >>> 0];
                  }
                }
                buf.bytesPerSample = 4;
                buf.channels = 2;
                buf.length = size >> 3;
                break;
              default:
                AL.currentCtx.err = 40963;
                return;
            }
            buf.frequency = freq;
            buf.audioBuf = audioBuf;
          } catch (e) {
            AL.currentCtx.err = 40963;
            return;
          }
        }
        _alBufferData.sig = "viipii";
        var _alBufferf = (bufferId, param, value) => {
          AL.setBufferParam("alBufferf", bufferId, param, null);
        };
        _alBufferf.sig = "viif";
        function _alBufferfv(bufferId, param, pValues) {
          pValues >>>= 0;
          if (!AL.currentCtx) {
            return;
          }
          if (!pValues) {
            AL.currentCtx.err = 40963;
            return;
          }
          AL.setBufferParam("alBufferfv", bufferId, param, null);
        }
        _alBufferfv.sig = "viip";
        var _alBufferi = (bufferId, param, value) => {
          AL.setBufferParam("alBufferi", bufferId, param, null);
        };
        _alBufferi.sig = "viii";
        function _alBufferiv(bufferId, param, pValues) {
          pValues >>>= 0;
          if (!AL.currentCtx) {
            return;
          }
          if (!pValues) {
            AL.currentCtx.err = 40963;
            return;
          }
          switch (param) {
            case 8213:
              AL.paramArray[0] = HEAP32[pValues >>> 2 >>> 0];
              AL.paramArray[1] = HEAP32[pValues + 4 >>> 2 >>> 0];
              AL.setBufferParam("alBufferiv", bufferId, param, AL.paramArray);
              break;
            default:
              AL.setBufferParam("alBufferiv", bufferId, param, null);
              break;
          }
        }
        _alBufferiv.sig = "viip";
        function _alDeleteBuffers(count, pBufferIds) {
          pBufferIds >>>= 0;
          if (!AL.currentCtx) {
            return;
          }
          for (var i2 = 0; i2 < count; ++i2) {
            var bufId = HEAP32[pBufferIds + i2 * 4 >>> 2 >>> 0];
            if (bufId === 0) {
              continue;
            }
            if (!AL.buffers[bufId]) {
              AL.currentCtx.err = 40961;
              return;
            }
            if (AL.buffers[bufId].refCount) {
              AL.currentCtx.err = 40964;
              return;
            }
          }
          for (var i2 = 0; i2 < count; ++i2) {
            var bufId = HEAP32[pBufferIds + i2 * 4 >>> 2 >>> 0];
            if (bufId === 0) {
              continue;
            }
            AL.deviceRefCounts[AL.buffers[bufId].deviceId]--;
            delete AL.buffers[bufId];
            AL.freeIds.push(bufId);
          }
        }
        _alDeleteBuffers.sig = "vip";
        var _alSourcei = (sourceId, param, value) => {
          switch (param) {
            case 514:
            case 4097:
            case 4098:
            case 4103:
            case 4105:
            case 4128:
            case 4129:
            case 4131:
            case 4132:
            case 4133:
            case 4134:
            case 4628:
            case 8201:
            case 8202:
            case 53248:
              AL.setSourceParam("alSourcei", sourceId, param, value);
              break;
            default:
              AL.setSourceParam("alSourcei", sourceId, param, null);
              break;
          }
        };
        _alSourcei.sig = "viii";
        function _alDeleteSources(count, pSourceIds) {
          pSourceIds >>>= 0;
          if (!AL.currentCtx) {
            return;
          }
          for (var i2 = 0; i2 < count; ++i2) {
            var srcId = HEAP32[pSourceIds + i2 * 4 >>> 2 >>> 0];
            if (!AL.currentCtx.sources[srcId]) {
              AL.currentCtx.err = 40961;
              return;
            }
          }
          for (var i2 = 0; i2 < count; ++i2) {
            var srcId = HEAP32[pSourceIds + i2 * 4 >>> 2 >>> 0];
            AL.setSourceState(AL.currentCtx.sources[srcId], 4116);
            _alSourcei(srcId, 4105, 0);
            delete AL.currentCtx.sources[srcId];
            AL.freeIds.push(srcId);
          }
        }
        _alDeleteSources.sig = "vip";
        var _alDisable = (param) => {
          if (!AL.currentCtx) {
            return;
          }
          switch (param) {
            case "AL_SOURCE_DISTANCE_MODEL":
              AL.currentCtx.sourceDistanceModel = false;
              AL.updateContextGlobal(AL.currentCtx);
              break;
            default:
              AL.currentCtx.err = 40962;
              return;
          }
        };
        _alDisable.sig = "vi";
        var _alDistanceModel = (model) => {
          AL.setGlobalParam("alDistanceModel", 53248, model);
        };
        _alDistanceModel.sig = "vi";
        var _alDopplerFactor = (value) => {
          AL.setGlobalParam("alDopplerFactor", 49152, value);
        };
        _alDopplerFactor.sig = "vf";
        var _alDopplerVelocity = (value) => {
          warnOnce("alDopplerVelocity() is deprecated, and only kept for compatibility with OpenAL 1.0. Use alSpeedOfSound() instead.");
          if (!AL.currentCtx) {
            return;
          }
          if (value <= 0) {
            AL.currentCtx.err = 40963;
            return;
          }
        };
        _alDopplerVelocity.sig = "vf";
        var _alEnable = (param) => {
          if (!AL.currentCtx) {
            return;
          }
          switch (param) {
            case "AL_SOURCE_DISTANCE_MODEL":
              AL.currentCtx.sourceDistanceModel = true;
              AL.updateContextGlobal(AL.currentCtx);
              break;
            default:
              AL.currentCtx.err = 40962;
              return;
          }
        };
        _alEnable.sig = "vi";
        function _alGenBuffers(count, pBufferIds) {
          pBufferIds >>>= 0;
          if (!AL.currentCtx) {
            return;
          }
          for (var i2 = 0; i2 < count; ++i2) {
            var buf = {
              deviceId: AL.currentCtx.deviceId,
              id: AL.newId(),
              refCount: 0,
              audioBuf: null,
              frequency: 0,
              bytesPerSample: 2,
              channels: 1,
              length: 0
            };
            AL.deviceRefCounts[buf.deviceId]++;
            AL.buffers[buf.id] = buf;
            HEAP32[pBufferIds + i2 * 4 >>> 2 >>> 0] = buf.id;
          }
        }
        _alGenBuffers.sig = "vip";
        function _alGenSources(count, pSourceIds) {
          pSourceIds >>>= 0;
          if (!AL.currentCtx) {
            return;
          }
          for (var i2 = 0; i2 < count; ++i2) {
            var gain = AL.currentCtx.audioCtx.createGain();
            gain.connect(AL.currentCtx.gain);
            var src = {
              context: AL.currentCtx,
              id: AL.newId(),
              type: 4144,
              state: 4113,
              bufQueue: [AL.buffers[0]],
              audioQueue: [],
              looping: false,
              pitch: 1,
              dopplerShift: 1,
              gain,
              minGain: 0,
              maxGain: 1,
              panner: null,
              bufsProcessed: 0,
              bufStartTime: Number.NEGATIVE_INFINITY,
              bufOffset: 0,
              relative: false,
              refDistance: 1,
              maxDistance: 340282e33,
              rolloffFactor: 1,
              position: [0, 0, 0],
              velocity: [0, 0, 0],
              direction: [0, 0, 0],
              coneOuterGain: 0,
              coneInnerAngle: 360,
              coneOuterAngle: 360,
              distanceModel: 53250,
              spatialize: 2,
              get playbackRate() {
                return this.pitch * this.dopplerShift;
              }
            };
            AL.currentCtx.sources[src.id] = src;
            HEAP32[pSourceIds + i2 * 4 >>> 2 >>> 0] = src.id;
          }
        }
        _alGenSources.sig = "vip";
        var _alGetBoolean = (param) => {
          var val = AL.getGlobalParam("alGetBoolean", param);
          if (val === null) {
            return 0;
          }
          switch (param) {
            case 49152:
            case 49155:
            case 53248:
              return val !== 0 ? 1 : 0;
            default:
              AL.currentCtx.err = 40962;
              return 0;
          }
        };
        _alGetBoolean.sig = "ii";
        function _alGetBooleanv(param, pValues) {
          pValues >>>= 0;
          var val = AL.getGlobalParam("alGetBooleanv", param);
          if (val === null || !pValues) {
            return;
          }
          switch (param) {
            case 49152:
            case 49155:
            case 53248:
              HEAP8[pValues >>> 0 >>> 0] = val;
              break;
            default:
              AL.currentCtx.err = 40962;
              return;
          }
        }
        _alGetBooleanv.sig = "vip";
        function _alGetBuffer3f(bufferId, param, pValue0, pValue1, pValue2) {
          pValue0 >>>= 0;
          pValue1 >>>= 0;
          pValue2 >>>= 0;
          var val = AL.getBufferParam("alGetBuffer3f", bufferId, param);
          if (val === null) {
            return;
          }
          if (!pValue0 || !pValue1 || !pValue2) {
            AL.currentCtx.err = 40963;
            return;
          }
          AL.currentCtx.err = 40962;
        }
        _alGetBuffer3f.sig = "viippp";
        function _alGetBuffer3i(bufferId, param, pValue0, pValue1, pValue2) {
          pValue0 >>>= 0;
          pValue1 >>>= 0;
          pValue2 >>>= 0;
          var val = AL.getBufferParam("alGetBuffer3i", bufferId, param);
          if (val === null) {
            return;
          }
          if (!pValue0 || !pValue1 || !pValue2) {
            AL.currentCtx.err = 40963;
            return;
          }
          AL.currentCtx.err = 40962;
        }
        _alGetBuffer3i.sig = "viippp";
        function _alGetBufferf(bufferId, param, pValue) {
          pValue >>>= 0;
          var val = AL.getBufferParam("alGetBufferf", bufferId, param);
          if (val === null) {
            return;
          }
          if (!pValue) {
            AL.currentCtx.err = 40963;
            return;
          }
          AL.currentCtx.err = 40962;
        }
        _alGetBufferf.sig = "viip";
        function _alGetBufferfv(bufferId, param, pValues) {
          pValues >>>= 0;
          var val = AL.getBufferParam("alGetBufferfv", bufferId, param);
          if (val === null) {
            return;
          }
          if (!pValues) {
            AL.currentCtx.err = 40963;
            return;
          }
          AL.currentCtx.err = 40962;
        }
        _alGetBufferfv.sig = "viip";
        function _alGetBufferi(bufferId, param, pValue) {
          pValue >>>= 0;
          var val = AL.getBufferParam("alGetBufferi", bufferId, param);
          if (val === null) {
            return;
          }
          if (!pValue) {
            AL.currentCtx.err = 40963;
            return;
          }
          switch (param) {
            case 8193:
            case 8194:
            case 8195:
            case 8196:
              HEAP32[pValue >>> 2 >>> 0] = val;
              break;
            default:
              AL.currentCtx.err = 40962;
              return;
          }
        }
        _alGetBufferi.sig = "viip";
        function _alGetBufferiv(bufferId, param, pValues) {
          pValues >>>= 0;
          var val = AL.getBufferParam("alGetBufferiv", bufferId, param);
          if (val === null) {
            return;
          }
          if (!pValues) {
            AL.currentCtx.err = 40963;
            return;
          }
          switch (param) {
            case 8193:
            case 8194:
            case 8195:
            case 8196:
              HEAP32[pValues >>> 2 >>> 0] = val;
              break;
            case 8213:
              HEAP32[pValues >>> 2 >>> 0] = val[0];
              HEAP32[pValues + 4 >>> 2 >>> 0] = val[1];
              break;
            default:
              AL.currentCtx.err = 40962;
              return;
          }
        }
        _alGetBufferiv.sig = "viip";
        var _alGetDouble = (param) => {
          var val = AL.getGlobalParam("alGetDouble", param);
          if (val === null) {
            return 0;
          }
          switch (param) {
            case 49152:
            case 49155:
            case 53248:
              return val;
            default:
              AL.currentCtx.err = 40962;
              return 0;
          }
        };
        _alGetDouble.sig = "di";
        function _alGetDoublev(param, pValues) {
          pValues >>>= 0;
          var val = AL.getGlobalParam("alGetDoublev", param);
          if (val === null || !pValues) {
            return;
          }
          switch (param) {
            case 49152:
            case 49155:
            case 53248:
              HEAPF64[pValues >>> 3 >>> 0] = val;
              break;
            default:
              AL.currentCtx.err = 40962;
              return;
          }
        }
        _alGetDoublev.sig = "vip";
        function _alGetEnumValue(pEnumName) {
          pEnumName >>>= 0;
          if (!AL.currentCtx) {
            return 0;
          }
          if (!pEnumName) {
            AL.currentCtx.err = 40963;
            return 0;
          }
          var name2 = UTF8ToString(pEnumName);
          switch (name2) {
            case "AL_BITS":
              return 8194;
            case "AL_BUFFER":
              return 4105;
            case "AL_BUFFERS_PROCESSED":
              return 4118;
            case "AL_BUFFERS_QUEUED":
              return 4117;
            case "AL_BYTE_OFFSET":
              return 4134;
            case "AL_CHANNELS":
              return 8195;
            case "AL_CONE_INNER_ANGLE":
              return 4097;
            case "AL_CONE_OUTER_ANGLE":
              return 4098;
            case "AL_CONE_OUTER_GAIN":
              return 4130;
            case "AL_DIRECTION":
              return 4101;
            case "AL_DISTANCE_MODEL":
              return 53248;
            case "AL_DOPPLER_FACTOR":
              return 49152;
            case "AL_DOPPLER_VELOCITY":
              return 49153;
            case "AL_EXPONENT_DISTANCE":
              return 53253;
            case "AL_EXPONENT_DISTANCE_CLAMPED":
              return 53254;
            case "AL_EXTENSIONS":
              return 45060;
            case "AL_FORMAT_MONO16":
              return 4353;
            case "AL_FORMAT_MONO8":
              return 4352;
            case "AL_FORMAT_STEREO16":
              return 4355;
            case "AL_FORMAT_STEREO8":
              return 4354;
            case "AL_FREQUENCY":
              return 8193;
            case "AL_GAIN":
              return 4106;
            case "AL_INITIAL":
              return 4113;
            case "AL_INVALID":
              return -1;
            case "AL_ILLEGAL_ENUM":
            case "AL_INVALID_ENUM":
              return 40962;
            case "AL_INVALID_NAME":
              return 40961;
            case "AL_ILLEGAL_COMMAND":
            case "AL_INVALID_OPERATION":
              return 40964;
            case "AL_INVALID_VALUE":
              return 40963;
            case "AL_INVERSE_DISTANCE":
              return 53249;
            case "AL_INVERSE_DISTANCE_CLAMPED":
              return 53250;
            case "AL_LINEAR_DISTANCE":
              return 53251;
            case "AL_LINEAR_DISTANCE_CLAMPED":
              return 53252;
            case "AL_LOOPING":
              return 4103;
            case "AL_MAX_DISTANCE":
              return 4131;
            case "AL_MAX_GAIN":
              return 4110;
            case "AL_MIN_GAIN":
              return 4109;
            case "AL_NONE":
              return 0;
            case "AL_NO_ERROR":
              return 0;
            case "AL_ORIENTATION":
              return 4111;
            case "AL_OUT_OF_MEMORY":
              return 40965;
            case "AL_PAUSED":
              return 4115;
            case "AL_PENDING":
              return 8209;
            case "AL_PITCH":
              return 4099;
            case "AL_PLAYING":
              return 4114;
            case "AL_POSITION":
              return 4100;
            case "AL_PROCESSED":
              return 8210;
            case "AL_REFERENCE_DISTANCE":
              return 4128;
            case "AL_RENDERER":
              return 45059;
            case "AL_ROLLOFF_FACTOR":
              return 4129;
            case "AL_SAMPLE_OFFSET":
              return 4133;
            case "AL_SEC_OFFSET":
              return 4132;
            case "AL_SIZE":
              return 8196;
            case "AL_SOURCE_RELATIVE":
              return 514;
            case "AL_SOURCE_STATE":
              return 4112;
            case "AL_SOURCE_TYPE":
              return 4135;
            case "AL_SPEED_OF_SOUND":
              return 49155;
            case "AL_STATIC":
              return 4136;
            case "AL_STOPPED":
              return 4116;
            case "AL_STREAMING":
              return 4137;
            case "AL_UNDETERMINED":
              return 4144;
            case "AL_UNUSED":
              return 8208;
            case "AL_VELOCITY":
              return 4102;
            case "AL_VENDOR":
              return 45057;
            case "AL_VERSION":
              return 45058;
            case "AL_AUTO_SOFT":
              return 2;
            case "AL_SOURCE_DISTANCE_MODEL":
              return 512;
            case "AL_SOURCE_SPATIALIZE_SOFT":
              return 4628;
            case "AL_LOOP_POINTS_SOFT":
              return 8213;
            case "AL_BYTE_LENGTH_SOFT":
              return 8201;
            case "AL_SAMPLE_LENGTH_SOFT":
              return 8202;
            case "AL_SEC_LENGTH_SOFT":
              return 8203;
            case "AL_FORMAT_MONO_FLOAT32":
              return 65552;
            case "AL_FORMAT_STEREO_FLOAT32":
              return 65553;
            default:
              AL.currentCtx.err = 40963;
              return 0;
          }
        }
        _alGetEnumValue.sig = "ip";
        var _alGetError = () => {
          if (!AL.currentCtx) {
            return 40964;
          }
          var err2 = AL.currentCtx.err;
          AL.currentCtx.err = 0;
          return err2;
        };
        _alGetError.sig = "i";
        var _alGetFloat = (param) => {
          var val = AL.getGlobalParam("alGetFloat", param);
          if (val === null) {
            return 0;
          }
          switch (param) {
            case 49152:
            case 49155:
            case 53248:
              return val;
            default:
              return 0;
          }
        };
        _alGetFloat.sig = "fi";
        function _alGetFloatv(param, pValues) {
          pValues >>>= 0;
          var val = AL.getGlobalParam("alGetFloatv", param);
          if (val === null || !pValues) {
            return;
          }
          switch (param) {
            case 49152:
            case 49155:
            case 53248:
              HEAPF32[pValues >>> 2 >>> 0] = val;
              break;
            default:
              AL.currentCtx.err = 40962;
              return;
          }
        }
        _alGetFloatv.sig = "vip";
        var _alGetInteger = (param) => {
          var val = AL.getGlobalParam("alGetInteger", param);
          if (val === null) {
            return 0;
          }
          switch (param) {
            case 49152:
            case 49155:
            case 53248:
              return val;
            default:
              AL.currentCtx.err = 40962;
              return 0;
          }
        };
        _alGetInteger.sig = "ii";
        function _alGetIntegerv(param, pValues) {
          pValues >>>= 0;
          var val = AL.getGlobalParam("alGetIntegerv", param);
          if (val === null || !pValues) {
            return;
          }
          switch (param) {
            case 49152:
            case 49155:
            case 53248:
              HEAP32[pValues >>> 2 >>> 0] = val;
              break;
            default:
              AL.currentCtx.err = 40962;
              return;
          }
        }
        _alGetIntegerv.sig = "vip";
        function _alGetListener3f(param, pValue0, pValue1, pValue2) {
          pValue0 >>>= 0;
          pValue1 >>>= 0;
          pValue2 >>>= 0;
          var val = AL.getListenerParam("alGetListener3f", param);
          if (val === null) {
            return;
          }
          if (!pValue0 || !pValue1 || !pValue2) {
            AL.currentCtx.err = 40963;
            return;
          }
          switch (param) {
            case 4100:
            case 4102:
              HEAPF32[pValue0 >>> 2 >>> 0] = val[0];
              HEAPF32[pValue1 >>> 2 >>> 0] = val[1];
              HEAPF32[pValue2 >>> 2 >>> 0] = val[2];
              break;
            default:
              AL.currentCtx.err = 40962;
              return;
          }
        }
        _alGetListener3f.sig = "vippp";
        function _alGetListener3i(param, pValue0, pValue1, pValue2) {
          pValue0 >>>= 0;
          pValue1 >>>= 0;
          pValue2 >>>= 0;
          var val = AL.getListenerParam("alGetListener3i", param);
          if (val === null) {
            return;
          }
          if (!pValue0 || !pValue1 || !pValue2) {
            AL.currentCtx.err = 40963;
            return;
          }
          switch (param) {
            case 4100:
            case 4102:
              HEAP32[pValue0 >>> 2 >>> 0] = val[0];
              HEAP32[pValue1 >>> 2 >>> 0] = val[1];
              HEAP32[pValue2 >>> 2 >>> 0] = val[2];
              break;
            default:
              AL.currentCtx.err = 40962;
              return;
          }
        }
        _alGetListener3i.sig = "vippp";
        function _alGetListenerf(param, pValue) {
          pValue >>>= 0;
          var val = AL.getListenerParam("alGetListenerf", param);
          if (val === null) {
            return;
          }
          if (!pValue) {
            AL.currentCtx.err = 40963;
            return;
          }
          switch (param) {
            case 4106:
              HEAPF32[pValue >>> 2 >>> 0] = val;
              break;
            default:
              AL.currentCtx.err = 40962;
              return;
          }
        }
        _alGetListenerf.sig = "vip";
        function _alGetListenerfv(param, pValues) {
          pValues >>>= 0;
          var val = AL.getListenerParam("alGetListenerfv", param);
          if (val === null) {
            return;
          }
          if (!pValues) {
            AL.currentCtx.err = 40963;
            return;
          }
          switch (param) {
            case 4100:
            case 4102:
              HEAPF32[pValues >>> 2 >>> 0] = val[0];
              HEAPF32[pValues + 4 >>> 2 >>> 0] = val[1];
              HEAPF32[pValues + 8 >>> 2 >>> 0] = val[2];
              break;
            case 4111:
              HEAPF32[pValues >>> 2 >>> 0] = val[0];
              HEAPF32[pValues + 4 >>> 2 >>> 0] = val[1];
              HEAPF32[pValues + 8 >>> 2 >>> 0] = val[2];
              HEAPF32[pValues + 12 >>> 2 >>> 0] = val[3];
              HEAPF32[pValues + 16 >>> 2 >>> 0] = val[4];
              HEAPF32[pValues + 20 >>> 2 >>> 0] = val[5];
              break;
            default:
              AL.currentCtx.err = 40962;
              return;
          }
        }
        _alGetListenerfv.sig = "vip";
        function _alGetListeneri(param, pValue) {
          pValue >>>= 0;
          var val = AL.getListenerParam("alGetListeneri", param);
          if (val === null) {
            return;
          }
          if (!pValue) {
            AL.currentCtx.err = 40963;
            return;
          }
          AL.currentCtx.err = 40962;
        }
        _alGetListeneri.sig = "vip";
        function _alGetListeneriv(param, pValues) {
          pValues >>>= 0;
          var val = AL.getListenerParam("alGetListeneriv", param);
          if (val === null) {
            return;
          }
          if (!pValues) {
            AL.currentCtx.err = 40963;
            return;
          }
          switch (param) {
            case 4100:
            case 4102:
              HEAP32[pValues >>> 2 >>> 0] = val[0];
              HEAP32[pValues + 4 >>> 2 >>> 0] = val[1];
              HEAP32[pValues + 8 >>> 2 >>> 0] = val[2];
              break;
            case 4111:
              HEAP32[pValues >>> 2 >>> 0] = val[0];
              HEAP32[pValues + 4 >>> 2 >>> 0] = val[1];
              HEAP32[pValues + 8 >>> 2 >>> 0] = val[2];
              HEAP32[pValues + 12 >>> 2 >>> 0] = val[3];
              HEAP32[pValues + 16 >>> 2 >>> 0] = val[4];
              HEAP32[pValues + 20 >>> 2 >>> 0] = val[5];
              break;
            default:
              AL.currentCtx.err = 40962;
              return;
          }
        }
        _alGetListeneriv.sig = "vip";
        function _alGetSource3f(sourceId, param, pValue0, pValue1, pValue2) {
          pValue0 >>>= 0;
          pValue1 >>>= 0;
          pValue2 >>>= 0;
          var val = AL.getSourceParam("alGetSource3f", sourceId, param);
          if (val === null) {
            return;
          }
          if (!pValue0 || !pValue1 || !pValue2) {
            AL.currentCtx.err = 40963;
            return;
          }
          switch (param) {
            case 4100:
            case 4101:
            case 4102:
              HEAPF32[pValue0 >>> 2 >>> 0] = val[0];
              HEAPF32[pValue1 >>> 2 >>> 0] = val[1];
              HEAPF32[pValue2 >>> 2 >>> 0] = val[2];
              break;
            default:
              AL.currentCtx.err = 40962;
              return;
          }
        }
        _alGetSource3f.sig = "viippp";
        function _alGetSource3i(sourceId, param, pValue0, pValue1, pValue2) {
          pValue0 >>>= 0;
          pValue1 >>>= 0;
          pValue2 >>>= 0;
          var val = AL.getSourceParam("alGetSource3i", sourceId, param);
          if (val === null) {
            return;
          }
          if (!pValue0 || !pValue1 || !pValue2) {
            AL.currentCtx.err = 40963;
            return;
          }
          switch (param) {
            case 4100:
            case 4101:
            case 4102:
              HEAP32[pValue0 >>> 2 >>> 0] = val[0];
              HEAP32[pValue1 >>> 2 >>> 0] = val[1];
              HEAP32[pValue2 >>> 2 >>> 0] = val[2];
              break;
            default:
              AL.currentCtx.err = 40962;
              return;
          }
        }
        _alGetSource3i.sig = "viippp";
        function _alGetSourcef(sourceId, param, pValue) {
          pValue >>>= 0;
          var val = AL.getSourceParam("alGetSourcef", sourceId, param);
          if (val === null) {
            return;
          }
          if (!pValue) {
            AL.currentCtx.err = 40963;
            return;
          }
          switch (param) {
            case 4097:
            case 4098:
            case 4099:
            case 4106:
            case 4109:
            case 4110:
            case 4128:
            case 4129:
            case 4130:
            case 4131:
            case 4132:
            case 4133:
            case 4134:
            case 8203:
              HEAPF32[pValue >>> 2 >>> 0] = val;
              break;
            default:
              AL.currentCtx.err = 40962;
              return;
          }
        }
        _alGetSourcef.sig = "viip";
        function _alGetSourcefv(sourceId, param, pValues) {
          pValues >>>= 0;
          var val = AL.getSourceParam("alGetSourcefv", sourceId, param);
          if (val === null) {
            return;
          }
          if (!pValues) {
            AL.currentCtx.err = 40963;
            return;
          }
          switch (param) {
            case 4097:
            case 4098:
            case 4099:
            case 4106:
            case 4109:
            case 4110:
            case 4128:
            case 4129:
            case 4130:
            case 4131:
            case 4132:
            case 4133:
            case 4134:
            case 8203:
              HEAPF32[pValues >>> 2 >>> 0] = val[0];
              break;
            case 4100:
            case 4101:
            case 4102:
              HEAPF32[pValues >>> 2 >>> 0] = val[0];
              HEAPF32[pValues + 4 >>> 2 >>> 0] = val[1];
              HEAPF32[pValues + 8 >>> 2 >>> 0] = val[2];
              break;
            default:
              AL.currentCtx.err = 40962;
              return;
          }
        }
        _alGetSourcefv.sig = "viip";
        function _alGetSourcei(sourceId, param, pValue) {
          pValue >>>= 0;
          var val = AL.getSourceParam("alGetSourcei", sourceId, param);
          if (val === null) {
            return;
          }
          if (!pValue) {
            AL.currentCtx.err = 40963;
            return;
          }
          switch (param) {
            case 514:
            case 4097:
            case 4098:
            case 4103:
            case 4105:
            case 4112:
            case 4117:
            case 4118:
            case 4128:
            case 4129:
            case 4131:
            case 4132:
            case 4133:
            case 4134:
            case 4135:
            case 4628:
            case 8201:
            case 8202:
            case 53248:
              HEAP32[pValue >>> 2 >>> 0] = val;
              break;
            default:
              AL.currentCtx.err = 40962;
              return;
          }
        }
        _alGetSourcei.sig = "viip";
        function _alGetSourceiv(sourceId, param, pValues) {
          pValues >>>= 0;
          var val = AL.getSourceParam("alGetSourceiv", sourceId, param);
          if (val === null) {
            return;
          }
          if (!pValues) {
            AL.currentCtx.err = 40963;
            return;
          }
          switch (param) {
            case 514:
            case 4097:
            case 4098:
            case 4103:
            case 4105:
            case 4112:
            case 4117:
            case 4118:
            case 4128:
            case 4129:
            case 4131:
            case 4132:
            case 4133:
            case 4134:
            case 4135:
            case 4628:
            case 8201:
            case 8202:
            case 53248:
              HEAP32[pValues >>> 2 >>> 0] = val;
              break;
            case 4100:
            case 4101:
            case 4102:
              HEAP32[pValues >>> 2 >>> 0] = val[0];
              HEAP32[pValues + 4 >>> 2 >>> 0] = val[1];
              HEAP32[pValues + 8 >>> 2 >>> 0] = val[2];
              break;
            default:
              AL.currentCtx.err = 40962;
              return;
          }
        }
        _alGetSourceiv.sig = "viip";
        function _alGetString(param) {
          if (AL.stringCache[param]) {
            return AL.stringCache[param];
          }
          var ret;
          switch (param) {
            case 0:
              ret = "No Error";
              break;
            case 40961:
              ret = "Invalid Name";
              break;
            case 40962:
              ret = "Invalid Enum";
              break;
            case 40963:
              ret = "Invalid Value";
              break;
            case 40964:
              ret = "Invalid Operation";
              break;
            case 40965:
              ret = "Out of Memory";
              break;
            case 45057:
              ret = "Emscripten";
              break;
            case 45058:
              ret = "1.1";
              break;
            case 45059:
              ret = "WebAudio";
              break;
            case 45060:
              ret = "";
              for (var ext in AL.AL_EXTENSIONS) {
                ret = ret.concat(ext);
                ret = ret.concat(" ");
              }
              ret = ret.trim();
              break;
            default:
              if (AL.currentCtx) {
                AL.currentCtx.err = 40962;
              } else {
              }
              return 0;
          }
          ret = stringToNewUTF8(ret);
          AL.stringCache[param] = ret;
          return ret;
        }
        _alGetString.sig = "pi";
        var _alIsBuffer = (bufferId) => {
          if (!AL.currentCtx) {
            return false;
          }
          if (bufferId > AL.buffers.length) {
            return false;
          }
          if (!AL.buffers[bufferId]) {
            return false;
          }
          return true;
        };
        _alIsBuffer.sig = "ii";
        var _alIsEnabled = (param) => {
          if (!AL.currentCtx) {
            return 0;
          }
          switch (param) {
            case "AL_SOURCE_DISTANCE_MODEL":
              return AL.currentCtx.sourceDistanceModel ? 0 : 1;
            default:
              AL.currentCtx.err = 40962;
              return 0;
          }
        };
        _alIsEnabled.sig = "ii";
        function _alIsExtensionPresent(pExtName) {
          pExtName >>>= 0;
          var name2 = UTF8ToString(pExtName);
          return AL.AL_EXTENSIONS[name2] ? 1 : 0;
        }
        _alIsExtensionPresent.sig = "ip";
        var _alIsSource = (sourceId) => {
          if (!AL.currentCtx) {
            return false;
          }
          if (!AL.currentCtx.sources[sourceId]) {
            return false;
          }
          return true;
        };
        _alIsSource.sig = "ii";
        var _alListener3f = (param, value0, value1, value2) => {
          switch (param) {
            case 4100:
            case 4102:
              AL.paramArray[0] = value0;
              AL.paramArray[1] = value1;
              AL.paramArray[2] = value2;
              AL.setListenerParam("alListener3f", param, AL.paramArray);
              break;
            default:
              AL.setListenerParam("alListener3f", param, null);
              break;
          }
        };
        _alListener3f.sig = "vifff";
        var _alListener3i = (param, value0, value1, value2) => {
          switch (param) {
            case 4100:
            case 4102:
              AL.paramArray[0] = value0;
              AL.paramArray[1] = value1;
              AL.paramArray[2] = value2;
              AL.setListenerParam("alListener3i", param, AL.paramArray);
              break;
            default:
              AL.setListenerParam("alListener3i", param, null);
              break;
          }
        };
        _alListener3i.sig = "viiii";
        var _alListenerf = (param, value) => {
          switch (param) {
            case 4106:
              AL.setListenerParam("alListenerf", param, value);
              break;
            default:
              AL.setListenerParam("alListenerf", param, null);
              break;
          }
        };
        _alListenerf.sig = "vif";
        function _alListenerfv(param, pValues) {
          pValues >>>= 0;
          if (!AL.currentCtx) {
            return;
          }
          if (!pValues) {
            AL.currentCtx.err = 40963;
            return;
          }
          switch (param) {
            case 4100:
            case 4102:
              AL.paramArray[0] = HEAPF32[pValues >>> 2 >>> 0];
              AL.paramArray[1] = HEAPF32[pValues + 4 >>> 2 >>> 0];
              AL.paramArray[2] = HEAPF32[pValues + 8 >>> 2 >>> 0];
              AL.setListenerParam("alListenerfv", param, AL.paramArray);
              break;
            case 4111:
              AL.paramArray[0] = HEAPF32[pValues >>> 2 >>> 0];
              AL.paramArray[1] = HEAPF32[pValues + 4 >>> 2 >>> 0];
              AL.paramArray[2] = HEAPF32[pValues + 8 >>> 2 >>> 0];
              AL.paramArray[3] = HEAPF32[pValues + 12 >>> 2 >>> 0];
              AL.paramArray[4] = HEAPF32[pValues + 16 >>> 2 >>> 0];
              AL.paramArray[5] = HEAPF32[pValues + 20 >>> 2 >>> 0];
              AL.setListenerParam("alListenerfv", param, AL.paramArray);
              break;
            default:
              AL.setListenerParam("alListenerfv", param, null);
              break;
          }
        }
        _alListenerfv.sig = "vip";
        var _alListeneri = (param, value) => {
          AL.setListenerParam("alListeneri", param, null);
        };
        _alListeneri.sig = "vii";
        function _alListeneriv(param, pValues) {
          pValues >>>= 0;
          if (!AL.currentCtx) {
            return;
          }
          if (!pValues) {
            AL.currentCtx.err = 40963;
            return;
          }
          switch (param) {
            case 4100:
            case 4102:
              AL.paramArray[0] = HEAP32[pValues >>> 2 >>> 0];
              AL.paramArray[1] = HEAP32[pValues + 4 >>> 2 >>> 0];
              AL.paramArray[2] = HEAP32[pValues + 8 >>> 2 >>> 0];
              AL.setListenerParam("alListeneriv", param, AL.paramArray);
              break;
            case 4111:
              AL.paramArray[0] = HEAP32[pValues >>> 2 >>> 0];
              AL.paramArray[1] = HEAP32[pValues + 4 >>> 2 >>> 0];
              AL.paramArray[2] = HEAP32[pValues + 8 >>> 2 >>> 0];
              AL.paramArray[3] = HEAP32[pValues + 12 >>> 2 >>> 0];
              AL.paramArray[4] = HEAP32[pValues + 16 >>> 2 >>> 0];
              AL.paramArray[5] = HEAP32[pValues + 20 >>> 2 >>> 0];
              AL.setListenerParam("alListeneriv", param, AL.paramArray);
              break;
            default:
              AL.setListenerParam("alListeneriv", param, null);
              break;
          }
        }
        _alListeneriv.sig = "vip";
        var _alSource3f = (sourceId, param, value0, value1, value2) => {
          switch (param) {
            case 4100:
            case 4101:
            case 4102:
              AL.paramArray[0] = value0;
              AL.paramArray[1] = value1;
              AL.paramArray[2] = value2;
              AL.setSourceParam("alSource3f", sourceId, param, AL.paramArray);
              break;
            default:
              AL.setSourceParam("alSource3f", sourceId, param, null);
              break;
          }
        };
        _alSource3f.sig = "viifff";
        var _alSource3i = (sourceId, param, value0, value1, value2) => {
          switch (param) {
            case 4100:
            case 4101:
            case 4102:
              AL.paramArray[0] = value0;
              AL.paramArray[1] = value1;
              AL.paramArray[2] = value2;
              AL.setSourceParam("alSource3i", sourceId, param, AL.paramArray);
              break;
            default:
              AL.setSourceParam("alSource3i", sourceId, param, null);
              break;
          }
        };
        _alSource3i.sig = "viiiii";
        var _alSourcePause = (sourceId) => {
          if (!AL.currentCtx) {
            return;
          }
          var src = AL.currentCtx.sources[sourceId];
          if (!src) {
            AL.currentCtx.err = 40961;
            return;
          }
          AL.setSourceState(src, 4115);
        };
        _alSourcePause.sig = "vi";
        function _alSourcePausev(count, pSourceIds) {
          pSourceIds >>>= 0;
          if (!AL.currentCtx) {
            return;
          }
          if (!pSourceIds) {
            AL.currentCtx.err = 40963;
          }
          for (var i2 = 0; i2 < count; ++i2) {
            if (!AL.currentCtx.sources[HEAP32[pSourceIds + i2 * 4 >>> 2 >>> 0]]) {
              AL.currentCtx.err = 40961;
              return;
            }
          }
          for (var i2 = 0; i2 < count; ++i2) {
            var srcId = HEAP32[pSourceIds + i2 * 4 >>> 2 >>> 0];
            AL.setSourceState(AL.currentCtx.sources[srcId], 4115);
          }
        }
        _alSourcePausev.sig = "vip";
        var _alSourcePlay = (sourceId) => {
          if (!AL.currentCtx) {
            return;
          }
          var src = AL.currentCtx.sources[sourceId];
          if (!src) {
            AL.currentCtx.err = 40961;
            return;
          }
          AL.setSourceState(src, 4114);
        };
        _alSourcePlay.sig = "vi";
        function _alSourcePlayv(count, pSourceIds) {
          pSourceIds >>>= 0;
          if (!AL.currentCtx) {
            return;
          }
          if (!pSourceIds) {
            AL.currentCtx.err = 40963;
          }
          for (var i2 = 0; i2 < count; ++i2) {
            if (!AL.currentCtx.sources[HEAP32[pSourceIds + i2 * 4 >>> 2 >>> 0]]) {
              AL.currentCtx.err = 40961;
              return;
            }
          }
          for (var i2 = 0; i2 < count; ++i2) {
            var srcId = HEAP32[pSourceIds + i2 * 4 >>> 2 >>> 0];
            AL.setSourceState(AL.currentCtx.sources[srcId], 4114);
          }
        }
        _alSourcePlayv.sig = "vip";
        function _alSourceQueueBuffers(sourceId, count, pBufferIds) {
          pBufferIds >>>= 0;
          if (!AL.currentCtx) {
            return;
          }
          var src = AL.currentCtx.sources[sourceId];
          if (!src) {
            AL.currentCtx.err = 40961;
            return;
          }
          if (src.type === 4136) {
            AL.currentCtx.err = 40964;
            return;
          }
          if (count === 0) {
            return;
          }
          var templateBuf = AL.buffers[0];
          for (var i2 = 0; i2 < src.bufQueue.length; i2++) {
            if (src.bufQueue[i2].id !== 0) {
              templateBuf = src.bufQueue[i2];
              break;
            }
          }
          for (var i2 = 0; i2 < count; ++i2) {
            var bufId = HEAP32[pBufferIds + i2 * 4 >>> 2 >>> 0];
            var buf = AL.buffers[bufId];
            if (!buf) {
              AL.currentCtx.err = 40961;
              return;
            }
            if (templateBuf.id !== 0 && (buf.frequency !== templateBuf.frequency || buf.bytesPerSample !== templateBuf.bytesPerSample || buf.channels !== templateBuf.channels)) {
              AL.currentCtx.err = 40964;
            }
          }
          if (src.bufQueue.length === 1 && src.bufQueue[0].id === 0) {
            src.bufQueue.length = 0;
          }
          src.type = 4137;
          for (var i2 = 0; i2 < count; ++i2) {
            var bufId = HEAP32[pBufferIds + i2 * 4 >>> 2 >>> 0];
            var buf = AL.buffers[bufId];
            buf.refCount++;
            src.bufQueue.push(buf);
          }
          if (src.looping) {
            AL.cancelPendingSourceAudio(src);
          }
          AL.initSourcePanner(src);
          AL.scheduleSourceAudio(src);
        }
        _alSourceQueueBuffers.sig = "viip";
        var _alSourceRewind = (sourceId) => {
          if (!AL.currentCtx) {
            return;
          }
          var src = AL.currentCtx.sources[sourceId];
          if (!src) {
            AL.currentCtx.err = 40961;
            return;
          }
          AL.setSourceState(src, 4116);
          AL.setSourceState(src, 4113);
        };
        _alSourceRewind.sig = "vi";
        function _alSourceRewindv(count, pSourceIds) {
          pSourceIds >>>= 0;
          if (!AL.currentCtx) {
            return;
          }
          if (!pSourceIds) {
            AL.currentCtx.err = 40963;
          }
          for (var i2 = 0; i2 < count; ++i2) {
            if (!AL.currentCtx.sources[HEAP32[pSourceIds + i2 * 4 >>> 2 >>> 0]]) {
              AL.currentCtx.err = 40961;
              return;
            }
          }
          for (var i2 = 0; i2 < count; ++i2) {
            var srcId = HEAP32[pSourceIds + i2 * 4 >>> 2 >>> 0];
            AL.setSourceState(AL.currentCtx.sources[srcId], 4113);
          }
        }
        _alSourceRewindv.sig = "vip";
        var _alSourceStop = (sourceId) => {
          if (!AL.currentCtx) {
            return;
          }
          var src = AL.currentCtx.sources[sourceId];
          if (!src) {
            AL.currentCtx.err = 40961;
            return;
          }
          AL.setSourceState(src, 4116);
        };
        _alSourceStop.sig = "vi";
        function _alSourceStopv(count, pSourceIds) {
          pSourceIds >>>= 0;
          if (!AL.currentCtx) {
            return;
          }
          if (!pSourceIds) {
            AL.currentCtx.err = 40963;
          }
          for (var i2 = 0; i2 < count; ++i2) {
            if (!AL.currentCtx.sources[HEAP32[pSourceIds + i2 * 4 >>> 2 >>> 0]]) {
              AL.currentCtx.err = 40961;
              return;
            }
          }
          for (var i2 = 0; i2 < count; ++i2) {
            var srcId = HEAP32[pSourceIds + i2 * 4 >>> 2 >>> 0];
            AL.setSourceState(AL.currentCtx.sources[srcId], 4116);
          }
        }
        _alSourceStopv.sig = "vip";
        function _alSourceUnqueueBuffers(sourceId, count, pBufferIds) {
          pBufferIds >>>= 0;
          if (!AL.currentCtx) {
            return;
          }
          var src = AL.currentCtx.sources[sourceId];
          if (!src) {
            AL.currentCtx.err = 40961;
            return;
          }
          if (count > (src.bufQueue.length === 1 && src.bufQueue[0].id === 0 ? 0 : src.bufsProcessed)) {
            AL.currentCtx.err = 40963;
            return;
          }
          if (count === 0) {
            return;
          }
          for (var i2 = 0; i2 < count; i2++) {
            var buf = src.bufQueue.shift();
            buf.refCount--;
            HEAP32[pBufferIds + i2 * 4 >>> 2 >>> 0] = buf.id;
            src.bufsProcessed--;
          }
          if (src.bufQueue.length === 0) {
            src.bufQueue.push(AL.buffers[0]);
          }
          AL.initSourcePanner(src);
          AL.scheduleSourceAudio(src);
        }
        _alSourceUnqueueBuffers.sig = "viip";
        var _alSourcef = (sourceId, param, value) => {
          switch (param) {
            case 4097:
            case 4098:
            case 4099:
            case 4106:
            case 4109:
            case 4110:
            case 4128:
            case 4129:
            case 4130:
            case 4131:
            case 4132:
            case 4133:
            case 4134:
            case 8203:
              AL.setSourceParam("alSourcef", sourceId, param, value);
              break;
            default:
              AL.setSourceParam("alSourcef", sourceId, param, null);
              break;
          }
        };
        _alSourcef.sig = "viif";
        function _alSourcefv(sourceId, param, pValues) {
          pValues >>>= 0;
          if (!AL.currentCtx) {
            return;
          }
          if (!pValues) {
            AL.currentCtx.err = 40963;
            return;
          }
          switch (param) {
            case 4097:
            case 4098:
            case 4099:
            case 4106:
            case 4109:
            case 4110:
            case 4128:
            case 4129:
            case 4130:
            case 4131:
            case 4132:
            case 4133:
            case 4134:
            case 8203:
              var val = HEAPF32[pValues >>> 2 >>> 0];
              AL.setSourceParam("alSourcefv", sourceId, param, val);
              break;
            case 4100:
            case 4101:
            case 4102:
              AL.paramArray[0] = HEAPF32[pValues >>> 2 >>> 0];
              AL.paramArray[1] = HEAPF32[pValues + 4 >>> 2 >>> 0];
              AL.paramArray[2] = HEAPF32[pValues + 8 >>> 2 >>> 0];
              AL.setSourceParam("alSourcefv", sourceId, param, AL.paramArray);
              break;
            default:
              AL.setSourceParam("alSourcefv", sourceId, param, null);
              break;
          }
        }
        _alSourcefv.sig = "viip";
        function _alSourceiv(sourceId, param, pValues) {
          pValues >>>= 0;
          if (!AL.currentCtx) {
            return;
          }
          if (!pValues) {
            AL.currentCtx.err = 40963;
            return;
          }
          switch (param) {
            case 514:
            case 4097:
            case 4098:
            case 4103:
            case 4105:
            case 4128:
            case 4129:
            case 4131:
            case 4132:
            case 4133:
            case 4134:
            case 4628:
            case 8201:
            case 8202:
            case 53248:
              var val = HEAP32[pValues >>> 2 >>> 0];
              AL.setSourceParam("alSourceiv", sourceId, param, val);
              break;
            case 4100:
            case 4101:
            case 4102:
              AL.paramArray[0] = HEAP32[pValues >>> 2 >>> 0];
              AL.paramArray[1] = HEAP32[pValues + 4 >>> 2 >>> 0];
              AL.paramArray[2] = HEAP32[pValues + 8 >>> 2 >>> 0];
              AL.setSourceParam("alSourceiv", sourceId, param, AL.paramArray);
              break;
            default:
              AL.setSourceParam("alSourceiv", sourceId, param, null);
              break;
          }
        }
        _alSourceiv.sig = "viip";
        var _alSpeedOfSound = (value) => {
          AL.setGlobalParam("alSpeedOfSound", 49155, value);
        };
        _alSpeedOfSound.sig = "vf";
        var _alcCaptureCloseDevice = function(deviceId) {
          var _a, _b, _c, _d;
          deviceId >>>= 0;
          var c = AL.requireValidCaptureDevice(deviceId, "alcCaptureCloseDevice");
          if (!c)
            return false;
          delete AL.captures[deviceId];
          AL.freeIds.push(deviceId);
          (_a = c.mediaStreamSourceNode) == null ? void 0 : _a.disconnect();
          (_b = c.mergerNode) == null ? void 0 : _b.disconnect();
          (_c = c.splitterNode) == null ? void 0 : _c.disconnect();
          (_d = c.scriptProcessorNode) == null ? void 0 : _d.disconnect();
          if (c.mediaStream) {
            c.mediaStream.getTracks().forEach((track) => track.stop());
          }
          delete c.buffers;
          c.capturedFrameCount = 0;
          c.isCapturing = false;
          return true;
        };
        _alcCaptureCloseDevice.sig = "ip";
        var listenOnce = (object, event2, func2) => {
          object.addEventListener(event2, func2, {
            "once": true
          });
        };
        var autoResumeAudioContext = (ctx, elements) => {
          if (!elements) {
            elements = [document, document.getElementById("canvas")];
          }
          ["keydown", "mousedown", "touchstart"].forEach((event2) => {
            elements.forEach((element) => {
              if (element) {
                listenOnce(element, event2, () => {
                  if (ctx.state === "suspended")
                    ctx.resume();
                });
              }
            });
          });
        };
        function _alcCaptureOpenDevice(pDeviceName, requestedSampleRate, format, bufferFrameCapacity) {
          var _a;
          pDeviceName >>>= 0;
          var resolvedDeviceName = AL.CAPTURE_DEVICE_NAME;
          if (pDeviceName !== 0) {
            resolvedDeviceName = UTF8ToString(pDeviceName);
            if (resolvedDeviceName !== AL.CAPTURE_DEVICE_NAME) {
              AL.alcErr = 40965;
              return 0;
            }
          }
          if (bufferFrameCapacity < 0) {
            AL.alcErr = 40964;
            return 0;
          }
          navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;
          var has_getUserMedia = navigator.getUserMedia || navigator.mediaDevices && navigator.mediaDevices.getUserMedia;
          if (!has_getUserMedia) {
            AL.alcErr = 40965;
            return 0;
          }
          var AudioContext2 = window.AudioContext || window.webkitAudioContext;
          if (!AL.sharedCaptureAudioCtx) {
            try {
              AL.sharedCaptureAudioCtx = new AudioContext2();
            } catch (e) {
              AL.alcErr = 40965;
              return 0;
            }
          }
          autoResumeAudioContext(AL.sharedCaptureAudioCtx);
          var outputChannelCount;
          switch (format) {
            case 65552:
            case 4353:
            case 4352:
              outputChannelCount = 1;
              break;
            case 65553:
            case 4355:
            case 4354:
              outputChannelCount = 2;
              break;
            default:
              AL.alcErr = 40964;
              return 0;
          }
          function newF32Array(cap) {
            return new Float32Array(cap);
          }
          function newI16Array(cap) {
            return new Int16Array(cap);
          }
          function newU8Array(cap) {
            return new Uint8Array(cap);
          }
          var requestedSampleType;
          var newSampleArray;
          switch (format) {
            case 65552:
            case 65553:
              requestedSampleType = "f32";
              newSampleArray = newF32Array;
              break;
            case 4353:
            case 4355:
              requestedSampleType = "i16";
              newSampleArray = newI16Array;
              break;
            case 4352:
            case 4354:
              requestedSampleType = "u8";
              newSampleArray = newU8Array;
              break;
          }
          var buffers = [];
          try {
            for (var chan = 0; chan < outputChannelCount; ++chan) {
              buffers[chan] = newSampleArray(bufferFrameCapacity);
            }
          } catch (e) {
            AL.alcErr = 40965;
            return 0;
          }
          var newCapture = {
            audioCtx: AL.sharedCaptureAudioCtx,
            deviceName: resolvedDeviceName,
            requestedSampleRate,
            requestedSampleType,
            outputChannelCount,
            inputChannelCount: null,
            mediaStreamError: null,
            mediaStreamSourceNode: null,
            mediaStream: null,
            mergerNode: null,
            splitterNode: null,
            scriptProcessorNode: null,
            isCapturing: false,
            buffers,
            get bufferFrameCapacity() {
              return buffers[0].length;
            },
            capturePlayhead: 0,
            captureReadhead: 0,
            capturedFrameCount: 0
          };
          var onError = (mediaStreamError) => {
            newCapture.mediaStreamError = mediaStreamError;
          };
          var onSuccess = (mediaStream) => {
            newCapture.mediaStreamSourceNode = newCapture.audioCtx.createMediaStreamSource(mediaStream);
            newCapture.mediaStream = mediaStream;
            var inputChannelCount = 1;
            switch (newCapture.mediaStreamSourceNode.channelCountMode) {
              case "max":
                inputChannelCount = outputChannelCount;
                break;
              case "clamped-max":
                inputChannelCount = Math.min(outputChannelCount, newCapture.mediaStreamSourceNode.channelCount);
                break;
              case "explicit":
                inputChannelCount = newCapture.mediaStreamSourceNode.channelCount;
                break;
            }
            newCapture.inputChannelCount = inputChannelCount;
            var processorFrameCount = 512;
            newCapture.scriptProcessorNode = newCapture.audioCtx.createScriptProcessor(processorFrameCount, inputChannelCount, outputChannelCount);
            if (inputChannelCount > outputChannelCount) {
              newCapture.mergerNode = newCapture.audioCtx.createChannelMerger(inputChannelCount);
              newCapture.mediaStreamSourceNode.connect(newCapture.mergerNode);
              newCapture.mergerNode.connect(newCapture.scriptProcessorNode);
            } else if (inputChannelCount < outputChannelCount) {
              newCapture.splitterNode = newCapture.audioCtx.createChannelSplitter(outputChannelCount);
              newCapture.mediaStreamSourceNode.connect(newCapture.splitterNode);
              newCapture.splitterNode.connect(newCapture.scriptProcessorNode);
            } else {
              newCapture.mediaStreamSourceNode.connect(newCapture.scriptProcessorNode);
            }
            newCapture.scriptProcessorNode.connect(newCapture.audioCtx.destination);
            newCapture.scriptProcessorNode.onaudioprocess = (audioProcessingEvent) => {
              if (!newCapture.isCapturing) {
                return;
              }
              var c = newCapture;
              var srcBuf = audioProcessingEvent.inputBuffer;
              switch (format) {
                case 65552:
                  var channel0 = srcBuf.getChannelData(0);
                  for (var i2 = 0; i2 < srcBuf.length; ++i2) {
                    var wi = (c.capturePlayhead + i2) % c.bufferFrameCapacity;
                    c.buffers[0][wi] = channel0[i2];
                  }
                  break;
                case 65553:
                  var channel0 = srcBuf.getChannelData(0);
                  var channel1 = srcBuf.getChannelData(1);
                  for (var i2 = 0; i2 < srcBuf.length; ++i2) {
                    var wi = (c.capturePlayhead + i2) % c.bufferFrameCapacity;
                    c.buffers[0][wi] = channel0[i2];
                    c.buffers[1][wi] = channel1[i2];
                  }
                  break;
                case 4353:
                  var channel0 = srcBuf.getChannelData(0);
                  for (var i2 = 0; i2 < srcBuf.length; ++i2) {
                    var wi = (c.capturePlayhead + i2) % c.bufferFrameCapacity;
                    c.buffers[0][wi] = channel0[i2] * 32767;
                  }
                  break;
                case 4355:
                  var channel0 = srcBuf.getChannelData(0);
                  var channel1 = srcBuf.getChannelData(1);
                  for (var i2 = 0; i2 < srcBuf.length; ++i2) {
                    var wi = (c.capturePlayhead + i2) % c.bufferFrameCapacity;
                    c.buffers[0][wi] = channel0[i2] * 32767;
                    c.buffers[1][wi] = channel1[i2] * 32767;
                  }
                  break;
                case 4352:
                  var channel0 = srcBuf.getChannelData(0);
                  for (var i2 = 0; i2 < srcBuf.length; ++i2) {
                    var wi = (c.capturePlayhead + i2) % c.bufferFrameCapacity;
                    c.buffers[0][wi] = (channel0[i2] + 1) * 127;
                  }
                  break;
                case 4354:
                  var channel0 = srcBuf.getChannelData(0);
                  var channel1 = srcBuf.getChannelData(1);
                  for (var i2 = 0; i2 < srcBuf.length; ++i2) {
                    var wi = (c.capturePlayhead + i2) % c.bufferFrameCapacity;
                    c.buffers[0][wi] = (channel0[i2] + 1) * 127;
                    c.buffers[1][wi] = (channel1[i2] + 1) * 127;
                  }
                  break;
              }
              c.capturePlayhead += srcBuf.length;
              c.capturePlayhead %= c.bufferFrameCapacity;
              c.capturedFrameCount += srcBuf.length;
              c.capturedFrameCount = Math.min(c.capturedFrameCount, c.bufferFrameCapacity);
            };
          };
          if ((_a = navigator.mediaDevices) == null ? void 0 : _a.getUserMedia) {
            navigator.mediaDevices.getUserMedia({
              audio: true
            }).then(onSuccess).catch(onError);
          } else {
            navigator.getUserMedia({
              audio: true
            }, onSuccess, onError);
          }
          var id = AL.newId();
          AL.captures[id] = newCapture;
          return id;
        }
        _alcCaptureOpenDevice.sig = "ppiii";
        function _alcCaptureSamples(deviceId, pFrames, requestedFrameCount) {
          deviceId >>>= 0;
          pFrames >>>= 0;
          var c = AL.requireValidCaptureDevice(deviceId, "alcCaptureSamples");
          if (!c)
            return;
          var dstfreq = c.requestedSampleRate;
          var srcfreq = c.audioCtx.sampleRate;
          var fratio = srcfreq / dstfreq;
          if (requestedFrameCount < 0 || requestedFrameCount > c.capturedFrameCount / fratio) {
            AL.alcErr = 40964;
            return;
          }
          function setF32Sample(i3, sample) {
            HEAPF32[pFrames + 4 * i3 >>> 2 >>> 0] = sample;
          }
          function setI16Sample(i3, sample) {
            HEAP16[pFrames + 2 * i3 >>> 1 >>> 0] = sample;
          }
          function setU8Sample(i3, sample) {
            HEAP8[pFrames + i3 >>> 0 >>> 0] = sample;
          }
          var setSample;
          switch (c.requestedSampleType) {
            case "f32":
              setSample = setF32Sample;
              break;
            case "i16":
              setSample = setI16Sample;
              break;
            case "u8":
              setSample = setU8Sample;
              break;
            default:
              return;
          }
          if (Math.floor(fratio) == fratio) {
            for (var i2 = 0, frame_i = 0; frame_i < requestedFrameCount; ++frame_i) {
              for (var chan = 0; chan < c.buffers.length; ++chan, ++i2) {
                setSample(i2, c.buffers[chan][c.captureReadhead]);
              }
              c.captureReadhead = (fratio + c.captureReadhead) % c.bufferFrameCapacity;
            }
          } else {
            for (var i2 = 0, frame_i = 0; frame_i < requestedFrameCount; ++frame_i) {
              var lefti = Math.floor(c.captureReadhead);
              var righti = Math.ceil(c.captureReadhead);
              var d = c.captureReadhead - lefti;
              for (var chan = 0; chan < c.buffers.length; ++chan, ++i2) {
                var lefts = c.buffers[chan][lefti];
                var rights = c.buffers[chan][righti];
                setSample(i2, (1 - d) * lefts + d * rights);
              }
              c.captureReadhead = (c.captureReadhead + fratio) % c.bufferFrameCapacity;
            }
          }
          c.capturedFrameCount = 0;
        }
        _alcCaptureSamples.sig = "vppi";
        function _alcCaptureStart(deviceId) {
          deviceId >>>= 0;
          var c = AL.requireValidCaptureDevice(deviceId, "alcCaptureStart");
          if (!c)
            return;
          if (c.isCapturing) {
            return;
          }
          c.isCapturing = true;
          c.capturedFrameCount = 0;
          c.capturePlayhead = 0;
        }
        _alcCaptureStart.sig = "vp";
        function _alcCaptureStop(deviceId) {
          deviceId >>>= 0;
          var c = AL.requireValidCaptureDevice(deviceId, "alcCaptureStop");
          if (!c)
            return;
          c.isCapturing = false;
        }
        _alcCaptureStop.sig = "vp";
        function _alcCloseDevice(deviceId) {
          deviceId >>>= 0;
          if (!(deviceId in AL.deviceRefCounts) || AL.deviceRefCounts[deviceId] > 0) {
            return 0;
          }
          delete AL.deviceRefCounts[deviceId];
          AL.freeIds.push(deviceId);
          return 1;
        }
        _alcCloseDevice.sig = "ip";
        function _alcCreateContext(deviceId, pAttrList) {
          deviceId >>>= 0;
          pAttrList >>>= 0;
          if (!(deviceId in AL.deviceRefCounts)) {
            AL.alcErr = 40961;
            return 0;
          }
          var options = null;
          var attrs = [];
          var hrtf = null;
          pAttrList >>= 2;
          if (pAttrList) {
            var attr = 0;
            var val = 0;
            while (true) {
              attr = HEAP32[pAttrList++ >>> 0];
              attrs.push(attr);
              if (attr === 0) {
                break;
              }
              val = HEAP32[pAttrList++ >>> 0];
              attrs.push(val);
              switch (attr) {
                case 4103:
                  if (!options) {
                    options = {};
                  }
                  options.sampleRate = val;
                  break;
                case 4112:
                case 4113:
                  break;
                case 6546:
                  switch (val) {
                    case 0:
                      hrtf = false;
                      break;
                    case 1:
                      hrtf = true;
                      break;
                    case 2:
                      break;
                    default:
                      AL.alcErr = 40964;
                      return 0;
                  }
                  break;
                case 6550:
                  if (val !== 0) {
                    AL.alcErr = 40964;
                    return 0;
                  }
                  break;
                default:
                  AL.alcErr = 40964;
                  return 0;
              }
            }
          }
          var AudioContext2 = window.AudioContext || window.webkitAudioContext;
          var ac = null;
          try {
            if (options) {
              ac = new AudioContext2(options);
            } else {
              ac = new AudioContext2();
            }
          } catch (e) {
            if (e.name === "NotSupportedError") {
              AL.alcErr = 40964;
            } else {
              AL.alcErr = 40961;
            }
            return 0;
          }
          autoResumeAudioContext(ac);
          if (typeof ac.createGain == "undefined") {
            ac.createGain = ac.createGainNode;
          }
          var gain = ac.createGain();
          gain.connect(ac.destination);
          var ctx = {
            deviceId,
            id: AL.newId(),
            attrs,
            audioCtx: ac,
            listener: {
              position: [0, 0, 0],
              velocity: [0, 0, 0],
              direction: [0, 0, 0],
              up: [0, 0, 0]
            },
            sources: [],
            interval: setInterval(() => AL.scheduleContextAudio(ctx), AL.QUEUE_INTERVAL),
            gain,
            distanceModel: 53250,
            speedOfSound: 343.3,
            dopplerFactor: 1,
            sourceDistanceModel: false,
            hrtf: hrtf || false,
            _err: 0,
            get err() {
              return this._err;
            },
            set err(val2) {
              if (this._err === 0 || val2 === 0) {
                this._err = val2;
              }
            }
          };
          AL.deviceRefCounts[deviceId]++;
          AL.contexts[ctx.id] = ctx;
          if (hrtf !== null) {
            for (var ctxId in AL.contexts) {
              var c = AL.contexts[ctxId];
              if (c.deviceId === deviceId) {
                c.hrtf = hrtf;
                AL.updateContextGlobal(c);
              }
            }
          }
          return ctx.id;
        }
        _alcCreateContext.sig = "ppp";
        function _alcDestroyContext(contextId) {
          contextId >>>= 0;
          var ctx = AL.contexts[contextId];
          if (AL.currentCtx === ctx) {
            AL.alcErr = 40962;
            return;
          }
          if (AL.contexts[contextId].interval) {
            clearInterval(AL.contexts[contextId].interval);
          }
          AL.deviceRefCounts[ctx.deviceId]--;
          delete AL.contexts[contextId];
          AL.freeIds.push(contextId);
        }
        _alcDestroyContext.sig = "vp";
        function _alcGetContextsDevice(contextId) {
          contextId >>>= 0;
          if (contextId in AL.contexts) {
            return AL.contexts[contextId].deviceId;
          }
          return 0;
        }
        _alcGetContextsDevice.sig = "pp";
        function _alcGetCurrentContext() {
          if (AL.currentCtx !== null) {
            return AL.currentCtx.id;
          }
          return 0;
        }
        _alcGetCurrentContext.sig = "p";
        function _alcGetEnumValue(deviceId, pEnumName) {
          deviceId >>>= 0;
          pEnumName >>>= 0;
          if (deviceId !== 0 && !(deviceId in AL.deviceRefCounts)) {
            return 0;
          } else if (!pEnumName) {
            AL.alcErr = 40964;
            return 0;
          }
          var name2 = UTF8ToString(pEnumName);
          switch (name2) {
            case "ALC_NO_ERROR":
              return 0;
            case "ALC_INVALID_DEVICE":
              return 40961;
            case "ALC_INVALID_CONTEXT":
              return 40962;
            case "ALC_INVALID_ENUM":
              return 40963;
            case "ALC_INVALID_VALUE":
              return 40964;
            case "ALC_OUT_OF_MEMORY":
              return 40965;
            case "ALC_MAJOR_VERSION":
              return 4096;
            case "ALC_MINOR_VERSION":
              return 4097;
            case "ALC_ATTRIBUTES_SIZE":
              return 4098;
            case "ALC_ALL_ATTRIBUTES":
              return 4099;
            case "ALC_DEFAULT_DEVICE_SPECIFIER":
              return 4100;
            case "ALC_DEVICE_SPECIFIER":
              return 4101;
            case "ALC_EXTENSIONS":
              return 4102;
            case "ALC_FREQUENCY":
              return 4103;
            case "ALC_REFRESH":
              return 4104;
            case "ALC_SYNC":
              return 4105;
            case "ALC_MONO_SOURCES":
              return 4112;
            case "ALC_STEREO_SOURCES":
              return 4113;
            case "ALC_CAPTURE_DEVICE_SPECIFIER":
              return 784;
            case "ALC_CAPTURE_DEFAULT_DEVICE_SPECIFIER":
              return 785;
            case "ALC_CAPTURE_SAMPLES":
              return 786;
            case "ALC_HRTF_SOFT":
              return 6546;
            case "ALC_HRTF_ID_SOFT":
              return 6550;
            case "ALC_DONT_CARE_SOFT":
              return 2;
            case "ALC_HRTF_STATUS_SOFT":
              return 6547;
            case "ALC_NUM_HRTF_SPECIFIERS_SOFT":
              return 6548;
            case "ALC_HRTF_SPECIFIER_SOFT":
              return 6549;
            case "ALC_HRTF_DISABLED_SOFT":
              return 0;
            case "ALC_HRTF_ENABLED_SOFT":
              return 1;
            case "ALC_HRTF_DENIED_SOFT":
              return 2;
            case "ALC_HRTF_REQUIRED_SOFT":
              return 3;
            case "ALC_HRTF_HEADPHONES_DETECTED_SOFT":
              return 4;
            case "ALC_HRTF_UNSUPPORTED_FORMAT_SOFT":
              return 5;
            default:
              AL.alcErr = 40964;
              return 0;
          }
        }
        _alcGetEnumValue.sig = "ipp";
        function _alcGetError(deviceId) {
          deviceId >>>= 0;
          var err2 = AL.alcErr;
          AL.alcErr = 0;
          return err2;
        }
        _alcGetError.sig = "ip";
        function _alcGetIntegerv(deviceId, param, size, pValues) {
          deviceId >>>= 0;
          pValues >>>= 0;
          if (size === 0 || !pValues) {
            return;
          }
          switch (param) {
            case 4096:
              HEAP32[pValues >>> 2 >>> 0] = 1;
              break;
            case 4097:
              HEAP32[pValues >>> 2 >>> 0] = 1;
              break;
            case 4098:
              if (!(deviceId in AL.deviceRefCounts)) {
                AL.alcErr = 40961;
                return;
              }
              if (!AL.currentCtx) {
                AL.alcErr = 40962;
                return;
              }
              HEAP32[pValues >>> 2 >>> 0] = AL.currentCtx.attrs.length;
              break;
            case 4099:
              if (!(deviceId in AL.deviceRefCounts)) {
                AL.alcErr = 40961;
                return;
              }
              if (!AL.currentCtx) {
                AL.alcErr = 40962;
                return;
              }
              for (var i2 = 0; i2 < AL.currentCtx.attrs.length; i2++) {
                HEAP32[pValues + i2 * 4 >>> 2 >>> 0] = AL.currentCtx.attrs[i2];
              }
              break;
            case 4103:
              if (!(deviceId in AL.deviceRefCounts)) {
                AL.alcErr = 40961;
                return;
              }
              if (!AL.currentCtx) {
                AL.alcErr = 40962;
                return;
              }
              HEAP32[pValues >>> 2 >>> 0] = AL.currentCtx.audioCtx.sampleRate;
              break;
            case 4112:
            case 4113:
              if (!(deviceId in AL.deviceRefCounts)) {
                AL.alcErr = 40961;
                return;
              }
              if (!AL.currentCtx) {
                AL.alcErr = 40962;
                return;
              }
              HEAP32[pValues >>> 2 >>> 0] = 2147483647;
              break;
            case 6546:
            case 6547:
              if (!(deviceId in AL.deviceRefCounts)) {
                AL.alcErr = 40961;
                return;
              }
              var hrtfStatus = 0;
              for (var ctxId in AL.contexts) {
                var ctx = AL.contexts[ctxId];
                if (ctx.deviceId === deviceId) {
                  hrtfStatus = ctx.hrtf ? 1 : 0;
                }
              }
              HEAP32[pValues >>> 2 >>> 0] = hrtfStatus;
              break;
            case 6548:
              if (!(deviceId in AL.deviceRefCounts)) {
                AL.alcErr = 40961;
                return;
              }
              HEAP32[pValues >>> 2 >>> 0] = 1;
              break;
            case 131075:
              if (!(deviceId in AL.deviceRefCounts)) {
                AL.alcErr = 40961;
                return;
              }
              if (!AL.currentCtx) {
                AL.alcErr = 40962;
                return;
              }
              HEAP32[pValues >>> 2 >>> 0] = 1;
            case 786:
              var c = AL.requireValidCaptureDevice(deviceId, "alcGetIntegerv");
              if (!c) {
                return;
              }
              var n = c.capturedFrameCount;
              var dstfreq = c.requestedSampleRate;
              var srcfreq = c.audioCtx.sampleRate;
              var nsamples = Math.floor(n * (dstfreq / srcfreq));
              HEAP32[pValues >>> 2 >>> 0] = nsamples;
              break;
            default:
              AL.alcErr = 40963;
              return;
          }
        }
        _alcGetIntegerv.sig = "vpiip";
        function _alcGetString(deviceId, param) {
          deviceId >>>= 0;
          if (AL.alcStringCache[param]) {
            return AL.alcStringCache[param];
          }
          var ret;
          switch (param) {
            case 0:
              ret = "No Error";
              break;
            case 40961:
              ret = "Invalid Device";
              break;
            case 40962:
              ret = "Invalid Context";
              break;
            case 40963:
              ret = "Invalid Enum";
              break;
            case 40964:
              ret = "Invalid Value";
              break;
            case 40965:
              ret = "Out of Memory";
              break;
            case 4100:
              if (typeof AudioContext != "undefined" || typeof webkitAudioContext != "undefined") {
                ret = AL.DEVICE_NAME;
              } else {
                return 0;
              }
              break;
            case 4101:
              if (typeof AudioContext != "undefined" || typeof webkitAudioContext != "undefined") {
                ret = AL.DEVICE_NAME.concat("\0");
              } else {
                ret = "\0";
              }
              break;
            case 785:
              ret = AL.CAPTURE_DEVICE_NAME;
              break;
            case 784:
              if (deviceId === 0)
                ret = AL.CAPTURE_DEVICE_NAME.concat("\0");
              else {
                var c = AL.requireValidCaptureDevice(deviceId, "alcGetString");
                if (!c) {
                  return 0;
                }
                ret = c.deviceName;
              }
              break;
            case 4102:
              if (!deviceId) {
                AL.alcErr = 40961;
                return 0;
              }
              ret = "";
              for (var ext in AL.ALC_EXTENSIONS) {
                ret = ret.concat(ext);
                ret = ret.concat(" ");
              }
              ret = ret.trim();
              break;
            default:
              AL.alcErr = 40963;
              return 0;
          }
          ret = stringToNewUTF8(ret);
          AL.alcStringCache[param] = ret;
          return ret;
        }
        _alcGetString.sig = "ppi";
        function _alcIsExtensionPresent(deviceId, pExtName) {
          deviceId >>>= 0;
          pExtName >>>= 0;
          var name2 = UTF8ToString(pExtName);
          return AL.ALC_EXTENSIONS[name2] ? 1 : 0;
        }
        _alcIsExtensionPresent.sig = "ipp";
        function _alcMakeContextCurrent(contextId) {
          contextId >>>= 0;
          if (contextId === 0) {
            AL.currentCtx = null;
          } else {
            AL.currentCtx = AL.contexts[contextId];
          }
          return 1;
        }
        _alcMakeContextCurrent.sig = "ip";
        function _alcOpenDevice(pDeviceName) {
          pDeviceName >>>= 0;
          if (pDeviceName) {
            var name2 = UTF8ToString(pDeviceName);
            if (name2 !== AL.DEVICE_NAME) {
              return 0;
            }
          }
          if (typeof AudioContext != "undefined" || typeof webkitAudioContext != "undefined") {
            var deviceId = AL.newId();
            AL.deviceRefCounts[deviceId] = 0;
            return deviceId;
          }
          return 0;
        }
        _alcOpenDevice.sig = "pp";
        function _alcProcessContext(contextId) {
          contextId >>>= 0;
        }
        _alcProcessContext.sig = "vp";
        function _alcSuspendContext(contextId) {
          contextId >>>= 0;
        }
        _alcSuspendContext.sig = "vp";
        function _duckdb_web_fs_directory_create(path2, pathLen) {
          path2 >>>= 0;
          return globalThis.DUCKDB_RUNTIME.createDirectory(Module, path2, pathLen);
        }
        _duckdb_web_fs_directory_create.sig = "vpi";
        function _duckdb_web_fs_directory_exists(path2, pathLen) {
          path2 >>>= 0;
          return globalThis.DUCKDB_RUNTIME.checkDirectory(Module, path2, pathLen);
        }
        _duckdb_web_fs_directory_exists.sig = "ipi";
        function _duckdb_web_fs_directory_list_files(path2, pathLen) {
          path2 >>>= 0;
          return globalThis.DUCKDB_RUNTIME.listDirectoryEntries(Module, path2, pathLen);
        }
        _duckdb_web_fs_directory_list_files.sig = "ipi";
        function _duckdb_web_fs_directory_remove(path2, pathLen) {
          path2 >>>= 0;
          return globalThis.DUCKDB_RUNTIME.removeDirectory(Module, path2, pathLen);
        }
        _duckdb_web_fs_directory_remove.sig = "vpi";
        function _duckdb_web_fs_file_close(fileId) {
          return globalThis.DUCKDB_RUNTIME.closeFile(Module, fileId);
        }
        _duckdb_web_fs_file_close.sig = "vi";
        function _duckdb_web_fs_file_exists(path2, pathLen) {
          path2 >>>= 0;
          return globalThis.DUCKDB_RUNTIME.checkFile(Module, path2, pathLen);
        }
        _duckdb_web_fs_file_exists.sig = "ipi";
        function _duckdb_web_fs_file_get_last_modified_time(fileId) {
          return globalThis.DUCKDB_RUNTIME.getLastFileModificationTime(Module, fileId);
        }
        _duckdb_web_fs_file_get_last_modified_time.sig = "ii";
        function _duckdb_web_fs_file_move(from, fromLen, to, toLen) {
          from >>>= 0;
          to >>>= 0;
          return globalThis.DUCKDB_RUNTIME.moveFile(Module, from, fromLen, to, toLen);
        }
        _duckdb_web_fs_file_move.sig = "vpipi";
        function _duckdb_web_fs_file_open(fileId, flags2) {
          return globalThis.DUCKDB_RUNTIME.openFile(Module, fileId, flags2);
        }
        _duckdb_web_fs_file_open.sig = "pii";
        function _duckdb_web_fs_file_read(fileId, buf, size, location) {
          buf >>>= 0;
          return globalThis.DUCKDB_RUNTIME.readFile(Module, fileId, buf, size, location);
        }
        _duckdb_web_fs_file_read.sig = "iipid";
        function _duckdb_web_fs_file_truncate(fileId, newSize) {
          return globalThis.DUCKDB_RUNTIME.truncateFile(Module, fileId, newSize);
        }
        _duckdb_web_fs_file_truncate.sig = "vid";
        function _duckdb_web_fs_file_write(fileId, buf, size, location) {
          buf >>>= 0;
          return globalThis.DUCKDB_RUNTIME.writeFile(Module, fileId, buf, size, location);
        }
        _duckdb_web_fs_file_write.sig = "iipid";
        function _duckdb_web_fs_get_default_data_protocol(Module2) {
          return globalThis.DUCKDB_RUNTIME.getDefaultDataProtocol(Module2);
        }
        _duckdb_web_fs_get_default_data_protocol.sig = "i";
        function _duckdb_web_fs_glob(path2, pathLen) {
          path2 >>>= 0;
          return globalThis.DUCKDB_RUNTIME.glob(Module, path2, pathLen);
        }
        _duckdb_web_fs_glob.sig = "vpi";
        function _duckdb_web_test_platform_feature(feature) {
          return globalThis.DUCKDB_RUNTIME.testPlatformFeature(Module, feature);
        }
        _duckdb_web_test_platform_feature.sig = "ii";
        function _duckdb_web_udf_scalar_call(funcId, descPtr, descSize, ptrsPtr, ptrsSize, response) {
          funcId >>>= 0;
          descSize >>>= 0;
          ptrsSize >>>= 0;
          return globalThis.DUCKDB_RUNTIME.callScalarUDF(Module, funcId, descPtr, descSize, ptrsPtr, ptrsSize, response);
        }
        _duckdb_web_udf_scalar_call.sig = "vpipipi";
        var _emscripten_alcDevicePauseSOFT = (deviceId) => {
          if (!(deviceId in AL.deviceRefCounts)) {
            AL.alcErr = 40961;
            return;
          }
          if (AL.paused) {
            return;
          }
          AL.paused = true;
          for (var ctxId in AL.contexts) {
            var ctx = AL.contexts[ctxId];
            if (ctx.deviceId !== deviceId) {
              continue;
            }
            ctx.audioCtx.suspend();
            clearInterval(ctx.interval);
            ctx.interval = null;
          }
        };
        _emscripten_alcDevicePauseSOFT.sig = "vi";
        var _emscripten_alcDeviceResumeSOFT = (deviceId) => {
          if (!(deviceId in AL.deviceRefCounts)) {
            AL.alcErr = 40961;
            return;
          }
          if (!AL.paused) {
            return;
          }
          AL.paused = false;
          for (var ctxId in AL.contexts) {
            var ctx = AL.contexts[ctxId];
            if (ctx.deviceId !== deviceId) {
              continue;
            }
            ctx.interval = setInterval(() => AL.scheduleContextAudio(ctx), AL.QUEUE_INTERVAL);
            ctx.audioCtx.resume();
          }
        };
        _emscripten_alcDeviceResumeSOFT.sig = "vi";
        var _emscripten_alcGetStringiSOFT = (deviceId, param, index) => {
          if (!(deviceId in AL.deviceRefCounts)) {
            AL.alcErr = 40961;
            return 0;
          }
          if (AL.alcStringCache[param]) {
            return AL.alcStringCache[param];
          }
          var ret;
          switch (param) {
            case 6549:
              if (index === 0) {
                ret = "Web Audio HRTF";
              } else {
                AL.alcErr = 40964;
                return 0;
              }
              break;
            default:
              if (index !== 0) {
                AL.alcErr = 40963;
                return 0;
              }
              return _alcGetString(deviceId, param);
          }
          ret = stringToNewUTF8(ret);
          AL.alcStringCache[param] = ret;
          return ret;
        };
        _emscripten_alcGetStringiSOFT.sig = "iiii";
        var _emscripten_alcResetDeviceSOFT = (deviceId, pAttrList) => {
          if (!(deviceId in AL.deviceRefCounts)) {
            AL.alcErr = 40961;
            return 0;
          }
          var hrtf = null;
          pAttrList >>= 2;
          if (pAttrList) {
            var attr = 0;
            var val = 0;
            while (true) {
              attr = HEAP32[pAttrList++ >>> 0];
              if (attr === 0) {
                break;
              }
              val = HEAP32[pAttrList++ >>> 0];
              switch (attr) {
                case 6546:
                  if (val === 1) {
                    hrtf = true;
                  } else if (val === 0) {
                    hrtf = false;
                  }
                  break;
              }
            }
          }
          if (hrtf !== null) {
            for (var ctxId in AL.contexts) {
              var ctx = AL.contexts[ctxId];
              if (ctx.deviceId === deviceId) {
                ctx.hrtf = hrtf;
                AL.updateContextGlobal(ctx);
              }
            }
          }
          return 1;
        };
        _emscripten_alcResetDeviceSOFT.sig = "iii";
        var readEmAsmArgsArray = [];
        var readEmAsmArgs = (sigPtr, buf) => {
          readEmAsmArgsArray.length = 0;
          var ch;
          while (ch = HEAPU8[sigPtr++ >>> 0]) {
            var wide = ch != 105;
            wide &= ch != 112;
            buf += wide && buf % 8 ? 4 : 0;
            readEmAsmArgsArray.push(ch == 112 ? HEAPU32[buf >>> 2 >>> 0] : ch == 105 ? HEAP32[buf >>> 2 >>> 0] : HEAPF64[buf >>> 3 >>> 0]);
            buf += wide ? 8 : 4;
          }
          return readEmAsmArgsArray;
        };
        var runEmAsmFunction = (code, sigPtr, argbuf) => {
          var args2 = readEmAsmArgs(sigPtr, argbuf);
          return ASM_CONSTS[code].apply(null, args2);
        };
        function _emscripten_asm_const_int(code, sigPtr, argbuf) {
          code >>>= 0;
          sigPtr >>>= 0;
          argbuf >>>= 0;
          return runEmAsmFunction(code, sigPtr, argbuf);
        }
        _emscripten_asm_const_int.sig = "ippp";
        function _emscripten_asm_const_ptr(code, sigPtr, argbuf) {
          code >>>= 0;
          sigPtr >>>= 0;
          argbuf >>>= 0;
          return runEmAsmFunction(code, sigPtr, argbuf);
        }
        _emscripten_asm_const_ptr.sig = "pppp";
        function _emscripten_console_error(str) {
          str >>>= 0;
          console.error(UTF8ToString(str));
        }
        _emscripten_console_error.sig = "vp";
        function _emscripten_console_log(str) {
          str >>>= 0;
          console.log(UTF8ToString(str));
        }
        _emscripten_console_log.sig = "vp";
        function _emscripten_console_warn(str) {
          str >>>= 0;
          console.warn(UTF8ToString(str));
        }
        _emscripten_console_warn.sig = "vp";
        var _emscripten_date_now = () => Date.now();
        _emscripten_date_now.sig = "d";
        function _emscripten_err(str) {
          str >>>= 0;
          return err(UTF8ToString(str));
        }
        _emscripten_err.sig = "vp";
        var getHeapMax = () => 4294901760;
        function _emscripten_get_heap_max() {
          return getHeapMax();
        }
        _emscripten_get_heap_max.sig = "p";
        var _emscripten_get_now_res = () => {
          if (ENVIRONMENT_IS_NODE) {
            return 1;
          }
          return 1e3;
        };
        _emscripten_get_now_res.sig = "d";
        var webgl_enable_ANGLE_instanced_arrays = (ctx) => {
          var ext = ctx.getExtension("ANGLE_instanced_arrays");
          if (ext) {
            ctx["vertexAttribDivisor"] = (index, divisor) => ext["vertexAttribDivisorANGLE"](index, divisor);
            ctx["drawArraysInstanced"] = (mode, first, count, primcount) => ext["drawArraysInstancedANGLE"](mode, first, count, primcount);
            ctx["drawElementsInstanced"] = (mode, count, type, indices, primcount) => ext["drawElementsInstancedANGLE"](mode, count, type, indices, primcount);
            return 1;
          }
        };
        var webgl_enable_OES_vertex_array_object = (ctx) => {
          var ext = ctx.getExtension("OES_vertex_array_object");
          if (ext) {
            ctx["createVertexArray"] = () => ext["createVertexArrayOES"]();
            ctx["deleteVertexArray"] = (vao) => ext["deleteVertexArrayOES"](vao);
            ctx["bindVertexArray"] = (vao) => ext["bindVertexArrayOES"](vao);
            ctx["isVertexArray"] = (vao) => ext["isVertexArrayOES"](vao);
            return 1;
          }
        };
        var webgl_enable_WEBGL_draw_buffers = (ctx) => {
          var ext = ctx.getExtension("WEBGL_draw_buffers");
          if (ext) {
            ctx["drawBuffers"] = (n, bufs) => ext["drawBuffersWEBGL"](n, bufs);
            return 1;
          }
        };
        var webgl_enable_WEBGL_multi_draw = (ctx) => !!(ctx.multiDrawWebgl = ctx.getExtension("WEBGL_multi_draw"));
        var getEmscriptenSupportedExtensions = function(ctx) {
          var supportedExtensions = ["ANGLE_instanced_arrays", "EXT_blend_minmax", "EXT_disjoint_timer_query", "EXT_frag_depth", "EXT_shader_texture_lod", "EXT_sRGB", "OES_element_index_uint", "OES_fbo_render_mipmap", "OES_standard_derivatives", "OES_texture_float", "OES_texture_half_float", "OES_texture_half_float_linear", "OES_vertex_array_object", "WEBGL_color_buffer_float", "WEBGL_depth_texture", "WEBGL_draw_buffers", "EXT_color_buffer_half_float", "EXT_float_blend", "EXT_texture_compression_bptc", "EXT_texture_compression_rgtc", "EXT_texture_filter_anisotropic", "KHR_parallel_shader_compile", "OES_texture_float_linear", "WEBGL_compressed_texture_s3tc", "WEBGL_compressed_texture_s3tc_srgb", "WEBGL_debug_renderer_info", "WEBGL_debug_shaders", "WEBGL_lose_context", "WEBGL_multi_draw"];
          return (ctx.getSupportedExtensions() || []).filter((ext) => supportedExtensions.includes(ext));
        };
        var GL = {
          counter: 1,
          buffers: [],
          programs: [],
          framebuffers: [],
          renderbuffers: [],
          textures: [],
          shaders: [],
          vaos: [],
          contexts: [],
          offscreenCanvases: {},
          queries: [],
          stringCache: {},
          unpackAlignment: 4,
          recordError: function recordError(errorCode) {
            if (!GL.lastError) {
              GL.lastError = errorCode;
            }
          },
          getNewId: (table) => {
            var ret = GL.counter++;
            for (var i2 = table.length; i2 < ret; i2++) {
              table[i2] = null;
            }
            return ret;
          },
          getSource: (shader, count, string, length) => {
            var source = "";
            for (var i2 = 0; i2 < count; ++i2) {
              var len2 = length ? HEAP32[length + i2 * 4 >>> 2 >>> 0] : -1;
              source += UTF8ToString(HEAP32[string + i2 * 4 >>> 2 >>> 0], len2 < 0 ? void 0 : len2);
            }
            return source;
          },
          createContext: (canvas, webGLContextAttributes) => {
            if (!canvas.getContextSafariWebGL2Fixed) {
              let fixedGetContext2 = function(ver, attrs) {
                var gl = canvas.getContextSafariWebGL2Fixed(ver, attrs);
                return ver == "webgl" == gl instanceof WebGLRenderingContext ? gl : null;
              };
              var fixedGetContext = fixedGetContext2;
              canvas.getContextSafariWebGL2Fixed = canvas.getContext;
              canvas.getContext = fixedGetContext2;
            }
            var ctx = canvas.getContext("webgl", webGLContextAttributes);
            if (!ctx)
              return 0;
            var handle2 = GL.registerContext(ctx, webGLContextAttributes);
            return handle2;
          },
          registerContext: (ctx, webGLContextAttributes) => {
            var handle2 = GL.getNewId(GL.contexts);
            var context = {
              handle: handle2,
              attributes: webGLContextAttributes,
              version: webGLContextAttributes.majorVersion,
              GLctx: ctx
            };
            if (ctx.canvas)
              ctx.canvas.GLctxObject = context;
            GL.contexts[handle2] = context;
            if (typeof webGLContextAttributes.enableExtensionsByDefault == "undefined" || webGLContextAttributes.enableExtensionsByDefault) {
              GL.initExtensions(context);
            }
            return handle2;
          },
          makeContextCurrent: (contextHandle) => {
            var _a;
            GL.currentContext = GL.contexts[contextHandle];
            Module.ctx = GLctx = (_a = GL.currentContext) == null ? void 0 : _a.GLctx;
            return !(contextHandle && !GLctx);
          },
          getContext: (contextHandle) => GL.contexts[contextHandle],
          deleteContext: (contextHandle) => {
            if (GL.currentContext === GL.contexts[contextHandle]) {
              GL.currentContext = null;
            }
            if (typeof JSEvents == "object") {
              JSEvents.removeAllHandlersOnTarget(GL.contexts[contextHandle].GLctx.canvas);
            }
            if (GL.contexts[contextHandle] && GL.contexts[contextHandle].GLctx.canvas) {
              GL.contexts[contextHandle].GLctx.canvas.GLctxObject = void 0;
            }
            GL.contexts[contextHandle] = null;
          },
          initExtensions: (context) => {
            context || (context = GL.currentContext);
            if (context.initExtensionsDone)
              return;
            context.initExtensionsDone = true;
            var GLctx2 = context.GLctx;
            webgl_enable_ANGLE_instanced_arrays(GLctx2);
            webgl_enable_OES_vertex_array_object(GLctx2);
            webgl_enable_WEBGL_draw_buffers(GLctx2);
            {
              GLctx2.disjointTimerQueryExt = GLctx2.getExtension("EXT_disjoint_timer_query");
            }
            webgl_enable_WEBGL_multi_draw(GLctx2);
            getEmscriptenSupportedExtensions(GLctx2).forEach((ext) => {
              if (!ext.includes("lose_context") && !ext.includes("debug")) {
                GLctx2.getExtension(ext);
              }
            });
          }
        };
        function _glActiveTexture(x0) {
          GLctx.activeTexture(x0);
        }
        _glActiveTexture.sig = "vi";
        var _emscripten_glActiveTexture = _glActiveTexture;
        var _glAttachShader = (program, shader) => {
          GLctx.attachShader(GL.programs[program], GL.shaders[shader]);
        };
        _glAttachShader.sig = "vii";
        var _emscripten_glAttachShader = _glAttachShader;
        var _glBeginQueryEXT = (target, id) => {
          GLctx.disjointTimerQueryExt["beginQueryEXT"](target, GL.queries[id]);
        };
        _glBeginQueryEXT.sig = "vii";
        var _emscripten_glBeginQueryEXT = _glBeginQueryEXT;
        function _glBindAttribLocation(program, index, name2) {
          name2 >>>= 0;
          GLctx.bindAttribLocation(GL.programs[program], index, UTF8ToString(name2));
        }
        _glBindAttribLocation.sig = "viip";
        var _emscripten_glBindAttribLocation = _glBindAttribLocation;
        var _glBindBuffer = (target, buffer) => {
          GLctx.bindBuffer(target, GL.buffers[buffer]);
        };
        _glBindBuffer.sig = "vii";
        var _emscripten_glBindBuffer = _glBindBuffer;
        var _glBindFramebuffer = (target, framebuffer) => {
          GLctx.bindFramebuffer(target, GL.framebuffers[framebuffer]);
        };
        _glBindFramebuffer.sig = "vii";
        var _emscripten_glBindFramebuffer = _glBindFramebuffer;
        var _glBindRenderbuffer = (target, renderbuffer) => {
          GLctx.bindRenderbuffer(target, GL.renderbuffers[renderbuffer]);
        };
        _glBindRenderbuffer.sig = "vii";
        var _emscripten_glBindRenderbuffer = _glBindRenderbuffer;
        var _glBindTexture = (target, texture) => {
          GLctx.bindTexture(target, GL.textures[texture]);
        };
        _glBindTexture.sig = "vii";
        var _emscripten_glBindTexture = _glBindTexture;
        var _glBindVertexArray = (vao) => {
          GLctx.bindVertexArray(GL.vaos[vao]);
        };
        _glBindVertexArray.sig = "vi";
        var _glBindVertexArrayOES = _glBindVertexArray;
        _glBindVertexArrayOES.sig = "vi";
        var _emscripten_glBindVertexArrayOES = _glBindVertexArrayOES;
        function _glBlendColor(x0, x1, x2, x3) {
          GLctx.blendColor(x0, x1, x2, x3);
        }
        _glBlendColor.sig = "vffff";
        var _emscripten_glBlendColor = _glBlendColor;
        function _glBlendEquation(x0) {
          GLctx.blendEquation(x0);
        }
        _glBlendEquation.sig = "vi";
        var _emscripten_glBlendEquation = _glBlendEquation;
        function _glBlendEquationSeparate(x0, x1) {
          GLctx.blendEquationSeparate(x0, x1);
        }
        _glBlendEquationSeparate.sig = "vii";
        var _emscripten_glBlendEquationSeparate = _glBlendEquationSeparate;
        function _glBlendFunc(x0, x1) {
          GLctx.blendFunc(x0, x1);
        }
        _glBlendFunc.sig = "vii";
        var _emscripten_glBlendFunc = _glBlendFunc;
        function _glBlendFuncSeparate(x0, x1, x2, x3) {
          GLctx.blendFuncSeparate(x0, x1, x2, x3);
        }
        _glBlendFuncSeparate.sig = "viiii";
        var _emscripten_glBlendFuncSeparate = _glBlendFuncSeparate;
        function _glBufferData(target, size, data2, usage) {
          size >>>= 0;
          data2 >>>= 0;
          GLctx.bufferData(target, data2 ? HEAPU8.subarray(data2 >>> 0, data2 + size >>> 0) : size, usage);
        }
        _glBufferData.sig = "vippi";
        var _emscripten_glBufferData = _glBufferData;
        function _glBufferSubData(target, offset, size, data2) {
          offset >>>= 0;
          size >>>= 0;
          data2 >>>= 0;
          GLctx.bufferSubData(target, offset, HEAPU8.subarray(data2 >>> 0, data2 + size >>> 0));
        }
        _glBufferSubData.sig = "vippp";
        var _emscripten_glBufferSubData = _glBufferSubData;
        function _glCheckFramebufferStatus(x0) {
          return GLctx.checkFramebufferStatus(x0);
        }
        _glCheckFramebufferStatus.sig = "ii";
        var _emscripten_glCheckFramebufferStatus = _glCheckFramebufferStatus;
        function _glClear(x0) {
          GLctx.clear(x0);
        }
        _glClear.sig = "vi";
        var _emscripten_glClear = _glClear;
        function _glClearColor(x0, x1, x2, x3) {
          GLctx.clearColor(x0, x1, x2, x3);
        }
        _glClearColor.sig = "vffff";
        var _emscripten_glClearColor = _glClearColor;
        function _glClearDepthf(x0) {
          GLctx.clearDepth(x0);
        }
        _glClearDepthf.sig = "vf";
        var _emscripten_glClearDepthf = _glClearDepthf;
        function _glClearStencil(x0) {
          GLctx.clearStencil(x0);
        }
        _glClearStencil.sig = "vi";
        var _emscripten_glClearStencil = _glClearStencil;
        var _glColorMask = (red, green, blue, alpha) => {
          GLctx.colorMask(!!red, !!green, !!blue, !!alpha);
        };
        _glColorMask.sig = "viiii";
        var _emscripten_glColorMask = _glColorMask;
        var _glCompileShader = (shader) => {
          GLctx.compileShader(GL.shaders[shader]);
        };
        _glCompileShader.sig = "vi";
        var _emscripten_glCompileShader = _glCompileShader;
        function _glCompressedTexImage2D(target, level, internalFormat, width, height, border, imageSize, data2) {
          data2 >>>= 0;
          GLctx.compressedTexImage2D(target, level, internalFormat, width, height, border, data2 ? HEAPU8.subarray(data2 >>> 0, data2 + imageSize >>> 0) : null);
        }
        _glCompressedTexImage2D.sig = "viiiiiiip";
        var _emscripten_glCompressedTexImage2D = _glCompressedTexImage2D;
        function _glCompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data2) {
          data2 >>>= 0;
          GLctx.compressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, data2 ? HEAPU8.subarray(data2 >>> 0, data2 + imageSize >>> 0) : null);
        }
        _glCompressedTexSubImage2D.sig = "viiiiiiiip";
        var _emscripten_glCompressedTexSubImage2D = _glCompressedTexSubImage2D;
        function _glCopyTexImage2D(x0, x1, x2, x3, x4, x5, x6, x7) {
          GLctx.copyTexImage2D(x0, x1, x2, x3, x4, x5, x6, x7);
        }
        _glCopyTexImage2D.sig = "viiiiiiii";
        var _emscripten_glCopyTexImage2D = _glCopyTexImage2D;
        function _glCopyTexSubImage2D(x0, x1, x2, x3, x4, x5, x6, x7) {
          GLctx.copyTexSubImage2D(x0, x1, x2, x3, x4, x5, x6, x7);
        }
        _glCopyTexSubImage2D.sig = "viiiiiiii";
        var _emscripten_glCopyTexSubImage2D = _glCopyTexSubImage2D;
        var _glCreateProgram = () => {
          var id = GL.getNewId(GL.programs);
          var program = GLctx.createProgram();
          program.name = id;
          program.maxUniformLength = program.maxAttributeLength = program.maxUniformBlockNameLength = 0;
          program.uniformIdCounter = 1;
          GL.programs[id] = program;
          return id;
        };
        _glCreateProgram.sig = "i";
        var _emscripten_glCreateProgram = _glCreateProgram;
        var _glCreateShader = (shaderType) => {
          var id = GL.getNewId(GL.shaders);
          GL.shaders[id] = GLctx.createShader(shaderType);
          return id;
        };
        _glCreateShader.sig = "ii";
        var _emscripten_glCreateShader = _glCreateShader;
        function _glCullFace(x0) {
          GLctx.cullFace(x0);
        }
        _glCullFace.sig = "vi";
        var _emscripten_glCullFace = _glCullFace;
        function _glDeleteBuffers(n, buffers) {
          buffers >>>= 0;
          for (var i2 = 0; i2 < n; i2++) {
            var id = HEAP32[buffers + i2 * 4 >>> 2 >>> 0];
            var buffer = GL.buffers[id];
            if (!buffer)
              continue;
            GLctx.deleteBuffer(buffer);
            buffer.name = 0;
            GL.buffers[id] = null;
          }
        }
        _glDeleteBuffers.sig = "vip";
        var _emscripten_glDeleteBuffers = _glDeleteBuffers;
        function _glDeleteFramebuffers(n, framebuffers) {
          framebuffers >>>= 0;
          for (var i2 = 0; i2 < n; ++i2) {
            var id = HEAP32[framebuffers + i2 * 4 >>> 2 >>> 0];
            var framebuffer = GL.framebuffers[id];
            if (!framebuffer)
              continue;
            GLctx.deleteFramebuffer(framebuffer);
            framebuffer.name = 0;
            GL.framebuffers[id] = null;
          }
        }
        _glDeleteFramebuffers.sig = "vip";
        var _emscripten_glDeleteFramebuffers = _glDeleteFramebuffers;
        var _glDeleteProgram = (id) => {
          if (!id)
            return;
          var program = GL.programs[id];
          if (!program) {
            GL.recordError(1281);
            return;
          }
          GLctx.deleteProgram(program);
          program.name = 0;
          GL.programs[id] = null;
        };
        _glDeleteProgram.sig = "vi";
        var _emscripten_glDeleteProgram = _glDeleteProgram;
        function _glDeleteQueriesEXT(n, ids) {
          ids >>>= 0;
          for (var i2 = 0; i2 < n; i2++) {
            var id = HEAP32[ids + i2 * 4 >>> 2 >>> 0];
            var query = GL.queries[id];
            if (!query)
              continue;
            GLctx.disjointTimerQueryExt["deleteQueryEXT"](query);
            GL.queries[id] = null;
          }
        }
        _glDeleteQueriesEXT.sig = "vip";
        var _emscripten_glDeleteQueriesEXT = _glDeleteQueriesEXT;
        function _glDeleteRenderbuffers(n, renderbuffers) {
          renderbuffers >>>= 0;
          for (var i2 = 0; i2 < n; i2++) {
            var id = HEAP32[renderbuffers + i2 * 4 >>> 2 >>> 0];
            var renderbuffer = GL.renderbuffers[id];
            if (!renderbuffer)
              continue;
            GLctx.deleteRenderbuffer(renderbuffer);
            renderbuffer.name = 0;
            GL.renderbuffers[id] = null;
          }
        }
        _glDeleteRenderbuffers.sig = "vip";
        var _emscripten_glDeleteRenderbuffers = _glDeleteRenderbuffers;
        var _glDeleteShader = (id) => {
          if (!id)
            return;
          var shader = GL.shaders[id];
          if (!shader) {
            GL.recordError(1281);
            return;
          }
          GLctx.deleteShader(shader);
          GL.shaders[id] = null;
        };
        _glDeleteShader.sig = "vi";
        var _emscripten_glDeleteShader = _glDeleteShader;
        function _glDeleteTextures(n, textures) {
          textures >>>= 0;
          for (var i2 = 0; i2 < n; i2++) {
            var id = HEAP32[textures + i2 * 4 >>> 2 >>> 0];
            var texture = GL.textures[id];
            if (!texture)
              continue;
            GLctx.deleteTexture(texture);
            texture.name = 0;
            GL.textures[id] = null;
          }
        }
        _glDeleteTextures.sig = "vip";
        var _emscripten_glDeleteTextures = _glDeleteTextures;
        function _glDeleteVertexArrays(n, vaos) {
          vaos >>>= 0;
          for (var i2 = 0; i2 < n; i2++) {
            var id = HEAP32[vaos + i2 * 4 >>> 2 >>> 0];
            GLctx.deleteVertexArray(GL.vaos[id]);
            GL.vaos[id] = null;
          }
        }
        _glDeleteVertexArrays.sig = "vip";
        var _glDeleteVertexArraysOES = _glDeleteVertexArrays;
        _glDeleteVertexArraysOES.sig = "vip";
        var _emscripten_glDeleteVertexArraysOES = _glDeleteVertexArraysOES;
        function _glDepthFunc(x0) {
          GLctx.depthFunc(x0);
        }
        _glDepthFunc.sig = "vi";
        var _emscripten_glDepthFunc = _glDepthFunc;
        var _glDepthMask = (flag) => {
          GLctx.depthMask(!!flag);
        };
        _glDepthMask.sig = "vi";
        var _emscripten_glDepthMask = _glDepthMask;
        function _glDepthRangef(x0, x1) {
          GLctx.depthRange(x0, x1);
        }
        _glDepthRangef.sig = "vff";
        var _emscripten_glDepthRangef = _glDepthRangef;
        var _glDetachShader = (program, shader) => {
          GLctx.detachShader(GL.programs[program], GL.shaders[shader]);
        };
        _glDetachShader.sig = "vii";
        var _emscripten_glDetachShader = _glDetachShader;
        function _glDisable(x0) {
          GLctx.disable(x0);
        }
        _glDisable.sig = "vi";
        var _emscripten_glDisable = _glDisable;
        var _glDisableVertexAttribArray = (index) => {
          GLctx.disableVertexAttribArray(index);
        };
        _glDisableVertexAttribArray.sig = "vi";
        var _emscripten_glDisableVertexAttribArray = _glDisableVertexAttribArray;
        var _glDrawArrays = (mode, first, count) => {
          GLctx.drawArrays(mode, first, count);
        };
        _glDrawArrays.sig = "viii";
        var _emscripten_glDrawArrays = _glDrawArrays;
        var _glDrawArraysInstanced = (mode, first, count, primcount) => {
          GLctx.drawArraysInstanced(mode, first, count, primcount);
        };
        _glDrawArraysInstanced.sig = "viiii";
        var _glDrawArraysInstancedANGLE = _glDrawArraysInstanced;
        var _emscripten_glDrawArraysInstancedANGLE = _glDrawArraysInstancedANGLE;
        var tempFixedLengthArray = [];
        function _glDrawBuffers(n, bufs) {
          bufs >>>= 0;
          var bufArray = tempFixedLengthArray[n];
          for (var i2 = 0; i2 < n; i2++) {
            bufArray[i2] = HEAP32[bufs + i2 * 4 >>> 2 >>> 0];
          }
          GLctx.drawBuffers(bufArray);
        }
        _glDrawBuffers.sig = "vip";
        var _glDrawBuffersWEBGL = _glDrawBuffers;
        var _emscripten_glDrawBuffersWEBGL = _glDrawBuffersWEBGL;
        function _glDrawElements(mode, count, type, indices) {
          indices >>>= 0;
          GLctx.drawElements(mode, count, type, indices);
        }
        _glDrawElements.sig = "viiip";
        var _emscripten_glDrawElements = _glDrawElements;
        function _glDrawElementsInstanced(mode, count, type, indices, primcount) {
          indices >>>= 0;
          GLctx.drawElementsInstanced(mode, count, type, indices, primcount);
        }
        _glDrawElementsInstanced.sig = "viiipi";
        var _glDrawElementsInstancedANGLE = _glDrawElementsInstanced;
        var _emscripten_glDrawElementsInstancedANGLE = _glDrawElementsInstancedANGLE;
        function _glEnable(x0) {
          GLctx.enable(x0);
        }
        _glEnable.sig = "vi";
        var _emscripten_glEnable = _glEnable;
        var _glEnableVertexAttribArray = (index) => {
          GLctx.enableVertexAttribArray(index);
        };
        _glEnableVertexAttribArray.sig = "vi";
        var _emscripten_glEnableVertexAttribArray = _glEnableVertexAttribArray;
        var _glEndQueryEXT = (target) => {
          GLctx.disjointTimerQueryExt["endQueryEXT"](target);
        };
        _glEndQueryEXT.sig = "vi";
        var _emscripten_glEndQueryEXT = _glEndQueryEXT;
        function _glFinish() {
          GLctx.finish();
        }
        _glFinish.sig = "v";
        var _emscripten_glFinish = _glFinish;
        function _glFlush() {
          GLctx.flush();
        }
        _glFlush.sig = "v";
        var _emscripten_glFlush = _glFlush;
        var _glFramebufferRenderbuffer = (target, attachment, renderbuffertarget, renderbuffer) => {
          GLctx.framebufferRenderbuffer(target, attachment, renderbuffertarget, GL.renderbuffers[renderbuffer]);
        };
        _glFramebufferRenderbuffer.sig = "viiii";
        var _emscripten_glFramebufferRenderbuffer = _glFramebufferRenderbuffer;
        var _glFramebufferTexture2D = (target, attachment, textarget, texture, level) => {
          GLctx.framebufferTexture2D(target, attachment, textarget, GL.textures[texture], level);
        };
        _glFramebufferTexture2D.sig = "viiiii";
        var _emscripten_glFramebufferTexture2D = _glFramebufferTexture2D;
        function _glFrontFace(x0) {
          GLctx.frontFace(x0);
        }
        _glFrontFace.sig = "vi";
        var _emscripten_glFrontFace = _glFrontFace;
        var __glGenObject = (n, buffers, createFunction, objectTable) => {
          for (var i2 = 0; i2 < n; i2++) {
            var buffer = GLctx[createFunction]();
            var id = buffer && GL.getNewId(objectTable);
            if (buffer) {
              buffer.name = id;
              objectTable[id] = buffer;
            } else {
              GL.recordError(1282);
            }
            HEAP32[buffers + i2 * 4 >>> 2 >>> 0] = id;
          }
        };
        function _glGenBuffers(n, buffers) {
          buffers >>>= 0;
          __glGenObject(n, buffers, "createBuffer", GL.buffers);
        }
        _glGenBuffers.sig = "vip";
        var _emscripten_glGenBuffers = _glGenBuffers;
        function _glGenFramebuffers(n, ids) {
          ids >>>= 0;
          __glGenObject(n, ids, "createFramebuffer", GL.framebuffers);
        }
        _glGenFramebuffers.sig = "vip";
        var _emscripten_glGenFramebuffers = _glGenFramebuffers;
        function _glGenQueriesEXT(n, ids) {
          ids >>>= 0;
          for (var i2 = 0; i2 < n; i2++) {
            var query = GLctx.disjointTimerQueryExt["createQueryEXT"]();
            if (!query) {
              GL.recordError(1282);
              while (i2 < n)
                HEAP32[ids + i2++ * 4 >>> 2 >>> 0] = 0;
              return;
            }
            var id = GL.getNewId(GL.queries);
            query.name = id;
            GL.queries[id] = query;
            HEAP32[ids + i2 * 4 >>> 2 >>> 0] = id;
          }
        }
        _glGenQueriesEXT.sig = "vip";
        var _emscripten_glGenQueriesEXT = _glGenQueriesEXT;
        function _glGenRenderbuffers(n, renderbuffers) {
          renderbuffers >>>= 0;
          __glGenObject(n, renderbuffers, "createRenderbuffer", GL.renderbuffers);
        }
        _glGenRenderbuffers.sig = "vip";
        var _emscripten_glGenRenderbuffers = _glGenRenderbuffers;
        function _glGenTextures(n, textures) {
          textures >>>= 0;
          __glGenObject(n, textures, "createTexture", GL.textures);
        }
        _glGenTextures.sig = "vip";
        var _emscripten_glGenTextures = _glGenTextures;
        function _glGenVertexArrays(n, arrays) {
          arrays >>>= 0;
          __glGenObject(n, arrays, "createVertexArray", GL.vaos);
        }
        _glGenVertexArrays.sig = "vip";
        var _glGenVertexArraysOES = _glGenVertexArrays;
        _glGenVertexArraysOES.sig = "vip";
        var _emscripten_glGenVertexArraysOES = _glGenVertexArraysOES;
        function _glGenerateMipmap(x0) {
          GLctx.generateMipmap(x0);
        }
        _glGenerateMipmap.sig = "vi";
        var _emscripten_glGenerateMipmap = _glGenerateMipmap;
        var __glGetActiveAttribOrUniform = (funcName, program, index, bufSize, length, size, type, name2) => {
          program = GL.programs[program];
          var info2 = GLctx[funcName](program, index);
          if (info2) {
            var numBytesWrittenExclNull = name2 && stringToUTF8(info2.name, name2, bufSize);
            if (length)
              HEAP32[length >>> 2 >>> 0] = numBytesWrittenExclNull;
            if (size)
              HEAP32[size >>> 2 >>> 0] = info2.size;
            if (type)
              HEAP32[type >>> 2 >>> 0] = info2.type;
          }
        };
        function _glGetActiveAttrib(program, index, bufSize, length, size, type, name2) {
          length >>>= 0;
          size >>>= 0;
          type >>>= 0;
          name2 >>>= 0;
          __glGetActiveAttribOrUniform("getActiveAttrib", program, index, bufSize, length, size, type, name2);
        }
        _glGetActiveAttrib.sig = "viiipppp";
        var _emscripten_glGetActiveAttrib = _glGetActiveAttrib;
        function _glGetActiveUniform(program, index, bufSize, length, size, type, name2) {
          length >>>= 0;
          size >>>= 0;
          type >>>= 0;
          name2 >>>= 0;
          __glGetActiveAttribOrUniform("getActiveUniform", program, index, bufSize, length, size, type, name2);
        }
        _glGetActiveUniform.sig = "viiipppp";
        var _emscripten_glGetActiveUniform = _glGetActiveUniform;
        function _glGetAttachedShaders(program, maxCount, count, shaders) {
          count >>>= 0;
          shaders >>>= 0;
          var result = GLctx.getAttachedShaders(GL.programs[program]);
          var len2 = result.length;
          if (len2 > maxCount) {
            len2 = maxCount;
          }
          HEAP32[count >>> 2 >>> 0] = len2;
          for (var i2 = 0; i2 < len2; ++i2) {
            var id = GL.shaders.indexOf(result[i2]);
            HEAP32[shaders + i2 * 4 >>> 2 >>> 0] = id;
          }
        }
        _glGetAttachedShaders.sig = "viipp";
        var _emscripten_glGetAttachedShaders = _glGetAttachedShaders;
        function _glGetAttribLocation(program, name2) {
          name2 >>>= 0;
          return GLctx.getAttribLocation(GL.programs[program], UTF8ToString(name2));
        }
        _glGetAttribLocation.sig = "iip";
        var _emscripten_glGetAttribLocation = _glGetAttribLocation;
        var writeI53ToI64 = (ptr2, num) => {
          HEAPU32[ptr2 >>> 2 >>> 0] = num;
          var lower = HEAPU32[ptr2 >>> 2 >>> 0];
          HEAPU32[ptr2 + 4 >>> 2 >>> 0] = (num - lower) / 4294967296;
        };
        var emscriptenWebGLGet = (name_, p, type) => {
          if (!p) {
            GL.recordError(1281);
            return;
          }
          var ret = void 0;
          switch (name_) {
            case 36346:
              ret = 1;
              break;
            case 36344:
              if (type != 0 && type != 1) {
                GL.recordError(1280);
              }
              return;
            case 36345:
              ret = 0;
              break;
            case 34466:
              var formats = GLctx.getParameter(34467);
              ret = formats ? formats.length : 0;
              break;
          }
          if (ret === void 0) {
            var result = GLctx.getParameter(name_);
            switch (typeof result) {
              case "number":
                ret = result;
                break;
              case "boolean":
                ret = result ? 1 : 0;
                break;
              case "string":
                GL.recordError(1280);
                return;
              case "object":
                if (result === null) {
                  switch (name_) {
                    case 34964:
                    case 35725:
                    case 34965:
                    case 36006:
                    case 36007:
                    case 32873:
                    case 34229:
                    case 34068: {
                      ret = 0;
                      break;
                    }
                    default: {
                      GL.recordError(1280);
                      return;
                    }
                  }
                } else if (result instanceof Float32Array || result instanceof Uint32Array || result instanceof Int32Array || result instanceof Array) {
                  for (var i2 = 0; i2 < result.length; ++i2) {
                    switch (type) {
                      case 0:
                        HEAP32[p + i2 * 4 >>> 2 >>> 0] = result[i2];
                        break;
                      case 2:
                        HEAPF32[p + i2 * 4 >>> 2 >>> 0] = result[i2];
                        break;
                      case 4:
                        HEAP8[p + i2 >>> 0 >>> 0] = result[i2] ? 1 : 0;
                        break;
                    }
                  }
                  return;
                } else {
                  try {
                    ret = result.name | 0;
                  } catch (e) {
                    GL.recordError(1280);
                    err(`GL_INVALID_ENUM in glGet${type}v: Unknown object returned from WebGL getParameter(${name_})! (error: ${e})`);
                    return;
                  }
                }
                break;
              default:
                GL.recordError(1280);
                err(`GL_INVALID_ENUM in glGet${type}v: Native code calling glGet${type}v(${name_}) and it returns ${result} of type ${typeof result}!`);
                return;
            }
          }
          switch (type) {
            case 1:
              writeI53ToI64(p, ret);
              break;
            case 0:
              HEAP32[p >>> 2 >>> 0] = ret;
              break;
            case 2:
              HEAPF32[p >>> 2 >>> 0] = ret;
              break;
            case 4:
              HEAP8[p >>> 0 >>> 0] = ret ? 1 : 0;
              break;
          }
        };
        function _glGetBooleanv(name_, p) {
          p >>>= 0;
          return emscriptenWebGLGet(name_, p, 4);
        }
        _glGetBooleanv.sig = "vip";
        var _emscripten_glGetBooleanv = _glGetBooleanv;
        function _glGetBufferParameteriv(target, value, data2) {
          data2 >>>= 0;
          if (!data2) {
            GL.recordError(1281);
            return;
          }
          HEAP32[data2 >>> 2 >>> 0] = GLctx.getBufferParameter(target, value);
        }
        _glGetBufferParameteriv.sig = "viip";
        var _emscripten_glGetBufferParameteriv = _glGetBufferParameteriv;
        var _glGetError = () => {
          var error = GLctx.getError() || GL.lastError;
          GL.lastError = 0;
          return error;
        };
        _glGetError.sig = "i";
        var _emscripten_glGetError = _glGetError;
        function _glGetFloatv(name_, p) {
          p >>>= 0;
          return emscriptenWebGLGet(name_, p, 2);
        }
        _glGetFloatv.sig = "vip";
        var _emscripten_glGetFloatv = _glGetFloatv;
        function _glGetFramebufferAttachmentParameteriv(target, attachment, pname, params) {
          params >>>= 0;
          var result = GLctx.getFramebufferAttachmentParameter(target, attachment, pname);
          if (result instanceof WebGLRenderbuffer || result instanceof WebGLTexture) {
            result = result.name | 0;
          }
          HEAP32[params >>> 2 >>> 0] = result;
        }
        _glGetFramebufferAttachmentParameteriv.sig = "viiip";
        var _emscripten_glGetFramebufferAttachmentParameteriv = _glGetFramebufferAttachmentParameteriv;
        function _glGetIntegerv(name_, p) {
          p >>>= 0;
          return emscriptenWebGLGet(name_, p, 0);
        }
        _glGetIntegerv.sig = "vip";
        var _emscripten_glGetIntegerv = _glGetIntegerv;
        function _glGetProgramInfoLog(program, maxLength, length, infoLog) {
          length >>>= 0;
          infoLog >>>= 0;
          var log = GLctx.getProgramInfoLog(GL.programs[program]);
          if (log === null)
            log = "(unknown error)";
          var numBytesWrittenExclNull = maxLength > 0 && infoLog ? stringToUTF8(log, infoLog, maxLength) : 0;
          if (length)
            HEAP32[length >>> 2 >>> 0] = numBytesWrittenExclNull;
        }
        _glGetProgramInfoLog.sig = "viipp";
        var _emscripten_glGetProgramInfoLog = _glGetProgramInfoLog;
        function _glGetProgramiv(program, pname, p) {
          p >>>= 0;
          if (!p) {
            GL.recordError(1281);
            return;
          }
          if (program >= GL.counter) {
            GL.recordError(1281);
            return;
          }
          program = GL.programs[program];
          if (pname == 35716) {
            var log = GLctx.getProgramInfoLog(program);
            if (log === null)
              log = "(unknown error)";
            HEAP32[p >>> 2 >>> 0] = log.length + 1;
          } else if (pname == 35719) {
            if (!program.maxUniformLength) {
              for (var i2 = 0; i2 < GLctx.getProgramParameter(program, 35718); ++i2) {
                program.maxUniformLength = Math.max(program.maxUniformLength, GLctx.getActiveUniform(program, i2).name.length + 1);
              }
            }
            HEAP32[p >>> 2 >>> 0] = program.maxUniformLength;
          } else if (pname == 35722) {
            if (!program.maxAttributeLength) {
              for (var i2 = 0; i2 < GLctx.getProgramParameter(program, 35721); ++i2) {
                program.maxAttributeLength = Math.max(program.maxAttributeLength, GLctx.getActiveAttrib(program, i2).name.length + 1);
              }
            }
            HEAP32[p >>> 2 >>> 0] = program.maxAttributeLength;
          } else if (pname == 35381) {
            if (!program.maxUniformBlockNameLength) {
              for (var i2 = 0; i2 < GLctx.getProgramParameter(program, 35382); ++i2) {
                program.maxUniformBlockNameLength = Math.max(program.maxUniformBlockNameLength, GLctx.getActiveUniformBlockName(program, i2).length + 1);
              }
            }
            HEAP32[p >>> 2 >>> 0] = program.maxUniformBlockNameLength;
          } else {
            HEAP32[p >>> 2 >>> 0] = GLctx.getProgramParameter(program, pname);
          }
        }
        _glGetProgramiv.sig = "viip";
        var _emscripten_glGetProgramiv = _glGetProgramiv;
        function _glGetQueryObjecti64vEXT(id, pname, params) {
          params >>>= 0;
          if (!params) {
            GL.recordError(1281);
            return;
          }
          var query = GL.queries[id];
          var param;
          {
            param = GLctx.disjointTimerQueryExt["getQueryObjectEXT"](query, pname);
          }
          var ret;
          if (typeof param == "boolean") {
            ret = param ? 1 : 0;
          } else {
            ret = param;
          }
          writeI53ToI64(params, ret);
        }
        _glGetQueryObjecti64vEXT.sig = "viip";
        var _emscripten_glGetQueryObjecti64vEXT = _glGetQueryObjecti64vEXT;
        function _glGetQueryObjectivEXT(id, pname, params) {
          params >>>= 0;
          if (!params) {
            GL.recordError(1281);
            return;
          }
          var query = GL.queries[id];
          var param = GLctx.disjointTimerQueryExt["getQueryObjectEXT"](query, pname);
          var ret;
          if (typeof param == "boolean") {
            ret = param ? 1 : 0;
          } else {
            ret = param;
          }
          HEAP32[params >>> 2 >>> 0] = ret;
        }
        _glGetQueryObjectivEXT.sig = "viip";
        var _emscripten_glGetQueryObjectivEXT = _glGetQueryObjectivEXT;
        var _glGetQueryObjectui64vEXT = _glGetQueryObjecti64vEXT;
        var _emscripten_glGetQueryObjectui64vEXT = _glGetQueryObjectui64vEXT;
        var _glGetQueryObjectuivEXT = _glGetQueryObjectivEXT;
        var _emscripten_glGetQueryObjectuivEXT = _glGetQueryObjectuivEXT;
        function _glGetQueryivEXT(target, pname, params) {
          params >>>= 0;
          if (!params) {
            GL.recordError(1281);
            return;
          }
          HEAP32[params >>> 2 >>> 0] = GLctx.disjointTimerQueryExt["getQueryEXT"](target, pname);
        }
        _glGetQueryivEXT.sig = "viip";
        var _emscripten_glGetQueryivEXT = _glGetQueryivEXT;
        function _glGetRenderbufferParameteriv(target, pname, params) {
          params >>>= 0;
          if (!params) {
            GL.recordError(1281);
            return;
          }
          HEAP32[params >>> 2 >>> 0] = GLctx.getRenderbufferParameter(target, pname);
        }
        _glGetRenderbufferParameteriv.sig = "viip";
        var _emscripten_glGetRenderbufferParameteriv = _glGetRenderbufferParameteriv;
        function _glGetShaderInfoLog(shader, maxLength, length, infoLog) {
          length >>>= 0;
          infoLog >>>= 0;
          var log = GLctx.getShaderInfoLog(GL.shaders[shader]);
          if (log === null)
            log = "(unknown error)";
          var numBytesWrittenExclNull = maxLength > 0 && infoLog ? stringToUTF8(log, infoLog, maxLength) : 0;
          if (length)
            HEAP32[length >>> 2 >>> 0] = numBytesWrittenExclNull;
        }
        _glGetShaderInfoLog.sig = "viipp";
        var _emscripten_glGetShaderInfoLog = _glGetShaderInfoLog;
        function _glGetShaderPrecisionFormat(shaderType, precisionType, range, precision) {
          range >>>= 0;
          precision >>>= 0;
          var result = GLctx.getShaderPrecisionFormat(shaderType, precisionType);
          HEAP32[range >>> 2 >>> 0] = result.rangeMin;
          HEAP32[range + 4 >>> 2 >>> 0] = result.rangeMax;
          HEAP32[precision >>> 2 >>> 0] = result.precision;
        }
        _glGetShaderPrecisionFormat.sig = "viipp";
        var _emscripten_glGetShaderPrecisionFormat = _glGetShaderPrecisionFormat;
        function _glGetShaderSource(shader, bufSize, length, source) {
          length >>>= 0;
          source >>>= 0;
          var result = GLctx.getShaderSource(GL.shaders[shader]);
          if (!result)
            return;
          var numBytesWrittenExclNull = bufSize > 0 && source ? stringToUTF8(result, source, bufSize) : 0;
          if (length)
            HEAP32[length >>> 2 >>> 0] = numBytesWrittenExclNull;
        }
        _glGetShaderSource.sig = "viipp";
        var _emscripten_glGetShaderSource = _glGetShaderSource;
        function _glGetShaderiv(shader, pname, p) {
          p >>>= 0;
          if (!p) {
            GL.recordError(1281);
            return;
          }
          if (pname == 35716) {
            var log = GLctx.getShaderInfoLog(GL.shaders[shader]);
            if (log === null)
              log = "(unknown error)";
            var logLength = log ? log.length + 1 : 0;
            HEAP32[p >>> 2 >>> 0] = logLength;
          } else if (pname == 35720) {
            var source = GLctx.getShaderSource(GL.shaders[shader]);
            var sourceLength = source ? source.length + 1 : 0;
            HEAP32[p >>> 2 >>> 0] = sourceLength;
          } else {
            HEAP32[p >>> 2 >>> 0] = GLctx.getShaderParameter(GL.shaders[shader], pname);
          }
        }
        _glGetShaderiv.sig = "viip";
        var _emscripten_glGetShaderiv = _glGetShaderiv;
        var webglGetExtensions = function $webglGetExtensions() {
          var exts = getEmscriptenSupportedExtensions(GLctx);
          exts = exts.concat(exts.map((e) => "GL_" + e));
          return exts;
        };
        function _glGetString(name_) {
          var ret = GL.stringCache[name_];
          if (!ret) {
            switch (name_) {
              case 7939:
                ret = stringToNewUTF8(webglGetExtensions().join(" "));
                break;
              case 7936:
              case 7937:
              case 37445:
              case 37446:
                var s2 = GLctx.getParameter(name_);
                if (!s2) {
                  GL.recordError(1280);
                }
                ret = s2 ? stringToNewUTF8(s2) : 0;
                break;
              case 7938:
                var glVersion = GLctx.getParameter(7938);
                {
                  glVersion = `OpenGL ES 2.0 (${glVersion})`;
                }
                ret = stringToNewUTF8(glVersion);
                break;
              case 35724:
                var glslVersion = GLctx.getParameter(35724);
                var ver_re = /^WebGL GLSL ES ([0-9]\.[0-9][0-9]?)(?:$| .*)/;
                var ver_num = glslVersion.match(ver_re);
                if (ver_num !== null) {
                  if (ver_num[1].length == 3)
                    ver_num[1] = ver_num[1] + "0";
                  glslVersion = `OpenGL ES GLSL ES ${ver_num[1]} (${glslVersion})`;
                }
                ret = stringToNewUTF8(glslVersion);
                break;
              default:
                GL.recordError(1280);
            }
            GL.stringCache[name_] = ret;
          }
          return ret;
        }
        _glGetString.sig = "pi";
        var _emscripten_glGetString = _glGetString;
        function _glGetTexParameterfv(target, pname, params) {
          params >>>= 0;
          if (!params) {
            GL.recordError(1281);
            return;
          }
          HEAPF32[params >>> 2 >>> 0] = GLctx.getTexParameter(target, pname);
        }
        _glGetTexParameterfv.sig = "viip";
        var _emscripten_glGetTexParameterfv = _glGetTexParameterfv;
        function _glGetTexParameteriv(target, pname, params) {
          params >>>= 0;
          if (!params) {
            GL.recordError(1281);
            return;
          }
          HEAP32[params >>> 2 >>> 0] = GLctx.getTexParameter(target, pname);
        }
        _glGetTexParameteriv.sig = "viip";
        var _emscripten_glGetTexParameteriv = _glGetTexParameteriv;
        var webglGetLeftBracePos = (name2) => name2.slice(-1) == "]" && name2.lastIndexOf("[");
        var webglPrepareUniformLocationsBeforeFirstUse = (program) => {
          var uniformLocsById = program.uniformLocsById, uniformSizeAndIdsByName = program.uniformSizeAndIdsByName, i2, j;
          if (!uniformLocsById) {
            program.uniformLocsById = uniformLocsById = {};
            program.uniformArrayNamesById = {};
            for (i2 = 0; i2 < GLctx.getProgramParameter(program, 35718); ++i2) {
              var u = GLctx.getActiveUniform(program, i2);
              var nm = u.name;
              var sz = u.size;
              var lb = webglGetLeftBracePos(nm);
              var arrayName = lb > 0 ? nm.slice(0, lb) : nm;
              var id = program.uniformIdCounter;
              program.uniformIdCounter += sz;
              uniformSizeAndIdsByName[arrayName] = [sz, id];
              for (j = 0; j < sz; ++j) {
                uniformLocsById[id] = j;
                program.uniformArrayNamesById[id++] = arrayName;
              }
            }
          }
        };
        function _glGetUniformLocation(program, name2) {
          name2 >>>= 0;
          name2 = UTF8ToString(name2);
          if (program = GL.programs[program]) {
            webglPrepareUniformLocationsBeforeFirstUse(program);
            var uniformLocsById = program.uniformLocsById;
            var arrayIndex = 0;
            var uniformBaseName = name2;
            var leftBrace = webglGetLeftBracePos(name2);
            if (leftBrace > 0) {
              arrayIndex = jstoi_q(name2.slice(leftBrace + 1)) >>> 0;
              uniformBaseName = name2.slice(0, leftBrace);
            }
            var sizeAndId = program.uniformSizeAndIdsByName[uniformBaseName];
            if (sizeAndId && arrayIndex < sizeAndId[0]) {
              arrayIndex += sizeAndId[1];
              if (uniformLocsById[arrayIndex] = uniformLocsById[arrayIndex] || GLctx.getUniformLocation(program, name2)) {
                return arrayIndex;
              }
            }
          } else {
            GL.recordError(1281);
          }
          return -1;
        }
        _glGetUniformLocation.sig = "iip";
        var _emscripten_glGetUniformLocation = _glGetUniformLocation;
        var webglGetUniformLocation = (location) => {
          var p = GLctx.currentProgram;
          if (p) {
            var webglLoc = p.uniformLocsById[location];
            if (typeof webglLoc == "number") {
              p.uniformLocsById[location] = webglLoc = GLctx.getUniformLocation(p, p.uniformArrayNamesById[location] + (webglLoc > 0 ? `[${webglLoc}]` : ""));
            }
            return webglLoc;
          } else {
            GL.recordError(1282);
          }
        };
        var emscriptenWebGLGetUniform = (program, location, params, type) => {
          if (!params) {
            GL.recordError(1281);
            return;
          }
          program = GL.programs[program];
          webglPrepareUniformLocationsBeforeFirstUse(program);
          var data2 = GLctx.getUniform(program, webglGetUniformLocation(location));
          if (typeof data2 == "number" || typeof data2 == "boolean") {
            switch (type) {
              case 0:
                HEAP32[params >>> 2 >>> 0] = data2;
                break;
              case 2:
                HEAPF32[params >>> 2 >>> 0] = data2;
                break;
            }
          } else {
            for (var i2 = 0; i2 < data2.length; i2++) {
              switch (type) {
                case 0:
                  HEAP32[params + i2 * 4 >>> 2 >>> 0] = data2[i2];
                  break;
                case 2:
                  HEAPF32[params + i2 * 4 >>> 2 >>> 0] = data2[i2];
                  break;
              }
            }
          }
        };
        function _glGetUniformfv(program, location, params) {
          params >>>= 0;
          emscriptenWebGLGetUniform(program, location, params, 2);
        }
        _glGetUniformfv.sig = "viip";
        var _emscripten_glGetUniformfv = _glGetUniformfv;
        function _glGetUniformiv(program, location, params) {
          params >>>= 0;
          emscriptenWebGLGetUniform(program, location, params, 0);
        }
        _glGetUniformiv.sig = "viip";
        var _emscripten_glGetUniformiv = _glGetUniformiv;
        function _glGetVertexAttribPointerv(index, pname, pointer) {
          pointer >>>= 0;
          if (!pointer) {
            GL.recordError(1281);
            return;
          }
          HEAP32[pointer >>> 2 >>> 0] = GLctx.getVertexAttribOffset(index, pname);
        }
        _glGetVertexAttribPointerv.sig = "viip";
        var _emscripten_glGetVertexAttribPointerv = _glGetVertexAttribPointerv;
        var emscriptenWebGLGetVertexAttrib = (index, pname, params, type) => {
          if (!params) {
            GL.recordError(1281);
            return;
          }
          var data2 = GLctx.getVertexAttrib(index, pname);
          if (pname == 34975) {
            HEAP32[params >>> 2 >>> 0] = data2 && data2["name"];
          } else if (typeof data2 == "number" || typeof data2 == "boolean") {
            switch (type) {
              case 0:
                HEAP32[params >>> 2 >>> 0] = data2;
                break;
              case 2:
                HEAPF32[params >>> 2 >>> 0] = data2;
                break;
              case 5:
                HEAP32[params >>> 2 >>> 0] = Math.fround(data2);
                break;
            }
          } else {
            for (var i2 = 0; i2 < data2.length; i2++) {
              switch (type) {
                case 0:
                  HEAP32[params + i2 * 4 >>> 2 >>> 0] = data2[i2];
                  break;
                case 2:
                  HEAPF32[params + i2 * 4 >>> 2 >>> 0] = data2[i2];
                  break;
                case 5:
                  HEAP32[params + i2 * 4 >>> 2 >>> 0] = Math.fround(data2[i2]);
                  break;
              }
            }
          }
        };
        function _glGetVertexAttribfv(index, pname, params) {
          params >>>= 0;
          emscriptenWebGLGetVertexAttrib(index, pname, params, 2);
        }
        _glGetVertexAttribfv.sig = "viip";
        var _emscripten_glGetVertexAttribfv = _glGetVertexAttribfv;
        function _glGetVertexAttribiv(index, pname, params) {
          params >>>= 0;
          emscriptenWebGLGetVertexAttrib(index, pname, params, 5);
        }
        _glGetVertexAttribiv.sig = "viip";
        var _emscripten_glGetVertexAttribiv = _glGetVertexAttribiv;
        function _glHint(x0, x1) {
          GLctx.hint(x0, x1);
        }
        _glHint.sig = "vii";
        var _emscripten_glHint = _glHint;
        var _glIsBuffer = (buffer) => {
          var b = GL.buffers[buffer];
          if (!b)
            return 0;
          return GLctx.isBuffer(b);
        };
        _glIsBuffer.sig = "ii";
        var _emscripten_glIsBuffer = _glIsBuffer;
        function _glIsEnabled(x0) {
          return GLctx.isEnabled(x0);
        }
        _glIsEnabled.sig = "ii";
        var _emscripten_glIsEnabled = _glIsEnabled;
        var _glIsFramebuffer = (framebuffer) => {
          var fb = GL.framebuffers[framebuffer];
          if (!fb)
            return 0;
          return GLctx.isFramebuffer(fb);
        };
        _glIsFramebuffer.sig = "ii";
        var _emscripten_glIsFramebuffer = _glIsFramebuffer;
        var _glIsProgram = (program) => {
          program = GL.programs[program];
          if (!program)
            return 0;
          return GLctx.isProgram(program);
        };
        _glIsProgram.sig = "ii";
        var _emscripten_glIsProgram = _glIsProgram;
        var _glIsQueryEXT = (id) => {
          var query = GL.queries[id];
          if (!query)
            return 0;
          return GLctx.disjointTimerQueryExt["isQueryEXT"](query);
        };
        _glIsQueryEXT.sig = "ii";
        var _emscripten_glIsQueryEXT = _glIsQueryEXT;
        var _glIsRenderbuffer = (renderbuffer) => {
          var rb = GL.renderbuffers[renderbuffer];
          if (!rb)
            return 0;
          return GLctx.isRenderbuffer(rb);
        };
        _glIsRenderbuffer.sig = "ii";
        var _emscripten_glIsRenderbuffer = _glIsRenderbuffer;
        var _glIsShader = (shader) => {
          var s2 = GL.shaders[shader];
          if (!s2)
            return 0;
          return GLctx.isShader(s2);
        };
        _glIsShader.sig = "ii";
        var _emscripten_glIsShader = _glIsShader;
        var _glIsTexture = (id) => {
          var texture = GL.textures[id];
          if (!texture)
            return 0;
          return GLctx.isTexture(texture);
        };
        _glIsTexture.sig = "ii";
        var _emscripten_glIsTexture = _glIsTexture;
        var _glIsVertexArray = (array) => {
          var vao = GL.vaos[array];
          if (!vao)
            return 0;
          return GLctx.isVertexArray(vao);
        };
        _glIsVertexArray.sig = "ii";
        var _glIsVertexArrayOES = _glIsVertexArray;
        _glIsVertexArrayOES.sig = "ii";
        var _emscripten_glIsVertexArrayOES = _glIsVertexArrayOES;
        function _glLineWidth(x0) {
          GLctx.lineWidth(x0);
        }
        _glLineWidth.sig = "vf";
        var _emscripten_glLineWidth = _glLineWidth;
        var _glLinkProgram = (program) => {
          program = GL.programs[program];
          GLctx.linkProgram(program);
          program.uniformLocsById = 0;
          program.uniformSizeAndIdsByName = {};
        };
        _glLinkProgram.sig = "vi";
        var _emscripten_glLinkProgram = _glLinkProgram;
        var _glPixelStorei = (pname, param) => {
          if (pname == 3317) {
            GL.unpackAlignment = param;
          }
          GLctx.pixelStorei(pname, param);
        };
        _glPixelStorei.sig = "vii";
        var _emscripten_glPixelStorei = _glPixelStorei;
        function _glPolygonOffset(x0, x1) {
          GLctx.polygonOffset(x0, x1);
        }
        _glPolygonOffset.sig = "vff";
        var _emscripten_glPolygonOffset = _glPolygonOffset;
        var _glQueryCounterEXT = (id, target) => {
          GLctx.disjointTimerQueryExt["queryCounterEXT"](GL.queries[id], target);
        };
        _glQueryCounterEXT.sig = "vii";
        var _emscripten_glQueryCounterEXT = _glQueryCounterEXT;
        var computeUnpackAlignedImageSize = (width, height, sizePerPixel, alignment) => {
          function roundedToNextMultipleOf(x, y) {
            return x + y - 1 & -y;
          }
          var plainRowSize = width * sizePerPixel;
          var alignedRowSize = roundedToNextMultipleOf(plainRowSize, alignment);
          return height * alignedRowSize;
        };
        var colorChannelsInGlTextureFormat = (format) => {
          var colorChannels = {
            5: 3,
            6: 4,
            8: 2,
            29502: 3,
            29504: 4
          };
          return colorChannels[format - 6402] || 1;
        };
        var heapObjectForWebGLType = (type) => {
          type -= 5120;
          if (type == 1)
            return HEAPU8;
          if (type == 4)
            return HEAP32;
          if (type == 6)
            return HEAPF32;
          if (type == 5 || type == 28922)
            return HEAPU32;
          return HEAPU16;
        };
        var heapAccessShiftForWebGLHeap = (heap) => 31 - Math.clz32(heap.BYTES_PER_ELEMENT);
        var emscriptenWebGLGetTexPixelData = (type, format, width, height, pixels, internalFormat) => {
          var heap = heapObjectForWebGLType(type);
          var shift = heapAccessShiftForWebGLHeap(heap);
          var byteSize = 1 << shift;
          var sizePerPixel = colorChannelsInGlTextureFormat(format) * byteSize;
          var bytes = computeUnpackAlignedImageSize(width, height, sizePerPixel, GL.unpackAlignment);
          return heap.subarray(pixels >>> shift, pixels + bytes >>> shift);
        };
        function _glReadPixels(x, y, width, height, format, type, pixels) {
          pixels >>>= 0;
          var pixelData = emscriptenWebGLGetTexPixelData(type, format, width, height, pixels, format);
          if (!pixelData) {
            GL.recordError(1280);
            return;
          }
          GLctx.readPixels(x, y, width, height, format, type, pixelData);
        }
        _glReadPixels.sig = "viiiiiip";
        var _emscripten_glReadPixels = _glReadPixels;
        var _glReleaseShaderCompiler = () => {
        };
        _glReleaseShaderCompiler.sig = "v";
        var _emscripten_glReleaseShaderCompiler = _glReleaseShaderCompiler;
        function _glRenderbufferStorage(x0, x1, x2, x3) {
          GLctx.renderbufferStorage(x0, x1, x2, x3);
        }
        _glRenderbufferStorage.sig = "viiii";
        var _emscripten_glRenderbufferStorage = _glRenderbufferStorage;
        var _glSampleCoverage = (value, invert) => {
          GLctx.sampleCoverage(value, !!invert);
        };
        _glSampleCoverage.sig = "vfi";
        var _emscripten_glSampleCoverage = _glSampleCoverage;
        function _glScissor(x0, x1, x2, x3) {
          GLctx.scissor(x0, x1, x2, x3);
        }
        _glScissor.sig = "viiii";
        var _emscripten_glScissor = _glScissor;
        function _glShaderBinary(count, shaders, binaryformat, binary2, length) {
          shaders >>>= 0;
          binary2 >>>= 0;
          GL.recordError(1280);
        }
        _glShaderBinary.sig = "vipipi";
        var _emscripten_glShaderBinary = _glShaderBinary;
        function _glShaderSource(shader, count, string, length) {
          string >>>= 0;
          length >>>= 0;
          var source = GL.getSource(shader, count, string, length);
          GLctx.shaderSource(GL.shaders[shader], source);
        }
        _glShaderSource.sig = "viipp";
        var _emscripten_glShaderSource = _glShaderSource;
        function _glStencilFunc(x0, x1, x2) {
          GLctx.stencilFunc(x0, x1, x2);
        }
        _glStencilFunc.sig = "viii";
        var _emscripten_glStencilFunc = _glStencilFunc;
        function _glStencilFuncSeparate(x0, x1, x2, x3) {
          GLctx.stencilFuncSeparate(x0, x1, x2, x3);
        }
        _glStencilFuncSeparate.sig = "viiii";
        var _emscripten_glStencilFuncSeparate = _glStencilFuncSeparate;
        function _glStencilMask(x0) {
          GLctx.stencilMask(x0);
        }
        _glStencilMask.sig = "vi";
        var _emscripten_glStencilMask = _glStencilMask;
        function _glStencilMaskSeparate(x0, x1) {
          GLctx.stencilMaskSeparate(x0, x1);
        }
        _glStencilMaskSeparate.sig = "vii";
        var _emscripten_glStencilMaskSeparate = _glStencilMaskSeparate;
        function _glStencilOp(x0, x1, x2) {
          GLctx.stencilOp(x0, x1, x2);
        }
        _glStencilOp.sig = "viii";
        var _emscripten_glStencilOp = _glStencilOp;
        function _glStencilOpSeparate(x0, x1, x2, x3) {
          GLctx.stencilOpSeparate(x0, x1, x2, x3);
        }
        _glStencilOpSeparate.sig = "viiii";
        var _emscripten_glStencilOpSeparate = _glStencilOpSeparate;
        function _glTexImage2D(target, level, internalFormat, width, height, border, format, type, pixels) {
          pixels >>>= 0;
          GLctx.texImage2D(target, level, internalFormat, width, height, border, format, type, pixels ? emscriptenWebGLGetTexPixelData(type, format, width, height, pixels, internalFormat) : null);
        }
        _glTexImage2D.sig = "viiiiiiiip";
        var _emscripten_glTexImage2D = _glTexImage2D;
        function _glTexParameterf(x0, x1, x2) {
          GLctx.texParameterf(x0, x1, x2);
        }
        _glTexParameterf.sig = "viif";
        var _emscripten_glTexParameterf = _glTexParameterf;
        function _glTexParameterfv(target, pname, params) {
          params >>>= 0;
          var param = HEAPF32[params >>> 2 >>> 0];
          GLctx.texParameterf(target, pname, param);
        }
        _glTexParameterfv.sig = "viip";
        var _emscripten_glTexParameterfv = _glTexParameterfv;
        function _glTexParameteri(x0, x1, x2) {
          GLctx.texParameteri(x0, x1, x2);
        }
        _glTexParameteri.sig = "viii";
        var _emscripten_glTexParameteri = _glTexParameteri;
        function _glTexParameteriv(target, pname, params) {
          params >>>= 0;
          var param = HEAP32[params >>> 2 >>> 0];
          GLctx.texParameteri(target, pname, param);
        }
        _glTexParameteriv.sig = "viip";
        var _emscripten_glTexParameteriv = _glTexParameteriv;
        function _glTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels) {
          pixels >>>= 0;
          var pixelData = null;
          if (pixels)
            pixelData = emscriptenWebGLGetTexPixelData(type, format, width, height, pixels, 0);
          GLctx.texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixelData);
        }
        _glTexSubImage2D.sig = "viiiiiiiip";
        var _emscripten_glTexSubImage2D = _glTexSubImage2D;
        var _glUniform1f = (location, v0) => {
          GLctx.uniform1f(webglGetUniformLocation(location), v0);
        };
        _glUniform1f.sig = "vif";
        var _emscripten_glUniform1f = _glUniform1f;
        var miniTempWebGLFloatBuffers = [];
        function _glUniform1fv(location, count, value) {
          value >>>= 0;
          if (count <= 288) {
            var view = miniTempWebGLFloatBuffers[count - 1];
            for (var i2 = 0; i2 < count; ++i2) {
              view[i2] = HEAPF32[value + 4 * i2 >>> 2 >>> 0];
            }
          } else {
            var view = HEAPF32.subarray(value >>> 2 >>> 0, value + count * 4 >>> 2 >>> 0);
          }
          GLctx.uniform1fv(webglGetUniformLocation(location), view);
        }
        _glUniform1fv.sig = "viip";
        var _emscripten_glUniform1fv = _glUniform1fv;
        var _glUniform1i = (location, v0) => {
          GLctx.uniform1i(webglGetUniformLocation(location), v0);
        };
        _glUniform1i.sig = "vii";
        var _emscripten_glUniform1i = _glUniform1i;
        var miniTempWebGLIntBuffers = [];
        function _glUniform1iv(location, count, value) {
          value >>>= 0;
          if (count <= 288) {
            var view = miniTempWebGLIntBuffers[count - 1];
            for (var i2 = 0; i2 < count; ++i2) {
              view[i2] = HEAP32[value + 4 * i2 >>> 2 >>> 0];
            }
          } else {
            var view = HEAP32.subarray(value >>> 2 >>> 0, value + count * 4 >>> 2 >>> 0);
          }
          GLctx.uniform1iv(webglGetUniformLocation(location), view);
        }
        _glUniform1iv.sig = "viip";
        var _emscripten_glUniform1iv = _glUniform1iv;
        var _glUniform2f = (location, v0, v1) => {
          GLctx.uniform2f(webglGetUniformLocation(location), v0, v1);
        };
        _glUniform2f.sig = "viff";
        var _emscripten_glUniform2f = _glUniform2f;
        function _glUniform2fv(location, count, value) {
          value >>>= 0;
          if (count <= 144) {
            var view = miniTempWebGLFloatBuffers[2 * count - 1];
            for (var i2 = 0; i2 < 2 * count; i2 += 2) {
              view[i2] = HEAPF32[value + 4 * i2 >>> 2 >>> 0];
              view[i2 + 1] = HEAPF32[value + (4 * i2 + 4) >>> 2 >>> 0];
            }
          } else {
            var view = HEAPF32.subarray(value >>> 2 >>> 0, value + count * 8 >>> 2 >>> 0);
          }
          GLctx.uniform2fv(webglGetUniformLocation(location), view);
        }
        _glUniform2fv.sig = "viip";
        var _emscripten_glUniform2fv = _glUniform2fv;
        var _glUniform2i = (location, v0, v1) => {
          GLctx.uniform2i(webglGetUniformLocation(location), v0, v1);
        };
        _glUniform2i.sig = "viii";
        var _emscripten_glUniform2i = _glUniform2i;
        function _glUniform2iv(location, count, value) {
          value >>>= 0;
          if (count <= 144) {
            var view = miniTempWebGLIntBuffers[2 * count - 1];
            for (var i2 = 0; i2 < 2 * count; i2 += 2) {
              view[i2] = HEAP32[value + 4 * i2 >>> 2 >>> 0];
              view[i2 + 1] = HEAP32[value + (4 * i2 + 4) >>> 2 >>> 0];
            }
          } else {
            var view = HEAP32.subarray(value >>> 2 >>> 0, value + count * 8 >>> 2 >>> 0);
          }
          GLctx.uniform2iv(webglGetUniformLocation(location), view);
        }
        _glUniform2iv.sig = "viip";
        var _emscripten_glUniform2iv = _glUniform2iv;
        var _glUniform3f = (location, v0, v1, v2) => {
          GLctx.uniform3f(webglGetUniformLocation(location), v0, v1, v2);
        };
        _glUniform3f.sig = "vifff";
        var _emscripten_glUniform3f = _glUniform3f;
        function _glUniform3fv(location, count, value) {
          value >>>= 0;
          if (count <= 96) {
            var view = miniTempWebGLFloatBuffers[3 * count - 1];
            for (var i2 = 0; i2 < 3 * count; i2 += 3) {
              view[i2] = HEAPF32[value + 4 * i2 >>> 2 >>> 0];
              view[i2 + 1] = HEAPF32[value + (4 * i2 + 4) >>> 2 >>> 0];
              view[i2 + 2] = HEAPF32[value + (4 * i2 + 8) >>> 2 >>> 0];
            }
          } else {
            var view = HEAPF32.subarray(value >>> 2 >>> 0, value + count * 12 >>> 2 >>> 0);
          }
          GLctx.uniform3fv(webglGetUniformLocation(location), view);
        }
        _glUniform3fv.sig = "viip";
        var _emscripten_glUniform3fv = _glUniform3fv;
        var _glUniform3i = (location, v0, v1, v2) => {
          GLctx.uniform3i(webglGetUniformLocation(location), v0, v1, v2);
        };
        _glUniform3i.sig = "viiii";
        var _emscripten_glUniform3i = _glUniform3i;
        function _glUniform3iv(location, count, value) {
          value >>>= 0;
          if (count <= 96) {
            var view = miniTempWebGLIntBuffers[3 * count - 1];
            for (var i2 = 0; i2 < 3 * count; i2 += 3) {
              view[i2] = HEAP32[value + 4 * i2 >>> 2 >>> 0];
              view[i2 + 1] = HEAP32[value + (4 * i2 + 4) >>> 2 >>> 0];
              view[i2 + 2] = HEAP32[value + (4 * i2 + 8) >>> 2 >>> 0];
            }
          } else {
            var view = HEAP32.subarray(value >>> 2 >>> 0, value + count * 12 >>> 2 >>> 0);
          }
          GLctx.uniform3iv(webglGetUniformLocation(location), view);
        }
        _glUniform3iv.sig = "viip";
        var _emscripten_glUniform3iv = _glUniform3iv;
        var _glUniform4f = (location, v0, v1, v2, v3) => {
          GLctx.uniform4f(webglGetUniformLocation(location), v0, v1, v2, v3);
        };
        _glUniform4f.sig = "viffff";
        var _emscripten_glUniform4f = _glUniform4f;
        function _glUniform4fv(location, count, value) {
          value >>>= 0;
          if (count <= 72) {
            var view = miniTempWebGLFloatBuffers[4 * count - 1];
            var heap = HEAPF32;
            value >>= 2;
            for (var i2 = 0; i2 < 4 * count; i2 += 4) {
              var dst = value + i2;
              view[i2] = heap[dst >>> 0];
              view[i2 + 1] = heap[dst + 1 >>> 0];
              view[i2 + 2] = heap[dst + 2 >>> 0];
              view[i2 + 3] = heap[dst + 3 >>> 0];
            }
          } else {
            var view = HEAPF32.subarray(value >>> 2 >>> 0, value + count * 16 >>> 2 >>> 0);
          }
          GLctx.uniform4fv(webglGetUniformLocation(location), view);
        }
        _glUniform4fv.sig = "viip";
        var _emscripten_glUniform4fv = _glUniform4fv;
        var _glUniform4i = (location, v0, v1, v2, v3) => {
          GLctx.uniform4i(webglGetUniformLocation(location), v0, v1, v2, v3);
        };
        _glUniform4i.sig = "viiiii";
        var _emscripten_glUniform4i = _glUniform4i;
        function _glUniform4iv(location, count, value) {
          value >>>= 0;
          if (count <= 72) {
            var view = miniTempWebGLIntBuffers[4 * count - 1];
            for (var i2 = 0; i2 < 4 * count; i2 += 4) {
              view[i2] = HEAP32[value + 4 * i2 >>> 2 >>> 0];
              view[i2 + 1] = HEAP32[value + (4 * i2 + 4) >>> 2 >>> 0];
              view[i2 + 2] = HEAP32[value + (4 * i2 + 8) >>> 2 >>> 0];
              view[i2 + 3] = HEAP32[value + (4 * i2 + 12) >>> 2 >>> 0];
            }
          } else {
            var view = HEAP32.subarray(value >>> 2 >>> 0, value + count * 16 >>> 2 >>> 0);
          }
          GLctx.uniform4iv(webglGetUniformLocation(location), view);
        }
        _glUniform4iv.sig = "viip";
        var _emscripten_glUniform4iv = _glUniform4iv;
        function _glUniformMatrix2fv(location, count, transpose, value) {
          value >>>= 0;
          if (count <= 72) {
            var view = miniTempWebGLFloatBuffers[4 * count - 1];
            for (var i2 = 0; i2 < 4 * count; i2 += 4) {
              view[i2] = HEAPF32[value + 4 * i2 >>> 2 >>> 0];
              view[i2 + 1] = HEAPF32[value + (4 * i2 + 4) >>> 2 >>> 0];
              view[i2 + 2] = HEAPF32[value + (4 * i2 + 8) >>> 2 >>> 0];
              view[i2 + 3] = HEAPF32[value + (4 * i2 + 12) >>> 2 >>> 0];
            }
          } else {
            var view = HEAPF32.subarray(value >>> 2 >>> 0, value + count * 16 >>> 2 >>> 0);
          }
          GLctx.uniformMatrix2fv(webglGetUniformLocation(location), !!transpose, view);
        }
        _glUniformMatrix2fv.sig = "viiip";
        var _emscripten_glUniformMatrix2fv = _glUniformMatrix2fv;
        function _glUniformMatrix3fv(location, count, transpose, value) {
          value >>>= 0;
          if (count <= 32) {
            var view = miniTempWebGLFloatBuffers[9 * count - 1];
            for (var i2 = 0; i2 < 9 * count; i2 += 9) {
              view[i2] = HEAPF32[value + 4 * i2 >>> 2 >>> 0];
              view[i2 + 1] = HEAPF32[value + (4 * i2 + 4) >>> 2 >>> 0];
              view[i2 + 2] = HEAPF32[value + (4 * i2 + 8) >>> 2 >>> 0];
              view[i2 + 3] = HEAPF32[value + (4 * i2 + 12) >>> 2 >>> 0];
              view[i2 + 4] = HEAPF32[value + (4 * i2 + 16) >>> 2 >>> 0];
              view[i2 + 5] = HEAPF32[value + (4 * i2 + 20) >>> 2 >>> 0];
              view[i2 + 6] = HEAPF32[value + (4 * i2 + 24) >>> 2 >>> 0];
              view[i2 + 7] = HEAPF32[value + (4 * i2 + 28) >>> 2 >>> 0];
              view[i2 + 8] = HEAPF32[value + (4 * i2 + 32) >>> 2 >>> 0];
            }
          } else {
            var view = HEAPF32.subarray(value >>> 2 >>> 0, value + count * 36 >>> 2 >>> 0);
          }
          GLctx.uniformMatrix3fv(webglGetUniformLocation(location), !!transpose, view);
        }
        _glUniformMatrix3fv.sig = "viiip";
        var _emscripten_glUniformMatrix3fv = _glUniformMatrix3fv;
        function _glUniformMatrix4fv(location, count, transpose, value) {
          value >>>= 0;
          if (count <= 18) {
            var view = miniTempWebGLFloatBuffers[16 * count - 1];
            var heap = HEAPF32;
            value >>= 2;
            for (var i2 = 0; i2 < 16 * count; i2 += 16) {
              var dst = value + i2;
              view[i2] = heap[dst >>> 0];
              view[i2 + 1] = heap[dst + 1 >>> 0];
              view[i2 + 2] = heap[dst + 2 >>> 0];
              view[i2 + 3] = heap[dst + 3 >>> 0];
              view[i2 + 4] = heap[dst + 4 >>> 0];
              view[i2 + 5] = heap[dst + 5 >>> 0];
              view[i2 + 6] = heap[dst + 6 >>> 0];
              view[i2 + 7] = heap[dst + 7 >>> 0];
              view[i2 + 8] = heap[dst + 8 >>> 0];
              view[i2 + 9] = heap[dst + 9 >>> 0];
              view[i2 + 10] = heap[dst + 10 >>> 0];
              view[i2 + 11] = heap[dst + 11 >>> 0];
              view[i2 + 12] = heap[dst + 12 >>> 0];
              view[i2 + 13] = heap[dst + 13 >>> 0];
              view[i2 + 14] = heap[dst + 14 >>> 0];
              view[i2 + 15] = heap[dst + 15 >>> 0];
            }
          } else {
            var view = HEAPF32.subarray(value >>> 2 >>> 0, value + count * 64 >>> 2 >>> 0);
          }
          GLctx.uniformMatrix4fv(webglGetUniformLocation(location), !!transpose, view);
        }
        _glUniformMatrix4fv.sig = "viiip";
        var _emscripten_glUniformMatrix4fv = _glUniformMatrix4fv;
        var _glUseProgram = (program) => {
          program = GL.programs[program];
          GLctx.useProgram(program);
          GLctx.currentProgram = program;
        };
        _glUseProgram.sig = "vi";
        var _emscripten_glUseProgram = _glUseProgram;
        var _glValidateProgram = (program) => {
          GLctx.validateProgram(GL.programs[program]);
        };
        _glValidateProgram.sig = "vi";
        var _emscripten_glValidateProgram = _glValidateProgram;
        function _glVertexAttrib1f(x0, x1) {
          GLctx.vertexAttrib1f(x0, x1);
        }
        _glVertexAttrib1f.sig = "vif";
        var _emscripten_glVertexAttrib1f = _glVertexAttrib1f;
        function _glVertexAttrib1fv(index, v) {
          v >>>= 0;
          GLctx.vertexAttrib1f(index, HEAPF32[v >>> 2]);
        }
        _glVertexAttrib1fv.sig = "vip";
        var _emscripten_glVertexAttrib1fv = _glVertexAttrib1fv;
        function _glVertexAttrib2f(x0, x1, x2) {
          GLctx.vertexAttrib2f(x0, x1, x2);
        }
        _glVertexAttrib2f.sig = "viff";
        var _emscripten_glVertexAttrib2f = _glVertexAttrib2f;
        function _glVertexAttrib2fv(index, v) {
          v >>>= 0;
          GLctx.vertexAttrib2f(index, HEAPF32[v >>> 2], HEAPF32[v + 4 >>> 2]);
        }
        _glVertexAttrib2fv.sig = "vip";
        var _emscripten_glVertexAttrib2fv = _glVertexAttrib2fv;
        function _glVertexAttrib3f(x0, x1, x2, x3) {
          GLctx.vertexAttrib3f(x0, x1, x2, x3);
        }
        _glVertexAttrib3f.sig = "vifff";
        var _emscripten_glVertexAttrib3f = _glVertexAttrib3f;
        function _glVertexAttrib3fv(index, v) {
          v >>>= 0;
          GLctx.vertexAttrib3f(index, HEAPF32[v >>> 2], HEAPF32[v + 4 >>> 2], HEAPF32[v + 8 >>> 2]);
        }
        _glVertexAttrib3fv.sig = "vip";
        var _emscripten_glVertexAttrib3fv = _glVertexAttrib3fv;
        function _glVertexAttrib4f(x0, x1, x2, x3, x4) {
          GLctx.vertexAttrib4f(x0, x1, x2, x3, x4);
        }
        _glVertexAttrib4f.sig = "viffff";
        var _emscripten_glVertexAttrib4f = _glVertexAttrib4f;
        function _glVertexAttrib4fv(index, v) {
          v >>>= 0;
          GLctx.vertexAttrib4f(index, HEAPF32[v >>> 2], HEAPF32[v + 4 >>> 2], HEAPF32[v + 8 >>> 2], HEAPF32[v + 12 >>> 2]);
        }
        _glVertexAttrib4fv.sig = "vip";
        var _emscripten_glVertexAttrib4fv = _glVertexAttrib4fv;
        var _glVertexAttribDivisor = (index, divisor) => {
          GLctx.vertexAttribDivisor(index, divisor);
        };
        _glVertexAttribDivisor.sig = "vii";
        var _glVertexAttribDivisorANGLE = _glVertexAttribDivisor;
        var _emscripten_glVertexAttribDivisorANGLE = _glVertexAttribDivisorANGLE;
        function _glVertexAttribPointer(index, size, type, normalized, stride, ptr2) {
          ptr2 >>>= 0;
          GLctx.vertexAttribPointer(index, size, type, !!normalized, stride, ptr2);
        }
        _glVertexAttribPointer.sig = "viiiiip";
        var _emscripten_glVertexAttribPointer = _glVertexAttribPointer;
        function _glViewport(x0, x1, x2, x3) {
          GLctx.viewport(x0, x1, x2, x3);
        }
        _glViewport.sig = "viiii";
        var _emscripten_glViewport = _glViewport;
        function _emscripten_memcpy_js(dest, src, num) {
          dest >>>= 0;
          src >>>= 0;
          num >>>= 0;
          return HEAPU8.copyWithin(dest >>> 0, src >>> 0, src + num >>> 0);
        }
        _emscripten_memcpy_js.sig = "vppp";
        function _emscripten_out(str) {
          str >>>= 0;
          return out(UTF8ToString(str));
        }
        _emscripten_out.sig = "vp";
        var promiseMap = new HandleAllocator();
        var makePromise = () => {
          var promiseInfo = {};
          promiseInfo.promise = new Promise((resolve, reject) => {
            promiseInfo.reject = reject;
            promiseInfo.resolve = resolve;
          });
          promiseInfo.id = promiseMap.allocate(promiseInfo);
          return promiseInfo;
        };
        function _emscripten_promise_create() {
          return makePromise().id;
        }
        _emscripten_promise_create.sig = "p";
        function _emscripten_promise_destroy(id) {
          id >>>= 0;
          promiseMap.free(id);
        }
        _emscripten_promise_destroy.sig = "vp";
        var getPromise = (id) => promiseMap.get(id).promise;
        function _emscripten_promise_resolve(id, result, value) {
          id >>>= 0;
          value >>>= 0;
          var info2 = promiseMap.get(id);
          switch (result) {
            case 0:
              info2.resolve(value);
              return;
            case 1:
              info2.resolve(getPromise(value));
              return;
            case 2:
              info2.resolve(getPromise(value));
              _emscripten_promise_destroy(value);
              return;
            case 3:
              info2.reject(value);
              return;
          }
        }
        _emscripten_promise_resolve.sig = "vpip";
        var growMemory = (size) => {
          var b = wasmMemory.buffer;
          var pages = (size - b.byteLength + 65535) / 65536;
          try {
            wasmMemory.grow(pages);
            updateMemoryViews();
            return 1;
          } catch (e) {
          }
        };
        function _emscripten_resize_heap(requestedSize) {
          requestedSize >>>= 0;
          var oldSize = HEAPU8.length;
          var maxHeapSize = getHeapMax();
          if (requestedSize > maxHeapSize) {
            return false;
          }
          var alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;
          for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
            var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
            overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
            var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
            var replacement = growMemory(newSize);
            if (replacement) {
              return true;
            }
          }
          return false;
        }
        _emscripten_resize_heap.sig = "ip";
        function _emscripten_wget_data(url2, pbuffer, pnum, perror) {
          url2 >>>= 0;
          pbuffer >>>= 0;
          pnum >>>= 0;
          perror >>>= 0;
          throw "Please compile your program with async support in order to use asynchronous operations like emscripten_wget_data";
        }
        _emscripten_wget_data.sig = "vpppp";
        var getExecutableName = () => thisProgram || "./this.program";
        var getEnvStrings = () => {
          if (!getEnvStrings.strings) {
            var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
            var env = {
              "USER": "web_user",
              "LOGNAME": "web_user",
              "PATH": "/",
              "PWD": "/",
              "HOME": "/home/web_user",
              "LANG": lang,
              "_": getExecutableName()
            };
            for (var x in ENV) {
              if (ENV[x] === void 0)
                delete env[x];
              else
                env[x] = ENV[x];
            }
            var strings = [];
            for (var x in env) {
              strings.push(`${x}=${env[x]}`);
            }
            getEnvStrings.strings = strings;
          }
          return getEnvStrings.strings;
        };
        var stringToAscii = (str, buffer) => {
          for (var i2 = 0; i2 < str.length; ++i2) {
            HEAP8[buffer++ >>> 0 >>> 0] = str.charCodeAt(i2);
          }
          HEAP8[buffer >>> 0 >>> 0] = 0;
        };
        var _environ_get = function(__environ, environ_buf) {
          __environ >>>= 0;
          environ_buf >>>= 0;
          var bufSize = 0;
          getEnvStrings().forEach((string, i2) => {
            var ptr2 = environ_buf + bufSize;
            HEAPU32[__environ + i2 * 4 >>> 2 >>> 0] = ptr2;
            stringToAscii(string, ptr2);
            bufSize += string.length + 1;
          });
          return 0;
        };
        _environ_get.sig = "ipp";
        var _environ_sizes_get = function(penviron_count, penviron_buf_size) {
          penviron_count >>>= 0;
          penviron_buf_size >>>= 0;
          var strings = getEnvStrings();
          HEAPU32[penviron_count >>> 2 >>> 0] = strings.length;
          var bufSize = 0;
          strings.forEach((string) => bufSize += string.length + 1);
          HEAPU32[penviron_buf_size >>> 2 >>> 0] = bufSize;
          return 0;
        };
        _environ_sizes_get.sig = "ipp";
        function _fd_close(fd) {
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            FS.close(stream);
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return e.errno;
          }
        }
        _fd_close.sig = "ii";
        function _fd_fdstat_get(fd, pbuf) {
          pbuf >>>= 0;
          try {
            var rightsBase = 0;
            var rightsInheriting = 0;
            var flags2 = 0;
            {
              var stream = SYSCALLS.getStreamFromFD(fd);
              var type = stream.tty ? 2 : FS.isDir(stream.mode) ? 3 : FS.isLink(stream.mode) ? 7 : 4;
            }
            HEAP8[pbuf >>> 0 >>> 0] = type;
            HEAP16[pbuf + 2 >>> 1 >>> 0] = flags2;
            tempI64 = [rightsBase >>> 0, (tempDouble = rightsBase, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[pbuf + 8 >>> 2 >>> 0] = tempI64[0], HEAP32[pbuf + 12 >>> 2 >>> 0] = tempI64[1];
            tempI64 = [rightsInheriting >>> 0, (tempDouble = rightsInheriting, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[pbuf + 16 >>> 2 >>> 0] = tempI64[0], HEAP32[pbuf + 20 >>> 2 >>> 0] = tempI64[1];
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return e.errno;
          }
        }
        _fd_fdstat_get.sig = "iip";
        var doReadv = (stream, iov, iovcnt, offset) => {
          var ret = 0;
          for (var i2 = 0; i2 < iovcnt; i2++) {
            var ptr2 = HEAPU32[iov >>> 2 >>> 0];
            var len2 = HEAPU32[iov + 4 >>> 2 >>> 0];
            iov += 8;
            var curr = FS.read(stream, HEAP8, ptr2, len2, offset);
            if (curr < 0)
              return -1;
            ret += curr;
            if (curr < len2)
              break;
            if (typeof offset !== "undefined") {
              offset += curr;
            }
          }
          return ret;
        };
        function _fd_pread(fd, iov, iovcnt, offset_low, offset_high, pnum) {
          iov >>>= 0;
          iovcnt >>>= 0;
          var offset = convertI32PairToI53Checked(offset_low, offset_high);
          pnum >>>= 0;
          try {
            if (isNaN(offset))
              return 61;
            var stream = SYSCALLS.getStreamFromFD(fd);
            var num = doReadv(stream, iov, iovcnt, offset);
            HEAPU32[pnum >>> 2 >>> 0] = num;
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return e.errno;
          }
        }
        _fd_pread.sig = "iippiip";
        var doWritev = (stream, iov, iovcnt, offset) => {
          var ret = 0;
          for (var i2 = 0; i2 < iovcnt; i2++) {
            var ptr2 = HEAPU32[iov >>> 2 >>> 0];
            var len2 = HEAPU32[iov + 4 >>> 2 >>> 0];
            iov += 8;
            var curr = FS.write(stream, HEAP8, ptr2, len2, offset);
            if (curr < 0)
              return -1;
            ret += curr;
            if (typeof offset !== "undefined") {
              offset += curr;
            }
          }
          return ret;
        };
        function _fd_pwrite(fd, iov, iovcnt, offset_low, offset_high, pnum) {
          iov >>>= 0;
          iovcnt >>>= 0;
          var offset = convertI32PairToI53Checked(offset_low, offset_high);
          pnum >>>= 0;
          try {
            if (isNaN(offset))
              return 61;
            var stream = SYSCALLS.getStreamFromFD(fd);
            var num = doWritev(stream, iov, iovcnt, offset);
            HEAPU32[pnum >>> 2 >>> 0] = num;
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return e.errno;
          }
        }
        _fd_pwrite.sig = "iippiip";
        function _fd_read(fd, iov, iovcnt, pnum) {
          iov >>>= 0;
          iovcnt >>>= 0;
          pnum >>>= 0;
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            var num = doReadv(stream, iov, iovcnt);
            HEAPU32[pnum >>> 2 >>> 0] = num;
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return e.errno;
          }
        }
        _fd_read.sig = "iippp";
        function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
          var offset = convertI32PairToI53Checked(offset_low, offset_high);
          newOffset >>>= 0;
          try {
            if (isNaN(offset))
              return 61;
            var stream = SYSCALLS.getStreamFromFD(fd);
            FS.llseek(stream, offset, whence);
            tempI64 = [stream.position >>> 0, (tempDouble = stream.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[newOffset >>> 2 >>> 0] = tempI64[0], HEAP32[newOffset + 4 >>> 2 >>> 0] = tempI64[1];
            if (stream.getdents && offset === 0 && whence === 0)
              stream.getdents = null;
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return e.errno;
          }
        }
        _fd_seek.sig = "iiiiip";
        function _fd_sync(fd) {
          var _a;
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            if ((_a = stream.stream_ops) == null ? void 0 : _a.fsync) {
              return stream.stream_ops.fsync(stream);
            }
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return e.errno;
          }
        }
        _fd_sync.sig = "ii";
        function _fd_write(fd, iov, iovcnt, pnum) {
          iov >>>= 0;
          iovcnt >>>= 0;
          pnum >>>= 0;
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            var num = doWritev(stream, iov, iovcnt);
            HEAPU32[pnum >>> 2 >>> 0] = num;
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return e.errno;
          }
        }
        _fd_write.sig = "iippp";
        function _getaddrinfo(node, service, hint, out2) {
          node >>>= 0;
          service >>>= 0;
          hint >>>= 0;
          out2 >>>= 0;
          var addrs = [];
          var canon = null;
          var addr2 = 0;
          var port = 0;
          var flags2 = 0;
          var family = 0;
          var type = 0;
          var proto = 0;
          var ai, last;
          function allocaddrinfo(family2, type2, proto2, canon2, addr3, port2) {
            var sa, salen, ai2;
            var errno;
            salen = family2 === 10 ? 28 : 16;
            addr3 = family2 === 10 ? inetNtop6(addr3) : inetNtop4(addr3);
            sa = _malloc(salen);
            errno = writeSockaddr(sa, family2, addr3, port2);
            assert(!errno);
            ai2 = _malloc(32);
            HEAP32[ai2 + 4 >>> 2 >>> 0] = family2;
            HEAP32[ai2 + 8 >>> 2 >>> 0] = type2;
            HEAP32[ai2 + 12 >>> 2 >>> 0] = proto2;
            HEAPU32[ai2 + 24 >>> 2 >>> 0] = canon2;
            HEAPU32[ai2 + 20 >>> 2 >>> 0] = sa;
            if (family2 === 10) {
              HEAP32[ai2 + 16 >>> 2 >>> 0] = 28;
            } else {
              HEAP32[ai2 + 16 >>> 2 >>> 0] = 16;
            }
            HEAP32[ai2 + 28 >>> 2 >>> 0] = 0;
            return ai2;
          }
          if (hint) {
            flags2 = HEAP32[hint >>> 2 >>> 0];
            family = HEAP32[hint + 4 >>> 2 >>> 0];
            type = HEAP32[hint + 8 >>> 2 >>> 0];
            proto = HEAP32[hint + 12 >>> 2 >>> 0];
          }
          if (type && !proto) {
            proto = type === 2 ? 17 : 6;
          }
          if (!type && proto) {
            type = proto === 17 ? 2 : 1;
          }
          if (proto === 0) {
            proto = 6;
          }
          if (type === 0) {
            type = 1;
          }
          if (!node && !service) {
            return -2;
          }
          if (flags2 & ~(1 | 2 | 4 | 1024 | 8 | 16 | 32)) {
            return -1;
          }
          if (hint !== 0 && HEAP32[hint >>> 2 >>> 0] & 2 && !node) {
            return -1;
          }
          if (flags2 & 32) {
            return -2;
          }
          if (type !== 0 && type !== 1 && type !== 2) {
            return -7;
          }
          if (family !== 0 && family !== 2 && family !== 10) {
            return -6;
          }
          if (service) {
            service = UTF8ToString(service);
            port = parseInt(service, 10);
            if (isNaN(port)) {
              if (flags2 & 1024) {
                return -2;
              }
              return -8;
            }
          }
          if (!node) {
            if (family === 0) {
              family = 2;
            }
            if ((flags2 & 1) === 0) {
              if (family === 2) {
                addr2 = _htonl(2130706433);
              } else {
                addr2 = [0, 0, 0, 1];
              }
            }
            ai = allocaddrinfo(family, type, proto, null, addr2, port);
            HEAPU32[out2 >>> 2 >>> 0] = ai;
            return 0;
          }
          node = UTF8ToString(node);
          addr2 = inetPton4(node);
          if (addr2 !== null) {
            if (family === 0 || family === 2) {
              family = 2;
            } else if (family === 10 && flags2 & 8) {
              addr2 = [0, 0, _htonl(65535), addr2];
              family = 10;
            } else {
              return -2;
            }
          } else {
            addr2 = inetPton6(node);
            if (addr2 !== null) {
              if (family === 0 || family === 10) {
                family = 10;
              } else {
                return -2;
              }
            }
          }
          if (addr2 != null) {
            ai = allocaddrinfo(family, type, proto, node, addr2, port);
            HEAPU32[out2 >>> 2 >>> 0] = ai;
            return 0;
          }
          if (flags2 & 4) {
            return -2;
          }
          node = DNS.lookup_name(node);
          addr2 = inetPton4(node);
          if (family === 0) {
            family = 2;
          } else if (family === 10) {
            addr2 = [0, 0, _htonl(65535), addr2];
          }
          ai = allocaddrinfo(family, type, proto, null, addr2, port);
          HEAPU32[out2 >>> 2 >>> 0] = ai;
          return 0;
        }
        _getaddrinfo.sig = "ipppp";
        function _getentropy(buffer, size) {
          buffer >>>= 0;
          size >>>= 0;
          randomFill(HEAPU8.subarray(buffer >>> 0, buffer + size >>> 0));
          return 0;
        }
        _getentropy.sig = "ipp";
        function _getnameinfo(sa, salen, node, nodelen, serv, servlen, flags2) {
          sa >>>= 0;
          node >>>= 0;
          serv >>>= 0;
          var info2 = readSockaddr(sa, salen);
          if (info2.errno) {
            return -6;
          }
          var port = info2.port;
          var addr2 = info2.addr;
          var overflowed = false;
          if (node && nodelen) {
            var lookup;
            if (flags2 & 1 || !(lookup = DNS.lookup_addr(addr2))) {
              if (flags2 & 8) {
                return -2;
              }
            } else {
              addr2 = lookup;
            }
            var numBytesWrittenExclNull = stringToUTF8(addr2, node, nodelen);
            if (numBytesWrittenExclNull + 1 >= nodelen) {
              overflowed = true;
            }
          }
          if (serv && servlen) {
            port = "" + port;
            var numBytesWrittenExclNull = stringToUTF8(port, serv, servlen);
            if (numBytesWrittenExclNull + 1 >= servlen) {
              overflowed = true;
            }
          }
          if (overflowed) {
            return -12;
          }
          return 0;
        }
        _getnameinfo.sig = "ipipipii";
        function _llvm_eh_typeid_for(type) {
          type >>>= 0;
          return type;
        }
        _llvm_eh_typeid_for.sig = "vp";
        function _pthread_kill() {
          return wasmImports["pthread_kill"].apply(null, arguments);
        }
        _pthread_kill.stub = true;
        var arraySum = (array, index) => {
          var sum = 0;
          for (var i2 = 0; i2 <= index; sum += array[i2++]) {
          }
          return sum;
        };
        var MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        var MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        var addDays = (date, days) => {
          var newDate = new Date(date.getTime());
          while (days > 0) {
            var leap = isLeapYear(newDate.getFullYear());
            var currentMonth = newDate.getMonth();
            var daysInCurrentMonth = (leap ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[currentMonth];
            if (days > daysInCurrentMonth - newDate.getDate()) {
              days -= daysInCurrentMonth - newDate.getDate() + 1;
              newDate.setDate(1);
              if (currentMonth < 11) {
                newDate.setMonth(currentMonth + 1);
              } else {
                newDate.setMonth(0);
                newDate.setFullYear(newDate.getFullYear() + 1);
              }
            } else {
              newDate.setDate(newDate.getDate() + days);
              return newDate;
            }
          }
          return newDate;
        };
        var writeArrayToMemory = (array, buffer) => {
          HEAP8.set(array, buffer >>> 0);
        };
        function _strftime(s2, maxsize, format, tm) {
          s2 >>>= 0;
          maxsize >>>= 0;
          format >>>= 0;
          tm >>>= 0;
          var tm_zone = HEAPU32[tm + 40 >>> 2 >>> 0];
          var date = {
            tm_sec: HEAP32[tm >>> 2 >>> 0],
            tm_min: HEAP32[tm + 4 >>> 2 >>> 0],
            tm_hour: HEAP32[tm + 8 >>> 2 >>> 0],
            tm_mday: HEAP32[tm + 12 >>> 2 >>> 0],
            tm_mon: HEAP32[tm + 16 >>> 2 >>> 0],
            tm_year: HEAP32[tm + 20 >>> 2 >>> 0],
            tm_wday: HEAP32[tm + 24 >>> 2 >>> 0],
            tm_yday: HEAP32[tm + 28 >>> 2 >>> 0],
            tm_isdst: HEAP32[tm + 32 >>> 2 >>> 0],
            tm_gmtoff: HEAP32[tm + 36 >>> 2 >>> 0],
            tm_zone: tm_zone ? UTF8ToString(tm_zone) : ""
          };
          var pattern = UTF8ToString(format);
          var EXPANSION_RULES_1 = {
            "%c": "%a %b %d %H:%M:%S %Y",
            "%D": "%m/%d/%y",
            "%F": "%Y-%m-%d",
            "%h": "%b",
            "%r": "%I:%M:%S %p",
            "%R": "%H:%M",
            "%T": "%H:%M:%S",
            "%x": "%m/%d/%y",
            "%X": "%H:%M:%S",
            "%Ec": "%c",
            "%EC": "%C",
            "%Ex": "%m/%d/%y",
            "%EX": "%H:%M:%S",
            "%Ey": "%y",
            "%EY": "%Y",
            "%Od": "%d",
            "%Oe": "%e",
            "%OH": "%H",
            "%OI": "%I",
            "%Om": "%m",
            "%OM": "%M",
            "%OS": "%S",
            "%Ou": "%u",
            "%OU": "%U",
            "%OV": "%V",
            "%Ow": "%w",
            "%OW": "%W",
            "%Oy": "%y"
          };
          for (var rule in EXPANSION_RULES_1) {
            pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_1[rule]);
          }
          var WEEKDAYS = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
          var MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
          function leadingSomething(value, digits, character) {
            var str = typeof value == "number" ? value.toString() : value || "";
            while (str.length < digits) {
              str = character[0] + str;
            }
            return str;
          }
          function leadingNulls(value, digits) {
            return leadingSomething(value, digits, "0");
          }
          function compareByDay(date1, date2) {
            function sgn(value) {
              return value < 0 ? -1 : value > 0 ? 1 : 0;
            }
            var compare;
            if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {
              if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {
                compare = sgn(date1.getDate() - date2.getDate());
              }
            }
            return compare;
          }
          function getFirstWeekStartDate(janFourth) {
            switch (janFourth.getDay()) {
              case 0:
                return new Date(janFourth.getFullYear() - 1, 11, 29);
              case 1:
                return janFourth;
              case 2:
                return new Date(janFourth.getFullYear(), 0, 3);
              case 3:
                return new Date(janFourth.getFullYear(), 0, 2);
              case 4:
                return new Date(janFourth.getFullYear(), 0, 1);
              case 5:
                return new Date(janFourth.getFullYear() - 1, 11, 31);
              case 6:
                return new Date(janFourth.getFullYear() - 1, 11, 30);
            }
          }
          function getWeekBasedYear(date2) {
            var thisDate = addDays(new Date(date2.tm_year + 1900, 0, 1), date2.tm_yday);
            var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);
            var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);
            var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
            var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
            if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {
              if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {
                return thisDate.getFullYear() + 1;
              }
              return thisDate.getFullYear();
            }
            return thisDate.getFullYear() - 1;
          }
          var EXPANSION_RULES_2 = {
            "%a": (date2) => WEEKDAYS[date2.tm_wday].substring(0, 3),
            "%A": (date2) => WEEKDAYS[date2.tm_wday],
            "%b": (date2) => MONTHS[date2.tm_mon].substring(0, 3),
            "%B": (date2) => MONTHS[date2.tm_mon],
            "%C": (date2) => {
              var year = date2.tm_year + 1900;
              return leadingNulls(year / 100 | 0, 2);
            },
            "%d": (date2) => leadingNulls(date2.tm_mday, 2),
            "%e": (date2) => leadingSomething(date2.tm_mday, 2, " "),
            "%g": (date2) => getWeekBasedYear(date2).toString().substring(2),
            "%G": getWeekBasedYear,
            "%H": (date2) => leadingNulls(date2.tm_hour, 2),
            "%I": (date2) => {
              var twelveHour = date2.tm_hour;
              if (twelveHour == 0)
                twelveHour = 12;
              else if (twelveHour > 12)
                twelveHour -= 12;
              return leadingNulls(twelveHour, 2);
            },
            "%j": (date2) => leadingNulls(date2.tm_mday + arraySum(isLeapYear(date2.tm_year + 1900) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, date2.tm_mon - 1), 3),
            "%m": (date2) => leadingNulls(date2.tm_mon + 1, 2),
            "%M": (date2) => leadingNulls(date2.tm_min, 2),
            "%n": () => "\n",
            "%p": (date2) => {
              if (date2.tm_hour >= 0 && date2.tm_hour < 12) {
                return "AM";
              }
              return "PM";
            },
            "%S": (date2) => leadingNulls(date2.tm_sec, 2),
            "%t": () => "	",
            "%u": (date2) => date2.tm_wday || 7,
            "%U": (date2) => {
              var days = date2.tm_yday + 7 - date2.tm_wday;
              return leadingNulls(Math.floor(days / 7), 2);
            },
            "%V": (date2) => {
              var val = Math.floor((date2.tm_yday + 7 - (date2.tm_wday + 6) % 7) / 7);
              if ((date2.tm_wday + 371 - date2.tm_yday - 2) % 7 <= 2) {
                val++;
              }
              if (!val) {
                val = 52;
                var dec31 = (date2.tm_wday + 7 - date2.tm_yday - 1) % 7;
                if (dec31 == 4 || dec31 == 5 && isLeapYear(date2.tm_year % 400 - 1)) {
                  val++;
                }
              } else if (val == 53) {
                var jan1 = (date2.tm_wday + 371 - date2.tm_yday) % 7;
                if (jan1 != 4 && (jan1 != 3 || !isLeapYear(date2.tm_year)))
                  val = 1;
              }
              return leadingNulls(val, 2);
            },
            "%w": (date2) => date2.tm_wday,
            "%W": (date2) => {
              var days = date2.tm_yday + 7 - (date2.tm_wday + 6) % 7;
              return leadingNulls(Math.floor(days / 7), 2);
            },
            "%y": (date2) => (date2.tm_year + 1900).toString().substring(2),
            "%Y": (date2) => date2.tm_year + 1900,
            "%z": (date2) => {
              var off = date2.tm_gmtoff;
              var ahead = off >= 0;
              off = Math.abs(off) / 60;
              off = off / 60 * 100 + off % 60;
              return (ahead ? "+" : "-") + String("0000" + off).slice(-4);
            },
            "%Z": (date2) => date2.tm_zone,
            "%%": () => "%"
          };
          pattern = pattern.replace(/%%/g, "\0\0");
          for (var rule in EXPANSION_RULES_2) {
            if (pattern.includes(rule)) {
              pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_2[rule](date));
            }
          }
          pattern = pattern.replace(/\0\0/g, "%");
          var bytes = intArrayFromString(pattern, false);
          if (bytes.length > maxsize) {
            return 0;
          }
          writeArrayToMemory(bytes, s2);
          return bytes.length - 1;
        }
        _strftime.sig = "ppppp";
        function _strftime_l(s2, maxsize, format, tm, loc) {
          s2 >>>= 0;
          maxsize >>>= 0;
          format >>>= 0;
          tm >>>= 0;
          loc >>>= 0;
          return _strftime(s2, maxsize, format, tm);
        }
        _strftime_l.sig = "pppppp";
        function _strptime(buf, format, tm) {
          buf >>>= 0;
          format >>>= 0;
          tm >>>= 0;
          var pattern = UTF8ToString(format);
          var SPECIAL_CHARS = "\\!@#$^&*()+=-[]/{}|:<>?,.";
          for (var i2 = 0, ii = SPECIAL_CHARS.length; i2 < ii; ++i2) {
            pattern = pattern.replace(new RegExp("\\" + SPECIAL_CHARS[i2], "g"), "\\" + SPECIAL_CHARS[i2]);
          }
          var EQUIVALENT_MATCHERS = {
            "A": "%a",
            "B": "%b",
            "c": "%a %b %d %H:%M:%S %Y",
            "D": "%m\\/%d\\/%y",
            "e": "%d",
            "F": "%Y-%m-%d",
            "h": "%b",
            "R": "%H\\:%M",
            "r": "%I\\:%M\\:%S\\s%p",
            "T": "%H\\:%M\\:%S",
            "x": "%m\\/%d\\/(?:%y|%Y)",
            "X": "%H\\:%M\\:%S"
          };
          var DATE_PATTERNS = {
            "a": "(?:Sun(?:day)?)|(?:Mon(?:day)?)|(?:Tue(?:sday)?)|(?:Wed(?:nesday)?)|(?:Thu(?:rsday)?)|(?:Fri(?:day)?)|(?:Sat(?:urday)?)",
            "b": "(?:Jan(?:uary)?)|(?:Feb(?:ruary)?)|(?:Mar(?:ch)?)|(?:Apr(?:il)?)|May|(?:Jun(?:e)?)|(?:Jul(?:y)?)|(?:Aug(?:ust)?)|(?:Sep(?:tember)?)|(?:Oct(?:ober)?)|(?:Nov(?:ember)?)|(?:Dec(?:ember)?)",
            "C": "\\d\\d",
            "d": "0[1-9]|[1-9](?!\\d)|1\\d|2\\d|30|31",
            "H": "\\d(?!\\d)|[0,1]\\d|20|21|22|23",
            "I": "\\d(?!\\d)|0\\d|10|11|12",
            "j": "00[1-9]|0?[1-9](?!\\d)|0?[1-9]\\d(?!\\d)|[1,2]\\d\\d|3[0-6]\\d",
            "m": "0[1-9]|[1-9](?!\\d)|10|11|12",
            "M": "0\\d|\\d(?!\\d)|[1-5]\\d",
            "n": " ",
            "p": "AM|am|PM|pm|A\\.M\\.|a\\.m\\.|P\\.M\\.|p\\.m\\.",
            "S": "0\\d|\\d(?!\\d)|[1-5]\\d|60",
            "U": "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
            "W": "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
            "w": "[0-6]",
            "y": "\\d\\d",
            "Y": "\\d\\d\\d\\d",
            "t": " ",
            "z": "Z|(?:[\\+\\-]\\d\\d:?(?:\\d\\d)?)"
          };
          var MONTH_NUMBERS = {
            JAN: 0,
            FEB: 1,
            MAR: 2,
            APR: 3,
            MAY: 4,
            JUN: 5,
            JUL: 6,
            AUG: 7,
            SEP: 8,
            OCT: 9,
            NOV: 10,
            DEC: 11
          };
          var DAY_NUMBERS_SUN_FIRST = {
            SUN: 0,
            MON: 1,
            TUE: 2,
            WED: 3,
            THU: 4,
            FRI: 5,
            SAT: 6
          };
          var DAY_NUMBERS_MON_FIRST = {
            MON: 0,
            TUE: 1,
            WED: 2,
            THU: 3,
            FRI: 4,
            SAT: 5,
            SUN: 6
          };
          var capture = [];
          var pattern_out = pattern.replace(/%(.)/g, (m, c) => EQUIVALENT_MATCHERS[c] || m).replace(/%(.)/g, (_, c) => {
            let pat = DATE_PATTERNS[c];
            if (pat) {
              capture.push(c);
              return `(${pat})`;
            } else {
              return c;
            }
          }).replace(/\s+/g, "\\s*");
          var matches = new RegExp("^" + pattern_out, "i").exec(UTF8ToString(buf));
          function initDate() {
            function fixup(value2, min, max) {
              return typeof value2 != "number" || isNaN(value2) ? min : value2 >= min ? value2 <= max ? value2 : max : min;
            }
            return {
              year: fixup(HEAP32[tm + 20 >>> 2 >>> 0] + 1900, 1970, 9999),
              month: fixup(HEAP32[tm + 16 >>> 2 >>> 0], 0, 11),
              day: fixup(HEAP32[tm + 12 >>> 2 >>> 0], 1, 31),
              hour: fixup(HEAP32[tm + 8 >>> 2 >>> 0], 0, 23),
              min: fixup(HEAP32[tm + 4 >>> 2 >>> 0], 0, 59),
              sec: fixup(HEAP32[tm >>> 2 >>> 0], 0, 59),
              gmtoff: 0
            };
          }
          if (matches) {
            var date = initDate();
            var value;
            var getMatch = (symbol) => {
              var pos = capture.indexOf(symbol);
              if (pos >= 0) {
                return matches[pos + 1];
              }
              return;
            };
            if (value = getMatch("S")) {
              date.sec = jstoi_q(value);
            }
            if (value = getMatch("M")) {
              date.min = jstoi_q(value);
            }
            if (value = getMatch("H")) {
              date.hour = jstoi_q(value);
            } else if (value = getMatch("I")) {
              var hour = jstoi_q(value);
              if (value = getMatch("p")) {
                hour += value.toUpperCase()[0] === "P" ? 12 : 0;
              }
              date.hour = hour;
            }
            if (value = getMatch("Y")) {
              date.year = jstoi_q(value);
            } else if (value = getMatch("y")) {
              var year = jstoi_q(value);
              if (value = getMatch("C")) {
                year += jstoi_q(value) * 100;
              } else {
                year += year < 69 ? 2e3 : 1900;
              }
              date.year = year;
            }
            if (value = getMatch("m")) {
              date.month = jstoi_q(value) - 1;
            } else if (value = getMatch("b")) {
              date.month = MONTH_NUMBERS[value.substring(0, 3).toUpperCase()] || 0;
            }
            if (value = getMatch("d")) {
              date.day = jstoi_q(value);
            } else if (value = getMatch("j")) {
              var day = jstoi_q(value);
              var leapYear = isLeapYear(date.year);
              for (var month = 0; month < 12; ++month) {
                var daysUntilMonth = arraySum(leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, month - 1);
                if (day <= daysUntilMonth + (leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[month]) {
                  date.day = day - daysUntilMonth;
                }
              }
            } else if (value = getMatch("a")) {
              var weekDay = value.substring(0, 3).toUpperCase();
              if (value = getMatch("U")) {
                var weekDayNumber = DAY_NUMBERS_SUN_FIRST[weekDay];
                var weekNumber = jstoi_q(value);
                var janFirst = new Date(date.year, 0, 1);
                var endDate;
                if (janFirst.getDay() === 0) {
                  endDate = addDays(janFirst, weekDayNumber + 7 * (weekNumber - 1));
                } else {
                  endDate = addDays(janFirst, 7 - janFirst.getDay() + weekDayNumber + 7 * (weekNumber - 1));
                }
                date.day = endDate.getDate();
                date.month = endDate.getMonth();
              } else if (value = getMatch("W")) {
                var weekDayNumber = DAY_NUMBERS_MON_FIRST[weekDay];
                var weekNumber = jstoi_q(value);
                var janFirst = new Date(date.year, 0, 1);
                var endDate;
                if (janFirst.getDay() === 1) {
                  endDate = addDays(janFirst, weekDayNumber + 7 * (weekNumber - 1));
                } else {
                  endDate = addDays(janFirst, 7 - janFirst.getDay() + 1 + weekDayNumber + 7 * (weekNumber - 1));
                }
                date.day = endDate.getDate();
                date.month = endDate.getMonth();
              }
            }
            if (value = getMatch("z")) {
              if (value.toLowerCase() === "z") {
                date.gmtoff = 0;
              } else {
                var match = value.match(/^((?:\-|\+)\d\d):?(\d\d)?/);
                date.gmtoff = match[1] * 3600;
                if (match[2]) {
                  date.gmtoff += date.gmtoff > 0 ? match[2] * 60 : -match[2] * 60;
                }
              }
            }
            var fullDate = new Date(date.year, date.month, date.day, date.hour, date.min, date.sec, 0);
            HEAP32[tm >>> 2 >>> 0] = fullDate.getSeconds();
            HEAP32[tm + 4 >>> 2 >>> 0] = fullDate.getMinutes();
            HEAP32[tm + 8 >>> 2 >>> 0] = fullDate.getHours();
            HEAP32[tm + 12 >>> 2 >>> 0] = fullDate.getDate();
            HEAP32[tm + 16 >>> 2 >>> 0] = fullDate.getMonth();
            HEAP32[tm + 20 >>> 2 >>> 0] = fullDate.getFullYear() - 1900;
            HEAP32[tm + 24 >>> 2 >>> 0] = fullDate.getDay();
            HEAP32[tm + 28 >>> 2 >>> 0] = arraySum(isLeapYear(fullDate.getFullYear()) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, fullDate.getMonth() - 1) + fullDate.getDate() - 1;
            HEAP32[tm + 32 >>> 2 >>> 0] = 0;
            HEAP32[tm + 36 >>> 2 >>> 0] = date.gmtoff;
            return buf + intArrayFromString(matches[0]).length - 1;
          }
          return 0;
        }
        _strptime.sig = "pppp";
        var getCFunc = (ident) => {
          var func2 = Module["_" + ident];
          return func2;
        };
        var ccall = (ident, returnType, argTypes, args2, opts) => {
          var toC = {
            "string": (str) => {
              var ret2 = 0;
              if (str !== null && str !== void 0 && str !== 0) {
                ret2 = stringToUTF8OnStack(str);
              }
              return ret2;
            },
            "array": (arr) => {
              var ret2 = stackAlloc(arr.length);
              writeArrayToMemory(arr, ret2);
              return ret2;
            }
          };
          function convertReturnValue(ret2) {
            if (returnType === "string") {
              return UTF8ToString(ret2);
            }
            if (returnType === "boolean")
              return Boolean(ret2);
            return ret2;
          }
          var func2 = getCFunc(ident);
          var cArgs = [];
          var stack = 0;
          if (args2) {
            for (var i2 = 0; i2 < args2.length; i2++) {
              var converter = toC[argTypes[i2]];
              if (converter) {
                if (stack === 0)
                  stack = stackSave();
                cArgs[i2] = converter(args2[i2]);
              } else {
                cArgs[i2] = args2[i2];
              }
            }
          }
          var ret = func2.apply(null, cArgs);
          function onDone(ret2) {
            if (stack !== 0)
              stackRestore(stack);
            return convertReturnValue(ret2);
          }
          ret = onDone(ret);
          return ret;
        };
        var writeI53ToI64Clamped = (ptr2, num) => {
          if (num > 9223372036854776e3) {
            HEAPU32[ptr2 >>> 2 >>> 0] = 4294967295;
            HEAPU32[ptr2 + 4 >>> 2 >>> 0] = 2147483647;
          } else if (num < -9223372036854776e3) {
            HEAPU32[ptr2 >>> 2 >>> 0] = 0;
            HEAPU32[ptr2 + 4 >>> 2 >>> 0] = 2147483648;
          } else {
            writeI53ToI64(ptr2, num);
          }
        };
        var writeI53ToI64Signaling = (ptr2, num) => {
          if (num > 9223372036854776e3 || num < -9223372036854776e3) {
            throw `RangeError: ${num}`;
          }
          writeI53ToI64(ptr2, num);
        };
        var writeI53ToU64Clamped = (ptr2, num) => {
          if (num > 18446744073709552e3) {
            HEAPU32[ptr2 >>> 2 >>> 0] = 4294967295;
            HEAPU32[ptr2 + 4 >>> 2 >>> 0] = 4294967295;
          } else if (num < 0) {
            HEAPU32[ptr2 >>> 2 >>> 0] = 0;
            HEAPU32[ptr2 + 4 >>> 2 >>> 0] = 0;
          } else {
            writeI53ToI64(ptr2, num);
          }
        };
        var writeI53ToU64Signaling = (ptr2, num) => {
          if (num < 0 || num > 18446744073709552e3) {
            throw `RangeError: ${num}`;
          }
          writeI53ToI64(ptr2, num);
        };
        var readI53FromU64 = (ptr2) => HEAPU32[ptr2 >>> 2 >>> 0] + HEAPU32[ptr2 + 4 >>> 2 >>> 0] * 4294967296;
        var convertI32PairToI53 = (lo, hi) => (lo >>> 0) + hi * 4294967296;
        var convertU32PairToI53 = (lo, hi) => (lo >>> 0) + (hi >>> 0) * 4294967296;
        var ptrToString = (ptr2) => "0x" + ptr2.toString(16).padStart(8, "0");
        function _emscripten_notify_memory_growth(memoryIndex) {
          memoryIndex >>>= 0;
          updateMemoryViews();
        }
        _emscripten_notify_memory_growth.sig = "vp";
        function ___asctime_r(tmPtr, buf) {
          tmPtr >>>= 0;
          buf >>>= 0;
          var date = {
            tm_sec: HEAP32[tmPtr >>> 2 >>> 0],
            tm_min: HEAP32[tmPtr + 4 >>> 2 >>> 0],
            tm_hour: HEAP32[tmPtr + 8 >>> 2 >>> 0],
            tm_mday: HEAP32[tmPtr + 12 >>> 2 >>> 0],
            tm_mon: HEAP32[tmPtr + 16 >>> 2 >>> 0],
            tm_year: HEAP32[tmPtr + 20 >>> 2 >>> 0],
            tm_wday: HEAP32[tmPtr + 24 >>> 2 >>> 0]
          };
          var days = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
          var months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
          var s2 = days[date.tm_wday] + " " + months[date.tm_mon] + (date.tm_mday < 10 ? "  " : " ") + date.tm_mday + (date.tm_hour < 10 ? " 0" : " ") + date.tm_hour + (date.tm_min < 10 ? ":0" : ":") + date.tm_min + (date.tm_sec < 10 ? ":0" : ":") + date.tm_sec + " " + (1900 + date.tm_year) + "\n";
          stringToUTF8(s2, buf, 26);
          return buf;
        }
        ___asctime_r.sig = "ppp";
        function _strptime_l(buf, format, tm, locale) {
          buf >>>= 0;
          format >>>= 0;
          tm >>>= 0;
          locale >>>= 0;
          return _strptime(buf, format, tm);
        }
        _strptime_l.sig = "ppppp";
        var ERRNO_CODES = {
          "EPERM": 63,
          "ENOENT": 44,
          "ESRCH": 71,
          "EINTR": 27,
          "EIO": 29,
          "ENXIO": 60,
          "E2BIG": 1,
          "ENOEXEC": 45,
          "EBADF": 8,
          "ECHILD": 12,
          "EAGAIN": 6,
          "EWOULDBLOCK": 6,
          "ENOMEM": 48,
          "EACCES": 2,
          "EFAULT": 21,
          "ENOTBLK": 105,
          "EBUSY": 10,
          "EEXIST": 20,
          "EXDEV": 75,
          "ENODEV": 43,
          "ENOTDIR": 54,
          "EISDIR": 31,
          "EINVAL": 28,
          "ENFILE": 41,
          "EMFILE": 33,
          "ENOTTY": 59,
          "ETXTBSY": 74,
          "EFBIG": 22,
          "ENOSPC": 51,
          "ESPIPE": 70,
          "EROFS": 69,
          "EMLINK": 34,
          "EPIPE": 64,
          "EDOM": 18,
          "ERANGE": 68,
          "ENOMSG": 49,
          "EIDRM": 24,
          "ECHRNG": 106,
          "EL2NSYNC": 156,
          "EL3HLT": 107,
          "EL3RST": 108,
          "ELNRNG": 109,
          "EUNATCH": 110,
          "ENOCSI": 111,
          "EL2HLT": 112,
          "EDEADLK": 16,
          "ENOLCK": 46,
          "EBADE": 113,
          "EBADR": 114,
          "EXFULL": 115,
          "ENOANO": 104,
          "EBADRQC": 103,
          "EBADSLT": 102,
          "EDEADLOCK": 16,
          "EBFONT": 101,
          "ENOSTR": 100,
          "ENODATA": 116,
          "ETIME": 117,
          "ENOSR": 118,
          "ENONET": 119,
          "ENOPKG": 120,
          "EREMOTE": 121,
          "ENOLINK": 47,
          "EADV": 122,
          "ESRMNT": 123,
          "ECOMM": 124,
          "EPROTO": 65,
          "EMULTIHOP": 36,
          "EDOTDOT": 125,
          "EBADMSG": 9,
          "ENOTUNIQ": 126,
          "EBADFD": 127,
          "EREMCHG": 128,
          "ELIBACC": 129,
          "ELIBBAD": 130,
          "ELIBSCN": 131,
          "ELIBMAX": 132,
          "ELIBEXEC": 133,
          "ENOSYS": 52,
          "ENOTEMPTY": 55,
          "ENAMETOOLONG": 37,
          "ELOOP": 32,
          "EOPNOTSUPP": 138,
          "EPFNOSUPPORT": 139,
          "ECONNRESET": 15,
          "ENOBUFS": 42,
          "EAFNOSUPPORT": 5,
          "EPROTOTYPE": 67,
          "ENOTSOCK": 57,
          "ENOPROTOOPT": 50,
          "ESHUTDOWN": 140,
          "ECONNREFUSED": 14,
          "EADDRINUSE": 3,
          "ECONNABORTED": 13,
          "ENETUNREACH": 40,
          "ENETDOWN": 38,
          "ETIMEDOUT": 73,
          "EHOSTDOWN": 142,
          "EHOSTUNREACH": 23,
          "EINPROGRESS": 26,
          "EALREADY": 7,
          "EDESTADDRREQ": 17,
          "EMSGSIZE": 35,
          "EPROTONOSUPPORT": 66,
          "ESOCKTNOSUPPORT": 137,
          "EADDRNOTAVAIL": 4,
          "ENETRESET": 39,
          "EISCONN": 30,
          "ENOTCONN": 53,
          "ETOOMANYREFS": 141,
          "EUSERS": 136,
          "EDQUOT": 19,
          "ESTALE": 72,
          "ENOTSUP": 138,
          "ENOMEDIUM": 148,
          "EILSEQ": 25,
          "EOVERFLOW": 61,
          "ECANCELED": 11,
          "ENOTRECOVERABLE": 56,
          "EOWNERDEAD": 62,
          "ESTRPIPE": 135
        };
        var ERRNO_MESSAGES = {
          0: "Success",
          1: "Arg list too long",
          2: "Permission denied",
          3: "Address already in use",
          4: "Address not available",
          5: "Address family not supported by protocol family",
          6: "No more processes",
          7: "Socket already connected",
          8: "Bad file number",
          9: "Trying to read unreadable message",
          10: "Mount device busy",
          11: "Operation canceled",
          12: "No children",
          13: "Connection aborted",
          14: "Connection refused",
          15: "Connection reset by peer",
          16: "File locking deadlock error",
          17: "Destination address required",
          18: "Math arg out of domain of func",
          19: "Quota exceeded",
          20: "File exists",
          21: "Bad address",
          22: "File too large",
          23: "Host is unreachable",
          24: "Identifier removed",
          25: "Illegal byte sequence",
          26: "Connection already in progress",
          27: "Interrupted system call",
          28: "Invalid argument",
          29: "I/O error",
          30: "Socket is already connected",
          31: "Is a directory",
          32: "Too many symbolic links",
          33: "Too many open files",
          34: "Too many links",
          35: "Message too long",
          36: "Multihop attempted",
          37: "File or path name too long",
          38: "Network interface is not configured",
          39: "Connection reset by network",
          40: "Network is unreachable",
          41: "Too many open files in system",
          42: "No buffer space available",
          43: "No such device",
          44: "No such file or directory",
          45: "Exec format error",
          46: "No record locks available",
          47: "The link has been severed",
          48: "Not enough core",
          49: "No message of desired type",
          50: "Protocol not available",
          51: "No space left on device",
          52: "Function not implemented",
          53: "Socket is not connected",
          54: "Not a directory",
          55: "Directory not empty",
          56: "State not recoverable",
          57: "Socket operation on non-socket",
          59: "Not a typewriter",
          60: "No such device or address",
          61: "Value too large for defined data type",
          62: "Previous owner died",
          63: "Not super-user",
          64: "Broken pipe",
          65: "Protocol error",
          66: "Unknown protocol",
          67: "Protocol wrong type for socket",
          68: "Math result not representable",
          69: "Read only file system",
          70: "Illegal seek",
          71: "No such process",
          72: "Stale file handle",
          73: "Connection timed out",
          74: "Text file busy",
          75: "Cross-device link",
          100: "Device not a stream",
          101: "Bad font file fmt",
          102: "Invalid slot",
          103: "Invalid request code",
          104: "No anode",
          105: "Block device required",
          106: "Channel number out of range",
          107: "Level 3 halted",
          108: "Level 3 reset",
          109: "Link number out of range",
          110: "Protocol driver not attached",
          111: "No CSI structure available",
          112: "Level 2 halted",
          113: "Invalid exchange",
          114: "Invalid request descriptor",
          115: "Exchange full",
          116: "No data (for no delay io)",
          117: "Timer expired",
          118: "Out of streams resources",
          119: "Machine is not on the network",
          120: "Package not installed",
          121: "The object is remote",
          122: "Advertise error",
          123: "Srmount error",
          124: "Communication error on send",
          125: "Cross mount point (not really error)",
          126: "Given log. name not unique",
          127: "f.d. invalid for this operation",
          128: "Remote address changed",
          129: "Can   access a needed shared lib",
          130: "Accessing a corrupted shared lib",
          131: ".lib section in a.out corrupted",
          132: "Attempting to link in too many libs",
          133: "Attempting to exec a shared library",
          135: "Streams pipe error",
          136: "Too many users",
          137: "Socket type not supported",
          138: "Not supported",
          139: "Protocol family not supported",
          140: "Can't send after socket shutdown",
          141: "Too many references",
          142: "Host is down",
          148: "No medium (in tape drive)",
          156: "Level 2 not synchronized"
        };
        var Protocols = {
          list: [],
          map: {}
        };
        var _setprotoent = (stayopen) => {
          function allocprotoent(name2, proto, aliases) {
            var nameBuf = _malloc(name2.length + 1);
            stringToAscii(name2, nameBuf);
            var j = 0;
            var length = aliases.length;
            var aliasListBuf = _malloc((length + 1) * 4);
            for (var i2 = 0; i2 < length; i2++, j += 4) {
              var alias = aliases[i2];
              var aliasBuf = _malloc(alias.length + 1);
              stringToAscii(alias, aliasBuf);
              HEAPU32[aliasListBuf + j >>> 2 >>> 0] = aliasBuf;
            }
            HEAPU32[aliasListBuf + j >>> 2 >>> 0] = 0;
            var pe = _malloc(12);
            HEAPU32[pe >>> 2 >>> 0] = nameBuf;
            HEAPU32[pe + 4 >>> 2 >>> 0] = aliasListBuf;
            HEAP32[pe + 8 >>> 2 >>> 0] = proto;
            return pe;
          }
          var list = Protocols.list;
          var map = Protocols.map;
          if (list.length === 0) {
            var entry = allocprotoent("tcp", 6, ["TCP"]);
            list.push(entry);
            map["tcp"] = map["6"] = entry;
            entry = allocprotoent("udp", 17, ["UDP"]);
            list.push(entry);
            map["udp"] = map["17"] = entry;
          }
          _setprotoent.index = 0;
        };
        _setprotoent.sig = "vi";
        var _endprotoent = () => {
        };
        _endprotoent.sig = "v";
        function _getprotoent(number) {
          if (_setprotoent.index === Protocols.list.length) {
            return 0;
          }
          var result = Protocols.list[_setprotoent.index++];
          return result;
        }
        _getprotoent.sig = "p";
        function _getprotobyname(name2) {
          name2 >>>= 0;
          name2 = UTF8ToString(name2);
          _setprotoent(true);
          var result = Protocols.map[name2];
          return result;
        }
        _getprotobyname.sig = "pp";
        function _getprotobynumber(number) {
          _setprotoent(true);
          var result = Protocols.map[number];
          return result;
        }
        _getprotobynumber.sig = "pi";
        function _emscripten_run_script(ptr) {
          ptr >>>= 0;
          eval(UTF8ToString(ptr));
        }
        _emscripten_run_script.sig = "vp";
        function _emscripten_run_script_int(ptr) {
          ptr >>>= 0;
          return eval(UTF8ToString(ptr)) | 0;
        }
        _emscripten_run_script_int.sig = "ip";
        function _emscripten_run_script_string(ptr) {
          ptr >>>= 0;
          var s = eval(UTF8ToString(ptr));
          if (s == null) {
            return 0;
          }
          s += "";
          var me = _emscripten_run_script_string;
          var len = lengthBytesUTF8(s);
          if (!me.bufferSize || me.bufferSize < len + 1) {
            if (me.bufferSize)
              _free(me.buffer);
            me.bufferSize = len + 1;
            me.buffer = _malloc(me.bufferSize);
          }
          stringToUTF8(s, me.buffer, me.bufferSize);
          return me.buffer;
        }
        _emscripten_run_script_string.sig = "pp";
        var _emscripten_random = () => Math.random();
        _emscripten_random.sig = "f";
        function jsStackTrace() {
          var error = new Error();
          if (!error.stack) {
            try {
              throw new Error();
            } catch (e) {
              error = e;
            }
            if (!error.stack) {
              return "(no stack trace available)";
            }
          }
          return error.stack.toString();
        }
        function getCallstack(flags2) {
          var callstack = jsStackTrace();
          var iThisFunc = callstack.lastIndexOf("_emscripten_log");
          var iThisFunc2 = callstack.lastIndexOf("_emscripten_get_callstack");
          var iNextLine = callstack.indexOf("\n", Math.max(iThisFunc, iThisFunc2)) + 1;
          callstack = callstack.slice(iNextLine);
          if (flags2 & 8 && typeof emscripten_source_map == "undefined") {
            warnOnce('Source map information is not available, emscripten_log with EM_LOG_C_STACK will be ignored. Build with "--pre-js $EMSCRIPTEN/src/emscripten-source-map.min.js" linker flag to add source map loading to code.');
            flags2 ^= 8;
            flags2 |= 16;
          }
          var lines = callstack.split("\n");
          callstack = "";
          var newFirefoxRe = new RegExp("\\s*(.*?)@(.*?):([0-9]+):([0-9]+)");
          var firefoxRe = new RegExp("\\s*(.*?)@(.*):(.*)(:(.*))?");
          var chromeRe = new RegExp("\\s*at (.*?) \\((.*):(.*):(.*)\\)");
          for (var l in lines) {
            var line = lines[l];
            var symbolName = "";
            var file = "";
            var lineno = 0;
            var column = 0;
            var parts2 = chromeRe.exec(line);
            if (parts2 && parts2.length == 5) {
              symbolName = parts2[1];
              file = parts2[2];
              lineno = parts2[3];
              column = parts2[4];
            } else {
              parts2 = newFirefoxRe.exec(line);
              if (!parts2)
                parts2 = firefoxRe.exec(line);
              if (parts2 && parts2.length >= 4) {
                symbolName = parts2[1];
                file = parts2[2];
                lineno = parts2[3];
                column = parts2[4] | 0;
              } else {
                callstack += line + "\n";
                continue;
              }
            }
            var haveSourceMap = false;
            if (flags2 & 8) {
              var orig = emscripten_source_map.originalPositionFor({
                line: lineno,
                column
              });
              haveSourceMap = orig == null ? void 0 : orig.source;
              if (haveSourceMap) {
                if (flags2 & 64) {
                  orig.source = orig.source.substring(orig.source.replace(/\\/g, "/").lastIndexOf("/") + 1);
                }
                callstack += `    at ${symbolName} (${orig.source}:${orig.line}:${orig.column})
`;
              }
            }
            if (flags2 & 16 || !haveSourceMap) {
              if (flags2 & 64) {
                file = file.substring(file.replace(/\\/g, "/").lastIndexOf("/") + 1);
              }
              callstack += (haveSourceMap ? `     = ${symbolName}` : `    at ${symbolName}`) + ` (${file}:${lineno}:${column})
`;
            }
          }
          callstack = callstack.replace(/\s+$/, "");
          return callstack;
        }
        function _emscripten_get_callstack(flags2, str, maxbytes) {
          str >>>= 0;
          var callstack = getCallstack(flags2);
          if (!str || maxbytes <= 0) {
            return lengthBytesUTF8(callstack) + 1;
          }
          var bytesWrittenExcludingNull = stringToUTF8(callstack, str, maxbytes);
          return bytesWrittenExcludingNull + 1;
        }
        _emscripten_get_callstack.sig = "iipi";
        var emscriptenLog = (flags2, str) => {
          if (flags2 & 24) {
            str = str.replace(/\s+$/, "");
            str += (str.length > 0 ? "\n" : "") + getCallstack(flags2);
          }
          if (flags2 & 1) {
            if (flags2 & 4) {
              console.error(str);
            } else if (flags2 & 2) {
              console.warn(str);
            } else if (flags2 & 512) {
              console.info(str);
            } else if (flags2 & 256) {
              console.debug(str);
            } else {
              console.log(str);
            }
          } else if (flags2 & 6) {
            err(str);
          } else {
            out(str);
          }
        };
        var reallyNegative = (x) => x < 0 || x === 0 && 1 / x === -Infinity;
        var reSign = (value, bits) => {
          if (value <= 0) {
            return value;
          }
          var half = bits <= 32 ? Math.abs(1 << bits - 1) : Math.pow(2, bits - 1);
          if (value >= half && (bits <= 32 || value > half)) {
            value = -2 * half + value;
          }
          return value;
        };
        var unSign = (value, bits) => {
          if (value >= 0) {
            return value;
          }
          return bits <= 32 ? 2 * Math.abs(1 << bits - 1) + value : Math.pow(2, bits) + value;
        };
        var strLen = (ptr2) => {
          var end = ptr2;
          while (HEAPU8[end >>> 0])
            ++end;
          return end - ptr2;
        };
        var formatString = (format, varargs) => {
          var textIndex = format;
          var argIndex = varargs;
          function prepVararg(ptr3, type) {
            if (type === "double" || type === "i64") {
              if (ptr3 & 7) {
                ptr3 += 4;
              }
            } else {
            }
            return ptr3;
          }
          function getNextArg(type) {
            var ret2;
            argIndex = prepVararg(argIndex, type);
            if (type === "double") {
              ret2 = HEAPF64[argIndex >>> 3 >>> 0];
              argIndex += 8;
            } else if (type == "i64") {
              ret2 = [HEAP32[argIndex >>> 2 >>> 0], HEAP32[argIndex + 4 >>> 2 >>> 0]];
              argIndex += 8;
            } else {
              type = "i32";
              ret2 = HEAP32[argIndex >>> 2 >>> 0];
              argIndex += 4;
            }
            return ret2;
          }
          var ret = [];
          var curr, next, currArg;
          while (1) {
            var startTextIndex = textIndex;
            curr = HEAP8[textIndex >>> 0 >>> 0];
            if (curr === 0)
              break;
            next = HEAP8[textIndex + 1 >>> 0 >>> 0];
            if (curr == 37) {
              var flagAlwaysSigned = false;
              var flagLeftAlign = false;
              var flagAlternative = false;
              var flagZeroPad = false;
              var flagPadSign = false;
              flagsLoop:
                while (1) {
                  switch (next) {
                    case 43:
                      flagAlwaysSigned = true;
                      break;
                    case 45:
                      flagLeftAlign = true;
                      break;
                    case 35:
                      flagAlternative = true;
                      break;
                    case 48:
                      if (flagZeroPad) {
                        break flagsLoop;
                      } else {
                        flagZeroPad = true;
                        break;
                      }
                    case 32:
                      flagPadSign = true;
                      break;
                    default:
                      break flagsLoop;
                  }
                  textIndex++;
                  next = HEAP8[textIndex + 1 >>> 0 >>> 0];
                }
              var width = 0;
              if (next == 42) {
                width = getNextArg("i32");
                textIndex++;
                next = HEAP8[textIndex + 1 >>> 0 >>> 0];
              } else {
                while (next >= 48 && next <= 57) {
                  width = width * 10 + (next - 48);
                  textIndex++;
                  next = HEAP8[textIndex + 1 >>> 0 >>> 0];
                }
              }
              var precisionSet = false, precision = -1;
              if (next == 46) {
                precision = 0;
                precisionSet = true;
                textIndex++;
                next = HEAP8[textIndex + 1 >>> 0 >>> 0];
                if (next == 42) {
                  precision = getNextArg("i32");
                  textIndex++;
                } else {
                  while (1) {
                    var precisionChr = HEAP8[textIndex + 1 >>> 0 >>> 0];
                    if (precisionChr < 48 || precisionChr > 57)
                      break;
                    precision = precision * 10 + (precisionChr - 48);
                    textIndex++;
                  }
                }
                next = HEAP8[textIndex + 1 >>> 0 >>> 0];
              }
              if (precision < 0) {
                precision = 6;
                precisionSet = false;
              }
              var argSize;
              switch (String.fromCharCode(next)) {
                case "h":
                  var nextNext = HEAP8[textIndex + 2 >>> 0 >>> 0];
                  if (nextNext == 104) {
                    textIndex++;
                    argSize = 1;
                  } else {
                    argSize = 2;
                  }
                  break;
                case "l":
                  var nextNext = HEAP8[textIndex + 2 >>> 0 >>> 0];
                  if (nextNext == 108) {
                    textIndex++;
                    argSize = 8;
                  } else {
                    argSize = 4;
                  }
                  break;
                case "L":
                case "q":
                case "j":
                  argSize = 8;
                  break;
                case "z":
                case "t":
                case "I":
                  argSize = 4;
                  break;
                default:
                  argSize = null;
              }
              if (argSize)
                textIndex++;
              next = HEAP8[textIndex + 1 >>> 0 >>> 0];
              switch (String.fromCharCode(next)) {
                case "d":
                case "i":
                case "u":
                case "o":
                case "x":
                case "X":
                case "p": {
                  var signed = next == 100 || next == 105;
                  argSize = argSize || 4;
                  currArg = getNextArg("i" + argSize * 8);
                  var argText;
                  if (argSize == 8) {
                    currArg = next == 117 ? convertU32PairToI53(currArg[0], currArg[1]) : convertI32PairToI53(currArg[0], currArg[1]);
                  }
                  if (argSize <= 4) {
                    var limit = Math.pow(256, argSize) - 1;
                    currArg = (signed ? reSign : unSign)(currArg & limit, argSize * 8);
                  }
                  var currAbsArg = Math.abs(currArg);
                  var prefix = "";
                  if (next == 100 || next == 105) {
                    argText = reSign(currArg, 8 * argSize).toString(10);
                  } else if (next == 117) {
                    argText = unSign(currArg, 8 * argSize).toString(10);
                    currArg = Math.abs(currArg);
                  } else if (next == 111) {
                    argText = (flagAlternative ? "0" : "") + currAbsArg.toString(8);
                  } else if (next == 120 || next == 88) {
                    prefix = flagAlternative && currArg != 0 ? "0x" : "";
                    if (currArg < 0) {
                      currArg = -currArg;
                      argText = (currAbsArg - 1).toString(16);
                      var buffer = [];
                      for (var i2 = 0; i2 < argText.length; i2++) {
                        buffer.push((15 - parseInt(argText[i2], 16)).toString(16));
                      }
                      argText = buffer.join("");
                      while (argText.length < argSize * 2)
                        argText = "f" + argText;
                    } else {
                      argText = currAbsArg.toString(16);
                    }
                    if (next == 88) {
                      prefix = prefix.toUpperCase();
                      argText = argText.toUpperCase();
                    }
                  } else if (next == 112) {
                    if (currAbsArg === 0) {
                      argText = "(nil)";
                    } else {
                      prefix = "0x";
                      argText = currAbsArg.toString(16);
                    }
                  }
                  if (precisionSet) {
                    while (argText.length < precision) {
                      argText = "0" + argText;
                    }
                  }
                  if (currArg >= 0) {
                    if (flagAlwaysSigned) {
                      prefix = "+" + prefix;
                    } else if (flagPadSign) {
                      prefix = " " + prefix;
                    }
                  }
                  if (argText.charAt(0) == "-") {
                    prefix = "-" + prefix;
                    argText = argText.substr(1);
                  }
                  while (prefix.length + argText.length < width) {
                    if (flagLeftAlign) {
                      argText += " ";
                    } else {
                      if (flagZeroPad) {
                        argText = "0" + argText;
                      } else {
                        prefix = " " + prefix;
                      }
                    }
                  }
                  argText = prefix + argText;
                  argText.split("").forEach(function(chr) {
                    ret.push(chr.charCodeAt(0));
                  });
                  break;
                }
                case "f":
                case "F":
                case "e":
                case "E":
                case "g":
                case "G": {
                  currArg = getNextArg("double");
                  var argText;
                  if (isNaN(currArg)) {
                    argText = "nan";
                    flagZeroPad = false;
                  } else if (!isFinite(currArg)) {
                    argText = (currArg < 0 ? "-" : "") + "inf";
                    flagZeroPad = false;
                  } else {
                    var isGeneral = false;
                    var effectivePrecision = Math.min(precision, 20);
                    if (next == 103 || next == 71) {
                      isGeneral = true;
                      precision = precision || 1;
                      var exponent = parseInt(currArg.toExponential(effectivePrecision).split("e")[1], 10);
                      if (precision > exponent && exponent >= -4) {
                        next = (next == 103 ? "f" : "F").charCodeAt(0);
                        precision -= exponent + 1;
                      } else {
                        next = (next == 103 ? "e" : "E").charCodeAt(0);
                        precision--;
                      }
                      effectivePrecision = Math.min(precision, 20);
                    }
                    if (next == 101 || next == 69) {
                      argText = currArg.toExponential(effectivePrecision);
                      if (/[eE][-+]\d$/.test(argText)) {
                        argText = argText.slice(0, -1) + "0" + argText.slice(-1);
                      }
                    } else if (next == 102 || next == 70) {
                      argText = currArg.toFixed(effectivePrecision);
                      if (currArg === 0 && reallyNegative(currArg)) {
                        argText = "-" + argText;
                      }
                    }
                    var parts2 = argText.split("e");
                    if (isGeneral && !flagAlternative) {
                      while (parts2[0].length > 1 && parts2[0].includes(".") && (parts2[0].slice(-1) == "0" || parts2[0].slice(-1) == ".")) {
                        parts2[0] = parts2[0].slice(0, -1);
                      }
                    } else {
                      if (flagAlternative && argText.indexOf(".") == -1)
                        parts2[0] += ".";
                      while (precision > effectivePrecision++)
                        parts2[0] += "0";
                    }
                    argText = parts2[0] + (parts2.length > 1 ? "e" + parts2[1] : "");
                    if (next == 69)
                      argText = argText.toUpperCase();
                    if (currArg >= 0) {
                      if (flagAlwaysSigned) {
                        argText = "+" + argText;
                      } else if (flagPadSign) {
                        argText = " " + argText;
                      }
                    }
                  }
                  while (argText.length < width) {
                    if (flagLeftAlign) {
                      argText += " ";
                    } else {
                      if (flagZeroPad && (argText[0] == "-" || argText[0] == "+")) {
                        argText = argText[0] + "0" + argText.slice(1);
                      } else {
                        argText = (flagZeroPad ? "0" : " ") + argText;
                      }
                    }
                  }
                  if (next < 97)
                    argText = argText.toUpperCase();
                  argText.split("").forEach(function(chr) {
                    ret.push(chr.charCodeAt(0));
                  });
                  break;
                }
                case "s": {
                  var arg = getNextArg("i8*");
                  var argLength = arg ? strLen(arg) : "(null)".length;
                  if (precisionSet)
                    argLength = Math.min(argLength, precision);
                  if (!flagLeftAlign) {
                    while (argLength < width--) {
                      ret.push(32);
                    }
                  }
                  if (arg) {
                    for (var i2 = 0; i2 < argLength; i2++) {
                      ret.push(HEAPU8[arg++ >>> 0 >>> 0]);
                    }
                  } else {
                    ret = ret.concat(intArrayFromString("(null)".substr(0, argLength), true));
                  }
                  if (flagLeftAlign) {
                    while (argLength < width--) {
                      ret.push(32);
                    }
                  }
                  break;
                }
                case "c": {
                  if (flagLeftAlign)
                    ret.push(getNextArg("i8"));
                  while (--width > 0) {
                    ret.push(32);
                  }
                  if (!flagLeftAlign)
                    ret.push(getNextArg("i8"));
                  break;
                }
                case "n": {
                  var ptr2 = getNextArg("i32*");
                  HEAP32[ptr2 >>> 2 >>> 0] = ret.length;
                  break;
                }
                case "%": {
                  ret.push(curr);
                  break;
                }
                default: {
                  for (var i2 = startTextIndex; i2 < textIndex + 2; i2++) {
                    ret.push(HEAP8[i2 >>> 0 >>> 0]);
                  }
                }
              }
              textIndex += 2;
            } else {
              ret.push(curr);
              textIndex += 1;
            }
          }
          return ret;
        };
        function _emscripten_log(flags2, format, varargs) {
          format >>>= 0;
          varargs >>>= 0;
          var result = formatString(format, varargs);
          var str = UTF8ArrayToString(result, 0);
          emscriptenLog(flags2, str);
        }
        _emscripten_log.sig = "vipp";
        function _emscripten_get_compiler_setting(name2) {
          name2 >>>= 0;
          throw "You must build with -sRETAIN_COMPILER_SETTINGS for getCompilerSetting or emscripten_get_compiler_setting to work";
        }
        _emscripten_get_compiler_setting.sig = "pp";
        var _emscripten_has_asyncify = () => 0;
        _emscripten_has_asyncify.sig = "i";
        function _emscripten_debugger() {
          debugger;
        }
        _emscripten_debugger.sig = "v";
        function _emscripten_print_double(x, to, max) {
          to >>>= 0;
          var str = x + "";
          if (to)
            return stringToUTF8(str, to, max);
          else
            return lengthBytesUTF8(str);
        }
        _emscripten_print_double.sig = "idpi";
        var convertFrameToPC = (frame) => {
          abort("Cannot use convertFrameToPC (needed by __builtin_return_address) without -sUSE_OFFSET_CONVERTER");
          return 0;
        };
        function _emscripten_return_address(level) {
          var callstack = jsStackTrace().split("\n");
          if (callstack[0] == "Error") {
            callstack.shift();
          }
          var caller = callstack[level + 3];
          return convertFrameToPC(caller);
        }
        _emscripten_return_address.sig = "pi";
        var UNWIND_CACHE = {};
        var saveInUnwindCache = (callstack) => {
          callstack.forEach((frame) => {
            var pc = convertFrameToPC(frame);
            if (pc) {
              UNWIND_CACHE[pc] = frame;
            }
          });
        };
        function _emscripten_stack_snapshot() {
          var callstack = jsStackTrace().split("\n");
          if (callstack[0] == "Error") {
            callstack.shift();
          }
          saveInUnwindCache(callstack);
          UNWIND_CACHE.last_addr = convertFrameToPC(callstack[3]);
          UNWIND_CACHE.last_stack = callstack;
          return UNWIND_CACHE.last_addr;
        }
        _emscripten_stack_snapshot.sig = "p";
        function _emscripten_stack_unwind_buffer(addr2, buffer, count) {
          addr2 >>>= 0;
          buffer >>>= 0;
          var stack;
          if (UNWIND_CACHE.last_addr == addr2) {
            stack = UNWIND_CACHE.last_stack;
          } else {
            stack = jsStackTrace().split("\n");
            if (stack[0] == "Error") {
              stack.shift();
            }
            saveInUnwindCache(stack);
          }
          var offset = 3;
          while (stack[offset] && convertFrameToPC(stack[offset]) != addr2) {
            ++offset;
          }
          for (var i2 = 0; i2 < count && stack[i2 + offset]; ++i2) {
            HEAP32[buffer + i2 * 4 >>> 2 >>> 0] = convertFrameToPC(stack[i2 + offset]);
          }
          return i2;
        }
        _emscripten_stack_unwind_buffer.sig = "ippi";
        function _emscripten_pc_get_function(pc) {
          pc >>>= 0;
          abort("Cannot use emscripten_pc_get_function without -sUSE_OFFSET_CONVERTER");
          return 0;
        }
        _emscripten_pc_get_function.sig = "pp";
        var convertPCtoSourceLocation = (pc) => {
          if (UNWIND_CACHE.last_get_source_pc == pc)
            return UNWIND_CACHE.last_source;
          var match;
          var source;
          if (!source) {
            var frame = UNWIND_CACHE[pc];
            if (!frame)
              return null;
            if (match = /\((.*):(\d+):(\d+)\)$/.exec(frame)) {
              source = {
                file: match[1],
                line: match[2],
                column: match[3]
              };
            } else if (match = /@(.*):(\d+):(\d+)/.exec(frame)) {
              source = {
                file: match[1],
                line: match[2],
                column: match[3]
              };
            }
          }
          UNWIND_CACHE.last_get_source_pc = pc;
          UNWIND_CACHE.last_source = source;
          return source;
        };
        function _emscripten_pc_get_file(pc) {
          pc >>>= 0;
          var result = convertPCtoSourceLocation(pc);
          if (!result)
            return 0;
          if (_emscripten_pc_get_file.ret)
            _free(_emscripten_pc_get_file.ret);
          _emscripten_pc_get_file.ret = stringToNewUTF8(result.file);
          return _emscripten_pc_get_file.ret;
        }
        _emscripten_pc_get_file.sig = "pp";
        function _emscripten_pc_get_line(pc) {
          pc >>>= 0;
          var result = convertPCtoSourceLocation(pc);
          return result ? result.line : 0;
        }
        _emscripten_pc_get_line.sig = "ip";
        function _emscripten_pc_get_column(pc) {
          pc >>>= 0;
          var result = convertPCtoSourceLocation(pc);
          return result ? result.column || 0 : 0;
        }
        _emscripten_pc_get_column.sig = "ip";
        function _emscripten_get_module_name(buf, length) {
          buf >>>= 0;
          length >>>= 0;
          return stringToUTF8(wasmBinaryFile, buf, length);
        }
        _emscripten_get_module_name.sig = "ppp";
        function _emscripten_asm_const_double(code, sigPtr, argbuf) {
          code >>>= 0;
          sigPtr >>>= 0;
          argbuf >>>= 0;
          return runEmAsmFunction(code, sigPtr, argbuf);
        }
        _emscripten_asm_const_double.sig = "dppp";
        var runMainThreadEmAsm = (code, sigPtr, argbuf, sync2) => {
          var args2 = readEmAsmArgs(sigPtr, argbuf);
          return ASM_CONSTS[code].apply(null, args2);
        };
        function _emscripten_asm_const_int_sync_on_main_thread(code, sigPtr, argbuf) {
          code >>>= 0;
          sigPtr >>>= 0;
          argbuf >>>= 0;
          return runMainThreadEmAsm(code, sigPtr, argbuf, 1);
        }
        _emscripten_asm_const_int_sync_on_main_thread.sig = "ippp";
        function _emscripten_asm_const_ptr_sync_on_main_thread(code, sigPtr, argbuf) {
          code >>>= 0;
          sigPtr >>>= 0;
          argbuf >>>= 0;
          return runMainThreadEmAsm(code, sigPtr, argbuf, 1);
        }
        _emscripten_asm_const_ptr_sync_on_main_thread.sig = "pppp";
        var _emscripten_asm_const_double_sync_on_main_thread = _emscripten_asm_const_int_sync_on_main_thread;
        _emscripten_asm_const_double_sync_on_main_thread.sig = "dppp";
        function _emscripten_asm_const_async_on_main_thread(code, sigPtr, argbuf) {
          code >>>= 0;
          sigPtr >>>= 0;
          argbuf >>>= 0;
          return runMainThreadEmAsm(code, sigPtr, argbuf, 0);
        }
        _emscripten_asm_const_async_on_main_thread.sig = "vppp";
        var jstoi_s = Number;
        function __Unwind_Backtrace(func2, arg) {
          func2 >>>= 0;
          arg >>>= 0;
          var trace = getCallstack();
          var parts2 = trace.split("\n");
          for (var i2 = 0; i2 < parts2.length; i2++) {
            var ret = getWasmTableEntry(func2)(0, arg);
            if (ret !== 0)
              return;
          }
        }
        __Unwind_Backtrace.sig = "ipp";
        function __Unwind_GetIPInfo(context, ipBefore) {
          context >>>= 0;
          ipBefore >>>= 0;
          return abort("Unwind_GetIPInfo");
        }
        __Unwind_GetIPInfo.sig = "ppp";
        function __Unwind_FindEnclosingFunction(ip) {
          ip >>>= 0;
          return 0;
        }
        __Unwind_FindEnclosingFunction.sig = "pp";
        function __Unwind_RaiseException(ex) {
          ex >>>= 0;
          err("Warning: _Unwind_RaiseException is not correctly implemented");
          return ___cxa_throw(ex, 0, 0);
        }
        __Unwind_RaiseException.sig = "ip";
        function __Unwind_DeleteException(ex) {
          ex >>>= 0;
          err("TODO: Unwind_DeleteException");
        }
        __Unwind_DeleteException.sig = "vp";
        var getDynCaller = (sig, ptr2) => {
          var argCache = [];
          return function() {
            argCache.length = 0;
            Object.assign(argCache, arguments);
            return dynCall(sig, ptr2, argCache);
          };
        };
        var _emscripten_exit_with_live_runtime = () => {
          throw "unwind";
        };
        _emscripten_exit_with_live_runtime.sig = "v";
        var _emscripten_force_exit = (status) => {
          __emscripten_runtime_keepalive_clear();
          _exit(status);
        };
        _emscripten_force_exit.sig = "vi";
        function _emscripten_outn(str, len2) {
          str >>>= 0;
          len2 >>>= 0;
          return out(UTF8ToString(str, len2));
        }
        _emscripten_outn.sig = "vpp";
        function _emscripten_errn(str, len2) {
          str >>>= 0;
          len2 >>>= 0;
          return err(UTF8ToString(str, len2));
        }
        _emscripten_errn.sig = "vpp";
        var _emscripten_throw_number = (number) => {
          throw number;
        };
        _emscripten_throw_number.sig = "vd";
        function _emscripten_throw_string(str) {
          str >>>= 0;
          throw UTF8ToString(str);
        }
        _emscripten_throw_string.sig = "vp";
        var runtimeKeepalivePush = () => {
          runtimeKeepaliveCounter += 1;
        };
        runtimeKeepalivePush.sig = "v";
        var runtimeKeepalivePop = () => {
          runtimeKeepaliveCounter -= 1;
        };
        runtimeKeepalivePop.sig = "v";
        var _emscripten_runtime_keepalive_push = runtimeKeepalivePush;
        _emscripten_runtime_keepalive_push.sig = "v";
        var _emscripten_runtime_keepalive_pop = runtimeKeepalivePop;
        _emscripten_runtime_keepalive_pop.sig = "v";
        var _emscripten_runtime_keepalive_check = keepRuntimeAlive;
        _emscripten_runtime_keepalive_check.sig = "i";
        var asmjsMangle = (x) => {
          var unmangledSymbols = ["stackAlloc", "stackSave", "stackRestore", "getTempRet0", "setTempRet0"];
          if (x == "__main_argc_argv") {
            x = "main";
          }
          return x.indexOf("dynCall_") == 0 || unmangledSymbols.includes(x) ? x : "_" + x;
        };
        var ___global_base = 1024;
        function __emscripten_fs_load_embedded_files(ptr2) {
          ptr2 >>>= 0;
          do {
            var name_addr = HEAPU32[ptr2 >>> 2 >>> 0];
            ptr2 += 4;
            var len2 = HEAPU32[ptr2 >>> 2 >>> 0];
            ptr2 += 4;
            var content = HEAPU32[ptr2 >>> 2 >>> 0];
            ptr2 += 4;
            var name2 = UTF8ToString(name_addr);
            FS.createPath("/", PATH.dirname(name2), true, true);
            FS.createDataFile(name2, null, HEAP8.subarray(content >>> 0, content + len2 >>> 0), true, true, true);
          } while (HEAPU32[ptr2 >>> 2 >>> 0]);
        }
        __emscripten_fs_load_embedded_files.sig = "vp";
        var POINTER_SIZE = 4;
        function getNativeTypeSize(type) {
          switch (type) {
            case "i1":
            case "i8":
            case "u8":
              return 1;
            case "i16":
            case "u16":
              return 2;
            case "i32":
            case "u32":
              return 4;
            case "i64":
            case "u64":
              return 8;
            case "float":
              return 4;
            case "double":
              return 8;
            default: {
              if (type[type.length - 1] === "*") {
                return POINTER_SIZE;
              }
              if (type[0] === "i") {
                const bits = Number(type.substr(1));
                assert(bits % 8 === 0, `getNativeTypeSize invalid bits ${bits}, ${type} type`);
                return bits / 8;
              }
              return 0;
            }
          }
        }
        var STACK_SIZE = 65536;
        var STACK_ALIGN = 16;
        var ASSERTIONS = 0;
        var cwrap = (ident, returnType, argTypes, opts) => {
          var numericArgs = !argTypes || argTypes.every((type) => type === "number" || type === "boolean");
          var numericRet = returnType !== "string";
          if (numericRet && numericArgs && !opts) {
            return getCFunc(ident);
          }
          return function() {
            return ccall(ident, returnType, argTypes, arguments, opts);
          };
        };
        var removeFunction = (index) => {
          functionsInTableMap.delete(getWasmTableEntry(index));
          setWasmTableEntry(index, null);
          freeTableIndexes.push(index);
        };
        var _emscripten_math_cbrt = (x) => Math.cbrt(x);
        _emscripten_math_cbrt.sig = "dd";
        var _emscripten_math_pow = (x, y) => Math.pow(x, y);
        _emscripten_math_pow.sig = "ddd";
        var _emscripten_math_random = () => Math.random();
        _emscripten_math_random.sig = "d";
        var _emscripten_math_sign = (x) => Math.sign(x);
        _emscripten_math_sign.sig = "dd";
        var _emscripten_math_sqrt = (x) => Math.sqrt(x);
        _emscripten_math_sqrt.sig = "dd";
        var _emscripten_math_exp = (x) => Math.exp(x);
        _emscripten_math_exp.sig = "dd";
        var _emscripten_math_expm1 = (x) => Math.expm1(x);
        _emscripten_math_expm1.sig = "dd";
        var _emscripten_math_fmod = (x, y) => x % y;
        _emscripten_math_fmod.sig = "ddd";
        var _emscripten_math_log = (x) => Math.log(x);
        _emscripten_math_log.sig = "dd";
        var _emscripten_math_log1p = (x) => Math.log1p(x);
        _emscripten_math_log1p.sig = "dd";
        var _emscripten_math_log10 = (x) => Math.log10(x);
        _emscripten_math_log10.sig = "dd";
        var _emscripten_math_log2 = (x) => Math.log2(x);
        _emscripten_math_log2.sig = "dd";
        var _emscripten_math_round = (x) => Math.round(x);
        _emscripten_math_round.sig = "dd";
        var _emscripten_math_acos = (x) => Math.acos(x);
        _emscripten_math_acos.sig = "dd";
        var _emscripten_math_acosh = (x) => Math.acosh(x);
        _emscripten_math_acosh.sig = "dd";
        var _emscripten_math_asin = (x) => Math.asin(x);
        _emscripten_math_asin.sig = "dd";
        var _emscripten_math_asinh = (x) => Math.asinh(x);
        _emscripten_math_asinh.sig = "dd";
        var _emscripten_math_atan = (x) => Math.atan(x);
        _emscripten_math_atan.sig = "dd";
        var _emscripten_math_atanh = (x) => Math.atanh(x);
        _emscripten_math_atanh.sig = "dd";
        var _emscripten_math_atan2 = (y, x) => Math.atan2(y, x);
        _emscripten_math_atan2.sig = "ddd";
        var _emscripten_math_cos = (x) => Math.cos(x);
        _emscripten_math_cos.sig = "dd";
        var _emscripten_math_cosh = (x) => Math.cosh(x);
        _emscripten_math_cosh.sig = "dd";
        function _emscripten_math_hypot(count, varargs) {
          varargs >>>= 0;
          var args2 = [];
          for (var i2 = 0; i2 < count; ++i2) {
            args2.push(HEAPF64[varargs + i2 * 8 >>> 3 >>> 0]);
          }
          return Math.hypot.apply(null, args2);
        }
        _emscripten_math_hypot.sig = "dip";
        var _emscripten_math_sin = (x) => Math.sin(x);
        _emscripten_math_sin.sig = "dd";
        var _emscripten_math_sinh = (x) => Math.sinh(x);
        _emscripten_math_sinh.sig = "dd";
        var _emscripten_math_tan = (x) => Math.tan(x);
        _emscripten_math_tan.sig = "dd";
        var _emscripten_math_tanh = (x) => Math.tanh(x);
        _emscripten_math_tanh.sig = "dd";
        function intArrayToString(array) {
          var ret = [];
          for (var i2 = 0; i2 < array.length; i2++) {
            var chr = array[i2];
            if (chr > 255) {
              chr &= 255;
            }
            ret.push(String.fromCharCode(chr));
          }
          return ret.join("");
        }
        var AsciiToString = (ptr2) => {
          ptr2 >>>= 0;
          var str = "";
          while (1) {
            var ch = HEAPU8[ptr2++ >>> 0 >>> 0];
            if (!ch)
              return str;
            str += String.fromCharCode(ch);
          }
        };
        var JSEvents = {
          removeAllEventListeners() {
            while (JSEvents.eventHandlers.length) {
              JSEvents._removeHandler(JSEvents.eventHandlers.length - 1);
            }
            JSEvents.deferredCalls = [];
          },
          inEventHandler: 0,
          deferredCalls: [],
          deferCall(targetFunction, precedence, argsList) {
            function arraysHaveEqualContent(arrA, arrB) {
              if (arrA.length != arrB.length)
                return false;
              for (var i3 in arrA) {
                if (arrA[i3] != arrB[i3])
                  return false;
              }
              return true;
            }
            for (var i2 in JSEvents.deferredCalls) {
              var call = JSEvents.deferredCalls[i2];
              if (call.targetFunction == targetFunction && arraysHaveEqualContent(call.argsList, argsList)) {
                return;
              }
            }
            JSEvents.deferredCalls.push({
              targetFunction,
              precedence,
              argsList
            });
            JSEvents.deferredCalls.sort((x, y) => x.precedence < y.precedence);
          },
          removeDeferredCalls(targetFunction) {
            for (var i2 = 0; i2 < JSEvents.deferredCalls.length; ++i2) {
              if (JSEvents.deferredCalls[i2].targetFunction == targetFunction) {
                JSEvents.deferredCalls.splice(i2, 1);
                --i2;
              }
            }
          },
          canPerformEventHandlerRequests() {
            if (navigator.userActivation) {
              return navigator.userActivation.isActive;
            }
            return JSEvents.inEventHandler && JSEvents.currentEventHandler.allowsDeferredCalls;
          },
          runDeferredCalls() {
            if (!JSEvents.canPerformEventHandlerRequests()) {
              return;
            }
            for (var i2 = 0; i2 < JSEvents.deferredCalls.length; ++i2) {
              var call = JSEvents.deferredCalls[i2];
              JSEvents.deferredCalls.splice(i2, 1);
              --i2;
              call.targetFunction.apply(null, call.argsList);
            }
          },
          eventHandlers: [],
          removeAllHandlersOnTarget: (target, eventTypeString) => {
            for (var i2 = 0; i2 < JSEvents.eventHandlers.length; ++i2) {
              if (JSEvents.eventHandlers[i2].target == target && (!eventTypeString || eventTypeString == JSEvents.eventHandlers[i2].eventTypeString)) {
                JSEvents._removeHandler(i2--);
              }
            }
          },
          _removeHandler(i2) {
            var h = JSEvents.eventHandlers[i2];
            h.target.removeEventListener(h.eventTypeString, h.eventListenerFunc, h.useCapture);
            JSEvents.eventHandlers.splice(i2, 1);
          },
          registerOrRemoveHandler(eventHandler) {
            if (!eventHandler.target) {
              return -4;
            }
            if (eventHandler.callbackfunc) {
              eventHandler.eventListenerFunc = function(event2) {
                ++JSEvents.inEventHandler;
                JSEvents.currentEventHandler = eventHandler;
                JSEvents.runDeferredCalls();
                eventHandler.handlerFunc(event2);
                JSEvents.runDeferredCalls();
                --JSEvents.inEventHandler;
              };
              eventHandler.target.addEventListener(eventHandler.eventTypeString, eventHandler.eventListenerFunc, eventHandler.useCapture);
              JSEvents.eventHandlers.push(eventHandler);
            } else {
              for (var i2 = 0; i2 < JSEvents.eventHandlers.length; ++i2) {
                if (JSEvents.eventHandlers[i2].target == eventHandler.target && JSEvents.eventHandlers[i2].eventTypeString == eventHandler.eventTypeString) {
                  JSEvents._removeHandler(i2--);
                }
              }
            }
            return 0;
          },
          getNodeNameForTarget(target) {
            if (!target)
              return "";
            if (target == window)
              return "#window";
            if (target == screen)
              return "#screen";
            return (target == null ? void 0 : target.nodeName) || "";
          },
          fullscreenEnabled() {
            return document.fullscreenEnabled || document.webkitFullscreenEnabled;
          }
        };
        var maybeCStringToJsString = (cString) => cString > 2 ? UTF8ToString(cString) : cString;
        var specialHTMLTargets = [0, typeof document != "undefined" ? document : 0, typeof window != "undefined" ? window : 0];
        var findEventTarget = (target) => {
          target = maybeCStringToJsString(target);
          var domElement = specialHTMLTargets[target] || (typeof document != "undefined" ? document.querySelector(target) : void 0);
          return domElement;
        };
        var registerKeyEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
          if (!JSEvents.keyEvent)
            JSEvents.keyEvent = _malloc(176);
          var keyEventHandlerFunc = (e) => {
            var keyEventData = JSEvents.keyEvent;
            HEAPF64[keyEventData >>> 3 >>> 0] = e.timeStamp;
            var idx = keyEventData >>> 2;
            HEAP32[idx + 2 >>> 0] = e.location;
            HEAP32[idx + 3 >>> 0] = e.ctrlKey;
            HEAP32[idx + 4 >>> 0] = e.shiftKey;
            HEAP32[idx + 5 >>> 0] = e.altKey;
            HEAP32[idx + 6 >>> 0] = e.metaKey;
            HEAP32[idx + 7 >>> 0] = e.repeat;
            HEAP32[idx + 8 >>> 0] = e.charCode;
            HEAP32[idx + 9 >>> 0] = e.keyCode;
            HEAP32[idx + 10 >>> 0] = e.which;
            stringToUTF8(e.key || "", keyEventData + 44, 32);
            stringToUTF8(e.code || "", keyEventData + 76, 32);
            stringToUTF8(e.char || "", keyEventData + 108, 32);
            stringToUTF8(e.locale || "", keyEventData + 140, 32);
            if (getWasmTableEntry(callbackfunc)(eventTypeId, keyEventData, userData))
              e.preventDefault();
          };
          var eventHandler = {
            target: findEventTarget(target),
            eventTypeString,
            callbackfunc,
            handlerFunc: keyEventHandlerFunc,
            useCapture
          };
          return JSEvents.registerOrRemoveHandler(eventHandler);
        };
        var findCanvasEventTarget = findEventTarget;
        function _emscripten_set_keypress_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
          target >>>= 0;
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          return registerKeyEventCallback(target, userData, useCapture, callbackfunc, 1, "keypress", targetThread);
        }
        _emscripten_set_keypress_callback_on_thread.sig = "ippipp";
        function _emscripten_set_keydown_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
          target >>>= 0;
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          return registerKeyEventCallback(target, userData, useCapture, callbackfunc, 2, "keydown", targetThread);
        }
        _emscripten_set_keydown_callback_on_thread.sig = "ippipp";
        function _emscripten_set_keyup_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
          target >>>= 0;
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          return registerKeyEventCallback(target, userData, useCapture, callbackfunc, 3, "keyup", targetThread);
        }
        _emscripten_set_keyup_callback_on_thread.sig = "ippipp";
        var getBoundingClientRect = (e) => specialHTMLTargets.indexOf(e) < 0 ? e.getBoundingClientRect() : {
          "left": 0,
          "top": 0
        };
        var fillMouseEventData = (eventStruct, e, target) => {
          HEAPF64[eventStruct >>> 3 >>> 0] = e.timeStamp;
          var idx = eventStruct >>> 2;
          HEAP32[idx + 2 >>> 0] = e.screenX;
          HEAP32[idx + 3 >>> 0] = e.screenY;
          HEAP32[idx + 4 >>> 0] = e.clientX;
          HEAP32[idx + 5 >>> 0] = e.clientY;
          HEAP32[idx + 6 >>> 0] = e.ctrlKey;
          HEAP32[idx + 7 >>> 0] = e.shiftKey;
          HEAP32[idx + 8 >>> 0] = e.altKey;
          HEAP32[idx + 9 >>> 0] = e.metaKey;
          HEAP16[idx * 2 + 20 >>> 0] = e.button;
          HEAP16[idx * 2 + 21 >>> 0] = e.buttons;
          HEAP32[idx + 11 >>> 0] = e["movementX"];
          HEAP32[idx + 12 >>> 0] = e["movementY"];
          var rect = getBoundingClientRect(target);
          HEAP32[idx + 13 >>> 0] = e.clientX - rect.left;
          HEAP32[idx + 14 >>> 0] = e.clientY - rect.top;
        };
        var registerMouseEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
          if (!JSEvents.mouseEvent)
            JSEvents.mouseEvent = _malloc(72);
          target = findEventTarget(target);
          var mouseEventHandlerFunc = (e = event) => {
            fillMouseEventData(JSEvents.mouseEvent, e, target);
            if (getWasmTableEntry(callbackfunc)(eventTypeId, JSEvents.mouseEvent, userData))
              e.preventDefault();
          };
          var eventHandler = {
            target,
            allowsDeferredCalls: eventTypeString != "mousemove" && eventTypeString != "mouseenter" && eventTypeString != "mouseleave",
            eventTypeString,
            callbackfunc,
            handlerFunc: mouseEventHandlerFunc,
            useCapture
          };
          return JSEvents.registerOrRemoveHandler(eventHandler);
        };
        function _emscripten_set_click_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
          target >>>= 0;
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          return registerMouseEventCallback(target, userData, useCapture, callbackfunc, 4, "click", targetThread);
        }
        _emscripten_set_click_callback_on_thread.sig = "ippipp";
        function _emscripten_set_mousedown_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
          target >>>= 0;
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          return registerMouseEventCallback(target, userData, useCapture, callbackfunc, 5, "mousedown", targetThread);
        }
        _emscripten_set_mousedown_callback_on_thread.sig = "ippipp";
        function _emscripten_set_mouseup_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
          target >>>= 0;
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          return registerMouseEventCallback(target, userData, useCapture, callbackfunc, 6, "mouseup", targetThread);
        }
        _emscripten_set_mouseup_callback_on_thread.sig = "ippipp";
        function _emscripten_set_dblclick_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
          target >>>= 0;
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          return registerMouseEventCallback(target, userData, useCapture, callbackfunc, 7, "dblclick", targetThread);
        }
        _emscripten_set_dblclick_callback_on_thread.sig = "ippipp";
        function _emscripten_set_mousemove_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
          target >>>= 0;
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          return registerMouseEventCallback(target, userData, useCapture, callbackfunc, 8, "mousemove", targetThread);
        }
        _emscripten_set_mousemove_callback_on_thread.sig = "ippipp";
        function _emscripten_set_mouseenter_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
          target >>>= 0;
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          return registerMouseEventCallback(target, userData, useCapture, callbackfunc, 33, "mouseenter", targetThread);
        }
        _emscripten_set_mouseenter_callback_on_thread.sig = "ippipp";
        function _emscripten_set_mouseleave_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
          target >>>= 0;
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          return registerMouseEventCallback(target, userData, useCapture, callbackfunc, 34, "mouseleave", targetThread);
        }
        _emscripten_set_mouseleave_callback_on_thread.sig = "ippipp";
        function _emscripten_set_mouseover_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
          target >>>= 0;
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          return registerMouseEventCallback(target, userData, useCapture, callbackfunc, 35, "mouseover", targetThread);
        }
        _emscripten_set_mouseover_callback_on_thread.sig = "ippipp";
        function _emscripten_set_mouseout_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
          target >>>= 0;
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          return registerMouseEventCallback(target, userData, useCapture, callbackfunc, 36, "mouseout", targetThread);
        }
        _emscripten_set_mouseout_callback_on_thread.sig = "ippipp";
        function _emscripten_get_mouse_status(mouseState) {
          mouseState >>>= 0;
          if (!JSEvents.mouseEvent)
            return -7;
          HEAP8.set(HEAP8.subarray(JSEvents.mouseEvent >>> 0, JSEvents.mouseEvent + 72 >>> 0), mouseState >>> 0);
          return 0;
        }
        _emscripten_get_mouse_status.sig = "ip";
        var registerWheelEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
          if (!JSEvents.wheelEvent)
            JSEvents.wheelEvent = _malloc(104);
          var wheelHandlerFunc = (e = event) => {
            var wheelEvent = JSEvents.wheelEvent;
            fillMouseEventData(wheelEvent, e, target);
            HEAPF64[wheelEvent + 72 >>> 3 >>> 0] = e["deltaX"];
            HEAPF64[wheelEvent + 80 >>> 3 >>> 0] = e["deltaY"];
            HEAPF64[wheelEvent + 88 >>> 3 >>> 0] = e["deltaZ"];
            HEAP32[wheelEvent + 96 >>> 2 >>> 0] = e["deltaMode"];
            if (getWasmTableEntry(callbackfunc)(eventTypeId, wheelEvent, userData))
              e.preventDefault();
          };
          var eventHandler = {
            target,
            allowsDeferredCalls: true,
            eventTypeString,
            callbackfunc,
            handlerFunc: wheelHandlerFunc,
            useCapture
          };
          return JSEvents.registerOrRemoveHandler(eventHandler);
        };
        function _emscripten_set_wheel_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
          target >>>= 0;
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          target = findEventTarget(target);
          if (!target)
            return -4;
          if (typeof target.onwheel != "undefined") {
            return registerWheelEventCallback(target, userData, useCapture, callbackfunc, 9, "wheel", targetThread);
          } else {
            return -1;
          }
        }
        _emscripten_set_wheel_callback_on_thread.sig = "ippipp";
        var registerUiEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
          if (!JSEvents.uiEvent)
            JSEvents.uiEvent = _malloc(36);
          target = findEventTarget(target);
          var uiEventHandlerFunc = (e = event) => {
            if (e.target != target) {
              return;
            }
            var b = document.body;
            if (!b) {
              return;
            }
            var uiEvent = JSEvents.uiEvent;
            HEAP32[uiEvent >>> 2 >>> 0] = e.detail;
            HEAP32[uiEvent + 4 >>> 2 >>> 0] = b.clientWidth;
            HEAP32[uiEvent + 8 >>> 2 >>> 0] = b.clientHeight;
            HEAP32[uiEvent + 12 >>> 2 >>> 0] = innerWidth;
            HEAP32[uiEvent + 16 >>> 2 >>> 0] = innerHeight;
            HEAP32[uiEvent + 20 >>> 2 >>> 0] = outerWidth;
            HEAP32[uiEvent + 24 >>> 2 >>> 0] = outerHeight;
            HEAP32[uiEvent + 28 >>> 2 >>> 0] = pageXOffset;
            HEAP32[uiEvent + 32 >>> 2 >>> 0] = pageYOffset;
            if (getWasmTableEntry(callbackfunc)(eventTypeId, uiEvent, userData))
              e.preventDefault();
          };
          var eventHandler = {
            target,
            eventTypeString,
            callbackfunc,
            handlerFunc: uiEventHandlerFunc,
            useCapture
          };
          return JSEvents.registerOrRemoveHandler(eventHandler);
        };
        function _emscripten_set_resize_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
          target >>>= 0;
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          return registerUiEventCallback(target, userData, useCapture, callbackfunc, 10, "resize", targetThread);
        }
        _emscripten_set_resize_callback_on_thread.sig = "ippipp";
        function _emscripten_set_scroll_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
          target >>>= 0;
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          return registerUiEventCallback(target, userData, useCapture, callbackfunc, 11, "scroll", targetThread);
        }
        _emscripten_set_scroll_callback_on_thread.sig = "ippipp";
        var registerFocusEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
          if (!JSEvents.focusEvent)
            JSEvents.focusEvent = _malloc(256);
          var focusEventHandlerFunc = (e = event) => {
            var nodeName = JSEvents.getNodeNameForTarget(e.target);
            var id = e.target.id ? e.target.id : "";
            var focusEvent = JSEvents.focusEvent;
            stringToUTF8(nodeName, focusEvent + 0, 128);
            stringToUTF8(id, focusEvent + 128, 128);
            if (getWasmTableEntry(callbackfunc)(eventTypeId, focusEvent, userData))
              e.preventDefault();
          };
          var eventHandler = {
            target: findEventTarget(target),
            eventTypeString,
            callbackfunc,
            handlerFunc: focusEventHandlerFunc,
            useCapture
          };
          return JSEvents.registerOrRemoveHandler(eventHandler);
        };
        function _emscripten_set_blur_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
          target >>>= 0;
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          return registerFocusEventCallback(target, userData, useCapture, callbackfunc, 12, "blur", targetThread);
        }
        _emscripten_set_blur_callback_on_thread.sig = "ippipp";
        function _emscripten_set_focus_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
          target >>>= 0;
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          return registerFocusEventCallback(target, userData, useCapture, callbackfunc, 13, "focus", targetThread);
        }
        _emscripten_set_focus_callback_on_thread.sig = "ippipp";
        function _emscripten_set_focusin_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
          target >>>= 0;
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          return registerFocusEventCallback(target, userData, useCapture, callbackfunc, 14, "focusin", targetThread);
        }
        _emscripten_set_focusin_callback_on_thread.sig = "ippipp";
        function _emscripten_set_focusout_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
          target >>>= 0;
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          return registerFocusEventCallback(target, userData, useCapture, callbackfunc, 15, "focusout", targetThread);
        }
        _emscripten_set_focusout_callback_on_thread.sig = "ippipp";
        var fillDeviceOrientationEventData = (eventStruct, e, target) => {
          HEAPF64[eventStruct >>> 3 >>> 0] = e.alpha;
          HEAPF64[eventStruct + 8 >>> 3 >>> 0] = e.beta;
          HEAPF64[eventStruct + 16 >>> 3 >>> 0] = e.gamma;
          HEAP32[eventStruct + 24 >>> 2 >>> 0] = e.absolute;
        };
        var registerDeviceOrientationEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
          if (!JSEvents.deviceOrientationEvent)
            JSEvents.deviceOrientationEvent = _malloc(32);
          var deviceOrientationEventHandlerFunc = (e = event) => {
            fillDeviceOrientationEventData(JSEvents.deviceOrientationEvent, e, target);
            if (getWasmTableEntry(callbackfunc)(eventTypeId, JSEvents.deviceOrientationEvent, userData))
              e.preventDefault();
          };
          var eventHandler = {
            target: findEventTarget(target),
            eventTypeString,
            callbackfunc,
            handlerFunc: deviceOrientationEventHandlerFunc,
            useCapture
          };
          return JSEvents.registerOrRemoveHandler(eventHandler);
        };
        function _emscripten_set_deviceorientation_callback_on_thread(userData, useCapture, callbackfunc, targetThread) {
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          return registerDeviceOrientationEventCallback(2, userData, useCapture, callbackfunc, 16, "deviceorientation", targetThread);
        }
        _emscripten_set_deviceorientation_callback_on_thread.sig = "ipipp";
        function _emscripten_get_deviceorientation_status(orientationState) {
          orientationState >>>= 0;
          if (!JSEvents.deviceOrientationEvent)
            return -7;
          HEAP32.set(HEAP32.subarray(JSEvents.deviceOrientationEvent >>> 0, 32 >>> 0), orientationState >>> 0);
          return 0;
        }
        _emscripten_get_deviceorientation_status.sig = "ip";
        var fillDeviceMotionEventData = (eventStruct, e, target) => {
          var supportedFields = 0;
          var a = e["acceleration"];
          supportedFields |= a && 1;
          var ag = e["accelerationIncludingGravity"];
          supportedFields |= ag && 2;
          var rr = e["rotationRate"];
          supportedFields |= rr && 4;
          a = a || {};
          ag = ag || {};
          rr = rr || {};
          HEAPF64[eventStruct >>> 3 >>> 0] = a["x"];
          HEAPF64[eventStruct + 8 >>> 3 >>> 0] = a["y"];
          HEAPF64[eventStruct + 16 >>> 3 >>> 0] = a["z"];
          HEAPF64[eventStruct + 24 >>> 3 >>> 0] = ag["x"];
          HEAPF64[eventStruct + 32 >>> 3 >>> 0] = ag["y"];
          HEAPF64[eventStruct + 40 >>> 3 >>> 0] = ag["z"];
          HEAPF64[eventStruct + 48 >>> 3 >>> 0] = rr["alpha"];
          HEAPF64[eventStruct + 56 >>> 3 >>> 0] = rr["beta"];
          HEAPF64[eventStruct + 64 >>> 3 >>> 0] = rr["gamma"];
        };
        var registerDeviceMotionEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
          if (!JSEvents.deviceMotionEvent)
            JSEvents.deviceMotionEvent = _malloc(80);
          var deviceMotionEventHandlerFunc = (e = event) => {
            fillDeviceMotionEventData(JSEvents.deviceMotionEvent, e, target);
            if (getWasmTableEntry(callbackfunc)(eventTypeId, JSEvents.deviceMotionEvent, userData))
              e.preventDefault();
          };
          var eventHandler = {
            target: findEventTarget(target),
            eventTypeString,
            callbackfunc,
            handlerFunc: deviceMotionEventHandlerFunc,
            useCapture
          };
          return JSEvents.registerOrRemoveHandler(eventHandler);
        };
        function _emscripten_set_devicemotion_callback_on_thread(userData, useCapture, callbackfunc, targetThread) {
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          return registerDeviceMotionEventCallback(2, userData, useCapture, callbackfunc, 17, "devicemotion", targetThread);
        }
        _emscripten_set_devicemotion_callback_on_thread.sig = "ipipp";
        function _emscripten_get_devicemotion_status(motionState) {
          motionState >>>= 0;
          if (!JSEvents.deviceMotionEvent)
            return -7;
          HEAP32.set(HEAP32.subarray(JSEvents.deviceMotionEvent >>> 0, 80 >>> 0), motionState >>> 0);
          return 0;
        }
        _emscripten_get_devicemotion_status.sig = "ip";
        var screenOrientation = () => {
          if (!screen)
            return void 0;
          return screen.orientation || screen.mozOrientation || screen.webkitOrientation || screen.msOrientation;
        };
        var fillOrientationChangeEventData = (eventStruct) => {
          var orientations = ["portrait-primary", "portrait-secondary", "landscape-primary", "landscape-secondary"];
          var orientations2 = ["portrait", "portrait", "landscape", "landscape"];
          var orientationString = screenOrientation();
          var orientation2 = orientations.indexOf(orientationString);
          if (orientation2 == -1) {
            orientation2 = orientations2.indexOf(orientationString);
          }
          HEAP32[eventStruct >>> 2 >>> 0] = 1 << orientation2;
          HEAP32[eventStruct + 4 >>> 2 >>> 0] = orientation2;
        };
        var registerOrientationChangeEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
          if (!JSEvents.orientationChangeEvent)
            JSEvents.orientationChangeEvent = _malloc(8);
          var orientationChangeEventHandlerFunc = (e = event) => {
            var orientationChangeEvent = JSEvents.orientationChangeEvent;
            fillOrientationChangeEventData(orientationChangeEvent);
            if (getWasmTableEntry(callbackfunc)(eventTypeId, orientationChangeEvent, userData))
              e.preventDefault();
          };
          if (eventTypeId == 18 && screen.mozOrientation !== void 0) {
            eventTypeString = "mozorientationchange";
          }
          var eventHandler = {
            target,
            eventTypeString,
            callbackfunc,
            handlerFunc: orientationChangeEventHandlerFunc,
            useCapture
          };
          return JSEvents.registerOrRemoveHandler(eventHandler);
        };
        function _emscripten_set_orientationchange_callback_on_thread(userData, useCapture, callbackfunc, targetThread) {
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          if (!screen || !screen["addEventListener"])
            return -1;
          return registerOrientationChangeEventCallback(screen, userData, useCapture, callbackfunc, 18, "orientationchange", targetThread);
        }
        _emscripten_set_orientationchange_callback_on_thread.sig = "ipipp";
        function _emscripten_get_orientation_status(orientationChangeEvent) {
          orientationChangeEvent >>>= 0;
          if (!screenOrientation() && typeof orientation == "undefined")
            return -1;
          fillOrientationChangeEventData(orientationChangeEvent);
          return 0;
        }
        _emscripten_get_orientation_status.sig = "ip";
        var _emscripten_lock_orientation = (allowedOrientations) => {
          var orientations = [];
          if (allowedOrientations & 1)
            orientations.push("portrait-primary");
          if (allowedOrientations & 2)
            orientations.push("portrait-secondary");
          if (allowedOrientations & 4)
            orientations.push("landscape-primary");
          if (allowedOrientations & 8)
            orientations.push("landscape-secondary");
          var succeeded;
          if (screen.lockOrientation) {
            succeeded = screen.lockOrientation(orientations);
          } else if (screen.mozLockOrientation) {
            succeeded = screen.mozLockOrientation(orientations);
          } else if (screen.webkitLockOrientation) {
            succeeded = screen.webkitLockOrientation(orientations);
          } else if (screen.msLockOrientation) {
            succeeded = screen.msLockOrientation(orientations);
          } else {
            return -1;
          }
          if (succeeded) {
            return 0;
          }
          return -6;
        };
        _emscripten_lock_orientation.sig = "ii";
        var _emscripten_unlock_orientation = () => {
          if (screen.unlockOrientation) {
            screen.unlockOrientation();
          } else if (screen.mozUnlockOrientation) {
            screen.mozUnlockOrientation();
          } else if (screen.webkitUnlockOrientation) {
            screen.webkitUnlockOrientation();
          } else if (screen.msUnlockOrientation) {
            screen.msUnlockOrientation();
          } else {
            return -1;
          }
          return 0;
        };
        _emscripten_unlock_orientation.sig = "i";
        var fillFullscreenChangeEventData = (eventStruct) => {
          var fullscreenElement = document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement;
          var isFullscreen = !!fullscreenElement;
          HEAP32[eventStruct >>> 2 >>> 0] = isFullscreen;
          HEAP32[eventStruct + 4 >>> 2 >>> 0] = JSEvents.fullscreenEnabled();
          var reportedElement = isFullscreen ? fullscreenElement : JSEvents.previousFullscreenElement;
          var nodeName = JSEvents.getNodeNameForTarget(reportedElement);
          var id = (reportedElement == null ? void 0 : reportedElement.id) || "";
          stringToUTF8(nodeName, eventStruct + 8, 128);
          stringToUTF8(id, eventStruct + 136, 128);
          HEAP32[eventStruct + 264 >>> 2 >>> 0] = reportedElement ? reportedElement.clientWidth : 0;
          HEAP32[eventStruct + 268 >>> 2 >>> 0] = reportedElement ? reportedElement.clientHeight : 0;
          HEAP32[eventStruct + 272 >>> 2 >>> 0] = screen.width;
          HEAP32[eventStruct + 276 >>> 2 >>> 0] = screen.height;
          if (isFullscreen) {
            JSEvents.previousFullscreenElement = fullscreenElement;
          }
        };
        var registerFullscreenChangeEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
          if (!JSEvents.fullscreenChangeEvent)
            JSEvents.fullscreenChangeEvent = _malloc(280);
          var fullscreenChangeEventhandlerFunc = (e = event) => {
            var fullscreenChangeEvent = JSEvents.fullscreenChangeEvent;
            fillFullscreenChangeEventData(fullscreenChangeEvent);
            if (getWasmTableEntry(callbackfunc)(eventTypeId, fullscreenChangeEvent, userData))
              e.preventDefault();
          };
          var eventHandler = {
            target,
            eventTypeString,
            callbackfunc,
            handlerFunc: fullscreenChangeEventhandlerFunc,
            useCapture
          };
          return JSEvents.registerOrRemoveHandler(eventHandler);
        };
        function _emscripten_set_fullscreenchange_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
          target >>>= 0;
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          if (!JSEvents.fullscreenEnabled())
            return -1;
          target = findEventTarget(target);
          if (!target)
            return -4;
          registerFullscreenChangeEventCallback(target, userData, useCapture, callbackfunc, 19, "webkitfullscreenchange", targetThread);
          return registerFullscreenChangeEventCallback(target, userData, useCapture, callbackfunc, 19, "fullscreenchange", targetThread);
        }
        _emscripten_set_fullscreenchange_callback_on_thread.sig = "ippipp";
        function _emscripten_get_fullscreen_status(fullscreenStatus) {
          fullscreenStatus >>>= 0;
          if (!JSEvents.fullscreenEnabled())
            return -1;
          fillFullscreenChangeEventData(fullscreenStatus);
          return 0;
        }
        _emscripten_get_fullscreen_status.sig = "ip";
        function _emscripten_get_canvas_element_size(target, width, height) {
          target >>>= 0;
          width >>>= 0;
          height >>>= 0;
          var canvas = findCanvasEventTarget(target);
          if (!canvas)
            return -4;
          HEAP32[width >>> 2 >>> 0] = canvas.width;
          HEAP32[height >>> 2 >>> 0] = canvas.height;
        }
        _emscripten_get_canvas_element_size.sig = "ippp";
        var getCanvasElementSize = (target) => withStackSave(() => {
          var w = stackAlloc(8);
          var h = w + 4;
          var targetInt = stringToUTF8OnStack(target.id);
          var ret = _emscripten_get_canvas_element_size(targetInt, w, h);
          var size = [HEAP32[w >>> 2 >>> 0], HEAP32[h >>> 2 >>> 0]];
          return size;
        });
        function _emscripten_set_canvas_element_size(target, width, height) {
          target >>>= 0;
          var canvas = findCanvasEventTarget(target);
          if (!canvas)
            return -4;
          canvas.width = width;
          canvas.height = height;
          return 0;
        }
        _emscripten_set_canvas_element_size.sig = "ipii";
        var setCanvasElementSize = (target, width, height) => {
          if (!target.controlTransferredOffscreen) {
            target.width = width;
            target.height = height;
          } else {
            withStackSave(() => {
              var targetInt = stringToUTF8OnStack(target.id);
              _emscripten_set_canvas_element_size(targetInt, width, height);
            });
          }
        };
        var registerRestoreOldStyle = (canvas) => {
          var canvasSize = getCanvasElementSize(canvas);
          var oldWidth = canvasSize[0];
          var oldHeight = canvasSize[1];
          var oldCssWidth = canvas.style.width;
          var oldCssHeight = canvas.style.height;
          var oldBackgroundColor = canvas.style.backgroundColor;
          var oldDocumentBackgroundColor = document.body.style.backgroundColor;
          var oldPaddingLeft = canvas.style.paddingLeft;
          var oldPaddingRight = canvas.style.paddingRight;
          var oldPaddingTop = canvas.style.paddingTop;
          var oldPaddingBottom = canvas.style.paddingBottom;
          var oldMarginLeft = canvas.style.marginLeft;
          var oldMarginRight = canvas.style.marginRight;
          var oldMarginTop = canvas.style.marginTop;
          var oldMarginBottom = canvas.style.marginBottom;
          var oldDocumentBodyMargin = document.body.style.margin;
          var oldDocumentOverflow = document.documentElement.style.overflow;
          var oldDocumentScroll = document.body.scroll;
          var oldImageRendering = canvas.style.imageRendering;
          function restoreOldStyle() {
            var fullscreenElement = document.fullscreenElement || document.webkitFullscreenElement;
            if (!fullscreenElement) {
              document.removeEventListener("fullscreenchange", restoreOldStyle);
              document.removeEventListener("webkitfullscreenchange", restoreOldStyle);
              setCanvasElementSize(canvas, oldWidth, oldHeight);
              canvas.style.width = oldCssWidth;
              canvas.style.height = oldCssHeight;
              canvas.style.backgroundColor = oldBackgroundColor;
              if (!oldDocumentBackgroundColor)
                document.body.style.backgroundColor = "white";
              document.body.style.backgroundColor = oldDocumentBackgroundColor;
              canvas.style.paddingLeft = oldPaddingLeft;
              canvas.style.paddingRight = oldPaddingRight;
              canvas.style.paddingTop = oldPaddingTop;
              canvas.style.paddingBottom = oldPaddingBottom;
              canvas.style.marginLeft = oldMarginLeft;
              canvas.style.marginRight = oldMarginRight;
              canvas.style.marginTop = oldMarginTop;
              canvas.style.marginBottom = oldMarginBottom;
              document.body.style.margin = oldDocumentBodyMargin;
              document.documentElement.style.overflow = oldDocumentOverflow;
              document.body.scroll = oldDocumentScroll;
              canvas.style.imageRendering = oldImageRendering;
              if (canvas.GLctxObject)
                canvas.GLctxObject.GLctx.viewport(0, 0, oldWidth, oldHeight);
              if (currentFullscreenStrategy.canvasResizedCallback) {
                getWasmTableEntry(currentFullscreenStrategy.canvasResizedCallback)(37, 0, currentFullscreenStrategy.canvasResizedCallbackUserData);
              }
            }
          }
          document.addEventListener("fullscreenchange", restoreOldStyle);
          document.addEventListener("webkitfullscreenchange", restoreOldStyle);
          return restoreOldStyle;
        };
        var setLetterbox = (element, topBottom, leftRight) => {
          element.style.paddingLeft = element.style.paddingRight = leftRight + "px";
          element.style.paddingTop = element.style.paddingBottom = topBottom + "px";
        };
        var JSEvents_resizeCanvasForFullscreen = (target, strategy) => {
          var restoreOldStyle = registerRestoreOldStyle(target);
          var cssWidth = strategy.softFullscreen ? innerWidth : screen.width;
          var cssHeight = strategy.softFullscreen ? innerHeight : screen.height;
          var rect = getBoundingClientRect(target);
          var windowedCssWidth = rect.width;
          var windowedCssHeight = rect.height;
          var canvasSize = getCanvasElementSize(target);
          var windowedRttWidth = canvasSize[0];
          var windowedRttHeight = canvasSize[1];
          if (strategy.scaleMode == 3) {
            setLetterbox(target, (cssHeight - windowedCssHeight) / 2, (cssWidth - windowedCssWidth) / 2);
            cssWidth = windowedCssWidth;
            cssHeight = windowedCssHeight;
          } else if (strategy.scaleMode == 2) {
            if (cssWidth * windowedRttHeight < windowedRttWidth * cssHeight) {
              var desiredCssHeight = windowedRttHeight * cssWidth / windowedRttWidth;
              setLetterbox(target, (cssHeight - desiredCssHeight) / 2, 0);
              cssHeight = desiredCssHeight;
            } else {
              var desiredCssWidth = windowedRttWidth * cssHeight / windowedRttHeight;
              setLetterbox(target, 0, (cssWidth - desiredCssWidth) / 2);
              cssWidth = desiredCssWidth;
            }
          }
          if (!target.style.backgroundColor)
            target.style.backgroundColor = "black";
          if (!document.body.style.backgroundColor)
            document.body.style.backgroundColor = "black";
          target.style.width = cssWidth + "px";
          target.style.height = cssHeight + "px";
          if (strategy.filteringMode == 1) {
            target.style.imageRendering = "optimizeSpeed";
            target.style.imageRendering = "-moz-crisp-edges";
            target.style.imageRendering = "-o-crisp-edges";
            target.style.imageRendering = "-webkit-optimize-contrast";
            target.style.imageRendering = "optimize-contrast";
            target.style.imageRendering = "crisp-edges";
            target.style.imageRendering = "pixelated";
          }
          var dpiScale = strategy.canvasResolutionScaleMode == 2 ? devicePixelRatio : 1;
          if (strategy.canvasResolutionScaleMode != 0) {
            var newWidth = cssWidth * dpiScale | 0;
            var newHeight = cssHeight * dpiScale | 0;
            setCanvasElementSize(target, newWidth, newHeight);
            if (target.GLctxObject)
              target.GLctxObject.GLctx.viewport(0, 0, newWidth, newHeight);
          }
          return restoreOldStyle;
        };
        var JSEvents_requestFullscreen = (target, strategy) => {
          if (strategy.scaleMode != 0 || strategy.canvasResolutionScaleMode != 0) {
            JSEvents_resizeCanvasForFullscreen(target, strategy);
          }
          if (target.requestFullscreen) {
            target.requestFullscreen();
          } else if (target.webkitRequestFullscreen) {
            target.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
          } else {
            return JSEvents.fullscreenEnabled() ? -3 : -1;
          }
          currentFullscreenStrategy = strategy;
          if (strategy.canvasResizedCallback) {
            getWasmTableEntry(strategy.canvasResizedCallback)(37, 0, strategy.canvasResizedCallbackUserData);
          }
          return 0;
        };
        var hideEverythingExceptGivenElement = (onlyVisibleElement) => {
          var child = onlyVisibleElement;
          var parent = child.parentNode;
          var hiddenElements = [];
          while (child != document.body) {
            var children = parent.children;
            for (var i2 = 0; i2 < children.length; ++i2) {
              if (children[i2] != child) {
                hiddenElements.push({
                  node: children[i2],
                  displayState: children[i2].style.display
                });
                children[i2].style.display = "none";
              }
            }
            child = parent;
            parent = parent.parentNode;
          }
          return hiddenElements;
        };
        var restoreHiddenElements = (hiddenElements) => {
          for (var i2 = 0; i2 < hiddenElements.length; ++i2) {
            hiddenElements[i2].node.style.display = hiddenElements[i2].displayState;
          }
        };
        var currentFullscreenStrategy = {};
        var restoreOldWindowedStyle = null;
        var softFullscreenResizeWebGLRenderTarget = () => {
          var dpr = devicePixelRatio;
          var inHiDPIFullscreenMode = currentFullscreenStrategy.canvasResolutionScaleMode == 2;
          var inAspectRatioFixedFullscreenMode = currentFullscreenStrategy.scaleMode == 2;
          var inPixelPerfectFullscreenMode = currentFullscreenStrategy.canvasResolutionScaleMode != 0;
          var inCenteredWithoutScalingFullscreenMode = currentFullscreenStrategy.scaleMode == 3;
          var screenWidth = inHiDPIFullscreenMode ? Math.round(innerWidth * dpr) : innerWidth;
          var screenHeight = inHiDPIFullscreenMode ? Math.round(innerHeight * dpr) : innerHeight;
          var w = screenWidth;
          var h = screenHeight;
          var canvas = currentFullscreenStrategy.target;
          var canvasSize = getCanvasElementSize(canvas);
          var x = canvasSize[0];
          var y = canvasSize[1];
          var topMargin;
          if (inAspectRatioFixedFullscreenMode) {
            if (w * y < x * h)
              h = w * y / x | 0;
            else if (w * y > x * h)
              w = h * x / y | 0;
            topMargin = (screenHeight - h) / 2 | 0;
          }
          if (inPixelPerfectFullscreenMode) {
            setCanvasElementSize(canvas, w, h);
            if (canvas.GLctxObject)
              canvas.GLctxObject.GLctx.viewport(0, 0, w, h);
          }
          if (inHiDPIFullscreenMode) {
            topMargin /= dpr;
            w /= dpr;
            h /= dpr;
            w = Math.round(w * 1e4) / 1e4;
            h = Math.round(h * 1e4) / 1e4;
            topMargin = Math.round(topMargin * 1e4) / 1e4;
          }
          if (inCenteredWithoutScalingFullscreenMode) {
            var t = (innerHeight - jstoi_q(canvas.style.height)) / 2;
            var b = (innerWidth - jstoi_q(canvas.style.width)) / 2;
            setLetterbox(canvas, t, b);
          } else {
            canvas.style.width = w + "px";
            canvas.style.height = h + "px";
            var b = (innerWidth - w) / 2;
            setLetterbox(canvas, topMargin, b);
          }
          if (!inCenteredWithoutScalingFullscreenMode && currentFullscreenStrategy.canvasResizedCallback) {
            getWasmTableEntry(currentFullscreenStrategy.canvasResizedCallback)(37, 0, currentFullscreenStrategy.canvasResizedCallbackUserData);
          }
        };
        var doRequestFullscreen = (target, strategy) => {
          if (!JSEvents.fullscreenEnabled())
            return -1;
          target = findEventTarget(target);
          if (!target)
            return -4;
          if (!target.requestFullscreen && !target.webkitRequestFullscreen) {
            return -3;
          }
          var canPerformRequests = JSEvents.canPerformEventHandlerRequests();
          if (!canPerformRequests) {
            if (strategy.deferUntilInEventHandler) {
              JSEvents.deferCall(JSEvents_requestFullscreen, 1, [target, strategy]);
              return 1;
            }
            return -2;
          }
          return JSEvents_requestFullscreen(target, strategy);
        };
        function _emscripten_request_fullscreen(target, deferUntilInEventHandler) {
          target >>>= 0;
          var strategy = {
            scaleMode: 0,
            canvasResolutionScaleMode: 0,
            filteringMode: 0,
            deferUntilInEventHandler,
            canvasResizedCallbackTargetThread: 2
          };
          return doRequestFullscreen(target, strategy);
        }
        _emscripten_request_fullscreen.sig = "ipi";
        function _emscripten_request_fullscreen_strategy(target, deferUntilInEventHandler, fullscreenStrategy) {
          target >>>= 0;
          fullscreenStrategy >>>= 0;
          var strategy = {
            scaleMode: HEAP32[fullscreenStrategy >>> 2 >>> 0],
            canvasResolutionScaleMode: HEAP32[fullscreenStrategy + 4 >>> 2 >>> 0],
            filteringMode: HEAP32[fullscreenStrategy + 8 >>> 2 >>> 0],
            deferUntilInEventHandler,
            canvasResizedCallback: HEAP32[fullscreenStrategy + 12 >>> 2 >>> 0],
            canvasResizedCallbackUserData: HEAP32[fullscreenStrategy + 16 >>> 2 >>> 0]
          };
          return doRequestFullscreen(target, strategy);
        }
        _emscripten_request_fullscreen_strategy.sig = "ipip";
        function _emscripten_enter_soft_fullscreen(target, fullscreenStrategy) {
          target >>>= 0;
          fullscreenStrategy >>>= 0;
          target = findEventTarget(target);
          if (!target)
            return -4;
          var strategy = {
            scaleMode: HEAP32[fullscreenStrategy >>> 2 >>> 0],
            canvasResolutionScaleMode: HEAP32[fullscreenStrategy + 4 >>> 2 >>> 0],
            filteringMode: HEAP32[fullscreenStrategy + 8 >>> 2 >>> 0],
            canvasResizedCallback: HEAP32[fullscreenStrategy + 12 >>> 2 >>> 0],
            canvasResizedCallbackUserData: HEAP32[fullscreenStrategy + 16 >>> 2 >>> 0],
            target,
            softFullscreen: true
          };
          var restoreOldStyle = JSEvents_resizeCanvasForFullscreen(target, strategy);
          document.documentElement.style.overflow = "hidden";
          document.body.scroll = "no";
          document.body.style.margin = "0px";
          var hiddenElements = hideEverythingExceptGivenElement(target);
          function restoreWindowedState() {
            restoreOldStyle();
            restoreHiddenElements(hiddenElements);
            removeEventListener("resize", softFullscreenResizeWebGLRenderTarget);
            if (strategy.canvasResizedCallback) {
              getWasmTableEntry(strategy.canvasResizedCallback)(37, 0, strategy.canvasResizedCallbackUserData);
            }
            currentFullscreenStrategy = 0;
          }
          restoreOldWindowedStyle = restoreWindowedState;
          currentFullscreenStrategy = strategy;
          addEventListener("resize", softFullscreenResizeWebGLRenderTarget);
          if (strategy.canvasResizedCallback) {
            getWasmTableEntry(strategy.canvasResizedCallback)(37, 0, strategy.canvasResizedCallbackUserData);
          }
          return 0;
        }
        _emscripten_enter_soft_fullscreen.sig = "ipp";
        var _emscripten_exit_soft_fullscreen = () => {
          restoreOldWindowedStyle == null ? void 0 : restoreOldWindowedStyle();
          restoreOldWindowedStyle = null;
          return 0;
        };
        _emscripten_exit_soft_fullscreen.sig = "i";
        var _emscripten_exit_fullscreen = () => {
          if (!JSEvents.fullscreenEnabled())
            return -1;
          JSEvents.removeDeferredCalls(JSEvents_requestFullscreen);
          var d = specialHTMLTargets[1];
          if (d.exitFullscreen) {
            d.fullscreenElement && d.exitFullscreen();
          } else if (d.webkitExitFullscreen) {
            d.webkitFullscreenElement && d.webkitExitFullscreen();
          } else {
            return -1;
          }
          return 0;
        };
        _emscripten_exit_fullscreen.sig = "i";
        var fillPointerlockChangeEventData = (eventStruct) => {
          var pointerLockElement = document.pointerLockElement || document.mozPointerLockElement || document.webkitPointerLockElement || document.msPointerLockElement;
          var isPointerlocked = !!pointerLockElement;
          HEAP32[eventStruct >>> 2 >>> 0] = isPointerlocked;
          var nodeName = JSEvents.getNodeNameForTarget(pointerLockElement);
          var id = (pointerLockElement == null ? void 0 : pointerLockElement.id) || "";
          stringToUTF8(nodeName, eventStruct + 4, 128);
          stringToUTF8(id, eventStruct + 132, 128);
        };
        var registerPointerlockChangeEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
          if (!JSEvents.pointerlockChangeEvent)
            JSEvents.pointerlockChangeEvent = _malloc(260);
          var pointerlockChangeEventHandlerFunc = (e = event) => {
            var pointerlockChangeEvent = JSEvents.pointerlockChangeEvent;
            fillPointerlockChangeEventData(pointerlockChangeEvent);
            if (getWasmTableEntry(callbackfunc)(eventTypeId, pointerlockChangeEvent, userData))
              e.preventDefault();
          };
          var eventHandler = {
            target,
            eventTypeString,
            callbackfunc,
            handlerFunc: pointerlockChangeEventHandlerFunc,
            useCapture
          };
          return JSEvents.registerOrRemoveHandler(eventHandler);
        };
        function _emscripten_set_pointerlockchange_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
          target >>>= 0;
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          if (!document || !document.body || !document.body.requestPointerLock && !document.body.mozRequestPointerLock && !document.body.webkitRequestPointerLock && !document.body.msRequestPointerLock) {
            return -1;
          }
          target = findEventTarget(target);
          if (!target)
            return -4;
          registerPointerlockChangeEventCallback(target, userData, useCapture, callbackfunc, 20, "mozpointerlockchange", targetThread);
          registerPointerlockChangeEventCallback(target, userData, useCapture, callbackfunc, 20, "webkitpointerlockchange", targetThread);
          registerPointerlockChangeEventCallback(target, userData, useCapture, callbackfunc, 20, "mspointerlockchange", targetThread);
          return registerPointerlockChangeEventCallback(target, userData, useCapture, callbackfunc, 20, "pointerlockchange", targetThread);
        }
        _emscripten_set_pointerlockchange_callback_on_thread.sig = "ippipp";
        var registerPointerlockErrorEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
          var pointerlockErrorEventHandlerFunc = (e = event) => {
            if (getWasmTableEntry(callbackfunc)(eventTypeId, 0, userData))
              e.preventDefault();
          };
          var eventHandler = {
            target,
            eventTypeString,
            callbackfunc,
            handlerFunc: pointerlockErrorEventHandlerFunc,
            useCapture
          };
          return JSEvents.registerOrRemoveHandler(eventHandler);
        };
        function _emscripten_set_pointerlockerror_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
          target >>>= 0;
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          if (!document || !document.body.requestPointerLock && !document.body.mozRequestPointerLock && !document.body.webkitRequestPointerLock && !document.body.msRequestPointerLock) {
            return -1;
          }
          target = findEventTarget(target);
          if (!target)
            return -4;
          registerPointerlockErrorEventCallback(target, userData, useCapture, callbackfunc, 38, "mozpointerlockerror", targetThread);
          registerPointerlockErrorEventCallback(target, userData, useCapture, callbackfunc, 38, "webkitpointerlockerror", targetThread);
          registerPointerlockErrorEventCallback(target, userData, useCapture, callbackfunc, 38, "mspointerlockerror", targetThread);
          return registerPointerlockErrorEventCallback(target, userData, useCapture, callbackfunc, 38, "pointerlockerror", targetThread);
        }
        _emscripten_set_pointerlockerror_callback_on_thread.sig = "ippipp";
        function _emscripten_get_pointerlock_status(pointerlockStatus) {
          pointerlockStatus >>>= 0;
          if (pointerlockStatus)
            fillPointerlockChangeEventData(pointerlockStatus);
          if (!document.body || !document.body.requestPointerLock && !document.body.mozRequestPointerLock && !document.body.webkitRequestPointerLock && !document.body.msRequestPointerLock) {
            return -1;
          }
          return 0;
        }
        _emscripten_get_pointerlock_status.sig = "ip";
        var requestPointerLock = (target) => {
          if (target.requestPointerLock) {
            target.requestPointerLock();
          } else {
            if (document.body.requestPointerLock) {
              return -3;
            }
            return -1;
          }
          return 0;
        };
        function _emscripten_request_pointerlock(target, deferUntilInEventHandler) {
          target >>>= 0;
          target = findEventTarget(target);
          if (!target)
            return -4;
          if (!target.requestPointerLock) {
            return -1;
          }
          var canPerformRequests = JSEvents.canPerformEventHandlerRequests();
          if (!canPerformRequests) {
            if (deferUntilInEventHandler) {
              JSEvents.deferCall(requestPointerLock, 2, [target]);
              return 1;
            }
            return -2;
          }
          return requestPointerLock(target);
        }
        _emscripten_request_pointerlock.sig = "ipi";
        var _emscripten_exit_pointerlock = () => {
          JSEvents.removeDeferredCalls(requestPointerLock);
          if (document.exitPointerLock) {
            document.exitPointerLock();
          } else {
            return -1;
          }
          return 0;
        };
        _emscripten_exit_pointerlock.sig = "i";
        var _emscripten_vibrate = (msecs) => {
          if (!navigator.vibrate)
            return -1;
          navigator.vibrate(msecs);
          return 0;
        };
        _emscripten_vibrate.sig = "ii";
        function _emscripten_vibrate_pattern(msecsArray, numEntries) {
          msecsArray >>>= 0;
          if (!navigator.vibrate)
            return -1;
          var vibrateList = [];
          for (var i2 = 0; i2 < numEntries; ++i2) {
            var msecs = HEAP32[msecsArray + i2 * 4 >>> 2 >>> 0];
            vibrateList.push(msecs);
          }
          navigator.vibrate(vibrateList);
          return 0;
        }
        _emscripten_vibrate_pattern.sig = "ipi";
        var fillVisibilityChangeEventData = (eventStruct) => {
          var visibilityStates = ["hidden", "visible", "prerender", "unloaded"];
          var visibilityState = visibilityStates.indexOf(document.visibilityState);
          HEAP32[eventStruct >>> 2 >>> 0] = document.hidden;
          HEAP32[eventStruct + 4 >>> 2 >>> 0] = visibilityState;
        };
        var registerVisibilityChangeEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
          if (!JSEvents.visibilityChangeEvent)
            JSEvents.visibilityChangeEvent = _malloc(8);
          var visibilityChangeEventHandlerFunc = (e = event) => {
            var visibilityChangeEvent = JSEvents.visibilityChangeEvent;
            fillVisibilityChangeEventData(visibilityChangeEvent);
            if (getWasmTableEntry(callbackfunc)(eventTypeId, visibilityChangeEvent, userData))
              e.preventDefault();
          };
          var eventHandler = {
            target,
            eventTypeString,
            callbackfunc,
            handlerFunc: visibilityChangeEventHandlerFunc,
            useCapture
          };
          return JSEvents.registerOrRemoveHandler(eventHandler);
        };
        function _emscripten_set_visibilitychange_callback_on_thread(userData, useCapture, callbackfunc, targetThread) {
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          if (!specialHTMLTargets[1]) {
            return -4;
          }
          return registerVisibilityChangeEventCallback(specialHTMLTargets[1], userData, useCapture, callbackfunc, 21, "visibilitychange", targetThread);
        }
        _emscripten_set_visibilitychange_callback_on_thread.sig = "ipipp";
        function _emscripten_get_visibility_status(visibilityStatus) {
          visibilityStatus >>>= 0;
          if (typeof document.visibilityState == "undefined" && typeof document.hidden == "undefined") {
            return -1;
          }
          fillVisibilityChangeEventData(visibilityStatus);
          return 0;
        }
        _emscripten_get_visibility_status.sig = "ip";
        var registerTouchEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
          if (!JSEvents.touchEvent)
            JSEvents.touchEvent = _malloc(1696);
          target = findEventTarget(target);
          var touchEventHandlerFunc = (e) => {
            var t, touches = {}, et = e.touches;
            for (var i2 = 0; i2 < et.length; ++i2) {
              t = et[i2];
              t.isChanged = t.onTarget = 0;
              touches[t.identifier] = t;
            }
            for (var i2 = 0; i2 < e.changedTouches.length; ++i2) {
              t = e.changedTouches[i2];
              t.isChanged = 1;
              touches[t.identifier] = t;
            }
            for (var i2 = 0; i2 < e.targetTouches.length; ++i2) {
              touches[e.targetTouches[i2].identifier].onTarget = 1;
            }
            var touchEvent = JSEvents.touchEvent;
            HEAPF64[touchEvent >>> 3 >>> 0] = e.timeStamp;
            var idx = touchEvent >>> 2;
            HEAP32[idx + 3 >>> 0] = e.ctrlKey;
            HEAP32[idx + 4 >>> 0] = e.shiftKey;
            HEAP32[idx + 5 >>> 0] = e.altKey;
            HEAP32[idx + 6 >>> 0] = e.metaKey;
            idx += 7;
            var targetRect = getBoundingClientRect(target);
            var numTouches = 0;
            for (var i2 in touches) {
              t = touches[i2];
              HEAP32[idx + 0 >>> 0] = t.identifier;
              HEAP32[idx + 1 >>> 0] = t.screenX;
              HEAP32[idx + 2 >>> 0] = t.screenY;
              HEAP32[idx + 3 >>> 0] = t.clientX;
              HEAP32[idx + 4 >>> 0] = t.clientY;
              HEAP32[idx + 5 >>> 0] = t.pageX;
              HEAP32[idx + 6 >>> 0] = t.pageY;
              HEAP32[idx + 7 >>> 0] = t.isChanged;
              HEAP32[idx + 8 >>> 0] = t.onTarget;
              HEAP32[idx + 9 >>> 0] = t.clientX - targetRect.left;
              HEAP32[idx + 10 >>> 0] = t.clientY - targetRect.top;
              idx += 13;
              if (++numTouches > 31) {
                break;
              }
            }
            HEAP32[touchEvent + 8 >>> 2 >>> 0] = numTouches;
            if (getWasmTableEntry(callbackfunc)(eventTypeId, touchEvent, userData))
              e.preventDefault();
          };
          var eventHandler = {
            target,
            allowsDeferredCalls: eventTypeString == "touchstart" || eventTypeString == "touchend",
            eventTypeString,
            callbackfunc,
            handlerFunc: touchEventHandlerFunc,
            useCapture
          };
          return JSEvents.registerOrRemoveHandler(eventHandler);
        };
        function _emscripten_set_touchstart_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
          target >>>= 0;
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          return registerTouchEventCallback(target, userData, useCapture, callbackfunc, 22, "touchstart", targetThread);
        }
        _emscripten_set_touchstart_callback_on_thread.sig = "ippipp";
        function _emscripten_set_touchend_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
          target >>>= 0;
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          return registerTouchEventCallback(target, userData, useCapture, callbackfunc, 23, "touchend", targetThread);
        }
        _emscripten_set_touchend_callback_on_thread.sig = "ippipp";
        function _emscripten_set_touchmove_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
          target >>>= 0;
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          return registerTouchEventCallback(target, userData, useCapture, callbackfunc, 24, "touchmove", targetThread);
        }
        _emscripten_set_touchmove_callback_on_thread.sig = "ippipp";
        function _emscripten_set_touchcancel_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
          target >>>= 0;
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          return registerTouchEventCallback(target, userData, useCapture, callbackfunc, 25, "touchcancel", targetThread);
        }
        _emscripten_set_touchcancel_callback_on_thread.sig = "ippipp";
        var fillGamepadEventData = (eventStruct, e) => {
          HEAPF64[eventStruct >>> 3 >>> 0] = e.timestamp;
          for (var i2 = 0; i2 < e.axes.length; ++i2) {
            HEAPF64[eventStruct + i2 * 8 + 16 >>> 3 >>> 0] = e.axes[i2];
          }
          for (var i2 = 0; i2 < e.buttons.length; ++i2) {
            if (typeof e.buttons[i2] == "object") {
              HEAPF64[eventStruct + i2 * 8 + 528 >>> 3 >>> 0] = e.buttons[i2].value;
            } else {
              HEAPF64[eventStruct + i2 * 8 + 528 >>> 3 >>> 0] = e.buttons[i2];
            }
          }
          for (var i2 = 0; i2 < e.buttons.length; ++i2) {
            if (typeof e.buttons[i2] == "object") {
              HEAP32[eventStruct + i2 * 4 + 1040 >>> 2 >>> 0] = e.buttons[i2].pressed;
            } else {
              HEAP32[eventStruct + i2 * 4 + 1040 >>> 2 >>> 0] = e.buttons[i2] == 1;
            }
          }
          HEAP32[eventStruct + 1296 >>> 2 >>> 0] = e.connected;
          HEAP32[eventStruct + 1300 >>> 2 >>> 0] = e.index;
          HEAP32[eventStruct + 8 >>> 2 >>> 0] = e.axes.length;
          HEAP32[eventStruct + 12 >>> 2 >>> 0] = e.buttons.length;
          stringToUTF8(e.id, eventStruct + 1304, 64);
          stringToUTF8(e.mapping, eventStruct + 1368, 64);
        };
        var registerGamepadEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
          if (!JSEvents.gamepadEvent)
            JSEvents.gamepadEvent = _malloc(1432);
          var gamepadEventHandlerFunc = (e = event) => {
            var gamepadEvent = JSEvents.gamepadEvent;
            fillGamepadEventData(gamepadEvent, e["gamepad"]);
            if (getWasmTableEntry(callbackfunc)(eventTypeId, gamepadEvent, userData))
              e.preventDefault();
          };
          var eventHandler = {
            target: findEventTarget(target),
            allowsDeferredCalls: true,
            eventTypeString,
            callbackfunc,
            handlerFunc: gamepadEventHandlerFunc,
            useCapture
          };
          return JSEvents.registerOrRemoveHandler(eventHandler);
        };
        var _emscripten_sample_gamepad_data = () => {
          try {
            if (navigator.getGamepads)
              return (JSEvents.lastGamepadState = navigator.getGamepads()) ? 0 : -1;
          } catch (e) {
            navigator.getGamepads = null;
          }
          return -1;
        };
        _emscripten_sample_gamepad_data.sig = "i";
        function _emscripten_set_gamepadconnected_callback_on_thread(userData, useCapture, callbackfunc, targetThread) {
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          if (_emscripten_sample_gamepad_data())
            return -1;
          return registerGamepadEventCallback(2, userData, useCapture, callbackfunc, 26, "gamepadconnected", targetThread);
        }
        _emscripten_set_gamepadconnected_callback_on_thread.sig = "ipipp";
        function _emscripten_set_gamepaddisconnected_callback_on_thread(userData, useCapture, callbackfunc, targetThread) {
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          if (_emscripten_sample_gamepad_data())
            return -1;
          return registerGamepadEventCallback(2, userData, useCapture, callbackfunc, 27, "gamepaddisconnected", targetThread);
        }
        _emscripten_set_gamepaddisconnected_callback_on_thread.sig = "ipipp";
        var _emscripten_get_num_gamepads = () => JSEvents.lastGamepadState.length;
        _emscripten_get_num_gamepads.sig = "i";
        function _emscripten_get_gamepad_status(index, gamepadState) {
          gamepadState >>>= 0;
          if (index < 0 || index >= JSEvents.lastGamepadState.length)
            return -5;
          if (!JSEvents.lastGamepadState[index])
            return -7;
          fillGamepadEventData(gamepadState, JSEvents.lastGamepadState[index]);
          return 0;
        }
        _emscripten_get_gamepad_status.sig = "iip";
        var registerBeforeUnloadEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString) => {
          var beforeUnloadEventHandlerFunc = (e = event) => {
            var confirmationMessage = getWasmTableEntry(callbackfunc)(eventTypeId, 0, userData);
            if (confirmationMessage) {
              confirmationMessage = UTF8ToString(confirmationMessage);
            }
            if (confirmationMessage) {
              e.preventDefault();
              e.returnValue = confirmationMessage;
              return confirmationMessage;
            }
          };
          var eventHandler = {
            target: findEventTarget(target),
            eventTypeString,
            callbackfunc,
            handlerFunc: beforeUnloadEventHandlerFunc,
            useCapture
          };
          return JSEvents.registerOrRemoveHandler(eventHandler);
        };
        function _emscripten_set_beforeunload_callback_on_thread(userData, callbackfunc, targetThread) {
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          if (typeof onbeforeunload == "undefined")
            return -1;
          if (targetThread !== 1)
            return -5;
          return registerBeforeUnloadEventCallback(2, userData, true, callbackfunc, 28, "beforeunload");
        }
        _emscripten_set_beforeunload_callback_on_thread.sig = "ippp";
        var fillBatteryEventData = (eventStruct, e) => {
          HEAPF64[eventStruct >>> 3 >>> 0] = e.chargingTime;
          HEAPF64[eventStruct + 8 >>> 3 >>> 0] = e.dischargingTime;
          HEAPF64[eventStruct + 16 >>> 3 >>> 0] = e.level;
          HEAP32[eventStruct + 24 >>> 2 >>> 0] = e.charging;
        };
        var battery = () => navigator.battery || navigator.mozBattery || navigator.webkitBattery;
        var registerBatteryEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
          if (!JSEvents.batteryEvent)
            JSEvents.batteryEvent = _malloc(32);
          var batteryEventHandlerFunc = (e = event) => {
            var batteryEvent = JSEvents.batteryEvent;
            fillBatteryEventData(batteryEvent, battery());
            if (getWasmTableEntry(callbackfunc)(eventTypeId, batteryEvent, userData))
              e.preventDefault();
          };
          var eventHandler = {
            target: findEventTarget(target),
            eventTypeString,
            callbackfunc,
            handlerFunc: batteryEventHandlerFunc,
            useCapture
          };
          return JSEvents.registerOrRemoveHandler(eventHandler);
        };
        function _emscripten_set_batterychargingchange_callback_on_thread(userData, callbackfunc, targetThread) {
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          if (!battery())
            return -1;
          return registerBatteryEventCallback(battery(), userData, true, callbackfunc, 29, "chargingchange", targetThread);
        }
        _emscripten_set_batterychargingchange_callback_on_thread.sig = "ippp";
        function _emscripten_set_batterylevelchange_callback_on_thread(userData, callbackfunc, targetThread) {
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          if (!battery())
            return -1;
          return registerBatteryEventCallback(battery(), userData, true, callbackfunc, 30, "levelchange", targetThread);
        }
        _emscripten_set_batterylevelchange_callback_on_thread.sig = "ippp";
        function _emscripten_get_battery_status(batteryState) {
          batteryState >>>= 0;
          if (!battery())
            return -1;
          fillBatteryEventData(batteryState, battery());
          return 0;
        }
        _emscripten_get_battery_status.sig = "ip";
        function _emscripten_set_element_css_size(target, width, height) {
          target >>>= 0;
          target = findEventTarget(target);
          if (!target)
            return -4;
          target.style.width = width + "px";
          target.style.height = height + "px";
          return 0;
        }
        _emscripten_set_element_css_size.sig = "ipdd";
        function _emscripten_get_element_css_size(target, width, height) {
          target >>>= 0;
          width >>>= 0;
          height >>>= 0;
          target = findEventTarget(target);
          if (!target)
            return -4;
          var rect = getBoundingClientRect(target);
          HEAPF64[width >>> 3 >>> 0] = rect.width;
          HEAPF64[height >>> 3 >>> 0] = rect.height;
          return 0;
        }
        _emscripten_get_element_css_size.sig = "ippp";
        var _emscripten_html5_remove_all_event_listeners = () => JSEvents.removeAllEventListeners();
        _emscripten_html5_remove_all_event_listeners.sig = "v";
        var _emscripten_request_animation_frame = function(cb, userData) {
          cb >>>= 0;
          userData >>>= 0;
          return requestAnimationFrame((timeStamp) => getWasmTableEntry(cb)(timeStamp, userData));
        };
        _emscripten_request_animation_frame.sig = "ipp";
        var _emscripten_cancel_animation_frame = (id) => cancelAnimationFrame(id);
        _emscripten_cancel_animation_frame.sig = "vi";
        function _emscripten_request_animation_frame_loop(cb, userData) {
          cb >>>= 0;
          userData >>>= 0;
          function tick(timeStamp) {
            if (getWasmTableEntry(cb)(timeStamp, userData)) {
              requestAnimationFrame(tick);
            }
          }
          return requestAnimationFrame(tick);
        }
        _emscripten_request_animation_frame_loop.sig = "vpp";
        var _emscripten_performance_now = () => performance.now();
        _emscripten_performance_now.sig = "d";
        var _emscripten_get_device_pixel_ratio = () => typeof devicePixelRatio == "number" && devicePixelRatio || 1;
        _emscripten_get_device_pixel_ratio.sig = "d";
        var demangle = (func2) => func2;
        var demangleAll = (text) => {
          var regex = /\b_Z[\w\d_]+/g;
          return text.replace(regex, function(x) {
            var y = demangle(x);
            return x === y ? x : y + " [" + x + "]";
          });
        };
        function stackTrace() {
          var js = jsStackTrace();
          if (Module["extraStackTrace"])
            js += "\n" + Module["extraStackTrace"]();
          return demangleAll(js);
        }
        function _random_get(buf, buf_len) {
          buf >>>= 0;
          buf_len >>>= 0;
          try {
            _getentropy(buf, buf_len);
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return e.errno;
          }
        }
        _random_get.sig = "ipp";
        var checkWasiClock = (clock_id) => clock_id == 0 || clock_id == 1 || clock_id == 2 || clock_id == 3;
        function _clock_time_get(clk_id, ignored_precision_low, ignored_precision_high, ptime) {
          var ignored_precision = convertI32PairToI53Checked(ignored_precision_low, ignored_precision_high);
          ptime >>>= 0;
          if (!checkWasiClock(clk_id)) {
            return 28;
          }
          var now;
          if (clk_id === 0) {
            now = Date.now();
          } else if (nowIsMonotonic) {
            now = _emscripten_get_now();
          } else {
            return 52;
          }
          var nsec = Math.round(now * 1e3 * 1e3);
          HEAP32[ptime >>> 2 >>> 0] = nsec >>> 0;
          HEAP32[ptime + 4 >>> 2 >>> 0] = nsec / Math.pow(2, 32) >>> 0;
          return 0;
        }
        _clock_time_get.sig = "iiiip";
        function _clock_res_get(clk_id, pres) {
          pres >>>= 0;
          if (!checkWasiClock(clk_id)) {
            return 28;
          }
          var nsec;
          if (clk_id === 0) {
            nsec = 1e3 * 1e3;
          } else if (nowIsMonotonic) {
            nsec = _emscripten_get_now_res();
          } else {
            return 52;
          }
          HEAP32[pres >>> 2 >>> 0] = nsec >>> 0;
          HEAP32[pres + 4 >>> 2 >>> 0] = nsec / Math.pow(2, 32) >>> 0;
          return 0;
        }
        _clock_res_get.sig = "iip";
        var wasiRightsToMuslOFlags = (rights) => {
          if (rights & 2 && rights & 64) {
            return 2;
          }
          if (rights & 2) {
            return 0;
          }
          if (rights & 64) {
            return 1;
          }
          throw new FS.ErrnoError(28);
        };
        var wasiOFlagsToMuslOFlags = (oflags) => {
          var musl_oflags = 0;
          if (oflags & 1) {
            musl_oflags |= 64;
          }
          if (oflags & 8) {
            musl_oflags |= 512;
          }
          if (oflags & 2) {
            musl_oflags |= 65536;
          }
          if (oflags & 4) {
            musl_oflags |= 128;
          }
          return musl_oflags;
        };
        var _emscripten_unwind_to_js_event_loop = () => {
          throw "unwind";
        };
        _emscripten_unwind_to_js_event_loop.sig = "v";
        var setImmediateWrapped = (func2) => {
          setImmediateWrapped.mapping || (setImmediateWrapped.mapping = []);
          var id = setImmediateWrapped.mapping.length;
          setImmediateWrapped.mapping[id] = setImmediate(() => {
            setImmediateWrapped.mapping[id] = void 0;
            func2();
          });
          return id;
        };
        var clearImmediateWrapped = (id) => {
          clearImmediate(setImmediateWrapped.mapping[id]);
          setImmediateWrapped.mapping[id] = void 0;
        };
        var polyfillSetImmediate = () => {
        };
        var _emscripten_set_immediate = function(cb, userData) {
          cb >>>= 0;
          userData >>>= 0;
          return emSetImmediate(() => {
            callUserCallback(() => getWasmTableEntry(cb)(userData));
          });
        };
        _emscripten_set_immediate.sig = "ipp";
        var _emscripten_clear_immediate = (id) => {
          emClearImmediate(id);
        };
        _emscripten_clear_immediate.sig = "vi";
        var _emscripten_set_immediate_loop = function(cb, userData) {
          cb >>>= 0;
          userData >>>= 0;
          function tick() {
            callUserCallback(() => {
              if (getWasmTableEntry(cb)(userData)) {
                emSetImmediate(tick);
              } else {
              }
            });
          }
          emSetImmediate(tick);
        };
        _emscripten_set_immediate_loop.sig = "vpp";
        var _emscripten_set_timeout = function(cb, msecs, userData) {
          cb >>>= 0;
          userData >>>= 0;
          return safeSetTimeout(() => getWasmTableEntry(cb)(userData), msecs);
        };
        _emscripten_set_timeout.sig = "ipdp";
        var _emscripten_clear_timeout = clearTimeout;
        _emscripten_clear_timeout.sig = "vi";
        var _emscripten_set_timeout_loop = function(cb, msecs, userData) {
          cb >>>= 0;
          userData >>>= 0;
          function tick() {
            var t = _emscripten_get_now();
            var n = t + msecs;
            callUserCallback(() => {
              if (getWasmTableEntry(cb)(t, userData)) {
                setTimeout(tick, n - _emscripten_get_now());
              }
            });
          }
          return setTimeout(tick, 0);
        };
        _emscripten_set_timeout_loop.sig = "vpdp";
        var _emscripten_set_interval = function(cb, msecs, userData) {
          cb >>>= 0;
          userData >>>= 0;
          return setInterval(() => {
            callUserCallback(() => getWasmTableEntry(cb)(userData));
          }, msecs);
        };
        _emscripten_set_interval.sig = "ipdp";
        var _emscripten_clear_interval = (id) => {
          clearInterval(id);
        };
        _emscripten_clear_interval.sig = "vi";
        var idsToPromises = (idBuf, size) => {
          var promises = [];
          for (var i2 = 0; i2 < size; i2++) {
            var id = HEAP32[idBuf + i2 * 4 >>> 2 >>> 0];
            promises[i2] = getPromise(id);
          }
          return promises;
        };
        var makePromiseCallback = (callback, userData) => (value) => {
          var stack = stackSave();
          var resultPtr = stackAlloc(POINTER_SIZE);
          HEAPU32[resultPtr >>> 2 >>> 0] = 0;
          try {
            var result = getWasmTableEntry(callback)(resultPtr, userData, value);
            var resultVal = HEAPU32[resultPtr >>> 2 >>> 0];
          } catch (e) {
            if (typeof e !== "number") {
              throw 0;
            }
            throw e;
          } finally {
            stackRestore(stack);
          }
          switch (result) {
            case 0:
              return resultVal;
            case 1:
              return getPromise(resultVal);
            case 2:
              var ret = getPromise(resultVal);
              _emscripten_promise_destroy(resultVal);
              return ret;
            case 3:
              throw resultVal;
          }
        };
        function _emscripten_promise_then(id, onFulfilled, onRejected, userData) {
          id >>>= 0;
          onFulfilled >>>= 0;
          onRejected >>>= 0;
          userData >>>= 0;
          var promise = getPromise(id);
          var newId = promiseMap.allocate({
            promise: promise.then(makePromiseCallback(onFulfilled, userData), makePromiseCallback(onRejected, userData))
          });
          return newId;
        }
        _emscripten_promise_then.sig = "ppppp";
        var _emscripten_promise_all = function(idBuf, resultBuf, size) {
          idBuf >>>= 0;
          resultBuf >>>= 0;
          size >>>= 0;
          var promises = idsToPromises(idBuf, size);
          var id = promiseMap.allocate({
            promise: Promise.all(promises).then((results) => {
              if (resultBuf) {
                for (var i2 = 0; i2 < size; i2++) {
                  var result = results[i2];
                  HEAPU32[resultBuf + i2 * 4 >>> 2 >>> 0] = result;
                }
              }
              return resultBuf;
            })
          });
          return id;
        };
        _emscripten_promise_all.sig = "pppp";
        var setPromiseResult = (ptr2, fulfill, value) => {
          var result = fulfill ? 0 : 3;
          HEAP32[ptr2 >>> 2 >>> 0] = result;
          HEAPU32[ptr2 + 4 >>> 2 >>> 0] = value;
        };
        var _emscripten_promise_all_settled = function(idBuf, resultBuf, size) {
          idBuf >>>= 0;
          resultBuf >>>= 0;
          size >>>= 0;
          var promises = idsToPromises(idBuf, size);
          var id = promiseMap.allocate({
            promise: Promise.allSettled(promises).then((results) => {
              if (resultBuf) {
                var offset = resultBuf;
                for (var i2 = 0; i2 < size; i2++, offset += 8) {
                  if (results[i2].status === "fulfilled") {
                    setPromiseResult(offset, true, results[i2].value);
                  } else {
                    setPromiseResult(offset, false, results[i2].reason);
                  }
                }
              }
              return resultBuf;
            })
          });
          return id;
        };
        _emscripten_promise_all_settled.sig = "pppp";
        var _emscripten_promise_any = function(idBuf, errorBuf, size) {
          idBuf >>>= 0;
          errorBuf >>>= 0;
          size >>>= 0;
          var promises = idsToPromises(idBuf, size);
          var id = promiseMap.allocate({
            promise: Promise.any(promises).catch((err2) => {
              if (errorBuf) {
                for (var i2 = 0; i2 < size; i2++) {
                  HEAPU32[errorBuf + i2 * 4 >>> 2 >>> 0] = err2.errors[i2];
                }
              }
              throw errorBuf;
            })
          });
          return id;
        };
        _emscripten_promise_any.sig = "pppp";
        function _emscripten_promise_race(idBuf, size) {
          idBuf >>>= 0;
          size >>>= 0;
          var promises = idsToPromises(idBuf, size);
          var id = promiseMap.allocate({
            promise: Promise.race(promises)
          });
          return id;
        }
        _emscripten_promise_race.sig = "ppp";
        function _emscripten_promise_await(returnValuePtr, id) {
          returnValuePtr >>>= 0;
          id >>>= 0;
          abort("emscripten_promise_await is only available with ASYNCIFY");
        }
        _emscripten_promise_await.sig = "vpp";
        function ___cxa_get_exception_ptr(ptr2) {
          ptr2 >>>= 0;
          var rtn = new ExceptionInfo(ptr2).get_exception_ptr();
          return rtn;
        }
        ___cxa_get_exception_ptr.sig = "pp";
        function ___cxa_call_unexpected(exception) {
          exception >>>= 0;
          return abort("Unexpected exception thrown, this is not properly supported - aborting");
        }
        ___cxa_call_unexpected.sig = "vp";
        var getExceptionMessageCommon = (ptr2) => withStackSave(() => {
          var type_addr_addr = stackAlloc(4);
          var message_addr_addr = stackAlloc(4);
          ___get_exception_message(ptr2, type_addr_addr, message_addr_addr);
          var type_addr = HEAPU32[type_addr_addr >>> 2 >>> 0];
          var message_addr = HEAPU32[message_addr_addr >>> 2 >>> 0];
          var type = UTF8ToString(type_addr);
          _free(type_addr);
          var message;
          if (message_addr) {
            message = UTF8ToString(message_addr);
            _free(message_addr);
          }
          return [type, message];
        });
        var incrementExceptionRefcount = (ptr2) => ___cxa_increment_exception_refcount(ptr2);
        var decrementExceptionRefcount = (ptr2) => ___cxa_decrement_exception_refcount(ptr2);
        var getExceptionMessage = (ptr2) => getExceptionMessageCommon(ptr2);
        var _emscripten_run_preload_plugins = function(file, onload2, onerror2) {
          file >>>= 0;
          onload2 >>>= 0;
          onerror2 >>>= 0;
          var _file = UTF8ToString(file);
          var data2 = FS.analyzePath(_file);
          if (!data2.exists)
            return -1;
          FS.createPreloadedFile(PATH.dirname(_file), PATH.basename(_file), new Uint8Array(data2.object.contents), true, true, () => {
            if (onload2)
              getWasmTableEntry(onload2)(file);
          }, () => {
            if (onerror2)
              getWasmTableEntry(onerror2)(file);
          }, true);
          return 0;
        };
        _emscripten_run_preload_plugins.sig = "ippp";
        var Browser_asyncPrepareDataCounter = 0;
        var _emscripten_run_preload_plugins_data = function(data2, size, suffix, arg, onload2, onerror2) {
          data2 >>>= 0;
          suffix >>>= 0;
          arg >>>= 0;
          onload2 >>>= 0;
          onerror2 >>>= 0;
          var _suffix = UTF8ToString(suffix);
          var name2 = "prepare_data_" + Browser_asyncPrepareDataCounter++ + "." + _suffix;
          var cname = stringToNewUTF8(name2);
          FS.createPreloadedFile("/", name2, HEAPU8.subarray(data2 >>> 0, data2 + size >>> 0), true, true, () => {
            if (onload2)
              getWasmTableEntry(onload2)(arg, cname);
          }, () => {
            if (onerror2)
              getWasmTableEntry(onerror2)(arg);
          }, true);
        };
        _emscripten_run_preload_plugins_data.sig = "vpipppp";
        var _emscripten_async_run_script = function(script2, millis) {
          script2 >>>= 0;
          safeSetTimeout(() => _emscripten_run_script(script2), millis);
        };
        _emscripten_async_run_script.sig = "vpi";
        var _emscripten_async_load_script = function(url, onload, onerror) {
          url >>>= 0;
          onload >>>= 0;
          onerror >>>= 0;
          url = UTF8ToString(url);
          onload = getWasmTableEntry(onload);
          onerror = getWasmTableEntry(onerror);
          assert(runDependencies === 0, "async_load_script must be run when no other dependencies are active");
          var loadDone = () => {
            if (onload) {
              if (runDependencies > 0) {
                dependenciesFulfilled = onload;
              } else {
                onload();
              }
            }
          };
          var loadError = () => {
            onerror == null ? void 0 : onerror();
          };
          if (ENVIRONMENT_IS_NODE) {
            readAsync(url, (data) => {
              eval(data);
              loadDone();
            }, loadError, false);
            return;
          }
          var script = document.createElement("script");
          script.onload = loadDone;
          script.onerror = loadError;
          script.src = url;
          document.body.appendChild(script);
        };
        _emscripten_async_load_script.sig = "vppp";
        function _emscripten_get_main_loop_timing(mode, value) {
          mode >>>= 0;
          value >>>= 0;
          if (mode)
            HEAP32[mode >>> 2 >>> 0] = Browser.mainLoop.timingMode;
          if (value)
            HEAP32[value >>> 2 >>> 0] = Browser.mainLoop.timingValue;
        }
        _emscripten_get_main_loop_timing.sig = "vpp";
        function _emscripten_set_main_loop(func2, fps, simulateInfiniteLoop) {
          func2 >>>= 0;
          var browserIterationFunc = getWasmTableEntry(func2);
          setMainLoop(browserIterationFunc, fps, simulateInfiniteLoop);
        }
        _emscripten_set_main_loop.sig = "vpii";
        var _emscripten_set_main_loop_arg = function(func2, arg, fps, simulateInfiniteLoop) {
          func2 >>>= 0;
          arg >>>= 0;
          var browserIterationFunc = () => getWasmTableEntry(func2)(arg);
          setMainLoop(browserIterationFunc, fps, simulateInfiniteLoop, arg);
        };
        _emscripten_set_main_loop_arg.sig = "vppii";
        var _emscripten_cancel_main_loop = () => {
          Browser.mainLoop.pause();
          Browser.mainLoop.func = null;
        };
        _emscripten_cancel_main_loop.sig = "v";
        var _emscripten_pause_main_loop = () => {
          Browser.mainLoop.pause();
        };
        _emscripten_pause_main_loop.sig = "v";
        var _emscripten_resume_main_loop = () => {
          Browser.mainLoop.resume();
        };
        _emscripten_resume_main_loop.sig = "v";
        var __emscripten_push_main_loop_blocker = function(func2, arg, name2) {
          func2 >>>= 0;
          arg >>>= 0;
          name2 >>>= 0;
          Browser.mainLoop.queue.push({
            func: () => {
              getWasmTableEntry(func2)(arg);
            },
            name: UTF8ToString(name2),
            counted: true
          });
          Browser.mainLoop.updateStatus();
        };
        __emscripten_push_main_loop_blocker.sig = "vppp";
        var __emscripten_push_uncounted_main_loop_blocker = function(func2, arg, name2) {
          func2 >>>= 0;
          arg >>>= 0;
          name2 >>>= 0;
          Browser.mainLoop.queue.push({
            func: () => {
              getWasmTableEntry(func2)(arg);
            },
            name: UTF8ToString(name2),
            counted: false
          });
          Browser.mainLoop.updateStatus();
        };
        __emscripten_push_uncounted_main_loop_blocker.sig = "vppp";
        var _emscripten_set_main_loop_expected_blockers = (num) => {
          Browser.mainLoop.expectedBlockers = num;
          Browser.mainLoop.remainingBlockers = num;
          Browser.mainLoop.updateStatus();
        };
        _emscripten_set_main_loop_expected_blockers.sig = "vi";
        function _emscripten_async_call(func2, arg, millis) {
          func2 >>>= 0;
          arg >>>= 0;
          function wrapper() {
            getWasmTableEntry(func2)(arg);
          }
          if (millis >= 0 || ENVIRONMENT_IS_NODE) {
            safeSetTimeout(wrapper, millis);
          } else {
            Browser.safeRequestAnimationFrame(wrapper);
          }
        }
        _emscripten_async_call.sig = "vppi";
        function _emscripten_get_window_title() {
          var buflen = 256;
          if (!_emscripten_get_window_title.buffer) {
            _emscripten_get_window_title.buffer = _malloc(buflen);
          }
          stringToUTF8(document.title, _emscripten_get_window_title.buffer, buflen);
          return _emscripten_get_window_title.buffer;
        }
        _emscripten_get_window_title.sig = "p";
        function _emscripten_set_window_title(title) {
          title >>>= 0;
          return document.title = UTF8ToString(title);
        }
        _emscripten_set_window_title.sig = "vp";
        function _emscripten_get_screen_size(width, height) {
          width >>>= 0;
          height >>>= 0;
          HEAP32[width >>> 2 >>> 0] = screen.width;
          HEAP32[height >>> 2 >>> 0] = screen.height;
        }
        _emscripten_get_screen_size.sig = "vpp";
        var _emscripten_hide_mouse = () => {
          var styleSheet = document.styleSheets[0];
          var rules = styleSheet.cssRules;
          for (var i2 = 0; i2 < rules.length; i2++) {
            if (rules[i2].cssText.substr(0, 6) == "canvas") {
              styleSheet.deleteRule(i2);
              i2--;
            }
          }
          styleSheet.insertRule("canvas.emscripten { border: 1px solid black; cursor: none; }", 0);
        };
        _emscripten_hide_mouse.sig = "v";
        var _emscripten_set_canvas_size = (width, height) => {
          Browser.setCanvasSize(width, height);
        };
        _emscripten_set_canvas_size.sig = "vii";
        function _emscripten_get_canvas_size(width, height, isFullscreen) {
          width >>>= 0;
          height >>>= 0;
          isFullscreen >>>= 0;
          var canvas = Module["canvas"];
          HEAP32[width >>> 2 >>> 0] = canvas.width;
          HEAP32[height >>> 2 >>> 0] = canvas.height;
          HEAP32[isFullscreen >>> 2 >>> 0] = Browser.isFullscreen ? 1 : 0;
        }
        _emscripten_get_canvas_size.sig = "vppp";
        function _emscripten_create_worker(url2) {
          url2 >>>= 0;
          url2 = UTF8ToString(url2);
          var id = Browser.workers.length;
          var info2 = {
            worker: new Worker(url2),
            callbacks: [],
            awaited: 0,
            buffer: 0,
            bufferSize: 0
          };
          info2.worker.onmessage = function info_worker_onmessage(msg) {
            if (ABORT)
              return;
            var info3 = Browser.workers[id];
            if (!info3)
              return;
            var callbackId = msg.data["callbackId"];
            var callbackInfo = info3.callbacks[callbackId];
            if (!callbackInfo)
              return;
            if (msg.data["finalResponse"]) {
              info3.awaited--;
              info3.callbacks[callbackId] = null;
            }
            var data2 = msg.data["data"];
            if (data2) {
              if (!data2.byteLength)
                data2 = new Uint8Array(data2);
              if (!info3.buffer || info3.bufferSize < data2.length) {
                if (info3.buffer)
                  _free(info3.buffer);
                info3.bufferSize = data2.length;
                info3.buffer = _malloc(data2.length);
              }
              HEAPU8.set(data2, info3.buffer >>> 0);
              callbackInfo.func(info3.buffer, data2.length, callbackInfo.arg);
            } else {
              callbackInfo.func(0, 0, callbackInfo.arg);
            }
          };
          Browser.workers.push(info2);
          return id;
        }
        _emscripten_create_worker.sig = "ip";
        var _emscripten_destroy_worker = (id) => {
          var info2 = Browser.workers[id];
          info2.worker.terminate();
          if (info2.buffer)
            _free(info2.buffer);
          Browser.workers[id] = null;
        };
        _emscripten_destroy_worker.sig = "vi";
        function _emscripten_call_worker(id, funcName, data2, size, callback, arg) {
          funcName >>>= 0;
          data2 >>>= 0;
          callback >>>= 0;
          arg >>>= 0;
          funcName = UTF8ToString(funcName);
          var info2 = Browser.workers[id];
          var callbackId = -1;
          if (callback) {
            callbackId = info2.callbacks.length;
            info2.callbacks.push({
              func: getWasmTableEntry(callback),
              arg
            });
            info2.awaited++;
          }
          var transferObject = {
            "funcName": funcName,
            "callbackId": callbackId,
            "data": data2 ? new Uint8Array(HEAPU8.subarray(data2 >>> 0, data2 + size >>> 0)) : 0
          };
          if (data2) {
            info2.worker.postMessage(transferObject, [transferObject.data.buffer]);
          } else {
            info2.worker.postMessage(transferObject);
          }
        }
        _emscripten_call_worker.sig = "vippipp";
        var _emscripten_get_worker_queue_size = (id) => {
          var info2 = Browser.workers[id];
          if (!info2)
            return -1;
          return info2.awaited;
        };
        _emscripten_get_worker_queue_size.sig = "ii";
        function _emscripten_get_preloaded_image_data(path2, w, h) {
          path2 >>>= 0;
          w >>>= 0;
          h >>>= 0;
          if ((path2 | 0) === path2)
            path2 = UTF8ToString(path2);
          path2 = PATH_FS.resolve(path2);
          var canvas = preloadedImages[path2];
          if (canvas) {
            var ctx = canvas.getContext("2d");
            var image = ctx.getImageData(0, 0, canvas.width, canvas.height);
            var buf = _malloc(canvas.width * canvas.height * 4);
            HEAPU8.set(image.data, buf >>> 0);
            HEAP32[w >>> 2 >>> 0] = canvas.width;
            HEAP32[h >>> 2 >>> 0] = canvas.height;
            return buf;
          }
          return 0;
        }
        _emscripten_get_preloaded_image_data.sig = "pppp";
        function _emscripten_get_preloaded_image_data_from_FILE(file, w, h) {
          file >>>= 0;
          w >>>= 0;
          h >>>= 0;
          var fd = _fileno(file);
          var stream = FS.getStream(fd);
          if (stream) {
            return _emscripten_get_preloaded_image_data(stream.path, w, h);
          }
          return 0;
        }
        _emscripten_get_preloaded_image_data_from_FILE.sig = "pppp";
        var wget = {
          wgetRequests: {},
          nextWgetRequestHandle: 0,
          getNextWgetRequestHandle() {
            var handle2 = wget.nextWgetRequestHandle;
            wget.nextWgetRequestHandle++;
            return handle2;
          }
        };
        var FS_mkdirTree = (path2, mode) => FS.mkdirTree(path2, mode);
        var FS_unlink = (path2) => FS.unlink(path2);
        var _emscripten_async_wget = function(url2, file, onload2, onerror2) {
          url2 >>>= 0;
          file >>>= 0;
          onload2 >>>= 0;
          onerror2 >>>= 0;
          var _url = UTF8ToString(url2);
          var _file = UTF8ToString(file);
          _file = PATH_FS.resolve(_file);
          function doCallback(callback) {
            if (callback) {
              callUserCallback(() => {
                withStackSave(() => {
                  getWasmTableEntry(callback)(stringToUTF8OnStack(_file));
                });
              });
            }
          }
          var destinationDirectory = PATH.dirname(_file);
          FS_createPreloadedFile(destinationDirectory, PATH.basename(_file), _url, true, true, () => doCallback(onload2), () => doCallback(onerror2), false, false, () => {
            try {
              FS_unlink(_file);
            } catch (e) {
            }
            FS_mkdirTree(destinationDirectory);
          });
        };
        _emscripten_async_wget.sig = "vpppp";
        var _emscripten_async_wget_data = function(url2, userdata, onload2, onerror2) {
          url2 >>>= 0;
          userdata >>>= 0;
          onload2 >>>= 0;
          onerror2 >>>= 0;
          asyncLoad(UTF8ToString(url2), (byteArray) => {
            callUserCallback(() => {
              var buffer = _malloc(byteArray.length);
              HEAPU8.set(byteArray, buffer >>> 0);
              getWasmTableEntry(onload2)(userdata, buffer, byteArray.length);
              _free(buffer);
            });
          }, () => {
            if (onerror2) {
              callUserCallback(() => {
                getWasmTableEntry(onerror2)(userdata);
              });
            }
          }, true);
        };
        _emscripten_async_wget_data.sig = "vpppp";
        var _emscripten_async_wget2 = function(url2, file, request, param, userdata, onload2, onerror2, onprogress) {
          url2 >>>= 0;
          file >>>= 0;
          request >>>= 0;
          param >>>= 0;
          userdata >>>= 0;
          onload2 >>>= 0;
          onerror2 >>>= 0;
          onprogress >>>= 0;
          var _url = UTF8ToString(url2);
          var _file = UTF8ToString(file);
          _file = PATH_FS.resolve(_file);
          var _request = UTF8ToString(request);
          var _param = UTF8ToString(param);
          var index = _file.lastIndexOf("/");
          var http = new XMLHttpRequest();
          http.open(_request, _url, true);
          http.responseType = "arraybuffer";
          var handle2 = wget.getNextWgetRequestHandle();
          var destinationDirectory = PATH.dirname(_file);
          http.onload = (e) => {
            if (http.status >= 200 && http.status < 300) {
              try {
                FS.unlink(_file);
              } catch (e2) {
              }
              FS.mkdirTree(destinationDirectory);
              FS.createDataFile(_file.substr(0, index), _file.substr(index + 1), new Uint8Array(http.response), true, true, false);
              if (onload2) {
                withStackSave(() => {
                  getWasmTableEntry(onload2)(handle2, userdata, stringToUTF8OnStack(_file));
                });
              }
            } else {
              if (onerror2)
                getWasmTableEntry(onerror2)(handle2, userdata, http.status);
            }
            delete wget.wgetRequests[handle2];
          };
          http.onerror = (e) => {
            if (onerror2)
              getWasmTableEntry(onerror2)(handle2, userdata, http.status);
            delete wget.wgetRequests[handle2];
          };
          http.onprogress = (e) => {
            if (e.lengthComputable || e.lengthComputable === void 0 && e.total != 0) {
              var percentComplete = e.loaded / e.total * 100;
              if (onprogress)
                getWasmTableEntry(onprogress)(handle2, userdata, percentComplete);
            }
          };
          http.onabort = (e) => {
            delete wget.wgetRequests[handle2];
          };
          if (_request == "POST") {
            http.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
            http.send(_param);
          } else {
            http.send(null);
          }
          wget.wgetRequests[handle2] = http;
          return handle2;
        };
        _emscripten_async_wget2.sig = "ipppppppp";
        var _emscripten_async_wget2_data = function(url2, request, param, userdata, free, onload2, onerror2, onprogress) {
          url2 >>>= 0;
          request >>>= 0;
          param >>>= 0;
          userdata >>>= 0;
          onload2 >>>= 0;
          onerror2 >>>= 0;
          onprogress >>>= 0;
          var _url = UTF8ToString(url2);
          var _request = UTF8ToString(request);
          var _param = UTF8ToString(param);
          var http = new XMLHttpRequest();
          http.open(_request, _url, true);
          http.responseType = "arraybuffer";
          var handle2 = wget.getNextWgetRequestHandle();
          function onerrorjs() {
            if (onerror2) {
              withStackSave(() => {
                var statusText = 0;
                if (http.statusText) {
                  statusText = stringToUTF8OnStack(http.statusText);
                }
                getWasmTableEntry(onerror2)(handle2, userdata, http.status, statusText);
              });
            }
          }
          http.onload = (e) => {
            if (http.status >= 200 && http.status < 300 || http.status === 0 && _url.substr(0, 4).toLowerCase() != "http") {
              var byteArray = new Uint8Array(http.response);
              var buffer = _malloc(byteArray.length);
              HEAPU8.set(byteArray, buffer >>> 0);
              if (onload2)
                getWasmTableEntry(onload2)(handle2, userdata, buffer, byteArray.length);
              if (free)
                _free(buffer);
            } else {
              onerrorjs();
            }
            delete wget.wgetRequests[handle2];
          };
          http.onerror = (e) => {
            onerrorjs();
            delete wget.wgetRequests[handle2];
          };
          http.onprogress = (e) => {
            if (onprogress)
              getWasmTableEntry(onprogress)(handle2, userdata, e.loaded, e.lengthComputable || e.lengthComputable === void 0 ? e.total : 0);
          };
          http.onabort = (e) => {
            delete wget.wgetRequests[handle2];
          };
          if (_request == "POST") {
            http.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
            http.send(_param);
          } else {
            http.send(null);
          }
          wget.wgetRequests[handle2] = http;
          return handle2;
        };
        _emscripten_async_wget2_data.sig = "ippppippp";
        var _emscripten_async_wget2_abort = (handle2) => {
          var http = wget.wgetRequests[handle2];
          http == null ? void 0 : http.abort();
        };
        _emscripten_async_wget2_abort.sig = "vi";
        function __dlsym_catchup_js(handle2, symbolIndex) {
          handle2 >>>= 0;
          var lib = LDSO.loadedLibsByHandle[handle2];
          var symDict = lib.exports;
          var symName = Object.keys(symDict)[symbolIndex];
          var sym = symDict[symName];
          var result = addFunction(sym, sym.sig);
          return result;
        }
        __dlsym_catchup_js.sig = "ppi";
        var _setNetworkCallback = (event2, userData, callback) => {
          function _callback(data2) {
            try {
              if (event2 === "error") {
                withStackSave(function() {
                  var msg = stringToUTF8OnStack(data2[2]);
                  getWasmTableEntry(callback)(data2[0], data2[1], msg, userData);
                });
              } else {
                getWasmTableEntry(callback)(data2, userData);
              }
            } catch (e) {
              if (!(e instanceof ExitStatus)) {
                if (e && typeof e == "object" && e.stack)
                  err("exception thrown: " + [e, e.stack]);
                throw e;
              }
            }
          }
          Module["websocket"]["on"](event2, callback ? _callback : null);
        };
        function _emscripten_set_socket_error_callback(userData, callback) {
          userData >>>= 0;
          callback >>>= 0;
          _setNetworkCallback("error", userData, callback);
        }
        _emscripten_set_socket_error_callback.sig = "vpp";
        function _emscripten_set_socket_open_callback(userData, callback) {
          userData >>>= 0;
          callback >>>= 0;
          _setNetworkCallback("open", userData, callback);
        }
        _emscripten_set_socket_open_callback.sig = "vpp";
        function _emscripten_set_socket_listen_callback(userData, callback) {
          userData >>>= 0;
          callback >>>= 0;
          _setNetworkCallback("listen", userData, callback);
        }
        _emscripten_set_socket_listen_callback.sig = "vpp";
        function _emscripten_set_socket_connection_callback(userData, callback) {
          userData >>>= 0;
          callback >>>= 0;
          _setNetworkCallback("connection", userData, callback);
        }
        _emscripten_set_socket_connection_callback.sig = "vpp";
        function _emscripten_set_socket_message_callback(userData, callback) {
          userData >>>= 0;
          callback >>>= 0;
          _setNetworkCallback("message", userData, callback);
        }
        _emscripten_set_socket_message_callback.sig = "vpp";
        function _emscripten_set_socket_close_callback(userData, callback) {
          userData >>>= 0;
          callback >>>= 0;
          _setNetworkCallback("close", userData, callback);
        }
        _emscripten_set_socket_close_callback.sig = "vpp";
        function _emscripten_webgl_enable_ANGLE_instanced_arrays(ctx) {
          ctx >>>= 0;
          return webgl_enable_ANGLE_instanced_arrays(GL.contexts[ctx].GLctx);
        }
        _emscripten_webgl_enable_ANGLE_instanced_arrays.sig = "ip";
        function _emscripten_webgl_enable_OES_vertex_array_object(ctx) {
          ctx >>>= 0;
          return webgl_enable_OES_vertex_array_object(GL.contexts[ctx].GLctx);
        }
        _emscripten_webgl_enable_OES_vertex_array_object.sig = "ip";
        function _emscripten_webgl_enable_WEBGL_draw_buffers(ctx) {
          ctx >>>= 0;
          return webgl_enable_WEBGL_draw_buffers(GL.contexts[ctx].GLctx);
        }
        _emscripten_webgl_enable_WEBGL_draw_buffers.sig = "ip";
        function _emscripten_webgl_enable_WEBGL_multi_draw(ctx) {
          ctx >>>= 0;
          return webgl_enable_WEBGL_multi_draw(GL.contexts[ctx].GLctx);
        }
        _emscripten_webgl_enable_WEBGL_multi_draw.sig = "ip";
        function _glVertexPointer(size, type, stride, ptr2) {
          ptr2 >>>= 0;
          throw "Legacy GL function (glVertexPointer) called. If you want legacy GL emulation, you need to compile with -sLEGACY_GL_EMULATION to enable legacy GL emulation.";
        }
        _glVertexPointer.sig = "viiip";
        var _glMatrixMode = () => {
          throw "Legacy GL function (glMatrixMode) called. If you want legacy GL emulation, you need to compile with -sLEGACY_GL_EMULATION to enable legacy GL emulation.";
        };
        _glMatrixMode.sig = "vi";
        var _glBegin = () => {
          throw "Legacy GL function (glBegin) called. If you want legacy GL emulation, you need to compile with -sLEGACY_GL_EMULATION to enable legacy GL emulation.";
        };
        _glBegin.sig = "vi";
        var _glLoadIdentity = () => {
          throw "Legacy GL function (glLoadIdentity) called. If you want legacy GL emulation, you need to compile with -sLEGACY_GL_EMULATION to enable legacy GL emulation.";
        };
        _glLoadIdentity.sig = "v";
        var _glVertexAttribDivisorNV = _glVertexAttribDivisor;
        var _glDrawArraysInstancedNV = _glDrawArraysInstanced;
        var _glDrawElementsInstancedNV = _glDrawElementsInstanced;
        var _glVertexAttribDivisorEXT = _glVertexAttribDivisor;
        var _glDrawArraysInstancedEXT = _glDrawArraysInstanced;
        var _glDrawElementsInstancedEXT = _glDrawElementsInstanced;
        var _glVertexAttribDivisorARB = _glVertexAttribDivisor;
        var _glDrawArraysInstancedARB = _glDrawArraysInstanced;
        var _glDrawElementsInstancedARB = _glDrawElementsInstanced;
        var _glDrawBuffersEXT = _glDrawBuffers;
        function _glMultiDrawArraysWEBGL(mode, firsts, counts, drawcount) {
          firsts >>>= 0;
          counts >>>= 0;
          GLctx.multiDrawWebgl["multiDrawArraysWEBGL"](mode, HEAP32, firsts >> 2, HEAP32, counts >> 2, drawcount);
        }
        _glMultiDrawArraysWEBGL.sig = "vippi";
        var _glMultiDrawArrays = _glMultiDrawArraysWEBGL;
        _glMultiDrawArrays.sig = "vippi";
        var _glMultiDrawArraysANGLE = _glMultiDrawArraysWEBGL;
        function _glMultiDrawArraysInstancedWEBGL(mode, firsts, counts, instanceCounts, drawcount) {
          firsts >>>= 0;
          counts >>>= 0;
          instanceCounts >>>= 0;
          GLctx.multiDrawWebgl["multiDrawArraysInstancedWEBGL"](mode, HEAP32, firsts >> 2, HEAP32, counts >> 2, HEAP32, instanceCounts >> 2, drawcount);
        }
        _glMultiDrawArraysInstancedWEBGL.sig = "vipppi";
        var _glMultiDrawArraysInstancedANGLE = _glMultiDrawArraysInstancedWEBGL;
        function _glMultiDrawElementsWEBGL(mode, counts, type, offsets, drawcount) {
          counts >>>= 0;
          offsets >>>= 0;
          GLctx.multiDrawWebgl["multiDrawElementsWEBGL"](mode, HEAP32, counts >> 2, type, HEAP32, offsets >> 2, drawcount);
        }
        _glMultiDrawElementsWEBGL.sig = "vipipi";
        var _glMultiDrawElements = _glMultiDrawElementsWEBGL;
        _glMultiDrawElements.sig = "vipipi";
        var _glMultiDrawElementsANGLE = _glMultiDrawElementsWEBGL;
        function _glMultiDrawElementsInstancedWEBGL(mode, counts, type, offsets, instanceCounts, drawcount) {
          counts >>>= 0;
          offsets >>>= 0;
          instanceCounts >>>= 0;
          GLctx.multiDrawWebgl["multiDrawElementsInstancedWEBGL"](mode, HEAP32, counts >> 2, type, HEAP32, offsets >> 2, HEAP32, instanceCounts >> 2, drawcount);
        }
        _glMultiDrawElementsInstancedWEBGL.sig = "vipippi";
        var _glMultiDrawElementsInstancedANGLE = _glMultiDrawElementsInstancedWEBGL;
        function _glClearDepth(x0) {
          GLctx.clearDepth(x0);
        }
        _glClearDepth.sig = "vd";
        function _glDepthRange(x0, x1) {
          GLctx.depthRange(x0, x1);
        }
        _glDepthRange.sig = "vdd";
        var _emscripten_glGenVertexArrays = _glGenVertexArrays;
        var _emscripten_glDeleteVertexArrays = _glDeleteVertexArrays;
        var _emscripten_glBindVertexArray = _glBindVertexArray;
        var _emscripten_glIsVertexArray = _glIsVertexArray;
        var _emscripten_glVertexPointer = _glVertexPointer;
        var _emscripten_glMatrixMode = _glMatrixMode;
        var _emscripten_glBegin = _glBegin;
        var _emscripten_glLoadIdentity = _glLoadIdentity;
        var _emscripten_glVertexAttribDivisor = _glVertexAttribDivisor;
        var _emscripten_glDrawArraysInstanced = _glDrawArraysInstanced;
        var _emscripten_glDrawElementsInstanced = _glDrawElementsInstanced;
        var _emscripten_glVertexAttribDivisorNV = _glVertexAttribDivisorNV;
        var _emscripten_glDrawArraysInstancedNV = _glDrawArraysInstancedNV;
        var _emscripten_glDrawElementsInstancedNV = _glDrawElementsInstancedNV;
        var _emscripten_glVertexAttribDivisorEXT = _glVertexAttribDivisorEXT;
        var _emscripten_glDrawArraysInstancedEXT = _glDrawArraysInstancedEXT;
        var _emscripten_glDrawElementsInstancedEXT = _glDrawElementsInstancedEXT;
        var _emscripten_glVertexAttribDivisorARB = _glVertexAttribDivisorARB;
        var _emscripten_glDrawArraysInstancedARB = _glDrawArraysInstancedARB;
        var _emscripten_glDrawElementsInstancedARB = _glDrawElementsInstancedARB;
        var _emscripten_glDrawBuffers = _glDrawBuffers;
        var _emscripten_glDrawBuffersEXT = _glDrawBuffersEXT;
        var _emscripten_glMultiDrawArrays = _glMultiDrawArrays;
        var _emscripten_glMultiDrawArraysANGLE = _glMultiDrawArraysANGLE;
        var _emscripten_glMultiDrawArraysWEBGL = _glMultiDrawArraysWEBGL;
        var _emscripten_glMultiDrawArraysInstancedANGLE = _glMultiDrawArraysInstancedANGLE;
        var _emscripten_glMultiDrawArraysInstancedWEBGL = _glMultiDrawArraysInstancedWEBGL;
        var _emscripten_glMultiDrawElements = _glMultiDrawElements;
        var _emscripten_glMultiDrawElementsANGLE = _glMultiDrawElementsANGLE;
        var _emscripten_glMultiDrawElementsWEBGL = _glMultiDrawElementsWEBGL;
        var _emscripten_glMultiDrawElementsInstancedANGLE = _glMultiDrawElementsInstancedANGLE;
        var _emscripten_glMultiDrawElementsInstancedWEBGL = _glMultiDrawElementsInstancedWEBGL;
        var _emscripten_glClearDepth = _glClearDepth;
        var _emscripten_glDepthRange = _glDepthRange;
        var writeGLArray = (arr, dst, dstLength, heapType) => {
          var len2 = arr.length;
          var writeLength = dstLength < len2 ? dstLength : len2;
          var heap = heapType ? HEAPF32 : HEAP32;
          for (var i2 = 0; i2 < writeLength; ++i2) {
            heap[(dst >> 2) + i2 >>> 0] = arr[i2];
          }
          return len2;
        };
        function _emscripten_webgl_init_context_attributes(attributes) {
          attributes >>>= 0;
          var a = attributes >> 2;
          for (var i2 = 0; i2 < 56 >> 2; ++i2) {
            HEAP32[a + i2 >>> 0] = 0;
          }
          HEAP32[a + (0 >> 2) >>> 0] = HEAP32[a + (4 >> 2) >>> 0] = HEAP32[a + (12 >> 2) >>> 0] = HEAP32[a + (16 >> 2) >>> 0] = HEAP32[a + (32 >> 2) >>> 0] = HEAP32[a + (40 >> 2) >>> 0] = 1;
        }
        _emscripten_webgl_init_context_attributes.sig = "vp";
        var emscripten_webgl_power_preferences = ["default", "low-power", "high-performance"];
        function _emscripten_webgl_do_create_context(target, attributes) {
          target >>>= 0;
          attributes >>>= 0;
          var a = attributes >> 2;
          var powerPreference = HEAP32[a + (24 >> 2) >>> 0];
          var contextAttributes = {
            "alpha": !!HEAP32[a + (0 >> 2) >>> 0],
            "depth": !!HEAP32[a + (4 >> 2) >>> 0],
            "stencil": !!HEAP32[a + (8 >> 2) >>> 0],
            "antialias": !!HEAP32[a + (12 >> 2) >>> 0],
            "premultipliedAlpha": !!HEAP32[a + (16 >> 2) >>> 0],
            "preserveDrawingBuffer": !!HEAP32[a + (20 >> 2) >>> 0],
            "powerPreference": emscripten_webgl_power_preferences[powerPreference],
            "failIfMajorPerformanceCaveat": !!HEAP32[a + (28 >> 2) >>> 0],
            majorVersion: HEAP32[a + (32 >> 2) >>> 0],
            minorVersion: HEAP32[a + (36 >> 2) >>> 0],
            enableExtensionsByDefault: HEAP32[a + (40 >> 2) >>> 0],
            explicitSwapControl: HEAP32[a + (44 >> 2) >>> 0],
            proxyContextToMainThread: HEAP32[a + (48 >> 2) >>> 0],
            renderViaOffscreenBackBuffer: HEAP32[a + (52 >> 2) >>> 0]
          };
          var canvas = findCanvasEventTarget(target);
          if (!canvas) {
            return 0;
          }
          if (contextAttributes.explicitSwapControl) {
            return 0;
          }
          var contextHandle = GL.createContext(canvas, contextAttributes);
          return contextHandle;
        }
        _emscripten_webgl_do_create_context.sig = "ppp";
        var _emscripten_webgl_create_context = _emscripten_webgl_do_create_context;
        _emscripten_webgl_create_context.sig = "ppp";
        function _emscripten_webgl_do_get_current_context() {
          return GL.currentContext ? GL.currentContext.handle : 0;
        }
        _emscripten_webgl_do_get_current_context.sig = "p";
        var _emscripten_webgl_get_current_context = _emscripten_webgl_do_get_current_context;
        _emscripten_webgl_get_current_context.sig = "p";
        var _emscripten_webgl_do_commit_frame = () => {
          if (!GL.currentContext || !GL.currentContext.GLctx) {
            return -3;
          }
          if (!GL.currentContext.attributes.explicitSwapControl) {
            return -3;
          }
          return 0;
        };
        _emscripten_webgl_do_commit_frame.sig = "i";
        var _emscripten_webgl_commit_frame = _emscripten_webgl_do_commit_frame;
        _emscripten_webgl_commit_frame.sig = "i";
        function _emscripten_webgl_make_context_current(contextHandle) {
          contextHandle >>>= 0;
          var success = GL.makeContextCurrent(contextHandle);
          return success ? 0 : -5;
        }
        _emscripten_webgl_make_context_current.sig = "ip";
        function _emscripten_webgl_get_drawing_buffer_size(contextHandle, width, height) {
          contextHandle >>>= 0;
          width >>>= 0;
          height >>>= 0;
          var GLContext = GL.getContext(contextHandle);
          if (!GLContext || !GLContext.GLctx || !width || !height) {
            return -5;
          }
          HEAP32[width >>> 2 >>> 0] = GLContext.GLctx.drawingBufferWidth;
          HEAP32[height >>> 2 >>> 0] = GLContext.GLctx.drawingBufferHeight;
          return 0;
        }
        _emscripten_webgl_get_drawing_buffer_size.sig = "ippp";
        function _emscripten_webgl_get_context_attributes(c, a) {
          c >>>= 0;
          a >>>= 0;
          if (!a)
            return -5;
          c = GL.contexts[c];
          if (!c)
            return -3;
          var t = c.GLctx;
          if (!t)
            return -3;
          t = t.getContextAttributes();
          HEAP32[a >>> 2 >>> 0] = t.alpha;
          HEAP32[a + 4 >>> 2 >>> 0] = t.depth;
          HEAP32[a + 8 >>> 2 >>> 0] = t.stencil;
          HEAP32[a + 12 >>> 2 >>> 0] = t.antialias;
          HEAP32[a + 16 >>> 2 >>> 0] = t.premultipliedAlpha;
          HEAP32[a + 20 >>> 2 >>> 0] = t.preserveDrawingBuffer;
          var power = t["powerPreference"] && emscripten_webgl_power_preferences.indexOf(t["powerPreference"]);
          HEAP32[a + 24 >>> 2 >>> 0] = power;
          HEAP32[a + 28 >>> 2 >>> 0] = t.failIfMajorPerformanceCaveat;
          HEAP32[a + 32 >>> 2 >>> 0] = c.version;
          HEAP32[a + 36 >>> 2 >>> 0] = 0;
          HEAP32[a + 40 >>> 2 >>> 0] = c.attributes.enableExtensionsByDefault;
          return 0;
        }
        _emscripten_webgl_get_context_attributes.sig = "ipp";
        function _emscripten_webgl_destroy_context(contextHandle) {
          contextHandle >>>= 0;
          if (GL.currentContext == contextHandle)
            GL.currentContext = 0;
          GL.deleteContext(contextHandle);
        }
        _emscripten_webgl_destroy_context.sig = "ip";
        function _emscripten_webgl_enable_extension(contextHandle, extension) {
          contextHandle >>>= 0;
          extension >>>= 0;
          var context = GL.getContext(contextHandle);
          var extString = UTF8ToString(extension);
          if (extString.startsWith("GL_"))
            extString = extString.substr(3);
          if (extString == "ANGLE_instanced_arrays")
            webgl_enable_ANGLE_instanced_arrays(GLctx);
          if (extString == "OES_vertex_array_object")
            webgl_enable_OES_vertex_array_object(GLctx);
          if (extString == "WEBGL_draw_buffers")
            webgl_enable_WEBGL_draw_buffers(GLctx);
          if (extString == "WEBGL_multi_draw")
            webgl_enable_WEBGL_multi_draw(GLctx);
          var ext = context.GLctx.getExtension(extString);
          return !!ext;
        }
        _emscripten_webgl_enable_extension.sig = "ipp";
        var _emscripten_supports_offscreencanvas = () => 0;
        _emscripten_supports_offscreencanvas.sig = "i";
        var registerWebGlEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
          var webGlEventHandlerFunc = (e = event) => {
            if (getWasmTableEntry(callbackfunc)(eventTypeId, 0, userData))
              e.preventDefault();
          };
          var eventHandler = {
            target: findEventTarget(target),
            eventTypeString,
            callbackfunc,
            handlerFunc: webGlEventHandlerFunc,
            useCapture
          };
          JSEvents.registerOrRemoveHandler(eventHandler);
        };
        function _emscripten_set_webglcontextlost_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
          target >>>= 0;
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          registerWebGlEventCallback(target, userData, useCapture, callbackfunc, 31, "webglcontextlost", targetThread);
          return 0;
        }
        _emscripten_set_webglcontextlost_callback_on_thread.sig = "ippipp";
        function _emscripten_set_webglcontextrestored_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
          target >>>= 0;
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          registerWebGlEventCallback(target, userData, useCapture, callbackfunc, 32, "webglcontextrestored", targetThread);
          return 0;
        }
        _emscripten_set_webglcontextrestored_callback_on_thread.sig = "ippipp";
        function _emscripten_is_webgl_context_lost(contextHandle) {
          contextHandle >>>= 0;
          return !GL.contexts[contextHandle] || GL.contexts[contextHandle].GLctx.isContextLost();
        }
        _emscripten_is_webgl_context_lost.sig = "ip";
        function _emscripten_webgl_get_supported_extensions() {
          return stringToNewUTF8(GLctx.getSupportedExtensions().join(" "));
        }
        _emscripten_webgl_get_supported_extensions.sig = "p";
        var _emscripten_webgl_get_program_parameter_d = (program, param) => GLctx.getProgramParameter(GL.programs[program], param);
        _emscripten_webgl_get_program_parameter_d.sig = "dii";
        function _emscripten_webgl_get_program_info_log_utf8(program) {
          return stringToNewUTF8(GLctx.getProgramInfoLog(GL.programs[program]));
        }
        _emscripten_webgl_get_program_info_log_utf8.sig = "pi";
        var _emscripten_webgl_get_shader_parameter_d = (shader, param) => GLctx.getShaderParameter(GL.shaders[shader], param);
        _emscripten_webgl_get_shader_parameter_d.sig = "dii";
        function _emscripten_webgl_get_shader_info_log_utf8(shader) {
          return stringToNewUTF8(GLctx.getShaderInfoLog(GL.shaders[shader]));
        }
        _emscripten_webgl_get_shader_info_log_utf8.sig = "pi";
        function _emscripten_webgl_get_shader_source_utf8(shader) {
          return stringToNewUTF8(GLctx.getShaderSource(GL.shaders[shader]));
        }
        _emscripten_webgl_get_shader_source_utf8.sig = "pi";
        var _emscripten_webgl_get_vertex_attrib_d = (index, param) => GLctx.getVertexAttrib(index, param);
        _emscripten_webgl_get_vertex_attrib_d.sig = "dii";
        var _emscripten_webgl_get_vertex_attrib_o = (index, param) => {
          var obj = GLctx.getVertexAttrib(index, param);
          return obj == null ? void 0 : obj.name;
        };
        _emscripten_webgl_get_vertex_attrib_o.sig = "iii";
        function _emscripten_webgl_get_vertex_attrib_v(index, param, dst, dstLength, dstType) {
          dst >>>= 0;
          return writeGLArray(GLctx.getVertexAttrib(index, param), dst, dstLength, dstType);
        }
        _emscripten_webgl_get_vertex_attrib_v.sig = "iiipii";
        var _emscripten_webgl_get_uniform_d = (program, location) => GLctx.getUniform(GL.programs[program], webglGetUniformLocation(location));
        _emscripten_webgl_get_uniform_d.sig = "dii";
        function _emscripten_webgl_get_uniform_v(program, location, dst, dstLength, dstType) {
          dst >>>= 0;
          return writeGLArray(GLctx.getUniform(GL.programs[program], webglGetUniformLocation(location)), dst, dstLength, dstType);
        }
        _emscripten_webgl_get_uniform_v.sig = "iiipii";
        function _emscripten_webgl_get_parameter_v(param, dst, dstLength, dstType) {
          dst >>>= 0;
          return writeGLArray(GLctx.getParameter(param), dst, dstLength, dstType);
        }
        _emscripten_webgl_get_parameter_v.sig = "iipii";
        var _emscripten_webgl_get_parameter_d = (param) => GLctx.getParameter(param);
        _emscripten_webgl_get_parameter_d.sig = "di";
        var _emscripten_webgl_get_parameter_o = (param) => {
          var obj = GLctx.getParameter(param);
          return obj == null ? void 0 : obj.name;
        };
        _emscripten_webgl_get_parameter_o.sig = "ii";
        function _emscripten_webgl_get_parameter_utf8(param) {
          return stringToNewUTF8(GLctx.getParameter(param));
        }
        _emscripten_webgl_get_parameter_utf8.sig = "pi";
        function _emscripten_webgl_get_parameter_i64v(param, dst) {
          dst >>>= 0;
          return writeI53ToI64(dst, GLctx.getParameter(param));
        }
        _emscripten_webgl_get_parameter_i64v.sig = "vip";
        var _glutPostRedisplay = () => {
          if (GLUT.displayFunc && !GLUT.requestedAnimationFrame) {
            GLUT.requestedAnimationFrame = true;
            Browser.requestAnimationFrame(function() {
              GLUT.requestedAnimationFrame = false;
              Browser.mainLoop.runIter(function() {
                getWasmTableEntry(GLUT.displayFunc)();
              });
            });
          }
        };
        _glutPostRedisplay.sig = "v";
        var GLUT = {
          initTime: null,
          idleFunc: null,
          displayFunc: null,
          keyboardFunc: null,
          keyboardUpFunc: null,
          specialFunc: null,
          specialUpFunc: null,
          reshapeFunc: null,
          motionFunc: null,
          passiveMotionFunc: null,
          mouseFunc: null,
          buttons: 0,
          modifiers: 0,
          initWindowWidth: 256,
          initWindowHeight: 256,
          initDisplayMode: 18,
          windowX: 0,
          windowY: 0,
          windowWidth: 0,
          windowHeight: 0,
          requestedAnimationFrame: false,
          saveModifiers: (event2) => {
            GLUT.modifiers = 0;
            if (event2["shiftKey"])
              GLUT.modifiers += 1;
            if (event2["ctrlKey"])
              GLUT.modifiers += 2;
            if (event2["altKey"])
              GLUT.modifiers += 4;
          },
          onMousemove: (event2) => {
            var lastX = Browser.mouseX;
            var lastY = Browser.mouseY;
            Browser.calculateMouseEvent(event2);
            var newX = Browser.mouseX;
            var newY = Browser.mouseY;
            if (newX == lastX && newY == lastY)
              return;
            if (GLUT.buttons == 0 && event2.target == Module["canvas"] && GLUT.passiveMotionFunc) {
              event2.preventDefault();
              GLUT.saveModifiers(event2);
              getWasmTableEntry(GLUT.passiveMotionFunc)(lastX, lastY);
            } else if (GLUT.buttons != 0 && GLUT.motionFunc) {
              event2.preventDefault();
              GLUT.saveModifiers(event2);
              getWasmTableEntry(GLUT.motionFunc)(lastX, lastY);
            }
          },
          getSpecialKey: (keycode) => {
            var key = null;
            switch (keycode) {
              case 8:
                key = 120;
                break;
              case 46:
                key = 111;
                break;
              case 112:
                key = 1;
                break;
              case 113:
                key = 2;
                break;
              case 114:
                key = 3;
                break;
              case 115:
                key = 4;
                break;
              case 116:
                key = 5;
                break;
              case 117:
                key = 6;
                break;
              case 118:
                key = 7;
                break;
              case 119:
                key = 8;
                break;
              case 120:
                key = 9;
                break;
              case 121:
                key = 10;
                break;
              case 122:
                key = 11;
                break;
              case 123:
                key = 12;
                break;
              case 37:
                key = 100;
                break;
              case 38:
                key = 101;
                break;
              case 39:
                key = 102;
                break;
              case 40:
                key = 103;
                break;
              case 33:
                key = 104;
                break;
              case 34:
                key = 105;
                break;
              case 36:
                key = 106;
                break;
              case 35:
                key = 107;
                break;
              case 45:
                key = 108;
                break;
              case 16:
              case 5:
                key = 112;
                break;
              case 6:
                key = 113;
                break;
              case 17:
              case 3:
                key = 114;
                break;
              case 4:
                key = 115;
                break;
              case 18:
              case 2:
                key = 116;
                break;
              case 1:
                key = 117;
                break;
            }
            return key;
          },
          getASCIIKey: (event2) => {
            if (event2["ctrlKey"] || event2["altKey"] || event2["metaKey"])
              return null;
            var keycode = event2["keyCode"];
            if (48 <= keycode && keycode <= 57)
              return keycode;
            if (65 <= keycode && keycode <= 90)
              return event2["shiftKey"] ? keycode : keycode + 32;
            if (96 <= keycode && keycode <= 105)
              return keycode - 48;
            if (106 <= keycode && keycode <= 111)
              return keycode - 106 + 42;
            switch (keycode) {
              case 9:
              case 13:
              case 27:
              case 32:
              case 61:
                return keycode;
            }
            var s2 = event2["shiftKey"];
            switch (keycode) {
              case 186:
                return s2 ? 58 : 59;
              case 187:
                return s2 ? 43 : 61;
              case 188:
                return s2 ? 60 : 44;
              case 189:
                return s2 ? 95 : 45;
              case 190:
                return s2 ? 62 : 46;
              case 191:
                return s2 ? 63 : 47;
              case 219:
                return s2 ? 123 : 91;
              case 220:
                return s2 ? 124 : 47;
              case 221:
                return s2 ? 125 : 93;
              case 222:
                return s2 ? 34 : 39;
            }
            return null;
          },
          onKeydown: (event2) => {
            if (GLUT.specialFunc || GLUT.keyboardFunc) {
              var key = GLUT.getSpecialKey(event2["keyCode"]);
              if (key !== null) {
                if (GLUT.specialFunc) {
                  event2.preventDefault();
                  GLUT.saveModifiers(event2);
                  getWasmTableEntry(GLUT.specialFunc)(key, Browser.mouseX, Browser.mouseY);
                }
              } else {
                key = GLUT.getASCIIKey(event2);
                if (key !== null && GLUT.keyboardFunc) {
                  event2.preventDefault();
                  GLUT.saveModifiers(event2);
                  getWasmTableEntry(GLUT.keyboardFunc)(key, Browser.mouseX, Browser.mouseY);
                }
              }
            }
          },
          onKeyup: (event2) => {
            if (GLUT.specialUpFunc || GLUT.keyboardUpFunc) {
              var key = GLUT.getSpecialKey(event2["keyCode"]);
              if (key !== null) {
                if (GLUT.specialUpFunc) {
                  event2.preventDefault();
                  GLUT.saveModifiers(event2);
                  getWasmTableEntry(GLUT.specialUpFunc)(key, Browser.mouseX, Browser.mouseY);
                }
              } else {
                key = GLUT.getASCIIKey(event2);
                if (key !== null && GLUT.keyboardUpFunc) {
                  event2.preventDefault();
                  GLUT.saveModifiers(event2);
                  getWasmTableEntry(GLUT.keyboardUpFunc)(key, Browser.mouseX, Browser.mouseY);
                }
              }
            }
          },
          touchHandler: (event2) => {
            if (event2.target != Module["canvas"]) {
              return;
            }
            var touches = event2.changedTouches, main = touches[0], type = "";
            switch (event2.type) {
              case "touchstart":
                type = "mousedown";
                break;
              case "touchmove":
                type = "mousemove";
                break;
              case "touchend":
                type = "mouseup";
                break;
              default:
                return;
            }
            var simulatedEvent = document.createEvent("MouseEvent");
            simulatedEvent.initMouseEvent(type, true, true, window, 1, main.screenX, main.screenY, main.clientX, main.clientY, false, false, false, false, 0, null);
            main.target.dispatchEvent(simulatedEvent);
            event2.preventDefault();
          },
          onMouseButtonDown: (event2) => {
            Browser.calculateMouseEvent(event2);
            GLUT.buttons |= 1 << event2["button"];
            if (event2.target == Module["canvas"] && GLUT.mouseFunc) {
              try {
                event2.target.setCapture();
              } catch (e) {
              }
              event2.preventDefault();
              GLUT.saveModifiers(event2);
              getWasmTableEntry(GLUT.mouseFunc)(event2["button"], 0, Browser.mouseX, Browser.mouseY);
            }
          },
          onMouseButtonUp: (event2) => {
            Browser.calculateMouseEvent(event2);
            GLUT.buttons &= ~(1 << event2["button"]);
            if (GLUT.mouseFunc) {
              event2.preventDefault();
              GLUT.saveModifiers(event2);
              getWasmTableEntry(GLUT.mouseFunc)(event2["button"], 1, Browser.mouseX, Browser.mouseY);
            }
          },
          onMouseWheel: (event2) => {
            Browser.calculateMouseEvent(event2);
            var e = window.event || event2;
            var delta = -Browser.getMouseWheelDelta(event2);
            delta = delta == 0 ? 0 : delta > 0 ? Math.max(delta, 1) : Math.min(delta, -1);
            var button = 3;
            if (delta < 0) {
              button = 4;
            }
            if (GLUT.mouseFunc) {
              event2.preventDefault();
              GLUT.saveModifiers(event2);
              getWasmTableEntry(GLUT.mouseFunc)(button, 0, Browser.mouseX, Browser.mouseY);
            }
          },
          onFullscreenEventChange: (event2) => {
            var width;
            var height;
            if (document["fullscreen"] || document["fullScreen"] || document["mozFullScreen"] || document["webkitIsFullScreen"]) {
              width = screen["width"];
              height = screen["height"];
            } else {
              width = GLUT.windowWidth;
              height = GLUT.windowHeight;
              document.removeEventListener("fullscreenchange", GLUT.onFullscreenEventChange, true);
              document.removeEventListener("mozfullscreenchange", GLUT.onFullscreenEventChange, true);
              document.removeEventListener("webkitfullscreenchange", GLUT.onFullscreenEventChange, true);
            }
            Browser.setCanvasSize(width, height, true);
            if (GLUT.reshapeFunc) {
              getWasmTableEntry(GLUT.reshapeFunc)(width, height);
            }
            _glutPostRedisplay();
          }
        };
        var _glutGetModifiers = () => GLUT.modifiers;
        _glutGetModifiers.sig = "i";
        function _glutInit(argcp, argv) {
          argcp >>>= 0;
          argv >>>= 0;
          GLUT.initTime = Date.now();
          var isTouchDevice = "ontouchstart" in document.documentElement;
          if (isTouchDevice) {
            window.addEventListener("touchmove", GLUT.touchHandler, true);
            window.addEventListener("touchstart", GLUT.touchHandler, true);
            window.addEventListener("touchend", GLUT.touchHandler, true);
          }
          window.addEventListener("keydown", GLUT.onKeydown, true);
          window.addEventListener("keyup", GLUT.onKeyup, true);
          window.addEventListener("mousemove", GLUT.onMousemove, true);
          window.addEventListener("mousedown", GLUT.onMouseButtonDown, true);
          window.addEventListener("mouseup", GLUT.onMouseButtonUp, true);
          window.addEventListener("mousewheel", GLUT.onMouseWheel, true);
          window.addEventListener("DOMMouseScroll", GLUT.onMouseWheel, true);
          Browser.resizeListeners.push(function(width, height) {
            if (GLUT.reshapeFunc) {
              getWasmTableEntry(GLUT.reshapeFunc)(width, height);
            }
          });
          __ATEXIT__.push(function() {
            if (isTouchDevice) {
              window.removeEventListener("touchmove", GLUT.touchHandler, true);
              window.removeEventListener("touchstart", GLUT.touchHandler, true);
              window.removeEventListener("touchend", GLUT.touchHandler, true);
            }
            window.removeEventListener("keydown", GLUT.onKeydown, true);
            window.removeEventListener("keyup", GLUT.onKeyup, true);
            window.removeEventListener("mousemove", GLUT.onMousemove, true);
            window.removeEventListener("mousedown", GLUT.onMouseButtonDown, true);
            window.removeEventListener("mouseup", GLUT.onMouseButtonUp, true);
            window.removeEventListener("mousewheel", GLUT.onMouseWheel, true);
            window.removeEventListener("DOMMouseScroll", GLUT.onMouseWheel, true);
            Module["canvas"].width = Module["canvas"].height = 1;
          });
        }
        _glutInit.sig = "vpp";
        var _glutInitWindowSize = (width, height) => {
          Browser.setCanvasSize(GLUT.initWindowWidth = width, GLUT.initWindowHeight = height);
        };
        _glutInitWindowSize.sig = "vii";
        var _glutInitWindowPosition = (x, y) => {
        };
        _glutInitWindowPosition.sig = "vii";
        var _glutGet = (type) => {
          switch (type) {
            case 100:
              return 0;
            case 101:
              return 0;
            case 102:
              return Module["canvas"].width;
            case 103:
              return Module["canvas"].height;
            case 200:
              return Module["canvas"].width;
            case 201:
              return Module["canvas"].height;
            case 500:
              return 0;
            case 501:
              return 0;
            case 502:
              return GLUT.initWindowWidth;
            case 503:
              return GLUT.initWindowHeight;
            case 700:
              var now = Date.now();
              return now - GLUT.initTime;
            case 105:
              return Module.ctx.getContextAttributes().stencil ? 8 : 0;
            case 106:
              return Module.ctx.getContextAttributes().depth ? 8 : 0;
            case 110:
              return Module.ctx.getContextAttributes().alpha ? 8 : 0;
            case 120:
              return Module.ctx.getContextAttributes().antialias ? 1 : 0;
            default:
              throw "glutGet(" + type + ") not implemented yet";
          }
        };
        _glutGet.sig = "ii";
        function _glutIdleFunc(func2) {
          func2 >>>= 0;
          function callback() {
            if (GLUT.idleFunc) {
              getWasmTableEntry(GLUT.idleFunc)();
              safeSetTimeout(callback, 4);
            }
          }
          if (!GLUT.idleFunc) {
            safeSetTimeout(callback, 0);
          }
          GLUT.idleFunc = func2;
        }
        _glutIdleFunc.sig = "vp";
        var _glutTimerFunc = function(msec, func2, value) {
          func2 >>>= 0;
          return safeSetTimeout(() => getWasmTableEntry(func2)(value), msec);
        };
        _glutTimerFunc.sig = "vipi";
        function _glutDisplayFunc(func2) {
          func2 >>>= 0;
          GLUT.displayFunc = func2;
        }
        _glutDisplayFunc.sig = "vp";
        function _glutKeyboardFunc(func2) {
          func2 >>>= 0;
          GLUT.keyboardFunc = func2;
        }
        _glutKeyboardFunc.sig = "vp";
        function _glutKeyboardUpFunc(func2) {
          func2 >>>= 0;
          GLUT.keyboardUpFunc = func2;
        }
        _glutKeyboardUpFunc.sig = "vp";
        function _glutSpecialFunc(func2) {
          func2 >>>= 0;
          GLUT.specialFunc = func2;
        }
        _glutSpecialFunc.sig = "vp";
        function _glutSpecialUpFunc(func2) {
          func2 >>>= 0;
          GLUT.specialUpFunc = func2;
        }
        _glutSpecialUpFunc.sig = "vp";
        function _glutReshapeFunc(func2) {
          func2 >>>= 0;
          GLUT.reshapeFunc = func2;
        }
        _glutReshapeFunc.sig = "vp";
        function _glutMotionFunc(func2) {
          func2 >>>= 0;
          GLUT.motionFunc = func2;
        }
        _glutMotionFunc.sig = "vp";
        function _glutPassiveMotionFunc(func2) {
          func2 >>>= 0;
          GLUT.passiveMotionFunc = func2;
        }
        _glutPassiveMotionFunc.sig = "vp";
        function _glutMouseFunc(func2) {
          func2 >>>= 0;
          GLUT.mouseFunc = func2;
        }
        _glutMouseFunc.sig = "vp";
        var _glutSetCursor = (cursor) => {
          var cursorStyle = "auto";
          switch (cursor) {
            case 0:
              break;
            case 1:
              break;
            case 2:
              cursorStyle = "pointer";
              break;
            case 3:
              break;
            case 4:
              cursorStyle = "help";
              break;
            case 5:
              break;
            case 6:
              break;
            case 7:
              cursorStyle = "wait";
              break;
            case 8:
              cursorStyle = "text";
              break;
            case 9:
            case 102:
              cursorStyle = "crosshair";
              break;
            case 10:
              cursorStyle = "ns-resize";
              break;
            case 11:
              cursorStyle = "ew-resize";
              break;
            case 12:
              cursorStyle = "n-resize";
              break;
            case 13:
              cursorStyle = "s-resize";
              break;
            case 14:
              cursorStyle = "w-resize";
              break;
            case 15:
              cursorStyle = "e-resize";
              break;
            case 16:
              cursorStyle = "nw-resize";
              break;
            case 17:
              cursorStyle = "ne-resize";
              break;
            case 18:
              cursorStyle = "se-resize";
              break;
            case 19:
              cursorStyle = "sw-resize";
              break;
            case 100:
              break;
            case 101:
              cursorStyle = "none";
              break;
            default:
              throw "glutSetCursor: Unknown cursor type: " + cursor;
          }
          Module["canvas"].style.cursor = cursorStyle;
        };
        _glutSetCursor.sig = "vi";
        function _glutCreateWindow(name2) {
          name2 >>>= 0;
          var contextAttributes = {
            antialias: (GLUT.initDisplayMode & 128) != 0,
            depth: (GLUT.initDisplayMode & 16) != 0,
            stencil: (GLUT.initDisplayMode & 32) != 0,
            alpha: (GLUT.initDisplayMode & 8) != 0
          };
          Module.ctx = Browser.createContext(Module["canvas"], true, true, contextAttributes);
          return Module.ctx ? 1 : 0;
        }
        _glutCreateWindow.sig = "ip";
        var _glutDestroyWindow = (name2) => {
          Module.ctx = Browser.destroyContext(Module["canvas"], true, true);
          return 1;
        };
        _glutDestroyWindow.sig = "vi";
        var _glutReshapeWindow = (width, height) => {
          Browser.exitFullscreen();
          Browser.setCanvasSize(width, height, true);
          if (GLUT.reshapeFunc) {
            getWasmTableEntry(GLUT.reshapeFunc)(width, height);
          }
          _glutPostRedisplay();
        };
        _glutReshapeWindow.sig = "vii";
        var _glutPositionWindow = (x, y) => {
          Browser.exitFullscreen();
          _glutPostRedisplay();
        };
        _glutPositionWindow.sig = "vii";
        var _glutFullScreen = () => {
          GLUT.windowX = 0;
          GLUT.windowY = 0;
          GLUT.windowWidth = Module["canvas"].width;
          GLUT.windowHeight = Module["canvas"].height;
          document.addEventListener("fullscreenchange", GLUT.onFullscreenEventChange, true);
          document.addEventListener("mozfullscreenchange", GLUT.onFullscreenEventChange, true);
          document.addEventListener("webkitfullscreenchange", GLUT.onFullscreenEventChange, true);
          Browser.requestFullscreen(false, false);
        };
        _glutFullScreen.sig = "v";
        var _glutInitDisplayMode = (mode) => GLUT.initDisplayMode = mode;
        _glutInitDisplayMode.sig = "vi";
        var _glutSwapBuffers = () => {
        };
        _glutSwapBuffers.sig = "v";
        var _glutMainLoop = () => {
          _glutReshapeWindow(Module["canvas"].width, Module["canvas"].height);
          _glutPostRedisplay();
          throw "unwind";
        };
        _glutMainLoop.sig = "v";
        function _XOpenDisplay(name2) {
          name2 >>>= 0;
          return 1;
        }
        _XOpenDisplay.sig = "pp";
        function _XCreateWindow(display, parent, x, y, width, height, border_width, depth, class_, visual, valuemask, attributes) {
          display >>>= 0;
          parent >>>= 0;
          visual >>>= 0;
          valuemask >>>= 0;
          attributes >>>= 0;
          Browser.setCanvasSize(width, height);
          return 2;
        }
        _XCreateWindow.sig = "pppiiiiiiippp";
        function _XChangeWindowAttributes(display, window2, valuemask, attributes) {
          display >>>= 0;
          window2 >>>= 0;
          valuemask >>>= 0;
          attributes >>>= 0;
        }
        _XChangeWindowAttributes.sig = "ipppp";
        function _XSetWMHints(display, win, hints) {
          display >>>= 0;
          win >>>= 0;
          hints >>>= 0;
        }
        _XSetWMHints.sig = "ippp";
        function _XMapWindow(display, win) {
          display >>>= 0;
          win >>>= 0;
        }
        _XMapWindow.sig = "ipp";
        function _XStoreName(display, win, name2) {
          display >>>= 0;
          win >>>= 0;
          name2 >>>= 0;
        }
        _XStoreName.sig = "ippp";
        function _XInternAtom(display, name_, hmm) {
          display >>>= 0;
          name_ >>>= 0;
          return 0;
        }
        _XInternAtom.sig = "pppi";
        function _XSendEvent(display, win, propagate, event_mask, even_send) {
          display >>>= 0;
          win >>>= 0;
          event_mask >>>= 0;
          even_send >>>= 0;
        }
        _XSendEvent.sig = "ippipp";
        function _XPending(display) {
          display >>>= 0;
          return 0;
        }
        _XPending.sig = "ip";
        var EGL = {
          errorCode: 12288,
          defaultDisplayInitialized: false,
          currentContext: 0,
          currentReadSurface: 0,
          currentDrawSurface: 0,
          contextAttributes: {
            alpha: false,
            depth: false,
            stencil: false,
            antialias: false
          },
          stringCache: {},
          setErrorCode(code) {
            EGL.errorCode = code;
          },
          chooseConfig(display, attribList, config, config_size, numConfigs) {
            if (display != 62e3) {
              EGL.setErrorCode(12296);
              return 0;
            }
            if (attribList) {
              for (; ; ) {
                var param = HEAP32[attribList >>> 2 >>> 0];
                if (param == 12321) {
                  var alphaSize = HEAP32[attribList + 4 >>> 2 >>> 0];
                  EGL.contextAttributes.alpha = alphaSize > 0;
                } else if (param == 12325) {
                  var depthSize = HEAP32[attribList + 4 >>> 2 >>> 0];
                  EGL.contextAttributes.depth = depthSize > 0;
                } else if (param == 12326) {
                  var stencilSize = HEAP32[attribList + 4 >>> 2 >>> 0];
                  EGL.contextAttributes.stencil = stencilSize > 0;
                } else if (param == 12337) {
                  var samples = HEAP32[attribList + 4 >>> 2 >>> 0];
                  EGL.contextAttributes.antialias = samples > 0;
                } else if (param == 12338) {
                  var samples = HEAP32[attribList + 4 >>> 2 >>> 0];
                  EGL.contextAttributes.antialias = samples == 1;
                } else if (param == 12544) {
                  var requestedPriority = HEAP32[attribList + 4 >>> 2 >>> 0];
                  EGL.contextAttributes.lowLatency = requestedPriority != 12547;
                } else if (param == 12344) {
                  break;
                }
                attribList += 8;
              }
            }
            if ((!config || !config_size) && !numConfigs) {
              EGL.setErrorCode(12300);
              return 0;
            }
            if (numConfigs) {
              HEAP32[numConfigs >>> 2 >>> 0] = 1;
            }
            if (config && config_size > 0) {
              HEAPU32[config >>> 2 >>> 0] = 62002;
            }
            EGL.setErrorCode(12288);
            return 1;
          }
        };
        function _eglGetDisplay(nativeDisplayType) {
          nativeDisplayType >>>= 0;
          EGL.setErrorCode(12288);
          if (nativeDisplayType != 0 && nativeDisplayType != 1) {
            return 0;
          }
          return 62e3;
        }
        _eglGetDisplay.sig = "pp";
        function _eglInitialize(display, majorVersion, minorVersion) {
          display >>>= 0;
          majorVersion >>>= 0;
          minorVersion >>>= 0;
          if (display != 62e3) {
            EGL.setErrorCode(12296);
            return 0;
          }
          if (majorVersion) {
            HEAP32[majorVersion >>> 2 >>> 0] = 1;
          }
          if (minorVersion) {
            HEAP32[minorVersion >>> 2 >>> 0] = 4;
          }
          EGL.defaultDisplayInitialized = true;
          EGL.setErrorCode(12288);
          return 1;
        }
        _eglInitialize.sig = "ippp";
        function _eglTerminate(display) {
          display >>>= 0;
          if (display != 62e3) {
            EGL.setErrorCode(12296);
            return 0;
          }
          EGL.currentContext = 0;
          EGL.currentReadSurface = 0;
          EGL.currentDrawSurface = 0;
          EGL.defaultDisplayInitialized = false;
          EGL.setErrorCode(12288);
          return 1;
        }
        _eglTerminate.sig = "ip";
        function _eglGetConfigs(display, configs, config_size, numConfigs) {
          display >>>= 0;
          configs >>>= 0;
          numConfigs >>>= 0;
          return EGL.chooseConfig(display, 0, configs, config_size, numConfigs);
        }
        _eglGetConfigs.sig = "ippip";
        function _eglChooseConfig(display, attrib_list, configs, config_size, numConfigs) {
          display >>>= 0;
          attrib_list >>>= 0;
          configs >>>= 0;
          numConfigs >>>= 0;
          return EGL.chooseConfig(display, attrib_list, configs, config_size, numConfigs);
        }
        _eglChooseConfig.sig = "ipppip";
        function _eglGetConfigAttrib(display, config, attribute, value) {
          display >>>= 0;
          config >>>= 0;
          value >>>= 0;
          if (display != 62e3) {
            EGL.setErrorCode(12296);
            return 0;
          }
          if (config != 62002) {
            EGL.setErrorCode(12293);
            return 0;
          }
          if (!value) {
            EGL.setErrorCode(12300);
            return 0;
          }
          EGL.setErrorCode(12288);
          switch (attribute) {
            case 12320:
              HEAP32[value >>> 2 >>> 0] = EGL.contextAttributes.alpha ? 32 : 24;
              return 1;
            case 12321:
              HEAP32[value >>> 2 >>> 0] = EGL.contextAttributes.alpha ? 8 : 0;
              return 1;
            case 12322:
              HEAP32[value >>> 2 >>> 0] = 8;
              return 1;
            case 12323:
              HEAP32[value >>> 2 >>> 0] = 8;
              return 1;
            case 12324:
              HEAP32[value >>> 2 >>> 0] = 8;
              return 1;
            case 12325:
              HEAP32[value >>> 2 >>> 0] = EGL.contextAttributes.depth ? 24 : 0;
              return 1;
            case 12326:
              HEAP32[value >>> 2 >>> 0] = EGL.contextAttributes.stencil ? 8 : 0;
              return 1;
            case 12327:
              HEAP32[value >>> 2 >>> 0] = 12344;
              return 1;
            case 12328:
              HEAP32[value >>> 2 >>> 0] = 62002;
              return 1;
            case 12329:
              HEAP32[value >>> 2 >>> 0] = 0;
              return 1;
            case 12330:
              HEAP32[value >>> 2 >>> 0] = 4096;
              return 1;
            case 12331:
              HEAP32[value >>> 2 >>> 0] = 16777216;
              return 1;
            case 12332:
              HEAP32[value >>> 2 >>> 0] = 4096;
              return 1;
            case 12333:
              HEAP32[value >>> 2 >>> 0] = 0;
              return 1;
            case 12334:
              HEAP32[value >>> 2 >>> 0] = 0;
              return 1;
            case 12335:
              HEAP32[value >>> 2 >>> 0] = 12344;
              return 1;
            case 12337:
              HEAP32[value >>> 2 >>> 0] = EGL.contextAttributes.antialias ? 4 : 0;
              return 1;
            case 12338:
              HEAP32[value >>> 2 >>> 0] = EGL.contextAttributes.antialias ? 1 : 0;
              return 1;
            case 12339:
              HEAP32[value >>> 2 >>> 0] = 4;
              return 1;
            case 12340:
              HEAP32[value >>> 2 >>> 0] = 12344;
              return 1;
            case 12341:
            case 12342:
            case 12343:
              HEAP32[value >>> 2 >>> 0] = -1;
              return 1;
            case 12345:
            case 12346:
              HEAP32[value >>> 2 >>> 0] = 0;
              return 1;
            case 12347:
              HEAP32[value >>> 2 >>> 0] = 0;
              return 1;
            case 12348:
              HEAP32[value >>> 2 >>> 0] = 1;
              return 1;
            case 12349:
            case 12350:
              HEAP32[value >>> 2 >>> 0] = 0;
              return 1;
            case 12351:
              HEAP32[value >>> 2 >>> 0] = 12430;
              return 1;
            case 12352:
              HEAP32[value >>> 2 >>> 0] = 4;
              return 1;
            case 12354:
              HEAP32[value >>> 2 >>> 0] = 0;
              return 1;
            default:
              EGL.setErrorCode(12292);
              return 0;
          }
        }
        _eglGetConfigAttrib.sig = "ippip";
        function _eglCreateWindowSurface(display, config, win, attrib_list) {
          display >>>= 0;
          config >>>= 0;
          attrib_list >>>= 0;
          if (display != 62e3) {
            EGL.setErrorCode(12296);
            return 0;
          }
          if (config != 62002) {
            EGL.setErrorCode(12293);
            return 0;
          }
          EGL.setErrorCode(12288);
          return 62006;
        }
        _eglCreateWindowSurface.sig = "pppip";
        function _eglDestroySurface(display, surface) {
          display >>>= 0;
          surface >>>= 0;
          if (display != 62e3) {
            EGL.setErrorCode(12296);
            return 0;
          }
          if (surface != 62006) {
            EGL.setErrorCode(12301);
            return 1;
          }
          if (EGL.currentReadSurface == surface) {
            EGL.currentReadSurface = 0;
          }
          if (EGL.currentDrawSurface == surface) {
            EGL.currentDrawSurface = 0;
          }
          EGL.setErrorCode(12288);
          return 1;
        }
        _eglDestroySurface.sig = "ipp";
        function _eglCreateContext(display, config, hmm, contextAttribs) {
          display >>>= 0;
          config >>>= 0;
          hmm >>>= 0;
          contextAttribs >>>= 0;
          if (display != 62e3) {
            EGL.setErrorCode(12296);
            return 0;
          }
          var glesContextVersion = 1;
          for (; ; ) {
            var param = HEAP32[contextAttribs >>> 2 >>> 0];
            if (param == 12440) {
              glesContextVersion = HEAP32[contextAttribs + 4 >>> 2 >>> 0];
            } else if (param == 12344) {
              break;
            } else {
              EGL.setErrorCode(12292);
              return 0;
            }
            contextAttribs += 8;
          }
          if (glesContextVersion != 2) {
            EGL.setErrorCode(12293);
            return 0;
          }
          EGL.contextAttributes.majorVersion = glesContextVersion - 1;
          EGL.contextAttributes.minorVersion = 0;
          EGL.context = GL.createContext(Module["canvas"], EGL.contextAttributes);
          if (EGL.context != 0) {
            EGL.setErrorCode(12288);
            GL.makeContextCurrent(EGL.context);
            Module.useWebGL = true;
            Browser.moduleContextCreatedCallbacks.forEach(function(callback) {
              callback();
            });
            GL.makeContextCurrent(null);
            return 62004;
          } else {
            EGL.setErrorCode(12297);
            return 0;
          }
        }
        _eglCreateContext.sig = "ppppp";
        function _eglDestroyContext(display, context) {
          display >>>= 0;
          context >>>= 0;
          if (display != 62e3) {
            EGL.setErrorCode(12296);
            return 0;
          }
          if (context != 62004) {
            EGL.setErrorCode(12294);
            return 0;
          }
          GL.deleteContext(EGL.context);
          EGL.setErrorCode(12288);
          if (EGL.currentContext == context) {
            EGL.currentContext = 0;
          }
          return 1;
        }
        _eglDestroyContext.sig = "ipp";
        function _eglQuerySurface(display, surface, attribute, value) {
          display >>>= 0;
          surface >>>= 0;
          value >>>= 0;
          if (display != 62e3) {
            EGL.setErrorCode(12296);
            return 0;
          }
          if (surface != 62006) {
            EGL.setErrorCode(12301);
            return 0;
          }
          if (!value) {
            EGL.setErrorCode(12300);
            return 0;
          }
          EGL.setErrorCode(12288);
          switch (attribute) {
            case 12328:
              HEAP32[value >>> 2 >>> 0] = 62002;
              return 1;
            case 12376:
              return 1;
            case 12375:
              HEAP32[value >>> 2 >>> 0] = Module["canvas"].width;
              return 1;
            case 12374:
              HEAP32[value >>> 2 >>> 0] = Module["canvas"].height;
              return 1;
            case 12432:
              HEAP32[value >>> 2 >>> 0] = -1;
              return 1;
            case 12433:
              HEAP32[value >>> 2 >>> 0] = -1;
              return 1;
            case 12434:
              HEAP32[value >>> 2 >>> 0] = -1;
              return 1;
            case 12422:
              HEAP32[value >>> 2 >>> 0] = 12420;
              return 1;
            case 12441:
              HEAP32[value >>> 2 >>> 0] = 12442;
              return 1;
            case 12435:
              HEAP32[value >>> 2 >>> 0] = 12437;
              return 1;
            case 12416:
            case 12417:
            case 12418:
            case 12419:
              return 1;
            default:
              EGL.setErrorCode(12292);
              return 0;
          }
        }
        _eglQuerySurface.sig = "ippip";
        function _eglQueryContext(display, context, attribute, value) {
          display >>>= 0;
          context >>>= 0;
          value >>>= 0;
          if (display != 62e3) {
            EGL.setErrorCode(12296);
            return 0;
          }
          if (context != 62004) {
            EGL.setErrorCode(12294);
            return 0;
          }
          if (!value) {
            EGL.setErrorCode(12300);
            return 0;
          }
          EGL.setErrorCode(12288);
          switch (attribute) {
            case 12328:
              HEAP32[value >>> 2 >>> 0] = 62002;
              return 1;
            case 12439:
              HEAP32[value >>> 2 >>> 0] = 12448;
              return 1;
            case 12440:
              HEAP32[value >>> 2 >>> 0] = EGL.contextAttributes.majorVersion + 1;
              return 1;
            case 12422:
              HEAP32[value >>> 2 >>> 0] = 12420;
              return 1;
            default:
              EGL.setErrorCode(12292);
              return 0;
          }
        }
        _eglQueryContext.sig = "ippip";
        var _eglGetError = () => EGL.errorCode;
        _eglGetError.sig = "i";
        function _eglQueryString(display, name2) {
          display >>>= 0;
          if (display != 62e3) {
            EGL.setErrorCode(12296);
            return 0;
          }
          EGL.setErrorCode(12288);
          if (EGL.stringCache[name2])
            return EGL.stringCache[name2];
          var ret;
          switch (name2) {
            case 12371:
              ret = stringToNewUTF8("Emscripten");
              break;
            case 12372:
              ret = stringToNewUTF8("1.4 Emscripten EGL");
              break;
            case 12373:
              ret = stringToNewUTF8("");
              break;
            case 12429:
              ret = stringToNewUTF8("OpenGL_ES");
              break;
            default:
              EGL.setErrorCode(12300);
              return 0;
          }
          EGL.stringCache[name2] = ret;
          return ret;
        }
        _eglQueryString.sig = "ppi";
        var _eglBindAPI = (api) => {
          if (api == 12448) {
            EGL.setErrorCode(12288);
            return 1;
          }
          EGL.setErrorCode(12300);
          return 0;
        };
        _eglBindAPI.sig = "ii";
        var _eglQueryAPI = () => {
          EGL.setErrorCode(12288);
          return 12448;
        };
        _eglQueryAPI.sig = "i";
        var _eglWaitClient = () => {
          EGL.setErrorCode(12288);
          return 1;
        };
        _eglWaitClient.sig = "i";
        var _eglWaitNative = (nativeEngineId) => {
          EGL.setErrorCode(12288);
          return 1;
        };
        _eglWaitNative.sig = "ii";
        var _eglWaitGL = _eglWaitClient;
        _eglWaitGL.sig = "i";
        function _eglSwapInterval(display, interval) {
          display >>>= 0;
          if (display != 62e3) {
            EGL.setErrorCode(12296);
            return 0;
          }
          if (interval == 0)
            _emscripten_set_main_loop_timing(0, 0);
          else
            _emscripten_set_main_loop_timing(1, interval);
          EGL.setErrorCode(12288);
          return 1;
        }
        _eglSwapInterval.sig = "ipi";
        function _eglMakeCurrent(display, draw, read, context) {
          display >>>= 0;
          draw >>>= 0;
          read >>>= 0;
          context >>>= 0;
          if (display != 62e3) {
            EGL.setErrorCode(12296);
            return 0;
          }
          if (context != 0 && context != 62004) {
            EGL.setErrorCode(12294);
            return 0;
          }
          if (read != 0 && read != 62006 || draw != 0 && draw != 62006) {
            EGL.setErrorCode(12301);
            return 0;
          }
          GL.makeContextCurrent(context ? EGL.context : null);
          EGL.currentContext = context;
          EGL.currentDrawSurface = draw;
          EGL.currentReadSurface = read;
          EGL.setErrorCode(12288);
          return 1;
        }
        _eglMakeCurrent.sig = "ipppp";
        function _eglGetCurrentContext() {
          return EGL.currentContext;
        }
        _eglGetCurrentContext.sig = "p";
        function _eglGetCurrentSurface(readdraw) {
          if (readdraw == 12378) {
            return EGL.currentReadSurface;
          } else if (readdraw == 12377) {
            return EGL.currentDrawSurface;
          } else {
            EGL.setErrorCode(12300);
            return 0;
          }
        }
        _eglGetCurrentSurface.sig = "pi";
        function _eglGetCurrentDisplay() {
          return EGL.currentContext ? 62e3 : 0;
        }
        _eglGetCurrentDisplay.sig = "p";
        function _eglSwapBuffers(dpy, surface) {
          dpy >>>= 0;
          surface >>>= 0;
          if (!EGL.defaultDisplayInitialized) {
            EGL.setErrorCode(12289);
          } else if (!Module.ctx) {
            EGL.setErrorCode(12290);
          } else if (Module.ctx.isContextLost()) {
            EGL.setErrorCode(12302);
          } else {
            EGL.setErrorCode(12288);
            return 1;
          }
          return 0;
        }
        _eglSwapBuffers.sig = "ipp";
        var _eglReleaseThread = () => {
          EGL.currentContext = 0;
          EGL.currentReadSurface = 0;
          EGL.currentDrawSurface = 0;
          EGL.setErrorCode(12288);
          return 1;
        };
        _eglReleaseThread.sig = "i";
        function _uuid_clear(uu) {
          uu >>>= 0;
          return zeroMemory(uu, 16);
        }
        _uuid_clear.sig = "vp";
        function _uuid_compare(uu1, uu2) {
          uu1 >>>= 0;
          uu2 >>>= 0;
          return _memcmp(uu1, uu2, 16);
        }
        _uuid_compare.sig = "ipp";
        function _uuid_copy(dst, src) {
          dst >>>= 0;
          src >>>= 0;
          return _memcpy(dst, src, 16);
        }
        _uuid_copy.sig = "vpp";
        function _uuid_generate(out2) {
          out2 >>>= 0;
          var uuid = null;
          if (ENVIRONMENT_IS_NODE) {
            try {
              var rb = require("crypto")["randomBytes"];
              uuid = rb(16);
            } catch (e) {
            }
          } else if (ENVIRONMENT_IS_WEB && typeof window.crypto != "undefined" && typeof window.crypto.getRandomValues != "undefined") {
            uuid = new Uint8Array(16);
            window.crypto.getRandomValues(uuid);
          }
          if (!uuid) {
            uuid = new Array(16);
            var d = (/* @__PURE__ */ new Date()).getTime();
            for (var i2 = 0; i2 < 16; i2++) {
              var r = (d + Math.random() * 256) % 256 | 0;
              d = d / 256 | 0;
              uuid[i2] = r;
            }
          }
          uuid[6] = uuid[6] & 15 | 64;
          uuid[8] = uuid[8] & 63 | 128;
          writeArrayToMemory(uuid, out2);
        }
        _uuid_generate.sig = "vp";
        function _uuid_is_null(uu) {
          uu >>>= 0;
          for (var i2 = 0; i2 < 4; i2++, uu = uu + 4 | 0) {
            var val = HEAP32[uu >>> 2 >>> 0];
            if (val) {
              return 0;
            }
          }
          return 1;
        }
        _uuid_is_null.sig = "ip";
        function _uuid_parse(inp, uu) {
          inp >>>= 0;
          uu >>>= 0;
          inp = UTF8ToString(inp);
          if (inp.length === 36) {
            var i2 = 0;
            var uuid = new Array(16);
            inp.toLowerCase().replace(/[0-9a-f]{2}/g, function(byte) {
              if (i2 < 16) {
                uuid[i2++] = parseInt(byte, 16);
              }
            });
            if (i2 < 16) {
              return -1;
            }
            writeArrayToMemory(uuid, uu);
            return 0;
          }
          return -1;
        }
        _uuid_parse.sig = "ipp";
        function _uuid_unparse(uu, out2, upper) {
          uu >>>= 0;
          out2 >>>= 0;
          var i2 = 0;
          var uuid = "xxxx-xx-xx-xx-xxxxxx".replace(/[x]/g, function(c) {
            var r = upper ? HEAPU8[uu + i2 >>> 0 >>> 0].toString(16).toUpperCase() : HEAPU8[uu + i2 >>> 0 >>> 0].toString(16);
            r = r.length === 1 ? "0" + r : r;
            i2++;
            return r;
          });
          stringToUTF8(uuid, out2, 37);
        }
        _uuid_unparse.sig = "vpp";
        function _uuid_unparse_lower(uu, out2) {
          uu >>>= 0;
          out2 >>>= 0;
          _uuid_unparse(uu, out2);
        }
        _uuid_unparse_lower.sig = "vpp";
        function _uuid_unparse_upper(uu, out2) {
          uu >>>= 0;
          out2 >>>= 0;
          _uuid_unparse(uu, out2, true);
        }
        _uuid_unparse_upper.sig = "vpp";
        function _uuid_type(uu) {
          uu >>>= 0;
          return 4;
        }
        _uuid_type.sig = "ip";
        function _uuid_variant(uu) {
          uu >>>= 0;
          return 1;
        }
        _uuid_variant.sig = "ip";
        var GLEW = {
          isLinaroFork: 1,
          extensions: null,
          error: {
            0: null,
            1: null,
            2: null,
            3: null,
            4: null,
            5: null,
            6: null,
            7: null,
            8: null
          },
          version: {
            1: null,
            2: null,
            3: null,
            4: null
          },
          errorStringConstantFromCode(error) {
            if (GLEW.isLinaroFork) {
              switch (error) {
                case 4:
                  return "OpenGL ES lib expected, found OpenGL lib";
                case 5:
                  return "OpenGL lib expected, found OpenGL ES lib";
                case 6:
                  return "Missing EGL version";
                case 7:
                  return "EGL 1.1 and up are supported";
                default:
                  break;
              }
            }
            switch (error) {
              case 0:
                return "No error";
              case 1:
                return "Missing GL version";
              case 2:
                return "GL 1.1 and up are supported";
              case 3:
                return "GLX 1.2 and up are supported";
              default:
                return null;
            }
          },
          errorString(error) {
            if (!GLEW.error[error]) {
              var string = GLEW.errorStringConstantFromCode(error);
              if (!string) {
                string = "Unknown error";
                error = 8;
              }
              GLEW.error[error] = stringToNewUTF8(string);
            }
            return GLEW.error[error];
          },
          versionStringConstantFromCode(name2) {
            switch (name2) {
              case 1:
                return "1.10.0";
              case 2:
                return "1";
              case 3:
                return "10";
              case 4:
                return "0";
              default:
                return null;
            }
          },
          versionString(name2) {
            if (!GLEW.version[name2]) {
              var string = GLEW.versionStringConstantFromCode(name2);
              if (!string)
                return 0;
              GLEW.version[name2] = stringToNewUTF8(string);
            }
            return GLEW.version[name2];
          },
          extensionIsSupported(name2) {
            GLEW.extensions || (GLEW.extensions = webglGetExtensions());
            if (GLEW.extensions.includes(name2))
              return 1;
            return GLEW.extensions.includes("GL_" + name2);
          }
        };
        var _glewInit = () => 0;
        _glewInit.sig = "i";
        function _glewIsSupported(name2) {
          name2 >>>= 0;
          var exts = UTF8ToString(name2).split(" ");
          for (var i2 = 0; i2 < exts.length; ++i2) {
            if (!GLEW.extensionIsSupported(exts[i2]))
              return 0;
          }
          return 1;
        }
        _glewIsSupported.sig = "ip";
        function _glewGetExtension(name2) {
          name2 >>>= 0;
          return GLEW.extensionIsSupported(UTF8ToString(name2));
        }
        _glewGetExtension.sig = "ip";
        function _glewGetErrorString(error) {
          return GLEW.errorString(error);
        }
        _glewGetErrorString.sig = "pi";
        function _glewGetString(name2) {
          return GLEW.versionString(name2);
        }
        _glewGetString.sig = "pi";
        var IDBStore = {
          indexedDB() {
            if (typeof indexedDB != "undefined")
              return indexedDB;
            var ret = null;
            if (typeof window == "object")
              ret = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
            assert(ret, "IDBStore used, but indexedDB not supported");
            return ret;
          },
          DB_VERSION: 22,
          DB_STORE_NAME: "FILE_DATA",
          dbs: {},
          blobs: [0],
          getDB(name2, callback) {
            var db2 = IDBStore.dbs[name2];
            if (db2) {
              return callback(null, db2);
            }
            var req;
            try {
              req = IDBStore.indexedDB().open(name2, IDBStore.DB_VERSION);
            } catch (e) {
              return callback(e);
            }
            req.onupgradeneeded = (e) => {
              var db3 = e.target.result;
              var transaction = e.target.transaction;
              var fileStore;
              if (db3.objectStoreNames.contains(IDBStore.DB_STORE_NAME)) {
                fileStore = transaction.objectStore(IDBStore.DB_STORE_NAME);
              } else {
                fileStore = db3.createObjectStore(IDBStore.DB_STORE_NAME);
              }
            };
            req.onsuccess = () => {
              db2 = req.result;
              IDBStore.dbs[name2] = db2;
              callback(null, db2);
            };
            req.onerror = function(event2) {
              callback(event2.target.error || "unknown error");
              event2.preventDefault();
            };
          },
          getStore(dbName, type, callback) {
            IDBStore.getDB(dbName, (error, db2) => {
              if (error)
                return callback(error);
              var transaction = db2.transaction([IDBStore.DB_STORE_NAME], type);
              transaction.onerror = (event2) => {
                callback(event2.target.error || "unknown error");
                event2.preventDefault();
              };
              var store = transaction.objectStore(IDBStore.DB_STORE_NAME);
              callback(null, store);
            });
          },
          getFile(dbName, id, callback) {
            IDBStore.getStore(dbName, "readonly", (err2, store) => {
              if (err2)
                return callback(err2);
              var req = store.get(id);
              req.onsuccess = (event2) => {
                var result = event2.target.result;
                if (!result) {
                  return callback(`file ${id} not found`);
                }
                return callback(null, result);
              };
              req.onerror = callback;
            });
          },
          setFile(dbName, id, data2, callback) {
            IDBStore.getStore(dbName, "readwrite", (err2, store) => {
              if (err2)
                return callback(err2);
              var req = store.put(data2, id);
              req.onsuccess = (event2) => callback();
              req.onerror = callback;
            });
          },
          deleteFile(dbName, id, callback) {
            IDBStore.getStore(dbName, "readwrite", (err2, store) => {
              if (err2)
                return callback(err2);
              var req = store.delete(id);
              req.onsuccess = (event2) => callback();
              req.onerror = callback;
            });
          },
          existsFile(dbName, id, callback) {
            IDBStore.getStore(dbName, "readonly", (err2, store) => {
              if (err2)
                return callback(err2);
              var req = store.count(id);
              req.onsuccess = (event2) => callback(null, event2.target.result > 0);
              req.onerror = callback;
            });
          },
          clearStore(dbName, callback) {
            IDBStore.getStore(dbName, "readwrite", (err2, store) => {
              if (err2)
                return callback(err2);
              var req = store.clear();
              req.onsuccess = (event2) => callback();
              req.onerror = callback;
            });
          }
        };
        var _emscripten_idb_async_load = function(db2, id, arg, onload2, onerror2) {
          db2 >>>= 0;
          id >>>= 0;
          arg >>>= 0;
          onload2 >>>= 0;
          onerror2 >>>= 0;
          IDBStore.getFile(UTF8ToString(db2), UTF8ToString(id), (error, byteArray) => {
            callUserCallback(() => {
              if (error) {
                if (onerror2)
                  getWasmTableEntry(onerror2)(arg);
                return;
              }
              var buffer = _malloc(byteArray.length);
              HEAPU8.set(byteArray, buffer >>> 0);
              getWasmTableEntry(onload2)(arg, buffer, byteArray.length);
              _free(buffer);
            });
          });
        };
        _emscripten_idb_async_load.sig = "vppppp";
        var _emscripten_idb_async_store = function(db2, id, ptr2, num, arg, onstore, onerror2) {
          db2 >>>= 0;
          id >>>= 0;
          ptr2 >>>= 0;
          arg >>>= 0;
          onstore >>>= 0;
          onerror2 >>>= 0;
          IDBStore.setFile(UTF8ToString(db2), UTF8ToString(id), new Uint8Array(HEAPU8.subarray(ptr2 >>> 0, ptr2 + num >>> 0)), (error) => {
            callUserCallback(() => {
              if (error) {
                if (onerror2)
                  getWasmTableEntry(onerror2)(arg);
                return;
              }
              if (onstore)
                getWasmTableEntry(onstore)(arg);
            });
          });
        };
        _emscripten_idb_async_store.sig = "vpppippp";
        var _emscripten_idb_async_delete = function(db2, id, arg, ondelete, onerror2) {
          db2 >>>= 0;
          id >>>= 0;
          arg >>>= 0;
          ondelete >>>= 0;
          onerror2 >>>= 0;
          IDBStore.deleteFile(UTF8ToString(db2), UTF8ToString(id), (error) => {
            callUserCallback(() => {
              if (error) {
                if (onerror2)
                  getWasmTableEntry(onerror2)(arg);
                return;
              }
              if (ondelete)
                getWasmTableEntry(ondelete)(arg);
            });
          });
        };
        _emscripten_idb_async_delete.sig = "vppppp";
        var _emscripten_idb_async_exists = function(db2, id, arg, oncheck, onerror2) {
          db2 >>>= 0;
          id >>>= 0;
          arg >>>= 0;
          oncheck >>>= 0;
          onerror2 >>>= 0;
          IDBStore.existsFile(UTF8ToString(db2), UTF8ToString(id), (error, exists) => {
            callUserCallback(() => {
              if (error) {
                if (onerror2)
                  getWasmTableEntry(onerror2)(arg);
                return;
              }
              if (oncheck)
                getWasmTableEntry(oncheck)(arg, exists);
            });
          });
        };
        _emscripten_idb_async_exists.sig = "vppppp";
        var _emscripten_idb_async_clear = function(db2, arg, onclear, onerror2) {
          db2 >>>= 0;
          arg >>>= 0;
          onclear >>>= 0;
          onerror2 >>>= 0;
          IDBStore.clearStore(UTF8ToString(db2), (error) => {
            callUserCallback(() => {
              if (error) {
                if (onerror2)
                  getWasmTableEntry(onerror2)(arg);
                return;
              }
              if (onclear)
                getWasmTableEntry(onclear)(arg);
            });
          });
        };
        _emscripten_idb_async_clear.sig = "vpppp";
        function _emscripten_idb_load(db2, id, pbuffer, pnum, perror) {
          db2 >>>= 0;
          id >>>= 0;
          pbuffer >>>= 0;
          pnum >>>= 0;
          perror >>>= 0;
          throw "Please compile your program with async support in order to use synchronous operations like emscripten_idb_load, etc.";
        }
        _emscripten_idb_load.sig = "vppppp";
        function _emscripten_idb_store(db2, id, ptr2, num, perror) {
          db2 >>>= 0;
          id >>>= 0;
          ptr2 >>>= 0;
          perror >>>= 0;
          throw "Please compile your program with async support in order to use synchronous operations like emscripten_idb_store, etc.";
        }
        _emscripten_idb_store.sig = "vpppip";
        function _emscripten_idb_delete(db2, id, perror) {
          db2 >>>= 0;
          id >>>= 0;
          perror >>>= 0;
          throw "Please compile your program with async support in order to use synchronous operations like emscripten_idb_delete, etc.";
        }
        _emscripten_idb_delete.sig = "vppp";
        function _emscripten_idb_exists(db2, id, pexists, perror) {
          db2 >>>= 0;
          id >>>= 0;
          pexists >>>= 0;
          perror >>>= 0;
          throw "Please compile your program with async support in order to use synchronous operations like emscripten_idb_exists, etc.";
        }
        _emscripten_idb_exists.sig = "vpppp";
        function _emscripten_idb_clear(db2, perror) {
          db2 >>>= 0;
          perror >>>= 0;
          throw "Please compile your program with async support in order to use synchronous operations like emscripten_idb_clear, etc.";
        }
        _emscripten_idb_clear.sig = "vpp";
        var runAndAbortIfError = (func2) => {
          try {
            return func2();
          } catch (e) {
            abort(e);
          }
        };
        var _emscripten_sleep = () => {
          throw "Please compile your program with async support in order to use asynchronous operations like emscripten_sleep";
        };
        _emscripten_sleep.sig = "vi";
        function _emscripten_scan_registers(func2) {
          func2 >>>= 0;
          throw "Please compile your program with async support in order to use asynchronous operations like emscripten_scan_registers";
        }
        _emscripten_scan_registers.sig = "vp";
        function _emscripten_fiber_swap(oldFiber, newFiber) {
          oldFiber >>>= 0;
          newFiber >>>= 0;
          throw "Please compile your program with async support in order to use asynchronous operations like emscripten_fiber_swap";
        }
        _emscripten_fiber_swap.sig = "vpp";
        var _SDL_GetTicks = () => Date.now() - SDL.startTime | 0;
        _SDL_GetTicks.sig = "i";
        function _SDL_LockSurface(surf) {
          surf >>>= 0;
          var surfData = SDL.surfaces[surf];
          surfData.locked++;
          if (surfData.locked > 1)
            return 0;
          if (!surfData.buffer) {
            surfData.buffer = _malloc(surfData.width * surfData.height * 4);
            HEAPU32[surf + 20 >>> 2 >>> 0] = surfData.buffer;
          }
          HEAPU32[surf + 20 >>> 2 >>> 0] = surfData.buffer;
          if (surf == SDL.screen && Module.screenIsReadOnly && surfData.image)
            return 0;
          if (SDL.defaults.discardOnLock) {
            if (!surfData.image) {
              surfData.image = surfData.ctx.createImageData(surfData.width, surfData.height);
            }
            if (!SDL.defaults.opaqueFrontBuffer)
              return;
          } else {
            surfData.image = surfData.ctx.getImageData(0, 0, surfData.width, surfData.height);
          }
          if (surf == SDL.screen && SDL.defaults.opaqueFrontBuffer) {
            var data2 = surfData.image.data;
            var num = data2.length;
            for (var i2 = 0; i2 < num / 4; i2++) {
              data2[i2 * 4 + 3] = 255;
            }
          }
          if (SDL.defaults.copyOnLock && !SDL.defaults.discardOnLock) {
            if (surfData.isFlagSet(2097152)) {
              throw "CopyOnLock is not supported for SDL_LockSurface with SDL_HWPALETTE flag set" + new Error().stack;
            } else {
              HEAPU8.set(surfData.image.data, surfData.buffer >>> 0);
            }
          }
          return 0;
        }
        _SDL_LockSurface.sig = "ip";
        var SDL_ttfContext = () => SDL.ttfContext;
        var SDL_audio = () => SDL.audio;
        var SDL = {
          defaults: {
            width: 320,
            height: 200,
            copyOnLock: true,
            discardOnLock: false,
            opaqueFrontBuffer: true
          },
          version: null,
          surfaces: {},
          canvasPool: [],
          events: [],
          fonts: [null],
          audios: [null],
          rwops: [null],
          music: {
            audio: null,
            volume: 1
          },
          mixerFrequency: 22050,
          mixerFormat: 32784,
          mixerNumChannels: 2,
          mixerChunkSize: 1024,
          channelMinimumNumber: 0,
          GL: false,
          glAttributes: {
            0: 3,
            1: 3,
            2: 2,
            3: 0,
            4: 0,
            5: 1,
            6: 16,
            7: 0,
            8: 0,
            9: 0,
            10: 0,
            11: 0,
            12: 0,
            13: 0,
            14: 0,
            15: 1,
            16: 0,
            17: 0,
            18: 0
          },
          keyboardState: null,
          keyboardMap: {},
          canRequestFullscreen: false,
          isRequestingFullscreen: false,
          textInput: false,
          startTime: null,
          initFlags: 0,
          buttonState: 0,
          modState: 0,
          DOMButtons: [0, 0, 0],
          DOMEventToSDLEvent: {},
          TOUCH_DEFAULT_ID: 0,
          eventHandler: null,
          eventHandlerContext: null,
          eventHandlerTemp: 0,
          keyCodes: {
            16: 1249,
            17: 1248,
            18: 1250,
            20: 1081,
            33: 1099,
            34: 1102,
            35: 1101,
            36: 1098,
            37: 1104,
            38: 1106,
            39: 1103,
            40: 1105,
            44: 316,
            45: 1097,
            46: 127,
            91: 1251,
            93: 1125,
            96: 1122,
            97: 1113,
            98: 1114,
            99: 1115,
            100: 1116,
            101: 1117,
            102: 1118,
            103: 1119,
            104: 1120,
            105: 1121,
            106: 1109,
            107: 1111,
            109: 1110,
            110: 1123,
            111: 1108,
            112: 1082,
            113: 1083,
            114: 1084,
            115: 1085,
            116: 1086,
            117: 1087,
            118: 1088,
            119: 1089,
            120: 1090,
            121: 1091,
            122: 1092,
            123: 1093,
            124: 1128,
            125: 1129,
            126: 1130,
            127: 1131,
            128: 1132,
            129: 1133,
            130: 1134,
            131: 1135,
            132: 1136,
            133: 1137,
            134: 1138,
            135: 1139,
            144: 1107,
            160: 94,
            161: 33,
            162: 34,
            163: 35,
            164: 36,
            165: 37,
            166: 38,
            167: 95,
            168: 40,
            169: 41,
            170: 42,
            171: 43,
            172: 124,
            173: 45,
            174: 123,
            175: 125,
            176: 126,
            181: 127,
            182: 129,
            183: 128,
            188: 44,
            190: 46,
            191: 47,
            192: 96,
            219: 91,
            220: 92,
            221: 93,
            222: 39,
            224: 1251
          },
          scanCodes: {
            8: 42,
            9: 43,
            13: 40,
            27: 41,
            32: 44,
            35: 204,
            39: 53,
            44: 54,
            46: 55,
            47: 56,
            48: 39,
            49: 30,
            50: 31,
            51: 32,
            52: 33,
            53: 34,
            54: 35,
            55: 36,
            56: 37,
            57: 38,
            58: 203,
            59: 51,
            61: 46,
            91: 47,
            92: 49,
            93: 48,
            96: 52,
            97: 4,
            98: 5,
            99: 6,
            100: 7,
            101: 8,
            102: 9,
            103: 10,
            104: 11,
            105: 12,
            106: 13,
            107: 14,
            108: 15,
            109: 16,
            110: 17,
            111: 18,
            112: 19,
            113: 20,
            114: 21,
            115: 22,
            116: 23,
            117: 24,
            118: 25,
            119: 26,
            120: 27,
            121: 28,
            122: 29,
            127: 76,
            305: 224,
            308: 226,
            316: 70
          },
          loadRect: (rect) => ({
            x: HEAP32[rect + 0 >>> 2 >>> 0],
            y: HEAP32[rect + 4 >>> 2 >>> 0],
            w: HEAP32[rect + 8 >>> 2 >>> 0],
            h: HEAP32[rect + 12 >>> 2 >>> 0]
          }),
          updateRect: (rect, r) => {
            HEAP32[rect >>> 2 >>> 0] = r.x;
            HEAP32[rect + 4 >>> 2 >>> 0] = r.y;
            HEAP32[rect + 8 >>> 2 >>> 0] = r.w;
            HEAP32[rect + 12 >>> 2 >>> 0] = r.h;
          },
          intersectionOfRects: (first, second) => {
            var leftX = Math.max(first.x, second.x);
            var leftY = Math.max(first.y, second.y);
            var rightX = Math.min(first.x + first.w, second.x + second.w);
            var rightY = Math.min(first.y + first.h, second.y + second.h);
            return {
              x: leftX,
              y: leftY,
              w: Math.max(leftX, rightX) - leftX,
              h: Math.max(leftY, rightY) - leftY
            };
          },
          checkPixelFormat: (fmt) => {
          },
          loadColorToCSSRGB: (color) => {
            var rgba = HEAP32[color >>> 2 >>> 0];
            return "rgb(" + (rgba & 255) + "," + (rgba >> 8 & 255) + "," + (rgba >> 16 & 255) + ")";
          },
          loadColorToCSSRGBA: (color) => {
            var rgba = HEAP32[color >>> 2 >>> 0];
            return "rgba(" + (rgba & 255) + "," + (rgba >> 8 & 255) + "," + (rgba >> 16 & 255) + "," + (rgba >> 24 & 255) / 255 + ")";
          },
          translateColorToCSSRGBA: (rgba) => "rgba(" + (rgba & 255) + "," + (rgba >> 8 & 255) + "," + (rgba >> 16 & 255) + "," + (rgba >>> 24) / 255 + ")",
          translateRGBAToCSSRGBA: (r, g, b, a) => "rgba(" + (r & 255) + "," + (g & 255) + "," + (b & 255) + "," + (a & 255) / 255 + ")",
          translateRGBAToColor: (r, g, b, a) => r | g << 8 | b << 16 | a << 24,
          makeSurface: (width, height, flags2, usePageCanvas, source, rmask, gmask, bmask, amask) => {
            var is_SDL_HWSURFACE = flags2 & 1;
            var is_SDL_HWPALETTE = flags2 & 2097152;
            var is_SDL_OPENGL = flags2 & 67108864;
            var surf = _malloc(60);
            var pixelFormat = _malloc(44);
            var bpp = is_SDL_HWPALETTE ? 1 : 4;
            var buffer = 0;
            if (!is_SDL_HWSURFACE && !is_SDL_OPENGL) {
              buffer = _malloc(width * height * 4);
            }
            HEAP32[surf >>> 2 >>> 0] = flags2;
            HEAPU32[surf + 4 >>> 2 >>> 0] = pixelFormat;
            HEAP32[surf + 8 >>> 2 >>> 0] = width;
            HEAP32[surf + 12 >>> 2 >>> 0] = height;
            HEAP32[surf + 16 >>> 2 >>> 0] = width * bpp;
            HEAPU32[surf + 20 >>> 2 >>> 0] = buffer;
            HEAP32[surf + 36 >>> 2 >>> 0] = 0;
            HEAP32[surf + 40 >>> 2 >>> 0] = 0;
            HEAP32[surf + 44 >>> 2 >>> 0] = Module["canvas"].width;
            HEAP32[surf + 48 >>> 2 >>> 0] = Module["canvas"].height;
            HEAP32[surf + 56 >>> 2 >>> 0] = 1;
            HEAP32[pixelFormat >>> 2 >>> 0] = -2042224636;
            HEAP32[pixelFormat + 4 >>> 2 >>> 0] = 0;
            HEAP8[pixelFormat + 8 >>> 0 >>> 0] = bpp * 8;
            HEAP8[pixelFormat + 9 >>> 0 >>> 0] = bpp;
            HEAP32[pixelFormat + 12 >>> 2 >>> 0] = rmask || 255;
            HEAP32[pixelFormat + 16 >>> 2 >>> 0] = gmask || 65280;
            HEAP32[pixelFormat + 20 >>> 2 >>> 0] = bmask || 16711680;
            HEAP32[pixelFormat + 24 >>> 2 >>> 0] = amask || 4278190080;
            SDL.GL = SDL.GL || is_SDL_OPENGL;
            var canvas;
            if (!usePageCanvas) {
              if (SDL.canvasPool.length > 0) {
                canvas = SDL.canvasPool.pop();
              } else {
                canvas = document.createElement("canvas");
              }
              canvas.width = width;
              canvas.height = height;
            } else {
              canvas = Module["canvas"];
            }
            var webGLContextAttributes = {
              antialias: SDL.glAttributes[13] != 0 && SDL.glAttributes[14] > 1,
              depth: SDL.glAttributes[6] > 0,
              stencil: SDL.glAttributes[7] > 0,
              alpha: SDL.glAttributes[3] > 0
            };
            var ctx = Browser.createContext(canvas, is_SDL_OPENGL, usePageCanvas, webGLContextAttributes);
            SDL.surfaces[surf] = {
              width,
              height,
              canvas,
              ctx,
              surf,
              buffer,
              pixelFormat,
              alpha: 255,
              flags: flags2,
              locked: 0,
              usePageCanvas,
              source,
              isFlagSet: (flag) => flags2 & flag
            };
            return surf;
          },
          copyIndexedColorData: (surfData, rX, rY, rW, rH) => {
            if (!surfData.colors) {
              return;
            }
            var fullWidth = Module["canvas"].width;
            var fullHeight = Module["canvas"].height;
            var startX = rX || 0;
            var startY = rY || 0;
            var endX = (rW || fullWidth - startX) + startX;
            var endY = (rH || fullHeight - startY) + startY;
            var buffer = surfData.buffer;
            if (!surfData.image.data32) {
              surfData.image.data32 = new Uint32Array(surfData.image.data.buffer);
            }
            var data32 = surfData.image.data32;
            var colors32 = surfData.colors32;
            for (var y = startY; y < endY; ++y) {
              var base = y * fullWidth;
              for (var x = startX; x < endX; ++x) {
                data32[base + x] = colors32[HEAPU8[buffer + base + x >>> 0 >>> 0]];
              }
            }
          },
          freeSurface: (surf) => {
            var refcountPointer = surf + 56;
            var refcount = HEAP32[refcountPointer >>> 2 >>> 0];
            if (refcount > 1) {
              HEAP32[refcountPointer >>> 2 >>> 0] = refcount - 1;
              return;
            }
            var info2 = SDL.surfaces[surf];
            if (!info2.usePageCanvas && info2.canvas)
              SDL.canvasPool.push(info2.canvas);
            if (info2.buffer)
              _free(info2.buffer);
            _free(info2.pixelFormat);
            _free(surf);
            SDL.surfaces[surf] = null;
            if (surf === SDL.screen) {
              SDL.screen = null;
            }
          },
          blitSurface: (src, srcrect, dst, dstrect, scale) => {
            var srcData = SDL.surfaces[src];
            var dstData = SDL.surfaces[dst];
            var sr, dr;
            if (srcrect) {
              sr = SDL.loadRect(srcrect);
            } else {
              sr = {
                x: 0,
                y: 0,
                w: srcData.width,
                h: srcData.height
              };
            }
            if (dstrect) {
              dr = SDL.loadRect(dstrect);
            } else {
              dr = {
                x: 0,
                y: 0,
                w: srcData.width,
                h: srcData.height
              };
            }
            if (dstData.clipRect) {
              var widthScale = !scale || sr.w === 0 ? 1 : sr.w / dr.w;
              var heightScale = !scale || sr.h === 0 ? 1 : sr.h / dr.h;
              dr = SDL.intersectionOfRects(dstData.clipRect, dr);
              sr.w = dr.w * widthScale;
              sr.h = dr.h * heightScale;
              if (dstrect) {
                SDL.updateRect(dstrect, dr);
              }
            }
            var blitw, blith;
            if (scale) {
              blitw = dr.w;
              blith = dr.h;
            } else {
              blitw = sr.w;
              blith = sr.h;
            }
            if (sr.w === 0 || sr.h === 0 || blitw === 0 || blith === 0) {
              return 0;
            }
            var oldAlpha = dstData.ctx.globalAlpha;
            dstData.ctx.globalAlpha = srcData.alpha / 255;
            dstData.ctx.drawImage(srcData.canvas, sr.x, sr.y, sr.w, sr.h, dr.x, dr.y, blitw, blith);
            dstData.ctx.globalAlpha = oldAlpha;
            if (dst != SDL.screen) {
              warnOnce("WARNING: copying canvas data to memory for compatibility");
              _SDL_LockSurface(dst);
              dstData.locked--;
            }
            return 0;
          },
          downFingers: {},
          savedKeydown: null,
          receiveEvent: (event2) => {
            function unpressAllPressedKeys() {
              for (var code in SDL.keyboardMap) {
                SDL.events.push({
                  type: "keyup",
                  keyCode: SDL.keyboardMap[code]
                });
              }
            }
            switch (event2.type) {
              case "touchstart":
              case "touchmove": {
                event2.preventDefault();
                var touches = [];
                if (event2.type === "touchstart") {
                  for (var i2 = 0; i2 < event2.touches.length; i2++) {
                    var touch = event2.touches[i2];
                    if (SDL.downFingers[touch.identifier] != true) {
                      SDL.downFingers[touch.identifier] = true;
                      touches.push(touch);
                    }
                  }
                } else {
                  touches = event2.touches;
                }
                var firstTouch = touches[0];
                if (firstTouch) {
                  if (event2.type == "touchstart") {
                    SDL.DOMButtons[0] = 1;
                  }
                  var mouseEventType;
                  switch (event2.type) {
                    case "touchstart":
                      mouseEventType = "mousedown";
                      break;
                    case "touchmove":
                      mouseEventType = "mousemove";
                      break;
                  }
                  var mouseEvent = {
                    type: mouseEventType,
                    button: 0,
                    pageX: firstTouch.clientX,
                    pageY: firstTouch.clientY
                  };
                  SDL.events.push(mouseEvent);
                }
                for (var i2 = 0; i2 < touches.length; i2++) {
                  var touch = touches[i2];
                  SDL.events.push({
                    type: event2.type,
                    touch
                  });
                }
                break;
              }
              case "touchend": {
                event2.preventDefault();
                for (var i2 = 0; i2 < event2.changedTouches.length; i2++) {
                  var touch = event2.changedTouches[i2];
                  if (SDL.downFingers[touch.identifier] === true) {
                    delete SDL.downFingers[touch.identifier];
                  }
                }
                var mouseEvent = {
                  type: "mouseup",
                  button: 0,
                  pageX: event2.changedTouches[0].clientX,
                  pageY: event2.changedTouches[0].clientY
                };
                SDL.DOMButtons[0] = 0;
                SDL.events.push(mouseEvent);
                for (var i2 = 0; i2 < event2.changedTouches.length; i2++) {
                  var touch = event2.changedTouches[i2];
                  SDL.events.push({
                    type: "touchend",
                    touch
                  });
                }
                break;
              }
              case "DOMMouseScroll":
              case "mousewheel":
              case "wheel":
                var delta = -Browser.getMouseWheelDelta(event2);
                delta = delta == 0 ? 0 : delta > 0 ? Math.max(delta, 1) : Math.min(delta, -1);
                var button = delta > 0 ? 3 : 4;
                SDL.events.push({
                  type: "mousedown",
                  button,
                  pageX: event2.pageX,
                  pageY: event2.pageY
                });
                SDL.events.push({
                  type: "mouseup",
                  button,
                  pageX: event2.pageX,
                  pageY: event2.pageY
                });
                SDL.events.push({
                  type: "wheel",
                  deltaX: 0,
                  deltaY: delta
                });
                event2.preventDefault();
                break;
              case "mousemove":
                if (SDL.DOMButtons[0] === 1) {
                  SDL.events.push({
                    type: "touchmove",
                    touch: {
                      identifier: 0,
                      deviceID: -1,
                      pageX: event2.pageX,
                      pageY: event2.pageY
                    }
                  });
                }
                if (Browser.pointerLock) {
                  if ("mozMovementX" in event2) {
                    event2["movementX"] = event2["mozMovementX"];
                    event2["movementY"] = event2["mozMovementY"];
                  }
                  if (event2["movementX"] == 0 && event2["movementY"] == 0) {
                    event2.preventDefault();
                    return;
                  }
                }
              case "keydown":
              case "keyup":
              case "keypress":
              case "mousedown":
              case "mouseup":
                if (event2.type !== "keydown" || !SDL_unicode() && !SDL.textInput || (event2.keyCode === 8 || event2.keyCode === 9)) {
                  event2.preventDefault();
                }
                if (event2.type == "mousedown") {
                  SDL.DOMButtons[event2.button] = 1;
                  SDL.events.push({
                    type: "touchstart",
                    touch: {
                      identifier: 0,
                      deviceID: -1,
                      pageX: event2.pageX,
                      pageY: event2.pageY
                    }
                  });
                } else if (event2.type == "mouseup") {
                  if (!SDL.DOMButtons[event2.button]) {
                    return;
                  }
                  SDL.events.push({
                    type: "touchend",
                    touch: {
                      identifier: 0,
                      deviceID: -1,
                      pageX: event2.pageX,
                      pageY: event2.pageY
                    }
                  });
                  SDL.DOMButtons[event2.button] = 0;
                }
                if (event2.type === "keydown" || event2.type === "mousedown") {
                  SDL.canRequestFullscreen = true;
                } else if (event2.type === "keyup" || event2.type === "mouseup") {
                  if (SDL.isRequestingFullscreen) {
                    Module["requestFullscreen"](true, true);
                    SDL.isRequestingFullscreen = false;
                  }
                  SDL.canRequestFullscreen = false;
                }
                if (event2.type === "keypress" && SDL.savedKeydown) {
                  SDL.savedKeydown.keypressCharCode = event2.charCode;
                  SDL.savedKeydown = null;
                } else if (event2.type === "keydown") {
                  SDL.savedKeydown = event2;
                }
                if (event2.type !== "keypress" || SDL.textInput) {
                  SDL.events.push(event2);
                }
                break;
              case "mouseout":
                for (var i2 = 0; i2 < 3; i2++) {
                  if (SDL.DOMButtons[i2]) {
                    SDL.events.push({
                      type: "mouseup",
                      button: i2,
                      pageX: event2.pageX,
                      pageY: event2.pageY
                    });
                    SDL.DOMButtons[i2] = 0;
                  }
                }
                event2.preventDefault();
                break;
              case "focus":
                SDL.events.push(event2);
                event2.preventDefault();
                break;
              case "blur":
                SDL.events.push(event2);
                unpressAllPressedKeys();
                event2.preventDefault();
                break;
              case "visibilitychange":
                SDL.events.push({
                  type: "visibilitychange",
                  visible: !document.hidden
                });
                unpressAllPressedKeys();
                event2.preventDefault();
                break;
              case "unload":
                if (Browser.mainLoop.runner) {
                  SDL.events.push(event2);
                  Browser.mainLoop.runner();
                }
                return;
              case "resize":
                SDL.events.push(event2);
                if (event2.preventDefault) {
                  event2.preventDefault();
                }
                break;
            }
            if (SDL.events.length >= 1e4) {
              err("SDL event queue full, dropping events");
              SDL.events = SDL.events.slice(0, 1e4);
            }
            SDL.flushEventsToHandler();
            return;
          },
          lookupKeyCodeForEvent: (event2) => {
            var code = event2.keyCode;
            if (code >= 65 && code <= 90) {
              code += 32;
            } else {
              code = SDL.keyCodes[event2.keyCode] || event2.keyCode;
              if (event2.location === 2 && code >= (224 | 1 << 10) && code <= (227 | 1 << 10)) {
                code += 4;
              }
            }
            return code;
          },
          handleEvent: (event2) => {
            if (event2.handled)
              return;
            event2.handled = true;
            switch (event2.type) {
              case "touchstart":
              case "touchend":
              case "touchmove": {
                Browser.calculateMouseEvent(event2);
                break;
              }
              case "keydown":
              case "keyup": {
                var down = event2.type === "keydown";
                var code = SDL.lookupKeyCodeForEvent(event2);
                HEAP8[SDL.keyboardState + code >>> 0 >>> 0] = down;
                SDL.modState = (HEAP8[SDL.keyboardState + 1248 >>> 0 >>> 0] ? 64 : 0) | (HEAP8[SDL.keyboardState + 1249 >>> 0 >>> 0] ? 1 : 0) | (HEAP8[SDL.keyboardState + 1250 >>> 0 >>> 0] ? 256 : 0) | (HEAP8[SDL.keyboardState + 1252 >>> 0 >>> 0] ? 128 : 0) | (HEAP8[SDL.keyboardState + 1253 >>> 0 >>> 0] ? 2 : 0) | (HEAP8[SDL.keyboardState + 1254 >>> 0 >>> 0] ? 512 : 0);
                if (down) {
                  SDL.keyboardMap[code] = event2.keyCode;
                } else {
                  delete SDL.keyboardMap[code];
                }
                break;
              }
              case "mousedown":
              case "mouseup":
                if (event2.type == "mousedown") {
                  SDL.buttonState |= 1 << event2.button;
                } else if (event2.type == "mouseup") {
                  SDL.buttonState &= ~(1 << event2.button);
                }
              case "mousemove": {
                Browser.calculateMouseEvent(event2);
                break;
              }
            }
          },
          flushEventsToHandler: () => {
            if (!SDL.eventHandler)
              return;
            while (SDL.pollEvent(SDL.eventHandlerTemp)) {
              getWasmTableEntry(SDL.eventHandler)(SDL.eventHandlerContext, SDL.eventHandlerTemp);
            }
          },
          pollEvent: (ptr2) => {
            if (SDL.initFlags & 512 && SDL.joystickEventState) {
              SDL.queryJoysticks();
            }
            if (ptr2) {
              while (SDL.events.length > 0) {
                if (SDL.makeCEvent(SDL.events.shift(), ptr2) !== false)
                  return 1;
              }
              return 0;
            }
            return SDL.events.length > 0;
          },
          makeCEvent: (event2, ptr2) => {
            if (typeof event2 == "number") {
              _memcpy(ptr2, event2, 28);
              _free(event2);
              return;
            }
            SDL.handleEvent(event2);
            switch (event2.type) {
              case "keydown":
              case "keyup": {
                var down = event2.type === "keydown";
                var key = SDL.lookupKeyCodeForEvent(event2);
                var scan;
                if (key >= 1024) {
                  scan = key - 1024;
                } else {
                  scan = SDL.scanCodes[key] || key;
                }
                HEAP32[ptr2 >>> 2 >>> 0] = SDL.DOMEventToSDLEvent[event2.type];
                HEAP8[ptr2 + 8 >>> 0 >>> 0] = down ? 1 : 0;
                HEAP8[ptr2 + 9 >>> 0 >>> 0] = 0;
                HEAP32[ptr2 + 12 >>> 2 >>> 0] = scan;
                HEAP32[ptr2 + 16 >>> 2 >>> 0] = key;
                HEAP16[ptr2 + 20 >>> 1 >>> 0] = SDL.modState;
                HEAP32[ptr2 + 24 >>> 2 >>> 0] = event2.keypressCharCode || key;
                break;
              }
              case "keypress": {
                HEAP32[ptr2 >>> 2 >>> 0] = SDL.DOMEventToSDLEvent[event2.type];
                var cStr = intArrayFromString(String.fromCharCode(event2.charCode));
                for (var i2 = 0; i2 < cStr.length; ++i2) {
                  HEAP8[ptr2 + (8 + i2) >>> 0 >>> 0] = cStr[i2];
                }
                break;
              }
              case "mousedown":
              case "mouseup":
              case "mousemove": {
                if (event2.type != "mousemove") {
                  var down = event2.type === "mousedown";
                  HEAP32[ptr2 >>> 2 >>> 0] = SDL.DOMEventToSDLEvent[event2.type];
                  HEAP32[ptr2 + 4 >>> 2 >>> 0] = 0;
                  HEAP32[ptr2 + 8 >>> 2 >>> 0] = 0;
                  HEAP32[ptr2 + 12 >>> 2 >>> 0] = 0;
                  HEAP8[ptr2 + 16 >>> 0 >>> 0] = event2.button + 1;
                  HEAP8[ptr2 + 17 >>> 0 >>> 0] = down ? 1 : 0;
                  HEAP32[ptr2 + 20 >>> 2 >>> 0] = Browser.mouseX;
                  HEAP32[ptr2 + 24 >>> 2 >>> 0] = Browser.mouseY;
                } else {
                  HEAP32[ptr2 >>> 2 >>> 0] = SDL.DOMEventToSDLEvent[event2.type];
                  HEAP32[ptr2 + 4 >>> 2 >>> 0] = 0;
                  HEAP32[ptr2 + 8 >>> 2 >>> 0] = 0;
                  HEAP32[ptr2 + 12 >>> 2 >>> 0] = 0;
                  HEAP32[ptr2 + 16 >>> 2 >>> 0] = SDL.buttonState;
                  HEAP32[ptr2 + 20 >>> 2 >>> 0] = Browser.mouseX;
                  HEAP32[ptr2 + 24 >>> 2 >>> 0] = Browser.mouseY;
                  HEAP32[ptr2 + 28 >>> 2 >>> 0] = Browser.mouseMovementX;
                  HEAP32[ptr2 + 32 >>> 2 >>> 0] = Browser.mouseMovementY;
                }
                break;
              }
              case "wheel": {
                HEAP32[ptr2 >>> 2 >>> 0] = SDL.DOMEventToSDLEvent[event2.type];
                HEAP32[ptr2 + 16 >>> 2 >>> 0] = event2.deltaX;
                HEAP32[ptr2 + 20 >>> 2 >>> 0] = event2.deltaY;
                break;
              }
              case "touchstart":
              case "touchend":
              case "touchmove": {
                var touch = event2.touch;
                if (!Browser.touches[touch.identifier])
                  break;
                var w = Module["canvas"].width;
                var h = Module["canvas"].height;
                var x = Browser.touches[touch.identifier].x / w;
                var y = Browser.touches[touch.identifier].y / h;
                var lx = Browser.lastTouches[touch.identifier].x / w;
                var ly = Browser.lastTouches[touch.identifier].y / h;
                var dx = x - lx;
                var dy = y - ly;
                if (touch["deviceID"] === void 0)
                  touch.deviceID = SDL.TOUCH_DEFAULT_ID;
                if (dx === 0 && dy === 0 && event2.type === "touchmove")
                  return false;
                HEAP32[ptr2 >>> 2 >>> 0] = SDL.DOMEventToSDLEvent[event2.type];
                HEAP32[ptr2 + 4 >>> 2 >>> 0] = _SDL_GetTicks();
                tempI64 = [touch.deviceID >>> 0, (tempDouble = touch.deviceID, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[ptr2 + 8 >>> 2 >>> 0] = tempI64[0], HEAP32[ptr2 + 12 >>> 2 >>> 0] = tempI64[1];
                tempI64 = [touch.identifier >>> 0, (tempDouble = touch.identifier, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[ptr2 + 16 >>> 2 >>> 0] = tempI64[0], HEAP32[ptr2 + 20 >>> 2 >>> 0] = tempI64[1];
                HEAPF32[ptr2 + 24 >>> 2 >>> 0] = x;
                HEAPF32[ptr2 + 28 >>> 2 >>> 0] = y;
                HEAPF32[ptr2 + 32 >>> 2 >>> 0] = dx;
                HEAPF32[ptr2 + 36 >>> 2 >>> 0] = dy;
                if (touch.force !== void 0) {
                  HEAPF32[ptr2 + 40 >>> 2 >>> 0] = touch.force;
                } else {
                  HEAPF32[ptr2 + 40 >>> 2 >>> 0] = event2.type == "touchend" ? 0 : 1;
                }
                break;
              }
              case "unload": {
                HEAP32[ptr2 >>> 2 >>> 0] = SDL.DOMEventToSDLEvent[event2.type];
                break;
              }
              case "resize": {
                HEAP32[ptr2 >>> 2 >>> 0] = SDL.DOMEventToSDLEvent[event2.type];
                HEAP32[ptr2 + 4 >>> 2 >>> 0] = event2.w;
                HEAP32[ptr2 + 8 >>> 2 >>> 0] = event2.h;
                break;
              }
              case "joystick_button_up":
              case "joystick_button_down": {
                var state = event2.type === "joystick_button_up" ? 0 : 1;
                HEAP32[ptr2 >>> 2 >>> 0] = SDL.DOMEventToSDLEvent[event2.type];
                HEAP8[ptr2 + 4 >>> 0 >>> 0] = event2.index;
                HEAP8[ptr2 + 5 >>> 0 >>> 0] = event2.button;
                HEAP8[ptr2 + 6 >>> 0 >>> 0] = state;
                break;
              }
              case "joystick_axis_motion": {
                HEAP32[ptr2 >>> 2 >>> 0] = SDL.DOMEventToSDLEvent[event2.type];
                HEAP8[ptr2 + 4 >>> 0 >>> 0] = event2.index;
                HEAP8[ptr2 + 5 >>> 0 >>> 0] = event2.axis;
                HEAP32[ptr2 + 8 >>> 2 >>> 0] = SDL.joystickAxisValueConversion(event2.value);
                break;
              }
              case "focus": {
                var SDL_WINDOWEVENT_FOCUS_GAINED = 12;
                HEAP32[ptr2 >>> 2 >>> 0] = SDL.DOMEventToSDLEvent[event2.type];
                HEAP32[ptr2 + 4 >>> 2 >>> 0] = 0;
                HEAP8[ptr2 + 8 >>> 0 >>> 0] = SDL_WINDOWEVENT_FOCUS_GAINED;
                break;
              }
              case "blur": {
                var SDL_WINDOWEVENT_FOCUS_LOST = 13;
                HEAP32[ptr2 >>> 2 >>> 0] = SDL.DOMEventToSDLEvent[event2.type];
                HEAP32[ptr2 + 4 >>> 2 >>> 0] = 0;
                HEAP8[ptr2 + 8 >>> 0 >>> 0] = SDL_WINDOWEVENT_FOCUS_LOST;
                break;
              }
              case "visibilitychange": {
                var SDL_WINDOWEVENT_SHOWN = 1;
                var SDL_WINDOWEVENT_HIDDEN = 2;
                var visibilityEventID = event2.visible ? SDL_WINDOWEVENT_SHOWN : SDL_WINDOWEVENT_HIDDEN;
                HEAP32[ptr2 >>> 2 >>> 0] = SDL.DOMEventToSDLEvent[event2.type];
                HEAP32[ptr2 + 4 >>> 2 >>> 0] = 0;
                HEAP8[ptr2 + 8 >>> 0 >>> 0] = visibilityEventID;
                break;
              }
              default:
                throw "Unhandled SDL event: " + event2.type;
            }
          },
          makeFontString: (height, fontName) => {
            if (fontName.charAt(0) != "'" && fontName.charAt(0) != '"') {
              fontName = '"' + fontName + '"';
            }
            return height + "px " + fontName + ", serif";
          },
          estimateTextWidth: (fontData, text) => {
            var h = fontData.size;
            var fontString = SDL.makeFontString(h, fontData.name);
            var tempCtx = SDL_ttfContext();
            tempCtx.font = fontString;
            var ret = tempCtx.measureText(text).width | 0;
            return ret;
          },
          allocateChannels: (num) => {
            if (SDL.numChannels && SDL.numChannels >= num && num != 0)
              return;
            SDL.numChannels = num;
            SDL.channels = [];
            for (var i2 = 0; i2 < num; i2++) {
              SDL.channels[i2] = {
                audio: null,
                volume: 1
              };
            }
          },
          setGetVolume: (info2, volume) => {
            if (!info2)
              return 0;
            var ret = info2.volume * 128;
            if (volume != -1) {
              info2.volume = Math.min(Math.max(volume, 0), 128) / 128;
              if (info2.audio) {
                try {
                  info2.audio.volume = info2.volume;
                  if (info2.audio.webAudioGainNode)
                    info2.audio.webAudioGainNode["gain"]["value"] = info2.volume;
                } catch (e) {
                  err(`setGetVolume failed to set audio volume: ${e}`);
                }
              }
            }
            return ret;
          },
          setPannerPosition: (info2, x, y, z) => {
            if (!info2)
              return;
            if (info2.audio) {
              if (info2.audio.webAudioPannerNode) {
                info2.audio.webAudioPannerNode["setPosition"](x, y, z);
              }
            }
          },
          playWebAudio: (audio) => {
            if (!audio)
              return;
            if (audio.webAudioNode)
              return;
            if (!SDL.webAudioAvailable())
              return;
            try {
              var webAudio = audio.resource.webAudio;
              audio.paused = false;
              if (!webAudio.decodedBuffer) {
                if (webAudio.onDecodeComplete === void 0)
                  abort("Cannot play back audio object that was not loaded");
                webAudio.onDecodeComplete.push(() => {
                  if (!audio.paused)
                    SDL.playWebAudio(audio);
                });
                return;
              }
              audio.webAudioNode = SDL.audioContext["createBufferSource"]();
              audio.webAudioNode["buffer"] = webAudio.decodedBuffer;
              audio.webAudioNode["loop"] = audio.loop;
              audio.webAudioNode["onended"] = audio["onended"];
              audio.webAudioPannerNode = SDL.audioContext["createPanner"]();
              audio.webAudioPannerNode["setPosition"](0, 0, -0.5);
              audio.webAudioPannerNode["panningModel"] = "equalpower";
              audio.webAudioGainNode = SDL.audioContext["createGain"]();
              audio.webAudioGainNode["gain"]["value"] = audio.volume;
              audio.webAudioNode["connect"](audio.webAudioPannerNode);
              audio.webAudioPannerNode["connect"](audio.webAudioGainNode);
              audio.webAudioGainNode["connect"](SDL.audioContext["destination"]);
              audio.webAudioNode["start"](0, audio.currentPosition);
              audio.startTime = SDL.audioContext["currentTime"] - audio.currentPosition;
            } catch (e) {
              err(`playWebAudio failed: ${e}`);
            }
          },
          pauseWebAudio: (audio) => {
            if (!audio)
              return;
            if (audio.webAudioNode) {
              try {
                audio.currentPosition = (SDL.audioContext["currentTime"] - audio.startTime) % audio.resource.webAudio.decodedBuffer.duration;
                audio.webAudioNode["onended"] = void 0;
                audio.webAudioNode.stop(0);
                audio.webAudioNode = void 0;
              } catch (e) {
                err(`pauseWebAudio failed: ${e}`);
              }
            }
            audio.paused = true;
          },
          openAudioContext: () => {
            if (!SDL.audioContext) {
              if (typeof AudioContext != "undefined")
                SDL.audioContext = new AudioContext();
              else if (typeof webkitAudioContext != "undefined")
                SDL.audioContext = new webkitAudioContext();
            }
          },
          webAudioAvailable: () => !!SDL.audioContext,
          fillWebAudioBufferFromHeap: (heapPtr, sizeSamplesPerChannel, dstAudioBuffer) => {
            var audio = SDL_audio();
            var numChannels = audio.channels;
            for (var c = 0; c < numChannels; ++c) {
              var channelData = dstAudioBuffer["getChannelData"](c);
              if (channelData.length != sizeSamplesPerChannel) {
                throw "Web Audio output buffer length mismatch! Destination size: " + channelData.length + " samples vs expected " + sizeSamplesPerChannel + " samples!";
              }
              if (audio.format == 32784) {
                for (var j = 0; j < sizeSamplesPerChannel; ++j) {
                  channelData[j] = HEAP16[heapPtr + (j * numChannels + c) * 2 >>> 1 >>> 0] / 32768;
                }
              } else if (audio.format == 8) {
                for (var j = 0; j < sizeSamplesPerChannel; ++j) {
                  var v = HEAP8[heapPtr + (j * numChannels + c) >>> 0 >>> 0];
                  channelData[j] = (v >= 0 ? v - 128 : v + 128) / 128;
                }
              } else if (audio.format == 33056) {
                for (var j = 0; j < sizeSamplesPerChannel; ++j) {
                  channelData[j] = HEAPF32[heapPtr + (j * numChannels + c) * 4 >>> 2 >>> 0];
                }
              } else {
                throw "Invalid SDL audio format " + audio.format + "!";
              }
            }
          },
          joystickEventState: 1,
          lastJoystickState: {},
          joystickNamePool: {},
          recordJoystickState: (joystick, state) => {
            var buttons = new Array(state.buttons.length);
            for (var i2 = 0; i2 < state.buttons.length; i2++) {
              buttons[i2] = SDL.getJoystickButtonState(state.buttons[i2]);
            }
            SDL.lastJoystickState[joystick] = {
              buttons,
              axes: state.axes.slice(0),
              timestamp: state.timestamp,
              index: state.index,
              id: state.id
            };
          },
          getJoystickButtonState: (button) => {
            if (typeof button == "object") {
              return button["pressed"];
            }
            return button > 0;
          },
          queryJoysticks: () => {
            for (var joystick in SDL.lastJoystickState) {
              var state = SDL.getGamepad(joystick - 1);
              var prevState = SDL.lastJoystickState[joystick];
              if (typeof state == "undefined")
                return;
              if (state === null)
                return;
              if (typeof state.timestamp != "number" || state.timestamp != prevState.timestamp || !state.timestamp) {
                var i2;
                for (i2 = 0; i2 < state.buttons.length; i2++) {
                  var buttonState = SDL.getJoystickButtonState(state.buttons[i2]);
                  if (buttonState !== prevState.buttons[i2]) {
                    SDL.events.push({
                      type: buttonState ? "joystick_button_down" : "joystick_button_up",
                      joystick,
                      index: joystick - 1,
                      button: i2
                    });
                  }
                }
                for (i2 = 0; i2 < state.axes.length; i2++) {
                  if (state.axes[i2] !== prevState.axes[i2]) {
                    SDL.events.push({
                      type: "joystick_axis_motion",
                      joystick,
                      index: joystick - 1,
                      axis: i2,
                      value: state.axes[i2]
                    });
                  }
                }
                SDL.recordJoystickState(joystick, state);
              }
            }
          },
          joystickAxisValueConversion: (value) => {
            value = Math.min(1, Math.max(value, -1));
            return Math.ceil((value + 1) * 32767.5 - 32768);
          },
          getGamepads: () => {
            var fcn = navigator.getGamepads || navigator.webkitGamepads || navigator.mozGamepads || navigator.gamepads || navigator.webkitGetGamepads;
            if (fcn !== void 0) {
              return fcn.apply(navigator);
            }
            return [];
          },
          getGamepad: (deviceIndex) => {
            var gamepads = SDL.getGamepads();
            if (gamepads.length > deviceIndex && deviceIndex >= 0) {
              return gamepads[deviceIndex];
            }
            return null;
          }
        };
        var SDL_unicode = () => SDL.unicode;
        function _SDL_Linked_Version() {
          if (SDL.version === null) {
            SDL.version = _malloc(3);
            HEAP8[SDL.version + 0 >>> 0 >>> 0] = 1;
            HEAP8[SDL.version + 1 >>> 0 >>> 0] = 3;
            HEAP8[SDL.version + 2 >>> 0 >>> 0] = 0;
          }
          return SDL.version;
        }
        _SDL_Linked_Version.sig = "p";
        var _SDL_Init = (initFlags) => {
          SDL.startTime = Date.now();
          SDL.initFlags = initFlags;
          if (!Module["doNotCaptureKeyboard"]) {
            var keyboardListeningElement = Module["keyboardListeningElement"] || document;
            keyboardListeningElement.addEventListener("keydown", SDL.receiveEvent);
            keyboardListeningElement.addEventListener("keyup", SDL.receiveEvent);
            keyboardListeningElement.addEventListener("keypress", SDL.receiveEvent);
            window.addEventListener("focus", SDL.receiveEvent);
            window.addEventListener("blur", SDL.receiveEvent);
            document.addEventListener("visibilitychange", SDL.receiveEvent);
          }
          window.addEventListener("unload", SDL.receiveEvent);
          SDL.keyboardState = _malloc(65536);
          zeroMemory(SDL.keyboardState, 65536);
          SDL.DOMEventToSDLEvent["keydown"] = 768;
          SDL.DOMEventToSDLEvent["keyup"] = 769;
          SDL.DOMEventToSDLEvent["keypress"] = 771;
          SDL.DOMEventToSDLEvent["mousedown"] = 1025;
          SDL.DOMEventToSDLEvent["mouseup"] = 1026;
          SDL.DOMEventToSDLEvent["mousemove"] = 1024;
          SDL.DOMEventToSDLEvent["wheel"] = 1027;
          SDL.DOMEventToSDLEvent["touchstart"] = 1792;
          SDL.DOMEventToSDLEvent["touchend"] = 1793;
          SDL.DOMEventToSDLEvent["touchmove"] = 1794;
          SDL.DOMEventToSDLEvent["unload"] = 256;
          SDL.DOMEventToSDLEvent["resize"] = 28673;
          SDL.DOMEventToSDLEvent["visibilitychange"] = 512;
          SDL.DOMEventToSDLEvent["focus"] = 512;
          SDL.DOMEventToSDLEvent["blur"] = 512;
          SDL.DOMEventToSDLEvent["joystick_axis_motion"] = 1536;
          SDL.DOMEventToSDLEvent["joystick_button_down"] = 1539;
          SDL.DOMEventToSDLEvent["joystick_button_up"] = 1540;
          return 0;
        };
        _SDL_Init.sig = "ii";
        var _SDL_WasInit = (flags2) => {
          if (SDL.startTime === null) {
            _SDL_Init(0);
          }
          return 1;
        };
        _SDL_WasInit.sig = "ii";
        function _SDL_GetVideoInfo() {
          var ret = _malloc(20);
          zeroMemory(ret, 3);
          HEAP32[ret + 12 >>> 2 >>> 0] = Module["canvas"].width;
          HEAP32[ret + 16 >>> 2 >>> 0] = Module["canvas"].height;
          return ret;
        }
        _SDL_GetVideoInfo.sig = "p";
        function _SDL_ListModes(format, flags2) {
          format >>>= 0;
          return -1;
        }
        _SDL_ListModes.sig = "ppi";
        var _SDL_VideoModeOK = (width, height, depth, flags2) => depth;
        _SDL_VideoModeOK.sig = "iiiii";
        function _SDL_VideoDriverName(buf, max_size) {
          buf >>>= 0;
          if (SDL.startTime === null) {
            return 0;
          }
          var driverName = [101, 109, 115, 99, 114, 105, 112, 116, 101, 110, 95, 115, 100, 108, 95, 100, 114, 105, 118, 101, 114];
          var index = 0;
          var size = driverName.length;
          if (max_size <= size) {
            size = max_size - 1;
          }
          while (index < size) {
            var value = driverName[index];
            HEAP8[buf + index >>> 0 >>> 0] = value;
            index++;
          }
          HEAP8[buf + index >>> 0 >>> 0] = 0;
          return buf;
        }
        _SDL_VideoDriverName.sig = "ppi";
        var _SDL_AudioDriverName = _SDL_VideoDriverName;
        _SDL_AudioDriverName.sig = "ppi";
        var _SDL_SetVideoMode = function(width, height, depth, flags2) {
          ["touchstart", "touchend", "touchmove", "mousedown", "mouseup", "mousemove", "mousewheel", "wheel", "mouseout", "DOMMouseScroll"].forEach((e) => Module["canvas"].addEventListener(e, SDL.receiveEvent, true));
          var canvas = Module["canvas"];
          if (width == 0 && height == 0) {
            width = canvas.width;
            height = canvas.height;
          }
          if (!SDL.addedResizeListener) {
            SDL.addedResizeListener = true;
            Browser.resizeListeners.push((w, h) => {
              if (!SDL.settingVideoMode) {
                SDL.receiveEvent({
                  type: "resize",
                  w,
                  h
                });
              }
            });
          }
          SDL.settingVideoMode = true;
          Browser.setCanvasSize(width, height);
          SDL.settingVideoMode = false;
          if (SDL.screen) {
            SDL.freeSurface(SDL.screen);
            assert(!SDL.screen);
          }
          if (SDL.GL)
            flags2 = flags2 | 67108864;
          SDL.screen = SDL.makeSurface(width, height, flags2, true, "screen");
          return SDL.screen;
        };
        _SDL_SetVideoMode.sig = "piiii";
        function _SDL_GetVideoSurface() {
          return SDL.screen;
        }
        _SDL_GetVideoSurface.sig = "p";
        var _SDL_AudioQuit = () => {
          for (var i2 = 0; i2 < SDL.numChannels; ++i2) {
            var chan = SDL.channels[i2];
            if (chan.audio) {
              chan.audio.pause();
              chan.audio = void 0;
            }
          }
          var audio = SDL.music.audio;
          audio == null ? void 0 : audio.pause();
          SDL.music.audio = void 0;
        };
        _SDL_AudioQuit.sig = "v";
        var _SDL_VideoQuit = () => out("SDL_VideoQuit called (and ignored)");
        _SDL_VideoQuit.sig = "v";
        var _SDL_QuitSubSystem = (flags2) => out("SDL_QuitSubSystem called (and ignored)");
        _SDL_QuitSubSystem.sig = "vi";
        var _SDL_Quit = () => {
          _SDL_AudioQuit();
          out("SDL_Quit called (and ignored)");
        };
        _SDL_Quit.sig = "v";
        function _SDL_UnlockSurface(surf) {
          surf >>>= 0;
          assert(!SDL.GL);
          var surfData = SDL.surfaces[surf];
          if (!surfData.locked || --surfData.locked > 0) {
            return;
          }
          if (surfData.isFlagSet(2097152)) {
            SDL.copyIndexedColorData(surfData);
          } else if (!surfData.colors) {
            var data2 = surfData.image.data;
            var buffer = surfData.buffer;
            assert(buffer % 4 == 0, "Invalid buffer offset: " + buffer);
            var src = buffer >> 2;
            var dst = 0;
            var isScreen = surf == SDL.screen;
            var num;
            if (typeof CanvasPixelArray != "undefined" && data2 instanceof CanvasPixelArray) {
              num = data2.length;
              while (dst < num) {
                var val = HEAP32[src >>> 0];
                data2[dst] = val & 255;
                data2[dst + 1] = val >> 8 & 255;
                data2[dst + 2] = val >> 16 & 255;
                data2[dst + 3] = isScreen ? 255 : val >> 24 & 255;
                src++;
                dst += 4;
              }
            } else {
              var data32 = new Uint32Array(data2.buffer);
              if (isScreen && SDL.defaults.opaqueFrontBuffer) {
                num = data32.length;
                data32.set(HEAP32.subarray(src >>> 0, src + num >>> 0));
                var data8 = new Uint8Array(data2.buffer);
                var i2 = 3;
                var j = i2 + 4 * num;
                if (num % 8 == 0) {
                  while (i2 < j) {
                    data8[i2] = 255;
                    i2 = i2 + 4 | 0;
                    data8[i2] = 255;
                    i2 = i2 + 4 | 0;
                    data8[i2] = 255;
                    i2 = i2 + 4 | 0;
                    data8[i2] = 255;
                    i2 = i2 + 4 | 0;
                    data8[i2] = 255;
                    i2 = i2 + 4 | 0;
                    data8[i2] = 255;
                    i2 = i2 + 4 | 0;
                    data8[i2] = 255;
                    i2 = i2 + 4 | 0;
                    data8[i2] = 255;
                    i2 = i2 + 4 | 0;
                  }
                } else {
                  while (i2 < j) {
                    data8[i2] = 255;
                    i2 = i2 + 4 | 0;
                  }
                }
              } else {
                data32.set(HEAP32.subarray(src >>> 0, src + data32.length >>> 0));
              }
            }
          } else {
            var width = Module["canvas"].width;
            var height = Module["canvas"].height;
            var s2 = surfData.buffer;
            var data2 = surfData.image.data;
            var colors = surfData.colors;
            for (var y = 0; y < height; y++) {
              var base = y * width * 4;
              for (var x = 0; x < width; x++) {
                var val = HEAPU8[s2++ >>> 0 >>> 0] * 4;
                var start2 = base + x * 4;
                data2[start2] = colors[val];
                data2[start2 + 1] = colors[val + 1];
                data2[start2 + 2] = colors[val + 2];
              }
              s2 += width * 3;
            }
          }
          surfData.ctx.putImageData(surfData.image, 0, 0);
        }
        _SDL_UnlockSurface.sig = "vp";
        function _SDL_Flip(surf) {
          surf >>>= 0;
        }
        _SDL_Flip.sig = "ip";
        function _SDL_UpdateRect(surf, x, y, w, h) {
          surf >>>= 0;
        }
        _SDL_UpdateRect.sig = "vpiiii";
        function _SDL_UpdateRects(surf, numrects, rects) {
          surf >>>= 0;
          rects >>>= 0;
        }
        _SDL_UpdateRects.sig = "vpip";
        var _SDL_Delay = (delay) => {
          if (!ENVIRONMENT_IS_WORKER)
            abort("SDL_Delay called on the main thread! Potential infinite loop, quitting. (consider building with async support like ASYNCIFY)");
          var now = Date.now();
          while (Date.now() - now < delay) {
          }
        };
        _SDL_Delay.sig = "vi";
        function _SDL_WM_SetCaption(title, icon) {
          title >>>= 0;
          icon >>>= 0;
          if (title) {
            _emscripten_set_window_title(title);
          }
          icon && (icon = UTF8ToString(icon));
        }
        _SDL_WM_SetCaption.sig = "vpp";
        var _SDL_EnableKeyRepeat = (delay, interval) => {
        };
        _SDL_EnableKeyRepeat.sig = "iii";
        function _SDL_GetKeyboardState(numKeys) {
          numKeys >>>= 0;
          if (numKeys) {
            HEAP32[numKeys >>> 2 >>> 0] = 65536;
          }
          return SDL.keyboardState;
        }
        _SDL_GetKeyboardState.sig = "pp";
        var _SDL_GetKeyState = () => _SDL_GetKeyboardState(0);
        function _SDL_GetKeyName(key) {
          SDL.keyName || (SDL.keyName = stringToNewUTF8("unknown key"));
          return SDL.keyName;
        }
        _SDL_GetKeyName.sig = "pi";
        var _SDL_GetModState = () => SDL.modState;
        _SDL_GetModState.sig = "i";
        function _SDL_GetMouseState(x, y) {
          x >>>= 0;
          y >>>= 0;
          if (x)
            HEAP32[x >>> 2 >>> 0] = Browser.mouseX;
          if (y)
            HEAP32[y >>> 2 >>> 0] = Browser.mouseY;
          return SDL.buttonState;
        }
        _SDL_GetMouseState.sig = "ipp";
        var _SDL_WarpMouse = (x, y) => {
        };
        _SDL_WarpMouse.sig = "vii";
        var _SDL_ShowCursor = (toggle) => {
          switch (toggle) {
            case 0:
              if (Browser.isFullscreen) {
                Module["canvas"].requestPointerLock();
                return 0;
              }
              return 1;
            case 1:
              Module["canvas"].exitPointerLock();
              return 1;
            case -1:
              return !Browser.pointerLock;
            default:
              err(`SDL_ShowCursor called with unknown toggle parameter value: ${toggle}`);
              break;
          }
        };
        _SDL_ShowCursor.sig = "ii";
        function _SDL_GetError() {
          SDL.errorMessage || (SDL.errorMessage = stringToNewUTF8("unknown SDL-emscripten error"));
          return SDL.errorMessage;
        }
        _SDL_GetError.sig = "p";
        function _SDL_SetError(fmt, varargs) {
          fmt >>>= 0;
          varargs >>>= 0;
        }
        _SDL_SetError.sig = "vpp";
        function _SDL_CreateRGBSurface(flags2, width, height, depth, rmask, gmask, bmask, amask) {
          return SDL.makeSurface(width, height, flags2, false, "CreateRGBSurface", rmask, gmask, bmask, amask);
        }
        _SDL_CreateRGBSurface.sig = "piiiiiiii";
        function _SDL_CreateRGBSurfaceFrom(pixels, width, height, depth, pitch, rmask, gmask, bmask, amask) {
          pixels >>>= 0;
          var surf = SDL.makeSurface(width, height, 0, false, "CreateRGBSurfaceFrom", rmask, gmask, bmask, amask);
          if (depth !== 32) {
            err("TODO: Partially unimplemented SDL_CreateRGBSurfaceFrom called!");
            return surf;
          }
          var data2 = SDL.surfaces[surf];
          var image = data2.ctx.createImageData(width, height);
          var pitchOfDst = width * 4;
          for (var row = 0; row < height; ++row) {
            var baseOfSrc = row * pitch;
            var baseOfDst = row * pitchOfDst;
            for (var col = 0; col < width * 4; ++col) {
              image.data[baseOfDst + col] = HEAPU8[pixels + (baseOfDst + col) >>> 0 >>> 0];
            }
          }
          data2.ctx.putImageData(image, 0, 0);
          return surf;
        }
        _SDL_CreateRGBSurfaceFrom.sig = "ppiiiiiiii";
        function _SDL_ConvertSurface(surf, format, flags2) {
          surf >>>= 0;
          format >>>= 0;
          if (format) {
            SDL.checkPixelFormat(format);
          }
          var oldData = SDL.surfaces[surf];
          var ret = SDL.makeSurface(oldData.width, oldData.height, oldData.flags, false, "copy:" + oldData.source);
          var newData = SDL.surfaces[ret];
          newData.ctx.globalCompositeOperation = "copy";
          newData.ctx.drawImage(oldData.canvas, 0, 0);
          newData.ctx.globalCompositeOperation = oldData.ctx.globalCompositeOperation;
          return ret;
        }
        _SDL_ConvertSurface.sig = "pppi";
        function _SDL_DisplayFormatAlpha(surf) {
          surf >>>= 0;
          return _SDL_ConvertSurface(surf, 0, 0);
        }
        _SDL_DisplayFormatAlpha.sig = "pp";
        function _SDL_FreeSurface(surf) {
          surf >>>= 0;
          if (surf)
            SDL.freeSurface(surf);
        }
        _SDL_FreeSurface.sig = "vp";
        function _SDL_UpperBlit(src, srcrect, dst, dstrect) {
          src >>>= 0;
          srcrect >>>= 0;
          dst >>>= 0;
          dstrect >>>= 0;
          return SDL.blitSurface(src, srcrect, dst, dstrect, false);
        }
        _SDL_UpperBlit.sig = "ipppp";
        function _SDL_UpperBlitScaled(src, srcrect, dst, dstrect) {
          src >>>= 0;
          srcrect >>>= 0;
          dst >>>= 0;
          dstrect >>>= 0;
          return SDL.blitSurface(src, srcrect, dst, dstrect, true);
        }
        _SDL_UpperBlitScaled.sig = "ipppp";
        var _SDL_LowerBlit = _SDL_UpperBlit;
        _SDL_LowerBlit.sig = "ipppp";
        var _SDL_LowerBlitScaled = _SDL_UpperBlitScaled;
        _SDL_LowerBlitScaled.sig = "ipppp";
        function _SDL_GetClipRect(surf, rect) {
          surf >>>= 0;
          rect >>>= 0;
          assert(rect);
          var surfData = SDL.surfaces[surf];
          var r = surfData.clipRect || {
            x: 0,
            y: 0,
            w: surfData.width,
            h: surfData.height
          };
          SDL.updateRect(rect, r);
        }
        _SDL_GetClipRect.sig = "vpp";
        function _SDL_SetClipRect(surf, rect) {
          surf >>>= 0;
          rect >>>= 0;
          var surfData = SDL.surfaces[surf];
          if (rect) {
            surfData.clipRect = SDL.intersectionOfRects({
              x: 0,
              y: 0,
              w: surfData.width,
              h: surfData.height
            }, SDL.loadRect(rect));
          } else {
            delete surfData.clipRect;
          }
        }
        _SDL_SetClipRect.sig = "ipp";
        function _SDL_FillRect(surf, rect, color) {
          surf >>>= 0;
          rect >>>= 0;
          var surfData = SDL.surfaces[surf];
          assert(!surfData.locked);
          if (surfData.isFlagSet(2097152)) {
            color = surfData.colors32[color];
          }
          var r = rect ? SDL.loadRect(rect) : {
            x: 0,
            y: 0,
            w: surfData.width,
            h: surfData.height
          };
          if (surfData.clipRect) {
            r = SDL.intersectionOfRects(surfData.clipRect, r);
            if (rect) {
              SDL.updateRect(rect, r);
            }
          }
          surfData.ctx.save();
          surfData.ctx.fillStyle = SDL.translateColorToCSSRGBA(color);
          surfData.ctx.fillRect(r.x, r.y, r.w, r.h);
          surfData.ctx.restore();
          return 0;
        }
        _SDL_FillRect.sig = "ippi";
        function _zoomSurface(src, x, y, smooth) {
          src >>>= 0;
          var srcData = SDL.surfaces[src];
          var w = srcData.width * x;
          var h = srcData.height * y;
          var ret = SDL.makeSurface(Math.abs(w), Math.abs(h), srcData.flags, false, "zoomSurface");
          var dstData = SDL.surfaces[ret];
          if (x >= 0 && y >= 0)
            dstData.ctx.drawImage(srcData.canvas, 0, 0, w, h);
          else {
            dstData.ctx.save();
            dstData.ctx.scale(x < 0 ? -1 : 1, y < 0 ? -1 : 1);
            dstData.ctx.drawImage(srcData.canvas, w < 0 ? w : 0, h < 0 ? h : 0, Math.abs(w), Math.abs(h));
            dstData.ctx.restore();
          }
          return ret;
        }
        _zoomSurface.sig = "ppddi";
        function _rotozoomSurface(src, angle, zoom, smooth) {
          src >>>= 0;
          if (angle % 360 === 0) {
            return _zoomSurface(src, zoom, zoom, smooth);
          }
          var srcData = SDL.surfaces[src];
          var w = srcData.width * zoom;
          var h = srcData.height * zoom;
          var diagonal = Math.ceil(Math.sqrt(Math.pow(w, 2) + Math.pow(h, 2)));
          var ret = SDL.makeSurface(diagonal, diagonal, srcData.flags, false, "rotozoomSurface");
          var dstData = SDL.surfaces[ret];
          dstData.ctx.translate(diagonal / 2, diagonal / 2);
          dstData.ctx.rotate(-angle * Math.PI / 180);
          dstData.ctx.drawImage(srcData.canvas, -w / 2, -h / 2, w, h);
          return ret;
        }
        _rotozoomSurface.sig = "ppddi";
        function _SDL_SetAlpha(surf, flag, alpha) {
          surf >>>= 0;
          var surfData = SDL.surfaces[surf];
          surfData.alpha = alpha;
          if (!(flag & 65536)) {
            surfData.alpha = 255;
          }
        }
        _SDL_SetAlpha.sig = "ipii";
        function _SDL_SetColorKey(surf, flag, key) {
          surf >>>= 0;
          warnOnce("SDL_SetColorKey is a no-op for performance reasons");
          return 0;
        }
        _SDL_SetColorKey.sig = "ipii";
        function _SDL_PollEvent(ptr2) {
          ptr2 >>>= 0;
          return SDL.pollEvent(ptr2);
        }
        _SDL_PollEvent.sig = "ip";
        function _SDL_PushEvent(ptr2) {
          ptr2 >>>= 0;
          var copy = _malloc(28);
          _memcpy(copy, ptr2, 28);
          SDL.events.push(copy);
          return 0;
        }
        _SDL_PushEvent.sig = "ip";
        function _SDL_PeepEvents(events, requestedEventCount, action, from, to) {
          events >>>= 0;
          switch (action) {
            case 2: {
              assert(requestedEventCount == 1);
              var index = 0;
              var retrievedEventCount = 0;
              while (index < SDL.events.length && retrievedEventCount < requestedEventCount) {
                var event2 = SDL.events[index];
                var type = SDL.DOMEventToSDLEvent[event2.type];
                if (from <= type && type <= to) {
                  if (SDL.makeCEvent(event2, events) === false) {
                    index++;
                  } else {
                    SDL.events.splice(index, 1);
                    retrievedEventCount++;
                  }
                } else {
                  index++;
                }
              }
              return retrievedEventCount;
            }
            default:
              throw "SDL_PeepEvents does not yet support that action: " + action;
          }
        }
        _SDL_PeepEvents.sig = "ipiiii";
        var _SDL_PumpEvents = () => SDL.events.forEach(SDL.handleEvent);
        _SDL_PumpEvents.sig = "v";
        function _emscripten_SDL_SetEventHandler(handler, userdata) {
          handler >>>= 0;
          userdata >>>= 0;
          SDL.eventHandler = handler;
          SDL.eventHandlerContext = userdata;
          if (!SDL.eventHandlerTemp)
            SDL.eventHandlerTemp = _malloc(28);
        }
        _emscripten_SDL_SetEventHandler.sig = "vpp";
        function _SDL_SetColors(surf, colors, firstColor, nColors) {
          surf >>>= 0;
          colors >>>= 0;
          var surfData = SDL.surfaces[surf];
          if (!surfData.colors) {
            var buffer = new ArrayBuffer(256 * 4);
            surfData.colors = new Uint8Array(buffer);
            surfData.colors32 = new Uint32Array(buffer);
          }
          for (var i2 = 0; i2 < nColors; ++i2) {
            var index = (firstColor + i2) * 4;
            surfData.colors[index] = HEAPU8[colors + i2 * 4 >>> 0 >>> 0];
            surfData.colors[index + 1] = HEAPU8[colors + (i2 * 4 + 1) >>> 0 >>> 0];
            surfData.colors[index + 2] = HEAPU8[colors + (i2 * 4 + 2) >>> 0 >>> 0];
            surfData.colors[index + 3] = 255;
          }
          return 1;
        }
        _SDL_SetColors.sig = "ippii";
        function _SDL_SetPalette(surf, flags2, colors, firstColor, nColors) {
          surf >>>= 0;
          colors >>>= 0;
          return _SDL_SetColors(surf, colors, firstColor, nColors);
        }
        _SDL_SetPalette.sig = "ipipii";
        function _SDL_MapRGB(fmt, r, g, b) {
          fmt >>>= 0;
          SDL.checkPixelFormat(fmt);
          return r & 255 | (g & 255) << 8 | (b & 255) << 16 | 4278190080;
        }
        _SDL_MapRGB.sig = "ipiii";
        function _SDL_MapRGBA(fmt, r, g, b, a) {
          fmt >>>= 0;
          SDL.checkPixelFormat(fmt);
          return r & 255 | (g & 255) << 8 | (b & 255) << 16 | (a & 255) << 24;
        }
        _SDL_MapRGBA.sig = "ipiiii";
        function _SDL_GetRGB(pixel, fmt, r, g, b) {
          fmt >>>= 0;
          r >>>= 0;
          g >>>= 0;
          b >>>= 0;
          SDL.checkPixelFormat(fmt);
          if (r) {
            HEAP8[r >>> 0 >>> 0] = pixel & 255;
          }
          if (g) {
            HEAP8[g >>> 0 >>> 0] = pixel >> 8 & 255;
          }
          if (b) {
            HEAP8[b >>> 0 >>> 0] = pixel >> 16 & 255;
          }
        }
        _SDL_GetRGB.sig = "vipppp";
        function _SDL_GetRGBA(pixel, fmt, r, g, b, a) {
          fmt >>>= 0;
          r >>>= 0;
          g >>>= 0;
          b >>>= 0;
          a >>>= 0;
          SDL.checkPixelFormat(fmt);
          if (r) {
            HEAP8[r >>> 0 >>> 0] = pixel & 255;
          }
          if (g) {
            HEAP8[g >>> 0 >>> 0] = pixel >> 8 & 255;
          }
          if (b) {
            HEAP8[b >>> 0 >>> 0] = pixel >> 16 & 255;
          }
          if (a) {
            HEAP8[a >>> 0 >>> 0] = pixel >> 24 & 255;
          }
        }
        _SDL_GetRGBA.sig = "vippppp";
        var _SDL_GetAppState = () => {
          var state = 0;
          if (Browser.pointerLock) {
            state |= 1;
          }
          if (document.hasFocus()) {
            state |= 2;
          }
          state |= 4;
          return state;
        };
        _SDL_GetAppState.sig = "i";
        var _SDL_WM_GrabInput = () => {
        };
        _SDL_WM_GrabInput.sig = "ii";
        function _SDL_WM_ToggleFullScreen(surf) {
          surf >>>= 0;
          if (Browser.exitFullscreen()) {
            return 1;
          }
          if (!SDL.canRequestFullscreen) {
            return 0;
          }
          SDL.isRequestingFullscreen = true;
          return 1;
        }
        _SDL_WM_ToggleFullScreen.sig = "ip";
        var _IMG_Init = (flags2) => flags2;
        _IMG_Init.sig = "ii";
        function _SDL_FreeRW(rwopsID) {
          rwopsID >>>= 0;
          SDL.rwops[rwopsID] = null;
          while (SDL.rwops.length > 0 && SDL.rwops[SDL.rwops.length - 1] === null) {
            SDL.rwops.pop();
          }
        }
        _SDL_FreeRW.sig = "vp";
        var _IMG_Load_RW = function(rwopsID, freeSrc) {
          rwopsID >>>= 0;
          try {
            var cleanup = () => {
              if (rwops && freeSrc)
                _SDL_FreeRW(rwopsID);
            };
            var addCleanup = (func2) => {
              var old = cleanup;
              cleanup = () => {
                old();
                func2();
              };
            };
            var callStbImage = (func2, params) => withStackSave(() => {
              var x = stackAlloc(4);
              var y = stackAlloc(4);
              var comp = stackAlloc(4);
              var data3 = Module["_" + func2].apply(null, params.concat([x, y, comp, 0]));
              if (!data3)
                return null;
              addCleanup(() => Module["_stbi_image_free"](data3));
              return {
                rawData: true,
                data: data3,
                width: HEAP32[x >>> 2 >>> 0],
                height: HEAP32[y >>> 2 >>> 0],
                size: HEAP32[x >>> 2 >>> 0] * HEAP32[y >>> 2 >>> 0] * HEAP32[comp >>> 2 >>> 0],
                bpp: HEAP32[comp >>> 2 >>> 0]
              };
            });
            var rwops = SDL.rwops[rwopsID];
            if (rwops === void 0) {
              return 0;
            }
            var raw;
            var filename = rwops.filename;
            if (filename === void 0) {
              warnOnce("Only file names that have been preloaded are supported for IMG_Load_RW. Consider using STB_IMAGE=1 if you want synchronous image decoding (see settings.js), or package files with --use-preload-plugins");
              return 0;
            }
            if (!raw) {
              filename = PATH_FS.resolve(filename);
              raw = preloadedImages[filename];
              if (!raw) {
                if (raw === null)
                  err("Trying to reuse preloaded image, but freePreloadedMediaOnUse is set!");
                warnOnce("Cannot find preloaded image " + filename);
                warnOnce("Cannot find preloaded image " + filename + ". Consider using STB_IMAGE=1 if you want synchronous image decoding (see settings.js), or package files with --use-preload-plugins");
                return 0;
              } else if (Module["freePreloadedMediaOnUse"]) {
                preloadedImages[filename] = null;
              }
            }
            var surf = SDL.makeSurface(raw.width, raw.height, 0, false, "load:" + filename);
            var surfData = SDL.surfaces[surf];
            surfData.ctx.globalCompositeOperation = "copy";
            if (!raw.rawData) {
              surfData.ctx.drawImage(raw, 0, 0, raw.width, raw.height, 0, 0, raw.width, raw.height);
            } else {
              var imageData = surfData.ctx.getImageData(0, 0, surfData.width, surfData.height);
              if (raw.bpp == 4) {
                imageData.data.set(HEAPU8.subarray(raw.data >>> 0, raw.data + raw.size >>> 0));
              } else if (raw.bpp == 3) {
                var pixels = raw.size / 3;
                var data2 = imageData.data;
                var sourcePtr = raw.data;
                var destPtr = 0;
                for (var i2 = 0; i2 < pixels; i2++) {
                  data2[destPtr++] = HEAPU8[sourcePtr++ >>> 0 >>> 0];
                  data2[destPtr++] = HEAPU8[sourcePtr++ >>> 0 >>> 0];
                  data2[destPtr++] = HEAPU8[sourcePtr++ >>> 0 >>> 0];
                  data2[destPtr++] = 255;
                }
              } else if (raw.bpp == 2) {
                var pixels = raw.size;
                var data2 = imageData.data;
                var sourcePtr = raw.data;
                var destPtr = 0;
                for (var i2 = 0; i2 < pixels; i2++) {
                  var gray = HEAPU8[sourcePtr++ >>> 0 >>> 0];
                  var alpha = HEAPU8[sourcePtr++ >>> 0 >>> 0];
                  data2[destPtr++] = gray;
                  data2[destPtr++] = gray;
                  data2[destPtr++] = gray;
                  data2[destPtr++] = alpha;
                }
              } else if (raw.bpp == 1) {
                var pixels = raw.size;
                var data2 = imageData.data;
                var sourcePtr = raw.data;
                var destPtr = 0;
                for (var i2 = 0; i2 < pixels; i2++) {
                  var value = HEAPU8[sourcePtr++ >>> 0 >>> 0];
                  data2[destPtr++] = value;
                  data2[destPtr++] = value;
                  data2[destPtr++] = value;
                  data2[destPtr++] = 255;
                }
              } else {
                err(`cannot handle bpp ${raw.bpp}`);
                return 0;
              }
              surfData.ctx.putImageData(imageData, 0, 0);
            }
            surfData.ctx.globalCompositeOperation = "source-over";
            _SDL_LockSurface(surf);
            surfData.locked--;
            if (SDL.GL) {
              surfData.canvas = surfData.ctx = null;
            }
            return surf;
          } finally {
            cleanup();
          }
        };
        _IMG_Load_RW.sig = "ppi";
        var _SDL_LoadBMP_RW = _IMG_Load_RW;
        _SDL_LoadBMP_RW.sig = "ppi";
        function _SDL_RWFromFile(_name, mode) {
          _name >>>= 0;
          mode >>>= 0;
          var id = SDL.rwops.length;
          var filename = UTF8ToString(_name);
          SDL.rwops.push({
            filename,
            mimetype: Browser.getMimetype(filename)
          });
          return id;
        }
        _SDL_RWFromFile.sig = "ppp";
        function _IMG_Load(filename) {
          filename >>>= 0;
          var rwops = _SDL_RWFromFile(filename, 0);
          var result = _IMG_Load_RW(rwops, 1);
          return result;
        }
        _IMG_Load.sig = "pp";
        var _IMG_Quit = () => out("IMG_Quit called (and ignored)");
        _IMG_Quit.sig = "v";
        function _SDL_OpenAudio(desired, obtained) {
          desired >>>= 0;
          obtained >>>= 0;
          try {
            SDL.audio = {
              freq: HEAPU32[desired >>> 2 >>> 0],
              format: HEAPU16[desired + 4 >>> 1 >>> 0],
              channels: HEAPU8[desired + 6 >>> 0 >>> 0],
              samples: HEAPU16[desired + 8 >>> 1 >>> 0],
              callback: HEAPU32[desired + 16 >>> 2 >>> 0],
              userdata: HEAPU32[desired + 20 >>> 2 >>> 0],
              paused: true,
              timer: null
            };
            if (SDL.audio.format == 8) {
              SDL.audio.silence = 128;
            } else if (SDL.audio.format == 32784) {
              SDL.audio.silence = 0;
            } else if (SDL.audio.format == 33056) {
              SDL.audio.silence = 0;
            } else {
              throw "Invalid SDL audio format " + SDL.audio.format + "!";
            }
            if (SDL.audio.freq <= 0) {
              throw "Unsupported sound frequency " + SDL.audio.freq + "!";
            } else if (SDL.audio.freq <= 22050) {
              SDL.audio.freq = 22050;
            } else if (SDL.audio.freq <= 32e3) {
              SDL.audio.freq = 32e3;
            } else if (SDL.audio.freq <= 44100) {
              SDL.audio.freq = 44100;
            } else if (SDL.audio.freq <= 48e3) {
              SDL.audio.freq = 48e3;
            } else if (SDL.audio.freq <= 96e3) {
              SDL.audio.freq = 96e3;
            } else {
              throw `Unsupported sound frequency ${SDL.audio.freq}!`;
            }
            if (SDL.audio.channels == 0) {
              SDL.audio.channels = 1;
            } else if (SDL.audio.channels < 0 || SDL.audio.channels > 32) {
              throw `Unsupported number of audio channels for SDL audio: ${SDL.audio.channels}!`;
            } else if (SDL.audio.channels != 1 && SDL.audio.channels != 2) {
              out(`Warning: Using untested number of audio channels ${SDL.audio.channels}`);
            }
            if (SDL.audio.samples < 128 || SDL.audio.samples > 524288) {
              throw `Unsupported audio callback buffer size ${SDL.audio.samples}!`;
            } else if ((SDL.audio.samples & SDL.audio.samples - 1) != 0) {
              throw `Audio callback buffer size ${SDL.audio.samples} must be a power-of-two!`;
            }
            var totalSamples = SDL.audio.samples * SDL.audio.channels;
            if (SDL.audio.format == 8) {
              SDL.audio.bytesPerSample = 1;
            } else if (SDL.audio.format == 32784) {
              SDL.audio.bytesPerSample = 2;
            } else if (SDL.audio.format == 33056) {
              SDL.audio.bytesPerSample = 4;
            } else {
              throw `Invalid SDL audio format ${SDL.audio.format}!`;
            }
            SDL.audio.bufferSize = totalSamples * SDL.audio.bytesPerSample;
            SDL.audio.bufferDurationSecs = SDL.audio.bufferSize / SDL.audio.bytesPerSample / SDL.audio.channels / SDL.audio.freq;
            SDL.audio.bufferingDelay = 50 / 1e3;
            SDL.audio.buffer = _malloc(SDL.audio.bufferSize);
            SDL.audio.numSimultaneouslyQueuedBuffers = Module["SDL_numSimultaneouslyQueuedBuffers"] || 5;
            SDL.audio.queueNewAudioData = () => {
              if (!SDL.audio)
                return;
              for (var i2 = 0; i2 < SDL.audio.numSimultaneouslyQueuedBuffers; ++i2) {
                var secsUntilNextPlayStart = SDL.audio.nextPlayTime - SDL.audioContext["currentTime"];
                if (secsUntilNextPlayStart >= SDL.audio.bufferingDelay + SDL.audio.bufferDurationSecs * SDL.audio.numSimultaneouslyQueuedBuffers)
                  return;
                getWasmTableEntry(SDL.audio.callback)(SDL.audio.userdata, SDL.audio.buffer, SDL.audio.bufferSize);
                SDL.audio.pushAudio(SDL.audio.buffer, SDL.audio.bufferSize);
              }
            };
            SDL.audio.caller = () => {
              if (!SDL.audio)
                return;
              --SDL.audio.numAudioTimersPending;
              SDL.audio.queueNewAudioData();
              var secsUntilNextPlayStart = SDL.audio.nextPlayTime - SDL.audioContext["currentTime"];
              var preemptBufferFeedSecs = SDL.audio.bufferDurationSecs / 2;
              if (SDL.audio.numAudioTimersPending < SDL.audio.numSimultaneouslyQueuedBuffers) {
                ++SDL.audio.numAudioTimersPending;
                SDL.audio.timer = safeSetTimeout(SDL.audio.caller, Math.max(0, 1e3 * (secsUntilNextPlayStart - preemptBufferFeedSecs)));
                if (SDL.audio.numAudioTimersPending < SDL.audio.numSimultaneouslyQueuedBuffers) {
                  ++SDL.audio.numAudioTimersPending;
                  safeSetTimeout(SDL.audio.caller, 1);
                }
              }
            };
            SDL.audio.audioOutput = new Audio();
            SDL.openAudioContext();
            if (!SDL.audioContext)
              throw "Web Audio API is not available!";
            autoResumeAudioContext(SDL.audioContext);
            SDL.audio.nextPlayTime = 0;
            SDL.audio.pushAudio = function(ptr2, sizeBytes) {
              try {
                if (SDL.audio.paused)
                  return;
                var sizeSamples = sizeBytes / SDL.audio.bytesPerSample;
                var sizeSamplesPerChannel = sizeSamples / SDL.audio.channels;
                if (sizeSamplesPerChannel != SDL.audio.samples) {
                  throw "Received mismatching audio buffer size!";
                }
                var source = SDL.audioContext["createBufferSource"]();
                var soundBuffer = SDL.audioContext["createBuffer"](SDL.audio.channels, sizeSamplesPerChannel, SDL.audio.freq);
                source["connect"](SDL.audioContext["destination"]);
                SDL.fillWebAudioBufferFromHeap(ptr2, sizeSamplesPerChannel, soundBuffer);
                source["buffer"] = soundBuffer;
                var curtime = SDL.audioContext["currentTime"];
                var playtime = Math.max(curtime + SDL.audio.bufferingDelay, SDL.audio.nextPlayTime);
                if (typeof source["start"] != "undefined") {
                  source["start"](playtime);
                } else if (typeof source["noteOn"] != "undefined") {
                  source["noteOn"](playtime);
                }
                SDL.audio.nextPlayTime = playtime + SDL.audio.bufferDurationSecs;
              } catch (e) {
                err(`Web Audio API error playing back audio: ${e.toString()}`);
              }
            };
            if (obtained) {
              HEAP32[obtained >>> 2 >>> 0] = SDL.audio.freq;
              HEAP16[obtained + 4 >>> 1 >>> 0] = SDL.audio.format;
              HEAP8[obtained + 6 >>> 0 >>> 0] = SDL.audio.channels;
              HEAP8[obtained + 7 >>> 0 >>> 0] = SDL.audio.silence;
              HEAP16[obtained + 8 >>> 1 >>> 0] = SDL.audio.samples;
              HEAPU32[obtained + 16 >>> 2 >>> 0] = SDL.audio.callback;
              HEAPU32[obtained + 20 >>> 2 >>> 0] = SDL.audio.userdata;
            }
            SDL.allocateChannels(32);
          } catch (e) {
            err(`Initializing SDL audio threw an exception: "${e.toString()}"! Continuing without audio`);
            SDL.audio = null;
            SDL.allocateChannels(0);
            if (obtained) {
              HEAP32[obtained >>> 2 >>> 0] = 0;
              HEAP16[obtained + 4 >>> 1 >>> 0] = 0;
              HEAP8[obtained + 6 >>> 0 >>> 0] = 0;
              HEAP8[obtained + 7 >>> 0 >>> 0] = 0;
              HEAP16[obtained + 8 >>> 1 >>> 0] = 0;
              HEAPU32[obtained + 16 >>> 2 >>> 0] = 0;
              HEAPU32[obtained + 20 >>> 2 >>> 0] = 0;
            }
          }
          if (!SDL.audio) {
            return -1;
          }
          return 0;
        }
        _SDL_OpenAudio.sig = "ipp";
        var _SDL_PauseAudio = (pauseOn) => {
          if (!SDL.audio) {
            return;
          }
          if (pauseOn) {
            if (SDL.audio.timer !== void 0) {
              clearTimeout(SDL.audio.timer);
              SDL.audio.numAudioTimersPending = 0;
              SDL.audio.timer = void 0;
            }
          } else if (!SDL.audio.timer) {
            SDL.audio.numAudioTimersPending = 1;
            SDL.audio.timer = safeSetTimeout(SDL.audio.caller, 1);
          }
          SDL.audio.paused = pauseOn;
        };
        _SDL_PauseAudio.sig = "vi";
        var _SDL_CloseAudio = () => {
          if (SDL.audio) {
            if (SDL.audio.callbackRemover) {
              SDL.audio.callbackRemover();
              SDL.audio.callbackRemover = null;
            }
            _SDL_PauseAudio(1);
            _free(SDL.audio.buffer);
            SDL.audio = null;
            SDL.allocateChannels(0);
          }
        };
        _SDL_CloseAudio.sig = "v";
        var _SDL_LockAudio = () => {
        };
        _SDL_LockAudio.sig = "v";
        var _SDL_UnlockAudio = () => {
        };
        _SDL_UnlockAudio.sig = "v";
        function _SDL_CreateMutex() {
          return 0;
        }
        _SDL_CreateMutex.sig = "p";
        function _SDL_mutexP(mutex) {
          mutex >>>= 0;
          return 0;
        }
        _SDL_mutexP.sig = "ip";
        function _SDL_mutexV(mutex) {
          mutex >>>= 0;
          return 0;
        }
        _SDL_mutexV.sig = "ip";
        function _SDL_DestroyMutex(mutex) {
          mutex >>>= 0;
        }
        _SDL_DestroyMutex.sig = "vp";
        function _SDL_CreateCond() {
          return 0;
        }
        _SDL_CreateCond.sig = "p";
        function _SDL_CondSignal(cond) {
          cond >>>= 0;
        }
        _SDL_CondSignal.sig = "ip";
        function _SDL_CondWait(cond, mutex) {
          cond >>>= 0;
          mutex >>>= 0;
        }
        _SDL_CondWait.sig = "ipp";
        function _SDL_DestroyCond(cond) {
          cond >>>= 0;
        }
        _SDL_DestroyCond.sig = "vp";
        var _SDL_StartTextInput = () => {
          SDL.textInput = true;
        };
        _SDL_StartTextInput.sig = "v";
        var _SDL_StopTextInput = () => {
          SDL.textInput = false;
        };
        _SDL_StopTextInput.sig = "v";
        var _Mix_Init = (flags2) => {
          if (!flags2)
            return 0;
          return 8;
        };
        _Mix_Init.sig = "ii";
        var _Mix_Quit = () => {
        };
        _Mix_Quit.sig = "v";
        var _Mix_OpenAudio = (frequency, format, channels, chunksize) => {
          SDL.openAudioContext();
          autoResumeAudioContext(SDL.audioContext);
          SDL.allocateChannels(32);
          SDL.mixerFrequency = frequency;
          SDL.mixerFormat = format;
          SDL.mixerNumChannels = channels;
          SDL.mixerChunkSize = chunksize;
          return 0;
        };
        _Mix_OpenAudio.sig = "iiiii";
        var _Mix_CloseAudio = _SDL_CloseAudio;
        _Mix_CloseAudio.sig = "v";
        var _Mix_AllocateChannels = (num) => {
          SDL.allocateChannels(num);
          return num;
        };
        _Mix_AllocateChannels.sig = "ii";
        function _Mix_ChannelFinished(func2) {
          func2 >>>= 0;
          SDL.channelFinished = func2;
        }
        _Mix_ChannelFinished.sig = "vp";
        var _Mix_Volume = (channel, volume) => {
          if (channel == -1) {
            for (var i2 = 0; i2 < SDL.numChannels - 1; i2++) {
              _Mix_Volume(i2, volume);
            }
            return _Mix_Volume(SDL.numChannels - 1, volume);
          }
          return SDL.setGetVolume(SDL.channels[channel], volume);
        };
        _Mix_Volume.sig = "iii";
        var _Mix_SetPanning = (channel, left, right) => {
          left /= 255;
          right /= 255;
          SDL.setPannerPosition(SDL.channels[channel], right - left, 0, 0.1);
          return 1;
        };
        _Mix_SetPanning.sig = "iiii";
        function _Mix_LoadWAV_RW(rwopsID, freesrc) {
          rwopsID >>>= 0;
          var rwops = SDL.rwops[rwopsID];
          if (rwops === void 0)
            return 0;
          var filename = "";
          var audio;
          var webAudio;
          var bytes;
          if (rwops.filename !== void 0) {
            filename = PATH_FS.resolve(rwops.filename);
            var raw = preloadedAudios[filename];
            if (!raw) {
              if (raw === null)
                err("Trying to reuse preloaded audio, but freePreloadedMediaOnUse is set!");
              if (!Module.noAudioDecoding)
                warnOnce("Cannot find preloaded audio " + filename);
              try {
                bytes = FS.readFile(filename);
              } catch (e) {
                err(`Couldn't find file for: ${filename}`);
                return 0;
              }
            }
            if (Module["freePreloadedMediaOnUse"]) {
              preloadedAudios[filename] = null;
            }
            audio = raw;
          } else if (rwops.bytes !== void 0) {
            if (SDL.webAudioAvailable())
              bytes = HEAPU8.buffer.slice(rwops.bytes, rwops.bytes + rwops.count);
            else
              bytes = HEAPU8.subarray(rwops.bytes >>> 0, rwops.bytes + rwops.count >>> 0);
          } else {
            return 0;
          }
          var arrayBuffer = bytes ? bytes.buffer || bytes : bytes;
          var canPlayWithWebAudio = Module["SDL_canPlayWithWebAudio"] === void 0 || Module["SDL_canPlayWithWebAudio"](filename, arrayBuffer);
          if (bytes !== void 0 && SDL.webAudioAvailable() && canPlayWithWebAudio) {
            audio = void 0;
            webAudio = {};
            webAudio.onDecodeComplete = [];
            var onDecodeComplete = (data2) => {
              webAudio.decodedBuffer = data2;
              webAudio.onDecodeComplete.forEach((e) => e());
              webAudio.onDecodeComplete = void 0;
            };
            SDL.audioContext["decodeAudioData"](arrayBuffer, onDecodeComplete);
          } else if (audio === void 0 && bytes) {
            var blob = new Blob([bytes], {
              type: rwops.mimetype
            });
            var url2 = URL.createObjectURL(blob);
            audio = new Audio();
            audio.src = url2;
            audio.mozAudioChannelType = "content";
          }
          var id = SDL.audios.length;
          SDL.audios.push({
            source: filename,
            audio,
            webAudio
          });
          return id;
        }
        _Mix_LoadWAV_RW.sig = "ppi";
        function _Mix_LoadWAV(filename) {
          filename >>>= 0;
          var rwops = _SDL_RWFromFile(filename, 0);
          var result = _Mix_LoadWAV_RW(rwops, 0);
          _SDL_FreeRW(rwops);
          return result;
        }
        _Mix_LoadWAV.sig = "pp";
        function _Mix_QuickLoad_RAW(mem, len2) {
          mem >>>= 0;
          var audio;
          var webAudio;
          var numSamples = len2 >> 1;
          var buffer = new Float32Array(numSamples);
          for (var i2 = 0; i2 < numSamples; ++i2) {
            buffer[i2] = HEAP16[mem + i2 * 2 >>> 1 >>> 0] / 32768;
          }
          if (SDL.webAudioAvailable()) {
            webAudio = {};
            webAudio.decodedBuffer = buffer;
          } else {
            audio = new Audio();
            audio.mozAudioChannelType = "content";
            audio.numChannels = SDL.mixerNumChannels;
            audio.frequency = SDL.mixerFrequency;
          }
          var id = SDL.audios.length;
          SDL.audios.push({
            source: "",
            audio,
            webAudio,
            buffer
          });
          return id;
        }
        _Mix_QuickLoad_RAW.sig = "ppi";
        function _Mix_FreeChunk(id) {
          id >>>= 0;
          SDL.audios[id] = null;
        }
        _Mix_FreeChunk.sig = "vp";
        var _Mix_ReserveChannels = (num) => {
          SDL.channelMinimumNumber = num;
        };
        _Mix_ReserveChannels.sig = "ii";
        function _Mix_PlayChannelTimed(channel, id, loops, ticks) {
          id >>>= 0;
          assert(ticks == -1);
          var info2 = SDL.audios[id];
          if (!info2)
            return -1;
          if (!info2.audio && !info2.webAudio)
            return -1;
          if (channel == -1) {
            for (var i2 = SDL.channelMinimumNumber; i2 < SDL.numChannels; i2++) {
              if (!SDL.channels[i2].audio) {
                channel = i2;
                break;
              }
            }
            if (channel == -1) {
              err(`All ${SDL.numChannels}  channels in use!`);
              return -1;
            }
          }
          var channelInfo = SDL.channels[channel];
          var audio;
          if (info2.webAudio) {
            audio = {};
            audio.resource = info2;
            audio.paused = false;
            audio.currentPosition = 0;
            audio.play = function() {
              SDL.playWebAudio(this);
            };
            audio.pause = function() {
              SDL.pauseWebAudio(this);
            };
          } else {
            audio = info2.audio.cloneNode(true);
            audio.numChannels = info2.audio.numChannels;
            audio.frequency = info2.audio.frequency;
          }
          audio["onended"] = function() {
            if (channelInfo.audio == this) {
              channelInfo.audio.paused = true;
              channelInfo.audio = null;
            }
            if (SDL.channelFinished)
              getWasmTableEntry(SDL.channelFinished)(channel);
          };
          channelInfo.audio = audio;
          audio.loop = loops != 0;
          audio.volume = channelInfo.volume;
          audio.play();
          return channel;
        }
        _Mix_PlayChannelTimed.sig = "iipii";
        var _Mix_FadingChannel = (channel) => 0;
        _Mix_FadingChannel.sig = "ii";
        var _Mix_HaltChannel = (channel) => {
          function halt(channel2) {
            var info2 = SDL.channels[channel2];
            if (info2.audio) {
              info2.audio.pause();
              info2.audio = null;
            }
            if (SDL.channelFinished) {
              getWasmTableEntry(SDL.channelFinished)(channel2);
            }
          }
          if (channel != -1) {
            halt(channel);
          } else {
            for (var i2 = 0; i2 < SDL.channels.length; ++i2)
              halt(i2);
          }
          return 0;
        };
        _Mix_HaltChannel.sig = "ii";
        var _Mix_HaltMusic = () => {
          var audio = SDL.music.audio;
          if (audio) {
            audio.src = audio.src;
            audio.currentPosition = 0;
            audio.pause();
          }
          SDL.music.audio = null;
          if (SDL.hookMusicFinished) {
            getWasmTableEntry(SDL.hookMusicFinished)();
          }
          return 0;
        };
        _Mix_HaltMusic.sig = "i";
        function _Mix_HookMusicFinished(func2) {
          func2 >>>= 0;
          SDL.hookMusicFinished = func2;
          if (SDL.music.audio) {
            SDL.music.audio["onended"] = _Mix_HaltMusic;
          }
        }
        _Mix_HookMusicFinished.sig = "vp";
        var _Mix_VolumeMusic = (volume) => SDL.setGetVolume(SDL.music, volume);
        _Mix_VolumeMusic.sig = "ii";
        var _Mix_LoadMUS_RW = _Mix_LoadWAV_RW;
        _Mix_LoadMUS_RW.sig = "pp";
        function _Mix_LoadMUS(filename) {
          filename >>>= 0;
          var rwops = _SDL_RWFromFile(filename, 0);
          var result = _Mix_LoadMUS_RW(rwops, 0);
          _SDL_FreeRW(rwops);
          return result;
        }
        _Mix_LoadMUS.sig = "pp";
        var _Mix_FreeMusic = _Mix_FreeChunk;
        _Mix_FreeMusic.sig = "vp";
        function _Mix_PlayMusic(id, loops) {
          id >>>= 0;
          if (SDL.music.audio) {
            if (!SDL.music.audio.paused)
              err(`Music is already playing. ${SDL.music.source}`);
            SDL.music.audio.pause();
          }
          var info2 = SDL.audios[id];
          var audio;
          if (info2.webAudio) {
            audio = {};
            audio.resource = info2;
            audio.paused = false;
            audio.currentPosition = 0;
            audio.play = function() {
              SDL.playWebAudio(this);
            };
            audio.pause = function() {
              SDL.pauseWebAudio(this);
            };
          } else if (info2.audio) {
            audio = info2.audio;
          }
          audio["onended"] = function() {
            if (SDL.music.audio == this)
              _Mix_HaltMusic();
          };
          audio.loop = loops != 0 && loops != 1;
          audio.volume = SDL.music.volume;
          SDL.music.audio = audio;
          audio.play();
          return 0;
        }
        _Mix_PlayMusic.sig = "ipi";
        var _Mix_PauseMusic = () => {
          var audio = SDL.music.audio;
          audio == null ? void 0 : audio.pause();
        };
        _Mix_PauseMusic.sig = "v";
        var _Mix_ResumeMusic = () => {
          var audio = SDL.music.audio;
          audio == null ? void 0 : audio.play();
        };
        _Mix_ResumeMusic.sig = "v";
        var _Mix_FadeInMusicPos = _Mix_PlayMusic;
        _Mix_FadeInMusicPos.sig = "ipiid";
        var _Mix_FadeOutMusic = _Mix_HaltMusic;
        _Mix_FadeOutMusic.sig = "ii";
        var _Mix_PlayingMusic = () => SDL.music.audio && !SDL.music.audio.paused ? 1 : 0;
        _Mix_PlayingMusic.sig = "i";
        var _Mix_Playing = (channel) => {
          if (channel === -1) {
            var count = 0;
            for (var i2 = 0; i2 < SDL.channels.length; i2++) {
              count += _Mix_Playing(i2);
            }
            return count;
          }
          var info2 = SDL.channels[channel];
          if ((info2 == null ? void 0 : info2.audio) && !info2.audio.paused) {
            return 1;
          }
          return 0;
        };
        _Mix_Playing.sig = "ii";
        var _Mix_Pause = (channel) => {
          if (channel === -1) {
            for (var i2 = 0; i2 < SDL.channels.length; i2++) {
              _Mix_Pause(i2);
            }
            return;
          }
          var info2 = SDL.channels[channel];
          if (info2 == null ? void 0 : info2.audio) {
            info2.audio.pause();
          } else {
          }
        };
        _Mix_Pause.sig = "vi";
        var _Mix_Paused = (channel) => {
          var _a;
          if (channel === -1) {
            var pausedCount = 0;
            for (var i2 = 0; i2 < SDL.channels.length; i2++) {
              pausedCount += _Mix_Paused(i2);
            }
            return pausedCount;
          }
          var info2 = SDL.channels[channel];
          if ((_a = info2 == null ? void 0 : info2.audio) == null ? void 0 : _a.paused) {
            return 1;
          }
          return 0;
        };
        _Mix_Paused.sig = "ii";
        var _Mix_PausedMusic = () => {
          var _a;
          return ((_a = SDL.music.audio) == null ? void 0 : _a.paused) ? 1 : 0;
        };
        _Mix_PausedMusic.sig = "i";
        var _Mix_Resume = (channel) => {
          if (channel === -1) {
            for (var i2 = 0; i2 < SDL.channels.length; i2++) {
              _Mix_Resume(i2);
            }
            return;
          }
          var info2 = SDL.channels[channel];
          if (info2 == null ? void 0 : info2.audio)
            info2.audio.play();
        };
        _Mix_Resume.sig = "vi";
        var _TTF_Init = () => {
          try {
            var offscreenCanvas = new OffscreenCanvas(0, 0);
            SDL.ttfContext = offscreenCanvas.getContext("2d");
            if (typeof SDL.ttfContext.measureText != "function") {
              throw "bad context";
            }
          } catch (ex) {
            var canvas = document.createElement("canvas");
            SDL.ttfContext = canvas.getContext("2d");
          }
          return 0;
        };
        _TTF_Init.sig = "i";
        function _TTF_OpenFont(name2, size) {
          name2 >>>= 0;
          name2 = PATH.normalize(UTF8ToString(name2));
          var id = SDL.fonts.length;
          SDL.fonts.push({
            name: name2,
            size
          });
          return id;
        }
        _TTF_OpenFont.sig = "ppi";
        function _TTF_CloseFont(font) {
          font >>>= 0;
          SDL.fonts[font] = null;
        }
        _TTF_CloseFont.sig = "vp";
        function _TTF_RenderText_Solid(font, text, color) {
          font >>>= 0;
          text >>>= 0;
          color >>>= 0;
          text = UTF8ToString(text) || " ";
          var fontData = SDL.fonts[font];
          var w = SDL.estimateTextWidth(fontData, text);
          var h = fontData.size;
          color = SDL.loadColorToCSSRGB(color);
          var fontString = SDL.makeFontString(h, fontData.name);
          var surf = SDL.makeSurface(w, h, 0, false, "text:" + text);
          var surfData = SDL.surfaces[surf];
          surfData.ctx.save();
          surfData.ctx.fillStyle = color;
          surfData.ctx.font = fontString;
          surfData.ctx.textBaseline = "bottom";
          surfData.ctx.fillText(text, 0, h | 0);
          surfData.ctx.restore();
          return surf;
        }
        _TTF_RenderText_Solid.sig = "pppp";
        var _TTF_RenderText_Blended = _TTF_RenderText_Solid;
        _TTF_RenderText_Blended.sig = "pppp";
        var _TTF_RenderText_Shaded = _TTF_RenderText_Solid;
        _TTF_RenderText_Shaded.sig = "ppppp";
        var _TTF_RenderUTF8_Solid = _TTF_RenderText_Solid;
        _TTF_RenderUTF8_Solid.sig = "pppp";
        function _TTF_SizeText(font, text, w, h) {
          font >>>= 0;
          text >>>= 0;
          w >>>= 0;
          h >>>= 0;
          var fontData = SDL.fonts[font];
          if (w) {
            HEAP32[w >>> 2 >>> 0] = SDL.estimateTextWidth(fontData, UTF8ToString(text));
          }
          if (h) {
            HEAP32[h >>> 2 >>> 0] = fontData.size;
          }
          return 0;
        }
        _TTF_SizeText.sig = "ipppp";
        var _TTF_SizeUTF8 = _TTF_SizeText;
        _TTF_SizeUTF8.sig = "ipppp";
        function _TTF_GlyphMetrics(font, ch, minx, maxx, miny, maxy, advance) {
          font >>>= 0;
          minx >>>= 0;
          maxx >>>= 0;
          miny >>>= 0;
          maxy >>>= 0;
          advance >>>= 0;
          var fontData = SDL.fonts[font];
          var width = SDL.estimateTextWidth(fontData, String.fromCharCode(ch));
          if (advance) {
            HEAP32[advance >>> 2 >>> 0] = width;
          }
          if (minx) {
            HEAP32[minx >>> 2 >>> 0] = 0;
          }
          if (maxx) {
            HEAP32[maxx >>> 2 >>> 0] = width;
          }
          if (miny) {
            HEAP32[miny >>> 2 >>> 0] = 0;
          }
          if (maxy) {
            HEAP32[maxy >>> 2 >>> 0] = fontData.size;
          }
        }
        _TTF_GlyphMetrics.sig = "ipippppp";
        function _TTF_FontAscent(font) {
          font >>>= 0;
          var fontData = SDL.fonts[font];
          return fontData.size * 0.98 | 0;
        }
        _TTF_FontAscent.sig = "ip";
        function _TTF_FontDescent(font) {
          font >>>= 0;
          var fontData = SDL.fonts[font];
          return fontData.size * 0.02 | 0;
        }
        _TTF_FontDescent.sig = "ip";
        function _TTF_FontHeight(font) {
          font >>>= 0;
          var fontData = SDL.fonts[font];
          return fontData.size;
        }
        _TTF_FontHeight.sig = "ip";
        var _TTF_FontLineSkip = _TTF_FontHeight;
        _TTF_FontLineSkip.sig = "ip";
        var _TTF_Quit = () => out("TTF_Quit called (and ignored)");
        _TTF_Quit.sig = "v";
        var SDL_gfx = {
          drawRectangle: (surf, x1, y1, x2, y2, action, cssColor) => {
            x1 = x1 << 16 >> 16;
            y1 = y1 << 16 >> 16;
            x2 = x2 << 16 >> 16;
            y2 = y2 << 16 >> 16;
            var surfData = SDL.surfaces[surf];
            assert(!surfData.locked);
            var x = x1 < x2 ? x1 : x2;
            var y = y1 < y2 ? y1 : y2;
            var w = Math.abs(x2 - x1);
            var h = Math.abs(y2 - y1);
            surfData.ctx.save();
            surfData.ctx[action + "Style"] = cssColor;
            surfData.ctx[action + "Rect"](x, y, w, h);
            surfData.ctx.restore();
          },
          drawLine: (surf, x1, y1, x2, y2, cssColor) => {
            x1 = x1 << 16 >> 16;
            y1 = y1 << 16 >> 16;
            x2 = x2 << 16 >> 16;
            y2 = y2 << 16 >> 16;
            var surfData = SDL.surfaces[surf];
            assert(!surfData.locked);
            surfData.ctx.save();
            surfData.ctx.strokeStyle = cssColor;
            surfData.ctx.beginPath();
            surfData.ctx.moveTo(x1, y1);
            surfData.ctx.lineTo(x2, y2);
            surfData.ctx.stroke();
            surfData.ctx.restore();
          },
          drawEllipse: (surf, x, y, rx, ry, action, cssColor) => {
            x = x << 16 >> 16;
            y = y << 16 >> 16;
            rx = rx << 16 >> 16;
            ry = ry << 16 >> 16;
            var surfData = SDL.surfaces[surf];
            assert(!surfData.locked);
            surfData.ctx.save();
            surfData.ctx.beginPath();
            surfData.ctx.translate(x, y);
            surfData.ctx.scale(rx, ry);
            surfData.ctx.arc(0, 0, 1, 0, 2 * Math.PI);
            surfData.ctx.restore();
            surfData.ctx.save();
            surfData.ctx[action + "Style"] = cssColor;
            surfData.ctx[action]();
            surfData.ctx.restore();
          },
          translateColorToCSSRGBA: (rgba) => `rgba(${rgba >>> 24},${rgba >> 16 & 255},${rgba >> 8 & 255},${rgba & 255})`
        };
        function _boxColor(surf, x1, y1, x2, y2, color) {
          surf >>>= 0;
          return SDL_gfx.drawRectangle(surf, x1, y1, x2, y2, "fill", SDL_gfx.translateColorToCSSRGBA(color));
        }
        _boxColor.sig = "ipiiiii";
        function _boxRGBA(surf, x1, y1, x2, y2, r, g, b, a) {
          surf >>>= 0;
          return SDL_gfx.drawRectangle(surf, x1, y1, x2, y2, "fill", SDL.translateRGBAToCSSRGBA(r, g, b, a));
        }
        _boxRGBA.sig = "ipiiiiiiii";
        function _rectangleColor(surf, x1, y1, x2, y2, color) {
          surf >>>= 0;
          return SDL_gfx.drawRectangle(surf, x1, y1, x2, y2, "stroke", SDL_gfx.translateColorToCSSRGBA(color));
        }
        _rectangleColor.sig = "ipiiiii";
        function _rectangleRGBA(surf, x1, y1, x2, y2, r, g, b, a) {
          surf >>>= 0;
          return SDL_gfx.drawRectangle(surf, x1, y1, x2, y2, "stroke", SDL.translateRGBAToCSSRGBA(r, g, b, a));
        }
        _rectangleRGBA.sig = "ipiiiiiiii";
        function _ellipseColor(surf, x, y, rx, ry, color) {
          surf >>>= 0;
          return SDL_gfx.drawEllipse(surf, x, y, rx, ry, "stroke", SDL_gfx.translateColorToCSSRGBA(color));
        }
        _ellipseColor.sig = "ipiiiii";
        function _ellipseRGBA(surf, x, y, rx, ry, r, g, b, a) {
          surf >>>= 0;
          return SDL_gfx.drawEllipse(surf, x, y, rx, ry, "stroke", SDL.translateRGBAToCSSRGBA(r, g, b, a));
        }
        _ellipseRGBA.sig = "ipiiiiiiii";
        function _filledEllipseColor(surf, x, y, rx, ry, color) {
          surf >>>= 0;
          return SDL_gfx.drawEllipse(surf, x, y, rx, ry, "fill", SDL_gfx.translateColorToCSSRGBA(color));
        }
        _filledEllipseColor.sig = "ipiiiii";
        function _filledEllipseRGBA(surf, x, y, rx, ry, r, g, b, a) {
          surf >>>= 0;
          return SDL_gfx.drawEllipse(surf, x, y, rx, ry, "fill", SDL.translateRGBAToCSSRGBA(r, g, b, a));
        }
        _filledEllipseRGBA.sig = "ipiiiiiiii";
        function _lineColor(surf, x1, y1, x2, y2, color) {
          surf >>>= 0;
          return SDL_gfx.drawLine(surf, x1, y1, x2, y2, SDL_gfx.translateColorToCSSRGBA(color));
        }
        _lineColor.sig = "ipiiiii";
        function _lineRGBA(surf, x1, y1, x2, y2, r, g, b, a) {
          surf >>>= 0;
          return SDL_gfx.drawLine(surf, x1, y1, x2, y2, SDL.translateRGBAToCSSRGBA(r, g, b, a));
        }
        _lineRGBA.sig = "ipiiiiiiii";
        function _pixelRGBA(surf, x1, y1, r, g, b, a) {
          surf >>>= 0;
          return _boxRGBA(surf, x1, y1, x1, y1, r, g, b, a);
        }
        _pixelRGBA.sig = "ipiiiiii";
        var _SDL_GL_SetAttribute = (attr, value) => {
          if (!(attr in SDL.glAttributes)) {
            abort("Unknown SDL GL attribute (" + attr + "). Please check if your SDL version is supported.");
          }
          SDL.glAttributes[attr] = value;
        };
        _SDL_GL_SetAttribute.sig = "iii";
        function _SDL_GL_GetAttribute(attr, value) {
          value >>>= 0;
          if (!(attr in SDL.glAttributes)) {
            abort("Unknown SDL GL attribute (" + attr + "). Please check if your SDL version is supported.");
          }
          if (value)
            HEAP32[value >>> 2 >>> 0] = SDL.glAttributes[attr];
          return 0;
        }
        _SDL_GL_GetAttribute.sig = "iip";
        var _SDL_GL_SwapBuffers = () => {
          var _a;
          (_a = Browser.doSwapBuffers) == null ? void 0 : _a.call(Browser);
        };
        _SDL_GL_SwapBuffers.sig = "v";
        function _SDL_GL_ExtensionSupported(extension) {
          extension >>>= 0;
          return Module.ctx.getExtension(extension) | 0;
        }
        _SDL_GL_ExtensionSupported.sig = "ip";
        function _SDL_DestroyWindow(window2) {
          window2 >>>= 0;
        }
        _SDL_DestroyWindow.sig = "vp";
        function _SDL_DestroyRenderer(renderer) {
          renderer >>>= 0;
        }
        _SDL_DestroyRenderer.sig = "vp";
        function _SDL_GetWindowFlags(window2) {
          window2 >>>= 0;
          if (Browser.isFullscreen) {
            return 1;
          }
          return 0;
        }
        _SDL_GetWindowFlags.sig = "ip";
        function _SDL_GL_SwapWindow(window2) {
          window2 >>>= 0;
        }
        _SDL_GL_SwapWindow.sig = "vp";
        function _SDL_GL_MakeCurrent(window2, context) {
          window2 >>>= 0;
          context >>>= 0;
        }
        _SDL_GL_MakeCurrent.sig = "ipp";
        function _SDL_GL_DeleteContext(context) {
          context >>>= 0;
        }
        _SDL_GL_DeleteContext.sig = "vp";
        var _SDL_GL_GetSwapInterval = () => {
          if (Browser.mainLoop.timingMode == 1)
            return Browser.mainLoop.timingValue;
          else
            return 0;
        };
        _SDL_GL_GetSwapInterval.sig = "i";
        var _SDL_GL_SetSwapInterval = (state) => {
          _emscripten_set_main_loop_timing(1, state);
        };
        _SDL_GL_SetSwapInterval.sig = "ii";
        function _SDL_SetWindowTitle(window2, title) {
          window2 >>>= 0;
          title >>>= 0;
          if (title)
            document.title = UTF8ToString(title);
        }
        _SDL_SetWindowTitle.sig = "vpp";
        function _SDL_GetWindowSize(window2, width, height) {
          window2 >>>= 0;
          width >>>= 0;
          height >>>= 0;
          var w = Module["canvas"].width;
          var h = Module["canvas"].height;
          if (width)
            HEAP32[width >>> 2 >>> 0] = w;
          if (height)
            HEAP32[height >>> 2 >>> 0] = h;
        }
        _SDL_GetWindowSize.sig = "vppp";
        function _SDL_LogSetOutputFunction(callback, userdata) {
          callback >>>= 0;
          userdata >>>= 0;
        }
        _SDL_LogSetOutputFunction.sig = "vpp";
        function _SDL_SetWindowFullscreen(window2, fullscreen) {
          window2 >>>= 0;
          if (Browser.isFullscreen) {
            Module["canvas"].exitFullscreen();
            return 1;
          }
          return 0;
        }
        _SDL_SetWindowFullscreen.sig = "ipi";
        var _SDL_ClearError = () => {
        };
        _SDL_ClearError.sig = "v";
        var _SDL_SetGamma = (r, g, b) => -1;
        _SDL_SetGamma.sig = "ifff";
        function _SDL_SetGammaRamp(redTable, greenTable, blueTable) {
          redTable >>>= 0;
          greenTable >>>= 0;
          blueTable >>>= 0;
          return -1;
        }
        _SDL_SetGammaRamp.sig = "ippp";
        var _SDL_NumJoysticks = () => {
          var count = 0;
          var gamepads = SDL.getGamepads();
          for (var i2 = 0; i2 < gamepads.length; i2++) {
            if (gamepads[i2] !== void 0)
              count++;
          }
          return count;
        };
        _SDL_NumJoysticks.sig = "i";
        function _SDL_JoystickName(deviceIndex) {
          var gamepad = SDL.getGamepad(deviceIndex);
          if (gamepad) {
            var name2 = gamepad.id;
            if (SDL.joystickNamePool.hasOwnProperty(name2)) {
              return SDL.joystickNamePool[name2];
            }
            return SDL.joystickNamePool[name2] = stringToNewUTF8(name2);
          }
          return 0;
        }
        _SDL_JoystickName.sig = "pi";
        function _SDL_JoystickOpen(deviceIndex) {
          var gamepad = SDL.getGamepad(deviceIndex);
          if (gamepad) {
            var joystick = deviceIndex + 1;
            SDL.recordJoystickState(joystick, gamepad);
            return joystick;
          }
          return 0;
        }
        _SDL_JoystickOpen.sig = "pi";
        var _SDL_JoystickOpened = (deviceIndex) => SDL.lastJoystickState.hasOwnProperty(deviceIndex + 1) ? 1 : 0;
        _SDL_JoystickOpened.sig = "ii";
        function _SDL_JoystickIndex(joystick) {
          joystick >>>= 0;
          return joystick - 1;
        }
        _SDL_JoystickIndex.sig = "ip";
        function _SDL_JoystickNumAxes(joystick) {
          joystick >>>= 0;
          var gamepad = SDL.getGamepad(joystick - 1);
          if (gamepad) {
            return gamepad.axes.length;
          }
          return 0;
        }
        _SDL_JoystickNumAxes.sig = "ip";
        function _SDL_JoystickNumBalls(joystick) {
          joystick >>>= 0;
          return 0;
        }
        _SDL_JoystickNumBalls.sig = "ip";
        function _SDL_JoystickNumHats(joystick) {
          joystick >>>= 0;
          return 0;
        }
        _SDL_JoystickNumHats.sig = "ip";
        function _SDL_JoystickNumButtons(joystick) {
          joystick >>>= 0;
          var gamepad = SDL.getGamepad(joystick - 1);
          if (gamepad) {
            return gamepad.buttons.length;
          }
          return 0;
        }
        _SDL_JoystickNumButtons.sig = "ip";
        var _SDL_JoystickUpdate = () => SDL.queryJoysticks();
        _SDL_JoystickUpdate.sig = "v";
        var _SDL_JoystickEventState = (state) => {
          if (state < 0) {
            return SDL.joystickEventState;
          }
          return SDL.joystickEventState = state;
        };
        _SDL_JoystickEventState.sig = "ii";
        function _SDL_JoystickGetAxis(joystick, axis) {
          joystick >>>= 0;
          var gamepad = SDL.getGamepad(joystick - 1);
          if (gamepad && gamepad.axes.length > axis) {
            return SDL.joystickAxisValueConversion(gamepad.axes[axis]);
          }
          return 0;
        }
        _SDL_JoystickGetAxis.sig = "ipi";
        function _SDL_JoystickGetHat(joystick, hat) {
          joystick >>>= 0;
          return 0;
        }
        _SDL_JoystickGetHat.sig = "ipi";
        function _SDL_JoystickGetBall(joystick, ball, dxptr, dyptr) {
          joystick >>>= 0;
          dxptr >>>= 0;
          dyptr >>>= 0;
          return -1;
        }
        _SDL_JoystickGetBall.sig = "ipipp";
        function _SDL_JoystickGetButton(joystick, button) {
          joystick >>>= 0;
          var gamepad = SDL.getGamepad(joystick - 1);
          if (gamepad && gamepad.buttons.length > button) {
            return SDL.getJoystickButtonState(gamepad.buttons[button]) ? 1 : 0;
          }
          return 0;
        }
        _SDL_JoystickGetButton.sig = "ipi";
        function _SDL_JoystickClose(joystick) {
          joystick >>>= 0;
          delete SDL.lastJoystickState[joystick];
        }
        _SDL_JoystickClose.sig = "vp";
        var _SDL_InitSubSystem = (flags2) => 0;
        _SDL_InitSubSystem.sig = "ii";
        function _SDL_RWFromConstMem(mem, size) {
          mem >>>= 0;
          var id = SDL.rwops.length;
          SDL.rwops.push({
            bytes: mem,
            count: size
          });
          return id;
        }
        _SDL_RWFromConstMem.sig = "ppi";
        var _SDL_RWFromMem = _SDL_RWFromConstMem;
        _SDL_RWFromMem.sig = "ppi";
        var _SDL_GetNumAudioDrivers = () => 1;
        _SDL_GetNumAudioDrivers.sig = "i";
        function _SDL_GetCurrentAudioDriver() {
          return stringToNewUTF8("Emscripten Audio");
        }
        _SDL_GetCurrentAudioDriver.sig = "p";
        var _SDL_GetScancodeFromKey = (key) => SDL.scanCodes[key];
        _SDL_GetScancodeFromKey.sig = "ii";
        function _SDL_GetAudioDriver(index) {
          return _SDL_GetCurrentAudioDriver();
        }
        _SDL_GetAudioDriver.sig = "pi";
        var _SDL_EnableUNICODE = (on) => {
          var ret = SDL.unicode || 0;
          SDL.unicode = on;
          return ret;
        };
        _SDL_EnableUNICODE.sig = "ii";
        var _SDL_AddTimer = function(interval, callback, param) {
          callback >>>= 0;
          param >>>= 0;
          return safeSetTimeout(() => getWasmTableEntry(callback)(interval, param), interval);
        };
        _SDL_AddTimer.sig = "iipp";
        var _SDL_RemoveTimer = (id) => {
          clearTimeout(id);
          return true;
        };
        _SDL_RemoveTimer.sig = "ii";
        function _SDL_CreateThread(fs5, data2, pfnBeginThread, pfnEndThread) {
          fs5 >>>= 0;
          data2 >>>= 0;
          throw "SDL threads cannot be supported in the web platform because they assume shared state. See emscripten_create_worker etc. for a message-passing concurrency model that does let you run code in another thread.";
        }
        _SDL_CreateThread.sig = "ppp";
        function _SDL_WaitThread(thread, status) {
          thread >>>= 0;
          status >>>= 0;
          throw "SDL_WaitThread";
        }
        _SDL_WaitThread.sig = "vpp";
        function _SDL_GetThreadID(thread) {
          thread >>>= 0;
          throw "SDL_GetThreadID";
        }
        _SDL_GetThreadID.sig = "pp";
        function _SDL_ThreadID() {
          return 0;
        }
        _SDL_ThreadID.sig = "p";
        function _SDL_AllocRW() {
          throw "SDL_AllocRW: TODO";
        }
        _SDL_AllocRW.sig = "p";
        function _SDL_CondBroadcast(cond) {
          cond >>>= 0;
          throw "SDL_CondBroadcast: TODO";
        }
        _SDL_CondBroadcast.sig = "ip";
        function _SDL_CondWaitTimeout(cond, mutex, ms) {
          cond >>>= 0;
          mutex >>>= 0;
          throw "SDL_CondWaitTimeout: TODO";
        }
        _SDL_CondWaitTimeout.sig = "ippi";
        var _SDL_WM_IconifyWindow = () => {
          throw "SDL_WM_IconifyWindow TODO";
        };
        _SDL_WM_IconifyWindow.sig = "i";
        function _Mix_SetPostMix(func2, arg) {
          func2 >>>= 0;
          arg >>>= 0;
          return warnOnce("Mix_SetPostMix: TODO");
        }
        _Mix_SetPostMix.sig = "vpp";
        function _Mix_VolumeChunk(chunk, volume) {
          chunk >>>= 0;
          throw "Mix_VolumeChunk: TODO";
        }
        _Mix_VolumeChunk.sig = "ipi";
        var _Mix_SetPosition = (channel, angle, distance) => {
          throw "Mix_SetPosition: TODO";
        };
        _Mix_SetPosition.sig = "iiii";
        function _Mix_QuerySpec(frequency, format, channels) {
          frequency >>>= 0;
          format >>>= 0;
          channels >>>= 0;
          throw "Mix_QuerySpec: TODO";
        }
        _Mix_QuerySpec.sig = "ippp";
        function _Mix_FadeInChannelTimed(channel, chunk, loop, ms, ticks) {
          chunk >>>= 0;
          throw "Mix_FadeInChannelTimed";
        }
        _Mix_FadeInChannelTimed.sig = "iipiii";
        var _Mix_FadeOutChannel = () => {
          throw "Mix_FadeOutChannel";
        };
        _Mix_FadeOutChannel.sig = "iii";
        function _Mix_Linked_Version() {
          throw "Mix_Linked_Version: TODO";
        }
        _Mix_Linked_Version.sig = "p";
        function _SDL_SaveBMP_RW(surface, dst, freedst) {
          surface >>>= 0;
          dst >>>= 0;
          throw "SDL_SaveBMP_RW: TODO";
        }
        _SDL_SaveBMP_RW.sig = "ippi";
        function _SDL_WM_SetIcon(icon, mask) {
          icon >>>= 0;
          mask >>>= 0;
        }
        _SDL_WM_SetIcon.sig = "vpp";
        var _SDL_HasRDTSC = () => 0;
        _SDL_HasRDTSC.sig = "i";
        var _SDL_HasMMX = () => 0;
        _SDL_HasMMX.sig = "i";
        var _SDL_HasMMXExt = () => 0;
        _SDL_HasMMXExt.sig = "i";
        var _SDL_Has3DNow = () => 0;
        _SDL_Has3DNow.sig = "i";
        var _SDL_Has3DNowExt = () => 0;
        _SDL_Has3DNowExt.sig = "i";
        var _SDL_HasSSE = () => 0;
        _SDL_HasSSE.sig = "i";
        var _SDL_HasSSE2 = () => 0;
        _SDL_HasSSE2.sig = "i";
        var _SDL_HasAltiVec = () => 0;
        _SDL_HasAltiVec.sig = "i";
        var ALLOC_NORMAL = 0;
        var ALLOC_STACK = 1;
        var allocate = (slab, allocator) => {
          var ret;
          if (allocator == ALLOC_STACK) {
            ret = stackAlloc(slab.length);
          } else {
            ret = _malloc(slab.length);
          }
          if (!slab.subarray && !slab.slice) {
            slab = new Uint8Array(slab);
          }
          HEAPU8.set(slab, ret >>> 0);
          return ret;
        };
        var writeStringToMemory = (string, buffer, dontAddNull) => {
          warnOnce("writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!");
          var lastChar, end;
          if (dontAddNull) {
            end = buffer + lengthBytesUTF8(string);
            lastChar = HEAP8[end >>> 0];
          }
          stringToUTF8(string, buffer, Infinity);
          if (dontAddNull)
            HEAP8[end >>> 0] = lastChar;
        };
        var writeAsciiToMemory = (str, buffer, dontAddNull) => {
          for (var i2 = 0; i2 < str.length; ++i2) {
            HEAP8[buffer++ >>> 0 >>> 0] = str.charCodeAt(i2);
          }
          if (!dontAddNull)
            HEAP8[buffer >>> 0 >>> 0] = 0;
        };
        var allocateUTF8 = stringToNewUTF8;
        var allocateUTF8OnStack = stringToUTF8OnStack;
        var setErrNo = (value) => {
          HEAP32[___errno_location() >>> 2 >>> 0] = value;
          return value;
        };
        var _emscripten_is_main_browser_thread = () => !ENVIRONMENT_IS_WORKER;
        var tupleRegistrations = {};
        var structRegistrations = {};
        var getTypeName = (type) => {
          var ptr2 = ___getTypeName(type);
          var rv = readLatin1String(ptr2);
          _free(ptr2);
          return rv;
        };
        var getFunctionName = (signature) => {
          signature = signature.trim();
          const argsIndex = signature.indexOf("(");
          if (argsIndex !== -1) {
            return signature.substr(0, argsIndex);
          } else {
            return signature;
          }
        };
        var getFunctionArgsName = (signature) => {
          signature = signature.trim();
          const argsIndex = signature.indexOf("(") + 1;
          if (argsIndex !== 0) {
            return signature.substr(argsIndex, signature.length - argsIndex - 1).replaceAll(" ", "").split(",").filter((n) => n.length);
          } else {
            return [];
          }
        };
        var heap32VectorToArray = (count, firstElement) => {
          var array = [];
          for (var i2 = 0; i2 < count; i2++) {
            array.push(HEAPU32[firstElement + i2 * 4 >>> 2 >>> 0]);
          }
          return array;
        };
        var requireRegisteredType = (rawType, humanName) => {
          var impl = registeredTypes[rawType];
          if (void 0 === impl) {
            throwBindingError(humanName + " has unknown type " + getTypeName(rawType));
          }
          return impl;
        };
        function usesDestructorStack(argTypes) {
          for (var i2 = 1; i2 < argTypes.length; ++i2) {
            if (argTypes[i2] !== null && argTypes[i2].destructorFunction === void 0) {
              return true;
            }
          }
          return false;
        }
        function createJsInvoker(humanName, argTypes, isClassMethodFunc, returns, isAsync) {
          var needsDestructorStack = usesDestructorStack(argTypes);
          var argCount = argTypes.length;
          var argsList = "";
          var argsListWired = "";
          for (var i2 = 0; i2 < argCount - 2; ++i2) {
            argsList += (i2 !== 0 ? ", " : "") + "arg" + i2;
            argsListWired += (i2 !== 0 ? ", " : "") + "arg" + i2 + "Wired";
          }
          var invokerFnBody = `
        return function (${argsList}) {
        if (arguments.length !== ${argCount - 2}) {
          throwBindingError('function ${humanName} called with ' + arguments.length + ' arguments, expected ${argCount - 2}');
        }`;
          if (needsDestructorStack) {
            invokerFnBody += "var destructors = [];\n";
          }
          var dtorStack = needsDestructorStack ? "destructors" : "null";
          var args1 = ["throwBindingError", "invoker", "fn", "runDestructors", "retType", "classParam"];
          if (isClassMethodFunc) {
            invokerFnBody += "var thisWired = classParam['toWireType'](" + dtorStack + ", this);\n";
          }
          for (var i2 = 0; i2 < argCount - 2; ++i2) {
            invokerFnBody += "var arg" + i2 + "Wired = argType" + i2 + "['toWireType'](" + dtorStack + ", arg" + i2 + "); // " + argTypes[i2 + 2].name + "\n";
            args1.push("argType" + i2);
          }
          if (isClassMethodFunc) {
            argsListWired = "thisWired" + (argsListWired.length > 0 ? ", " : "") + argsListWired;
          }
          invokerFnBody += (returns || isAsync ? "var rv = " : "") + "invoker(fn" + (argsListWired.length > 0 ? ", " : "") + argsListWired + ");\n";
          if (needsDestructorStack) {
            invokerFnBody += "runDestructors(destructors);\n";
          } else {
            for (var i2 = isClassMethodFunc ? 1 : 2; i2 < argTypes.length; ++i2) {
              var paramName = i2 === 1 ? "thisWired" : "arg" + (i2 - 2) + "Wired";
              if (argTypes[i2].destructorFunction !== null) {
                invokerFnBody += paramName + "_dtor(" + paramName + "); // " + argTypes[i2].name + "\n";
                args1.push(paramName + "_dtor");
              }
            }
          }
          if (returns) {
            invokerFnBody += "var ret = retType['fromWireType'](rv);\nreturn ret;\n";
          } else {
          }
          invokerFnBody += "}\n";
          return [args1, invokerFnBody];
        }
        var createNamedFunction = (name2, body2) => Object.defineProperty(body2, "name", {
          value: name2
        });
        var extendError = (baseErrorType, errorName) => {
          var errorClass = createNamedFunction(errorName, function(message) {
            this.name = errorName;
            this.message = message;
            var stack = new Error(message).stack;
            if (stack !== void 0) {
              this.stack = this.toString() + "\n" + stack.replace(/^Error(:[^\n]*)?\n/, "");
            }
          });
          errorClass.prototype = Object.create(baseErrorType.prototype);
          errorClass.prototype.constructor = errorClass;
          errorClass.prototype.toString = function() {
            if (this.message === void 0) {
              return this.name;
            } else {
              return `${this.name}: ${this.message}`;
            }
          };
          return errorClass;
        };
        var UnboundTypeError;
        var PureVirtualError;
        var registeredInstances = {};
        var getInheritedInstanceCount = () => Object.keys(registeredInstances).length;
        var getLiveInheritedInstances = () => {
          var rv = [];
          for (var k in registeredInstances) {
            if (registeredInstances.hasOwnProperty(k)) {
              rv.push(registeredInstances[k]);
            }
          }
          return rv;
        };
        var deletionQueue = [];
        var flushPendingDeletes = () => {
          while (deletionQueue.length) {
            var obj = deletionQueue.pop();
            obj.$$.deleteScheduled = false;
            obj["delete"]();
          }
        };
        var delayFunction;
        var setDelayFunction = (fn) => {
          delayFunction = fn;
          if (deletionQueue.length && delayFunction) {
            delayFunction(flushPendingDeletes);
          }
        };
        var init_embind = () => {
          Module["getInheritedInstanceCount"] = getInheritedInstanceCount;
          Module["getLiveInheritedInstances"] = getLiveInheritedInstances;
          Module["flushPendingDeletes"] = flushPendingDeletes;
          Module["setDelayFunction"] = setDelayFunction;
        };
        var throwUnboundTypeError = (message, types) => {
          var unboundTypes = [];
          var seen = {};
          function visit(type) {
            if (seen[type]) {
              return;
            }
            if (registeredTypes[type]) {
              return;
            }
            if (typeDependencies[type]) {
              typeDependencies[type].forEach(visit);
              return;
            }
            unboundTypes.push(type);
            seen[type] = true;
          }
          types.forEach(visit);
          throw new UnboundTypeError(`${message}: ` + unboundTypes.map(getTypeName).join([", "]));
        };
        var ensureOverloadTable = (proto, methodName, humanName) => {
          if (void 0 === proto[methodName].overloadTable) {
            var prevFunc = proto[methodName];
            proto[methodName] = function() {
              if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {
                throwBindingError(`Function '${humanName}' called with an invalid number of arguments (${arguments.length}) - expects one of (${proto[methodName].overloadTable})!`);
              }
              return proto[methodName].overloadTable[arguments.length].apply(this, arguments);
            };
            proto[methodName].overloadTable = [];
            proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;
          }
        };
        var exposePublicSymbol = (name2, value, numArguments) => {
          if (Module.hasOwnProperty(name2)) {
            if (void 0 === numArguments || void 0 !== Module[name2].overloadTable && void 0 !== Module[name2].overloadTable[numArguments]) {
              throwBindingError(`Cannot register public name '${name2}' twice`);
            }
            ensureOverloadTable(Module, name2, name2);
            if (Module.hasOwnProperty(numArguments)) {
              throwBindingError(`Cannot register multiple overloads of a function with the same number of arguments (${numArguments})!`);
            }
            Module[name2].overloadTable[numArguments] = value;
          } else {
            Module[name2] = value;
            if (void 0 !== numArguments) {
              Module[name2].numArguments = numArguments;
            }
          }
        };
        var replacePublicSymbol = (name2, value, numArguments) => {
          if (!Module.hasOwnProperty(name2)) {
            throwInternalError("Replacing nonexistant public symbol");
          }
          if (void 0 !== Module[name2].overloadTable && void 0 !== numArguments) {
            Module[name2].overloadTable[numArguments] = value;
          } else {
            Module[name2] = value;
            Module[name2].argCount = numArguments;
          }
        };
        var getBasestPointer = (class_, ptr2) => {
          if (ptr2 === void 0) {
            throwBindingError("ptr should not be undefined");
          }
          while (class_.baseClass) {
            ptr2 = class_.upcast(ptr2);
            class_ = class_.baseClass;
          }
          return ptr2;
        };
        var registerInheritedInstance = (class_, ptr2, instance2) => {
          ptr2 = getBasestPointer(class_, ptr2);
          if (registeredInstances.hasOwnProperty(ptr2)) {
            throwBindingError(`Tried to register registered instance: ${ptr2}`);
          } else {
            registeredInstances[ptr2] = instance2;
          }
        };
        var unregisterInheritedInstance = (class_, ptr2) => {
          ptr2 = getBasestPointer(class_, ptr2);
          if (registeredInstances.hasOwnProperty(ptr2)) {
            delete registeredInstances[ptr2];
          } else {
            throwBindingError(`Tried to unregister unregistered instance: ${ptr2}`);
          }
        };
        var getInheritedInstance = (class_, ptr2) => {
          ptr2 = getBasestPointer(class_, ptr2);
          return registeredInstances[ptr2];
        };
        var registeredPointers = {};
        var enumReadValueFromPointer = (name2, width, signed) => {
          switch (width) {
            case 1:
              return signed ? function(pointer) {
                return this["fromWireType"](HEAP8[pointer >>> 0 >>> 0]);
              } : function(pointer) {
                return this["fromWireType"](HEAPU8[pointer >>> 0 >>> 0]);
              };
            case 2:
              return signed ? function(pointer) {
                return this["fromWireType"](HEAP16[pointer >>> 1 >>> 0]);
              } : function(pointer) {
                return this["fromWireType"](HEAPU16[pointer >>> 1 >>> 0]);
              };
            case 4:
              return signed ? function(pointer) {
                return this["fromWireType"](HEAP32[pointer >>> 2 >>> 0]);
              } : function(pointer) {
                return this["fromWireType"](HEAPU32[pointer >>> 2 >>> 0]);
              };
            default:
              throw new TypeError(`invalid integer width (${width}): ${name2}`);
          }
        };
        function __embind_register_user_type(rawType, name2) {
          rawType >>>= 0;
          name2 >>>= 0;
          __embind_register_emval(rawType);
        }
        __embind_register_user_type.sig = "vpp";
        function __embind_register_optional(rawOptionalType, rawType) {
          rawOptionalType >>>= 0;
          rawType >>>= 0;
          __embind_register_emval(rawOptionalType);
        }
        __embind_register_optional.sig = "vpp";
        var runDestructors = (destructors) => {
          while (destructors.length) {
            var ptr2 = destructors.pop();
            var del = destructors.pop();
            del(ptr2);
          }
        };
        function newFunc(constructor, argumentList) {
          if (!(constructor instanceof Function)) {
            throw new TypeError(`new_ called with constructor type ${typeof constructor} which is not a function`);
          }
          var dummy = createNamedFunction(constructor.name || "unknownFunctionName", function() {
          });
          dummy.prototype = constructor.prototype;
          var obj = new dummy();
          var r = constructor.apply(obj, argumentList);
          return r instanceof Object ? r : obj;
        }
        function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc, isAsync) {
          var argCount = argTypes.length;
          if (argCount < 2) {
            throwBindingError("argTypes array size mismatch! Must at least get return value and 'this' types!");
          }
          var isClassMethodFunc = argTypes[1] !== null && classType !== null;
          var needsDestructorStack = usesDestructorStack(argTypes);
          var returns = argTypes[0].name !== "void";
          var closureArgs = [throwBindingError, cppInvokerFunc, cppTargetFunc, runDestructors, argTypes[0], argTypes[1]];
          for (var i2 = 0; i2 < argCount - 2; ++i2) {
            closureArgs.push(argTypes[i2 + 2]);
          }
          if (!needsDestructorStack) {
            for (var i2 = isClassMethodFunc ? 1 : 2; i2 < argTypes.length; ++i2) {
              if (argTypes[i2].destructorFunction !== null) {
                closureArgs.push(argTypes[i2].destructorFunction);
              }
            }
          }
          let [args2, invokerFnBody] = createJsInvoker(humanName, argTypes, isClassMethodFunc, returns, isAsync);
          args2.push(invokerFnBody);
          var invokerFn = newFunc(Function, args2).apply(null, closureArgs);
          return createNamedFunction(humanName, invokerFn);
        }
        var embind__requireFunction = (signature, rawFunction) => {
          signature = readLatin1String(signature);
          function makeDynCaller() {
            if (signature.includes("j")) {
              return getDynCaller(signature, rawFunction);
            }
            return getWasmTableEntry(rawFunction);
          }
          var fp = makeDynCaller();
          if (typeof fp != "function") {
            throwBindingError(`unknown function pointer with signature ${signature}: ${rawFunction}`);
          }
          return fp;
        };
        function __embind_register_function(name2, argCount, rawArgTypesAddr, signature, rawInvoker, fn, isAsync) {
          name2 >>>= 0;
          rawArgTypesAddr >>>= 0;
          signature >>>= 0;
          rawInvoker >>>= 0;
          fn >>>= 0;
          var argTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
          name2 = readLatin1String(name2);
          name2 = getFunctionName(name2);
          rawInvoker = embind__requireFunction(signature, rawInvoker);
          exposePublicSymbol(name2, function() {
            throwUnboundTypeError(`Cannot call ${name2} due to unbound types`, argTypes);
          }, argCount - 1);
          whenDependentTypesAreResolved([], argTypes, function(argTypes2) {
            var invokerArgsArray = [argTypes2[0], null].concat(argTypes2.slice(1));
            replacePublicSymbol(name2, craftInvokerFunction(name2, invokerArgsArray, null, rawInvoker, fn, isAsync), argCount - 1);
            return [];
          });
        }
        __embind_register_function.sig = "vpippppi";
        function __embind_register_value_array(rawType, name2, constructorSignature, rawConstructor, destructorSignature, rawDestructor) {
          rawType >>>= 0;
          name2 >>>= 0;
          constructorSignature >>>= 0;
          rawConstructor >>>= 0;
          destructorSignature >>>= 0;
          rawDestructor >>>= 0;
          tupleRegistrations[rawType] = {
            name: readLatin1String(name2),
            rawConstructor: embind__requireFunction(constructorSignature, rawConstructor),
            rawDestructor: embind__requireFunction(destructorSignature, rawDestructor),
            elements: []
          };
        }
        __embind_register_value_array.sig = "vpppppp";
        function __embind_register_value_array_element(rawTupleType, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {
          rawTupleType >>>= 0;
          getterReturnType >>>= 0;
          getterSignature >>>= 0;
          getter >>>= 0;
          getterContext >>>= 0;
          setterArgumentType >>>= 0;
          setterSignature >>>= 0;
          setter >>>= 0;
          setterContext >>>= 0;
          tupleRegistrations[rawTupleType].elements.push({
            getterReturnType,
            getter: embind__requireFunction(getterSignature, getter),
            getterContext,
            setterArgumentType,
            setter: embind__requireFunction(setterSignature, setter),
            setterContext
          });
        }
        __embind_register_value_array_element.sig = "vppppppppp";
        var __embind_finalize_value_array = function(rawTupleType) {
          rawTupleType >>>= 0;
          var reg = tupleRegistrations[rawTupleType];
          delete tupleRegistrations[rawTupleType];
          var elements = reg.elements;
          var elementsLength = elements.length;
          var elementTypes = elements.map((elt) => elt.getterReturnType).concat(elements.map((elt) => elt.setterArgumentType));
          var rawConstructor = reg.rawConstructor;
          var rawDestructor = reg.rawDestructor;
          whenDependentTypesAreResolved([rawTupleType], elementTypes, function(elementTypes2) {
            elements.forEach((elt, i2) => {
              var getterReturnType = elementTypes2[i2];
              var getter = elt.getter;
              var getterContext = elt.getterContext;
              var setterArgumentType = elementTypes2[i2 + elementsLength];
              var setter = elt.setter;
              var setterContext = elt.setterContext;
              elt.read = (ptr2) => getterReturnType["fromWireType"](getter(getterContext, ptr2));
              elt.write = (ptr2, o) => {
                var destructors = [];
                setter(setterContext, ptr2, setterArgumentType["toWireType"](destructors, o));
                runDestructors(destructors);
              };
            });
            return [{
              name: reg.name,
              "fromWireType": (ptr2) => {
                var rv = new Array(elementsLength);
                for (var i2 = 0; i2 < elementsLength; ++i2) {
                  rv[i2] = elements[i2].read(ptr2);
                }
                rawDestructor(ptr2);
                return rv;
              },
              "toWireType": (destructors, o) => {
                if (elementsLength !== o.length) {
                  throw new TypeError(`Incorrect number of tuple elements for ${reg.name}: expected=${elementsLength}, actual=${o.length}`);
                }
                var ptr2 = rawConstructor();
                for (var i2 = 0; i2 < elementsLength; ++i2) {
                  elements[i2].write(ptr2, o[i2]);
                }
                if (destructors !== null) {
                  destructors.push(rawDestructor, ptr2);
                }
                return ptr2;
              },
              "argPackAdvance": GenericWireTypeSize,
              "readValueFromPointer": simpleReadValueFromPointer,
              destructorFunction: rawDestructor
            }];
          });
        };
        __embind_finalize_value_array.sig = "vp";
        function __embind_register_value_object(rawType, name2, constructorSignature, rawConstructor, destructorSignature, rawDestructor) {
          rawType >>>= 0;
          name2 >>>= 0;
          constructorSignature >>>= 0;
          rawConstructor >>>= 0;
          destructorSignature >>>= 0;
          rawDestructor >>>= 0;
          structRegistrations[rawType] = {
            name: readLatin1String(name2),
            rawConstructor: embind__requireFunction(constructorSignature, rawConstructor),
            rawDestructor: embind__requireFunction(destructorSignature, rawDestructor),
            fields: []
          };
        }
        __embind_register_value_object.sig = "vpppppp";
        function __embind_register_value_object_field(structType, fieldName, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {
          structType >>>= 0;
          fieldName >>>= 0;
          getterReturnType >>>= 0;
          getterSignature >>>= 0;
          getter >>>= 0;
          getterContext >>>= 0;
          setterArgumentType >>>= 0;
          setterSignature >>>= 0;
          setter >>>= 0;
          setterContext >>>= 0;
          structRegistrations[structType].fields.push({
            fieldName: readLatin1String(fieldName),
            getterReturnType,
            getter: embind__requireFunction(getterSignature, getter),
            getterContext,
            setterArgumentType,
            setter: embind__requireFunction(setterSignature, setter),
            setterContext
          });
        }
        __embind_register_value_object_field.sig = "vpppppppppp";
        var __embind_finalize_value_object = function(structType) {
          structType >>>= 0;
          var reg = structRegistrations[structType];
          delete structRegistrations[structType];
          var rawConstructor = reg.rawConstructor;
          var rawDestructor = reg.rawDestructor;
          var fieldRecords = reg.fields;
          var fieldTypes = fieldRecords.map((field) => field.getterReturnType).concat(fieldRecords.map((field) => field.setterArgumentType));
          whenDependentTypesAreResolved([structType], fieldTypes, (fieldTypes2) => {
            var fields = {};
            fieldRecords.forEach((field, i2) => {
              var fieldName = field.fieldName;
              var getterReturnType = fieldTypes2[i2];
              var getter = field.getter;
              var getterContext = field.getterContext;
              var setterArgumentType = fieldTypes2[i2 + fieldRecords.length];
              var setter = field.setter;
              var setterContext = field.setterContext;
              fields[fieldName] = {
                read: (ptr2) => getterReturnType["fromWireType"](getter(getterContext, ptr2)),
                write: (ptr2, o) => {
                  var destructors = [];
                  setter(setterContext, ptr2, setterArgumentType["toWireType"](destructors, o));
                  runDestructors(destructors);
                }
              };
            });
            return [{
              name: reg.name,
              "fromWireType": (ptr2) => {
                var rv = {};
                for (var i2 in fields) {
                  rv[i2] = fields[i2].read(ptr2);
                }
                rawDestructor(ptr2);
                return rv;
              },
              "toWireType": (destructors, o) => {
                for (var fieldName in fields) {
                  if (!(fieldName in o)) {
                    throw new TypeError(`Missing field: "${fieldName}"`);
                  }
                }
                var ptr2 = rawConstructor();
                for (fieldName in fields) {
                  fields[fieldName].write(ptr2, o[fieldName]);
                }
                if (destructors !== null) {
                  destructors.push(rawDestructor, ptr2);
                }
                return ptr2;
              },
              "argPackAdvance": GenericWireTypeSize,
              "readValueFromPointer": simpleReadValueFromPointer,
              destructorFunction: rawDestructor
            }];
          });
        };
        __embind_finalize_value_object.sig = "vp";
        var upcastPointer = (ptr2, ptrClass, desiredClass) => {
          while (ptrClass !== desiredClass) {
            if (!ptrClass.upcast) {
              throwBindingError(`Expected null or instance of ${desiredClass.name}, got an instance of ${ptrClass.name}`);
            }
            ptr2 = ptrClass.upcast(ptr2);
            ptrClass = ptrClass.baseClass;
          }
          return ptr2;
        };
        function genericPointerToWireType(destructors, handle2) {
          var ptr2;
          if (handle2 === null) {
            if (this.isReference) {
              throwBindingError(`null is not a valid ${this.name}`);
            }
            if (this.isSmartPointer) {
              ptr2 = this.rawConstructor();
              if (destructors !== null) {
                destructors.push(this.rawDestructor, ptr2);
              }
              return ptr2;
            } else {
              return 0;
            }
          }
          if (!handle2 || !handle2.$$) {
            throwBindingError(`Cannot pass "${embindRepr(handle2)}" as a ${this.name}`);
          }
          if (!handle2.$$.ptr) {
            throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);
          }
          if (!this.isConst && handle2.$$.ptrType.isConst) {
            throwBindingError(`Cannot convert argument of type ${handle2.$$.smartPtrType ? handle2.$$.smartPtrType.name : handle2.$$.ptrType.name} to parameter type ${this.name}`);
          }
          var handleClass = handle2.$$.ptrType.registeredClass;
          ptr2 = upcastPointer(handle2.$$.ptr, handleClass, this.registeredClass);
          if (this.isSmartPointer) {
            if (void 0 === handle2.$$.smartPtr) {
              throwBindingError("Passing raw pointer to smart pointer is illegal");
            }
            switch (this.sharingPolicy) {
              case 0:
                if (handle2.$$.smartPtrType === this) {
                  ptr2 = handle2.$$.smartPtr;
                } else {
                  throwBindingError(`Cannot convert argument of type ${handle2.$$.smartPtrType ? handle2.$$.smartPtrType.name : handle2.$$.ptrType.name} to parameter type ${this.name}`);
                }
                break;
              case 1:
                ptr2 = handle2.$$.smartPtr;
                break;
              case 2:
                if (handle2.$$.smartPtrType === this) {
                  ptr2 = handle2.$$.smartPtr;
                } else {
                  var clonedHandle = handle2["clone"]();
                  ptr2 = this.rawShare(ptr2, Emval.toHandle(() => clonedHandle["delete"]()));
                  if (destructors !== null) {
                    destructors.push(this.rawDestructor, ptr2);
                  }
                }
                break;
              default:
                throwBindingError("Unsupporting sharing policy");
            }
          }
          return ptr2;
        }
        function constNoSmartPtrRawPointerToWireType(destructors, handle2) {
          if (handle2 === null) {
            if (this.isReference) {
              throwBindingError(`null is not a valid ${this.name}`);
            }
            return 0;
          }
          if (!handle2.$$) {
            throwBindingError(`Cannot pass "${embindRepr(handle2)}" as a ${this.name}`);
          }
          if (!handle2.$$.ptr) {
            throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);
          }
          var handleClass = handle2.$$.ptrType.registeredClass;
          var ptr2 = upcastPointer(handle2.$$.ptr, handleClass, this.registeredClass);
          return ptr2;
        }
        function nonConstNoSmartPtrRawPointerToWireType(destructors, handle2) {
          if (handle2 === null) {
            if (this.isReference) {
              throwBindingError(`null is not a valid ${this.name}`);
            }
            return 0;
          }
          if (!handle2.$$) {
            throwBindingError(`Cannot pass "${embindRepr(handle2)}" as a ${this.name}`);
          }
          if (!handle2.$$.ptr) {
            throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);
          }
          if (handle2.$$.ptrType.isConst) {
            throwBindingError(`Cannot convert argument of type ${handle2.$$.ptrType.name} to parameter type ${this.name}`);
          }
          var handleClass = handle2.$$.ptrType.registeredClass;
          var ptr2 = upcastPointer(handle2.$$.ptr, handleClass, this.registeredClass);
          return ptr2;
        }
        function RegisteredPointer(name2, registeredClass, isReference, isConst, isSmartPointer, pointeeType, sharingPolicy, rawGetPointee, rawConstructor, rawShare, rawDestructor) {
          this.name = name2;
          this.registeredClass = registeredClass;
          this.isReference = isReference;
          this.isConst = isConst;
          this.isSmartPointer = isSmartPointer;
          this.pointeeType = pointeeType;
          this.sharingPolicy = sharingPolicy;
          this.rawGetPointee = rawGetPointee;
          this.rawConstructor = rawConstructor;
          this.rawShare = rawShare;
          this.rawDestructor = rawDestructor;
          if (!isSmartPointer && registeredClass.baseClass === void 0) {
            if (isConst) {
              this["toWireType"] = constNoSmartPtrRawPointerToWireType;
              this.destructorFunction = null;
            } else {
              this["toWireType"] = nonConstNoSmartPtrRawPointerToWireType;
              this.destructorFunction = null;
            }
          } else {
            this["toWireType"] = genericPointerToWireType;
          }
        }
        var downcastPointer = (ptr2, ptrClass, desiredClass) => {
          if (ptrClass === desiredClass) {
            return ptr2;
          }
          if (void 0 === desiredClass.baseClass) {
            return null;
          }
          var rv = downcastPointer(ptr2, ptrClass, desiredClass.baseClass);
          if (rv === null) {
            return null;
          }
          return desiredClass.downcast(rv);
        };
        var finalizationRegistry = false;
        var detachFinalizer = (handle2) => {
        };
        var runDestructor = ($$) => {
          if ($$.smartPtr) {
            $$.smartPtrType.rawDestructor($$.smartPtr);
          } else {
            $$.ptrType.registeredClass.rawDestructor($$.ptr);
          }
        };
        var releaseClassHandle = ($$) => {
          $$.count.value -= 1;
          var toDelete = 0 === $$.count.value;
          if (toDelete) {
            runDestructor($$);
          }
        };
        var attachFinalizer = (handle2) => {
          if ("undefined" === typeof FinalizationRegistry) {
            attachFinalizer = (handle3) => handle3;
            return handle2;
          }
          finalizationRegistry = new FinalizationRegistry((info2) => {
            releaseClassHandle(info2.$$);
          });
          attachFinalizer = (handle3) => {
            var $$ = handle3.$$;
            var hasSmartPtr = !!$$.smartPtr;
            if (hasSmartPtr) {
              var info2 = {
                $$
              };
              finalizationRegistry.register(handle3, info2, handle3);
            }
            return handle3;
          };
          detachFinalizer = (handle3) => finalizationRegistry.unregister(handle3);
          return attachFinalizer(handle2);
        };
        var makeClassHandle = (prototype, record) => {
          if (!record.ptrType || !record.ptr) {
            throwInternalError("makeClassHandle requires ptr and ptrType");
          }
          var hasSmartPtrType = !!record.smartPtrType;
          var hasSmartPtr = !!record.smartPtr;
          if (hasSmartPtrType !== hasSmartPtr) {
            throwInternalError("Both smartPtrType and smartPtr must be specified");
          }
          record.count = {
            value: 1
          };
          return attachFinalizer(Object.create(prototype, {
            $$: {
              value: record,
              writable: true
            }
          }));
        };
        function RegisteredPointer_fromWireType(ptr2) {
          var rawPointer = this.getPointee(ptr2);
          if (!rawPointer) {
            this.destructor(ptr2);
            return null;
          }
          var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);
          if (void 0 !== registeredInstance) {
            if (0 === registeredInstance.$$.count.value) {
              registeredInstance.$$.ptr = rawPointer;
              registeredInstance.$$.smartPtr = ptr2;
              return registeredInstance["clone"]();
            } else {
              var rv = registeredInstance["clone"]();
              this.destructor(ptr2);
              return rv;
            }
          }
          function makeDefaultHandle() {
            if (this.isSmartPointer) {
              return makeClassHandle(this.registeredClass.instancePrototype, {
                ptrType: this.pointeeType,
                ptr: rawPointer,
                smartPtrType: this,
                smartPtr: ptr2
              });
            } else {
              return makeClassHandle(this.registeredClass.instancePrototype, {
                ptrType: this,
                ptr: ptr2
              });
            }
          }
          var actualType = this.registeredClass.getActualType(rawPointer);
          var registeredPointerRecord = registeredPointers[actualType];
          if (!registeredPointerRecord) {
            return makeDefaultHandle.call(this);
          }
          var toType;
          if (this.isConst) {
            toType = registeredPointerRecord.constPointerType;
          } else {
            toType = registeredPointerRecord.pointerType;
          }
          var dp = downcastPointer(rawPointer, this.registeredClass, toType.registeredClass);
          if (dp === null) {
            return makeDefaultHandle.call(this);
          }
          if (this.isSmartPointer) {
            return makeClassHandle(toType.registeredClass.instancePrototype, {
              ptrType: toType,
              ptr: dp,
              smartPtrType: this,
              smartPtr: ptr2
            });
          } else {
            return makeClassHandle(toType.registeredClass.instancePrototype, {
              ptrType: toType,
              ptr: dp
            });
          }
        }
        var init_RegisteredPointer = () => {
          Object.assign(RegisteredPointer.prototype, {
            getPointee(ptr2) {
              if (this.rawGetPointee) {
                ptr2 = this.rawGetPointee(ptr2);
              }
              return ptr2;
            },
            destructor(ptr2) {
              var _a;
              (_a = this.rawDestructor) == null ? void 0 : _a.call(this, ptr2);
            },
            "argPackAdvance": GenericWireTypeSize,
            "readValueFromPointer": readPointer,
            "fromWireType": RegisteredPointer_fromWireType
          });
        };
        var detachFinalizer_deps = ["$finalizationRegistry"];
        function ClassHandle() {
        }
        var shallowCopyInternalPointer = (o) => ({
          count: o.count,
          deleteScheduled: o.deleteScheduled,
          preservePointerOnDelete: o.preservePointerOnDelete,
          ptr: o.ptr,
          ptrType: o.ptrType,
          smartPtr: o.smartPtr,
          smartPtrType: o.smartPtrType
        });
        var throwInstanceAlreadyDeleted = (obj) => {
          function getInstanceTypeName(handle2) {
            return handle2.$$.ptrType.registeredClass.name;
          }
          throwBindingError(getInstanceTypeName(obj) + " instance already deleted");
        };
        var init_ClassHandle = () => {
          Object.assign(ClassHandle.prototype, {
            "isAliasOf"(other) {
              if (!(this instanceof ClassHandle)) {
                return false;
              }
              if (!(other instanceof ClassHandle)) {
                return false;
              }
              var leftClass = this.$$.ptrType.registeredClass;
              var left = this.$$.ptr;
              other.$$ = other.$$;
              var rightClass = other.$$.ptrType.registeredClass;
              var right = other.$$.ptr;
              while (leftClass.baseClass) {
                left = leftClass.upcast(left);
                leftClass = leftClass.baseClass;
              }
              while (rightClass.baseClass) {
                right = rightClass.upcast(right);
                rightClass = rightClass.baseClass;
              }
              return leftClass === rightClass && left === right;
            },
            "clone"() {
              if (!this.$$.ptr) {
                throwInstanceAlreadyDeleted(this);
              }
              if (this.$$.preservePointerOnDelete) {
                this.$$.count.value += 1;
                return this;
              } else {
                var clone = attachFinalizer(Object.create(Object.getPrototypeOf(this), {
                  $$: {
                    value: shallowCopyInternalPointer(this.$$)
                  }
                }));
                clone.$$.count.value += 1;
                clone.$$.deleteScheduled = false;
                return clone;
              }
            },
            "delete"() {
              if (!this.$$.ptr) {
                throwInstanceAlreadyDeleted(this);
              }
              if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
                throwBindingError("Object already scheduled for deletion");
              }
              detachFinalizer(this);
              releaseClassHandle(this.$$);
              if (!this.$$.preservePointerOnDelete) {
                this.$$.smartPtr = void 0;
                this.$$.ptr = void 0;
              }
            },
            "isDeleted"() {
              return !this.$$.ptr;
            },
            "deleteLater"() {
              if (!this.$$.ptr) {
                throwInstanceAlreadyDeleted(this);
              }
              if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
                throwBindingError("Object already scheduled for deletion");
              }
              deletionQueue.push(this);
              if (deletionQueue.length === 1 && delayFunction) {
                delayFunction(flushPendingDeletes);
              }
              this.$$.deleteScheduled = true;
              return this;
            }
          });
        };
        function RegisteredClass(name2, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast) {
          this.name = name2;
          this.constructor = constructor;
          this.instancePrototype = instancePrototype;
          this.rawDestructor = rawDestructor;
          this.baseClass = baseClass;
          this.getActualType = getActualType;
          this.upcast = upcast;
          this.downcast = downcast;
          this.pureVirtualFunctions = [];
        }
        var char_0 = 48;
        var char_9 = 57;
        var makeLegalFunctionName = (name2) => {
          if (void 0 === name2) {
            return "_unknown";
          }
          name2 = name2.replace(/[^a-zA-Z0-9_]/g, "$");
          var f = name2.charCodeAt(0);
          if (f >= char_0 && f <= char_9) {
            return `_${name2}`;
          }
          return name2;
        };
        function __embind_register_class(rawType, rawPointerType, rawConstPointerType, baseClassRawType, getActualTypeSignature, getActualType, upcastSignature, upcast, downcastSignature, downcast, name2, destructorSignature, rawDestructor) {
          rawType >>>= 0;
          rawPointerType >>>= 0;
          rawConstPointerType >>>= 0;
          baseClassRawType >>>= 0;
          getActualTypeSignature >>>= 0;
          getActualType >>>= 0;
          upcastSignature >>>= 0;
          upcast >>>= 0;
          downcastSignature >>>= 0;
          downcast >>>= 0;
          name2 >>>= 0;
          destructorSignature >>>= 0;
          rawDestructor >>>= 0;
          name2 = readLatin1String(name2);
          getActualType = embind__requireFunction(getActualTypeSignature, getActualType);
          upcast && (upcast = embind__requireFunction(upcastSignature, upcast));
          downcast && (downcast = embind__requireFunction(downcastSignature, downcast));
          rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);
          var legalFunctionName = makeLegalFunctionName(name2);
          exposePublicSymbol(legalFunctionName, function() {
            throwUnboundTypeError(`Cannot construct ${name2} due to unbound types`, [baseClassRawType]);
          });
          whenDependentTypesAreResolved([rawType, rawPointerType, rawConstPointerType], baseClassRawType ? [baseClassRawType] : [], function(base) {
            var _a;
            base = base[0];
            var baseClass;
            var basePrototype;
            if (baseClassRawType) {
              baseClass = base.registeredClass;
              basePrototype = baseClass.instancePrototype;
            } else {
              basePrototype = ClassHandle.prototype;
            }
            var constructor = createNamedFunction(name2, function() {
              if (Object.getPrototypeOf(this) !== instancePrototype) {
                throw new BindingError("Use 'new' to construct " + name2);
              }
              if (void 0 === registeredClass.constructor_body) {
                throw new BindingError(name2 + " has no accessible constructor");
              }
              var body2 = registeredClass.constructor_body[arguments.length];
              if (void 0 === body2) {
                throw new BindingError(`Tried to invoke ctor of ${name2} with invalid number of parameters (${arguments.length}) - expected (${Object.keys(registeredClass.constructor_body).toString()}) parameters instead!`);
              }
              return body2.apply(this, arguments);
            });
            var instancePrototype = Object.create(basePrototype, {
              constructor: {
                value: constructor
              }
            });
            constructor.prototype = instancePrototype;
            var registeredClass = new RegisteredClass(name2, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast);
            if (registeredClass.baseClass) {
              (_a = registeredClass.baseClass).__derivedClasses ?? (_a.__derivedClasses = []);
              registeredClass.baseClass.__derivedClasses.push(registeredClass);
            }
            var referenceConverter = new RegisteredPointer(name2, registeredClass, true, false, false);
            var pointerConverter = new RegisteredPointer(name2 + "*", registeredClass, false, false, false);
            var constPointerConverter = new RegisteredPointer(name2 + " const*", registeredClass, false, true, false);
            registeredPointers[rawType] = {
              pointerType: pointerConverter,
              constPointerType: constPointerConverter
            };
            replacePublicSymbol(legalFunctionName, constructor);
            return [referenceConverter, pointerConverter, constPointerConverter];
          });
        }
        __embind_register_class.sig = "vppppppppppppp";
        function __embind_register_class_constructor(rawClassType, argCount, rawArgTypesAddr, invokerSignature, invoker, rawConstructor) {
          rawClassType >>>= 0;
          rawArgTypesAddr >>>= 0;
          invokerSignature >>>= 0;
          invoker >>>= 0;
          rawConstructor >>>= 0;
          var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
          invoker = embind__requireFunction(invokerSignature, invoker);
          var args2 = [rawConstructor];
          var destructors = [];
          whenDependentTypesAreResolved([], [rawClassType], function(classType) {
            classType = classType[0];
            var humanName = `constructor ${classType.name}`;
            if (void 0 === classType.registeredClass.constructor_body) {
              classType.registeredClass.constructor_body = [];
            }
            if (void 0 !== classType.registeredClass.constructor_body[argCount - 1]) {
              throw new BindingError(`Cannot register multiple constructors with identical number of parameters (${argCount - 1}) for class '${classType.name}'! Overload resolution is currently only performed using the parameter count, not actual type info!`);
            }
            classType.registeredClass.constructor_body[argCount - 1] = () => {
              throwUnboundTypeError(`Cannot construct ${classType.name} due to unbound types`, rawArgTypes);
            };
            whenDependentTypesAreResolved([], rawArgTypes, (argTypes) => {
              argTypes.splice(1, 0, null);
              classType.registeredClass.constructor_body[argCount - 1] = craftInvokerFunction(humanName, argTypes, null, invoker, rawConstructor);
              return [];
            });
            return [];
          });
        }
        __embind_register_class_constructor.sig = "vpipppp";
        var validateThis = (this_, classType, humanName) => {
          if (!(this_ instanceof Object)) {
            throwBindingError(`${humanName} with invalid "this": ${this_}`);
          }
          if (!(this_ instanceof classType.registeredClass.constructor)) {
            throwBindingError(`${humanName} incompatible with "this" of type ${this_.constructor.name}`);
          }
          if (!this_.$$.ptr) {
            throwBindingError(`cannot call emscripten binding method ${humanName} on deleted object`);
          }
          return upcastPointer(this_.$$.ptr, this_.$$.ptrType.registeredClass, classType.registeredClass);
        };
        function __embind_register_class_function(rawClassType, methodName, argCount, rawArgTypesAddr, invokerSignature, rawInvoker, context, isPureVirtual, isAsync) {
          rawClassType >>>= 0;
          methodName >>>= 0;
          rawArgTypesAddr >>>= 0;
          invokerSignature >>>= 0;
          rawInvoker >>>= 0;
          context >>>= 0;
          var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
          methodName = readLatin1String(methodName);
          methodName = getFunctionName(methodName);
          rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);
          whenDependentTypesAreResolved([], [rawClassType], function(classType) {
            classType = classType[0];
            var humanName = `${classType.name}.${methodName}`;
            if (methodName.startsWith("@@")) {
              methodName = Symbol[methodName.substring(2)];
            }
            if (isPureVirtual) {
              classType.registeredClass.pureVirtualFunctions.push(methodName);
            }
            function unboundTypesHandler() {
              throwUnboundTypeError(`Cannot call ${humanName} due to unbound types`, rawArgTypes);
            }
            var proto = classType.registeredClass.instancePrototype;
            var method = proto[methodName];
            if (void 0 === method || void 0 === method.overloadTable && method.className !== classType.name && method.argCount === argCount - 2) {
              unboundTypesHandler.argCount = argCount - 2;
              unboundTypesHandler.className = classType.name;
              proto[methodName] = unboundTypesHandler;
            } else {
              ensureOverloadTable(proto, methodName, humanName);
              proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;
            }
            whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
              var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context, isAsync);
              if (void 0 === proto[methodName].overloadTable) {
                memberFunction.argCount = argCount - 2;
                proto[methodName] = memberFunction;
              } else {
                proto[methodName].overloadTable[argCount - 2] = memberFunction;
              }
              return [];
            });
            return [];
          });
        }
        __embind_register_class_function.sig = "vppippppii";
        function __embind_register_class_property(classType, fieldName, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {
          classType >>>= 0;
          fieldName >>>= 0;
          getterReturnType >>>= 0;
          getterSignature >>>= 0;
          getter >>>= 0;
          getterContext >>>= 0;
          setterArgumentType >>>= 0;
          setterSignature >>>= 0;
          setter >>>= 0;
          setterContext >>>= 0;
          fieldName = readLatin1String(fieldName);
          getter = embind__requireFunction(getterSignature, getter);
          whenDependentTypesAreResolved([], [classType], function(classType2) {
            classType2 = classType2[0];
            var humanName = `${classType2.name}.${fieldName}`;
            var desc = {
              get() {
                throwUnboundTypeError(`Cannot access ${humanName} due to unbound types`, [getterReturnType, setterArgumentType]);
              },
              enumerable: true,
              configurable: true
            };
            if (setter) {
              desc.set = () => throwUnboundTypeError(`Cannot access ${humanName} due to unbound types`, [getterReturnType, setterArgumentType]);
            } else {
              desc.set = (v) => throwBindingError(humanName + " is a read-only property");
            }
            Object.defineProperty(classType2.registeredClass.instancePrototype, fieldName, desc);
            whenDependentTypesAreResolved([], setter ? [getterReturnType, setterArgumentType] : [getterReturnType], function(types) {
              var getterReturnType2 = types[0];
              var desc2 = {
                get() {
                  var ptr2 = validateThis(this, classType2, humanName + " getter");
                  return getterReturnType2["fromWireType"](getter(getterContext, ptr2));
                },
                enumerable: true
              };
              if (setter) {
                setter = embind__requireFunction(setterSignature, setter);
                var setterArgumentType2 = types[1];
                desc2.set = function(v) {
                  var ptr2 = validateThis(this, classType2, humanName + " setter");
                  var destructors = [];
                  setter(setterContext, ptr2, setterArgumentType2["toWireType"](destructors, v));
                  runDestructors(destructors);
                };
              }
              Object.defineProperty(classType2.registeredClass.instancePrototype, fieldName, desc2);
              return [];
            });
            return [];
          });
        }
        __embind_register_class_property.sig = "vpppppppppp";
        function __embind_register_class_class_function(rawClassType, methodName, argCount, rawArgTypesAddr, invokerSignature, rawInvoker, fn, isAsync) {
          rawClassType >>>= 0;
          methodName >>>= 0;
          rawArgTypesAddr >>>= 0;
          invokerSignature >>>= 0;
          rawInvoker >>>= 0;
          fn >>>= 0;
          var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
          methodName = readLatin1String(methodName);
          methodName = getFunctionName(methodName);
          rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);
          whenDependentTypesAreResolved([], [rawClassType], function(classType) {
            classType = classType[0];
            var humanName = `${classType.name}.${methodName}`;
            function unboundTypesHandler() {
              throwUnboundTypeError(`Cannot call ${humanName} due to unbound types`, rawArgTypes);
            }
            if (methodName.startsWith("@@")) {
              methodName = Symbol[methodName.substring(2)];
            }
            var proto = classType.registeredClass.constructor;
            if (void 0 === proto[methodName]) {
              unboundTypesHandler.argCount = argCount - 1;
              proto[methodName] = unboundTypesHandler;
            } else {
              ensureOverloadTable(proto, methodName, humanName);
              proto[methodName].overloadTable[argCount - 1] = unboundTypesHandler;
            }
            whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
              var invokerArgsArray = [argTypes[0], null].concat(argTypes.slice(1));
              var func2 = craftInvokerFunction(humanName, invokerArgsArray, null, rawInvoker, fn, isAsync);
              if (void 0 === proto[methodName].overloadTable) {
                func2.argCount = argCount - 1;
                proto[methodName] = func2;
              } else {
                proto[methodName].overloadTable[argCount - 1] = func2;
              }
              if (classType.registeredClass.__derivedClasses) {
                for (const derivedClass of classType.registeredClass.__derivedClasses) {
                  if (!derivedClass.constructor.hasOwnProperty(methodName)) {
                    derivedClass.constructor[methodName] = func2;
                  }
                }
              }
              return [];
            });
            return [];
          });
        }
        __embind_register_class_class_function.sig = "vppippppi";
        function __embind_register_class_class_property(rawClassType, fieldName, rawFieldType, rawFieldPtr, getterSignature, getter, setterSignature, setter) {
          rawClassType >>>= 0;
          fieldName >>>= 0;
          rawFieldType >>>= 0;
          rawFieldPtr >>>= 0;
          getterSignature >>>= 0;
          getter >>>= 0;
          setterSignature >>>= 0;
          setter >>>= 0;
          fieldName = readLatin1String(fieldName);
          getter = embind__requireFunction(getterSignature, getter);
          whenDependentTypesAreResolved([], [rawClassType], function(classType) {
            classType = classType[0];
            var humanName = `${classType.name}.${fieldName}`;
            var desc = {
              get() {
                throwUnboundTypeError(`Cannot access ${humanName} due to unbound types`, [rawFieldType]);
              },
              enumerable: true,
              configurable: true
            };
            if (setter) {
              desc.set = () => {
                throwUnboundTypeError(`Cannot access ${humanName} due to unbound types`, [rawFieldType]);
              };
            } else {
              desc.set = (v) => {
                throwBindingError(`${humanName} is a read-only property`);
              };
            }
            Object.defineProperty(classType.registeredClass.constructor, fieldName, desc);
            whenDependentTypesAreResolved([], [rawFieldType], function(fieldType) {
              fieldType = fieldType[0];
              var desc2 = {
                get() {
                  return fieldType["fromWireType"](getter(rawFieldPtr));
                },
                enumerable: true
              };
              if (setter) {
                setter = embind__requireFunction(setterSignature, setter);
                desc2.set = (v) => {
                  var destructors = [];
                  setter(rawFieldPtr, fieldType["toWireType"](destructors, v));
                  runDestructors(destructors);
                };
              }
              Object.defineProperty(classType.registeredClass.constructor, fieldName, desc2);
              return [];
            });
            return [];
          });
        }
        __embind_register_class_class_property.sig = "vpppppppp";
        function __embind_create_inheriting_constructor(constructorName, wrapperType, properties) {
          constructorName >>>= 0;
          wrapperType >>>= 0;
          properties >>>= 0;
          constructorName = readLatin1String(constructorName);
          wrapperType = requireRegisteredType(wrapperType, "wrapper");
          properties = Emval.toValue(properties);
          var arraySlice = [].slice;
          var registeredClass = wrapperType.registeredClass;
          var wrapperPrototype = registeredClass.instancePrototype;
          var baseClass = registeredClass.baseClass;
          var baseClassPrototype = baseClass.instancePrototype;
          var baseConstructor = registeredClass.baseClass.constructor;
          var ctor = createNamedFunction(constructorName, function() {
            registeredClass.baseClass.pureVirtualFunctions.forEach(function(name2) {
              if (this[name2] === baseClassPrototype[name2]) {
                throw new PureVirtualError(`Pure virtual function ${name2} must be implemented in JavaScript`);
              }
            }.bind(this));
            Object.defineProperty(this, "__parent", {
              value: wrapperPrototype
            });
            this["__construct"].apply(this, arraySlice.call(arguments));
          });
          wrapperPrototype["__construct"] = function __construct() {
            if (this === wrapperPrototype) {
              throwBindingError("Pass correct 'this' to __construct");
            }
            var inner = baseConstructor["implement"].apply(void 0, [this].concat(arraySlice.call(arguments)));
            detachFinalizer(inner);
            var $$ = inner.$$;
            inner["notifyOnDestruction"]();
            $$.preservePointerOnDelete = true;
            Object.defineProperties(this, {
              $$: {
                value: $$
              }
            });
            attachFinalizer(this);
            registerInheritedInstance(registeredClass, $$.ptr, this);
          };
          wrapperPrototype["__destruct"] = function __destruct() {
            if (this === wrapperPrototype) {
              throwBindingError("Pass correct 'this' to __destruct");
            }
            detachFinalizer(this);
            unregisterInheritedInstance(registeredClass, this.$$.ptr);
          };
          ctor.prototype = Object.create(wrapperPrototype);
          Object.assign(ctor.prototype, properties);
          return Emval.toHandle(ctor);
        }
        __embind_create_inheriting_constructor.sig = "pppp";
        function __embind_register_smart_ptr(rawType, rawPointeeType, name2, sharingPolicy, getPointeeSignature, rawGetPointee, constructorSignature, rawConstructor, shareSignature, rawShare, destructorSignature, rawDestructor) {
          rawType >>>= 0;
          rawPointeeType >>>= 0;
          name2 >>>= 0;
          getPointeeSignature >>>= 0;
          rawGetPointee >>>= 0;
          constructorSignature >>>= 0;
          rawConstructor >>>= 0;
          shareSignature >>>= 0;
          rawShare >>>= 0;
          destructorSignature >>>= 0;
          rawDestructor >>>= 0;
          name2 = readLatin1String(name2);
          rawGetPointee = embind__requireFunction(getPointeeSignature, rawGetPointee);
          rawConstructor = embind__requireFunction(constructorSignature, rawConstructor);
          rawShare = embind__requireFunction(shareSignature, rawShare);
          rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);
          whenDependentTypesAreResolved([rawType], [rawPointeeType], function(pointeeType) {
            pointeeType = pointeeType[0];
            var registeredPointer = new RegisteredPointer(name2, pointeeType.registeredClass, false, false, true, pointeeType, sharingPolicy, rawGetPointee, rawConstructor, rawShare, rawDestructor);
            return [registeredPointer];
          });
        }
        __embind_register_smart_ptr.sig = "vpppipppppppp";
        function __embind_register_enum(rawType, name2, size, isSigned) {
          rawType >>>= 0;
          name2 >>>= 0;
          size >>>= 0;
          name2 = readLatin1String(name2);
          function ctor() {
          }
          ctor.values = {};
          registerType(rawType, {
            name: name2,
            constructor: ctor,
            "fromWireType": function(c) {
              return this.constructor.values[c];
            },
            "toWireType": (destructors, c) => c.value,
            "argPackAdvance": GenericWireTypeSize,
            "readValueFromPointer": enumReadValueFromPointer(name2, size, isSigned),
            destructorFunction: null
          });
          exposePublicSymbol(name2, ctor);
        }
        __embind_register_enum.sig = "vpppi";
        function __embind_register_enum_value(rawEnumType, name2, enumValue) {
          rawEnumType >>>= 0;
          name2 >>>= 0;
          var enumType = requireRegisteredType(rawEnumType, "enum");
          name2 = readLatin1String(name2);
          var Enum = enumType.constructor;
          var Value = Object.create(enumType.constructor.prototype, {
            value: {
              value: enumValue
            },
            constructor: {
              value: createNamedFunction(`${enumType.name}_${name2}`, function() {
              })
            }
          });
          Enum.values[enumValue] = Value;
          Enum[name2] = Value;
        }
        __embind_register_enum_value.sig = "vppi";
        function __embind_register_constant(name2, type, value) {
          name2 >>>= 0;
          type >>>= 0;
          name2 = readLatin1String(name2);
          whenDependentTypesAreResolved([], [type], function(type2) {
            type2 = type2[0];
            Module[name2] = type2["fromWireType"](value);
            return [];
          });
        }
        __embind_register_constant.sig = "vppd";
        var emval_symbols = {};
        function __emval_register_symbol(address) {
          address >>>= 0;
          emval_symbols[address] = readLatin1String(address);
        }
        __emval_register_symbol.sig = "vp";
        var getStringOrSymbol = (address) => {
          var symbol = emval_symbols[address];
          if (symbol === void 0) {
            return readLatin1String(address);
          }
          return symbol;
        };
        function __emval_incref(handle2) {
          handle2 >>>= 0;
          if (handle2 > 4) {
            emval_handles.get(handle2).refcount += 1;
          }
        }
        __emval_incref.sig = "vp";
        function __emval_run_destructors(handle2) {
          handle2 >>>= 0;
          var destructors = Emval.toValue(handle2);
          runDestructors(destructors);
          __emval_decref(handle2);
        }
        __emval_run_destructors.sig = "vp";
        function __emval_new_array() {
          return Emval.toHandle([]);
        }
        __emval_new_array.sig = "p";
        function __emval_new_array_from_memory_view(view) {
          view >>>= 0;
          view = Emval.toValue(view);
          var a = new Array(view.length);
          for (var i2 = 0; i2 < view.length; i2++)
            a[i2] = view[i2];
          return Emval.toHandle(a);
        }
        __emval_new_array_from_memory_view.sig = "pp";
        function __emval_new_object() {
          return Emval.toHandle({});
        }
        __emval_new_object.sig = "p";
        function __emval_new_cstring(v) {
          v >>>= 0;
          return Emval.toHandle(getStringOrSymbol(v));
        }
        __emval_new_cstring.sig = "pp";
        function __emval_new_u8string(v) {
          v >>>= 0;
          return Emval.toHandle(UTF8ToString(v));
        }
        __emval_new_u8string.sig = "pp";
        function __emval_new_u16string(v) {
          v >>>= 0;
          return Emval.toHandle(UTF16ToString(v));
        }
        __emval_new_u16string.sig = "pp";
        function __emval_take_value(type, arg) {
          type >>>= 0;
          arg >>>= 0;
          type = requireRegisteredType(type, "_emval_take_value");
          var v = type["readValueFromPointer"](arg);
          return Emval.toHandle(v);
        }
        __emval_take_value.sig = "ppp";
        var emval_get_global = () => {
          if (typeof globalThis == "object") {
            return globalThis;
          }
          return (/* @__PURE__ */ function() {
            return Function;
          }())("return this")();
        };
        function __emval_get_global(name2) {
          name2 >>>= 0;
          if (name2 === 0) {
            return Emval.toHandle(emval_get_global());
          } else {
            name2 = getStringOrSymbol(name2);
            return Emval.toHandle(emval_get_global()[name2]);
          }
        }
        __emval_get_global.sig = "pp";
        function __emval_get_module_property(name2) {
          name2 >>>= 0;
          name2 = getStringOrSymbol(name2);
          return Emval.toHandle(Module[name2]);
        }
        __emval_get_module_property.sig = "pp";
        function __emval_get_property(handle2, key) {
          handle2 >>>= 0;
          key >>>= 0;
          handle2 = Emval.toValue(handle2);
          key = Emval.toValue(key);
          return Emval.toHandle(handle2[key]);
        }
        __emval_get_property.sig = "ppp";
        function __emval_set_property(handle2, key, value) {
          handle2 >>>= 0;
          key >>>= 0;
          value >>>= 0;
          handle2 = Emval.toValue(handle2);
          key = Emval.toValue(key);
          value = Emval.toValue(value);
          handle2[key] = value;
        }
        __emval_set_property.sig = "vppp";
        var emval_returnValue = (returnType, destructorsRef, handle2) => {
          var destructors = [];
          var result = returnType["toWireType"](destructors, handle2);
          if (destructors.length) {
            HEAPU32[destructorsRef >>> 2 >>> 0] = Emval.toHandle(destructors);
          }
          return result;
        };
        function __emval_as(handle2, returnType, destructorsRef) {
          handle2 >>>= 0;
          returnType >>>= 0;
          destructorsRef >>>= 0;
          handle2 = Emval.toValue(handle2);
          returnType = requireRegisteredType(returnType, "emval::as");
          return emval_returnValue(returnType, destructorsRef, handle2);
        }
        __emval_as.sig = "dppp";
        function __emval_as_int64(handle2, returnType) {
          handle2 >>>= 0;
          returnType >>>= 0;
          handle2 = Emval.toValue(handle2);
          returnType = requireRegisteredType(returnType, "emval::as");
          return returnType["toWireType"](null, handle2);
        }
        __emval_as_int64.sig = "ipp";
        function __emval_as_uint64(handle2, returnType) {
          handle2 >>>= 0;
          returnType >>>= 0;
          handle2 = Emval.toValue(handle2);
          returnType = requireRegisteredType(returnType, "emval::as");
          return returnType["toWireType"](null, handle2);
        }
        __emval_as_uint64.sig = "ipp";
        function __emval_equals(first, second) {
          first >>>= 0;
          second >>>= 0;
          first = Emval.toValue(first);
          second = Emval.toValue(second);
          return first == second;
        }
        __emval_equals.sig = "ipp";
        function __emval_strictly_equals(first, second) {
          first >>>= 0;
          second >>>= 0;
          first = Emval.toValue(first);
          second = Emval.toValue(second);
          return first === second;
        }
        __emval_strictly_equals.sig = "ipp";
        function __emval_greater_than(first, second) {
          first >>>= 0;
          second >>>= 0;
          first = Emval.toValue(first);
          second = Emval.toValue(second);
          return first > second;
        }
        __emval_greater_than.sig = "ipp";
        function __emval_less_than(first, second) {
          first >>>= 0;
          second >>>= 0;
          first = Emval.toValue(first);
          second = Emval.toValue(second);
          return first < second;
        }
        __emval_less_than.sig = "ipp";
        function __emval_not(object) {
          object >>>= 0;
          object = Emval.toValue(object);
          return !object;
        }
        __emval_not.sig = "ip";
        var emval_methodCallers = [];
        function __emval_call(caller, handle2, destructorsRef, args2) {
          caller >>>= 0;
          handle2 >>>= 0;
          destructorsRef >>>= 0;
          args2 >>>= 0;
          caller = emval_methodCallers[caller];
          handle2 = Emval.toValue(handle2);
          return caller(null, handle2, destructorsRef, args2);
        }
        __emval_call.sig = "dpppp";
        var emval_lookupTypes = (argCount, argTypes) => {
          var a = new Array(argCount);
          for (var i2 = 0; i2 < argCount; ++i2) {
            a[i2] = requireRegisteredType(HEAPU32[argTypes + i2 * 4 >>> 2 >>> 0], "parameter " + i2);
          }
          return a;
        };
        var emval_addMethodCaller = (caller) => {
          var id = emval_methodCallers.length;
          emval_methodCallers.push(caller);
          return id;
        };
        var reflectConstruct = Reflect.construct;
        function __emval_get_method_caller(argCount, argTypes, kind) {
          argTypes >>>= 0;
          var types = emval_lookupTypes(argCount, argTypes);
          var retType = types.shift();
          argCount--;
          var functionBody = `return function (obj, func, destructorsRef, args) {
`;
          var offset = 0;
          var argsList = [];
          if (kind === 0) {
            argsList.push("obj");
          }
          var params = ["retType"];
          var args2 = [retType];
          for (var i2 = 0; i2 < argCount; ++i2) {
            argsList.push("arg" + i2);
            params.push("argType" + i2);
            args2.push(types[i2]);
            functionBody += `  var arg${i2} = argType${i2}.readValueFromPointer(args${offset ? "+" + offset : ""});
`;
            offset += types[i2]["argPackAdvance"];
          }
          var invoker = kind === 1 ? "new func" : "func.call";
          functionBody += `  var rv = ${invoker}(${argsList.join(", ")});
`;
          if (!retType.isVoid) {
            params.push("emval_returnValue");
            args2.push(emval_returnValue);
            functionBody += "  return emval_returnValue(retType, destructorsRef, rv);\n";
          }
          functionBody += "};\n";
          params.push(functionBody);
          var invokerFunction = newFunc(Function, params).apply(null, args2);
          var functionName = `methodCaller<(${types.map((t) => t.name).join(", ")}) => ${retType.name}>`;
          return emval_addMethodCaller(createNamedFunction(functionName, invokerFunction));
        }
        __emval_get_method_caller.sig = "pipi";
        function __emval_call_method(caller, objHandle, methodName, destructorsRef, args2) {
          caller >>>= 0;
          objHandle >>>= 0;
          methodName >>>= 0;
          destructorsRef >>>= 0;
          args2 >>>= 0;
          caller = emval_methodCallers[caller];
          objHandle = Emval.toValue(objHandle);
          methodName = getStringOrSymbol(methodName);
          return caller(objHandle, objHandle[methodName], destructorsRef, args2);
        }
        __emval_call_method.sig = "dppppp";
        function __emval_typeof(handle2) {
          handle2 >>>= 0;
          handle2 = Emval.toValue(handle2);
          return Emval.toHandle(typeof handle2);
        }
        __emval_typeof.sig = "pp";
        function __emval_instanceof(object, constructor) {
          object >>>= 0;
          constructor >>>= 0;
          object = Emval.toValue(object);
          constructor = Emval.toValue(constructor);
          return object instanceof constructor;
        }
        __emval_instanceof.sig = "ipp";
        function __emval_is_number(handle2) {
          handle2 >>>= 0;
          handle2 = Emval.toValue(handle2);
          return typeof handle2 == "number";
        }
        __emval_is_number.sig = "ip";
        function __emval_is_string(handle2) {
          handle2 >>>= 0;
          handle2 = Emval.toValue(handle2);
          return typeof handle2 == "string";
        }
        __emval_is_string.sig = "ip";
        function __emval_in(item, object) {
          item >>>= 0;
          object >>>= 0;
          item = Emval.toValue(item);
          object = Emval.toValue(object);
          return item in object;
        }
        __emval_in.sig = "ipp";
        function __emval_delete(object, property) {
          object >>>= 0;
          property >>>= 0;
          object = Emval.toValue(object);
          property = Emval.toValue(property);
          return delete object[property];
        }
        __emval_delete.sig = "ipp";
        function __emval_throw(object) {
          object >>>= 0;
          object = Emval.toValue(object);
          throw object;
        }
        __emval_throw.sig = "ip";
        function __emval_iter_begin(iterable) {
          iterable >>>= 0;
          iterable = Emval.toValue(iterable);
          return Emval.toHandle(iterable[Symbol.iterator]());
        }
        __emval_iter_begin.sig = "pp";
        function __emval_iter_next(iterator) {
          iterator >>>= 0;
          iterator = Emval.toValue(iterator);
          var result = iterator.next();
          return result.done ? 0 : Emval.toHandle(result.value);
        }
        __emval_iter_next.sig = "pp";
        var __emval_coro_suspend = function(promiseHandle, awaiterPtr) {
          promiseHandle >>>= 0;
          awaiterPtr >>>= 0;
          Emval.toValue(promiseHandle).then((result) => {
            __emval_coro_resume(awaiterPtr, Emval.toHandle(result));
          });
        };
        __emval_coro_suspend.sig = "vpp";
        var __emval_coro_make_promise = function(resolveHandlePtr, rejectHandlePtr) {
          resolveHandlePtr >>>= 0;
          rejectHandlePtr >>>= 0;
          return Emval.toHandle(new Promise((resolve, reject) => {
            const rejectWithCurrentException = () => {
              try {
                ___cxa_rethrow();
              } catch (e) {
                reject(e);
              }
            };
            HEAPU32[resolveHandlePtr >>> 2 >>> 0] = Emval.toHandle(resolve);
            HEAPU32[rejectHandlePtr >>> 2 >>> 0] = Emval.toHandle(rejectWithCurrentException);
          }));
        };
        __emval_coro_make_promise.sig = "ppp";
        function _duckdb_web_fs_file_sync(fileId) {
          return globalThis.DUCKDB_RUNTIME.syncFile(Module, fileId);
        }
        _duckdb_web_fs_file_sync.sig = "vi";
        function _duckdb_web_fs_file_remove(path2, pathLen) {
          return globalThis.DUCKDB_RUNTIME.removeFile(Module, path2, pathLen);
        }
        registerWasmPlugin();
        var FSNode = function(parent, name2, mode, rdev) {
          if (!parent) {
            parent = this;
          }
          this.parent = parent;
          this.mount = parent.mount;
          this.mounted = null;
          this.id = FS.nextInode++;
          this.name = name2;
          this.mode = mode;
          this.node_ops = {};
          this.stream_ops = {};
          this.rdev = rdev;
        };
        var readMode = 292 | 73;
        var writeMode = 146;
        Object.defineProperties(FSNode.prototype, {
          read: {
            get: function() {
              return (this.mode & readMode) === readMode;
            },
            set: function(val) {
              val ? this.mode |= readMode : this.mode &= ~readMode;
            }
          },
          write: {
            get: function() {
              return (this.mode & writeMode) === writeMode;
            },
            set: function(val) {
              val ? this.mode |= writeMode : this.mode &= ~writeMode;
            }
          },
          isFolder: {
            get: function() {
              return FS.isDir(this.mode);
            }
          },
          isDevice: {
            get: function() {
              return FS.isChrdev(this.mode);
            }
          }
        });
        FS.FSNode = FSNode;
        FS.createPreloadedFile = FS_createPreloadedFile;
        FS.staticInit();
        embind_init_charCodes();
        BindingError = Module["BindingError"] = class BindingError extends Error {
          constructor(message) {
            super(message);
            this.name = "BindingError";
          }
        };
        InternalError = Module["InternalError"] = class InternalError extends Error {
          constructor(message) {
            super(message);
            this.name = "InternalError";
          }
        };
        init_emval();
        Module["requestFullscreen"] = Browser.requestFullscreen;
        Module["requestAnimationFrame"] = Browser.requestAnimationFrame;
        Module["setCanvasSize"] = Browser.setCanvasSize;
        Module["pauseMainLoop"] = Browser.mainLoop.pause;
        Module["resumeMainLoop"] = Browser.mainLoop.resume;
        Module["getUserMedia"] = Browser.getUserMedia;
        Module["createContext"] = Browser.createContext;
        var preloadedImages = {};
        var preloadedAudios = {};
        var GLctx;
        for (var i = 0; i < 32; ++i)
          tempFixedLengthArray.push(new Array(i));
        var miniTempWebGLFloatBuffersStorage = new Float32Array(288);
        for (var i = 0; i < 288; ++i) {
          miniTempWebGLFloatBuffers[i] = miniTempWebGLFloatBuffersStorage.subarray(0, i + 1);
        }
        var miniTempWebGLIntBuffersStorage = new Int32Array(288);
        for (var i = 0; i < 288; ++i) {
          miniTempWebGLIntBuffers[i] = miniTempWebGLIntBuffersStorage.subarray(0, i + 1);
        }
        var emSetImmediate;
        var emClearImmediate;
        if (typeof setImmediate != "undefined") {
          emSetImmediate = setImmediateWrapped;
          emClearImmediate = clearImmediateWrapped;
        } else if (typeof addEventListener == "function") {
          var __setImmediate_id_counter = 0;
          var __setImmediate_queue = [];
          var __setImmediate_message_id = "_si";
          var __setImmediate_cb = (e) => {
            if (e.data === __setImmediate_message_id) {
              e.stopPropagation();
              __setImmediate_queue.shift()();
              ++__setImmediate_id_counter;
            }
          };
          addEventListener("message", __setImmediate_cb, true);
          emSetImmediate = (func2) => {
            postMessage(__setImmediate_message_id, "*");
            return __setImmediate_id_counter + __setImmediate_queue.push(func2) - 1;
          };
          emClearImmediate = (id) => {
            var index = id - __setImmediate_id_counter;
            if (index >= 0 && index < __setImmediate_queue.length)
              __setImmediate_queue[index] = () => {
              };
          };
        }
        UnboundTypeError = Module["UnboundTypeError"] = extendError(Error, "UnboundTypeError");
        PureVirtualError = Module["PureVirtualError"] = extendError(Error, "PureVirtualError");
        init_embind();
        init_RegisteredPointer();
        init_ClassHandle();
        var wasmImports = {
          IMG_Init: _IMG_Init,
          IMG_Load: _IMG_Load,
          IMG_Load_RW: _IMG_Load_RW,
          IMG_Quit: _IMG_Quit,
          Mix_AllocateChannels: _Mix_AllocateChannels,
          Mix_ChannelFinished: _Mix_ChannelFinished,
          Mix_CloseAudio: _Mix_CloseAudio,
          Mix_FadeInChannelTimed: _Mix_FadeInChannelTimed,
          Mix_FadeInMusicPos: _Mix_FadeInMusicPos,
          Mix_FadeOutChannel: _Mix_FadeOutChannel,
          Mix_FadeOutMusic: _Mix_FadeOutMusic,
          Mix_FadingChannel: _Mix_FadingChannel,
          Mix_FreeChunk: _Mix_FreeChunk,
          Mix_FreeMusic: _Mix_FreeMusic,
          Mix_HaltChannel: _Mix_HaltChannel,
          Mix_HaltMusic: _Mix_HaltMusic,
          Mix_HookMusicFinished: _Mix_HookMusicFinished,
          Mix_Init: _Mix_Init,
          Mix_Linked_Version: _Mix_Linked_Version,
          Mix_LoadMUS: _Mix_LoadMUS,
          Mix_LoadMUS_RW: _Mix_LoadMUS_RW,
          Mix_LoadWAV: _Mix_LoadWAV,
          Mix_LoadWAV_RW: _Mix_LoadWAV_RW,
          Mix_OpenAudio: _Mix_OpenAudio,
          Mix_Pause: _Mix_Pause,
          Mix_PauseMusic: _Mix_PauseMusic,
          Mix_Paused: _Mix_Paused,
          Mix_PausedMusic: _Mix_PausedMusic,
          Mix_PlayChannelTimed: _Mix_PlayChannelTimed,
          Mix_PlayMusic: _Mix_PlayMusic,
          Mix_Playing: _Mix_Playing,
          Mix_PlayingMusic: _Mix_PlayingMusic,
          Mix_QuerySpec: _Mix_QuerySpec,
          Mix_QuickLoad_RAW: _Mix_QuickLoad_RAW,
          Mix_Quit: _Mix_Quit,
          Mix_ReserveChannels: _Mix_ReserveChannels,
          Mix_Resume: _Mix_Resume,
          Mix_ResumeMusic: _Mix_ResumeMusic,
          Mix_SetPanning: _Mix_SetPanning,
          Mix_SetPosition: _Mix_SetPosition,
          Mix_SetPostMix: _Mix_SetPostMix,
          Mix_Volume: _Mix_Volume,
          Mix_VolumeChunk: _Mix_VolumeChunk,
          Mix_VolumeMusic: _Mix_VolumeMusic,
          SDL_AddTimer: _SDL_AddTimer,
          SDL_AllocRW: _SDL_AllocRW,
          SDL_AudioDriverName: _SDL_AudioDriverName,
          SDL_AudioQuit: _SDL_AudioQuit,
          SDL_ClearError: _SDL_ClearError,
          SDL_CloseAudio: _SDL_CloseAudio,
          SDL_CondBroadcast: _SDL_CondBroadcast,
          SDL_CondSignal: _SDL_CondSignal,
          SDL_CondWait: _SDL_CondWait,
          SDL_CondWaitTimeout: _SDL_CondWaitTimeout,
          SDL_ConvertSurface: _SDL_ConvertSurface,
          SDL_CreateCond: _SDL_CreateCond,
          SDL_CreateMutex: _SDL_CreateMutex,
          SDL_CreateRGBSurface: _SDL_CreateRGBSurface,
          SDL_CreateRGBSurfaceFrom: _SDL_CreateRGBSurfaceFrom,
          SDL_CreateThread: _SDL_CreateThread,
          SDL_Delay: _SDL_Delay,
          SDL_DestroyCond: _SDL_DestroyCond,
          SDL_DestroyMutex: _SDL_DestroyMutex,
          SDL_DestroyRenderer: _SDL_DestroyRenderer,
          SDL_DestroyWindow: _SDL_DestroyWindow,
          SDL_DisplayFormatAlpha: _SDL_DisplayFormatAlpha,
          SDL_EnableKeyRepeat: _SDL_EnableKeyRepeat,
          SDL_EnableUNICODE: _SDL_EnableUNICODE,
          SDL_FillRect: _SDL_FillRect,
          SDL_Flip: _SDL_Flip,
          SDL_FreeRW: _SDL_FreeRW,
          SDL_FreeSurface: _SDL_FreeSurface,
          SDL_GL_DeleteContext: _SDL_GL_DeleteContext,
          SDL_GL_ExtensionSupported: _SDL_GL_ExtensionSupported,
          SDL_GL_GetAttribute: _SDL_GL_GetAttribute,
          SDL_GL_GetSwapInterval: _SDL_GL_GetSwapInterval,
          SDL_GL_MakeCurrent: _SDL_GL_MakeCurrent,
          SDL_GL_SetAttribute: _SDL_GL_SetAttribute,
          SDL_GL_SetSwapInterval: _SDL_GL_SetSwapInterval,
          SDL_GL_SwapBuffers: _SDL_GL_SwapBuffers,
          SDL_GL_SwapWindow: _SDL_GL_SwapWindow,
          SDL_GetAppState: _SDL_GetAppState,
          SDL_GetAudioDriver: _SDL_GetAudioDriver,
          SDL_GetClipRect: _SDL_GetClipRect,
          SDL_GetCurrentAudioDriver: _SDL_GetCurrentAudioDriver,
          SDL_GetError: _SDL_GetError,
          SDL_GetKeyName: _SDL_GetKeyName,
          SDL_GetKeyState: _SDL_GetKeyState,
          SDL_GetKeyboardState: _SDL_GetKeyboardState,
          SDL_GetModState: _SDL_GetModState,
          SDL_GetMouseState: _SDL_GetMouseState,
          SDL_GetNumAudioDrivers: _SDL_GetNumAudioDrivers,
          SDL_GetRGB: _SDL_GetRGB,
          SDL_GetRGBA: _SDL_GetRGBA,
          SDL_GetScancodeFromKey: _SDL_GetScancodeFromKey,
          SDL_GetThreadID: _SDL_GetThreadID,
          SDL_GetTicks: _SDL_GetTicks,
          SDL_GetVideoInfo: _SDL_GetVideoInfo,
          SDL_GetVideoSurface: _SDL_GetVideoSurface,
          SDL_GetWindowFlags: _SDL_GetWindowFlags,
          SDL_GetWindowSize: _SDL_GetWindowSize,
          SDL_Has3DNow: _SDL_Has3DNow,
          SDL_Has3DNowExt: _SDL_Has3DNowExt,
          SDL_HasAltiVec: _SDL_HasAltiVec,
          SDL_HasMMX: _SDL_HasMMX,
          SDL_HasMMXExt: _SDL_HasMMXExt,
          SDL_HasRDTSC: _SDL_HasRDTSC,
          SDL_HasSSE: _SDL_HasSSE,
          SDL_HasSSE2: _SDL_HasSSE2,
          SDL_Init: _SDL_Init,
          SDL_InitSubSystem: _SDL_InitSubSystem,
          SDL_JoystickClose: _SDL_JoystickClose,
          SDL_JoystickEventState: _SDL_JoystickEventState,
          SDL_JoystickGetAxis: _SDL_JoystickGetAxis,
          SDL_JoystickGetBall: _SDL_JoystickGetBall,
          SDL_JoystickGetButton: _SDL_JoystickGetButton,
          SDL_JoystickGetHat: _SDL_JoystickGetHat,
          SDL_JoystickIndex: _SDL_JoystickIndex,
          SDL_JoystickName: _SDL_JoystickName,
          SDL_JoystickNumAxes: _SDL_JoystickNumAxes,
          SDL_JoystickNumBalls: _SDL_JoystickNumBalls,
          SDL_JoystickNumButtons: _SDL_JoystickNumButtons,
          SDL_JoystickNumHats: _SDL_JoystickNumHats,
          SDL_JoystickOpen: _SDL_JoystickOpen,
          SDL_JoystickOpened: _SDL_JoystickOpened,
          SDL_JoystickUpdate: _SDL_JoystickUpdate,
          SDL_Linked_Version: _SDL_Linked_Version,
          SDL_ListModes: _SDL_ListModes,
          SDL_LoadBMP_RW: _SDL_LoadBMP_RW,
          SDL_LockAudio: _SDL_LockAudio,
          SDL_LockSurface: _SDL_LockSurface,
          SDL_LogSetOutputFunction: _SDL_LogSetOutputFunction,
          SDL_LowerBlit: _SDL_LowerBlit,
          SDL_LowerBlitScaled: _SDL_LowerBlitScaled,
          SDL_MapRGB: _SDL_MapRGB,
          SDL_MapRGBA: _SDL_MapRGBA,
          SDL_NumJoysticks: _SDL_NumJoysticks,
          SDL_OpenAudio: _SDL_OpenAudio,
          SDL_PauseAudio: _SDL_PauseAudio,
          SDL_PeepEvents: _SDL_PeepEvents,
          SDL_PollEvent: _SDL_PollEvent,
          SDL_PumpEvents: _SDL_PumpEvents,
          SDL_PushEvent: _SDL_PushEvent,
          SDL_Quit: _SDL_Quit,
          SDL_QuitSubSystem: _SDL_QuitSubSystem,
          SDL_RWFromConstMem: _SDL_RWFromConstMem,
          SDL_RWFromFile: _SDL_RWFromFile,
          SDL_RWFromMem: _SDL_RWFromMem,
          SDL_RemoveTimer: _SDL_RemoveTimer,
          SDL_SaveBMP_RW: _SDL_SaveBMP_RW,
          SDL_SetAlpha: _SDL_SetAlpha,
          SDL_SetClipRect: _SDL_SetClipRect,
          SDL_SetColorKey: _SDL_SetColorKey,
          SDL_SetColors: _SDL_SetColors,
          SDL_SetError: _SDL_SetError,
          SDL_SetGamma: _SDL_SetGamma,
          SDL_SetGammaRamp: _SDL_SetGammaRamp,
          SDL_SetPalette: _SDL_SetPalette,
          SDL_SetVideoMode: _SDL_SetVideoMode,
          SDL_SetWindowFullscreen: _SDL_SetWindowFullscreen,
          SDL_SetWindowTitle: _SDL_SetWindowTitle,
          SDL_ShowCursor: _SDL_ShowCursor,
          SDL_StartTextInput: _SDL_StartTextInput,
          SDL_StopTextInput: _SDL_StopTextInput,
          SDL_ThreadID: _SDL_ThreadID,
          SDL_UnlockAudio: _SDL_UnlockAudio,
          SDL_UnlockSurface: _SDL_UnlockSurface,
          SDL_UpdateRect: _SDL_UpdateRect,
          SDL_UpdateRects: _SDL_UpdateRects,
          SDL_UpperBlit: _SDL_UpperBlit,
          SDL_UpperBlitScaled: _SDL_UpperBlitScaled,
          SDL_VideoDriverName: _SDL_VideoDriverName,
          SDL_VideoModeOK: _SDL_VideoModeOK,
          SDL_VideoQuit: _SDL_VideoQuit,
          SDL_WM_GrabInput: _SDL_WM_GrabInput,
          SDL_WM_IconifyWindow: _SDL_WM_IconifyWindow,
          SDL_WM_SetCaption: _SDL_WM_SetCaption,
          SDL_WM_SetIcon: _SDL_WM_SetIcon,
          SDL_WM_ToggleFullScreen: _SDL_WM_ToggleFullScreen,
          SDL_WaitThread: _SDL_WaitThread,
          SDL_WarpMouse: _SDL_WarpMouse,
          SDL_WasInit: _SDL_WasInit,
          SDL_mutexP: _SDL_mutexP,
          SDL_mutexV: _SDL_mutexV,
          TTF_CloseFont: _TTF_CloseFont,
          TTF_FontAscent: _TTF_FontAscent,
          TTF_FontDescent: _TTF_FontDescent,
          TTF_FontHeight: _TTF_FontHeight,
          TTF_FontLineSkip: _TTF_FontLineSkip,
          TTF_GlyphMetrics: _TTF_GlyphMetrics,
          TTF_Init: _TTF_Init,
          TTF_OpenFont: _TTF_OpenFont,
          TTF_Quit: _TTF_Quit,
          TTF_RenderText_Blended: _TTF_RenderText_Blended,
          TTF_RenderText_Shaded: _TTF_RenderText_Shaded,
          TTF_RenderText_Solid: _TTF_RenderText_Solid,
          TTF_RenderUTF8_Solid: _TTF_RenderUTF8_Solid,
          TTF_SizeText: _TTF_SizeText,
          TTF_SizeUTF8: _TTF_SizeUTF8,
          XChangeWindowAttributes: _XChangeWindowAttributes,
          XCreateWindow: _XCreateWindow,
          XInternAtom: _XInternAtom,
          XMapWindow: _XMapWindow,
          XOpenDisplay: _XOpenDisplay,
          XPending: _XPending,
          XSendEvent: _XSendEvent,
          XSetWMHints: _XSetWMHints,
          XStoreName: _XStoreName,
          _Unwind_Backtrace: __Unwind_Backtrace,
          _Unwind_DeleteException: __Unwind_DeleteException,
          _Unwind_FindEnclosingFunction: __Unwind_FindEnclosingFunction,
          _Unwind_GetIPInfo: __Unwind_GetIPInfo,
          _Unwind_RaiseException: __Unwind_RaiseException,
          __asctime_r: ___asctime_r,
          __assert_fail: ___assert_fail,
          __call_sighandler: ___call_sighandler,
          __cxa_begin_catch: ___cxa_begin_catch,
          __cxa_call_unexpected: ___cxa_call_unexpected,
          __cxa_current_primary_exception: ___cxa_current_primary_exception,
          __cxa_end_catch: ___cxa_end_catch,
          __cxa_find_matching_catch_2: ___cxa_find_matching_catch_2,
          __cxa_find_matching_catch_3: ___cxa_find_matching_catch_3,
          __cxa_find_matching_catch_4: ___cxa_find_matching_catch_4,
          __cxa_find_matching_catch_5: ___cxa_find_matching_catch_5,
          __cxa_find_matching_catch_6: ___cxa_find_matching_catch_6,
          __cxa_find_matching_catch_7: ___cxa_find_matching_catch_7,
          __cxa_get_exception_ptr: ___cxa_get_exception_ptr,
          __cxa_rethrow: ___cxa_rethrow,
          __cxa_rethrow_primary_exception: ___cxa_rethrow_primary_exception,
          __cxa_throw: ___cxa_throw,
          __cxa_uncaught_exceptions: ___cxa_uncaught_exceptions,
          __global_base: ___global_base,
          __heap_base: ___heap_base,
          __indirect_function_table: wasmTable,
          __memory_base: ___memory_base,
          __resumeException: ___resumeException,
          __stack_high: ___stack_high,
          __stack_low: ___stack_low,
          __stack_pointer: ___stack_pointer,
          __syscall__newselect: ___syscall__newselect,
          __syscall_accept4: ___syscall_accept4,
          __syscall_bind: ___syscall_bind,
          __syscall_chdir: ___syscall_chdir,
          __syscall_chmod: ___syscall_chmod,
          __syscall_connect: ___syscall_connect,
          __syscall_dup: ___syscall_dup,
          __syscall_dup3: ___syscall_dup3,
          __syscall_faccessat: ___syscall_faccessat,
          __syscall_fadvise64: ___syscall_fadvise64,
          __syscall_fallocate: ___syscall_fallocate,
          __syscall_fchdir: ___syscall_fchdir,
          __syscall_fchmod: ___syscall_fchmod,
          __syscall_fchmodat: ___syscall_fchmodat,
          __syscall_fchown32: ___syscall_fchown32,
          __syscall_fchownat: ___syscall_fchownat,
          __syscall_fcntl64: ___syscall_fcntl64,
          __syscall_fdatasync: ___syscall_fdatasync,
          __syscall_fstat64: ___syscall_fstat64,
          __syscall_fstatfs64: ___syscall_fstatfs64,
          __syscall_ftruncate64: ___syscall_ftruncate64,
          __syscall_getcwd: ___syscall_getcwd,
          __syscall_getdents64: ___syscall_getdents64,
          __syscall_getpeername: ___syscall_getpeername,
          __syscall_getsockname: ___syscall_getsockname,
          __syscall_getsockopt: ___syscall_getsockopt,
          __syscall_ioctl: ___syscall_ioctl,
          __syscall_listen: ___syscall_listen,
          __syscall_lstat64: ___syscall_lstat64,
          __syscall_mkdirat: ___syscall_mkdirat,
          __syscall_mknodat: ___syscall_mknodat,
          __syscall_newfstatat: ___syscall_newfstatat,
          __syscall_openat: ___syscall_openat,
          __syscall_pipe: ___syscall_pipe,
          __syscall_poll: ___syscall_poll,
          __syscall_readlinkat: ___syscall_readlinkat,
          __syscall_recvfrom: ___syscall_recvfrom,
          __syscall_recvmsg: ___syscall_recvmsg,
          __syscall_renameat: ___syscall_renameat,
          __syscall_rmdir: ___syscall_rmdir,
          __syscall_sendmsg: ___syscall_sendmsg,
          __syscall_sendto: ___syscall_sendto,
          __syscall_socket: ___syscall_socket,
          __syscall_stat64: ___syscall_stat64,
          __syscall_statfs64: ___syscall_statfs64,
          __syscall_symlink: ___syscall_symlink,
          __syscall_symlinkat: ___syscall_symlinkat,
          __syscall_truncate64: ___syscall_truncate64,
          __syscall_unlinkat: ___syscall_unlinkat,
          __syscall_utimensat: ___syscall_utimensat,
          __table_base: ___table_base,
          _dlopen_js: __dlopen_js,
          _dlsym_catchup_js: __dlsym_catchup_js,
          _dlsym_js: __dlsym_js,
          _embind_create_inheriting_constructor: __embind_create_inheriting_constructor,
          _embind_finalize_value_array: __embind_finalize_value_array,
          _embind_finalize_value_object: __embind_finalize_value_object,
          _embind_register_bigint: __embind_register_bigint,
          _embind_register_bool: __embind_register_bool,
          _embind_register_class: __embind_register_class,
          _embind_register_class_class_function: __embind_register_class_class_function,
          _embind_register_class_class_property: __embind_register_class_class_property,
          _embind_register_class_constructor: __embind_register_class_constructor,
          _embind_register_class_function: __embind_register_class_function,
          _embind_register_class_property: __embind_register_class_property,
          _embind_register_constant: __embind_register_constant,
          _embind_register_emval: __embind_register_emval,
          _embind_register_enum: __embind_register_enum,
          _embind_register_enum_value: __embind_register_enum_value,
          _embind_register_float: __embind_register_float,
          _embind_register_function: __embind_register_function,
          _embind_register_integer: __embind_register_integer,
          _embind_register_memory_view: __embind_register_memory_view,
          _embind_register_optional: __embind_register_optional,
          _embind_register_smart_ptr: __embind_register_smart_ptr,
          _embind_register_std_string: __embind_register_std_string,
          _embind_register_std_wstring: __embind_register_std_wstring,
          _embind_register_user_type: __embind_register_user_type,
          _embind_register_value_array: __embind_register_value_array,
          _embind_register_value_array_element: __embind_register_value_array_element,
          _embind_register_value_object: __embind_register_value_object,
          _embind_register_value_object_field: __embind_register_value_object_field,
          _embind_register_void: __embind_register_void,
          _emscripten_dlopen_js: __emscripten_dlopen_js,
          _emscripten_fs_load_embedded_files: __emscripten_fs_load_embedded_files,
          _emscripten_get_now_is_monotonic: __emscripten_get_now_is_monotonic,
          _emscripten_get_progname: __emscripten_get_progname,
          _emscripten_lookup_name: __emscripten_lookup_name,
          _emscripten_push_main_loop_blocker: __emscripten_push_main_loop_blocker,
          _emscripten_push_uncounted_main_loop_blocker: __emscripten_push_uncounted_main_loop_blocker,
          _emscripten_runtime_keepalive_clear: __emscripten_runtime_keepalive_clear,
          _emscripten_set_offscreencanvas_size: __emscripten_set_offscreencanvas_size,
          _emscripten_system: __emscripten_system,
          _emscripten_throw_longjmp: __emscripten_throw_longjmp,
          _emval_as: __emval_as,
          _emval_as_int64: __emval_as_int64,
          _emval_as_uint64: __emval_as_uint64,
          _emval_call: __emval_call,
          _emval_call_method: __emval_call_method,
          _emval_coro_make_promise: __emval_coro_make_promise,
          _emval_coro_suspend: __emval_coro_suspend,
          _emval_decref: __emval_decref,
          _emval_delete: __emval_delete,
          _emval_equals: __emval_equals,
          _emval_get_global: __emval_get_global,
          _emval_get_method_caller: __emval_get_method_caller,
          _emval_get_module_property: __emval_get_module_property,
          _emval_get_property: __emval_get_property,
          _emval_greater_than: __emval_greater_than,
          _emval_in: __emval_in,
          _emval_incref: __emval_incref,
          _emval_instanceof: __emval_instanceof,
          _emval_is_number: __emval_is_number,
          _emval_is_string: __emval_is_string,
          _emval_iter_begin: __emval_iter_begin,
          _emval_iter_next: __emval_iter_next,
          _emval_less_than: __emval_less_than,
          _emval_new_array: __emval_new_array,
          _emval_new_array_from_memory_view: __emval_new_array_from_memory_view,
          _emval_new_cstring: __emval_new_cstring,
          _emval_new_object: __emval_new_object,
          _emval_new_u16string: __emval_new_u16string,
          _emval_new_u8string: __emval_new_u8string,
          _emval_not: __emval_not,
          _emval_register_symbol: __emval_register_symbol,
          _emval_run_destructors: __emval_run_destructors,
          _emval_set_property: __emval_set_property,
          _emval_strictly_equals: __emval_strictly_equals,
          _emval_take_value: __emval_take_value,
          _emval_throw: __emval_throw,
          _emval_typeof: __emval_typeof,
          _glGenObject: __glGenObject,
          _glGetActiveAttribOrUniform: __glGetActiveAttribOrUniform,
          _gmtime_js: __gmtime_js,
          _localtime_js: __localtime_js,
          _mktime_js: __mktime_js,
          _mmap_js: __mmap_js,
          _msync_js: __msync_js,
          _munmap_js: __munmap_js,
          _setitimer_js: __setitimer_js,
          _timegm_js: __timegm_js,
          _tzset_js: __tzset_js,
          abort: _abort,
          alBuffer3f: _alBuffer3f,
          alBuffer3i: _alBuffer3i,
          alBufferData: _alBufferData,
          alBufferf: _alBufferf,
          alBufferfv: _alBufferfv,
          alBufferi: _alBufferi,
          alBufferiv: _alBufferiv,
          alDeleteBuffers: _alDeleteBuffers,
          alDeleteSources: _alDeleteSources,
          alDisable: _alDisable,
          alDistanceModel: _alDistanceModel,
          alDopplerFactor: _alDopplerFactor,
          alDopplerVelocity: _alDopplerVelocity,
          alEnable: _alEnable,
          alGenBuffers: _alGenBuffers,
          alGenSources: _alGenSources,
          alGetBoolean: _alGetBoolean,
          alGetBooleanv: _alGetBooleanv,
          alGetBuffer3f: _alGetBuffer3f,
          alGetBuffer3i: _alGetBuffer3i,
          alGetBufferf: _alGetBufferf,
          alGetBufferfv: _alGetBufferfv,
          alGetBufferi: _alGetBufferi,
          alGetBufferiv: _alGetBufferiv,
          alGetDouble: _alGetDouble,
          alGetDoublev: _alGetDoublev,
          alGetEnumValue: _alGetEnumValue,
          alGetError: _alGetError,
          alGetFloat: _alGetFloat,
          alGetFloatv: _alGetFloatv,
          alGetInteger: _alGetInteger,
          alGetIntegerv: _alGetIntegerv,
          alGetListener3f: _alGetListener3f,
          alGetListener3i: _alGetListener3i,
          alGetListenerf: _alGetListenerf,
          alGetListenerfv: _alGetListenerfv,
          alGetListeneri: _alGetListeneri,
          alGetListeneriv: _alGetListeneriv,
          alGetSource3f: _alGetSource3f,
          alGetSource3i: _alGetSource3i,
          alGetSourcef: _alGetSourcef,
          alGetSourcefv: _alGetSourcefv,
          alGetSourcei: _alGetSourcei,
          alGetSourceiv: _alGetSourceiv,
          alGetString: _alGetString,
          alIsBuffer: _alIsBuffer,
          alIsEnabled: _alIsEnabled,
          alIsExtensionPresent: _alIsExtensionPresent,
          alIsSource: _alIsSource,
          alListener3f: _alListener3f,
          alListener3i: _alListener3i,
          alListenerf: _alListenerf,
          alListenerfv: _alListenerfv,
          alListeneri: _alListeneri,
          alListeneriv: _alListeneriv,
          alSource3f: _alSource3f,
          alSource3i: _alSource3i,
          alSourcePause: _alSourcePause,
          alSourcePausev: _alSourcePausev,
          alSourcePlay: _alSourcePlay,
          alSourcePlayv: _alSourcePlayv,
          alSourceQueueBuffers: _alSourceQueueBuffers,
          alSourceRewind: _alSourceRewind,
          alSourceRewindv: _alSourceRewindv,
          alSourceStop: _alSourceStop,
          alSourceStopv: _alSourceStopv,
          alSourceUnqueueBuffers: _alSourceUnqueueBuffers,
          alSourcef: _alSourcef,
          alSourcefv: _alSourcefv,
          alSourcei: _alSourcei,
          alSourceiv: _alSourceiv,
          alSpeedOfSound: _alSpeedOfSound,
          alcCaptureCloseDevice: _alcCaptureCloseDevice,
          alcCaptureOpenDevice: _alcCaptureOpenDevice,
          alcCaptureSamples: _alcCaptureSamples,
          alcCaptureStart: _alcCaptureStart,
          alcCaptureStop: _alcCaptureStop,
          alcCloseDevice: _alcCloseDevice,
          alcCreateContext: _alcCreateContext,
          alcDestroyContext: _alcDestroyContext,
          alcGetContextsDevice: _alcGetContextsDevice,
          alcGetCurrentContext: _alcGetCurrentContext,
          alcGetEnumValue: _alcGetEnumValue,
          alcGetError: _alcGetError,
          alcGetIntegerv: _alcGetIntegerv,
          alcGetString: _alcGetString,
          alcIsExtensionPresent: _alcIsExtensionPresent,
          alcMakeContextCurrent: _alcMakeContextCurrent,
          alcOpenDevice: _alcOpenDevice,
          alcProcessContext: _alcProcessContext,
          alcSuspendContext: _alcSuspendContext,
          boxColor: _boxColor,
          boxRGBA: _boxRGBA,
          clock_res_get: _clock_res_get,
          clock_time_get: _clock_time_get,
          duckdb_web_fs_directory_create: _duckdb_web_fs_directory_create,
          duckdb_web_fs_directory_exists: _duckdb_web_fs_directory_exists,
          duckdb_web_fs_directory_list_files: _duckdb_web_fs_directory_list_files,
          duckdb_web_fs_directory_remove: _duckdb_web_fs_directory_remove,
          duckdb_web_fs_file_close: _duckdb_web_fs_file_close,
          duckdb_web_fs_file_exists: _duckdb_web_fs_file_exists,
          duckdb_web_fs_file_get_last_modified_time: _duckdb_web_fs_file_get_last_modified_time,
          duckdb_web_fs_file_move: _duckdb_web_fs_file_move,
          duckdb_web_fs_file_open: _duckdb_web_fs_file_open,
          duckdb_web_fs_file_read: _duckdb_web_fs_file_read,
          duckdb_web_fs_file_remove: _duckdb_web_fs_file_remove,
          duckdb_web_fs_file_sync: _duckdb_web_fs_file_sync,
          duckdb_web_fs_file_truncate: _duckdb_web_fs_file_truncate,
          duckdb_web_fs_file_write: _duckdb_web_fs_file_write,
          duckdb_web_fs_get_default_data_protocol: _duckdb_web_fs_get_default_data_protocol,
          duckdb_web_fs_glob: _duckdb_web_fs_glob,
          duckdb_web_test_platform_feature: _duckdb_web_test_platform_feature,
          duckdb_web_udf_scalar_call: _duckdb_web_udf_scalar_call,
          eglBindAPI: _eglBindAPI,
          eglChooseConfig: _eglChooseConfig,
          eglCreateContext: _eglCreateContext,
          eglCreateWindowSurface: _eglCreateWindowSurface,
          eglDestroyContext: _eglDestroyContext,
          eglDestroySurface: _eglDestroySurface,
          eglGetConfigAttrib: _eglGetConfigAttrib,
          eglGetConfigs: _eglGetConfigs,
          eglGetCurrentContext: _eglGetCurrentContext,
          eglGetCurrentDisplay: _eglGetCurrentDisplay,
          eglGetCurrentSurface: _eglGetCurrentSurface,
          eglGetDisplay: _eglGetDisplay,
          eglGetError: _eglGetError,
          eglInitialize: _eglInitialize,
          eglMakeCurrent: _eglMakeCurrent,
          eglQueryAPI: _eglQueryAPI,
          eglQueryContext: _eglQueryContext,
          eglQueryString: _eglQueryString,
          eglQuerySurface: _eglQuerySurface,
          eglReleaseThread: _eglReleaseThread,
          eglSwapBuffers: _eglSwapBuffers,
          eglSwapInterval: _eglSwapInterval,
          eglTerminate: _eglTerminate,
          eglWaitClient: _eglWaitClient,
          eglWaitGL: _eglWaitGL,
          eglWaitNative: _eglWaitNative,
          ellipseColor: _ellipseColor,
          ellipseRGBA: _ellipseRGBA,
          emscripten_SDL_SetEventHandler: _emscripten_SDL_SetEventHandler,
          emscripten_alcDevicePauseSOFT: _emscripten_alcDevicePauseSOFT,
          emscripten_alcDeviceResumeSOFT: _emscripten_alcDeviceResumeSOFT,
          emscripten_alcGetStringiSOFT: _emscripten_alcGetStringiSOFT,
          emscripten_alcResetDeviceSOFT: _emscripten_alcResetDeviceSOFT,
          emscripten_asm_const_async_on_main_thread: _emscripten_asm_const_async_on_main_thread,
          emscripten_asm_const_double: _emscripten_asm_const_double,
          emscripten_asm_const_double_sync_on_main_thread: _emscripten_asm_const_double_sync_on_main_thread,
          emscripten_asm_const_int: _emscripten_asm_const_int,
          emscripten_asm_const_int_sync_on_main_thread: _emscripten_asm_const_int_sync_on_main_thread,
          emscripten_asm_const_ptr: _emscripten_asm_const_ptr,
          emscripten_asm_const_ptr_sync_on_main_thread: _emscripten_asm_const_ptr_sync_on_main_thread,
          emscripten_async_call: _emscripten_async_call,
          emscripten_async_load_script: _emscripten_async_load_script,
          emscripten_async_run_script: _emscripten_async_run_script,
          emscripten_async_wget: _emscripten_async_wget,
          emscripten_async_wget2: _emscripten_async_wget2,
          emscripten_async_wget2_abort: _emscripten_async_wget2_abort,
          emscripten_async_wget2_data: _emscripten_async_wget2_data,
          emscripten_async_wget_data: _emscripten_async_wget_data,
          emscripten_call_worker: _emscripten_call_worker,
          emscripten_cancel_animation_frame: _emscripten_cancel_animation_frame,
          emscripten_cancel_main_loop: _emscripten_cancel_main_loop,
          emscripten_clear_immediate: _emscripten_clear_immediate,
          emscripten_clear_interval: _emscripten_clear_interval,
          emscripten_clear_timeout: _emscripten_clear_timeout,
          emscripten_console_error: _emscripten_console_error,
          emscripten_console_log: _emscripten_console_log,
          emscripten_console_warn: _emscripten_console_warn,
          emscripten_create_worker: _emscripten_create_worker,
          emscripten_date_now: _emscripten_date_now,
          emscripten_debugger: _emscripten_debugger,
          emscripten_destroy_worker: _emscripten_destroy_worker,
          emscripten_enter_soft_fullscreen: _emscripten_enter_soft_fullscreen,
          emscripten_err: _emscripten_err,
          emscripten_errn: _emscripten_errn,
          emscripten_exit_fullscreen: _emscripten_exit_fullscreen,
          emscripten_exit_pointerlock: _emscripten_exit_pointerlock,
          emscripten_exit_soft_fullscreen: _emscripten_exit_soft_fullscreen,
          emscripten_exit_with_live_runtime: _emscripten_exit_with_live_runtime,
          emscripten_fiber_swap: _emscripten_fiber_swap,
          emscripten_force_exit: _emscripten_force_exit,
          emscripten_get_battery_status: _emscripten_get_battery_status,
          emscripten_get_callstack: _emscripten_get_callstack,
          emscripten_get_canvas_element_size: _emscripten_get_canvas_element_size,
          emscripten_get_canvas_size: _emscripten_get_canvas_size,
          emscripten_get_compiler_setting: _emscripten_get_compiler_setting,
          emscripten_get_device_pixel_ratio: _emscripten_get_device_pixel_ratio,
          emscripten_get_devicemotion_status: _emscripten_get_devicemotion_status,
          emscripten_get_deviceorientation_status: _emscripten_get_deviceorientation_status,
          emscripten_get_element_css_size: _emscripten_get_element_css_size,
          emscripten_get_fullscreen_status: _emscripten_get_fullscreen_status,
          emscripten_get_gamepad_status: _emscripten_get_gamepad_status,
          emscripten_get_heap_max: _emscripten_get_heap_max,
          emscripten_get_main_loop_timing: _emscripten_get_main_loop_timing,
          emscripten_get_module_name: _emscripten_get_module_name,
          emscripten_get_mouse_status: _emscripten_get_mouse_status,
          emscripten_get_now: _emscripten_get_now,
          emscripten_get_now_res: _emscripten_get_now_res,
          emscripten_get_num_gamepads: _emscripten_get_num_gamepads,
          emscripten_get_orientation_status: _emscripten_get_orientation_status,
          emscripten_get_pointerlock_status: _emscripten_get_pointerlock_status,
          emscripten_get_preloaded_image_data: _emscripten_get_preloaded_image_data,
          emscripten_get_preloaded_image_data_from_FILE: _emscripten_get_preloaded_image_data_from_FILE,
          emscripten_get_screen_size: _emscripten_get_screen_size,
          emscripten_get_visibility_status: _emscripten_get_visibility_status,
          emscripten_get_window_title: _emscripten_get_window_title,
          emscripten_get_worker_queue_size: _emscripten_get_worker_queue_size,
          emscripten_glActiveTexture: _emscripten_glActiveTexture,
          emscripten_glAttachShader: _emscripten_glAttachShader,
          emscripten_glBegin: _emscripten_glBegin,
          emscripten_glBeginQueryEXT: _emscripten_glBeginQueryEXT,
          emscripten_glBindAttribLocation: _emscripten_glBindAttribLocation,
          emscripten_glBindBuffer: _emscripten_glBindBuffer,
          emscripten_glBindFramebuffer: _emscripten_glBindFramebuffer,
          emscripten_glBindRenderbuffer: _emscripten_glBindRenderbuffer,
          emscripten_glBindTexture: _emscripten_glBindTexture,
          emscripten_glBindVertexArray: _emscripten_glBindVertexArray,
          emscripten_glBindVertexArrayOES: _emscripten_glBindVertexArrayOES,
          emscripten_glBlendColor: _emscripten_glBlendColor,
          emscripten_glBlendEquation: _emscripten_glBlendEquation,
          emscripten_glBlendEquationSeparate: _emscripten_glBlendEquationSeparate,
          emscripten_glBlendFunc: _emscripten_glBlendFunc,
          emscripten_glBlendFuncSeparate: _emscripten_glBlendFuncSeparate,
          emscripten_glBufferData: _emscripten_glBufferData,
          emscripten_glBufferSubData: _emscripten_glBufferSubData,
          emscripten_glCheckFramebufferStatus: _emscripten_glCheckFramebufferStatus,
          emscripten_glClear: _emscripten_glClear,
          emscripten_glClearColor: _emscripten_glClearColor,
          emscripten_glClearDepth: _emscripten_glClearDepth,
          emscripten_glClearDepthf: _emscripten_glClearDepthf,
          emscripten_glClearStencil: _emscripten_glClearStencil,
          emscripten_glColorMask: _emscripten_glColorMask,
          emscripten_glCompileShader: _emscripten_glCompileShader,
          emscripten_glCompressedTexImage2D: _emscripten_glCompressedTexImage2D,
          emscripten_glCompressedTexSubImage2D: _emscripten_glCompressedTexSubImage2D,
          emscripten_glCopyTexImage2D: _emscripten_glCopyTexImage2D,
          emscripten_glCopyTexSubImage2D: _emscripten_glCopyTexSubImage2D,
          emscripten_glCreateProgram: _emscripten_glCreateProgram,
          emscripten_glCreateShader: _emscripten_glCreateShader,
          emscripten_glCullFace: _emscripten_glCullFace,
          emscripten_glDeleteBuffers: _emscripten_glDeleteBuffers,
          emscripten_glDeleteFramebuffers: _emscripten_glDeleteFramebuffers,
          emscripten_glDeleteProgram: _emscripten_glDeleteProgram,
          emscripten_glDeleteQueriesEXT: _emscripten_glDeleteQueriesEXT,
          emscripten_glDeleteRenderbuffers: _emscripten_glDeleteRenderbuffers,
          emscripten_glDeleteShader: _emscripten_glDeleteShader,
          emscripten_glDeleteTextures: _emscripten_glDeleteTextures,
          emscripten_glDeleteVertexArrays: _emscripten_glDeleteVertexArrays,
          emscripten_glDeleteVertexArraysOES: _emscripten_glDeleteVertexArraysOES,
          emscripten_glDepthFunc: _emscripten_glDepthFunc,
          emscripten_glDepthMask: _emscripten_glDepthMask,
          emscripten_glDepthRange: _emscripten_glDepthRange,
          emscripten_glDepthRangef: _emscripten_glDepthRangef,
          emscripten_glDetachShader: _emscripten_glDetachShader,
          emscripten_glDisable: _emscripten_glDisable,
          emscripten_glDisableVertexAttribArray: _emscripten_glDisableVertexAttribArray,
          emscripten_glDrawArrays: _emscripten_glDrawArrays,
          emscripten_glDrawArraysInstanced: _emscripten_glDrawArraysInstanced,
          emscripten_glDrawArraysInstancedANGLE: _emscripten_glDrawArraysInstancedANGLE,
          emscripten_glDrawArraysInstancedARB: _emscripten_glDrawArraysInstancedARB,
          emscripten_glDrawArraysInstancedEXT: _emscripten_glDrawArraysInstancedEXT,
          emscripten_glDrawArraysInstancedNV: _emscripten_glDrawArraysInstancedNV,
          emscripten_glDrawBuffers: _emscripten_glDrawBuffers,
          emscripten_glDrawBuffersEXT: _emscripten_glDrawBuffersEXT,
          emscripten_glDrawBuffersWEBGL: _emscripten_glDrawBuffersWEBGL,
          emscripten_glDrawElements: _emscripten_glDrawElements,
          emscripten_glDrawElementsInstanced: _emscripten_glDrawElementsInstanced,
          emscripten_glDrawElementsInstancedANGLE: _emscripten_glDrawElementsInstancedANGLE,
          emscripten_glDrawElementsInstancedARB: _emscripten_glDrawElementsInstancedARB,
          emscripten_glDrawElementsInstancedEXT: _emscripten_glDrawElementsInstancedEXT,
          emscripten_glDrawElementsInstancedNV: _emscripten_glDrawElementsInstancedNV,
          emscripten_glEnable: _emscripten_glEnable,
          emscripten_glEnableVertexAttribArray: _emscripten_glEnableVertexAttribArray,
          emscripten_glEndQueryEXT: _emscripten_glEndQueryEXT,
          emscripten_glFinish: _emscripten_glFinish,
          emscripten_glFlush: _emscripten_glFlush,
          emscripten_glFramebufferRenderbuffer: _emscripten_glFramebufferRenderbuffer,
          emscripten_glFramebufferTexture2D: _emscripten_glFramebufferTexture2D,
          emscripten_glFrontFace: _emscripten_glFrontFace,
          emscripten_glGenBuffers: _emscripten_glGenBuffers,
          emscripten_glGenFramebuffers: _emscripten_glGenFramebuffers,
          emscripten_glGenQueriesEXT: _emscripten_glGenQueriesEXT,
          emscripten_glGenRenderbuffers: _emscripten_glGenRenderbuffers,
          emscripten_glGenTextures: _emscripten_glGenTextures,
          emscripten_glGenVertexArrays: _emscripten_glGenVertexArrays,
          emscripten_glGenVertexArraysOES: _emscripten_glGenVertexArraysOES,
          emscripten_glGenerateMipmap: _emscripten_glGenerateMipmap,
          emscripten_glGetActiveAttrib: _emscripten_glGetActiveAttrib,
          emscripten_glGetActiveUniform: _emscripten_glGetActiveUniform,
          emscripten_glGetAttachedShaders: _emscripten_glGetAttachedShaders,
          emscripten_glGetAttribLocation: _emscripten_glGetAttribLocation,
          emscripten_glGetBooleanv: _emscripten_glGetBooleanv,
          emscripten_glGetBufferParameteriv: _emscripten_glGetBufferParameteriv,
          emscripten_glGetError: _emscripten_glGetError,
          emscripten_glGetFloatv: _emscripten_glGetFloatv,
          emscripten_glGetFramebufferAttachmentParameteriv: _emscripten_glGetFramebufferAttachmentParameteriv,
          emscripten_glGetIntegerv: _emscripten_glGetIntegerv,
          emscripten_glGetProgramInfoLog: _emscripten_glGetProgramInfoLog,
          emscripten_glGetProgramiv: _emscripten_glGetProgramiv,
          emscripten_glGetQueryObjecti64vEXT: _emscripten_glGetQueryObjecti64vEXT,
          emscripten_glGetQueryObjectivEXT: _emscripten_glGetQueryObjectivEXT,
          emscripten_glGetQueryObjectui64vEXT: _emscripten_glGetQueryObjectui64vEXT,
          emscripten_glGetQueryObjectuivEXT: _emscripten_glGetQueryObjectuivEXT,
          emscripten_glGetQueryivEXT: _emscripten_glGetQueryivEXT,
          emscripten_glGetRenderbufferParameteriv: _emscripten_glGetRenderbufferParameteriv,
          emscripten_glGetShaderInfoLog: _emscripten_glGetShaderInfoLog,
          emscripten_glGetShaderPrecisionFormat: _emscripten_glGetShaderPrecisionFormat,
          emscripten_glGetShaderSource: _emscripten_glGetShaderSource,
          emscripten_glGetShaderiv: _emscripten_glGetShaderiv,
          emscripten_glGetString: _emscripten_glGetString,
          emscripten_glGetTexParameterfv: _emscripten_glGetTexParameterfv,
          emscripten_glGetTexParameteriv: _emscripten_glGetTexParameteriv,
          emscripten_glGetUniformLocation: _emscripten_glGetUniformLocation,
          emscripten_glGetUniformfv: _emscripten_glGetUniformfv,
          emscripten_glGetUniformiv: _emscripten_glGetUniformiv,
          emscripten_glGetVertexAttribPointerv: _emscripten_glGetVertexAttribPointerv,
          emscripten_glGetVertexAttribfv: _emscripten_glGetVertexAttribfv,
          emscripten_glGetVertexAttribiv: _emscripten_glGetVertexAttribiv,
          emscripten_glHint: _emscripten_glHint,
          emscripten_glIsBuffer: _emscripten_glIsBuffer,
          emscripten_glIsEnabled: _emscripten_glIsEnabled,
          emscripten_glIsFramebuffer: _emscripten_glIsFramebuffer,
          emscripten_glIsProgram: _emscripten_glIsProgram,
          emscripten_glIsQueryEXT: _emscripten_glIsQueryEXT,
          emscripten_glIsRenderbuffer: _emscripten_glIsRenderbuffer,
          emscripten_glIsShader: _emscripten_glIsShader,
          emscripten_glIsTexture: _emscripten_glIsTexture,
          emscripten_glIsVertexArray: _emscripten_glIsVertexArray,
          emscripten_glIsVertexArrayOES: _emscripten_glIsVertexArrayOES,
          emscripten_glLineWidth: _emscripten_glLineWidth,
          emscripten_glLinkProgram: _emscripten_glLinkProgram,
          emscripten_glLoadIdentity: _emscripten_glLoadIdentity,
          emscripten_glMatrixMode: _emscripten_glMatrixMode,
          emscripten_glMultiDrawArrays: _emscripten_glMultiDrawArrays,
          emscripten_glMultiDrawArraysANGLE: _emscripten_glMultiDrawArraysANGLE,
          emscripten_glMultiDrawArraysInstancedANGLE: _emscripten_glMultiDrawArraysInstancedANGLE,
          emscripten_glMultiDrawArraysInstancedWEBGL: _emscripten_glMultiDrawArraysInstancedWEBGL,
          emscripten_glMultiDrawArraysWEBGL: _emscripten_glMultiDrawArraysWEBGL,
          emscripten_glMultiDrawElements: _emscripten_glMultiDrawElements,
          emscripten_glMultiDrawElementsANGLE: _emscripten_glMultiDrawElementsANGLE,
          emscripten_glMultiDrawElementsInstancedANGLE: _emscripten_glMultiDrawElementsInstancedANGLE,
          emscripten_glMultiDrawElementsInstancedWEBGL: _emscripten_glMultiDrawElementsInstancedWEBGL,
          emscripten_glMultiDrawElementsWEBGL: _emscripten_glMultiDrawElementsWEBGL,
          emscripten_glPixelStorei: _emscripten_glPixelStorei,
          emscripten_glPolygonOffset: _emscripten_glPolygonOffset,
          emscripten_glQueryCounterEXT: _emscripten_glQueryCounterEXT,
          emscripten_glReadPixels: _emscripten_glReadPixels,
          emscripten_glReleaseShaderCompiler: _emscripten_glReleaseShaderCompiler,
          emscripten_glRenderbufferStorage: _emscripten_glRenderbufferStorage,
          emscripten_glSampleCoverage: _emscripten_glSampleCoverage,
          emscripten_glScissor: _emscripten_glScissor,
          emscripten_glShaderBinary: _emscripten_glShaderBinary,
          emscripten_glShaderSource: _emscripten_glShaderSource,
          emscripten_glStencilFunc: _emscripten_glStencilFunc,
          emscripten_glStencilFuncSeparate: _emscripten_glStencilFuncSeparate,
          emscripten_glStencilMask: _emscripten_glStencilMask,
          emscripten_glStencilMaskSeparate: _emscripten_glStencilMaskSeparate,
          emscripten_glStencilOp: _emscripten_glStencilOp,
          emscripten_glStencilOpSeparate: _emscripten_glStencilOpSeparate,
          emscripten_glTexImage2D: _emscripten_glTexImage2D,
          emscripten_glTexParameterf: _emscripten_glTexParameterf,
          emscripten_glTexParameterfv: _emscripten_glTexParameterfv,
          emscripten_glTexParameteri: _emscripten_glTexParameteri,
          emscripten_glTexParameteriv: _emscripten_glTexParameteriv,
          emscripten_glTexSubImage2D: _emscripten_glTexSubImage2D,
          emscripten_glUniform1f: _emscripten_glUniform1f,
          emscripten_glUniform1fv: _emscripten_glUniform1fv,
          emscripten_glUniform1i: _emscripten_glUniform1i,
          emscripten_glUniform1iv: _emscripten_glUniform1iv,
          emscripten_glUniform2f: _emscripten_glUniform2f,
          emscripten_glUniform2fv: _emscripten_glUniform2fv,
          emscripten_glUniform2i: _emscripten_glUniform2i,
          emscripten_glUniform2iv: _emscripten_glUniform2iv,
          emscripten_glUniform3f: _emscripten_glUniform3f,
          emscripten_glUniform3fv: _emscripten_glUniform3fv,
          emscripten_glUniform3i: _emscripten_glUniform3i,
          emscripten_glUniform3iv: _emscripten_glUniform3iv,
          emscripten_glUniform4f: _emscripten_glUniform4f,
          emscripten_glUniform4fv: _emscripten_glUniform4fv,
          emscripten_glUniform4i: _emscripten_glUniform4i,
          emscripten_glUniform4iv: _emscripten_glUniform4iv,
          emscripten_glUniformMatrix2fv: _emscripten_glUniformMatrix2fv,
          emscripten_glUniformMatrix3fv: _emscripten_glUniformMatrix3fv,
          emscripten_glUniformMatrix4fv: _emscripten_glUniformMatrix4fv,
          emscripten_glUseProgram: _emscripten_glUseProgram,
          emscripten_glValidateProgram: _emscripten_glValidateProgram,
          emscripten_glVertexAttrib1f: _emscripten_glVertexAttrib1f,
          emscripten_glVertexAttrib1fv: _emscripten_glVertexAttrib1fv,
          emscripten_glVertexAttrib2f: _emscripten_glVertexAttrib2f,
          emscripten_glVertexAttrib2fv: _emscripten_glVertexAttrib2fv,
          emscripten_glVertexAttrib3f: _emscripten_glVertexAttrib3f,
          emscripten_glVertexAttrib3fv: _emscripten_glVertexAttrib3fv,
          emscripten_glVertexAttrib4f: _emscripten_glVertexAttrib4f,
          emscripten_glVertexAttrib4fv: _emscripten_glVertexAttrib4fv,
          emscripten_glVertexAttribDivisor: _emscripten_glVertexAttribDivisor,
          emscripten_glVertexAttribDivisorANGLE: _emscripten_glVertexAttribDivisorANGLE,
          emscripten_glVertexAttribDivisorARB: _emscripten_glVertexAttribDivisorARB,
          emscripten_glVertexAttribDivisorEXT: _emscripten_glVertexAttribDivisorEXT,
          emscripten_glVertexAttribDivisorNV: _emscripten_glVertexAttribDivisorNV,
          emscripten_glVertexAttribPointer: _emscripten_glVertexAttribPointer,
          emscripten_glVertexPointer: _emscripten_glVertexPointer,
          emscripten_glViewport: _emscripten_glViewport,
          emscripten_has_asyncify: _emscripten_has_asyncify,
          emscripten_hide_mouse: _emscripten_hide_mouse,
          emscripten_html5_remove_all_event_listeners: _emscripten_html5_remove_all_event_listeners,
          emscripten_idb_async_clear: _emscripten_idb_async_clear,
          emscripten_idb_async_delete: _emscripten_idb_async_delete,
          emscripten_idb_async_exists: _emscripten_idb_async_exists,
          emscripten_idb_async_load: _emscripten_idb_async_load,
          emscripten_idb_async_store: _emscripten_idb_async_store,
          emscripten_idb_clear: _emscripten_idb_clear,
          emscripten_idb_delete: _emscripten_idb_delete,
          emscripten_idb_exists: _emscripten_idb_exists,
          emscripten_idb_load: _emscripten_idb_load,
          emscripten_idb_store: _emscripten_idb_store,
          emscripten_is_main_browser_thread: _emscripten_is_main_browser_thread,
          emscripten_is_webgl_context_lost: _emscripten_is_webgl_context_lost,
          emscripten_lock_orientation: _emscripten_lock_orientation,
          emscripten_log: _emscripten_log,
          emscripten_math_acos: _emscripten_math_acos,
          emscripten_math_acosh: _emscripten_math_acosh,
          emscripten_math_asin: _emscripten_math_asin,
          emscripten_math_asinh: _emscripten_math_asinh,
          emscripten_math_atan: _emscripten_math_atan,
          emscripten_math_atan2: _emscripten_math_atan2,
          emscripten_math_atanh: _emscripten_math_atanh,
          emscripten_math_cbrt: _emscripten_math_cbrt,
          emscripten_math_cos: _emscripten_math_cos,
          emscripten_math_cosh: _emscripten_math_cosh,
          emscripten_math_exp: _emscripten_math_exp,
          emscripten_math_expm1: _emscripten_math_expm1,
          emscripten_math_fmod: _emscripten_math_fmod,
          emscripten_math_hypot: _emscripten_math_hypot,
          emscripten_math_log: _emscripten_math_log,
          emscripten_math_log10: _emscripten_math_log10,
          emscripten_math_log1p: _emscripten_math_log1p,
          emscripten_math_log2: _emscripten_math_log2,
          emscripten_math_pow: _emscripten_math_pow,
          emscripten_math_random: _emscripten_math_random,
          emscripten_math_round: _emscripten_math_round,
          emscripten_math_sign: _emscripten_math_sign,
          emscripten_math_sin: _emscripten_math_sin,
          emscripten_math_sinh: _emscripten_math_sinh,
          emscripten_math_sqrt: _emscripten_math_sqrt,
          emscripten_math_tan: _emscripten_math_tan,
          emscripten_math_tanh: _emscripten_math_tanh,
          emscripten_memcpy_js: _emscripten_memcpy_js,
          emscripten_notify_memory_growth: _emscripten_notify_memory_growth,
          emscripten_out: _emscripten_out,
          emscripten_outn: _emscripten_outn,
          emscripten_pause_main_loop: _emscripten_pause_main_loop,
          emscripten_pc_get_column: _emscripten_pc_get_column,
          emscripten_pc_get_file: _emscripten_pc_get_file,
          emscripten_pc_get_function: _emscripten_pc_get_function,
          emscripten_pc_get_line: _emscripten_pc_get_line,
          emscripten_performance_now: _emscripten_performance_now,
          emscripten_print_double: _emscripten_print_double,
          emscripten_promise_all: _emscripten_promise_all,
          emscripten_promise_all_settled: _emscripten_promise_all_settled,
          emscripten_promise_any: _emscripten_promise_any,
          emscripten_promise_await: _emscripten_promise_await,
          emscripten_promise_create: _emscripten_promise_create,
          emscripten_promise_destroy: _emscripten_promise_destroy,
          emscripten_promise_race: _emscripten_promise_race,
          emscripten_promise_resolve: _emscripten_promise_resolve,
          emscripten_promise_then: _emscripten_promise_then,
          emscripten_random: _emscripten_random,
          emscripten_request_animation_frame: _emscripten_request_animation_frame,
          emscripten_request_animation_frame_loop: _emscripten_request_animation_frame_loop,
          emscripten_request_fullscreen: _emscripten_request_fullscreen,
          emscripten_request_fullscreen_strategy: _emscripten_request_fullscreen_strategy,
          emscripten_request_pointerlock: _emscripten_request_pointerlock,
          emscripten_resize_heap: _emscripten_resize_heap,
          emscripten_resume_main_loop: _emscripten_resume_main_loop,
          emscripten_return_address: _emscripten_return_address,
          emscripten_run_preload_plugins: _emscripten_run_preload_plugins,
          emscripten_run_preload_plugins_data: _emscripten_run_preload_plugins_data,
          emscripten_run_script: _emscripten_run_script,
          emscripten_run_script_int: _emscripten_run_script_int,
          emscripten_run_script_string: _emscripten_run_script_string,
          emscripten_runtime_keepalive_check: _emscripten_runtime_keepalive_check,
          emscripten_runtime_keepalive_pop: _emscripten_runtime_keepalive_pop,
          emscripten_runtime_keepalive_push: _emscripten_runtime_keepalive_push,
          emscripten_sample_gamepad_data: _emscripten_sample_gamepad_data,
          emscripten_scan_registers: _emscripten_scan_registers,
          emscripten_set_batterychargingchange_callback_on_thread: _emscripten_set_batterychargingchange_callback_on_thread,
          emscripten_set_batterylevelchange_callback_on_thread: _emscripten_set_batterylevelchange_callback_on_thread,
          emscripten_set_beforeunload_callback_on_thread: _emscripten_set_beforeunload_callback_on_thread,
          emscripten_set_blur_callback_on_thread: _emscripten_set_blur_callback_on_thread,
          emscripten_set_canvas_element_size: _emscripten_set_canvas_element_size,
          emscripten_set_canvas_size: _emscripten_set_canvas_size,
          emscripten_set_click_callback_on_thread: _emscripten_set_click_callback_on_thread,
          emscripten_set_dblclick_callback_on_thread: _emscripten_set_dblclick_callback_on_thread,
          emscripten_set_devicemotion_callback_on_thread: _emscripten_set_devicemotion_callback_on_thread,
          emscripten_set_deviceorientation_callback_on_thread: _emscripten_set_deviceorientation_callback_on_thread,
          emscripten_set_element_css_size: _emscripten_set_element_css_size,
          emscripten_set_focus_callback_on_thread: _emscripten_set_focus_callback_on_thread,
          emscripten_set_focusin_callback_on_thread: _emscripten_set_focusin_callback_on_thread,
          emscripten_set_focusout_callback_on_thread: _emscripten_set_focusout_callback_on_thread,
          emscripten_set_fullscreenchange_callback_on_thread: _emscripten_set_fullscreenchange_callback_on_thread,
          emscripten_set_gamepadconnected_callback_on_thread: _emscripten_set_gamepadconnected_callback_on_thread,
          emscripten_set_gamepaddisconnected_callback_on_thread: _emscripten_set_gamepaddisconnected_callback_on_thread,
          emscripten_set_immediate: _emscripten_set_immediate,
          emscripten_set_immediate_loop: _emscripten_set_immediate_loop,
          emscripten_set_interval: _emscripten_set_interval,
          emscripten_set_keydown_callback_on_thread: _emscripten_set_keydown_callback_on_thread,
          emscripten_set_keypress_callback_on_thread: _emscripten_set_keypress_callback_on_thread,
          emscripten_set_keyup_callback_on_thread: _emscripten_set_keyup_callback_on_thread,
          emscripten_set_main_loop: _emscripten_set_main_loop,
          emscripten_set_main_loop_arg: _emscripten_set_main_loop_arg,
          emscripten_set_main_loop_expected_blockers: _emscripten_set_main_loop_expected_blockers,
          emscripten_set_main_loop_timing: _emscripten_set_main_loop_timing,
          emscripten_set_mousedown_callback_on_thread: _emscripten_set_mousedown_callback_on_thread,
          emscripten_set_mouseenter_callback_on_thread: _emscripten_set_mouseenter_callback_on_thread,
          emscripten_set_mouseleave_callback_on_thread: _emscripten_set_mouseleave_callback_on_thread,
          emscripten_set_mousemove_callback_on_thread: _emscripten_set_mousemove_callback_on_thread,
          emscripten_set_mouseout_callback_on_thread: _emscripten_set_mouseout_callback_on_thread,
          emscripten_set_mouseover_callback_on_thread: _emscripten_set_mouseover_callback_on_thread,
          emscripten_set_mouseup_callback_on_thread: _emscripten_set_mouseup_callback_on_thread,
          emscripten_set_orientationchange_callback_on_thread: _emscripten_set_orientationchange_callback_on_thread,
          emscripten_set_pointerlockchange_callback_on_thread: _emscripten_set_pointerlockchange_callback_on_thread,
          emscripten_set_pointerlockerror_callback_on_thread: _emscripten_set_pointerlockerror_callback_on_thread,
          emscripten_set_resize_callback_on_thread: _emscripten_set_resize_callback_on_thread,
          emscripten_set_scroll_callback_on_thread: _emscripten_set_scroll_callback_on_thread,
          emscripten_set_socket_close_callback: _emscripten_set_socket_close_callback,
          emscripten_set_socket_connection_callback: _emscripten_set_socket_connection_callback,
          emscripten_set_socket_error_callback: _emscripten_set_socket_error_callback,
          emscripten_set_socket_listen_callback: _emscripten_set_socket_listen_callback,
          emscripten_set_socket_message_callback: _emscripten_set_socket_message_callback,
          emscripten_set_socket_open_callback: _emscripten_set_socket_open_callback,
          emscripten_set_timeout: _emscripten_set_timeout,
          emscripten_set_timeout_loop: _emscripten_set_timeout_loop,
          emscripten_set_touchcancel_callback_on_thread: _emscripten_set_touchcancel_callback_on_thread,
          emscripten_set_touchend_callback_on_thread: _emscripten_set_touchend_callback_on_thread,
          emscripten_set_touchmove_callback_on_thread: _emscripten_set_touchmove_callback_on_thread,
          emscripten_set_touchstart_callback_on_thread: _emscripten_set_touchstart_callback_on_thread,
          emscripten_set_visibilitychange_callback_on_thread: _emscripten_set_visibilitychange_callback_on_thread,
          emscripten_set_webglcontextlost_callback_on_thread: _emscripten_set_webglcontextlost_callback_on_thread,
          emscripten_set_webglcontextrestored_callback_on_thread: _emscripten_set_webglcontextrestored_callback_on_thread,
          emscripten_set_wheel_callback_on_thread: _emscripten_set_wheel_callback_on_thread,
          emscripten_set_window_title: _emscripten_set_window_title,
          emscripten_sleep: _emscripten_sleep,
          emscripten_stack_snapshot: _emscripten_stack_snapshot,
          emscripten_stack_unwind_buffer: _emscripten_stack_unwind_buffer,
          emscripten_supports_offscreencanvas: _emscripten_supports_offscreencanvas,
          emscripten_throw_number: _emscripten_throw_number,
          emscripten_throw_string: _emscripten_throw_string,
          emscripten_unlock_orientation: _emscripten_unlock_orientation,
          emscripten_unwind_to_js_event_loop: _emscripten_unwind_to_js_event_loop,
          emscripten_vibrate: _emscripten_vibrate,
          emscripten_vibrate_pattern: _emscripten_vibrate_pattern,
          emscripten_webgl_commit_frame: _emscripten_webgl_commit_frame,
          emscripten_webgl_create_context: _emscripten_webgl_create_context,
          emscripten_webgl_destroy_context: _emscripten_webgl_destroy_context,
          emscripten_webgl_do_commit_frame: _emscripten_webgl_do_commit_frame,
          emscripten_webgl_do_create_context: _emscripten_webgl_do_create_context,
          emscripten_webgl_do_get_current_context: _emscripten_webgl_do_get_current_context,
          emscripten_webgl_enable_ANGLE_instanced_arrays: _emscripten_webgl_enable_ANGLE_instanced_arrays,
          emscripten_webgl_enable_OES_vertex_array_object: _emscripten_webgl_enable_OES_vertex_array_object,
          emscripten_webgl_enable_WEBGL_draw_buffers: _emscripten_webgl_enable_WEBGL_draw_buffers,
          emscripten_webgl_enable_WEBGL_multi_draw: _emscripten_webgl_enable_WEBGL_multi_draw,
          emscripten_webgl_enable_extension: _emscripten_webgl_enable_extension,
          emscripten_webgl_get_context_attributes: _emscripten_webgl_get_context_attributes,
          emscripten_webgl_get_current_context: _emscripten_webgl_get_current_context,
          emscripten_webgl_get_drawing_buffer_size: _emscripten_webgl_get_drawing_buffer_size,
          emscripten_webgl_get_parameter_d: _emscripten_webgl_get_parameter_d,
          emscripten_webgl_get_parameter_i64v: _emscripten_webgl_get_parameter_i64v,
          emscripten_webgl_get_parameter_o: _emscripten_webgl_get_parameter_o,
          emscripten_webgl_get_parameter_utf8: _emscripten_webgl_get_parameter_utf8,
          emscripten_webgl_get_parameter_v: _emscripten_webgl_get_parameter_v,
          emscripten_webgl_get_program_info_log_utf8: _emscripten_webgl_get_program_info_log_utf8,
          emscripten_webgl_get_program_parameter_d: _emscripten_webgl_get_program_parameter_d,
          emscripten_webgl_get_shader_info_log_utf8: _emscripten_webgl_get_shader_info_log_utf8,
          emscripten_webgl_get_shader_parameter_d: _emscripten_webgl_get_shader_parameter_d,
          emscripten_webgl_get_shader_source_utf8: _emscripten_webgl_get_shader_source_utf8,
          emscripten_webgl_get_supported_extensions: _emscripten_webgl_get_supported_extensions,
          emscripten_webgl_get_uniform_d: _emscripten_webgl_get_uniform_d,
          emscripten_webgl_get_uniform_v: _emscripten_webgl_get_uniform_v,
          emscripten_webgl_get_vertex_attrib_d: _emscripten_webgl_get_vertex_attrib_d,
          emscripten_webgl_get_vertex_attrib_o: _emscripten_webgl_get_vertex_attrib_o,
          emscripten_webgl_get_vertex_attrib_v: _emscripten_webgl_get_vertex_attrib_v,
          emscripten_webgl_init_context_attributes: _emscripten_webgl_init_context_attributes,
          emscripten_webgl_make_context_current: _emscripten_webgl_make_context_current,
          emscripten_wget_data: _emscripten_wget_data,
          endprotoent: _endprotoent,
          environ_get: _environ_get,
          environ_sizes_get: _environ_sizes_get,
          exit: _exit,
          fd_close: _fd_close,
          fd_fdstat_get: _fd_fdstat_get,
          fd_pread: _fd_pread,
          fd_pwrite: _fd_pwrite,
          fd_read: _fd_read,
          fd_seek: _fd_seek,
          fd_sync: _fd_sync,
          fd_write: _fd_write,
          filledEllipseColor: _filledEllipseColor,
          filledEllipseRGBA: _filledEllipseRGBA,
          getaddrinfo: _getaddrinfo,
          getentropy: _getentropy,
          getnameinfo: _getnameinfo,
          getprotobyname: _getprotobyname,
          getprotobynumber: _getprotobynumber,
          getprotoent: _getprotoent,
          glActiveTexture: _glActiveTexture,
          glAttachShader: _glAttachShader,
          glBegin: _glBegin,
          glBeginQueryEXT: _glBeginQueryEXT,
          glBindAttribLocation: _glBindAttribLocation,
          glBindBuffer: _glBindBuffer,
          glBindFramebuffer: _glBindFramebuffer,
          glBindRenderbuffer: _glBindRenderbuffer,
          glBindTexture: _glBindTexture,
          glBindVertexArray: _glBindVertexArray,
          glBindVertexArrayOES: _glBindVertexArrayOES,
          glBlendColor: _glBlendColor,
          glBlendEquation: _glBlendEquation,
          glBlendEquationSeparate: _glBlendEquationSeparate,
          glBlendFunc: _glBlendFunc,
          glBlendFuncSeparate: _glBlendFuncSeparate,
          glBufferData: _glBufferData,
          glBufferSubData: _glBufferSubData,
          glCheckFramebufferStatus: _glCheckFramebufferStatus,
          glClear: _glClear,
          glClearColor: _glClearColor,
          glClearDepth: _glClearDepth,
          glClearDepthf: _glClearDepthf,
          glClearStencil: _glClearStencil,
          glColorMask: _glColorMask,
          glCompileShader: _glCompileShader,
          glCompressedTexImage2D: _glCompressedTexImage2D,
          glCompressedTexSubImage2D: _glCompressedTexSubImage2D,
          glCopyTexImage2D: _glCopyTexImage2D,
          glCopyTexSubImage2D: _glCopyTexSubImage2D,
          glCreateProgram: _glCreateProgram,
          glCreateShader: _glCreateShader,
          glCullFace: _glCullFace,
          glDeleteBuffers: _glDeleteBuffers,
          glDeleteFramebuffers: _glDeleteFramebuffers,
          glDeleteProgram: _glDeleteProgram,
          glDeleteQueriesEXT: _glDeleteQueriesEXT,
          glDeleteRenderbuffers: _glDeleteRenderbuffers,
          glDeleteShader: _glDeleteShader,
          glDeleteTextures: _glDeleteTextures,
          glDeleteVertexArrays: _glDeleteVertexArrays,
          glDeleteVertexArraysOES: _glDeleteVertexArraysOES,
          glDepthFunc: _glDepthFunc,
          glDepthMask: _glDepthMask,
          glDepthRange: _glDepthRange,
          glDepthRangef: _glDepthRangef,
          glDetachShader: _glDetachShader,
          glDisable: _glDisable,
          glDisableVertexAttribArray: _glDisableVertexAttribArray,
          glDrawArrays: _glDrawArrays,
          glDrawArraysInstanced: _glDrawArraysInstanced,
          glDrawArraysInstancedANGLE: _glDrawArraysInstancedANGLE,
          glDrawArraysInstancedARB: _glDrawArraysInstancedARB,
          glDrawArraysInstancedEXT: _glDrawArraysInstancedEXT,
          glDrawArraysInstancedNV: _glDrawArraysInstancedNV,
          glDrawBuffers: _glDrawBuffers,
          glDrawBuffersEXT: _glDrawBuffersEXT,
          glDrawBuffersWEBGL: _glDrawBuffersWEBGL,
          glDrawElements: _glDrawElements,
          glDrawElementsInstanced: _glDrawElementsInstanced,
          glDrawElementsInstancedANGLE: _glDrawElementsInstancedANGLE,
          glDrawElementsInstancedARB: _glDrawElementsInstancedARB,
          glDrawElementsInstancedEXT: _glDrawElementsInstancedEXT,
          glDrawElementsInstancedNV: _glDrawElementsInstancedNV,
          glEnable: _glEnable,
          glEnableVertexAttribArray: _glEnableVertexAttribArray,
          glEndQueryEXT: _glEndQueryEXT,
          glFinish: _glFinish,
          glFlush: _glFlush,
          glFramebufferRenderbuffer: _glFramebufferRenderbuffer,
          glFramebufferTexture2D: _glFramebufferTexture2D,
          glFrontFace: _glFrontFace,
          glGenBuffers: _glGenBuffers,
          glGenFramebuffers: _glGenFramebuffers,
          glGenQueriesEXT: _glGenQueriesEXT,
          glGenRenderbuffers: _glGenRenderbuffers,
          glGenTextures: _glGenTextures,
          glGenVertexArrays: _glGenVertexArrays,
          glGenVertexArraysOES: _glGenVertexArraysOES,
          glGenerateMipmap: _glGenerateMipmap,
          glGetActiveAttrib: _glGetActiveAttrib,
          glGetActiveUniform: _glGetActiveUniform,
          glGetAttachedShaders: _glGetAttachedShaders,
          glGetAttribLocation: _glGetAttribLocation,
          glGetBooleanv: _glGetBooleanv,
          glGetBufferParameteriv: _glGetBufferParameteriv,
          glGetError: _glGetError,
          glGetFloatv: _glGetFloatv,
          glGetFramebufferAttachmentParameteriv: _glGetFramebufferAttachmentParameteriv,
          glGetIntegerv: _glGetIntegerv,
          glGetProgramInfoLog: _glGetProgramInfoLog,
          glGetProgramiv: _glGetProgramiv,
          glGetQueryObjecti64vEXT: _glGetQueryObjecti64vEXT,
          glGetQueryObjectivEXT: _glGetQueryObjectivEXT,
          glGetQueryObjectui64vEXT: _glGetQueryObjectui64vEXT,
          glGetQueryObjectuivEXT: _glGetQueryObjectuivEXT,
          glGetQueryivEXT: _glGetQueryivEXT,
          glGetRenderbufferParameteriv: _glGetRenderbufferParameteriv,
          glGetShaderInfoLog: _glGetShaderInfoLog,
          glGetShaderPrecisionFormat: _glGetShaderPrecisionFormat,
          glGetShaderSource: _glGetShaderSource,
          glGetShaderiv: _glGetShaderiv,
          glGetString: _glGetString,
          glGetTexParameterfv: _glGetTexParameterfv,
          glGetTexParameteriv: _glGetTexParameteriv,
          glGetUniformLocation: _glGetUniformLocation,
          glGetUniformfv: _glGetUniformfv,
          glGetUniformiv: _glGetUniformiv,
          glGetVertexAttribPointerv: _glGetVertexAttribPointerv,
          glGetVertexAttribfv: _glGetVertexAttribfv,
          glGetVertexAttribiv: _glGetVertexAttribiv,
          glHint: _glHint,
          glIsBuffer: _glIsBuffer,
          glIsEnabled: _glIsEnabled,
          glIsFramebuffer: _glIsFramebuffer,
          glIsProgram: _glIsProgram,
          glIsQueryEXT: _glIsQueryEXT,
          glIsRenderbuffer: _glIsRenderbuffer,
          glIsShader: _glIsShader,
          glIsTexture: _glIsTexture,
          glIsVertexArray: _glIsVertexArray,
          glIsVertexArrayOES: _glIsVertexArrayOES,
          glLineWidth: _glLineWidth,
          glLinkProgram: _glLinkProgram,
          glLoadIdentity: _glLoadIdentity,
          glMatrixMode: _glMatrixMode,
          glMultiDrawArrays: _glMultiDrawArrays,
          glMultiDrawArraysANGLE: _glMultiDrawArraysANGLE,
          glMultiDrawArraysInstancedANGLE: _glMultiDrawArraysInstancedANGLE,
          glMultiDrawArraysInstancedWEBGL: _glMultiDrawArraysInstancedWEBGL,
          glMultiDrawArraysWEBGL: _glMultiDrawArraysWEBGL,
          glMultiDrawElements: _glMultiDrawElements,
          glMultiDrawElementsANGLE: _glMultiDrawElementsANGLE,
          glMultiDrawElementsInstancedANGLE: _glMultiDrawElementsInstancedANGLE,
          glMultiDrawElementsInstancedWEBGL: _glMultiDrawElementsInstancedWEBGL,
          glMultiDrawElementsWEBGL: _glMultiDrawElementsWEBGL,
          glPixelStorei: _glPixelStorei,
          glPolygonOffset: _glPolygonOffset,
          glQueryCounterEXT: _glQueryCounterEXT,
          glReadPixels: _glReadPixels,
          glReleaseShaderCompiler: _glReleaseShaderCompiler,
          glRenderbufferStorage: _glRenderbufferStorage,
          glSampleCoverage: _glSampleCoverage,
          glScissor: _glScissor,
          glShaderBinary: _glShaderBinary,
          glShaderSource: _glShaderSource,
          glStencilFunc: _glStencilFunc,
          glStencilFuncSeparate: _glStencilFuncSeparate,
          glStencilMask: _glStencilMask,
          glStencilMaskSeparate: _glStencilMaskSeparate,
          glStencilOp: _glStencilOp,
          glStencilOpSeparate: _glStencilOpSeparate,
          glTexImage2D: _glTexImage2D,
          glTexParameterf: _glTexParameterf,
          glTexParameterfv: _glTexParameterfv,
          glTexParameteri: _glTexParameteri,
          glTexParameteriv: _glTexParameteriv,
          glTexSubImage2D: _glTexSubImage2D,
          glUniform1f: _glUniform1f,
          glUniform1fv: _glUniform1fv,
          glUniform1i: _glUniform1i,
          glUniform1iv: _glUniform1iv,
          glUniform2f: _glUniform2f,
          glUniform2fv: _glUniform2fv,
          glUniform2i: _glUniform2i,
          glUniform2iv: _glUniform2iv,
          glUniform3f: _glUniform3f,
          glUniform3fv: _glUniform3fv,
          glUniform3i: _glUniform3i,
          glUniform3iv: _glUniform3iv,
          glUniform4f: _glUniform4f,
          glUniform4fv: _glUniform4fv,
          glUniform4i: _glUniform4i,
          glUniform4iv: _glUniform4iv,
          glUniformMatrix2fv: _glUniformMatrix2fv,
          glUniformMatrix3fv: _glUniformMatrix3fv,
          glUniformMatrix4fv: _glUniformMatrix4fv,
          glUseProgram: _glUseProgram,
          glValidateProgram: _glValidateProgram,
          glVertexAttrib1f: _glVertexAttrib1f,
          glVertexAttrib1fv: _glVertexAttrib1fv,
          glVertexAttrib2f: _glVertexAttrib2f,
          glVertexAttrib2fv: _glVertexAttrib2fv,
          glVertexAttrib3f: _glVertexAttrib3f,
          glVertexAttrib3fv: _glVertexAttrib3fv,
          glVertexAttrib4f: _glVertexAttrib4f,
          glVertexAttrib4fv: _glVertexAttrib4fv,
          glVertexAttribDivisor: _glVertexAttribDivisor,
          glVertexAttribDivisorANGLE: _glVertexAttribDivisorANGLE,
          glVertexAttribDivisorARB: _glVertexAttribDivisorARB,
          glVertexAttribDivisorEXT: _glVertexAttribDivisorEXT,
          glVertexAttribDivisorNV: _glVertexAttribDivisorNV,
          glVertexAttribPointer: _glVertexAttribPointer,
          glVertexPointer: _glVertexPointer,
          glViewport: _glViewport,
          glewGetErrorString: _glewGetErrorString,
          glewGetExtension: _glewGetExtension,
          glewGetString: _glewGetString,
          glewInit: _glewInit,
          glewIsSupported: _glewIsSupported,
          glutCreateWindow: _glutCreateWindow,
          glutDestroyWindow: _glutDestroyWindow,
          glutDisplayFunc: _glutDisplayFunc,
          glutFullScreen: _glutFullScreen,
          glutGet: _glutGet,
          glutGetModifiers: _glutGetModifiers,
          glutIdleFunc: _glutIdleFunc,
          glutInit: _glutInit,
          glutInitDisplayMode: _glutInitDisplayMode,
          glutInitWindowPosition: _glutInitWindowPosition,
          glutInitWindowSize: _glutInitWindowSize,
          glutKeyboardFunc: _glutKeyboardFunc,
          glutKeyboardUpFunc: _glutKeyboardUpFunc,
          glutMainLoop: _glutMainLoop,
          glutMotionFunc: _glutMotionFunc,
          glutMouseFunc: _glutMouseFunc,
          glutPassiveMotionFunc: _glutPassiveMotionFunc,
          glutPositionWindow: _glutPositionWindow,
          glutPostRedisplay: _glutPostRedisplay,
          glutReshapeFunc: _glutReshapeFunc,
          glutReshapeWindow: _glutReshapeWindow,
          glutSetCursor: _glutSetCursor,
          glutSpecialFunc: _glutSpecialFunc,
          glutSpecialUpFunc: _glutSpecialUpFunc,
          glutSwapBuffers: _glutSwapBuffers,
          glutTimerFunc: _glutTimerFunc,
          invoke_di,
          invoke_dii,
          invoke_diii,
          invoke_diiii,
          invoke_diiiiid,
          invoke_diijii,
          invoke_fi,
          invoke_fiii,
          invoke_fiiii,
          invoke_fiijii,
          invoke_i,
          invoke_id,
          invoke_idd,
          invoke_idi,
          invoke_idii,
          invoke_idiii,
          invoke_idiiii,
          invoke_if,
          invoke_iff,
          invoke_ifi,
          invoke_ifii,
          invoke_ii,
          invoke_iid,
          invoke_iidi,
          invoke_iidii,
          invoke_iidiii,
          invoke_iidiiii,
          invoke_iif,
          invoke_iifii,
          invoke_iii,
          invoke_iiid,
          invoke_iiidj,
          invoke_iiii,
          invoke_iiiid,
          invoke_iiiidjj,
          invoke_iiiii,
          invoke_iiiiid,
          invoke_iiiiii,
          invoke_iiiiiid,
          invoke_iiiiiii,
          invoke_iiiiiiii,
          invoke_iiiiiiiii,
          invoke_iiiiiiiiii,
          invoke_iiiiiiiiiii,
          invoke_iiiiiiiiiiii,
          invoke_iiiiiiiiiiiii,
          invoke_iiiiiiiiiiiiiiii,
          invoke_iiiiiiiiiiiiiiiii,
          invoke_iiiiiiiiiiiiiiiiii,
          invoke_iiiiiiiiiiiij,
          invoke_iiiiiiiiiiji,
          invoke_iiiiiiiiijiiiiiii,
          invoke_iiiiiiiij,
          invoke_iiiiiiiiji,
          invoke_iiiiiiij,
          invoke_iiiiiiiji,
          invoke_iiiiiiijii,
          invoke_iiiiiiijj,
          invoke_iiiiiiijji,
          invoke_iiiiiij,
          invoke_iiiiiiji,
          invoke_iiiiiijjiijjji,
          invoke_iiiiij,
          invoke_iiiiiji,
          invoke_iiiiijii,
          invoke_iiiiijiii,
          invoke_iiiiijij,
          invoke_iiiiijj,
          invoke_iiiiijjj,
          invoke_iiiiijjji,
          invoke_iiiij,
          invoke_iiiiji,
          invoke_iiiijii,
          invoke_iiiijiii,
          invoke_iiiijj,
          invoke_iiiijji,
          invoke_iiiijjii,
          invoke_iiiijjiii,
          invoke_iiiijjj,
          invoke_iiiijjjj,
          invoke_iiij,
          invoke_iiiji,
          invoke_iiijii,
          invoke_iiijiii,
          invoke_iiijiiiii,
          invoke_iiijiiiij,
          invoke_iiijiiiijj,
          invoke_iiijiiij,
          invoke_iiijiiijj,
          invoke_iiijiij,
          invoke_iiijiiji,
          invoke_iiijiijj,
          invoke_iiijij,
          invoke_iiijj,
          invoke_iiijji,
          invoke_iiijjii,
          invoke_iiijjiii,
          invoke_iiijjiij,
          invoke_iiijjiiji,
          invoke_iiijjijjiii,
          invoke_iiijjj,
          invoke_iiijjji,
          invoke_iiijjjj,
          invoke_iij,
          invoke_iiji,
          invoke_iijii,
          invoke_iijiii,
          invoke_iijiiii,
          invoke_iijiiijj,
          invoke_iijiij,
          invoke_iijiijj,
          invoke_iijiji,
          invoke_iijj,
          invoke_iijji,
          invoke_iijjii,
          invoke_iijjiii,
          invoke_iijjijj,
          invoke_iijjj,
          invoke_iijjjii,
          invoke_ij,
          invoke_iji,
          invoke_ijii,
          invoke_ijji,
          invoke_ijjiii,
          invoke_ijjji,
          invoke_j,
          invoke_jd,
          invoke_jf,
          invoke_ji,
          invoke_jii,
          invoke_jiii,
          invoke_jiiii,
          invoke_jiiiii,
          invoke_jiiiiii,
          invoke_jiiiiiii,
          invoke_jiiiiijiiii,
          invoke_jiiiij,
          invoke_jiiiiji,
          invoke_jiiiijii,
          invoke_jiiiijiiii,
          invoke_jiiij,
          invoke_jiiiji,
          invoke_jiiijii,
          invoke_jiiijiii,
          invoke_jiiijiijiii,
          invoke_jiiijj,
          invoke_jiiijjj,
          invoke_jiij,
          invoke_jiiji,
          invoke_jiijii,
          invoke_jiijiii,
          invoke_jiijj,
          invoke_jiijjjii,
          invoke_jij,
          invoke_jiji,
          invoke_jijiii,
          invoke_jijiiii,
          invoke_jijij,
          invoke_jijj,
          invoke_jijji,
          invoke_jijjij,
          invoke_jijjjjii,
          invoke_jj,
          invoke_jji,
          invoke_jjiji,
          invoke_jjj,
          invoke_jjjd,
          invoke_jjjii,
          invoke_jjjji,
          invoke_v,
          invoke_vdii,
          invoke_vfii,
          invoke_vi,
          invoke_vid,
          invoke_viddddi,
          invoke_vidi,
          invoke_vidii,
          invoke_vif,
          invoke_vifi,
          invoke_vifii,
          invoke_vii,
          invoke_viid,
          invoke_viidii,
          invoke_viif,
          invoke_viii,
          invoke_viiidi,
          invoke_viiifi,
          invoke_viiii,
          invoke_viiiidiiii,
          invoke_viiiii,
          invoke_viiiiii,
          invoke_viiiiiidiii,
          invoke_viiiiiii,
          invoke_viiiiiiii,
          invoke_viiiiiiiii,
          invoke_viiiiiiiiii,
          invoke_viiiiiiiiiii,
          invoke_viiiiiiiiiiii,
          invoke_viiiiiiiiiiiiiii,
          invoke_viiiiiiijjjji,
          invoke_viiiiiij,
          invoke_viiiiiiji,
          invoke_viiiiiijii,
          invoke_viiiiij,
          invoke_viiiiiji,
          invoke_viiiiijii,
          invoke_viiiiijiii,
          invoke_viiiiijiiii,
          invoke_viiiiijiijii,
          invoke_viiiiijj,
          invoke_viiiiijjii,
          invoke_viiiiijjji,
          invoke_viiiij,
          invoke_viiiiji,
          invoke_viiiijii,
          invoke_viiiijiii,
          invoke_viiiijiiii,
          invoke_viiiijiiiii,
          invoke_viiiijiiiiiiii,
          invoke_viiiijijji,
          invoke_viiiijj,
          invoke_viiiijji,
          invoke_viiiijjij,
          invoke_viiij,
          invoke_viiiji,
          invoke_viiijii,
          invoke_viiijiii,
          invoke_viiijiiii,
          invoke_viiijiiiijjj,
          invoke_viiijiiijii,
          invoke_viiijij,
          invoke_viiijiji,
          invoke_viiijijij,
          invoke_viiijijj,
          invoke_viiijijjj,
          invoke_viiijj,
          invoke_viiijji,
          invoke_viiijjii,
          invoke_viiijjiii,
          invoke_viiijjiij,
          invoke_viiijjij,
          invoke_viiijjj,
          invoke_viiijjjj,
          invoke_viiijjjji,
          invoke_viij,
          invoke_viiji,
          invoke_viijii,
          invoke_viijiii,
          invoke_viijiiii,
          invoke_viijiiiii,
          invoke_viijiiiiii,
          invoke_viijiiiij,
          invoke_viijiiij,
          invoke_viijiiijj,
          invoke_viijiij,
          invoke_viijiiji,
          invoke_viijiijj,
          invoke_viijij,
          invoke_viijiji,
          invoke_viijijiiii,
          invoke_viijijiiiijjj,
          invoke_viijijj,
          invoke_viijj,
          invoke_viijji,
          invoke_viijjii,
          invoke_viijjj,
          invoke_viijjji,
          invoke_vij,
          invoke_viji,
          invoke_vijii,
          invoke_vijiii,
          invoke_vijiiii,
          invoke_vijiiiii,
          invoke_vijiiiiii,
          invoke_vijiiiiji,
          invoke_vijiiiji,
          invoke_vijiij,
          invoke_vijiji,
          invoke_vijijiiiijjj,
          invoke_vijijj,
          invoke_vijijjiij,
          invoke_vijijjji,
          invoke_vijj,
          invoke_vijji,
          invoke_vijjiii,
          invoke_vijjij,
          invoke_vijjj,
          invoke_vijjji,
          invoke_vijjjiiji,
          invoke_vijjjj,
          invoke_vj,
          invoke_vjii,
          invoke_vjiii,
          invoke_vjiiii,
          invoke_vjiiiji,
          invoke_vjjii,
          invoke_vjjijij,
          lineColor: _lineColor,
          lineRGBA: _lineRGBA,
          llvm_eh_typeid_for: _llvm_eh_typeid_for,
          memory: wasmMemory,
          pixelRGBA: _pixelRGBA,
          proc_exit: _proc_exit,
          pthread_kill: _pthread_kill,
          random_get: _random_get,
          rectangleColor: _rectangleColor,
          rectangleRGBA: _rectangleRGBA,
          rotozoomSurface: _rotozoomSurface,
          setNetworkCallback: _setNetworkCallback,
          setprotoent: _setprotoent,
          strftime: _strftime,
          strftime_l: _strftime_l,
          strptime: _strptime,
          strptime_l: _strptime_l,
          uuid_clear: _uuid_clear,
          uuid_compare: _uuid_compare,
          uuid_copy: _uuid_copy,
          uuid_generate: _uuid_generate,
          uuid_is_null: _uuid_is_null,
          uuid_parse: _uuid_parse,
          uuid_type: _uuid_type,
          uuid_unparse: _uuid_unparse,
          uuid_unparse_lower: _uuid_unparse_lower,
          uuid_unparse_upper: _uuid_unparse_upper,
          uuid_variant: _uuid_variant,
          zoomSurface: _zoomSurface
        };
        var wasmExports = createWasm();
        var _main = Module["_main"] = (a0, a1) => (_main = Module["_main"] = wasmExports["main"])(a0, a1);
        var _malloc = Module["_malloc"] = (a0) => (_malloc = Module["_malloc"] = wasmExports["malloc"])(a0);
        var _free = Module["_free"] = (a0) => (_free = Module["_free"] = wasmExports["free"])(a0);
        var _duckdb_web_fs_glob_add_path = Module["_duckdb_web_fs_glob_add_path"] = (a0) => (_duckdb_web_fs_glob_add_path = Module["_duckdb_web_fs_glob_add_path"] = wasmExports["duckdb_web_fs_glob_add_path"])(a0);
        var _duckdb_web_clear_response = Module["_duckdb_web_clear_response"] = () => (_duckdb_web_clear_response = Module["_duckdb_web_clear_response"] = wasmExports["duckdb_web_clear_response"])();
        var _duckdb_web_fail_with = Module["_duckdb_web_fail_with"] = (a0) => (_duckdb_web_fail_with = Module["_duckdb_web_fail_with"] = wasmExports["duckdb_web_fail_with"])(a0);
        var _duckdb_web_reset = Module["_duckdb_web_reset"] = (a0) => (_duckdb_web_reset = Module["_duckdb_web_reset"] = wasmExports["duckdb_web_reset"])(a0);
        var _duckdb_web_connect = Module["_duckdb_web_connect"] = () => (_duckdb_web_connect = Module["_duckdb_web_connect"] = wasmExports["duckdb_web_connect"])();
        var _duckdb_web_disconnect = Module["_duckdb_web_disconnect"] = (a0) => (_duckdb_web_disconnect = Module["_duckdb_web_disconnect"] = wasmExports["duckdb_web_disconnect"])(a0);
        var _duckdb_web_access_buffer = Module["_duckdb_web_access_buffer"] = (a0, a1) => (_duckdb_web_access_buffer = Module["_duckdb_web_access_buffer"] = wasmExports["duckdb_web_access_buffer"])(a0, a1);
        var _duckdb_web_flush_files = Module["_duckdb_web_flush_files"] = () => (_duckdb_web_flush_files = Module["_duckdb_web_flush_files"] = wasmExports["duckdb_web_flush_files"])();
        var _duckdb_web_flush_file = Module["_duckdb_web_flush_file"] = (a0) => (_duckdb_web_flush_file = Module["_duckdb_web_flush_file"] = wasmExports["duckdb_web_flush_file"])(a0);
        var _duckdb_web_open = Module["_duckdb_web_open"] = (a0, a1) => (_duckdb_web_open = Module["_duckdb_web_open"] = wasmExports["duckdb_web_open"])(a0, a1);
        var _duckdb_web_get_global_file_info = Module["_duckdb_web_get_global_file_info"] = (a0, a1) => (_duckdb_web_get_global_file_info = Module["_duckdb_web_get_global_file_info"] = wasmExports["duckdb_web_get_global_file_info"])(a0, a1);
        var _duckdb_web_collect_file_stats = Module["_duckdb_web_collect_file_stats"] = (a0, a1, a2) => (_duckdb_web_collect_file_stats = Module["_duckdb_web_collect_file_stats"] = wasmExports["duckdb_web_collect_file_stats"])(a0, a1, a2);
        var _duckdb_web_export_file_stats = Module["_duckdb_web_export_file_stats"] = (a0, a1) => (_duckdb_web_export_file_stats = Module["_duckdb_web_export_file_stats"] = wasmExports["duckdb_web_export_file_stats"])(a0, a1);
        var _duckdb_web_fs_drop_file = Module["_duckdb_web_fs_drop_file"] = (a0, a1) => (_duckdb_web_fs_drop_file = Module["_duckdb_web_fs_drop_file"] = wasmExports["duckdb_web_fs_drop_file"])(a0, a1);
        var _duckdb_web_fs_drop_files = Module["_duckdb_web_fs_drop_files"] = (a0) => (_duckdb_web_fs_drop_files = Module["_duckdb_web_fs_drop_files"] = wasmExports["duckdb_web_fs_drop_files"])(a0);
        var _duckdb_web_fs_glob_file_infos = Module["_duckdb_web_fs_glob_file_infos"] = (a0, a1) => (_duckdb_web_fs_glob_file_infos = Module["_duckdb_web_fs_glob_file_infos"] = wasmExports["duckdb_web_fs_glob_file_infos"])(a0, a1);
        var _duckdb_web_fs_get_file_info_by_id = Module["_duckdb_web_fs_get_file_info_by_id"] = (a0, a1, a2) => (_duckdb_web_fs_get_file_info_by_id = Module["_duckdb_web_fs_get_file_info_by_id"] = wasmExports["duckdb_web_fs_get_file_info_by_id"])(a0, a1, a2);
        var _duckdb_web_fs_get_file_info_by_name = Module["_duckdb_web_fs_get_file_info_by_name"] = (a0, a1, a2) => (_duckdb_web_fs_get_file_info_by_name = Module["_duckdb_web_fs_get_file_info_by_name"] = wasmExports["duckdb_web_fs_get_file_info_by_name"])(a0, a1, a2);
        var _duckdb_web_fs_register_file_url = Module["_duckdb_web_fs_register_file_url"] = (a0, a1, a2, a3, a4) => (_duckdb_web_fs_register_file_url = Module["_duckdb_web_fs_register_file_url"] = wasmExports["duckdb_web_fs_register_file_url"])(a0, a1, a2, a3, a4);
        var _duckdb_web_fs_register_file_buffer = Module["_duckdb_web_fs_register_file_buffer"] = (a0, a1, a2, a3) => (_duckdb_web_fs_register_file_buffer = Module["_duckdb_web_fs_register_file_buffer"] = wasmExports["duckdb_web_fs_register_file_buffer"])(a0, a1, a2, a3);
        var _duckdb_web_copy_file_to_buffer = Module["_duckdb_web_copy_file_to_buffer"] = (a0, a1) => (_duckdb_web_copy_file_to_buffer = Module["_duckdb_web_copy_file_to_buffer"] = wasmExports["duckdb_web_copy_file_to_buffer"])(a0, a1);
        var _duckdb_web_copy_file_to_path = Module["_duckdb_web_copy_file_to_path"] = (a0, a1, a2) => (_duckdb_web_copy_file_to_path = Module["_duckdb_web_copy_file_to_path"] = wasmExports["duckdb_web_copy_file_to_path"])(a0, a1, a2);
        var _duckdb_web_get_version = Module["_duckdb_web_get_version"] = (a0) => (_duckdb_web_get_version = Module["_duckdb_web_get_version"] = wasmExports["duckdb_web_get_version"])(a0);
        var _duckdb_web_get_feature_flags = Module["_duckdb_web_get_feature_flags"] = () => (_duckdb_web_get_feature_flags = Module["_duckdb_web_get_feature_flags"] = wasmExports["duckdb_web_get_feature_flags"])();
        var _duckdb_web_tokenize = Module["_duckdb_web_tokenize"] = (a0, a1) => (_duckdb_web_tokenize = Module["_duckdb_web_tokenize"] = wasmExports["duckdb_web_tokenize"])(a0, a1);
        var _duckdb_web_udf_scalar_create = Module["_duckdb_web_udf_scalar_create"] = (a0, a1, a2) => (_duckdb_web_udf_scalar_create = Module["_duckdb_web_udf_scalar_create"] = wasmExports["duckdb_web_udf_scalar_create"])(a0, a1, a2);
        var _duckdb_web_prepared_create = Module["_duckdb_web_prepared_create"] = (a0, a1, a2) => (_duckdb_web_prepared_create = Module["_duckdb_web_prepared_create"] = wasmExports["duckdb_web_prepared_create"])(a0, a1, a2);
        var _duckdb_web_prepared_close = Module["_duckdb_web_prepared_close"] = (a0, a1, a2) => (_duckdb_web_prepared_close = Module["_duckdb_web_prepared_close"] = wasmExports["duckdb_web_prepared_close"])(a0, a1, a2);
        var _duckdb_web_prepared_run = Module["_duckdb_web_prepared_run"] = (a0, a1, a2, a3) => (_duckdb_web_prepared_run = Module["_duckdb_web_prepared_run"] = wasmExports["duckdb_web_prepared_run"])(a0, a1, a2, a3);
        var _duckdb_web_prepared_send = Module["_duckdb_web_prepared_send"] = (a0, a1, a2, a3) => (_duckdb_web_prepared_send = Module["_duckdb_web_prepared_send"] = wasmExports["duckdb_web_prepared_send"])(a0, a1, a2, a3);
        var _duckdb_web_query_run = Module["_duckdb_web_query_run"] = (a0, a1, a2) => (_duckdb_web_query_run = Module["_duckdb_web_query_run"] = wasmExports["duckdb_web_query_run"])(a0, a1, a2);
        var _duckdb_web_pending_query_start = Module["_duckdb_web_pending_query_start"] = (a0, a1, a2) => (_duckdb_web_pending_query_start = Module["_duckdb_web_pending_query_start"] = wasmExports["duckdb_web_pending_query_start"])(a0, a1, a2);
        var _duckdb_web_pending_query_poll = Module["_duckdb_web_pending_query_poll"] = (a0, a1, a2) => (_duckdb_web_pending_query_poll = Module["_duckdb_web_pending_query_poll"] = wasmExports["duckdb_web_pending_query_poll"])(a0, a1, a2);
        var _duckdb_web_pending_query_cancel = Module["_duckdb_web_pending_query_cancel"] = (a0, a1) => (_duckdb_web_pending_query_cancel = Module["_duckdb_web_pending_query_cancel"] = wasmExports["duckdb_web_pending_query_cancel"])(a0, a1);
        var _duckdb_web_query_fetch_results = Module["_duckdb_web_query_fetch_results"] = (a0, a1) => (_duckdb_web_query_fetch_results = Module["_duckdb_web_query_fetch_results"] = wasmExports["duckdb_web_query_fetch_results"])(a0, a1);
        var _duckdb_web_get_tablenames = Module["_duckdb_web_get_tablenames"] = (a0, a1, a2) => (_duckdb_web_get_tablenames = Module["_duckdb_web_get_tablenames"] = wasmExports["duckdb_web_get_tablenames"])(a0, a1, a2);
        var _duckdb_web_insert_arrow_from_ipc_stream = Module["_duckdb_web_insert_arrow_from_ipc_stream"] = (a0, a1, a2, a3, a4) => (_duckdb_web_insert_arrow_from_ipc_stream = Module["_duckdb_web_insert_arrow_from_ipc_stream"] = wasmExports["duckdb_web_insert_arrow_from_ipc_stream"])(a0, a1, a2, a3, a4);
        var _duckdb_web_insert_csv_from_path = Module["_duckdb_web_insert_csv_from_path"] = (a0, a1, a2, a3) => (_duckdb_web_insert_csv_from_path = Module["_duckdb_web_insert_csv_from_path"] = wasmExports["duckdb_web_insert_csv_from_path"])(a0, a1, a2, a3);
        var _duckdb_web_insert_json_from_path = Module["_duckdb_web_insert_json_from_path"] = (a0, a1, a2, a3) => (_duckdb_web_insert_json_from_path = Module["_duckdb_web_insert_json_from_path"] = wasmExports["duckdb_web_insert_json_from_path"])(a0, a1, a2, a3);
        var _duckdb_web_fts_init = Module["_duckdb_web_fts_init"] = (a0) => (_duckdb_web_fts_init = Module["_duckdb_web_fts_init"] = wasmExports["duckdb_web_fts_init"])(a0);
        var _duckdb_web_parquet_init = Module["_duckdb_web_parquet_init"] = (a0) => (_duckdb_web_parquet_init = Module["_duckdb_web_parquet_init"] = wasmExports["duckdb_web_parquet_init"])(a0);
        var _freeaddrinfo = Module["_freeaddrinfo"] = (a0) => (_freeaddrinfo = Module["_freeaddrinfo"] = wasmExports["freeaddrinfo"])(a0);
        var _freeifaddrs = Module["_freeifaddrs"] = (a0) => (_freeifaddrs = Module["_freeifaddrs"] = wasmExports["freeifaddrs"])(a0);
        var _freelocale = Module["_freelocale"] = (a0) => (_freelocale = Module["_freelocale"] = wasmExports["freelocale"])(a0);
        var _malloc_trim = Module["_malloc_trim"] = (a0) => (_malloc_trim = Module["_malloc_trim"] = wasmExports["malloc_trim"])(a0);
        var _malloc_usable_size = Module["_malloc_usable_size"] = (a0) => (_malloc_usable_size = Module["_malloc_usable_size"] = wasmExports["malloc_usable_size"])(a0);
        var _malloc_footprint = Module["_malloc_footprint"] = () => (_malloc_footprint = Module["_malloc_footprint"] = wasmExports["malloc_footprint"])();
        var _malloc_max_footprint = Module["_malloc_max_footprint"] = () => (_malloc_max_footprint = Module["_malloc_max_footprint"] = wasmExports["malloc_max_footprint"])();
        var _malloc_footprint_limit = Module["_malloc_footprint_limit"] = () => (_malloc_footprint_limit = Module["_malloc_footprint_limit"] = wasmExports["malloc_footprint_limit"])();
        var _malloc_set_footprint_limit = Module["_malloc_set_footprint_limit"] = (a0) => (_malloc_set_footprint_limit = Module["_malloc_set_footprint_limit"] = wasmExports["malloc_set_footprint_limit"])(a0);
        var stackSave = () => (stackSave = wasmExports["stackSave"])();
        var stackRestore = (a0) => (stackRestore = wasmExports["stackRestore"])(a0);
        var stackAlloc = (a0) => (stackAlloc = wasmExports["stackAlloc"])(a0);
        var __ZTVN5arrow15BaseListBuilderINS_8ListTypeEEE = Module["__ZTVN5arrow15BaseListBuilderINS_8ListTypeEEE"] = 1762e3;
        var __ZTSN6duckdb15SetseedBindDataE = Module["__ZTSN6duckdb15SetseedBindDataE"] = 461e3;
        var __ZTIN6duckdb18DuckDBSettingsDataE = Module["__ZTIN6duckdb18DuckDBSettingsDataE"] = 1958e3;
        var __ZN6duckdb11BoxRenderer12SPLIT_COLUMNE = Module["__ZN6duckdb11BoxRenderer12SPLIT_COLUMNE"] = 534e3;
        var __ZTIN6duckdb11PhysicalSetE = Module["__ZTIN6duckdb11PhysicalSetE"] = 1985e3;
        var __ZTIN6duckdb21BatchCopyToLocalStateE = Module["__ZTIN6duckdb21BatchCopyToLocalStateE"] = 1992e3;
        var __ZTIN6duckdb17UpdateGlobalStateE = Module["__ZTIN6duckdb17UpdateGlobalStateE"] = 1993e3;
        var __ZTVNSt3__220__shared_ptr_emplaceIN6duckdb16SubqueryRelationENS_9allocatorIS2_EEEE = Module["__ZTVNSt3__220__shared_ptr_emplaceIN6duckdb16SubqueryRelationENS_9allocatorIS2_EEEE"] = 2008e3;
        var __ZTVN6duckdb16RLECompressStateIxLb1EEE = Module["__ZTVN6duckdb16RLECompressStateIxLb1EEE"] = 201e4;
        var __ZTINSt3__220__shared_ptr_emplaceIN6duckdb16ColumnStatisticsENS_9allocatorIS2_EEEE = Module["__ZTINSt3__220__shared_ptr_emplaceIN6duckdb16ColumnStatisticsENS_9allocatorIS2_EEEE"] = 2015e3;
        var __ZTIN6duckdb15DuckTransactionE = Module["__ZTIN6duckdb15DuckTransactionE"] = 2019e3;
        var __ZTVN5arrow9ListArrayE = Module["__ZTVN5arrow9ListArrayE"] = 2052e3;
        var __ZTIZN5arrow22ValueComparatorVisitor5VisitINS_14DenseUnionTypeEEENS_6StatusERKT_EUlRKNS_5ArrayExS9_xE_ = Module["__ZTIZN5arrow22ValueComparatorVisitor5VisitINS_14DenseUnionTypeEEENS_6StatusERKT_EUlRKNS_5ArrayExS9_xE_"] = 2057e3;
        var __ZTIZN5arrow17MakeFormatterImpl5VisitINS_10BinaryTypeEEENSt3__29enable_ifIXsr19is_binary_like_typeIT_EE5valueENS_6StatusEE4typeERKS5_EUlRKNS_5ArrayExPNS3_13basic_ostreamIcNS3_11char_traitsIcEEEEE_ = Module["__ZTIZN5arrow17MakeFormatterImpl5VisitINS_10BinaryTypeEEENSt3__29enable_ifIXsr19is_binary_like_typeIT_EE5valueENS_6StatusEE4typeERKS5_EUlRKNS_5ArrayExPNS3_13basic_ostreamIcNS3_11char_traitsIcEEEEE_"] = 2058e3;
        var __ZTIN5arrow8internal21DictionaryBuilderBaseINS_20TypeErasedIntBuilderENS_17MonthIntervalTypeEEE = Module["__ZTIN5arrow8internal21DictionaryBuilderBaseINS_20TypeErasedIntBuilderENS_17MonthIntervalTypeEEE"] = 2067e3;
        var __ZTVNSt3__220__shared_ptr_emplaceIN5arrow14SparseCSFIndexENS_9allocatorIS2_EEEE = Module["__ZTVNSt3__220__shared_ptr_emplaceIN5arrow14SparseCSFIndexENS_9allocatorIS2_EEEE"] = 2071e3;
        var __ZTVN5arrow10UInt32TypeE = Module["__ZTVN5arrow10UInt32TypeE"] = 2075e3;
        var __ZTVNSt3__220__shared_ptr_emplaceIN5arrow10StringTypeENS_9allocatorIS2_EEEE = Module["__ZTVNSt3__220__shared_ptr_emplaceIN5arrow10StringTypeENS_9allocatorIS2_EEEE"] = 2076e3;
        var __ZN5arrow7compute27ElementWiseAggregateOptions9kTypeNameE = Module["__ZN5arrow7compute27ElementWiseAggregateOptions9kTypeNameE"] = 1372e3;
        var __ZTIZN5arrow7compute8internal22GetFunctionOptionsTypeINS0_16MapLookupOptionsEJNS_8internal18DataMemberPropertyIS3_NS3_10OccurrenceEEENS5_IS3_NSt3__210shared_ptrINS_6ScalarEEEEEEEEPKNS0_19FunctionOptionsTypeEDpRKT0_E11OptionsType = Module["__ZTIZN5arrow7compute8internal22GetFunctionOptionsTypeINS0_16MapLookupOptionsEJNS_8internal18DataMemberPropertyIS3_NS3_10OccurrenceEEENS5_IS3_NSt3__210shared_ptrINS_6ScalarEEEEEEEEPKNS0_19FunctionOptionsTypeEDpRKT0_E11OptionsType"] = 2099e3;
        var __ZTVN5arrow7compute11SortOptionsE = Module["__ZTVN5arrow7compute11SortOptionsE"] = 2101e3;
        var __ZTVNSt3__220__shared_ptr_emplaceIN5arrow7compute11CastOptionsENS_9allocatorIS3_EEEE = Module["__ZTVNSt3__220__shared_ptr_emplaceIN5arrow7compute11CastOptionsENS_9allocatorIS3_EEEE"] = 2103e3;
        var __ZTVNSt3__210__stdinbufIcEE = Module["__ZTVNSt3__210__stdinbufIcEE"] = 2117e3;
        var __ZTVNSt3__27codecvtIDsc11__mbstate_tEE = Module["__ZTVNSt3__27codecvtIDsc11__mbstate_tEE"] = 2118e3;
        var __ZTINSt3__215__codecvt_utf16IDsLb1EEE = Module["__ZTINSt3__215__codecvt_utf16IDsLb1EEE"] = 2119e3;
        var __ZNSt3__212__rs_default4__c_E = Module["__ZNSt3__212__rs_default4__c_E"] = 2209e3;
        function invoke_ii(index, a1) {
          var sp = stackSave();
          try {
            return getWasmTableEntry(index)(a1);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_vii(index, a1, a2) {
          var sp = stackSave();
          try {
            getWasmTableEntry(index)(a1, a2);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viii(index, a1, a2, a3) {
          var sp = stackSave();
          try {
            getWasmTableEntry(index)(a1, a2, a3);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiii(index, a1, a2, a3, a4) {
          var sp = stackSave();
          try {
            getWasmTableEntry(index)(a1, a2, a3, a4);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iii(index, a1, a2) {
          var sp = stackSave();
          try {
            return getWasmTableEntry(index)(a1, a2);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiiiii(index, a1, a2, a3, a4, a5, a6) {
          var sp = stackSave();
          try {
            getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_dii(index, a1, a2) {
          var sp = stackSave();
          try {
            return getWasmTableEntry(index)(a1, a2);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {
          var sp = stackSave();
          try {
            getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_vi(index, a1) {
          var sp = stackSave();
          try {
            getWasmTableEntry(index)(a1);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiiii(index, a1, a2, a3, a4) {
          var sp = stackSave();
          try {
            return getWasmTableEntry(index)(a1, a2, a3, a4);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiiiiii(index, a1, a2, a3, a4, a5, a6) {
          var sp = stackSave();
          try {
            return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {
          var sp = stackSave();
          try {
            return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiii(index, a1, a2, a3) {
          var sp = stackSave();
          try {
            return getWasmTableEntry(index)(a1, a2, a3);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_v(index) {
          var sp = stackSave();
          try {
            getWasmTableEntry(index)();
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_i(index) {
          var sp = stackSave();
          try {
            return getWasmTableEntry(index)();
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8) {
          var sp = stackSave();
          try {
            return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiiiii(index, a1, a2, a3, a4, a5) {
          var sp = stackSave();
          try {
            return getWasmTableEntry(index)(a1, a2, a3, a4, a5);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiiii(index, a1, a2, a3, a4, a5) {
          var sp = stackSave();
          try {
            getWasmTableEntry(index)(a1, a2, a3, a4, a5);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viif(index, a1, a2, a3) {
          var sp = stackSave();
          try {
            getWasmTableEntry(index)(a1, a2, a3);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viid(index, a1, a2, a3) {
          var sp = stackSave();
          try {
            getWasmTableEntry(index)(a1, a2, a3);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iid(index, a1, a2) {
          var sp = stackSave();
          try {
            return getWasmTableEntry(index)(a1, a2);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiiiiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) {
          var sp = stackSave();
          try {
            return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_vid(index, a1, a2) {
          var sp = stackSave();
          try {
            getWasmTableEntry(index)(a1, a2);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiiiiid(index, a1, a2, a3, a4, a5, a6) {
          var sp = stackSave();
          try {
            return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
          var sp = stackSave();
          try {
            getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
          var sp = stackSave();
          try {
            getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_di(index, a1) {
          var sp = stackSave();
          try {
            return getWasmTableEntry(index)(a1);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_vif(index, a1, a2) {
          var sp = stackSave();
          try {
            getWasmTableEntry(index)(a1, a2);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
          var sp = stackSave();
          try {
            return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8) {
          var sp = stackSave();
          try {
            getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
          var sp = stackSave();
          try {
            return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiid(index, a1, a2, a3) {
          var sp = stackSave();
          try {
            return getWasmTableEntry(index)(a1, a2, a3);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiiiiiiiiiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17) {
          var sp = stackSave();
          try {
            return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iidii(index, a1, a2, a3, a4) {
          var sp = stackSave();
          try {
            return getWasmTableEntry(index)(a1, a2, a3, a4);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_fi(index, a1) {
          var sp = stackSave();
          try {
            return getWasmTableEntry(index)(a1);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiiiiiiiiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16) {
          var sp = stackSave();
          try {
            return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiiiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {
          var sp = stackSave();
          try {
            return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_fiiii(index, a1, a2, a3, a4) {
          var sp = stackSave();
          try {
            return getWasmTableEntry(index)(a1, a2, a3, a4);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_diiii(index, a1, a2, a3, a4) {
          var sp = stackSave();
          try {
            return getWasmTableEntry(index)(a1, a2, a3, a4);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viddddi(index, a1, a2, a3, a4, a5, a6) {
          var sp = stackSave();
          try {
            getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_diiiiid(index, a1, a2, a3, a4, a5, a6) {
          var sp = stackSave();
          try {
            return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiiid(index, a1, a2, a3, a4) {
          var sp = stackSave();
          try {
            return getWasmTableEntry(index)(a1, a2, a3, a4);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_idiii(index, a1, a2, a3, a4) {
          var sp = stackSave();
          try {
            return getWasmTableEntry(index)(a1, a2, a3, a4);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiiiiidiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
          var sp = stackSave();
          try {
            getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viidii(index, a1, a2, a3, a4, a5) {
          var sp = stackSave();
          try {
            getWasmTableEntry(index)(a1, a2, a3, a4, a5);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iff(index, a1, a2) {
          var sp = stackSave();
          try {
            return getWasmTableEntry(index)(a1, a2);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_idd(index, a1, a2) {
          var sp = stackSave();
          try {
            return getWasmTableEntry(index)(a1, a2);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiiiiiiiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) {
          var sp = stackSave();
          try {
            return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_if(index, a1) {
          var sp = stackSave();
          try {
            return getWasmTableEntry(index)(a1);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_id(index, a1) {
          var sp = stackSave();
          try {
            return getWasmTableEntry(index)(a1);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_idiiii(index, a1, a2, a3, a4, a5) {
          var sp = stackSave();
          try {
            return getWasmTableEntry(index)(a1, a2, a3, a4, a5);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_ifii(index, a1, a2, a3) {
          var sp = stackSave();
          try {
            return getWasmTableEntry(index)(a1, a2, a3);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_idii(index, a1, a2, a3) {
          var sp = stackSave();
          try {
            return getWasmTableEntry(index)(a1, a2, a3);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_ifi(index, a1, a2) {
          var sp = stackSave();
          try {
            return getWasmTableEntry(index)(a1, a2);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_idi(index, a1, a2) {
          var sp = stackSave();
          try {
            return getWasmTableEntry(index)(a1, a2);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_vifi(index, a1, a2, a3) {
          var sp = stackSave();
          try {
            getWasmTableEntry(index)(a1, a2, a3);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_vidi(index, a1, a2, a3) {
          var sp = stackSave();
          try {
            getWasmTableEntry(index)(a1, a2, a3);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiiidiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
          var sp = stackSave();
          try {
            getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_diii(index, a1, a2, a3) {
          var sp = stackSave();
          try {
            return getWasmTableEntry(index)(a1, a2, a3);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_vfii(index, a1, a2, a3) {
          var sp = stackSave();
          try {
            getWasmTableEntry(index)(a1, a2, a3);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_vdii(index, a1, a2, a3) {
          var sp = stackSave();
          try {
            getWasmTableEntry(index)(a1, a2, a3);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {
          var sp = stackSave();
          try {
            getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iifii(index, a1, a2, a3, a4) {
          var sp = stackSave();
          try {
            return getWasmTableEntry(index)(a1, a2, a3, a4);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iif(index, a1, a2) {
          var sp = stackSave();
          try {
            return getWasmTableEntry(index)(a1, a2);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iidiii(index, a1, a2, a3, a4, a5) {
          var sp = stackSave();
          try {
            return getWasmTableEntry(index)(a1, a2, a3, a4, a5);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iidiiii(index, a1, a2, a3, a4, a5, a6) {
          var sp = stackSave();
          try {
            return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iidi(index, a1, a2, a3) {
          var sp = stackSave();
          try {
            return getWasmTableEntry(index)(a1, a2, a3);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiiiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) {
          var sp = stackSave();
          try {
            getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_vifii(index, a1, a2, a3, a4) {
          var sp = stackSave();
          try {
            getWasmTableEntry(index)(a1, a2, a3, a4);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_vidii(index, a1, a2, a3, a4) {
          var sp = stackSave();
          try {
            getWasmTableEntry(index)(a1, a2, a3, a4);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiifi(index, a1, a2, a3, a4, a5) {
          var sp = stackSave();
          try {
            getWasmTableEntry(index)(a1, a2, a3, a4, a5);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiidi(index, a1, a2, a3, a4, a5) {
          var sp = stackSave();
          try {
            getWasmTableEntry(index)(a1, a2, a3, a4, a5);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiiiid(index, a1, a2, a3, a4, a5) {
          var sp = stackSave();
          try {
            return getWasmTableEntry(index)(a1, a2, a3, a4, a5);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_fiii(index, a1, a2, a3) {
          var sp = stackSave();
          try {
            return getWasmTableEntry(index)(a1, a2, a3);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiiiiiiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) {
          var sp = stackSave();
          try {
            getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viji(index, a1, a2, a3, a4) {
          var sp = stackSave();
          try {
            Module["dynCall_viji"](index, a1, a2, a3, a4);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_ji(index, a1) {
          var sp = stackSave();
          try {
            return Module["dynCall_ji"](index, a1);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiji(index, a1, a2, a3, a4, a5) {
          var sp = stackSave();
          try {
            Module["dynCall_viiji"](index, a1, a2, a3, a4, a5);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iij(index, a1, a2, a3) {
          var sp = stackSave();
          try {
            return Module["dynCall_iij"](index, a1, a2, a3);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iijiijj(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
          var sp = stackSave();
          try {
            return Module["dynCall_iijiijj"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiijiijj(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
          var sp = stackSave();
          try {
            return Module["dynCall_iiijiijj"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viij(index, a1, a2, a3, a4) {
          var sp = stackSave();
          try {
            Module["dynCall_viij"](index, a1, a2, a3, a4);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiijj(index, a1, a2, a3, a4, a5, a6) {
          var sp = stackSave();
          try {
            return Module["dynCall_iiijj"](index, a1, a2, a3, a4, a5, a6);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiijj(index, a1, a2, a3, a4, a5, a6, a7) {
          var sp = stackSave();
          try {
            Module["dynCall_viiijj"](index, a1, a2, a3, a4, a5, a6, a7);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_jii(index, a1, a2) {
          var sp = stackSave();
          try {
            return Module["dynCall_jii"](index, a1, a2);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_vij(index, a1, a2, a3) {
          var sp = stackSave();
          try {
            Module["dynCall_vij"](index, a1, a2, a3);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiijii(index, a1, a2, a3, a4, a5, a6) {
          var sp = stackSave();
          try {
            return Module["dynCall_iiijii"](index, a1, a2, a3, a4, a5, a6);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viijii(index, a1, a2, a3, a4, a5, a6) {
          var sp = stackSave();
          try {
            Module["dynCall_viijii"](index, a1, a2, a3, a4, a5, a6);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiij(index, a1, a2, a3, a4) {
          var sp = stackSave();
          try {
            return Module["dynCall_iiij"](index, a1, a2, a3, a4);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiij(index, a1, a2, a3, a4, a5) {
          var sp = stackSave();
          try {
            Module["dynCall_viiij"](index, a1, a2, a3, a4, a5);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiiij(index, a1, a2, a3, a4, a5) {
          var sp = stackSave();
          try {
            return Module["dynCall_iiiij"](index, a1, a2, a3, a4, a5);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viijijj(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
          var sp = stackSave();
          try {
            Module["dynCall_viijijj"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiiiij(index, a1, a2, a3, a4, a5, a6) {
          var sp = stackSave();
          try {
            return Module["dynCall_iiiiij"](index, a1, a2, a3, a4, a5, a6);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viijiijj(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
          var sp = stackSave();
          try {
            Module["dynCall_viijiijj"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiiji(index, a1, a2, a3, a4, a5) {
          var sp = stackSave();
          try {
            return Module["dynCall_iiiji"](index, a1, a2, a3, a4, a5);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiji(index, a1, a2, a3, a4) {
          var sp = stackSave();
          try {
            return Module["dynCall_iiji"](index, a1, a2, a3, a4);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_jiiij(index, a1, a2, a3, a4, a5) {
          var sp = stackSave();
          try {
            return Module["dynCall_jiiij"](index, a1, a2, a3, a4, a5);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiiji(index, a1, a2, a3, a4, a5, a6) {
          var sp = stackSave();
          try {
            Module["dynCall_viiiji"](index, a1, a2, a3, a4, a5, a6);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_jj(index, a1, a2) {
          var sp = stackSave();
          try {
            return Module["dynCall_jj"](index, a1, a2);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iijjii(index, a1, a2, a3, a4, a5, a6, a7) {
          var sp = stackSave();
          try {
            return Module["dynCall_iijjii"](index, a1, a2, a3, a4, a5, a6, a7);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_vijji(index, a1, a2, a3, a4, a5, a6) {
          var sp = stackSave();
          try {
            Module["dynCall_vijji"](index, a1, a2, a3, a4, a5, a6);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iijii(index, a1, a2, a3, a4, a5) {
          var sp = stackSave();
          try {
            return Module["dynCall_iijii"](index, a1, a2, a3, a4, a5);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiiiijj(index, a1, a2, a3, a4, a5, a6, a7, a8) {
          var sp = stackSave();
          try {
            return Module["dynCall_iiiiijj"](index, a1, a2, a3, a4, a5, a6, a7, a8);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_jiiiii(index, a1, a2, a3, a4, a5) {
          var sp = stackSave();
          try {
            return Module["dynCall_jiiiii"](index, a1, a2, a3, a4, a5);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiijii(index, a1, a2, a3, a4, a5, a6, a7) {
          var sp = stackSave();
          try {
            Module["dynCall_viiijii"](index, a1, a2, a3, a4, a5, a6, a7);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiiijii(index, a1, a2, a3, a4, a5, a6, a7) {
          var sp = stackSave();
          try {
            return Module["dynCall_iiiijii"](index, a1, a2, a3, a4, a5, a6, a7);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiiijii(index, a1, a2, a3, a4, a5, a6, a7, a8) {
          var sp = stackSave();
          try {
            Module["dynCall_viiiijii"](index, a1, a2, a3, a4, a5, a6, a7, a8);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiijiii(index, a1, a2, a3, a4, a5, a6, a7) {
          var sp = stackSave();
          try {
            return Module["dynCall_iiijiii"](index, a1, a2, a3, a4, a5, a6, a7);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiiiijii(index, a1, a2, a3, a4, a5, a6, a7, a8) {
          var sp = stackSave();
          try {
            return Module["dynCall_iiiiijii"](index, a1, a2, a3, a4, a5, a6, a7, a8);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viijiiii(index, a1, a2, a3, a4, a5, a6, a7, a8) {
          var sp = stackSave();
          try {
            Module["dynCall_viijiiii"](index, a1, a2, a3, a4, a5, a6, a7, a8);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viijiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
          var sp = stackSave();
          try {
            Module["dynCall_viijiiiii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiijiij(index, a1, a2, a3, a4, a5, a6, a7, a8) {
          var sp = stackSave();
          try {
            return Module["dynCall_iiijiij"](index, a1, a2, a3, a4, a5, a6, a7, a8);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_vijiii(index, a1, a2, a3, a4, a5, a6) {
          var sp = stackSave();
          try {
            Module["dynCall_vijiii"](index, a1, a2, a3, a4, a5, a6);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iijjiii(index, a1, a2, a3, a4, a5, a6, a7, a8) {
          var sp = stackSave();
          try {
            return Module["dynCall_iijjiii"](index, a1, a2, a3, a4, a5, a6, a7, a8);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiijjiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
          var sp = stackSave();
          try {
            return Module["dynCall_iiijjiii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiijjii(index, a1, a2, a3, a4, a5, a6, a7, a8) {
          var sp = stackSave();
          try {
            return Module["dynCall_iiijjii"](index, a1, a2, a3, a4, a5, a6, a7, a8);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iijji(index, a1, a2, a3, a4, a5, a6) {
          var sp = stackSave();
          try {
            return Module["dynCall_iijji"](index, a1, a2, a3, a4, a5, a6);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viijiii(index, a1, a2, a3, a4, a5, a6, a7) {
          var sp = stackSave();
          try {
            Module["dynCall_viijiii"](index, a1, a2, a3, a4, a5, a6, a7);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiiij(index, a1, a2, a3, a4, a5, a6) {
          var sp = stackSave();
          try {
            Module["dynCall_viiiij"](index, a1, a2, a3, a4, a5, a6);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_jiii(index, a1, a2, a3) {
          var sp = stackSave();
          try {
            return Module["dynCall_jiii"](index, a1, a2, a3);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_vjjii(index, a1, a2, a3, a4, a5, a6) {
          var sp = stackSave();
          try {
            Module["dynCall_vjjii"](index, a1, a2, a3, a4, a5, a6);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiiiijii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
          var sp = stackSave();
          try {
            Module["dynCall_viiiiijii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iijiiii(index, a1, a2, a3, a4, a5, a6, a7) {
          var sp = stackSave();
          try {
            return Module["dynCall_iijiiii"](index, a1, a2, a3, a4, a5, a6, a7);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_jij(index, a1, a2, a3) {
          var sp = stackSave();
          try {
            return Module["dynCall_jij"](index, a1, a2, a3);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_vijiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
          var sp = stackSave();
          try {
            Module["dynCall_vijiiiiii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_vijiiii(index, a1, a2, a3, a4, a5, a6, a7) {
          var sp = stackSave();
          try {
            Module["dynCall_vijiiii"](index, a1, a2, a3, a4, a5, a6, a7);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_vijiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8) {
          var sp = stackSave();
          try {
            Module["dynCall_vijiiiii"](index, a1, a2, a3, a4, a5, a6, a7, a8);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiiiji(index, a1, a2, a3, a4, a5, a6, a7) {
          var sp = stackSave();
          try {
            Module["dynCall_viiiiji"](index, a1, a2, a3, a4, a5, a6, a7);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_vijj(index, a1, a2, a3, a4, a5) {
          var sp = stackSave();
          try {
            Module["dynCall_vijj"](index, a1, a2, a3, a4, a5);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiiiji(index, a1, a2, a3, a4, a5, a6) {
          var sp = stackSave();
          try {
            return Module["dynCall_iiiiji"](index, a1, a2, a3, a4, a5, a6);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_ijji(index, a1, a2, a3, a4, a5) {
          var sp = stackSave();
          try {
            return Module["dynCall_ijji"](index, a1, a2, a3, a4, a5);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiiiiij(index, a1, a2, a3, a4, a5, a6, a7) {
          var sp = stackSave();
          try {
            return Module["dynCall_iiiiiij"](index, a1, a2, a3, a4, a5, a6, a7);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viijj(index, a1, a2, a3, a4, a5, a6) {
          var sp = stackSave();
          try {
            Module["dynCall_viijj"](index, a1, a2, a3, a4, a5, a6);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiiiiiiji(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
          var sp = stackSave();
          try {
            return Module["dynCall_iiiiiiiji"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiiiiji(index, a1, a2, a3, a4, a5, a6, a7) {
          var sp = stackSave();
          try {
            return Module["dynCall_iiiiiji"](index, a1, a2, a3, a4, a5, a6, a7);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_vj(index, a1, a2) {
          var sp = stackSave();
          try {
            Module["dynCall_vj"](index, a1, a2);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiiiiij(index, a1, a2, a3, a4, a5, a6, a7, a8) {
          var sp = stackSave();
          try {
            Module["dynCall_viiiiiij"](index, a1, a2, a3, a4, a5, a6, a7, a8);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiiijiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {
          var sp = stackSave();
          try {
            Module["dynCall_viiiijiiiii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiiijiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
          var sp = stackSave();
          try {
            Module["dynCall_viiiijiiii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiijjj(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
          var sp = stackSave();
          try {
            Module["dynCall_viiijjj"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iijjijj(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
          var sp = stackSave();
          try {
            return Module["dynCall_iijjijj"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiiiijiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {
          var sp = stackSave();
          try {
            Module["dynCall_viiiiijiiii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_vijiji(index, a1, a2, a3, a4, a5, a6, a7) {
          var sp = stackSave();
          try {
            Module["dynCall_vijiji"](index, a1, a2, a3, a4, a5, a6, a7);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_vijjij(index, a1, a2, a3, a4, a5, a6, a7, a8) {
          var sp = stackSave();
          try {
            Module["dynCall_vijjij"](index, a1, a2, a3, a4, a5, a6, a7, a8);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_jiiji(index, a1, a2, a3, a4, a5) {
          var sp = stackSave();
          try {
            return Module["dynCall_jiiji"](index, a1, a2, a3, a4, a5);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_jjiji(index, a1, a2, a3, a4, a5, a6) {
          var sp = stackSave();
          try {
            return Module["dynCall_jjiji"](index, a1, a2, a3, a4, a5, a6);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_jijij(index, a1, a2, a3, a4, a5, a6) {
          var sp = stackSave();
          try {
            return Module["dynCall_jijij"](index, a1, a2, a3, a4, a5, a6);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_jjjd(index, a1, a2, a3, a4, a5) {
          var sp = stackSave();
          try {
            return Module["dynCall_jjjd"](index, a1, a2, a3, a4, a5);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_ij(index, a1, a2) {
          var sp = stackSave();
          try {
            return Module["dynCall_ij"](index, a1, a2);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_ijii(index, a1, a2, a3, a4) {
          var sp = stackSave();
          try {
            return Module["dynCall_ijii"](index, a1, a2, a3, a4);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_vjii(index, a1, a2, a3, a4) {
          var sp = stackSave();
          try {
            Module["dynCall_vjii"](index, a1, a2, a3, a4);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_vjiiii(index, a1, a2, a3, a4, a5, a6) {
          var sp = stackSave();
          try {
            Module["dynCall_vjiiii"](index, a1, a2, a3, a4, a5, a6);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_jiiii(index, a1, a2, a3, a4) {
          var sp = stackSave();
          try {
            return Module["dynCall_jiiii"](index, a1, a2, a3, a4);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiiiijiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
          var sp = stackSave();
          try {
            Module["dynCall_viiiiijiii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiiijiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14) {
          var sp = stackSave();
          try {
            Module["dynCall_viiiijiiiiiiii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_jjj(index, a1, a2, a3, a4) {
          var sp = stackSave();
          try {
            return Module["dynCall_jjj"](index, a1, a2, a3, a4);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiijjjj(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
          var sp = stackSave();
          try {
            return Module["dynCall_iiijjjj"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiijjjj(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {
          var sp = stackSave();
          try {
            Module["dynCall_viiijjjj"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_ijjji(index, a1, a2, a3, a4, a5, a6, a7) {
          var sp = stackSave();
          try {
            return Module["dynCall_ijjji"](index, a1, a2, a3, a4, a5, a6, a7);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_j(index) {
          var sp = stackSave();
          try {
            return Module["dynCall_j"](index);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viijij(index, a1, a2, a3, a4, a5, a6, a7) {
          var sp = stackSave();
          try {
            Module["dynCall_viijij"](index, a1, a2, a3, a4, a5, a6, a7);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viijjj(index, a1, a2, a3, a4, a5, a6, a7, a8) {
          var sp = stackSave();
          try {
            Module["dynCall_viijjj"](index, a1, a2, a3, a4, a5, a6, a7, a8);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viijiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
          var sp = stackSave();
          try {
            Module["dynCall_viijiiiiii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_jjjji(index, a1, a2, a3, a4, a5, a6, a7) {
          var sp = stackSave();
          try {
            return Module["dynCall_jjjji"](index, a1, a2, a3, a4, a5, a6, a7);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_jjjii(index, a1, a2, a3, a4, a5, a6) {
          var sp = stackSave();
          try {
            return Module["dynCall_jjjii"](index, a1, a2, a3, a4, a5, a6);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_jji(index, a1, a2, a3) {
          var sp = stackSave();
          try {
            return Module["dynCall_jji"](index, a1, a2, a3);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_ijjiii(index, a1, a2, a3, a4, a5, a6, a7) {
          var sp = stackSave();
          try {
            return Module["dynCall_ijjiii"](index, a1, a2, a3, a4, a5, a6, a7);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiiiiiijii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
          var sp = stackSave();
          try {
            return Module["dynCall_iiiiiiijii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_jiijii(index, a1, a2, a3, a4, a5, a6) {
          var sp = stackSave();
          try {
            return Module["dynCall_jiijii"](index, a1, a2, a3, a4, a5, a6);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_fiijii(index, a1, a2, a3, a4, a5, a6) {
          var sp = stackSave();
          try {
            return Module["dynCall_fiijii"](index, a1, a2, a3, a4, a5, a6);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_diijii(index, a1, a2, a3, a4, a5, a6) {
          var sp = stackSave();
          try {
            return Module["dynCall_diijii"](index, a1, a2, a3, a4, a5, a6);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_vijii(index, a1, a2, a3, a4, a5) {
          var sp = stackSave();
          try {
            Module["dynCall_vijii"](index, a1, a2, a3, a4, a5);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_vjiiiji(index, a1, a2, a3, a4, a5, a6, a7, a8) {
          var sp = stackSave();
          try {
            Module["dynCall_vjiiiji"](index, a1, a2, a3, a4, a5, a6, a7, a8);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiiiij(index, a1, a2, a3, a4, a5, a6, a7) {
          var sp = stackSave();
          try {
            Module["dynCall_viiiiij"](index, a1, a2, a3, a4, a5, a6, a7);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iijiji(index, a1, a2, a3, a4, a5, a6, a7) {
          var sp = stackSave();
          try {
            return Module["dynCall_iijiji"](index, a1, a2, a3, a4, a5, a6, a7);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiijjj(index, a1, a2, a3, a4, a5, a6, a7, a8) {
          var sp = stackSave();
          try {
            return Module["dynCall_iiijjj"](index, a1, a2, a3, a4, a5, a6, a7, a8);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_vijjji(index, a1, a2, a3, a4, a5, a6, a7, a8) {
          var sp = stackSave();
          try {
            Module["dynCall_vijjji"](index, a1, a2, a3, a4, a5, a6, a7, a8);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viijjji(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
          var sp = stackSave();
          try {
            Module["dynCall_viijjji"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiijijij(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {
          var sp = stackSave();
          try {
            Module["dynCall_viiijijij"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiijij(index, a1, a2, a3, a4, a5, a6, a7, a8) {
          var sp = stackSave();
          try {
            Module["dynCall_viiijij"](index, a1, a2, a3, a4, a5, a6, a7, a8);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_jiij(index, a1, a2, a3, a4) {
          var sp = stackSave();
          try {
            return Module["dynCall_jiij"](index, a1, a2, a3, a4);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_jijjjjii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {
          var sp = stackSave();
          try {
            return Module["dynCall_jijjjjii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_vijjj(index, a1, a2, a3, a4, a5, a6, a7) {
          var sp = stackSave();
          try {
            Module["dynCall_vijjj"](index, a1, a2, a3, a4, a5, a6, a7);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiiiijij(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
          var sp = stackSave();
          try {
            return Module["dynCall_iiiiijij"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiiiijiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
          var sp = stackSave();
          try {
            return Module["dynCall_iiiiijiii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_jiiiiii(index, a1, a2, a3, a4, a5, a6) {
          var sp = stackSave();
          try {
            return Module["dynCall_jiiiiii"](index, a1, a2, a3, a4, a5, a6);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiiijiii(index, a1, a2, a3, a4, a5, a6, a7, a8) {
          var sp = stackSave();
          try {
            return Module["dynCall_iiiijiii"](index, a1, a2, a3, a4, a5, a6, a7, a8);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viijji(index, a1, a2, a3, a4, a5, a6, a7) {
          var sp = stackSave();
          try {
            Module["dynCall_viijji"](index, a1, a2, a3, a4, a5, a6, a7);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiijjij(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
          var sp = stackSave();
          try {
            Module["dynCall_viiijjij"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_vijijjiij(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) {
          var sp = stackSave();
          try {
            Module["dynCall_vijijjiij"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viijiiiij(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
          var sp = stackSave();
          try {
            Module["dynCall_viijiiiij"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiijiiiijjj(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) {
          var sp = stackSave();
          try {
            Module["dynCall_viiijiiiijjj"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viijijiiiijjj(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17) {
          var sp = stackSave();
          try {
            Module["dynCall_viijijiiiijjj"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiijjiij(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {
          var sp = stackSave();
          try {
            Module["dynCall_viiijjiij"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_jiiijiijiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) {
          var sp = stackSave();
          try {
            return Module["dynCall_jiiijiijiii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viijijiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {
          var sp = stackSave();
          try {
            Module["dynCall_viijijiiii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_jiiijii(index, a1, a2, a3, a4, a5, a6, a7) {
          var sp = stackSave();
          try {
            return Module["dynCall_jiiijii"](index, a1, a2, a3, a4, a5, a6, a7);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iijjj(index, a1, a2, a3, a4, a5, a6, a7) {
          var sp = stackSave();
          try {
            return Module["dynCall_iijjj"](index, a1, a2, a3, a4, a5, a6, a7);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiiijj(index, a1, a2, a3, a4, a5, a6, a7) {
          var sp = stackSave();
          try {
            return Module["dynCall_iiiijj"](index, a1, a2, a3, a4, a5, a6, a7);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiijji(index, a1, a2, a3, a4, a5, a6, a7) {
          var sp = stackSave();
          try {
            return Module["dynCall_iiijji"](index, a1, a2, a3, a4, a5, a6, a7);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_vijijiiiijjj(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16) {
          var sp = stackSave();
          try {
            Module["dynCall_vijijiiiijjj"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_jiiiij(index, a1, a2, a3, a4, a5, a6) {
          var sp = stackSave();
          try {
            return Module["dynCall_jiiiij"](index, a1, a2, a3, a4, a5, a6);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiiijj(index, a1, a2, a3, a4, a5, a6, a7, a8) {
          var sp = stackSave();
          try {
            Module["dynCall_viiiijj"](index, a1, a2, a3, a4, a5, a6, a7, a8);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiiiijj(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
          var sp = stackSave();
          try {
            Module["dynCall_viiiiijj"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_jiiiiji(index, a1, a2, a3, a4, a5, a6, a7) {
          var sp = stackSave();
          try {
            return Module["dynCall_jiiiiji"](index, a1, a2, a3, a4, a5, a6, a7);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiiijijji(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) {
          var sp = stackSave();
          try {
            Module["dynCall_viiiijijji"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiiijjij(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {
          var sp = stackSave();
          try {
            Module["dynCall_viiiijjij"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiijiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
          var sp = stackSave();
          try {
            Module["dynCall_viiijiiii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiijiiijii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) {
          var sp = stackSave();
          try {
            Module["dynCall_viiijiiijii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iijiii(index, a1, a2, a3, a4, a5, a6) {
          var sp = stackSave();
          try {
            return Module["dynCall_iijiii"](index, a1, a2, a3, a4, a5, a6);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iji(index, a1, a2, a3) {
          var sp = stackSave();
          try {
            return Module["dynCall_iji"](index, a1, a2, a3);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_vijijj(index, a1, a2, a3, a4, a5, a6, a7, a8) {
          var sp = stackSave();
          try {
            Module["dynCall_vijijj"](index, a1, a2, a3, a4, a5, a6, a7, a8);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_jd(index, a1) {
          var sp = stackSave();
          try {
            return Module["dynCall_jd"](index, a1);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_jf(index, a1) {
          var sp = stackSave();
          try {
            return Module["dynCall_jf"](index, a1);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_jiijiii(index, a1, a2, a3, a4, a5, a6, a7) {
          var sp = stackSave();
          try {
            return Module["dynCall_jiijiii"](index, a1, a2, a3, a4, a5, a6, a7);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiiiijjii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {
          var sp = stackSave();
          try {
            Module["dynCall_viiiiijjii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiiiiijii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
          var sp = stackSave();
          try {
            Module["dynCall_viiiiiijii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiiiiiijjjji(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16) {
          var sp = stackSave();
          try {
            Module["dynCall_viiiiiiijjjji"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiijjii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
          var sp = stackSave();
          try {
            Module["dynCall_viiijjii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_vjiii(index, a1, a2, a3, a4, a5) {
          var sp = stackSave();
          try {
            Module["dynCall_vjiii"](index, a1, a2, a3, a4, a5);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iijj(index, a1, a2, a3, a4, a5) {
          var sp = stackSave();
          try {
            return Module["dynCall_iijj"](index, a1, a2, a3, a4, a5);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_jiiijj(index, a1, a2, a3, a4, a5, a6, a7) {
          var sp = stackSave();
          try {
            return Module["dynCall_jiiijj"](index, a1, a2, a3, a4, a5, a6, a7);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_jiiijiii(index, a1, a2, a3, a4, a5, a6, a7, a8) {
          var sp = stackSave();
          try {
            return Module["dynCall_jiiijiii"](index, a1, a2, a3, a4, a5, a6, a7, a8);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_jiiiiijiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {
          var sp = stackSave();
          try {
            return Module["dynCall_jiiiiijiiii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_jiiiijii(index, a1, a2, a3, a4, a5, a6, a7, a8) {
          var sp = stackSave();
          try {
            return Module["dynCall_jiiiijii"](index, a1, a2, a3, a4, a5, a6, a7, a8);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viijjii(index, a1, a2, a3, a4, a5, a6, a7, a8) {
          var sp = stackSave();
          try {
            Module["dynCall_viijjii"](index, a1, a2, a3, a4, a5, a6, a7, a8);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiiijjiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
          var sp = stackSave();
          try {
            return Module["dynCall_iiiijjiii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiiiiiiij(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
          var sp = stackSave();
          try {
            return Module["dynCall_iiiiiiiij"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiiiiiji(index, a1, a2, a3, a4, a5, a6, a7, a8) {
          var sp = stackSave();
          try {
            return Module["dynCall_iiiiiiji"](index, a1, a2, a3, a4, a5, a6, a7, a8);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiiiiiij(index, a1, a2, a3, a4, a5, a6, a7, a8) {
          var sp = stackSave();
          try {
            return Module["dynCall_iiiiiiij"](index, a1, a2, a3, a4, a5, a6, a7, a8);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_jijji(index, a1, a2, a3, a4, a5, a6) {
          var sp = stackSave();
          try {
            return Module["dynCall_jijji"](index, a1, a2, a3, a4, a5, a6);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiiiiji(index, a1, a2, a3, a4, a5, a6, a7, a8) {
          var sp = stackSave();
          try {
            Module["dynCall_viiiiiji"](index, a1, a2, a3, a4, a5, a6, a7, a8);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiijiii(index, a1, a2, a3, a4, a5, a6, a7, a8) {
          var sp = stackSave();
          try {
            Module["dynCall_viiijiii"](index, a1, a2, a3, a4, a5, a6, a7, a8);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiiijjj(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
          var sp = stackSave();
          try {
            return Module["dynCall_iiiijjj"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiiiiiji(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
          var sp = stackSave();
          try {
            Module["dynCall_viiiiiiji"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiiijiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
          var sp = stackSave();
          try {
            Module["dynCall_viiiijiii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiidj(index, a1, a2, a3, a4, a5) {
          var sp = stackSave();
          try {
            return Module["dynCall_iiidj"](index, a1, a2, a3, a4, a5);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiiiiiiiiiji(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) {
          var sp = stackSave();
          try {
            return Module["dynCall_iiiiiiiiiiji"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiiiiiijj(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
          var sp = stackSave();
          try {
            return Module["dynCall_iiiiiiijj"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiiijji(index, a1, a2, a3, a4, a5, a6, a7, a8) {
          var sp = stackSave();
          try {
            return Module["dynCall_iiiijji"](index, a1, a2, a3, a4, a5, a6, a7, a8);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_jiiijjj(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
          var sp = stackSave();
          try {
            return Module["dynCall_jiiijjj"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiijijj(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
          var sp = stackSave();
          try {
            Module["dynCall_viiijijj"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_jiiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {
          var sp = stackSave();
          try {
            return Module["dynCall_jiiiiiii"](index, a1, a2, a3, a4, a5, a6, a7);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_jiijj(index, a1, a2, a3, a4, a5, a6) {
          var sp = stackSave();
          try {
            return Module["dynCall_jiijj"](index, a1, a2, a3, a4, a5, a6);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiiiiiiiijiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17) {
          var sp = stackSave();
          try {
            return Module["dynCall_iiiiiiiiijiiiiiii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiijjiiji(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {
          var sp = stackSave();
          try {
            return Module["dynCall_iiijjiiji"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiijjiij(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
          var sp = stackSave();
          try {
            return Module["dynCall_iiijjiij"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiiidjj(index, a1, a2, a3, a4, a5, a6, a7, a8) {
          var sp = stackSave();
          try {
            return Module["dynCall_iiiidjj"](index, a1, a2, a3, a4, a5, a6, a7, a8);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiiiiiiiji(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
          var sp = stackSave();
          try {
            return Module["dynCall_iiiiiiiiji"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiijiiiij(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
          var sp = stackSave();
          try {
            return Module["dynCall_iiijiiiij"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiijiiij(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
          var sp = stackSave();
          try {
            return Module["dynCall_iiijiiij"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiiiiiiiiiiij(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13) {
          var sp = stackSave();
          try {
            return Module["dynCall_iiiiiiiiiiiij"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiijji(index, a1, a2, a3, a4, a5, a6, a7, a8) {
          var sp = stackSave();
          try {
            Module["dynCall_viiijji"](index, a1, a2, a3, a4, a5, a6, a7, a8);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_jiiiijiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
          var sp = stackSave();
          try {
            return Module["dynCall_jiiiijiiii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_jiijjjii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
          var sp = stackSave();
          try {
            return Module["dynCall_jiijjjii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiiijji(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
          var sp = stackSave();
          try {
            Module["dynCall_viiiijji"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiijij(index, a1, a2, a3, a4, a5, a6, a7) {
          var sp = stackSave();
          try {
            return Module["dynCall_iiijij"](index, a1, a2, a3, a4, a5, a6, a7);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_jiiiji(index, a1, a2, a3, a4, a5, a6) {
          var sp = stackSave();
          try {
            return Module["dynCall_jiiiji"](index, a1, a2, a3, a4, a5, a6);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_vjjijij(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
          var sp = stackSave();
          try {
            Module["dynCall_vjjijij"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viijiiji(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
          var sp = stackSave();
          try {
            Module["dynCall_viijiiji"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiijjijjiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14) {
          var sp = stackSave();
          try {
            return Module["dynCall_iiijjijjiii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiiijjii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
          var sp = stackSave();
          try {
            return Module["dynCall_iiiijjii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiiiiijjiijjji(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18) {
          var sp = stackSave();
          try {
            return Module["dynCall_iiiiiijjiijjji"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiijjiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
          var sp = stackSave();
          try {
            Module["dynCall_viiijjiii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viijiiij(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
          var sp = stackSave();
          try {
            Module["dynCall_viijiiij"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_vijiiiji(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
          var sp = stackSave();
          try {
            Module["dynCall_vijiiiji"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_jijiii(index, a1, a2, a3, a4, a5, a6) {
          var sp = stackSave();
          try {
            return Module["dynCall_jijiii"](index, a1, a2, a3, a4, a5, a6);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_jijjij(index, a1, a2, a3, a4, a5, a6, a7, a8) {
          var sp = stackSave();
          try {
            return Module["dynCall_jijjij"](index, a1, a2, a3, a4, a5, a6, a7, a8);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viijiij(index, a1, a2, a3, a4, a5, a6, a7, a8) {
          var sp = stackSave();
          try {
            Module["dynCall_viijiij"](index, a1, a2, a3, a4, a5, a6, a7, a8);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiijiiji(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
          var sp = stackSave();
          try {
            return Module["dynCall_iiijiiji"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iijiij(index, a1, a2, a3, a4, a5, a6, a7) {
          var sp = stackSave();
          try {
            return Module["dynCall_iijiij"](index, a1, a2, a3, a4, a5, a6, a7);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiiiiiijji(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {
          var sp = stackSave();
          try {
            return Module["dynCall_iiiiiiijji"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iijjjii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
          var sp = stackSave();
          try {
            return Module["dynCall_iijjjii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiiiijjji(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {
          var sp = stackSave();
          try {
            return Module["dynCall_iiiiijjji"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiiiijjj(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
          var sp = stackSave();
          try {
            return Module["dynCall_iiiiijjj"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_jijiiii(index, a1, a2, a3, a4, a5, a6, a7) {
          var sp = stackSave();
          try {
            return Module["dynCall_jijiiii"](index, a1, a2, a3, a4, a5, a6, a7);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiijiji(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
          var sp = stackSave();
          try {
            Module["dynCall_viiijiji"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_jijj(index, a1, a2, a3, a4, a5) {
          var sp = stackSave();
          try {
            return Module["dynCall_jijj"](index, a1, a2, a3, a4, a5);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiijjji(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
          var sp = stackSave();
          try {
            return Module["dynCall_iiijjji"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiiiijjji(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) {
          var sp = stackSave();
          try {
            Module["dynCall_viiiiijjji"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiijiiiijj(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) {
          var sp = stackSave();
          try {
            return Module["dynCall_iiijiiiijj"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiijijjj(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) {
          var sp = stackSave();
          try {
            Module["dynCall_viiijijjj"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_vijijjji(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {
          var sp = stackSave();
          try {
            Module["dynCall_vijijjji"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_vijiij(index, a1, a2, a3, a4, a5, a6, a7) {
          var sp = stackSave();
          try {
            Module["dynCall_vijiij"](index, a1, a2, a3, a4, a5, a6, a7);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iijiiijj(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
          var sp = stackSave();
          try {
            return Module["dynCall_iijiiijj"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiijiiijj(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {
          var sp = stackSave();
          try {
            return Module["dynCall_iiijiiijj"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiijjjji(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) {
          var sp = stackSave();
          try {
            Module["dynCall_viiijjjji"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_vijjjj(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
          var sp = stackSave();
          try {
            Module["dynCall_vijjjj"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiiiijiijii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13) {
          var sp = stackSave();
          try {
            Module["dynCall_viiiiijiijii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viijiji(index, a1, a2, a3, a4, a5, a6, a7, a8) {
          var sp = stackSave();
          try {
            Module["dynCall_viijiji"](index, a1, a2, a3, a4, a5, a6, a7, a8);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viijiiijj(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {
          var sp = stackSave();
          try {
            Module["dynCall_viijiiijj"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_jiji(index, a1, a2, a3, a4) {
          var sp = stackSave();
          try {
            return Module["dynCall_jiji"](index, a1, a2, a3, a4);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiijiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
          var sp = stackSave();
          try {
            return Module["dynCall_iiijiiiii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_vijjjiiji(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) {
          var sp = stackSave();
          try {
            Module["dynCall_vijjjiiji"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiiijjjj(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {
          var sp = stackSave();
          try {
            return Module["dynCall_iiiijjjj"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_vijiiiiji(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
          var sp = stackSave();
          try {
            Module["dynCall_vijiiiiji"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_vijjiii(index, a1, a2, a3, a4, a5, a6, a7, a8) {
          var sp = stackSave();
          try {
            Module["dynCall_vijjiii"](index, a1, a2, a3, a4, a5, a6, a7, a8);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0)
              throw e;
            _setThrew(1, 0);
          }
        }
        function applySignatureConversions(wasmExports2) {
          wasmExports2 = Object.assign({}, wasmExports2);
          var makeWrapper_pppp = (f) => (a0, a1, a2) => f(a0, a1, a2) >>> 0;
          var makeWrapper_pp = (f) => (a0) => f(a0) >>> 0;
          var makeWrapper_p = (f) => () => f() >>> 0;
          var makeWrapper_ppp = (f) => (a0, a1) => f(a0, a1) >>> 0;
          var makeWrapper_pP = (f) => (a0) => f(a0) >>> 0;
          wasmExports2["memcpy"] = makeWrapper_pppp(wasmExports2["memcpy"]);
          wasmExports2["malloc"] = makeWrapper_pp(wasmExports2["malloc"]);
          wasmExports2["__errno_location"] = makeWrapper_p(wasmExports2["__errno_location"]);
          wasmExports2["pthread_self"] = makeWrapper_p(wasmExports2["pthread_self"]);
          wasmExports2["__getTypeName"] = makeWrapper_pp(wasmExports2["__getTypeName"]);
          wasmExports2["emscripten_builtin_malloc"] = makeWrapper_pp(wasmExports2["emscripten_builtin_malloc"]);
          wasmExports2["emscripten_stack_get_base"] = makeWrapper_p(wasmExports2["emscripten_stack_get_base"]);
          wasmExports2["emscripten_stack_get_end"] = makeWrapper_p(wasmExports2["emscripten_stack_get_end"]);
          wasmExports2["emscripten_builtin_memalign"] = makeWrapper_ppp(wasmExports2["emscripten_builtin_memalign"]);
          wasmExports2["emscripten_stack_get_current"] = makeWrapper_p(wasmExports2["emscripten_stack_get_current"]);
          wasmExports2["emscripten_main_runtime_thread_id"] = makeWrapper_p(wasmExports2["emscripten_main_runtime_thread_id"]);
          wasmExports2["sbrk"] = makeWrapper_pP(wasmExports2["sbrk"]);
          wasmExports2["memalign"] = makeWrapper_ppp(wasmExports2["memalign"]);
          wasmExports2["stackSave"] = makeWrapper_p(wasmExports2["stackSave"]);
          wasmExports2["stackAlloc"] = makeWrapper_pp(wasmExports2["stackAlloc"]);
          return wasmExports2;
        }
        Module["stackAlloc"] = stackAlloc;
        Module["stackSave"] = stackSave;
        Module["stackRestore"] = stackRestore;
        Module["ccall"] = ccall;
        var calledRun;
        dependenciesFulfilled = function runCaller() {
          if (!calledRun)
            run();
          if (!calledRun)
            dependenciesFulfilled = runCaller;
        };
        function callMain(args2 = []) {
          var entryFunction = resolveGlobalSymbol("main").sym;
          if (!entryFunction)
            return;
          args2.unshift(thisProgram);
          var argc = args2.length;
          var argv = stackAlloc((argc + 1) * 4);
          var argv_ptr = argv;
          args2.forEach((arg) => {
            HEAPU32[argv_ptr >>> 2 >>> 0] = stringToUTF8OnStack(arg);
            argv_ptr += 4;
          });
          HEAPU32[argv_ptr >>> 2 >>> 0] = 0;
          try {
            var ret = entryFunction(argc, argv);
            exitJS(ret, true);
            return ret;
          } catch (e) {
            return handleException(e);
          }
        }
        function run(args2 = arguments_) {
          if (runDependencies > 0) {
            return;
          }
          preRun();
          if (runDependencies > 0) {
            return;
          }
          function doRun() {
            if (calledRun)
              return;
            calledRun = true;
            Module["calledRun"] = true;
            if (ABORT)
              return;
            initRuntime();
            preMain();
            readyPromiseResolve(Module);
            if (Module["onRuntimeInitialized"])
              Module["onRuntimeInitialized"]();
            if (shouldRunNow)
              callMain(args2);
            postRun();
          }
          if (Module["setStatus"]) {
            Module["setStatus"]("Running...");
            setTimeout(function() {
              setTimeout(function() {
                Module["setStatus"]("");
              }, 1);
              doRun();
            }, 1);
          } else {
            doRun();
          }
        }
        if (Module["preInit"]) {
          if (typeof Module["preInit"] == "function")
            Module["preInit"] = [Module["preInit"]];
          while (Module["preInit"].length > 0) {
            Module["preInit"].pop()();
          }
        }
        var shouldRunNow = true;
        if (Module["noInitialRun"])
          shouldRunNow = false;
        run();
        return moduleArg.ready;
      };
    })();
    if (typeof exports === "object" && typeof module === "object")
      module.exports = DuckDB;
    else if (typeof define === "function" && define["amd"])
      define([], () => DuckDB);
  }
});

// src/bindings/duckdb-eh.js
var require_duckdb_eh = __commonJS({
  "src/bindings/duckdb-eh.js"(exports, module) {
    "use strict";
    var DuckDB = (() => {
      var _scriptDir = typeof document !== "undefined" && document.currentScript ? document.currentScript.src : void 0;
      if (typeof __filename !== "undefined")
        _scriptDir || (_scriptDir = __filename);
      return function(moduleArg = {}) {
        var Module = moduleArg;
        var readyPromiseResolve, readyPromiseReject;
        Module["ready"] = new Promise((resolve, reject) => {
          readyPromiseResolve = resolve;
          readyPromiseReject = reject;
        });
        var moduleOverrides = Object.assign({}, Module);
        var arguments_ = [];
        var thisProgram = "./this.program";
        var quit_ = (status, toThrow) => {
          throw toThrow;
        };
        var ENVIRONMENT_IS_WEB = typeof window == "object";
        var ENVIRONMENT_IS_WORKER = typeof importScripts == "function";
        var ENVIRONMENT_IS_NODE = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string";
        var ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;
        var scriptDirectory = "";
        function locateFile(path2) {
          if (Module["locateFile"]) {
            return Module["locateFile"](path2, scriptDirectory);
          }
          return scriptDirectory + path2;
        }
        var read_, readAsync, readBinary;
        if (ENVIRONMENT_IS_NODE) {
          var fs = require("fs");
          var nodePath = require("path");
          if (ENVIRONMENT_IS_WORKER) {
            scriptDirectory = nodePath.dirname(scriptDirectory) + "/";
          } else {
            scriptDirectory = __dirname + "/";
          }
          read_ = (filename, binary2) => {
            filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
            return fs.readFileSync(filename, binary2 ? void 0 : "utf8");
          };
          readBinary = (filename) => {
            var ret = read_(filename, true);
            if (!ret.buffer) {
              ret = new Uint8Array(ret);
            }
            return ret;
          };
          readAsync = (filename, onload2, onerror2, binary2 = true) => {
            filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
            fs.readFile(filename, binary2 ? void 0 : "utf8", (err2, data2) => {
              if (err2)
                onerror2(err2);
              else
                onload2(binary2 ? data2.buffer : data2);
            });
          };
          if (!Module["thisProgram"] && process.argv.length > 1) {
            thisProgram = process.argv[1].replace(/\\/g, "/");
          }
          arguments_ = process.argv.slice(2);
          quit_ = (status, toThrow) => {
            process.exitCode = status;
            throw toThrow;
          };
        } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
          if (ENVIRONMENT_IS_WORKER) {
            scriptDirectory = self.location.href;
          } else if (typeof document != "undefined" && document.currentScript) {
            scriptDirectory = document.currentScript.src;
          }
          if (_scriptDir) {
            scriptDirectory = _scriptDir;
          }
          if (scriptDirectory.indexOf("blob:") !== 0) {
            scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, "").lastIndexOf("/") + 1);
          } else {
            scriptDirectory = "";
          }
          {
            read_ = (url2) => {
              var xhr = new XMLHttpRequest();
              xhr.open("GET", url2, false);
              xhr.send(null);
              return xhr.responseText;
            };
            if (ENVIRONMENT_IS_WORKER) {
              readBinary = (url2) => {
                var xhr = new XMLHttpRequest();
                xhr.open("GET", url2, false);
                xhr.responseType = "arraybuffer";
                xhr.send(null);
                return new Uint8Array(xhr.response);
              };
            }
            readAsync = (url2, onload2, onerror2) => {
              var xhr = new XMLHttpRequest();
              xhr.open("GET", url2, true);
              xhr.responseType = "arraybuffer";
              xhr.onload = () => {
                if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
                  onload2(xhr.response);
                  return;
                }
                onerror2();
              };
              xhr.onerror = onerror2;
              xhr.send(null);
            };
          }
        } else {
        }
        var out = Module["print"] || console.log.bind(console);
        var err = Module["printErr"] || console.error.bind(console);
        Object.assign(Module, moduleOverrides);
        moduleOverrides = null;
        if (Module["arguments"])
          arguments_ = Module["arguments"];
        if (Module["thisProgram"])
          thisProgram = Module["thisProgram"];
        if (Module["quit"])
          quit_ = Module["quit"];
        var dynamicLibraries = Module["dynamicLibraries"] || [];
        var wasmBinary;
        if (Module["wasmBinary"])
          wasmBinary = Module["wasmBinary"];
        if (typeof WebAssembly != "object") {
          abort("no native wasm support detected");
        }
        var wasmMemory;
        var ABORT = false;
        var EXITSTATUS;
        function assert(condition, text) {
          if (!condition) {
            abort(text);
          }
        }
        var HEAP, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
        function updateMemoryViews() {
          var b = wasmMemory.buffer;
          Module["HEAP8"] = HEAP8 = new Int8Array(b);
          Module["HEAP16"] = HEAP16 = new Int16Array(b);
          Module["HEAPU8"] = HEAPU8 = new Uint8Array(b);
          Module["HEAPU16"] = HEAPU16 = new Uint16Array(b);
          Module["HEAP32"] = HEAP32 = new Int32Array(b);
          Module["HEAPU32"] = HEAPU32 = new Uint32Array(b);
          Module["HEAPF32"] = HEAPF32 = new Float32Array(b);
          Module["HEAPF64"] = HEAPF64 = new Float64Array(b);
        }
        var INITIAL_MEMORY = Module["INITIAL_MEMORY"] || 16777216;
        if (Module["wasmMemory"]) {
          wasmMemory = Module["wasmMemory"];
        } else {
          wasmMemory = new WebAssembly.Memory({
            "initial": INITIAL_MEMORY / 65536,
            "maximum": 4294967296 / 65536
          });
        }
        updateMemoryViews();
        INITIAL_MEMORY = wasmMemory.buffer.byteLength;
        var __ATPRERUN__ = [];
        var __ATINIT__ = [];
        var __ATMAIN__ = [];
        var __ATEXIT__ = [];
        var __ATPOSTRUN__ = [];
        var __RELOC_FUNCS__ = [];
        var runtimeInitialized = false;
        function preRun() {
          if (Module["preRun"]) {
            if (typeof Module["preRun"] == "function")
              Module["preRun"] = [Module["preRun"]];
            while (Module["preRun"].length) {
              addOnPreRun(Module["preRun"].shift());
            }
          }
          callRuntimeCallbacks(__ATPRERUN__);
        }
        function initRuntime() {
          runtimeInitialized = true;
          callRuntimeCallbacks(__RELOC_FUNCS__);
          if (!Module["noFSInit"] && !FS.init.initialized)
            FS.init();
          FS.ignorePermissions = false;
          TTY.init();
          SOCKFS.root = FS.mount(SOCKFS, {}, null);
          PIPEFS.root = FS.mount(PIPEFS, {}, null);
          callRuntimeCallbacks(__ATINIT__);
        }
        function preMain() {
          callRuntimeCallbacks(__ATMAIN__);
        }
        function postRun() {
          if (Module["postRun"]) {
            if (typeof Module["postRun"] == "function")
              Module["postRun"] = [Module["postRun"]];
            while (Module["postRun"].length) {
              addOnPostRun(Module["postRun"].shift());
            }
          }
          callRuntimeCallbacks(__ATPOSTRUN__);
        }
        function addOnPreRun(cb) {
          __ATPRERUN__.unshift(cb);
        }
        function addOnInit(cb) {
          __ATINIT__.unshift(cb);
        }
        function addOnPreMain(cb) {
          __ATMAIN__.unshift(cb);
        }
        function addOnExit(cb) {
        }
        function addOnPostRun(cb) {
          __ATPOSTRUN__.unshift(cb);
        }
        var runDependencies = 0;
        var runDependencyWatcher = null;
        var dependenciesFulfilled = null;
        function getUniqueRunDependency(id) {
          return id;
        }
        function addRunDependency(id) {
          var _a;
          runDependencies++;
          (_a = Module["monitorRunDependencies"]) == null ? void 0 : _a.call(Module, runDependencies);
        }
        function removeRunDependency(id) {
          var _a;
          runDependencies--;
          (_a = Module["monitorRunDependencies"]) == null ? void 0 : _a.call(Module, runDependencies);
          if (runDependencies == 0) {
            if (runDependencyWatcher !== null) {
              clearInterval(runDependencyWatcher);
              runDependencyWatcher = null;
            }
            if (dependenciesFulfilled) {
              var callback = dependenciesFulfilled;
              dependenciesFulfilled = null;
              callback();
            }
          }
        }
        function abort(what) {
          var _a;
          (_a = Module["onAbort"]) == null ? void 0 : _a.call(Module, what);
          what = "Aborted(" + what + ")";
          err(what);
          ABORT = true;
          EXITSTATUS = 1;
          what += ". Build with -sASSERTIONS for more info.";
          if (runtimeInitialized) {
            ___trap();
          }
          var e = new WebAssembly.RuntimeError(what);
          readyPromiseReject(e);
          throw e;
        }
        var dataURIPrefix = "data:application/octet-stream;base64,";
        var isDataURI = (filename) => filename.startsWith(dataURIPrefix);
        var isFileURI = (filename) => filename.startsWith("file://");
        var wasmBinaryFile;
        wasmBinaryFile = "./duckdb-eh.wasm";
        if (!isDataURI(wasmBinaryFile)) {
          wasmBinaryFile = locateFile(wasmBinaryFile);
        }
        function getBinarySync(file) {
          if (file == wasmBinaryFile && wasmBinary) {
            return new Uint8Array(wasmBinary);
          }
          if (readBinary) {
            return readBinary(file);
          }
          throw "both async and sync fetching of the wasm failed";
        }
        function getBinaryPromise(binaryFile) {
          if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
            if (typeof fetch == "function") {
              return fetch(binaryFile, {
                credentials: "same-origin"
              }).then((response) => {
                if (!response["ok"]) {
                  throw "failed to load wasm binary file at '" + binaryFile + "'";
                }
                return response["arrayBuffer"]();
              }).catch(() => getBinarySync(binaryFile));
            }
          }
          return Promise.resolve().then(() => getBinarySync(binaryFile));
        }
        function instantiateArrayBuffer(binaryFile, imports, receiver) {
          return getBinaryPromise(binaryFile).then((binary2) => WebAssembly.instantiate(binary2, imports)).then((instance2) => instance2).then(receiver, (reason) => {
            err(`failed to asynchronously prepare wasm: ${reason}`);
            abort(reason);
          });
        }
        function instantiateAsync(binary2, binaryFile, imports, callback) {
          if (!binary2 && typeof WebAssembly.instantiateStreaming == "function" && !isDataURI(binaryFile) && !ENVIRONMENT_IS_NODE && typeof fetch == "function") {
            return fetch(binaryFile, {
              credentials: "same-origin"
            }).then((response) => {
              var result = WebAssembly.instantiateStreaming(response, imports);
              return result.then(callback, function(reason) {
                err(`wasm streaming compile failed: ${reason}`);
                err("falling back to ArrayBuffer instantiation");
                return instantiateArrayBuffer(binaryFile, imports, callback);
              });
            });
          }
          return instantiateArrayBuffer(binaryFile, imports, callback);
        }
        function createWasm() {
          var info2 = {
            "env": wasmImports,
            "wasi_snapshot_preview1": wasmImports,
            "GOT.mem": new Proxy(wasmImports, GOTHandler),
            "GOT.func": new Proxy(wasmImports, GOTHandler)
          };
          function receiveInstance(instance2, module2) {
            wasmExports = instance2.exports;
            wasmExports = relocateExports(wasmExports, 1024);
            var metadata2 = getDylinkMetadata(module2);
            if (metadata2.neededDynlibs) {
              dynamicLibraries = metadata2.neededDynlibs.concat(dynamicLibraries);
            }
            mergeLibSymbols(wasmExports, "main");
            LDSO.init();
            loadDylibs();
            wasmExports = applySignatureConversions(wasmExports);
            addOnInit(wasmExports["__wasm_call_ctors"]);
            __RELOC_FUNCS__.push(wasmExports["__wasm_apply_data_relocs"]);
            removeRunDependency("wasm-instantiate");
            return wasmExports;
          }
          addRunDependency("wasm-instantiate");
          function receiveInstantiationResult(result) {
            receiveInstance(result["instance"], result["module"]);
          }
          if (Module["instantiateWasm"]) {
            try {
              return Module["instantiateWasm"](info2, receiveInstance);
            } catch (e) {
              err(`Module.instantiateWasm callback failed with error: ${e}`);
              readyPromiseReject(e);
            }
          }
          instantiateAsync(wasmBinary, wasmBinaryFile, info2, receiveInstantiationResult).catch(readyPromiseReject);
          return {};
        }
        var tempDouble;
        var tempI64;
        var ASM_CONSTS = {
          2134048: ($0, $1) => {
            var jsString2 = typeof runtime == "object" && runtime && typeof runtime.whereToLoad == "function" && runtime.whereToLoad ? runtime.whereToLoad(UTF8ToString($0)) : UTF8ToString($1);
            var lengthBytes = lengthBytesUTF8(jsString2) + 1;
            var stringOnWasmHeap = _malloc(lengthBytes);
            stringToUTF8(jsString2, stringOnWasmHeap, lengthBytes);
            return stringOnWasmHeap;
          },
          2134414: ($0, $1) => {
            var url2 = UTF8ToString($0);
            if (typeof XMLHttpRequest === "undefined") {
              const os = require("os");
              const path2 = require("path");
              const fs5 = require("fs");
              var array = url2.split("/");
              var l = array.length;
              var folder = path2.join(os.homedir(), ".duckdb/extensions/" + array[l - 4] + "/" + array[l - 3] + "/" + array[l - 2] + "/");
              var filePath = path2.join(folder, array[l - 1]);
              try {
                if (!fs5.existsSync(folder)) {
                  fs5.mkdirSync(folder, {
                    recursive: true
                  });
                }
                if (!fs5.existsSync(filePath)) {
                  const int32 = new Int32Array(new SharedArrayBuffer(8));
                  var Worker3 = require("worker_threads").Worker;
                  var worker2 = new Worker3("const {Worker,isMainThread,parentPort,workerData,} = require('node:worker_threads');var times = 0;var SAB = 23;var Z = 0;async function ZZZ(e) {var x = await fetch(e);var res = await x.arrayBuffer();Atomics.store(SAB, 1, res.byteLength);Atomics.store(SAB, 0, 1);Atomics.notify(SAB, 1);Atomics.notify(SAB, 0);Z = res;};parentPort.on('message', function(event) {if (times == 0) {times++;SAB = event;} else if (times == 1) {times++;ZZZ(event);} else {const a = new Uint8Array(Z);const b = new Uint8Array(event.buffer);var K = Z.byteLength;for (var i = 0; i < K; i++) {b[i] = a[i];}Atomics.notify(event, 0);Atomics.store(SAB, 0, 2);Atomics.notify(SAB, 0);}});", {
                    eval: true
                  });
                  var uInt8Array;
                  int32[0] = 0;
                  int32[2] = 4;
                  worker2.postMessage(int32);
                  worker2.postMessage(url2);
                  Atomics.wait(int32, 0, 0);
                  const int32_2 = new Int32Array(new SharedArrayBuffer(int32[1] + 3 - (int32[1] + 3) % 4));
                  worker2.postMessage(int32_2);
                  Atomics.wait(int32, 0, 1);
                  var x = new Uint8Array(int32_2.buffer, 0, int32[1]);
                  uInt8Array = x;
                  worker2.terminate();
                  fs5.writeFileSync(filePath, uInt8Array);
                } else {
                  uInt8Array = fs5.readFileSync(filePath);
                }
              } catch (e) {
                console.log("Error fetching module", e);
                return 0;
              }
            } else {
              const xhr = new XMLHttpRequest();
              xhr.open("GET", url2, false);
              xhr.responseType = "arraybuffer";
              xhr.send(null);
              if (xhr.status != 200)
                return 0;
              uInt8Array = xhr.response;
            }
            var valid = WebAssembly.validate(uInt8Array);
            var len2 = uInt8Array.byteLength;
            var fileOnWasmHeap = _malloc(len2 + 4);
            var properArray = new Uint8Array(uInt8Array);
            for (var iii = 0; iii < len2; iii++) {
              Module.HEAPU8[iii + fileOnWasmHeap + 4] = properArray[iii];
            }
            var LEN123 = new Uint8Array(4);
            LEN123[0] = len2 % 256;
            len2 -= LEN123[0];
            len2 /= 256;
            LEN123[1] = len2 % 256;
            len2 -= LEN123[1];
            len2 /= 256;
            LEN123[2] = len2 % 256;
            len2 -= LEN123[2];
            len2 /= 256;
            LEN123[3] = len2 % 256;
            len2 -= LEN123[3];
            len2 /= 256;
            Module.HEAPU8.set(LEN123, fileOnWasmHeap);
            FS.writeFile(UTF8ToString($1), new Uint8Array(uInt8Array));
            return fileOnWasmHeap;
          },
          2137053: ($0) => {
            if (!$0) {
              AL.alcErr = 40964;
              return 1;
            }
          },
          2137101: ($0) => {
            if (!AL.currentCtx) {
              err("alGetProcAddress() called without a valid context");
              return 1;
            }
            if (!$0) {
              AL.currentCtx.err = 40963;
              return 1;
            }
          }
        };
        function ExitStatus(status) {
          this.name = "ExitStatus";
          this.message = `Program terminated with exit(${status})`;
          this.status = status;
        }
        var GOT = {};
        var currentModuleWeakSymbols = /* @__PURE__ */ new Set([]);
        var GOTHandler = {
          get(obj, symName) {
            var rtn = GOT[symName];
            if (!rtn) {
              rtn = GOT[symName] = new WebAssembly.Global({
                "value": "i32",
                "mutable": true
              });
            }
            if (!currentModuleWeakSymbols.has(symName)) {
              rtn.required = true;
            }
            return rtn;
          }
        };
        var callRuntimeCallbacks = (callbacks) => {
          while (callbacks.length > 0) {
            callbacks.shift()(Module);
          }
        };
        var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : void 0;
        var UTF8ArrayToString = (heapOrArray, idx, maxBytesToRead) => {
          idx >>>= 0;
          var endIdx = idx + maxBytesToRead;
          var endPtr = idx;
          while (heapOrArray[endPtr] && !(endPtr >= endIdx))
            ++endPtr;
          if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
            return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
          }
          var str = "";
          while (idx < endPtr) {
            var u0 = heapOrArray[idx++];
            if (!(u0 & 128)) {
              str += String.fromCharCode(u0);
              continue;
            }
            var u1 = heapOrArray[idx++] & 63;
            if ((u0 & 224) == 192) {
              str += String.fromCharCode((u0 & 31) << 6 | u1);
              continue;
            }
            var u2 = heapOrArray[idx++] & 63;
            if ((u0 & 240) == 224) {
              u0 = (u0 & 15) << 12 | u1 << 6 | u2;
            } else {
              u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
            }
            if (u0 < 65536) {
              str += String.fromCharCode(u0);
            } else {
              var ch = u0 - 65536;
              str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
            }
          }
          return str;
        };
        var getDylinkMetadata = (binary2) => {
          var offset = 0;
          var end = 0;
          function getU8() {
            return binary2[offset++];
          }
          function getLEB() {
            var ret = 0;
            var mul = 1;
            while (1) {
              var byte = binary2[offset++];
              ret += (byte & 127) * mul;
              mul *= 128;
              if (!(byte & 128))
                break;
            }
            return ret;
          }
          function getString() {
            var len2 = getLEB();
            offset += len2;
            return UTF8ArrayToString(binary2, offset - len2, len2);
          }
          function failIf(condition, message) {
            if (condition)
              throw new Error(message);
          }
          var name2 = "dylink.0";
          if (binary2 instanceof WebAssembly.Module) {
            var dylinkSection = WebAssembly.Module.customSections(binary2, name2);
            if (dylinkSection.length === 0) {
              name2 = "dylink";
              dylinkSection = WebAssembly.Module.customSections(binary2, name2);
            }
            failIf(dylinkSection.length === 0, "need dylink section");
            binary2 = new Uint8Array(dylinkSection[0]);
            end = binary2.length;
          } else {
            var int32View = new Uint32Array(new Uint8Array(binary2.subarray(0, 24)).buffer);
            var magicNumberFound = int32View[0] == 1836278016;
            failIf(!magicNumberFound, "need to see wasm magic number");
            failIf(binary2[8] !== 0, "need the dylink section to be first");
            offset = 9;
            var section_size = getLEB();
            end = offset + section_size;
            name2 = getString();
          }
          var customSection = {
            neededDynlibs: [],
            tlsExports: /* @__PURE__ */ new Set(),
            weakImports: /* @__PURE__ */ new Set()
          };
          if (name2 == "dylink") {
            customSection.memorySize = getLEB();
            customSection.memoryAlign = getLEB();
            customSection.tableSize = getLEB();
            customSection.tableAlign = getLEB();
            var neededDynlibsCount = getLEB();
            for (var i2 = 0; i2 < neededDynlibsCount; ++i2) {
              var libname = getString();
              customSection.neededDynlibs.push(libname);
            }
          } else {
            failIf(name2 !== "dylink.0");
            var WASM_DYLINK_MEM_INFO = 1;
            var WASM_DYLINK_NEEDED = 2;
            var WASM_DYLINK_EXPORT_INFO = 3;
            var WASM_DYLINK_IMPORT_INFO = 4;
            var WASM_SYMBOL_TLS = 256;
            var WASM_SYMBOL_BINDING_MASK = 3;
            var WASM_SYMBOL_BINDING_WEAK = 1;
            while (offset < end) {
              var subsectionType = getU8();
              var subsectionSize = getLEB();
              if (subsectionType === WASM_DYLINK_MEM_INFO) {
                customSection.memorySize = getLEB();
                customSection.memoryAlign = getLEB();
                customSection.tableSize = getLEB();
                customSection.tableAlign = getLEB();
              } else if (subsectionType === WASM_DYLINK_NEEDED) {
                var neededDynlibsCount = getLEB();
                for (var i2 = 0; i2 < neededDynlibsCount; ++i2) {
                  libname = getString();
                  customSection.neededDynlibs.push(libname);
                }
              } else if (subsectionType === WASM_DYLINK_EXPORT_INFO) {
                var count = getLEB();
                while (count--) {
                  var symname = getString();
                  var flags2 = getLEB();
                  if (flags2 & WASM_SYMBOL_TLS) {
                    customSection.tlsExports.add(symname);
                  }
                }
              } else if (subsectionType === WASM_DYLINK_IMPORT_INFO) {
                var count = getLEB();
                while (count--) {
                  var modname = getString();
                  var symname = getString();
                  var flags2 = getLEB();
                  if ((flags2 & WASM_SYMBOL_BINDING_MASK) == WASM_SYMBOL_BINDING_WEAK) {
                    customSection.weakImports.add(symname);
                  }
                }
              } else {
                offset += subsectionSize;
              }
            }
          }
          return customSection;
        };
        function getValue(ptr2, type = "i8") {
          if (type.endsWith("*"))
            type = "*";
          switch (type) {
            case "i1":
              return HEAP8[ptr2 >>> 0 >>> 0];
            case "i8":
              return HEAP8[ptr2 >>> 0 >>> 0];
            case "i16":
              return HEAP16[ptr2 >>> 1 >>> 0];
            case "i32":
              return HEAP32[ptr2 >>> 2 >>> 0];
            case "i64":
              abort("to do getValue(i64) use WASM_BIGINT");
            case "float":
              return HEAPF32[ptr2 >>> 2 >>> 0];
            case "double":
              return HEAPF64[ptr2 >>> 3 >>> 0];
            case "*":
              return HEAPU32[ptr2 >>> 2 >>> 0];
            default:
              abort(`invalid type for getValue: ${type}`);
          }
        }
        var newDSO = (name2, handle2, syms) => {
          var dso = {
            refcount: Infinity,
            name: name2,
            exports: syms,
            global: true
          };
          LDSO.loadedLibsByName[name2] = dso;
          if (handle2 != void 0) {
            LDSO.loadedLibsByHandle[handle2] = dso;
          }
          return dso;
        };
        var LDSO = {
          loadedLibsByName: {},
          loadedLibsByHandle: {},
          init() {
            newDSO("__main__", 0, wasmImports);
          }
        };
        var ___heap_base = 2279648;
        var zeroMemory = (address, size) => {
          HEAPU8.fill(0, address, address + size);
          return address;
        };
        var alignMemory = (size, alignment) => Math.ceil(size / alignment) * alignment;
        var getMemory = (size) => {
          if (runtimeInitialized) {
            return zeroMemory(_malloc(size), size);
          }
          var ret = ___heap_base;
          var end = ret + alignMemory(size, 16);
          ___heap_base = end;
          GOT["__heap_base"].value = end;
          return ret;
        };
        var isInternalSym = (symName) => ["__cpp_exception", "__c_longjmp", "__wasm_apply_data_relocs", "__dso_handle", "__tls_size", "__tls_align", "__set_stack_limits", "_emscripten_tls_init", "__wasm_init_tls", "__wasm_call_ctors", "__start_em_asm", "__stop_em_asm", "__start_em_js", "__stop_em_js"].includes(symName) || symName.startsWith("__em_js__");
        var uleb128Encode = (n, target) => {
          if (n < 128) {
            target.push(n);
          } else {
            target.push(n % 128 | 128, n >> 7);
          }
        };
        var sigToWasmTypes = (sig) => {
          var typeNames = {
            "i": "i32",
            "j": "i64",
            "f": "f32",
            "d": "f64",
            "e": "externref",
            "p": "i32"
          };
          var type = {
            parameters: [],
            results: sig[0] == "v" ? [] : [typeNames[sig[0]]]
          };
          for (var i2 = 1; i2 < sig.length; ++i2) {
            type.parameters.push(typeNames[sig[i2]]);
          }
          return type;
        };
        var generateFuncType = (sig, target) => {
          var sigRet = sig.slice(0, 1);
          var sigParam = sig.slice(1);
          var typeCodes = {
            "i": 127,
            "p": 127,
            "j": 126,
            "f": 125,
            "d": 124,
            "e": 111
          };
          target.push(96);
          uleb128Encode(sigParam.length, target);
          for (var i2 = 0; i2 < sigParam.length; ++i2) {
            target.push(typeCodes[sigParam[i2]]);
          }
          if (sigRet == "v") {
            target.push(0);
          } else {
            target.push(1, typeCodes[sigRet]);
          }
        };
        var convertJsFunctionToWasm = (func2, sig) => {
          if (typeof WebAssembly.Function == "function") {
            return new WebAssembly.Function(sigToWasmTypes(sig), func2);
          }
          var typeSectionBody = [1];
          generateFuncType(sig, typeSectionBody);
          var bytes = [0, 97, 115, 109, 1, 0, 0, 0, 1];
          uleb128Encode(typeSectionBody.length, bytes);
          bytes.push.apply(bytes, typeSectionBody);
          bytes.push(2, 7, 1, 1, 101, 1, 102, 0, 0, 7, 5, 1, 1, 102, 0, 0);
          var module2 = new WebAssembly.Module(new Uint8Array(bytes));
          var instance2 = new WebAssembly.Instance(module2, {
            "e": {
              "f": func2
            }
          });
          var wrappedFunc = instance2.exports["f"];
          return wrappedFunc;
        };
        var wasmTable = new WebAssembly.Table({
          "initial": 21341,
          "element": "anyfunc"
        });
        var getWasmTableEntry = (funcPtr) => wasmTable.get(funcPtr);
        var updateTableMap = (offset, count) => {
          if (functionsInTableMap) {
            for (var i2 = offset; i2 < offset + count; i2++) {
              var item = getWasmTableEntry(i2);
              if (item) {
                functionsInTableMap.set(item, i2);
              }
            }
          }
        };
        var functionsInTableMap;
        var getFunctionAddress = (func2) => {
          if (!functionsInTableMap) {
            functionsInTableMap = /* @__PURE__ */ new WeakMap();
            updateTableMap(0, wasmTable.length);
          }
          return functionsInTableMap.get(func2) || 0;
        };
        var freeTableIndexes = [];
        var getEmptyTableSlot = () => {
          if (freeTableIndexes.length) {
            return freeTableIndexes.pop();
          }
          try {
            wasmTable.grow(1);
          } catch (err2) {
            if (!(err2 instanceof RangeError)) {
              throw err2;
            }
            throw "Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.";
          }
          return wasmTable.length - 1;
        };
        var setWasmTableEntry = (idx, func2) => wasmTable.set(idx, func2);
        var addFunction = (func2, sig) => {
          var rtn = getFunctionAddress(func2);
          if (rtn) {
            return rtn;
          }
          var ret = getEmptyTableSlot();
          try {
            setWasmTableEntry(ret, func2);
          } catch (err2) {
            if (!(err2 instanceof TypeError)) {
              throw err2;
            }
            var wrapped = convertJsFunctionToWasm(func2, sig);
            setWasmTableEntry(ret, wrapped);
          }
          functionsInTableMap.set(func2, ret);
          return ret;
        };
        var updateGOT = (exports2, replace) => {
          for (var symName in exports2) {
            if (isInternalSym(symName)) {
              continue;
            }
            var value = exports2[symName];
            if (symName.startsWith("orig$")) {
              symName = symName.split("$")[1];
              replace = true;
            }
            GOT[symName] || (GOT[symName] = new WebAssembly.Global({
              "value": "i32",
              "mutable": true
            }));
            if (replace || GOT[symName].value == 0) {
              if (typeof value == "function") {
                GOT[symName].value = addFunction(value);
              } else if (typeof value == "number") {
                GOT[symName].value = value;
              } else {
                err(`unhandled export type for '${symName}': ${typeof value}`);
              }
            }
          }
        };
        var relocateExports = (exports2, memoryBase2, replace) => {
          var relocated = {};
          for (var e in exports2) {
            var value = exports2[e];
            if (typeof value == "object") {
              value = value.value;
            }
            if (typeof value == "number") {
              value += memoryBase2;
            }
            relocated[e] = value;
          }
          updateGOT(relocated, replace);
          return relocated;
        };
        var isSymbolDefined = (symName) => {
          var existing = wasmImports[symName];
          if (!existing || existing.stub) {
            return false;
          }
          return true;
        };
        var resolveGlobalSymbol = (symName, direct = false) => {
          var sym;
          if (direct && "orig$" + symName in wasmImports) {
            symName = "orig$" + symName;
          }
          if (isSymbolDefined(symName)) {
            sym = wasmImports[symName];
          }
          return {
            sym,
            name: symName
          };
        };
        var UTF8ToString = (ptr2, maxBytesToRead) => {
          ptr2 >>>= 0;
          return ptr2 ? UTF8ArrayToString(HEAPU8, ptr2, maxBytesToRead) : "";
        };
        var loadWebAssemblyModule = (binary, flags, libName, localScope, handle) => {
          var metadata = getDylinkMetadata(binary);
          currentModuleWeakSymbols = metadata.weakImports;
          function loadModule() {
            var firstLoad = !handle || !HEAP8[handle + 8 >>> 0 >>> 0];
            if (firstLoad) {
              var memAlign = Math.pow(2, metadata.memoryAlign);
              var memoryBase = metadata.memorySize ? alignMemory(getMemory(metadata.memorySize + memAlign), memAlign) : 0;
              var tableBase = metadata.tableSize ? wasmTable.length : 0;
              if (handle) {
                HEAP8[handle + 8 >>> 0 >>> 0] = 1;
                HEAPU32[handle + 12 >>> 2 >>> 0] = memoryBase;
                HEAP32[handle + 16 >>> 2 >>> 0] = metadata.memorySize;
                HEAPU32[handle + 20 >>> 2 >>> 0] = tableBase;
                HEAP32[handle + 24 >>> 2 >>> 0] = metadata.tableSize;
              }
            } else {
              memoryBase = HEAPU32[handle + 12 >>> 2 >>> 0];
              tableBase = HEAPU32[handle + 20 >>> 2 >>> 0];
            }
            var tableGrowthNeeded = tableBase + metadata.tableSize - wasmTable.length;
            if (tableGrowthNeeded > 0) {
              wasmTable.grow(tableGrowthNeeded);
            }
            var moduleExports;
            function resolveSymbol(sym) {
              var resolved = resolveGlobalSymbol(sym).sym;
              if (!resolved && localScope) {
                resolved = localScope[sym];
              }
              if (!resolved) {
                resolved = moduleExports[sym];
              }
              return resolved;
            }
            var proxyHandler = {
              get(stubs, prop) {
                switch (prop) {
                  case "__memory_base":
                    return memoryBase;
                  case "__table_base":
                    return tableBase;
                }
                if (prop in wasmImports && !wasmImports[prop].stub) {
                  return wasmImports[prop];
                }
                if (!(prop in stubs)) {
                  var resolved;
                  stubs[prop] = function() {
                    resolved || (resolved = resolveSymbol(prop));
                    return resolved.apply(null, arguments);
                  };
                }
                return stubs[prop];
              }
            };
            var proxy = new Proxy({}, proxyHandler);
            var info = {
              "GOT.mem": new Proxy({}, GOTHandler),
              "GOT.func": new Proxy({}, GOTHandler),
              "env": proxy,
              "wasi_snapshot_preview1": proxy
            };
            function postInstantiation(module, instance) {
              updateTableMap(tableBase, metadata.tableSize);
              moduleExports = relocateExports(instance.exports, memoryBase);
              if (!flags.allowUndefined) {
                reportUndefinedSymbols();
              }
              function addEmAsm(addr, body) {
                var args = [];
                var arity = 0;
                for (; arity < 16; arity++) {
                  if (body.indexOf("$" + arity) != -1) {
                    args.push("$" + arity);
                  } else {
                    break;
                  }
                }
                args = args.join(",");
                var func = `(${args}) => { ${body} };`;
                ASM_CONSTS[start] = eval(func);
              }
              if ("__start_em_asm" in moduleExports) {
                var start = moduleExports["__start_em_asm"];
                var stop = moduleExports["__stop_em_asm"];
                while (start < stop) {
                  var jsString = UTF8ToString(start);
                  addEmAsm(start, jsString);
                  start = HEAPU8.indexOf(0, start) + 1;
                }
              }
              function addEmJs(name, cSig, body) {
                var jsArgs = [];
                cSig = cSig.slice(1, -1);
                if (cSig != "void") {
                  cSig = cSig.split(",");
                  for (var i in cSig) {
                    var jsArg = cSig[i].split(" ").pop();
                    jsArgs.push(jsArg.replace("*", ""));
                  }
                }
                var func = `(${jsArgs}) => ${body};`;
                moduleExports[name] = eval(func);
              }
              for (var name in moduleExports) {
                if (name.startsWith("__em_js__")) {
                  var start = moduleExports[name];
                  var jsString = UTF8ToString(start);
                  var parts = jsString.split("<::>");
                  addEmJs(name.replace("__em_js__", ""), parts[0], parts[1]);
                  delete moduleExports[name];
                }
              }
              var applyRelocs = moduleExports["__wasm_apply_data_relocs"];
              if (applyRelocs) {
                if (runtimeInitialized) {
                  applyRelocs();
                } else {
                  __RELOC_FUNCS__.push(applyRelocs);
                }
              }
              var init = moduleExports["__wasm_call_ctors"];
              if (init) {
                if (runtimeInitialized) {
                  init();
                } else {
                  __ATINIT__.push(init);
                }
              }
              return moduleExports;
            }
            if (flags.loadAsync) {
              if (binary instanceof WebAssembly.Module) {
                var instance = new WebAssembly.Instance(binary, info);
                return Promise.resolve(postInstantiation(binary, instance));
              }
              return WebAssembly.instantiate(binary, info).then((result) => postInstantiation(result.module, result.instance));
            }
            var module = binary instanceof WebAssembly.Module ? binary : new WebAssembly.Module(binary);
            var instance = new WebAssembly.Instance(module, info);
            return postInstantiation(module, instance);
          }
          if (flags.loadAsync) {
            return metadata.neededDynlibs.reduce((chain, dynNeeded) => chain.then(() => loadDynamicLibrary(dynNeeded, flags)), Promise.resolve()).then(loadModule);
          }
          metadata.neededDynlibs.forEach((needed) => loadDynamicLibrary(needed, flags, localScope));
          return loadModule();
        };
        var mergeLibSymbols = (exports2, libName2) => {
          for (var [sym, exp] of Object.entries(exports2)) {
            const setImport = (target) => {
              if (!isSymbolDefined(target)) {
                wasmImports[target] = exp;
              }
            };
            setImport(sym);
            if (sym.startsWith("dynCall_") && !Module.hasOwnProperty(sym)) {
              Module[sym] = exp;
            }
          }
        };
        var asyncLoad = (url2, onload2, onerror2, noRunDep) => {
          var dep = !noRunDep ? getUniqueRunDependency(`al ${url2}`) : "";
          readAsync(url2, (arrayBuffer) => {
            onload2(new Uint8Array(arrayBuffer));
            if (dep)
              removeRunDependency(dep);
          }, (event2) => {
            if (onerror2) {
              onerror2();
            } else {
              throw `Loading data file "${url2}" failed.`;
            }
          });
          if (dep)
            addRunDependency(dep);
        };
        var preloadPlugins = Module["preloadPlugins"] || [];
        var registerWasmPlugin = () => {
          var wasmPlugin = {
            "promiseChainEnd": Promise.resolve(),
            "canHandle": (name2) => !Module.noWasmDecoding && name2.endsWith(".so"),
            "handle": (byteArray, name2, onload2, onerror2) => {
              wasmPlugin["promiseChainEnd"] = wasmPlugin["promiseChainEnd"].then(() => loadWebAssemblyModule(byteArray, {
                loadAsync: true,
                nodelete: true
              }, name2)).then((exports2) => {
                preloadedWasm[name2] = exports2;
                onload2(byteArray);
              }, (error) => {
                err(`failed to instantiate wasm: ${name2}: ${error}`);
                onerror2();
              });
            }
          };
          preloadPlugins.push(wasmPlugin);
        };
        var preloadedWasm = {};
        function loadDynamicLibrary(libName2, flags2 = {
          global: true,
          nodelete: true
        }, localScope2, handle2) {
          var dso = LDSO.loadedLibsByName[libName2];
          if (dso) {
            if (!flags2.global) {
              if (localScope2) {
                Object.assign(localScope2, dso.exports);
              }
            } else if (!dso.global) {
              dso.global = true;
              mergeLibSymbols(dso.exports, libName2);
            }
            if (flags2.nodelete && dso.refcount !== Infinity) {
              dso.refcount = Infinity;
            }
            dso.refcount++;
            if (handle2) {
              LDSO.loadedLibsByHandle[handle2] = dso;
            }
            return flags2.loadAsync ? Promise.resolve(true) : true;
          }
          dso = newDSO(libName2, handle2, "loading");
          dso.refcount = flags2.nodelete ? Infinity : 1;
          dso.global = flags2.global;
          function loadLibData() {
            if (handle2) {
              var data2 = HEAPU32[handle2 + 28 >>> 2 >>> 0];
              var dataSize = HEAPU32[handle2 + 32 >>> 2 >>> 0];
              if (data2 && dataSize) {
                var libData = HEAP8.slice(data2, data2 + dataSize);
                return flags2.loadAsync ? Promise.resolve(libData) : libData;
              }
            }
            var libFile = locateFile(libName2);
            if (flags2.loadAsync) {
              return new Promise(function(resolve, reject) {
                asyncLoad(libFile, resolve, reject);
              });
            }
            if (!readBinary) {
              throw new Error(`${libFile}: file not found, and synchronous loading of external files is not available`);
            }
            return readBinary(libFile);
          }
          function getExports() {
            var preloaded = preloadedWasm[libName2];
            if (preloaded) {
              return flags2.loadAsync ? Promise.resolve(preloaded) : preloaded;
            }
            if (flags2.loadAsync) {
              return loadLibData().then((libData) => loadWebAssemblyModule(libData, flags2, libName2, localScope2, handle2));
            }
            return loadWebAssemblyModule(loadLibData(), flags2, libName2, localScope2, handle2);
          }
          function moduleLoaded(exports2) {
            if (dso.global) {
              mergeLibSymbols(exports2, libName2);
            } else if (localScope2) {
              Object.assign(localScope2, exports2);
            }
            dso.exports = exports2;
          }
          if (flags2.loadAsync) {
            return getExports().then((exports2) => {
              moduleLoaded(exports2);
              return true;
            });
          }
          moduleLoaded(getExports());
          return true;
        }
        var reportUndefinedSymbols = () => {
          for (var [symName, entry] of Object.entries(GOT)) {
            if (entry.value == 0) {
              var value = resolveGlobalSymbol(symName, true).sym;
              if (!value && !entry.required) {
                continue;
              }
              if (typeof value == "function") {
                entry.value = addFunction(value, value.sig);
              } else if (typeof value == "number") {
                entry.value = value;
              } else {
                throw new Error(`bad export type for '${symName}': ${typeof value}`);
              }
            }
          }
        };
        var loadDylibs = () => {
          if (!dynamicLibraries.length) {
            reportUndefinedSymbols();
            return;
          }
          addRunDependency("loadDylibs");
          dynamicLibraries.reduce((chain, lib) => chain.then(() => loadDynamicLibrary(lib, {
            loadAsync: true,
            global: true,
            nodelete: true,
            allowUndefined: true
          })), Promise.resolve()).then(() => {
            reportUndefinedSymbols();
            removeRunDependency("loadDylibs");
          });
        };
        var noExitRuntime = Module["noExitRuntime"] || true;
        function setValue(ptr2, value, type = "i8") {
          if (type.endsWith("*"))
            type = "*";
          switch (type) {
            case "i1":
              HEAP8[ptr2 >>> 0 >>> 0] = value;
              break;
            case "i8":
              HEAP8[ptr2 >>> 0 >>> 0] = value;
              break;
            case "i16":
              HEAP16[ptr2 >>> 1 >>> 0] = value;
              break;
            case "i32":
              HEAP32[ptr2 >>> 2 >>> 0] = value;
              break;
            case "i64":
              abort("to do setValue(i64) use WASM_BIGINT");
            case "float":
              HEAPF32[ptr2 >>> 2 >>> 0] = value;
              break;
            case "double":
              HEAPF64[ptr2 >>> 3 >>> 0] = value;
              break;
            case "*":
              HEAPU32[ptr2 >>> 2 >>> 0] = value;
              break;
            default:
              abort(`invalid type for setValue: ${type}`);
          }
        }
        var convertI32PairToI53Checked = (lo, hi) => hi + 2097152 >>> 0 < 4194305 - !!lo ? (lo >>> 0) + hi * 4294967296 : NaN;
        function ___assert_fail(condition, filename, line, func2) {
          condition >>>= 0;
          filename >>>= 0;
          func2 >>>= 0;
          abort(`Assertion failed: ${UTF8ToString(condition)}, at: ` + [filename ? UTF8ToString(filename) : "unknown filename", line, func2 ? UTF8ToString(func2) : "unknown function"]);
        }
        ___assert_fail.sig = "vppip";
        var ___c_longjmp = new WebAssembly.Tag({
          "parameters": ["i32"]
        });
        function ___call_sighandler(fp, sig) {
          fp >>>= 0;
          return getWasmTableEntry(fp)(sig);
        }
        ___call_sighandler.sig = "vpi";
        var ___cpp_exception = new WebAssembly.Tag({
          "parameters": ["i32"]
        });
        var ___memory_base = new WebAssembly.Global({
          "value": "i32",
          "mutable": false
        }, 1024);
        var ___stack_high = 2279648;
        var ___stack_low = 2214112;
        var ___stack_pointer = new WebAssembly.Global({
          "value": "i32",
          "mutable": true
        }, 2279648);
        var PATH = {
          isAbs: (path2) => path2.charAt(0) === "/",
          splitPath: (filename) => {
            var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
            return splitPathRe.exec(filename).slice(1);
          },
          normalizeArray: (parts2, allowAboveRoot) => {
            var up = 0;
            for (var i2 = parts2.length - 1; i2 >= 0; i2--) {
              var last = parts2[i2];
              if (last === ".") {
                parts2.splice(i2, 1);
              } else if (last === "..") {
                parts2.splice(i2, 1);
                up++;
              } else if (up) {
                parts2.splice(i2, 1);
                up--;
              }
            }
            if (allowAboveRoot) {
              for (; up; up--) {
                parts2.unshift("..");
              }
            }
            return parts2;
          },
          normalize: (path2) => {
            var isAbsolute = PATH.isAbs(path2), trailingSlash = path2.substr(-1) === "/";
            path2 = PATH.normalizeArray(path2.split("/").filter((p) => !!p), !isAbsolute).join("/");
            if (!path2 && !isAbsolute) {
              path2 = ".";
            }
            if (path2 && trailingSlash) {
              path2 += "/";
            }
            return (isAbsolute ? "/" : "") + path2;
          },
          dirname: (path2) => {
            var result = PATH.splitPath(path2), root = result[0], dir = result[1];
            if (!root && !dir) {
              return ".";
            }
            if (dir) {
              dir = dir.substr(0, dir.length - 1);
            }
            return root + dir;
          },
          basename: (path2) => {
            if (path2 === "/")
              return "/";
            path2 = PATH.normalize(path2);
            path2 = path2.replace(/\/$/, "");
            var lastSlash = path2.lastIndexOf("/");
            if (lastSlash === -1)
              return path2;
            return path2.substr(lastSlash + 1);
          },
          join: function() {
            var paths = Array.prototype.slice.call(arguments);
            return PATH.normalize(paths.join("/"));
          },
          join2: (l, r) => PATH.normalize(l + "/" + r)
        };
        var initRandomFill = () => {
          if (typeof crypto == "object" && typeof crypto["getRandomValues"] == "function") {
            return (view) => crypto.getRandomValues(view);
          } else if (ENVIRONMENT_IS_NODE) {
            try {
              var crypto_module = require("crypto");
              var randomFillSync = crypto_module["randomFillSync"];
              if (randomFillSync) {
                return (view) => crypto_module["randomFillSync"](view);
              }
              var randomBytes = crypto_module["randomBytes"];
              return (view) => (view.set(randomBytes(view.byteLength)), view);
            } catch (e) {
            }
          }
          abort("initRandomDevice");
        };
        var randomFill = (view) => (randomFill = initRandomFill())(view);
        var PATH_FS = {
          resolve: function() {
            var resolvedPath = "", resolvedAbsolute = false;
            for (var i2 = arguments.length - 1; i2 >= -1 && !resolvedAbsolute; i2--) {
              var path2 = i2 >= 0 ? arguments[i2] : FS.cwd();
              if (typeof path2 != "string") {
                throw new TypeError("Arguments to path.resolve must be strings");
              } else if (!path2) {
                return "";
              }
              resolvedPath = path2 + "/" + resolvedPath;
              resolvedAbsolute = PATH.isAbs(path2);
            }
            resolvedPath = PATH.normalizeArray(resolvedPath.split("/").filter((p) => !!p), !resolvedAbsolute).join("/");
            return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
          },
          relative: (from, to) => {
            from = PATH_FS.resolve(from).substr(1);
            to = PATH_FS.resolve(to).substr(1);
            function trim(arr) {
              var start2 = 0;
              for (; start2 < arr.length; start2++) {
                if (arr[start2] !== "")
                  break;
              }
              var end = arr.length - 1;
              for (; end >= 0; end--) {
                if (arr[end] !== "")
                  break;
              }
              if (start2 > end)
                return [];
              return arr.slice(start2, end - start2 + 1);
            }
            var fromParts = trim(from.split("/"));
            var toParts = trim(to.split("/"));
            var length = Math.min(fromParts.length, toParts.length);
            var samePartsLength = length;
            for (var i2 = 0; i2 < length; i2++) {
              if (fromParts[i2] !== toParts[i2]) {
                samePartsLength = i2;
                break;
              }
            }
            var outputParts = [];
            for (var i2 = samePartsLength; i2 < fromParts.length; i2++) {
              outputParts.push("..");
            }
            outputParts = outputParts.concat(toParts.slice(samePartsLength));
            return outputParts.join("/");
          }
        };
        var FS_stdin_getChar_buffer = [];
        var lengthBytesUTF8 = (str) => {
          var len2 = 0;
          for (var i2 = 0; i2 < str.length; ++i2) {
            var c = str.charCodeAt(i2);
            if (c <= 127) {
              len2++;
            } else if (c <= 2047) {
              len2 += 2;
            } else if (c >= 55296 && c <= 57343) {
              len2 += 4;
              ++i2;
            } else {
              len2 += 3;
            }
          }
          return len2;
        };
        var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {
          outIdx >>>= 0;
          if (!(maxBytesToWrite > 0))
            return 0;
          var startIdx = outIdx;
          var endIdx = outIdx + maxBytesToWrite - 1;
          for (var i2 = 0; i2 < str.length; ++i2) {
            var u = str.charCodeAt(i2);
            if (u >= 55296 && u <= 57343) {
              var u1 = str.charCodeAt(++i2);
              u = 65536 + ((u & 1023) << 10) | u1 & 1023;
            }
            if (u <= 127) {
              if (outIdx >= endIdx)
                break;
              heap[outIdx++ >>> 0] = u;
            } else if (u <= 2047) {
              if (outIdx + 1 >= endIdx)
                break;
              heap[outIdx++ >>> 0] = 192 | u >> 6;
              heap[outIdx++ >>> 0] = 128 | u & 63;
            } else if (u <= 65535) {
              if (outIdx + 2 >= endIdx)
                break;
              heap[outIdx++ >>> 0] = 224 | u >> 12;
              heap[outIdx++ >>> 0] = 128 | u >> 6 & 63;
              heap[outIdx++ >>> 0] = 128 | u & 63;
            } else {
              if (outIdx + 3 >= endIdx)
                break;
              heap[outIdx++ >>> 0] = 240 | u >> 18;
              heap[outIdx++ >>> 0] = 128 | u >> 12 & 63;
              heap[outIdx++ >>> 0] = 128 | u >> 6 & 63;
              heap[outIdx++ >>> 0] = 128 | u & 63;
            }
          }
          heap[outIdx >>> 0] = 0;
          return outIdx - startIdx;
        };
        function intArrayFromString(stringy, dontAddNull, length) {
          var len2 = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
          var u8array = new Array(len2);
          var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
          if (dontAddNull)
            u8array.length = numBytesWritten;
          return u8array;
        }
        var FS_stdin_getChar = () => {
          if (!FS_stdin_getChar_buffer.length) {
            var result = null;
            if (ENVIRONMENT_IS_NODE) {
              var BUFSIZE = 256;
              var buf = Buffer.alloc(BUFSIZE);
              var bytesRead = 0;
              var fd = process.stdin.fd;
              try {
                bytesRead = fs.readSync(fd, buf);
              } catch (e) {
                if (e.toString().includes("EOF"))
                  bytesRead = 0;
                else
                  throw e;
              }
              if (bytesRead > 0) {
                result = buf.slice(0, bytesRead).toString("utf-8");
              } else {
                result = null;
              }
            } else if (typeof window != "undefined" && typeof window.prompt == "function") {
              result = window.prompt("Input: ");
              if (result !== null) {
                result += "\n";
              }
            } else if (typeof readline == "function") {
              result = readline();
              if (result !== null) {
                result += "\n";
              }
            }
            if (!result) {
              return null;
            }
            FS_stdin_getChar_buffer = intArrayFromString(result, true);
          }
          return FS_stdin_getChar_buffer.shift();
        };
        var TTY = {
          ttys: [],
          init() {
          },
          shutdown() {
          },
          register(dev, ops) {
            TTY.ttys[dev] = {
              input: [],
              output: [],
              ops
            };
            FS.registerDevice(dev, TTY.stream_ops);
          },
          stream_ops: {
            open(stream) {
              var tty = TTY.ttys[stream.node.rdev];
              if (!tty) {
                throw new FS.ErrnoError(43);
              }
              stream.tty = tty;
              stream.seekable = false;
            },
            close(stream) {
              stream.tty.ops.fsync(stream.tty);
            },
            fsync(stream) {
              stream.tty.ops.fsync(stream.tty);
            },
            read(stream, buffer, offset, length, pos) {
              if (!stream.tty || !stream.tty.ops.get_char) {
                throw new FS.ErrnoError(60);
              }
              var bytesRead = 0;
              for (var i2 = 0; i2 < length; i2++) {
                var result;
                try {
                  result = stream.tty.ops.get_char(stream.tty);
                } catch (e) {
                  throw new FS.ErrnoError(29);
                }
                if (result === void 0 && bytesRead === 0) {
                  throw new FS.ErrnoError(6);
                }
                if (result === null || result === void 0)
                  break;
                bytesRead++;
                buffer[offset + i2] = result;
              }
              if (bytesRead) {
                stream.node.timestamp = Date.now();
              }
              return bytesRead;
            },
            write(stream, buffer, offset, length, pos) {
              if (!stream.tty || !stream.tty.ops.put_char) {
                throw new FS.ErrnoError(60);
              }
              try {
                for (var i2 = 0; i2 < length; i2++) {
                  stream.tty.ops.put_char(stream.tty, buffer[offset + i2]);
                }
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
              if (length) {
                stream.node.timestamp = Date.now();
              }
              return i2;
            }
          },
          default_tty_ops: {
            get_char(tty) {
              return FS_stdin_getChar();
            },
            put_char(tty, val) {
              if (val === null || val === 10) {
                out(UTF8ArrayToString(tty.output, 0));
                tty.output = [];
              } else {
                if (val != 0)
                  tty.output.push(val);
              }
            },
            fsync(tty) {
              if (tty.output && tty.output.length > 0) {
                out(UTF8ArrayToString(tty.output, 0));
                tty.output = [];
              }
            },
            ioctl_tcgets(tty) {
              return {
                c_iflag: 25856,
                c_oflag: 5,
                c_cflag: 191,
                c_lflag: 35387,
                c_cc: [3, 28, 127, 21, 4, 0, 1, 0, 17, 19, 26, 0, 18, 15, 23, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
              };
            },
            ioctl_tcsets(tty, optional_actions, data2) {
              return 0;
            },
            ioctl_tiocgwinsz(tty) {
              return [24, 80];
            }
          },
          default_tty1_ops: {
            put_char(tty, val) {
              if (val === null || val === 10) {
                err(UTF8ArrayToString(tty.output, 0));
                tty.output = [];
              } else {
                if (val != 0)
                  tty.output.push(val);
              }
            },
            fsync(tty) {
              if (tty.output && tty.output.length > 0) {
                err(UTF8ArrayToString(tty.output, 0));
                tty.output = [];
              }
            }
          }
        };
        var mmapAlloc = (size) => {
          size = alignMemory(size, 65536);
          var ptr2 = _emscripten_builtin_memalign(65536, size);
          if (!ptr2)
            return 0;
          return zeroMemory(ptr2, size);
        };
        var MEMFS = {
          ops_table: null,
          mount(mount) {
            return MEMFS.createNode(null, "/", 16384 | 511, 0);
          },
          createNode(parent, name2, mode, dev) {
            if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
              throw new FS.ErrnoError(63);
            }
            MEMFS.ops_table || (MEMFS.ops_table = {
              dir: {
                node: {
                  getattr: MEMFS.node_ops.getattr,
                  setattr: MEMFS.node_ops.setattr,
                  lookup: MEMFS.node_ops.lookup,
                  mknod: MEMFS.node_ops.mknod,
                  rename: MEMFS.node_ops.rename,
                  unlink: MEMFS.node_ops.unlink,
                  rmdir: MEMFS.node_ops.rmdir,
                  readdir: MEMFS.node_ops.readdir,
                  symlink: MEMFS.node_ops.symlink
                },
                stream: {
                  llseek: MEMFS.stream_ops.llseek
                }
              },
              file: {
                node: {
                  getattr: MEMFS.node_ops.getattr,
                  setattr: MEMFS.node_ops.setattr
                },
                stream: {
                  llseek: MEMFS.stream_ops.llseek,
                  read: MEMFS.stream_ops.read,
                  write: MEMFS.stream_ops.write,
                  allocate: MEMFS.stream_ops.allocate,
                  mmap: MEMFS.stream_ops.mmap,
                  msync: MEMFS.stream_ops.msync
                }
              },
              link: {
                node: {
                  getattr: MEMFS.node_ops.getattr,
                  setattr: MEMFS.node_ops.setattr,
                  readlink: MEMFS.node_ops.readlink
                },
                stream: {}
              },
              chrdev: {
                node: {
                  getattr: MEMFS.node_ops.getattr,
                  setattr: MEMFS.node_ops.setattr
                },
                stream: FS.chrdev_stream_ops
              }
            });
            var node = FS.createNode(parent, name2, mode, dev);
            if (FS.isDir(node.mode)) {
              node.node_ops = MEMFS.ops_table.dir.node;
              node.stream_ops = MEMFS.ops_table.dir.stream;
              node.contents = {};
            } else if (FS.isFile(node.mode)) {
              node.node_ops = MEMFS.ops_table.file.node;
              node.stream_ops = MEMFS.ops_table.file.stream;
              node.usedBytes = 0;
              node.contents = null;
            } else if (FS.isLink(node.mode)) {
              node.node_ops = MEMFS.ops_table.link.node;
              node.stream_ops = MEMFS.ops_table.link.stream;
            } else if (FS.isChrdev(node.mode)) {
              node.node_ops = MEMFS.ops_table.chrdev.node;
              node.stream_ops = MEMFS.ops_table.chrdev.stream;
            }
            node.timestamp = Date.now();
            if (parent) {
              parent.contents[name2] = node;
              parent.timestamp = node.timestamp;
            }
            return node;
          },
          getFileDataAsTypedArray(node) {
            if (!node.contents)
              return new Uint8Array(0);
            if (node.contents.subarray)
              return node.contents.subarray(0, node.usedBytes);
            return new Uint8Array(node.contents);
          },
          expandFileStorage(node, newCapacity) {
            var prevCapacity = node.contents ? node.contents.length : 0;
            if (prevCapacity >= newCapacity)
              return;
            var CAPACITY_DOUBLING_MAX = 1024 * 1024;
            newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0);
            if (prevCapacity != 0)
              newCapacity = Math.max(newCapacity, 256);
            var oldContents = node.contents;
            node.contents = new Uint8Array(newCapacity);
            if (node.usedBytes > 0)
              node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
          },
          resizeFileStorage(node, newSize) {
            if (node.usedBytes == newSize)
              return;
            if (newSize == 0) {
              node.contents = null;
              node.usedBytes = 0;
            } else {
              var oldContents = node.contents;
              node.contents = new Uint8Array(newSize);
              if (oldContents) {
                node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));
              }
              node.usedBytes = newSize;
            }
          },
          node_ops: {
            getattr(node) {
              var attr = {};
              attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
              attr.ino = node.id;
              attr.mode = node.mode;
              attr.nlink = 1;
              attr.uid = 0;
              attr.gid = 0;
              attr.rdev = node.rdev;
              if (FS.isDir(node.mode)) {
                attr.size = 4096;
              } else if (FS.isFile(node.mode)) {
                attr.size = node.usedBytes;
              } else if (FS.isLink(node.mode)) {
                attr.size = node.link.length;
              } else {
                attr.size = 0;
              }
              attr.atime = new Date(node.timestamp);
              attr.mtime = new Date(node.timestamp);
              attr.ctime = new Date(node.timestamp);
              attr.blksize = 4096;
              attr.blocks = Math.ceil(attr.size / attr.blksize);
              return attr;
            },
            setattr(node, attr) {
              if (attr.mode !== void 0) {
                node.mode = attr.mode;
              }
              if (attr.timestamp !== void 0) {
                node.timestamp = attr.timestamp;
              }
              if (attr.size !== void 0) {
                MEMFS.resizeFileStorage(node, attr.size);
              }
            },
            lookup(parent, name2) {
              throw FS.genericErrors[44];
            },
            mknod(parent, name2, mode, dev) {
              return MEMFS.createNode(parent, name2, mode, dev);
            },
            rename(old_node, new_dir, new_name) {
              if (FS.isDir(old_node.mode)) {
                var new_node;
                try {
                  new_node = FS.lookupNode(new_dir, new_name);
                } catch (e) {
                }
                if (new_node) {
                  for (var i2 in new_node.contents) {
                    throw new FS.ErrnoError(55);
                  }
                }
              }
              delete old_node.parent.contents[old_node.name];
              old_node.parent.timestamp = Date.now();
              old_node.name = new_name;
              new_dir.contents[new_name] = old_node;
              new_dir.timestamp = old_node.parent.timestamp;
              old_node.parent = new_dir;
            },
            unlink(parent, name2) {
              delete parent.contents[name2];
              parent.timestamp = Date.now();
            },
            rmdir(parent, name2) {
              var node = FS.lookupNode(parent, name2);
              for (var i2 in node.contents) {
                throw new FS.ErrnoError(55);
              }
              delete parent.contents[name2];
              parent.timestamp = Date.now();
            },
            readdir(node) {
              var entries = [".", ".."];
              for (var key of Object.keys(node.contents)) {
                entries.push(key);
              }
              return entries;
            },
            symlink(parent, newname, oldpath) {
              var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
              node.link = oldpath;
              return node;
            },
            readlink(node) {
              if (!FS.isLink(node.mode)) {
                throw new FS.ErrnoError(28);
              }
              return node.link;
            }
          },
          stream_ops: {
            read(stream, buffer, offset, length, position) {
              var contents = stream.node.contents;
              if (position >= stream.node.usedBytes)
                return 0;
              var size = Math.min(stream.node.usedBytes - position, length);
              if (size > 8 && contents.subarray) {
                buffer.set(contents.subarray(position, position + size), offset);
              } else {
                for (var i2 = 0; i2 < size; i2++)
                  buffer[offset + i2] = contents[position + i2];
              }
              return size;
            },
            write(stream, buffer, offset, length, position, canOwn) {
              if (buffer.buffer === HEAP8.buffer) {
                canOwn = false;
              }
              if (!length)
                return 0;
              var node = stream.node;
              node.timestamp = Date.now();
              if (buffer.subarray && (!node.contents || node.contents.subarray)) {
                if (canOwn) {
                  node.contents = buffer.subarray(offset, offset + length);
                  node.usedBytes = length;
                  return length;
                } else if (node.usedBytes === 0 && position === 0) {
                  node.contents = buffer.slice(offset, offset + length);
                  node.usedBytes = length;
                  return length;
                } else if (position + length <= node.usedBytes) {
                  node.contents.set(buffer.subarray(offset, offset + length), position);
                  return length;
                }
              }
              MEMFS.expandFileStorage(node, position + length);
              if (node.contents.subarray && buffer.subarray) {
                node.contents.set(buffer.subarray(offset, offset + length), position);
              } else {
                for (var i2 = 0; i2 < length; i2++) {
                  node.contents[position + i2] = buffer[offset + i2];
                }
              }
              node.usedBytes = Math.max(node.usedBytes, position + length);
              return length;
            },
            llseek(stream, offset, whence) {
              var position = offset;
              if (whence === 1) {
                position += stream.position;
              } else if (whence === 2) {
                if (FS.isFile(stream.node.mode)) {
                  position += stream.node.usedBytes;
                }
              }
              if (position < 0) {
                throw new FS.ErrnoError(28);
              }
              return position;
            },
            allocate(stream, offset, length) {
              MEMFS.expandFileStorage(stream.node, offset + length);
              stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
            },
            mmap(stream, length, position, prot, flags2) {
              if (!FS.isFile(stream.node.mode)) {
                throw new FS.ErrnoError(43);
              }
              var ptr2;
              var allocated;
              var contents = stream.node.contents;
              if (!(flags2 & 2) && contents.buffer === HEAP8.buffer) {
                allocated = false;
                ptr2 = contents.byteOffset;
              } else {
                if (position > 0 || position + length < contents.length) {
                  if (contents.subarray) {
                    contents = contents.subarray(position, position + length);
                  } else {
                    contents = Array.prototype.slice.call(contents, position, position + length);
                  }
                }
                allocated = true;
                ptr2 = mmapAlloc(length);
                if (!ptr2) {
                  throw new FS.ErrnoError(48);
                }
                HEAP8.set(contents, ptr2 >>> 0);
              }
              return {
                ptr: ptr2,
                allocated
              };
            },
            msync(stream, buffer, offset, length, mmapFlags) {
              MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);
              return 0;
            }
          }
        };
        var FS_createDataFile = (parent, name2, fileData, canRead, canWrite, canOwn) => {
          FS.createDataFile(parent, name2, fileData, canRead, canWrite, canOwn);
        };
        var FS_handledByPreloadPlugin = (byteArray, fullname, finish, onerror2) => {
          if (typeof Browser != "undefined")
            Browser.init();
          var handled = false;
          preloadPlugins.forEach((plugin) => {
            if (handled)
              return;
            if (plugin["canHandle"](fullname)) {
              plugin["handle"](byteArray, fullname, finish, onerror2);
              handled = true;
            }
          });
          return handled;
        };
        var FS_createPreloadedFile = (parent, name2, url2, canRead, canWrite, onload2, onerror2, dontCreateFile, canOwn, preFinish) => {
          var fullname = name2 ? PATH_FS.resolve(PATH.join2(parent, name2)) : parent;
          var dep = getUniqueRunDependency(`cp ${fullname}`);
          function processData(byteArray) {
            function finish(byteArray2) {
              preFinish == null ? void 0 : preFinish();
              if (!dontCreateFile) {
                FS_createDataFile(parent, name2, byteArray2, canRead, canWrite, canOwn);
              }
              onload2 == null ? void 0 : onload2();
              removeRunDependency(dep);
            }
            if (FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {
              onerror2 == null ? void 0 : onerror2();
              removeRunDependency(dep);
            })) {
              return;
            }
            finish(byteArray);
          }
          addRunDependency(dep);
          if (typeof url2 == "string") {
            asyncLoad(url2, processData, onerror2);
          } else {
            processData(url2);
          }
        };
        var FS_modeStringToFlags = (str) => {
          var flagModes = {
            "r": 0,
            "r+": 2,
            "w": 512 | 64 | 1,
            "w+": 512 | 64 | 2,
            "a": 1024 | 64 | 1,
            "a+": 1024 | 64 | 2
          };
          var flags2 = flagModes[str];
          if (typeof flags2 == "undefined") {
            throw new Error(`Unknown file open mode: ${str}`);
          }
          return flags2;
        };
        var FS_getMode = (canRead, canWrite) => {
          var mode = 0;
          if (canRead)
            mode |= 292 | 73;
          if (canWrite)
            mode |= 146;
          return mode;
        };
        var FS = {
          root: null,
          mounts: [],
          devices: {},
          streams: [],
          nextInode: 1,
          nameTable: null,
          currentPath: "/",
          initialized: false,
          ignorePermissions: true,
          ErrnoError: null,
          genericErrors: {},
          filesystems: null,
          syncFSRequests: 0,
          lookupPath(path2, opts = {}) {
            path2 = PATH_FS.resolve(path2);
            if (!path2)
              return {
                path: "",
                node: null
              };
            var defaults = {
              follow_mount: true,
              recurse_count: 0
            };
            opts = Object.assign(defaults, opts);
            if (opts.recurse_count > 8) {
              throw new FS.ErrnoError(32);
            }
            var parts2 = path2.split("/").filter((p) => !!p);
            var current = FS.root;
            var current_path = "/";
            for (var i2 = 0; i2 < parts2.length; i2++) {
              var islast = i2 === parts2.length - 1;
              if (islast && opts.parent) {
                break;
              }
              current = FS.lookupNode(current, parts2[i2]);
              current_path = PATH.join2(current_path, parts2[i2]);
              if (FS.isMountpoint(current)) {
                if (!islast || islast && opts.follow_mount) {
                  current = current.mounted.root;
                }
              }
              if (!islast || opts.follow) {
                var count = 0;
                while (FS.isLink(current.mode)) {
                  var link = FS.readlink(current_path);
                  current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
                  var lookup = FS.lookupPath(current_path, {
                    recurse_count: opts.recurse_count + 1
                  });
                  current = lookup.node;
                  if (count++ > 40) {
                    throw new FS.ErrnoError(32);
                  }
                }
              }
            }
            return {
              path: current_path,
              node: current
            };
          },
          getPath(node) {
            var path2;
            while (true) {
              if (FS.isRoot(node)) {
                var mount = node.mount.mountpoint;
                if (!path2)
                  return mount;
                return mount[mount.length - 1] !== "/" ? `${mount}/${path2}` : mount + path2;
              }
              path2 = path2 ? `${node.name}/${path2}` : node.name;
              node = node.parent;
            }
          },
          hashName(parentid, name2) {
            var hash = 0;
            for (var i2 = 0; i2 < name2.length; i2++) {
              hash = (hash << 5) - hash + name2.charCodeAt(i2) | 0;
            }
            return (parentid + hash >>> 0) % FS.nameTable.length;
          },
          hashAddNode(node) {
            var hash = FS.hashName(node.parent.id, node.name);
            node.name_next = FS.nameTable[hash];
            FS.nameTable[hash] = node;
          },
          hashRemoveNode(node) {
            var hash = FS.hashName(node.parent.id, node.name);
            if (FS.nameTable[hash] === node) {
              FS.nameTable[hash] = node.name_next;
            } else {
              var current = FS.nameTable[hash];
              while (current) {
                if (current.name_next === node) {
                  current.name_next = node.name_next;
                  break;
                }
                current = current.name_next;
              }
            }
          },
          lookupNode(parent, name2) {
            var errCode = FS.mayLookup(parent);
            if (errCode) {
              throw new FS.ErrnoError(errCode, parent);
            }
            var hash = FS.hashName(parent.id, name2);
            for (var node = FS.nameTable[hash]; node; node = node.name_next) {
              var nodeName = node.name;
              if (node.parent.id === parent.id && nodeName === name2) {
                return node;
              }
            }
            return FS.lookup(parent, name2);
          },
          createNode(parent, name2, mode, rdev) {
            var node = new FS.FSNode(parent, name2, mode, rdev);
            FS.hashAddNode(node);
            return node;
          },
          destroyNode(node) {
            FS.hashRemoveNode(node);
          },
          isRoot(node) {
            return node === node.parent;
          },
          isMountpoint(node) {
            return !!node.mounted;
          },
          isFile(mode) {
            return (mode & 61440) === 32768;
          },
          isDir(mode) {
            return (mode & 61440) === 16384;
          },
          isLink(mode) {
            return (mode & 61440) === 40960;
          },
          isChrdev(mode) {
            return (mode & 61440) === 8192;
          },
          isBlkdev(mode) {
            return (mode & 61440) === 24576;
          },
          isFIFO(mode) {
            return (mode & 61440) === 4096;
          },
          isSocket(mode) {
            return (mode & 49152) === 49152;
          },
          flagsToPermissionString(flag) {
            var perms = ["r", "w", "rw"][flag & 3];
            if (flag & 512) {
              perms += "w";
            }
            return perms;
          },
          nodePermissions(node, perms) {
            if (FS.ignorePermissions) {
              return 0;
            }
            if (perms.includes("r") && !(node.mode & 292)) {
              return 2;
            } else if (perms.includes("w") && !(node.mode & 146)) {
              return 2;
            } else if (perms.includes("x") && !(node.mode & 73)) {
              return 2;
            }
            return 0;
          },
          mayLookup(dir) {
            var errCode = FS.nodePermissions(dir, "x");
            if (errCode)
              return errCode;
            if (!dir.node_ops.lookup)
              return 2;
            return 0;
          },
          mayCreate(dir, name2) {
            try {
              var node = FS.lookupNode(dir, name2);
              return 20;
            } catch (e) {
            }
            return FS.nodePermissions(dir, "wx");
          },
          mayDelete(dir, name2, isdir) {
            var node;
            try {
              node = FS.lookupNode(dir, name2);
            } catch (e) {
              return e.errno;
            }
            var errCode = FS.nodePermissions(dir, "wx");
            if (errCode) {
              return errCode;
            }
            if (isdir) {
              if (!FS.isDir(node.mode)) {
                return 54;
              }
              if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
                return 10;
              }
            } else {
              if (FS.isDir(node.mode)) {
                return 31;
              }
            }
            return 0;
          },
          mayOpen(node, flags2) {
            if (!node) {
              return 44;
            }
            if (FS.isLink(node.mode)) {
              return 32;
            } else if (FS.isDir(node.mode)) {
              if (FS.flagsToPermissionString(flags2) !== "r" || flags2 & 512) {
                return 31;
              }
            }
            return FS.nodePermissions(node, FS.flagsToPermissionString(flags2));
          },
          MAX_OPEN_FDS: 4096,
          nextfd() {
            for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {
              if (!FS.streams[fd]) {
                return fd;
              }
            }
            throw new FS.ErrnoError(33);
          },
          getStreamChecked(fd) {
            var stream = FS.getStream(fd);
            if (!stream) {
              throw new FS.ErrnoError(8);
            }
            return stream;
          },
          getStream: (fd) => FS.streams[fd],
          createStream(stream, fd = -1) {
            if (!FS.FSStream) {
              FS.FSStream = function() {
                this.shared = {};
              };
              FS.FSStream.prototype = {};
              Object.defineProperties(FS.FSStream.prototype, {
                object: {
                  get() {
                    return this.node;
                  },
                  set(val) {
                    this.node = val;
                  }
                },
                isRead: {
                  get() {
                    return (this.flags & 2097155) !== 1;
                  }
                },
                isWrite: {
                  get() {
                    return (this.flags & 2097155) !== 0;
                  }
                },
                isAppend: {
                  get() {
                    return this.flags & 1024;
                  }
                },
                flags: {
                  get() {
                    return this.shared.flags;
                  },
                  set(val) {
                    this.shared.flags = val;
                  }
                },
                position: {
                  get() {
                    return this.shared.position;
                  },
                  set(val) {
                    this.shared.position = val;
                  }
                }
              });
            }
            stream = Object.assign(new FS.FSStream(), stream);
            if (fd == -1) {
              fd = FS.nextfd();
            }
            stream.fd = fd;
            FS.streams[fd] = stream;
            return stream;
          },
          closeStream(fd) {
            FS.streams[fd] = null;
          },
          chrdev_stream_ops: {
            open(stream) {
              var _a, _b;
              var device = FS.getDevice(stream.node.rdev);
              stream.stream_ops = device.stream_ops;
              (_b = (_a = stream.stream_ops).open) == null ? void 0 : _b.call(_a, stream);
            },
            llseek() {
              throw new FS.ErrnoError(70);
            }
          },
          major: (dev) => dev >> 8,
          minor: (dev) => dev & 255,
          makedev: (ma, mi) => ma << 8 | mi,
          registerDevice(dev, ops) {
            FS.devices[dev] = {
              stream_ops: ops
            };
          },
          getDevice: (dev) => FS.devices[dev],
          getMounts(mount) {
            var mounts = [];
            var check = [mount];
            while (check.length) {
              var m = check.pop();
              mounts.push(m);
              check.push.apply(check, m.mounts);
            }
            return mounts;
          },
          syncfs(populate, callback) {
            if (typeof populate == "function") {
              callback = populate;
              populate = false;
            }
            FS.syncFSRequests++;
            if (FS.syncFSRequests > 1) {
              err(`warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`);
            }
            var mounts = FS.getMounts(FS.root.mount);
            var completed = 0;
            function doCallback(errCode) {
              FS.syncFSRequests--;
              return callback(errCode);
            }
            function done(errCode) {
              if (errCode) {
                if (!done.errored) {
                  done.errored = true;
                  return doCallback(errCode);
                }
                return;
              }
              if (++completed >= mounts.length) {
                doCallback(null);
              }
            }
            mounts.forEach((mount) => {
              if (!mount.type.syncfs) {
                return done(null);
              }
              mount.type.syncfs(mount, populate, done);
            });
          },
          mount(type, opts, mountpoint) {
            var root = mountpoint === "/";
            var pseudo = !mountpoint;
            var node;
            if (root && FS.root) {
              throw new FS.ErrnoError(10);
            } else if (!root && !pseudo) {
              var lookup = FS.lookupPath(mountpoint, {
                follow_mount: false
              });
              mountpoint = lookup.path;
              node = lookup.node;
              if (FS.isMountpoint(node)) {
                throw new FS.ErrnoError(10);
              }
              if (!FS.isDir(node.mode)) {
                throw new FS.ErrnoError(54);
              }
            }
            var mount = {
              type,
              opts,
              mountpoint,
              mounts: []
            };
            var mountRoot = type.mount(mount);
            mountRoot.mount = mount;
            mount.root = mountRoot;
            if (root) {
              FS.root = mountRoot;
            } else if (node) {
              node.mounted = mount;
              if (node.mount) {
                node.mount.mounts.push(mount);
              }
            }
            return mountRoot;
          },
          unmount(mountpoint) {
            var lookup = FS.lookupPath(mountpoint, {
              follow_mount: false
            });
            if (!FS.isMountpoint(lookup.node)) {
              throw new FS.ErrnoError(28);
            }
            var node = lookup.node;
            var mount = node.mounted;
            var mounts = FS.getMounts(mount);
            Object.keys(FS.nameTable).forEach((hash) => {
              var current = FS.nameTable[hash];
              while (current) {
                var next = current.name_next;
                if (mounts.includes(current.mount)) {
                  FS.destroyNode(current);
                }
                current = next;
              }
            });
            node.mounted = null;
            var idx = node.mount.mounts.indexOf(mount);
            node.mount.mounts.splice(idx, 1);
          },
          lookup(parent, name2) {
            return parent.node_ops.lookup(parent, name2);
          },
          mknod(path2, mode, dev) {
            var lookup = FS.lookupPath(path2, {
              parent: true
            });
            var parent = lookup.node;
            var name2 = PATH.basename(path2);
            if (!name2 || name2 === "." || name2 === "..") {
              throw new FS.ErrnoError(28);
            }
            var errCode = FS.mayCreate(parent, name2);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            if (!parent.node_ops.mknod) {
              throw new FS.ErrnoError(63);
            }
            return parent.node_ops.mknod(parent, name2, mode, dev);
          },
          create(path2, mode) {
            mode = mode !== void 0 ? mode : 438;
            mode &= 4095;
            mode |= 32768;
            return FS.mknod(path2, mode, 0);
          },
          mkdir(path2, mode) {
            mode = mode !== void 0 ? mode : 511;
            mode &= 511 | 512;
            mode |= 16384;
            return FS.mknod(path2, mode, 0);
          },
          mkdirTree(path2, mode) {
            var dirs = path2.split("/");
            var d = "";
            for (var i2 = 0; i2 < dirs.length; ++i2) {
              if (!dirs[i2])
                continue;
              d += "/" + dirs[i2];
              try {
                FS.mkdir(d, mode);
              } catch (e) {
                if (e.errno != 20)
                  throw e;
              }
            }
          },
          mkdev(path2, mode, dev) {
            if (typeof dev == "undefined") {
              dev = mode;
              mode = 438;
            }
            mode |= 8192;
            return FS.mknod(path2, mode, dev);
          },
          symlink(oldpath, newpath) {
            if (!PATH_FS.resolve(oldpath)) {
              throw new FS.ErrnoError(44);
            }
            var lookup = FS.lookupPath(newpath, {
              parent: true
            });
            var parent = lookup.node;
            if (!parent) {
              throw new FS.ErrnoError(44);
            }
            var newname = PATH.basename(newpath);
            var errCode = FS.mayCreate(parent, newname);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            if (!parent.node_ops.symlink) {
              throw new FS.ErrnoError(63);
            }
            return parent.node_ops.symlink(parent, newname, oldpath);
          },
          rename(old_path, new_path) {
            var old_dirname = PATH.dirname(old_path);
            var new_dirname = PATH.dirname(new_path);
            var old_name = PATH.basename(old_path);
            var new_name = PATH.basename(new_path);
            var lookup, old_dir, new_dir;
            lookup = FS.lookupPath(old_path, {
              parent: true
            });
            old_dir = lookup.node;
            lookup = FS.lookupPath(new_path, {
              parent: true
            });
            new_dir = lookup.node;
            if (!old_dir || !new_dir)
              throw new FS.ErrnoError(44);
            if (old_dir.mount !== new_dir.mount) {
              throw new FS.ErrnoError(75);
            }
            var old_node = FS.lookupNode(old_dir, old_name);
            var relative = PATH_FS.relative(old_path, new_dirname);
            if (relative.charAt(0) !== ".") {
              throw new FS.ErrnoError(28);
            }
            relative = PATH_FS.relative(new_path, old_dirname);
            if (relative.charAt(0) !== ".") {
              throw new FS.ErrnoError(55);
            }
            var new_node;
            try {
              new_node = FS.lookupNode(new_dir, new_name);
            } catch (e) {
            }
            if (old_node === new_node) {
              return;
            }
            var isdir = FS.isDir(old_node.mode);
            var errCode = FS.mayDelete(old_dir, old_name, isdir);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            if (!old_dir.node_ops.rename) {
              throw new FS.ErrnoError(63);
            }
            if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
              throw new FS.ErrnoError(10);
            }
            if (new_dir !== old_dir) {
              errCode = FS.nodePermissions(old_dir, "w");
              if (errCode) {
                throw new FS.ErrnoError(errCode);
              }
            }
            FS.hashRemoveNode(old_node);
            try {
              old_dir.node_ops.rename(old_node, new_dir, new_name);
            } catch (e) {
              throw e;
            } finally {
              FS.hashAddNode(old_node);
            }
          },
          rmdir(path2) {
            var lookup = FS.lookupPath(path2, {
              parent: true
            });
            var parent = lookup.node;
            var name2 = PATH.basename(path2);
            var node = FS.lookupNode(parent, name2);
            var errCode = FS.mayDelete(parent, name2, true);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            if (!parent.node_ops.rmdir) {
              throw new FS.ErrnoError(63);
            }
            if (FS.isMountpoint(node)) {
              throw new FS.ErrnoError(10);
            }
            parent.node_ops.rmdir(parent, name2);
            FS.destroyNode(node);
          },
          readdir(path2) {
            var lookup = FS.lookupPath(path2, {
              follow: true
            });
            var node = lookup.node;
            if (!node.node_ops.readdir) {
              throw new FS.ErrnoError(54);
            }
            return node.node_ops.readdir(node);
          },
          unlink(path2) {
            var lookup = FS.lookupPath(path2, {
              parent: true
            });
            var parent = lookup.node;
            if (!parent) {
              throw new FS.ErrnoError(44);
            }
            var name2 = PATH.basename(path2);
            var node = FS.lookupNode(parent, name2);
            var errCode = FS.mayDelete(parent, name2, false);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            if (!parent.node_ops.unlink) {
              throw new FS.ErrnoError(63);
            }
            if (FS.isMountpoint(node)) {
              throw new FS.ErrnoError(10);
            }
            parent.node_ops.unlink(parent, name2);
            FS.destroyNode(node);
          },
          readlink(path2) {
            var lookup = FS.lookupPath(path2);
            var link = lookup.node;
            if (!link) {
              throw new FS.ErrnoError(44);
            }
            if (!link.node_ops.readlink) {
              throw new FS.ErrnoError(28);
            }
            return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
          },
          stat(path2, dontFollow) {
            var lookup = FS.lookupPath(path2, {
              follow: !dontFollow
            });
            var node = lookup.node;
            if (!node) {
              throw new FS.ErrnoError(44);
            }
            if (!node.node_ops.getattr) {
              throw new FS.ErrnoError(63);
            }
            return node.node_ops.getattr(node);
          },
          lstat(path2) {
            return FS.stat(path2, true);
          },
          chmod(path2, mode, dontFollow) {
            var node;
            if (typeof path2 == "string") {
              var lookup = FS.lookupPath(path2, {
                follow: !dontFollow
              });
              node = lookup.node;
            } else {
              node = path2;
            }
            if (!node.node_ops.setattr) {
              throw new FS.ErrnoError(63);
            }
            node.node_ops.setattr(node, {
              mode: mode & 4095 | node.mode & ~4095,
              timestamp: Date.now()
            });
          },
          lchmod(path2, mode) {
            FS.chmod(path2, mode, true);
          },
          fchmod(fd, mode) {
            var stream = FS.getStreamChecked(fd);
            FS.chmod(stream.node, mode);
          },
          chown(path2, uid, gid, dontFollow) {
            var node;
            if (typeof path2 == "string") {
              var lookup = FS.lookupPath(path2, {
                follow: !dontFollow
              });
              node = lookup.node;
            } else {
              node = path2;
            }
            if (!node.node_ops.setattr) {
              throw new FS.ErrnoError(63);
            }
            node.node_ops.setattr(node, {
              timestamp: Date.now()
            });
          },
          lchown(path2, uid, gid) {
            FS.chown(path2, uid, gid, true);
          },
          fchown(fd, uid, gid) {
            var stream = FS.getStreamChecked(fd);
            FS.chown(stream.node, uid, gid);
          },
          truncate(path2, len2) {
            if (len2 < 0) {
              throw new FS.ErrnoError(28);
            }
            var node;
            if (typeof path2 == "string") {
              var lookup = FS.lookupPath(path2, {
                follow: true
              });
              node = lookup.node;
            } else {
              node = path2;
            }
            if (!node.node_ops.setattr) {
              throw new FS.ErrnoError(63);
            }
            if (FS.isDir(node.mode)) {
              throw new FS.ErrnoError(31);
            }
            if (!FS.isFile(node.mode)) {
              throw new FS.ErrnoError(28);
            }
            var errCode = FS.nodePermissions(node, "w");
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            node.node_ops.setattr(node, {
              size: len2,
              timestamp: Date.now()
            });
          },
          ftruncate(fd, len2) {
            var stream = FS.getStreamChecked(fd);
            if ((stream.flags & 2097155) === 0) {
              throw new FS.ErrnoError(28);
            }
            FS.truncate(stream.node, len2);
          },
          utime(path2, atime, mtime) {
            var lookup = FS.lookupPath(path2, {
              follow: true
            });
            var node = lookup.node;
            node.node_ops.setattr(node, {
              timestamp: Math.max(atime, mtime)
            });
          },
          open(path2, flags2, mode) {
            if (path2 === "") {
              throw new FS.ErrnoError(44);
            }
            flags2 = typeof flags2 == "string" ? FS_modeStringToFlags(flags2) : flags2;
            mode = typeof mode == "undefined" ? 438 : mode;
            if (flags2 & 64) {
              mode = mode & 4095 | 32768;
            } else {
              mode = 0;
            }
            var node;
            if (typeof path2 == "object") {
              node = path2;
            } else {
              path2 = PATH.normalize(path2);
              try {
                var lookup = FS.lookupPath(path2, {
                  follow: !(flags2 & 131072)
                });
                node = lookup.node;
              } catch (e) {
              }
            }
            var created = false;
            if (flags2 & 64) {
              if (node) {
                if (flags2 & 128) {
                  throw new FS.ErrnoError(20);
                }
              } else {
                node = FS.mknod(path2, mode, 0);
                created = true;
              }
            }
            if (!node) {
              throw new FS.ErrnoError(44);
            }
            if (FS.isChrdev(node.mode)) {
              flags2 &= ~512;
            }
            if (flags2 & 65536 && !FS.isDir(node.mode)) {
              throw new FS.ErrnoError(54);
            }
            if (!created) {
              var errCode = FS.mayOpen(node, flags2);
              if (errCode) {
                throw new FS.ErrnoError(errCode);
              }
            }
            if (flags2 & 512 && !created) {
              FS.truncate(node, 0);
            }
            flags2 &= ~(128 | 512 | 131072);
            var stream = FS.createStream({
              node,
              path: FS.getPath(node),
              flags: flags2,
              seekable: true,
              position: 0,
              stream_ops: node.stream_ops,
              ungotten: [],
              error: false
            });
            if (stream.stream_ops.open) {
              stream.stream_ops.open(stream);
            }
            if (Module["logReadFiles"] && !(flags2 & 1)) {
              if (!FS.readFiles)
                FS.readFiles = {};
              if (!(path2 in FS.readFiles)) {
                FS.readFiles[path2] = 1;
              }
            }
            return stream;
          },
          close(stream) {
            if (FS.isClosed(stream)) {
              throw new FS.ErrnoError(8);
            }
            if (stream.getdents)
              stream.getdents = null;
            try {
              if (stream.stream_ops.close) {
                stream.stream_ops.close(stream);
              }
            } catch (e) {
              throw e;
            } finally {
              FS.closeStream(stream.fd);
            }
            stream.fd = null;
          },
          isClosed(stream) {
            return stream.fd === null;
          },
          llseek(stream, offset, whence) {
            if (FS.isClosed(stream)) {
              throw new FS.ErrnoError(8);
            }
            if (!stream.seekable || !stream.stream_ops.llseek) {
              throw new FS.ErrnoError(70);
            }
            if (whence != 0 && whence != 1 && whence != 2) {
              throw new FS.ErrnoError(28);
            }
            stream.position = stream.stream_ops.llseek(stream, offset, whence);
            stream.ungotten = [];
            return stream.position;
          },
          read(stream, buffer, offset, length, position) {
            if (length < 0 || position < 0) {
              throw new FS.ErrnoError(28);
            }
            if (FS.isClosed(stream)) {
              throw new FS.ErrnoError(8);
            }
            if ((stream.flags & 2097155) === 1) {
              throw new FS.ErrnoError(8);
            }
            if (FS.isDir(stream.node.mode)) {
              throw new FS.ErrnoError(31);
            }
            if (!stream.stream_ops.read) {
              throw new FS.ErrnoError(28);
            }
            var seeking = typeof position != "undefined";
            if (!seeking) {
              position = stream.position;
            } else if (!stream.seekable) {
              throw new FS.ErrnoError(70);
            }
            var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
            if (!seeking)
              stream.position += bytesRead;
            return bytesRead;
          },
          write(stream, buffer, offset, length, position, canOwn) {
            if (length < 0 || position < 0) {
              throw new FS.ErrnoError(28);
            }
            if (FS.isClosed(stream)) {
              throw new FS.ErrnoError(8);
            }
            if ((stream.flags & 2097155) === 0) {
              throw new FS.ErrnoError(8);
            }
            if (FS.isDir(stream.node.mode)) {
              throw new FS.ErrnoError(31);
            }
            if (!stream.stream_ops.write) {
              throw new FS.ErrnoError(28);
            }
            if (stream.seekable && stream.flags & 1024) {
              FS.llseek(stream, 0, 2);
            }
            var seeking = typeof position != "undefined";
            if (!seeking) {
              position = stream.position;
            } else if (!stream.seekable) {
              throw new FS.ErrnoError(70);
            }
            var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
            if (!seeking)
              stream.position += bytesWritten;
            return bytesWritten;
          },
          allocate(stream, offset, length) {
            if (FS.isClosed(stream)) {
              throw new FS.ErrnoError(8);
            }
            if (offset < 0 || length <= 0) {
              throw new FS.ErrnoError(28);
            }
            if ((stream.flags & 2097155) === 0) {
              throw new FS.ErrnoError(8);
            }
            if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
              throw new FS.ErrnoError(43);
            }
            if (!stream.stream_ops.allocate) {
              throw new FS.ErrnoError(138);
            }
            stream.stream_ops.allocate(stream, offset, length);
          },
          mmap(stream, length, position, prot, flags2) {
            if ((prot & 2) !== 0 && (flags2 & 2) === 0 && (stream.flags & 2097155) !== 2) {
              throw new FS.ErrnoError(2);
            }
            if ((stream.flags & 2097155) === 1) {
              throw new FS.ErrnoError(2);
            }
            if (!stream.stream_ops.mmap) {
              throw new FS.ErrnoError(43);
            }
            return stream.stream_ops.mmap(stream, length, position, prot, flags2);
          },
          msync(stream, buffer, offset, length, mmapFlags) {
            if (!stream.stream_ops.msync) {
              return 0;
            }
            return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);
          },
          munmap: (stream) => 0,
          ioctl(stream, cmd, arg) {
            if (!stream.stream_ops.ioctl) {
              throw new FS.ErrnoError(59);
            }
            return stream.stream_ops.ioctl(stream, cmd, arg);
          },
          readFile(path2, opts = {}) {
            opts.flags = opts.flags || 0;
            opts.encoding = opts.encoding || "binary";
            if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
              throw new Error(`Invalid encoding type "${opts.encoding}"`);
            }
            var ret;
            var stream = FS.open(path2, opts.flags);
            var stat = FS.stat(path2);
            var length = stat.size;
            var buf = new Uint8Array(length);
            FS.read(stream, buf, 0, length, 0);
            if (opts.encoding === "utf8") {
              ret = UTF8ArrayToString(buf, 0);
            } else if (opts.encoding === "binary") {
              ret = buf;
            }
            FS.close(stream);
            return ret;
          },
          writeFile(path2, data2, opts = {}) {
            opts.flags = opts.flags || 577;
            var stream = FS.open(path2, opts.flags, opts.mode);
            if (typeof data2 == "string") {
              var buf = new Uint8Array(lengthBytesUTF8(data2) + 1);
              var actualNumBytes = stringToUTF8Array(data2, buf, 0, buf.length);
              FS.write(stream, buf, 0, actualNumBytes, void 0, opts.canOwn);
            } else if (ArrayBuffer.isView(data2)) {
              FS.write(stream, data2, 0, data2.byteLength, void 0, opts.canOwn);
            } else {
              throw new Error("Unsupported data type");
            }
            FS.close(stream);
          },
          cwd: () => FS.currentPath,
          chdir(path2) {
            var lookup = FS.lookupPath(path2, {
              follow: true
            });
            if (lookup.node === null) {
              throw new FS.ErrnoError(44);
            }
            if (!FS.isDir(lookup.node.mode)) {
              throw new FS.ErrnoError(54);
            }
            var errCode = FS.nodePermissions(lookup.node, "x");
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            FS.currentPath = lookup.path;
          },
          createDefaultDirectories() {
            FS.mkdir("/tmp");
            FS.mkdir("/home");
            FS.mkdir("/home/web_user");
          },
          createDefaultDevices() {
            FS.mkdir("/dev");
            FS.registerDevice(FS.makedev(1, 3), {
              read: () => 0,
              write: (stream, buffer, offset, length, pos) => length
            });
            FS.mkdev("/dev/null", FS.makedev(1, 3));
            TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
            TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
            FS.mkdev("/dev/tty", FS.makedev(5, 0));
            FS.mkdev("/dev/tty1", FS.makedev(6, 0));
            var randomBuffer = new Uint8Array(1024), randomLeft = 0;
            var randomByte = () => {
              if (randomLeft === 0) {
                randomLeft = randomFill(randomBuffer).byteLength;
              }
              return randomBuffer[--randomLeft];
            };
            FS.createDevice("/dev", "random", randomByte);
            FS.createDevice("/dev", "urandom", randomByte);
            FS.mkdir("/dev/shm");
            FS.mkdir("/dev/shm/tmp");
          },
          createSpecialDirectories() {
            FS.mkdir("/proc");
            var proc_self = FS.mkdir("/proc/self");
            FS.mkdir("/proc/self/fd");
            FS.mount({
              mount() {
                var node = FS.createNode(proc_self, "fd", 16384 | 511, 73);
                node.node_ops = {
                  lookup(parent, name2) {
                    var fd = +name2;
                    var stream = FS.getStreamChecked(fd);
                    var ret = {
                      parent: null,
                      mount: {
                        mountpoint: "fake"
                      },
                      node_ops: {
                        readlink: () => stream.path
                      }
                    };
                    ret.parent = ret;
                    return ret;
                  }
                };
                return node;
              }
            }, {}, "/proc/self/fd");
          },
          createStandardStreams() {
            if (Module["stdin"]) {
              FS.createDevice("/dev", "stdin", Module["stdin"]);
            } else {
              FS.symlink("/dev/tty", "/dev/stdin");
            }
            if (Module["stdout"]) {
              FS.createDevice("/dev", "stdout", null, Module["stdout"]);
            } else {
              FS.symlink("/dev/tty", "/dev/stdout");
            }
            if (Module["stderr"]) {
              FS.createDevice("/dev", "stderr", null, Module["stderr"]);
            } else {
              FS.symlink("/dev/tty1", "/dev/stderr");
            }
            var stdin = FS.open("/dev/stdin", 0);
            var stdout = FS.open("/dev/stdout", 1);
            var stderr = FS.open("/dev/stderr", 1);
          },
          ensureErrnoError() {
            if (FS.ErrnoError)
              return;
            FS.ErrnoError = function ErrnoError(errno, node) {
              this.name = "ErrnoError";
              this.node = node;
              this.setErrno = function(errno2) {
                this.errno = errno2;
              };
              this.setErrno(errno);
              this.message = "FS error";
            };
            FS.ErrnoError.prototype = new Error();
            FS.ErrnoError.prototype.constructor = FS.ErrnoError;
            [44].forEach((code) => {
              FS.genericErrors[code] = new FS.ErrnoError(code);
              FS.genericErrors[code].stack = "<generic error, no stack>";
            });
          },
          staticInit() {
            FS.ensureErrnoError();
            FS.nameTable = new Array(4096);
            FS.mount(MEMFS, {}, "/");
            FS.createDefaultDirectories();
            FS.createDefaultDevices();
            FS.createSpecialDirectories();
            FS.filesystems = {
              "MEMFS": MEMFS
            };
          },
          init(input, output, error) {
            FS.init.initialized = true;
            FS.ensureErrnoError();
            Module["stdin"] = input || Module["stdin"];
            Module["stdout"] = output || Module["stdout"];
            Module["stderr"] = error || Module["stderr"];
            FS.createStandardStreams();
          },
          quit() {
            FS.init.initialized = false;
            _fflush(0);
            for (var i2 = 0; i2 < FS.streams.length; i2++) {
              var stream = FS.streams[i2];
              if (!stream) {
                continue;
              }
              FS.close(stream);
            }
          },
          findObject(path2, dontResolveLastLink) {
            var ret = FS.analyzePath(path2, dontResolveLastLink);
            if (!ret.exists) {
              return null;
            }
            return ret.object;
          },
          analyzePath(path2, dontResolveLastLink) {
            try {
              var lookup = FS.lookupPath(path2, {
                follow: !dontResolveLastLink
              });
              path2 = lookup.path;
            } catch (e) {
            }
            var ret = {
              isRoot: false,
              exists: false,
              error: 0,
              name: null,
              path: null,
              object: null,
              parentExists: false,
              parentPath: null,
              parentObject: null
            };
            try {
              var lookup = FS.lookupPath(path2, {
                parent: true
              });
              ret.parentExists = true;
              ret.parentPath = lookup.path;
              ret.parentObject = lookup.node;
              ret.name = PATH.basename(path2);
              lookup = FS.lookupPath(path2, {
                follow: !dontResolveLastLink
              });
              ret.exists = true;
              ret.path = lookup.path;
              ret.object = lookup.node;
              ret.name = lookup.node.name;
              ret.isRoot = lookup.path === "/";
            } catch (e) {
              ret.error = e.errno;
            }
            return ret;
          },
          createPath(parent, path2, canRead, canWrite) {
            parent = typeof parent == "string" ? parent : FS.getPath(parent);
            var parts2 = path2.split("/").reverse();
            while (parts2.length) {
              var part = parts2.pop();
              if (!part)
                continue;
              var current = PATH.join2(parent, part);
              try {
                FS.mkdir(current);
              } catch (e) {
              }
              parent = current;
            }
            return current;
          },
          createFile(parent, name2, properties, canRead, canWrite) {
            var path2 = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name2);
            var mode = FS_getMode(canRead, canWrite);
            return FS.create(path2, mode);
          },
          createDataFile(parent, name2, data2, canRead, canWrite, canOwn) {
            var path2 = name2;
            if (parent) {
              parent = typeof parent == "string" ? parent : FS.getPath(parent);
              path2 = name2 ? PATH.join2(parent, name2) : parent;
            }
            var mode = FS_getMode(canRead, canWrite);
            var node = FS.create(path2, mode);
            if (data2) {
              if (typeof data2 == "string") {
                var arr = new Array(data2.length);
                for (var i2 = 0, len2 = data2.length; i2 < len2; ++i2)
                  arr[i2] = data2.charCodeAt(i2);
                data2 = arr;
              }
              FS.chmod(node, mode | 146);
              var stream = FS.open(node, 577);
              FS.write(stream, data2, 0, data2.length, 0, canOwn);
              FS.close(stream);
              FS.chmod(node, mode);
            }
          },
          createDevice(parent, name2, input, output) {
            var path2 = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name2);
            var mode = FS_getMode(!!input, !!output);
            if (!FS.createDevice.major)
              FS.createDevice.major = 64;
            var dev = FS.makedev(FS.createDevice.major++, 0);
            FS.registerDevice(dev, {
              open(stream) {
                stream.seekable = false;
              },
              close(stream) {
                var _a;
                if ((_a = output == null ? void 0 : output.buffer) == null ? void 0 : _a.length) {
                  output(10);
                }
              },
              read(stream, buffer, offset, length, pos) {
                var bytesRead = 0;
                for (var i2 = 0; i2 < length; i2++) {
                  var result;
                  try {
                    result = input();
                  } catch (e) {
                    throw new FS.ErrnoError(29);
                  }
                  if (result === void 0 && bytesRead === 0) {
                    throw new FS.ErrnoError(6);
                  }
                  if (result === null || result === void 0)
                    break;
                  bytesRead++;
                  buffer[offset + i2] = result;
                }
                if (bytesRead) {
                  stream.node.timestamp = Date.now();
                }
                return bytesRead;
              },
              write(stream, buffer, offset, length, pos) {
                for (var i2 = 0; i2 < length; i2++) {
                  try {
                    output(buffer[offset + i2]);
                  } catch (e) {
                    throw new FS.ErrnoError(29);
                  }
                }
                if (length) {
                  stream.node.timestamp = Date.now();
                }
                return i2;
              }
            });
            return FS.mkdev(path2, mode, dev);
          },
          forceLoadFile(obj) {
            if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
              return true;
            if (typeof XMLHttpRequest != "undefined") {
              throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
            } else if (read_) {
              try {
                obj.contents = intArrayFromString(read_(obj.url), true);
                obj.usedBytes = obj.contents.length;
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
            } else {
              throw new Error("Cannot load without read() or XMLHttpRequest.");
            }
          },
          createLazyFile(parent, name2, url2, canRead, canWrite) {
            function LazyUint8Array() {
              this.lengthKnown = false;
              this.chunks = [];
            }
            LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {
              if (idx > this.length - 1 || idx < 0) {
                return void 0;
              }
              var chunkOffset = idx % this.chunkSize;
              var chunkNum = idx / this.chunkSize | 0;
              return this.getter(chunkNum)[chunkOffset];
            };
            LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
              this.getter = getter;
            };
            LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
              var xhr = new XMLHttpRequest();
              xhr.open("HEAD", url2, false);
              xhr.send(null);
              if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))
                throw new Error("Couldn't load " + url2 + ". Status: " + xhr.status);
              var datalength = Number(xhr.getResponseHeader("Content-length"));
              var header;
              var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
              var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
              var chunkSize = 1024 * 1024;
              if (!hasByteServing)
                chunkSize = datalength;
              var doXHR = (from, to) => {
                if (from > to)
                  throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
                if (to > datalength - 1)
                  throw new Error("only " + datalength + " bytes available! programmer error!");
                var xhr2 = new XMLHttpRequest();
                xhr2.open("GET", url2, false);
                if (datalength !== chunkSize)
                  xhr2.setRequestHeader("Range", "bytes=" + from + "-" + to);
                xhr2.responseType = "arraybuffer";
                if (xhr2.overrideMimeType) {
                  xhr2.overrideMimeType("text/plain; charset=x-user-defined");
                }
                xhr2.send(null);
                if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))
                  throw new Error("Couldn't load " + url2 + ". Status: " + xhr2.status);
                if (xhr2.response !== void 0) {
                  return new Uint8Array(xhr2.response || []);
                }
                return intArrayFromString(xhr2.responseText || "", true);
              };
              var lazyArray2 = this;
              lazyArray2.setDataGetter((chunkNum) => {
                var start2 = chunkNum * chunkSize;
                var end = (chunkNum + 1) * chunkSize - 1;
                end = Math.min(end, datalength - 1);
                if (typeof lazyArray2.chunks[chunkNum] == "undefined") {
                  lazyArray2.chunks[chunkNum] = doXHR(start2, end);
                }
                if (typeof lazyArray2.chunks[chunkNum] == "undefined")
                  throw new Error("doXHR failed!");
                return lazyArray2.chunks[chunkNum];
              });
              if (usesGzip || !datalength) {
                chunkSize = datalength = 1;
                datalength = this.getter(0).length;
                chunkSize = datalength;
                out("LazyFiles on gzip forces download of the whole file when length is accessed");
              }
              this._length = datalength;
              this._chunkSize = chunkSize;
              this.lengthKnown = true;
            };
            if (typeof XMLHttpRequest != "undefined") {
              if (!ENVIRONMENT_IS_WORKER)
                throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
              var lazyArray = new LazyUint8Array();
              Object.defineProperties(lazyArray, {
                length: {
                  get: function() {
                    if (!this.lengthKnown) {
                      this.cacheLength();
                    }
                    return this._length;
                  }
                },
                chunkSize: {
                  get: function() {
                    if (!this.lengthKnown) {
                      this.cacheLength();
                    }
                    return this._chunkSize;
                  }
                }
              });
              var properties = {
                isDevice: false,
                contents: lazyArray
              };
            } else {
              var properties = {
                isDevice: false,
                url: url2
              };
            }
            var node = FS.createFile(parent, name2, properties, canRead, canWrite);
            if (properties.contents) {
              node.contents = properties.contents;
            } else if (properties.url) {
              node.contents = null;
              node.url = properties.url;
            }
            Object.defineProperties(node, {
              usedBytes: {
                get: function() {
                  return this.contents.length;
                }
              }
            });
            var stream_ops = {};
            var keys = Object.keys(node.stream_ops);
            keys.forEach((key) => {
              var fn = node.stream_ops[key];
              stream_ops[key] = function forceLoadLazyFile() {
                FS.forceLoadFile(node);
                return fn.apply(null, arguments);
              };
            });
            function writeChunks(stream, buffer, offset, length, position) {
              var contents = stream.node.contents;
              if (position >= contents.length)
                return 0;
              var size = Math.min(contents.length - position, length);
              if (contents.slice) {
                for (var i2 = 0; i2 < size; i2++) {
                  buffer[offset + i2] = contents[position + i2];
                }
              } else {
                for (var i2 = 0; i2 < size; i2++) {
                  buffer[offset + i2] = contents.get(position + i2);
                }
              }
              return size;
            }
            stream_ops.read = (stream, buffer, offset, length, position) => {
              FS.forceLoadFile(node);
              return writeChunks(stream, buffer, offset, length, position);
            };
            stream_ops.mmap = (stream, length, position, prot, flags2) => {
              FS.forceLoadFile(node);
              var ptr2 = mmapAlloc(length);
              if (!ptr2) {
                throw new FS.ErrnoError(48);
              }
              writeChunks(stream, HEAP8, ptr2, length, position);
              return {
                ptr: ptr2,
                allocated: true
              };
            };
            node.stream_ops = stream_ops;
            return node;
          }
        };
        var SYSCALLS = {
          DEFAULT_POLLMASK: 5,
          calculateAt(dirfd, path2, allowEmpty) {
            if (PATH.isAbs(path2)) {
              return path2;
            }
            var dir;
            if (dirfd === -100) {
              dir = FS.cwd();
            } else {
              var dirstream = SYSCALLS.getStreamFromFD(dirfd);
              dir = dirstream.path;
            }
            if (path2.length == 0) {
              if (!allowEmpty) {
                throw new FS.ErrnoError(44);
              }
              return dir;
            }
            return PATH.join2(dir, path2);
          },
          doStat(func2, path2, buf) {
            try {
              var stat = func2(path2);
            } catch (e) {
              if (e && e.node && PATH.normalize(path2) !== PATH.normalize(FS.getPath(e.node))) {
                return -54;
              }
              throw e;
            }
            HEAP32[buf >>> 2 >>> 0] = stat.dev;
            HEAP32[buf + 4 >>> 2 >>> 0] = stat.mode;
            HEAPU32[buf + 8 >>> 2 >>> 0] = stat.nlink;
            HEAP32[buf + 12 >>> 2 >>> 0] = stat.uid;
            HEAP32[buf + 16 >>> 2 >>> 0] = stat.gid;
            HEAP32[buf + 20 >>> 2 >>> 0] = stat.rdev;
            tempI64 = [stat.size >>> 0, (tempDouble = stat.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 24 >>> 2 >>> 0] = tempI64[0], HEAP32[buf + 28 >>> 2 >>> 0] = tempI64[1];
            HEAP32[buf + 32 >>> 2 >>> 0] = 4096;
            HEAP32[buf + 36 >>> 2 >>> 0] = stat.blocks;
            var atime = stat.atime.getTime();
            var mtime = stat.mtime.getTime();
            var ctime = stat.ctime.getTime();
            tempI64 = [Math.floor(atime / 1e3) >>> 0, (tempDouble = Math.floor(atime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 40 >>> 2 >>> 0] = tempI64[0], HEAP32[buf + 44 >>> 2 >>> 0] = tempI64[1];
            HEAPU32[buf + 48 >>> 2 >>> 0] = atime % 1e3 * 1e3;
            tempI64 = [Math.floor(mtime / 1e3) >>> 0, (tempDouble = Math.floor(mtime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 56 >>> 2 >>> 0] = tempI64[0], HEAP32[buf + 60 >>> 2 >>> 0] = tempI64[1];
            HEAPU32[buf + 64 >>> 2 >>> 0] = mtime % 1e3 * 1e3;
            tempI64 = [Math.floor(ctime / 1e3) >>> 0, (tempDouble = Math.floor(ctime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 72 >>> 2 >>> 0] = tempI64[0], HEAP32[buf + 76 >>> 2 >>> 0] = tempI64[1];
            HEAPU32[buf + 80 >>> 2 >>> 0] = ctime % 1e3 * 1e3;
            tempI64 = [stat.ino >>> 0, (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 88 >>> 2 >>> 0] = tempI64[0], HEAP32[buf + 92 >>> 2 >>> 0] = tempI64[1];
            return 0;
          },
          doMsync(addr2, stream, len2, flags2, offset) {
            if (!FS.isFile(stream.node.mode)) {
              throw new FS.ErrnoError(43);
            }
            if (flags2 & 2) {
              return 0;
            }
            var buffer = HEAPU8.slice(addr2, addr2 + len2);
            FS.msync(stream, buffer, offset, len2, flags2);
          },
          varargs: void 0,
          get() {
            var ret = HEAP32[+SYSCALLS.varargs >>> 2 >>> 0];
            SYSCALLS.varargs += 4;
            return ret;
          },
          getp() {
            return SYSCALLS.get();
          },
          getStr(ptr2) {
            var ret = UTF8ToString(ptr2);
            return ret;
          },
          getStreamFromFD(fd) {
            var stream = FS.getStreamChecked(fd);
            return stream;
          }
        };
        function ___syscall__newselect(nfds, readfds, writefds, exceptfds, timeout) {
          readfds >>>= 0;
          writefds >>>= 0;
          exceptfds >>>= 0;
          timeout >>>= 0;
          try {
            var total = 0;
            var srcReadLow = readfds ? HEAP32[readfds >>> 2 >>> 0] : 0, srcReadHigh = readfds ? HEAP32[readfds + 4 >>> 2 >>> 0] : 0;
            var srcWriteLow = writefds ? HEAP32[writefds >>> 2 >>> 0] : 0, srcWriteHigh = writefds ? HEAP32[writefds + 4 >>> 2 >>> 0] : 0;
            var srcExceptLow = exceptfds ? HEAP32[exceptfds >>> 2 >>> 0] : 0, srcExceptHigh = exceptfds ? HEAP32[exceptfds + 4 >>> 2 >>> 0] : 0;
            var dstReadLow = 0, dstReadHigh = 0;
            var dstWriteLow = 0, dstWriteHigh = 0;
            var dstExceptLow = 0, dstExceptHigh = 0;
            var allLow = (readfds ? HEAP32[readfds >>> 2 >>> 0] : 0) | (writefds ? HEAP32[writefds >>> 2 >>> 0] : 0) | (exceptfds ? HEAP32[exceptfds >>> 2 >>> 0] : 0);
            var allHigh = (readfds ? HEAP32[readfds + 4 >>> 2 >>> 0] : 0) | (writefds ? HEAP32[writefds + 4 >>> 2 >>> 0] : 0) | (exceptfds ? HEAP32[exceptfds + 4 >>> 2 >>> 0] : 0);
            var check = function(fd2, low, high, val) {
              return fd2 < 32 ? low & val : high & val;
            };
            for (var fd = 0; fd < nfds; fd++) {
              var mask = 1 << fd % 32;
              if (!check(fd, allLow, allHigh, mask)) {
                continue;
              }
              var stream = SYSCALLS.getStreamFromFD(fd);
              var flags2 = SYSCALLS.DEFAULT_POLLMASK;
              if (stream.stream_ops.poll) {
                var timeoutInMillis = -1;
                if (timeout) {
                  var tv_sec = readfds ? HEAP32[timeout >>> 2 >>> 0] : 0, tv_usec = readfds ? HEAP32[timeout + 4 >>> 2 >>> 0] : 0;
                  timeoutInMillis = (tv_sec + tv_usec / 1e6) * 1e3;
                }
                flags2 = stream.stream_ops.poll(stream, timeoutInMillis);
              }
              if (flags2 & 1 && check(fd, srcReadLow, srcReadHigh, mask)) {
                fd < 32 ? dstReadLow = dstReadLow | mask : dstReadHigh = dstReadHigh | mask;
                total++;
              }
              if (flags2 & 4 && check(fd, srcWriteLow, srcWriteHigh, mask)) {
                fd < 32 ? dstWriteLow = dstWriteLow | mask : dstWriteHigh = dstWriteHigh | mask;
                total++;
              }
              if (flags2 & 2 && check(fd, srcExceptLow, srcExceptHigh, mask)) {
                fd < 32 ? dstExceptLow = dstExceptLow | mask : dstExceptHigh = dstExceptHigh | mask;
                total++;
              }
            }
            if (readfds) {
              HEAP32[readfds >>> 2 >>> 0] = dstReadLow;
              HEAP32[readfds + 4 >>> 2 >>> 0] = dstReadHigh;
            }
            if (writefds) {
              HEAP32[writefds >>> 2 >>> 0] = dstWriteLow;
              HEAP32[writefds + 4 >>> 2 >>> 0] = dstWriteHigh;
            }
            if (exceptfds) {
              HEAP32[exceptfds >>> 2 >>> 0] = dstExceptLow;
              HEAP32[exceptfds + 4 >>> 2 >>> 0] = dstExceptHigh;
            }
            return total;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall__newselect.sig = "iipppp";
        var SOCKFS = {
          mount(mount) {
            Module["websocket"] = Module["websocket"] && "object" === typeof Module["websocket"] ? Module["websocket"] : {};
            Module["websocket"]._callbacks = {};
            Module["websocket"]["on"] = function(event2, callback) {
              if ("function" === typeof callback) {
                this._callbacks[event2] = callback;
              }
              return this;
            };
            Module["websocket"].emit = function(event2, param) {
              if ("function" === typeof this._callbacks[event2]) {
                this._callbacks[event2].call(this, param);
              }
            };
            return FS.createNode(null, "/", 16384 | 511, 0);
          },
          createSocket(family, type, protocol) {
            type &= ~526336;
            var streaming = type == 1;
            if (streaming && protocol && protocol != 6) {
              throw new FS.ErrnoError(66);
            }
            var sock = {
              family,
              type,
              protocol,
              server: null,
              error: null,
              peers: {},
              pending: [],
              recv_queue: [],
              sock_ops: SOCKFS.websocket_sock_ops
            };
            var name2 = SOCKFS.nextname();
            var node = FS.createNode(SOCKFS.root, name2, 49152, 0);
            node.sock = sock;
            var stream = FS.createStream({
              path: name2,
              node,
              flags: 2,
              seekable: false,
              stream_ops: SOCKFS.stream_ops
            });
            sock.stream = stream;
            return sock;
          },
          getSocket(fd) {
            var stream = FS.getStream(fd);
            if (!stream || !FS.isSocket(stream.node.mode)) {
              return null;
            }
            return stream.node.sock;
          },
          stream_ops: {
            poll(stream) {
              var sock = stream.node.sock;
              return sock.sock_ops.poll(sock);
            },
            ioctl(stream, request, varargs) {
              var sock = stream.node.sock;
              return sock.sock_ops.ioctl(sock, request, varargs);
            },
            read(stream, buffer, offset, length, position) {
              var sock = stream.node.sock;
              var msg = sock.sock_ops.recvmsg(sock, length);
              if (!msg) {
                return 0;
              }
              buffer.set(msg.buffer, offset);
              return msg.buffer.length;
            },
            write(stream, buffer, offset, length, position) {
              var sock = stream.node.sock;
              return sock.sock_ops.sendmsg(sock, buffer, offset, length);
            },
            close(stream) {
              var sock = stream.node.sock;
              sock.sock_ops.close(sock);
            }
          },
          nextname() {
            if (!SOCKFS.nextname.current) {
              SOCKFS.nextname.current = 0;
            }
            return "socket[" + SOCKFS.nextname.current++ + "]";
          },
          websocket_sock_ops: {
            createPeer(sock, addr2, port) {
              var ws;
              if (typeof addr2 == "object") {
                ws = addr2;
                addr2 = null;
                port = null;
              }
              if (ws) {
                if (ws._socket) {
                  addr2 = ws._socket.remoteAddress;
                  port = ws._socket.remotePort;
                } else {
                  var result = /ws[s]?:\/\/([^:]+):(\d+)/.exec(ws.url);
                  if (!result) {
                    throw new Error("WebSocket URL must be in the format ws(s)://address:port");
                  }
                  addr2 = result[1];
                  port = parseInt(result[2], 10);
                }
              } else {
                try {
                  var runtimeConfig = Module["websocket"] && "object" === typeof Module["websocket"];
                  var url2 = "ws:#".replace("#", "//");
                  if (runtimeConfig) {
                    if ("string" === typeof Module["websocket"]["url"]) {
                      url2 = Module["websocket"]["url"];
                    }
                  }
                  if (url2 === "ws://" || url2 === "wss://") {
                    var parts2 = addr2.split("/");
                    url2 = url2 + parts2[0] + ":" + port + "/" + parts2.slice(1).join("/");
                  }
                  var subProtocols = "binary";
                  if (runtimeConfig) {
                    if ("string" === typeof Module["websocket"]["subprotocol"]) {
                      subProtocols = Module["websocket"]["subprotocol"];
                    }
                  }
                  var opts = void 0;
                  if (subProtocols !== "null") {
                    subProtocols = subProtocols.replace(/^ +| +$/g, "").split(/ *, */);
                    opts = subProtocols;
                  }
                  if (runtimeConfig && null === Module["websocket"]["subprotocol"]) {
                    subProtocols = "null";
                    opts = void 0;
                  }
                  var WebSocketConstructor;
                  if (ENVIRONMENT_IS_NODE) {
                    WebSocketConstructor = require_ws();
                  } else {
                    WebSocketConstructor = WebSocket;
                  }
                  ws = new WebSocketConstructor(url2, opts);
                  ws.binaryType = "arraybuffer";
                } catch (e) {
                  throw new FS.ErrnoError(23);
                }
              }
              var peer = {
                addr: addr2,
                port,
                socket: ws,
                dgram_send_queue: []
              };
              SOCKFS.websocket_sock_ops.addPeer(sock, peer);
              SOCKFS.websocket_sock_ops.handlePeerEvents(sock, peer);
              if (sock.type === 2 && typeof sock.sport != "undefined") {
                peer.dgram_send_queue.push(new Uint8Array([255, 255, 255, 255, "p".charCodeAt(0), "o".charCodeAt(0), "r".charCodeAt(0), "t".charCodeAt(0), (sock.sport & 65280) >> 8, sock.sport & 255]));
              }
              return peer;
            },
            getPeer(sock, addr2, port) {
              return sock.peers[addr2 + ":" + port];
            },
            addPeer(sock, peer) {
              sock.peers[peer.addr + ":" + peer.port] = peer;
            },
            removePeer(sock, peer) {
              delete sock.peers[peer.addr + ":" + peer.port];
            },
            handlePeerEvents(sock, peer) {
              var first = true;
              var handleOpen = function() {
                Module["websocket"].emit("open", sock.stream.fd);
                try {
                  var queued = peer.dgram_send_queue.shift();
                  while (queued) {
                    peer.socket.send(queued);
                    queued = peer.dgram_send_queue.shift();
                  }
                } catch (e) {
                  peer.socket.close();
                }
              };
              function handleMessage(data2) {
                if (typeof data2 == "string") {
                  var encoder3 = new TextEncoder();
                  data2 = encoder3.encode(data2);
                } else {
                  assert(data2.byteLength !== void 0);
                  if (data2.byteLength == 0) {
                    return;
                  }
                  data2 = new Uint8Array(data2);
                }
                var wasfirst = first;
                first = false;
                if (wasfirst && data2.length === 10 && data2[0] === 255 && data2[1] === 255 && data2[2] === 255 && data2[3] === 255 && data2[4] === "p".charCodeAt(0) && data2[5] === "o".charCodeAt(0) && data2[6] === "r".charCodeAt(0) && data2[7] === "t".charCodeAt(0)) {
                  var newport = data2[8] << 8 | data2[9];
                  SOCKFS.websocket_sock_ops.removePeer(sock, peer);
                  peer.port = newport;
                  SOCKFS.websocket_sock_ops.addPeer(sock, peer);
                  return;
                }
                sock.recv_queue.push({
                  addr: peer.addr,
                  port: peer.port,
                  data: data2
                });
                Module["websocket"].emit("message", sock.stream.fd);
              }
              if (ENVIRONMENT_IS_NODE) {
                peer.socket.on("open", handleOpen);
                peer.socket.on("message", function(data2, isBinary) {
                  if (!isBinary) {
                    return;
                  }
                  handleMessage(new Uint8Array(data2).buffer);
                });
                peer.socket.on("close", function() {
                  Module["websocket"].emit("close", sock.stream.fd);
                });
                peer.socket.on("error", function(error) {
                  sock.error = 14;
                  Module["websocket"].emit("error", [sock.stream.fd, sock.error, "ECONNREFUSED: Connection refused"]);
                });
              } else {
                peer.socket.onopen = handleOpen;
                peer.socket.onclose = function() {
                  Module["websocket"].emit("close", sock.stream.fd);
                };
                peer.socket.onmessage = function peer_socket_onmessage(event2) {
                  handleMessage(event2.data);
                };
                peer.socket.onerror = function(error) {
                  sock.error = 14;
                  Module["websocket"].emit("error", [sock.stream.fd, sock.error, "ECONNREFUSED: Connection refused"]);
                };
              }
            },
            poll(sock) {
              if (sock.type === 1 && sock.server) {
                return sock.pending.length ? 64 | 1 : 0;
              }
              var mask = 0;
              var dest = sock.type === 1 ? SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport) : null;
              if (sock.recv_queue.length || !dest || dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
                mask |= 64 | 1;
              }
              if (!dest || dest && dest.socket.readyState === dest.socket.OPEN) {
                mask |= 4;
              }
              if (dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
                mask |= 16;
              }
              return mask;
            },
            ioctl(sock, request, arg) {
              switch (request) {
                case 21531:
                  var bytes = 0;
                  if (sock.recv_queue.length) {
                    bytes = sock.recv_queue[0].data.length;
                  }
                  HEAP32[arg >>> 2 >>> 0] = bytes;
                  return 0;
                default:
                  return 28;
              }
            },
            close(sock) {
              if (sock.server) {
                try {
                  sock.server.close();
                } catch (e) {
                }
                sock.server = null;
              }
              var peers = Object.keys(sock.peers);
              for (var i2 = 0; i2 < peers.length; i2++) {
                var peer = sock.peers[peers[i2]];
                try {
                  peer.socket.close();
                } catch (e) {
                }
                SOCKFS.websocket_sock_ops.removePeer(sock, peer);
              }
              return 0;
            },
            bind(sock, addr2, port) {
              if (typeof sock.saddr != "undefined" || typeof sock.sport != "undefined") {
                throw new FS.ErrnoError(28);
              }
              sock.saddr = addr2;
              sock.sport = port;
              if (sock.type === 2) {
                if (sock.server) {
                  sock.server.close();
                  sock.server = null;
                }
                try {
                  sock.sock_ops.listen(sock, 0);
                } catch (e) {
                  if (!(e.name === "ErrnoError"))
                    throw e;
                  if (e.errno !== 138)
                    throw e;
                }
              }
            },
            connect(sock, addr2, port) {
              if (sock.server) {
                throw new FS.ErrnoError(138);
              }
              if (typeof sock.daddr != "undefined" && typeof sock.dport != "undefined") {
                var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
                if (dest) {
                  if (dest.socket.readyState === dest.socket.CONNECTING) {
                    throw new FS.ErrnoError(7);
                  } else {
                    throw new FS.ErrnoError(30);
                  }
                }
              }
              var peer = SOCKFS.websocket_sock_ops.createPeer(sock, addr2, port);
              sock.daddr = peer.addr;
              sock.dport = peer.port;
              throw new FS.ErrnoError(26);
            },
            listen(sock, backlog) {
              if (!ENVIRONMENT_IS_NODE) {
                throw new FS.ErrnoError(138);
              }
              if (sock.server) {
                throw new FS.ErrnoError(28);
              }
              var WebSocketServer = require_ws().Server;
              var host = sock.saddr;
              sock.server = new WebSocketServer({
                host,
                port: sock.sport
              });
              Module["websocket"].emit("listen", sock.stream.fd);
              sock.server.on("connection", function(ws) {
                if (sock.type === 1) {
                  var newsock = SOCKFS.createSocket(sock.family, sock.type, sock.protocol);
                  var peer = SOCKFS.websocket_sock_ops.createPeer(newsock, ws);
                  newsock.daddr = peer.addr;
                  newsock.dport = peer.port;
                  sock.pending.push(newsock);
                  Module["websocket"].emit("connection", newsock.stream.fd);
                } else {
                  SOCKFS.websocket_sock_ops.createPeer(sock, ws);
                  Module["websocket"].emit("connection", sock.stream.fd);
                }
              });
              sock.server.on("close", function() {
                Module["websocket"].emit("close", sock.stream.fd);
                sock.server = null;
              });
              sock.server.on("error", function(error) {
                sock.error = 23;
                Module["websocket"].emit("error", [sock.stream.fd, sock.error, "EHOSTUNREACH: Host is unreachable"]);
              });
            },
            accept(listensock) {
              if (!listensock.server || !listensock.pending.length) {
                throw new FS.ErrnoError(28);
              }
              var newsock = listensock.pending.shift();
              newsock.stream.flags = listensock.stream.flags;
              return newsock;
            },
            getname(sock, peer) {
              var addr2, port;
              if (peer) {
                if (sock.daddr === void 0 || sock.dport === void 0) {
                  throw new FS.ErrnoError(53);
                }
                addr2 = sock.daddr;
                port = sock.dport;
              } else {
                addr2 = sock.saddr || 0;
                port = sock.sport || 0;
              }
              return {
                addr: addr2,
                port
              };
            },
            sendmsg(sock, buffer, offset, length, addr2, port) {
              if (sock.type === 2) {
                if (addr2 === void 0 || port === void 0) {
                  addr2 = sock.daddr;
                  port = sock.dport;
                }
                if (addr2 === void 0 || port === void 0) {
                  throw new FS.ErrnoError(17);
                }
              } else {
                addr2 = sock.daddr;
                port = sock.dport;
              }
              var dest = SOCKFS.websocket_sock_ops.getPeer(sock, addr2, port);
              if (sock.type === 1) {
                if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
                  throw new FS.ErrnoError(53);
                } else if (dest.socket.readyState === dest.socket.CONNECTING) {
                  throw new FS.ErrnoError(6);
                }
              }
              if (ArrayBuffer.isView(buffer)) {
                offset += buffer.byteOffset;
                buffer = buffer.buffer;
              }
              var data2;
              data2 = buffer.slice(offset, offset + length);
              if (sock.type === 2) {
                if (!dest || dest.socket.readyState !== dest.socket.OPEN) {
                  if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
                    dest = SOCKFS.websocket_sock_ops.createPeer(sock, addr2, port);
                  }
                  dest.dgram_send_queue.push(data2);
                  return length;
                }
              }
              try {
                dest.socket.send(data2);
                return length;
              } catch (e) {
                throw new FS.ErrnoError(28);
              }
            },
            recvmsg(sock, length) {
              if (sock.type === 1 && sock.server) {
                throw new FS.ErrnoError(53);
              }
              var queued = sock.recv_queue.shift();
              if (!queued) {
                if (sock.type === 1) {
                  var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
                  if (!dest) {
                    throw new FS.ErrnoError(53);
                  }
                  if (dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
                    return null;
                  }
                  throw new FS.ErrnoError(6);
                }
                throw new FS.ErrnoError(6);
              }
              var queuedLength = queued.data.byteLength || queued.data.length;
              var queuedOffset = queued.data.byteOffset || 0;
              var queuedBuffer = queued.data.buffer || queued.data;
              var bytesRead = Math.min(length, queuedLength);
              var res = {
                buffer: new Uint8Array(queuedBuffer, queuedOffset, bytesRead),
                addr: queued.addr,
                port: queued.port
              };
              if (sock.type === 1 && bytesRead < queuedLength) {
                var bytesRemaining = queuedLength - bytesRead;
                queued.data = new Uint8Array(queuedBuffer, queuedOffset + bytesRead, bytesRemaining);
                sock.recv_queue.unshift(queued);
              }
              return res;
            }
          }
        };
        var getSocketFromFD = (fd) => {
          var socket = SOCKFS.getSocket(fd);
          if (!socket)
            throw new FS.ErrnoError(8);
          return socket;
        };
        var Sockets = {
          BUFFER_SIZE: 10240,
          MAX_BUFFER_SIZE: 10485760,
          nextFd: 1,
          fds: {},
          nextport: 1,
          maxport: 65535,
          peer: null,
          connections: {},
          portmap: {},
          localAddr: 4261412874,
          addrPool: [33554442, 50331658, 67108874, 83886090, 100663306, 117440522, 134217738, 150994954, 167772170, 184549386, 201326602, 218103818, 234881034]
        };
        var inetPton4 = (str) => {
          var b = str.split(".");
          for (var i2 = 0; i2 < 4; i2++) {
            var tmp = Number(b[i2]);
            if (isNaN(tmp))
              return null;
            b[i2] = tmp;
          }
          return (b[0] | b[1] << 8 | b[2] << 16 | b[3] << 24) >>> 0;
        };
        var jstoi_q = (str) => parseInt(str);
        var inetPton6 = (str) => {
          var words;
          var w, offset, z, i2;
          var valid6regx = /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i;
          var parts2 = [];
          if (!valid6regx.test(str)) {
            return null;
          }
          if (str === "::") {
            return [0, 0, 0, 0, 0, 0, 0, 0];
          }
          if (str.startsWith("::")) {
            str = str.replace("::", "Z:");
          } else {
            str = str.replace("::", ":Z:");
          }
          if (str.indexOf(".") > 0) {
            str = str.replace(new RegExp("[.]", "g"), ":");
            words = str.split(":");
            words[words.length - 4] = jstoi_q(words[words.length - 4]) + jstoi_q(words[words.length - 3]) * 256;
            words[words.length - 3] = jstoi_q(words[words.length - 2]) + jstoi_q(words[words.length - 1]) * 256;
            words = words.slice(0, words.length - 2);
          } else {
            words = str.split(":");
          }
          offset = 0;
          z = 0;
          for (w = 0; w < words.length; w++) {
            if (typeof words[w] == "string") {
              if (words[w] === "Z") {
                for (z = 0; z < 8 - words.length + 1; z++) {
                  parts2[w + z] = 0;
                }
                offset = z - 1;
              } else {
                parts2[w + offset] = _htons(parseInt(words[w], 16));
              }
            } else {
              parts2[w + offset] = words[w];
            }
          }
          return [parts2[1] << 16 | parts2[0], parts2[3] << 16 | parts2[2], parts2[5] << 16 | parts2[4], parts2[7] << 16 | parts2[6]];
        };
        var writeSockaddr = (sa, family, addr2, port, addrlen) => {
          switch (family) {
            case 2:
              addr2 = inetPton4(addr2);
              zeroMemory(sa, 16);
              if (addrlen) {
                HEAP32[addrlen >>> 2 >>> 0] = 16;
              }
              HEAP16[sa >>> 1 >>> 0] = family;
              HEAP32[sa + 4 >>> 2 >>> 0] = addr2;
              HEAP16[sa + 2 >>> 1 >>> 0] = _htons(port);
              break;
            case 10:
              addr2 = inetPton6(addr2);
              zeroMemory(sa, 28);
              if (addrlen) {
                HEAP32[addrlen >>> 2 >>> 0] = 28;
              }
              HEAP32[sa >>> 2 >>> 0] = family;
              HEAP32[sa + 8 >>> 2 >>> 0] = addr2[0];
              HEAP32[sa + 12 >>> 2 >>> 0] = addr2[1];
              HEAP32[sa + 16 >>> 2 >>> 0] = addr2[2];
              HEAP32[sa + 20 >>> 2 >>> 0] = addr2[3];
              HEAP16[sa + 2 >>> 1 >>> 0] = _htons(port);
              break;
            default:
              return 5;
          }
          return 0;
        };
        var DNS = {
          address_map: {
            id: 1,
            addrs: {},
            names: {}
          },
          lookup_name(name2) {
            var res = inetPton4(name2);
            if (res !== null) {
              return name2;
            }
            res = inetPton6(name2);
            if (res !== null) {
              return name2;
            }
            var addr2;
            if (DNS.address_map.addrs[name2]) {
              addr2 = DNS.address_map.addrs[name2];
            } else {
              var id = DNS.address_map.id++;
              assert(id < 65535, "exceeded max address mappings of 65535");
              addr2 = "172.29." + (id & 255) + "." + (id & 65280);
              DNS.address_map.names[addr2] = name2;
              DNS.address_map.addrs[name2] = addr2;
            }
            return addr2;
          },
          lookup_addr(addr2) {
            if (DNS.address_map.names[addr2]) {
              return DNS.address_map.names[addr2];
            }
            return null;
          }
        };
        function ___syscall_accept4(fd, addr2, addrlen, flags2, d1, d2) {
          addr2 >>>= 0;
          addrlen >>>= 0;
          try {
            var sock = getSocketFromFD(fd);
            var newsock = sock.sock_ops.accept(sock);
            if (addr2) {
              var errno = writeSockaddr(addr2, newsock.family, DNS.lookup_name(newsock.daddr), newsock.dport, addrlen);
            }
            return newsock.stream.fd;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_accept4.sig = "iippiii";
        var inetNtop4 = (addr2) => (addr2 & 255) + "." + (addr2 >> 8 & 255) + "." + (addr2 >> 16 & 255) + "." + (addr2 >> 24 & 255);
        var inetNtop6 = (ints) => {
          var str = "";
          var word = 0;
          var longest = 0;
          var lastzero = 0;
          var zstart = 0;
          var len2 = 0;
          var i2 = 0;
          var parts2 = [ints[0] & 65535, ints[0] >> 16, ints[1] & 65535, ints[1] >> 16, ints[2] & 65535, ints[2] >> 16, ints[3] & 65535, ints[3] >> 16];
          var hasipv4 = true;
          var v4part = "";
          for (i2 = 0; i2 < 5; i2++) {
            if (parts2[i2] !== 0) {
              hasipv4 = false;
              break;
            }
          }
          if (hasipv4) {
            v4part = inetNtop4(parts2[6] | parts2[7] << 16);
            if (parts2[5] === -1) {
              str = "::ffff:";
              str += v4part;
              return str;
            }
            if (parts2[5] === 0) {
              str = "::";
              if (v4part === "0.0.0.0")
                v4part = "";
              if (v4part === "0.0.0.1")
                v4part = "1";
              str += v4part;
              return str;
            }
          }
          for (word = 0; word < 8; word++) {
            if (parts2[word] === 0) {
              if (word - lastzero > 1) {
                len2 = 0;
              }
              lastzero = word;
              len2++;
            }
            if (len2 > longest) {
              longest = len2;
              zstart = word - longest + 1;
            }
          }
          for (word = 0; word < 8; word++) {
            if (longest > 1) {
              if (parts2[word] === 0 && word >= zstart && word < zstart + longest) {
                if (word === zstart) {
                  str += ":";
                  if (zstart === 0)
                    str += ":";
                }
                continue;
              }
            }
            str += Number(_ntohs(parts2[word] & 65535)).toString(16);
            str += word < 7 ? ":" : "";
          }
          return str;
        };
        var readSockaddr = (sa, salen) => {
          var family = HEAP16[sa >>> 1 >>> 0];
          var port = _ntohs(HEAPU16[sa + 2 >>> 1 >>> 0]);
          var addr2;
          switch (family) {
            case 2:
              if (salen !== 16) {
                return {
                  errno: 28
                };
              }
              addr2 = HEAP32[sa + 4 >>> 2 >>> 0];
              addr2 = inetNtop4(addr2);
              break;
            case 10:
              if (salen !== 28) {
                return {
                  errno: 28
                };
              }
              addr2 = [HEAP32[sa + 8 >>> 2 >>> 0], HEAP32[sa + 12 >>> 2 >>> 0], HEAP32[sa + 16 >>> 2 >>> 0], HEAP32[sa + 20 >>> 2 >>> 0]];
              addr2 = inetNtop6(addr2);
              break;
            default:
              return {
                errno: 5
              };
          }
          return {
            family,
            addr: addr2,
            port
          };
        };
        var getSocketAddress = (addrp, addrlen, allowNull) => {
          if (allowNull && addrp === 0)
            return null;
          var info2 = readSockaddr(addrp, addrlen);
          if (info2.errno)
            throw new FS.ErrnoError(info2.errno);
          info2.addr = DNS.lookup_addr(info2.addr) || info2.addr;
          return info2;
        };
        function ___syscall_bind(fd, addr2, addrlen, d1, d2, d3) {
          addr2 >>>= 0;
          addrlen >>>= 0;
          try {
            var sock = getSocketFromFD(fd);
            var info2 = getSocketAddress(addr2, addrlen);
            sock.sock_ops.bind(sock, info2.addr, info2.port);
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_bind.sig = "iippiii";
        function ___syscall_chdir(path2) {
          path2 >>>= 0;
          try {
            path2 = SYSCALLS.getStr(path2);
            FS.chdir(path2);
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_chdir.sig = "ip";
        function ___syscall_chmod(path2, mode) {
          path2 >>>= 0;
          try {
            path2 = SYSCALLS.getStr(path2);
            FS.chmod(path2, mode);
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_chmod.sig = "ipi";
        function ___syscall_connect(fd, addr2, addrlen, d1, d2, d3) {
          addr2 >>>= 0;
          addrlen >>>= 0;
          try {
            var sock = getSocketFromFD(fd);
            var info2 = getSocketAddress(addr2, addrlen);
            sock.sock_ops.connect(sock, info2.addr, info2.port);
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_connect.sig = "iippiii";
        function ___syscall_dup(fd) {
          try {
            var old = SYSCALLS.getStreamFromFD(fd);
            return FS.createStream(old).fd;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_dup.sig = "ii";
        function ___syscall_dup3(fd, newfd, flags2) {
          try {
            var old = SYSCALLS.getStreamFromFD(fd);
            if (old.fd === newfd)
              return -28;
            var existing = FS.getStream(newfd);
            if (existing)
              FS.close(existing);
            return FS.createStream(old, newfd).fd;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_dup3.sig = "iiii";
        function ___syscall_faccessat(dirfd, path2, amode, flags2) {
          path2 >>>= 0;
          try {
            path2 = SYSCALLS.getStr(path2);
            path2 = SYSCALLS.calculateAt(dirfd, path2);
            if (amode & ~7) {
              return -28;
            }
            var lookup = FS.lookupPath(path2, {
              follow: true
            });
            var node = lookup.node;
            if (!node) {
              return -44;
            }
            var perms = "";
            if (amode & 4)
              perms += "r";
            if (amode & 2)
              perms += "w";
            if (amode & 1)
              perms += "x";
            if (perms && FS.nodePermissions(node, perms)) {
              return -2;
            }
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_faccessat.sig = "iipii";
        var ___syscall_fadvise64 = (fd, offset, len2, advice) => 0;
        ___syscall_fadvise64.sig = "iiiiiii";
        function ___syscall_fallocate(fd, mode, offset_low, offset_high, len_low, len_high) {
          var offset = convertI32PairToI53Checked(offset_low, offset_high);
          var len2 = convertI32PairToI53Checked(len_low, len_high);
          try {
            if (isNaN(offset))
              return 61;
            var stream = SYSCALLS.getStreamFromFD(fd);
            FS.allocate(stream, offset, len2);
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_fallocate.sig = "iiiiiii";
        function ___syscall_fchdir(fd) {
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            FS.chdir(stream.path);
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_fchdir.sig = "ii";
        function ___syscall_fchmod(fd, mode) {
          try {
            FS.fchmod(fd, mode);
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_fchmod.sig = "iii";
        function ___syscall_fchmodat(dirfd, path2, mode, varargs) {
          path2 >>>= 0;
          varargs >>>= 0;
          SYSCALLS.varargs = varargs;
          try {
            path2 = SYSCALLS.getStr(path2);
            path2 = SYSCALLS.calculateAt(dirfd, path2);
            FS.chmod(path2, mode);
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_fchmodat.sig = "iipip";
        function ___syscall_fchown32(fd, owner, group) {
          try {
            FS.fchown(fd, owner, group);
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_fchown32.sig = "iiii";
        function ___syscall_fchownat(dirfd, path2, owner, group, flags2) {
          path2 >>>= 0;
          try {
            path2 = SYSCALLS.getStr(path2);
            var nofollow = flags2 & 256;
            flags2 = flags2 & ~256;
            path2 = SYSCALLS.calculateAt(dirfd, path2);
            (nofollow ? FS.lchown : FS.chown)(path2, owner, group);
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_fchownat.sig = "iipiii";
        function ___syscall_fcntl64(fd, cmd, varargs) {
          varargs >>>= 0;
          SYSCALLS.varargs = varargs;
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            switch (cmd) {
              case 0: {
                var arg = SYSCALLS.get();
                if (arg < 0) {
                  return -28;
                }
                while (FS.streams[arg]) {
                  arg++;
                }
                var newStream;
                newStream = FS.createStream(stream, arg);
                return newStream.fd;
              }
              case 1:
              case 2:
                return 0;
              case 3:
                return stream.flags;
              case 4: {
                var arg = SYSCALLS.get();
                stream.flags |= arg;
                return 0;
              }
              case 12: {
                var arg = SYSCALLS.getp();
                var offset = 0;
                HEAP16[arg + offset >>> 1 >>> 0] = 2;
                return 0;
              }
              case 13:
              case 14:
                return 0;
            }
            return -28;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_fcntl64.sig = "iiip";
        function ___syscall_fdatasync(fd) {
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_fdatasync.sig = "ii";
        function ___syscall_fstat64(fd, buf) {
          buf >>>= 0;
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            return SYSCALLS.doStat(FS.stat, stream.path, buf);
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_fstat64.sig = "iip";
        function ___syscall_statfs64(path2, size, buf) {
          path2 >>>= 0;
          size >>>= 0;
          buf >>>= 0;
          try {
            path2 = SYSCALLS.getStr(path2);
            HEAP32[buf + 4 >>> 2 >>> 0] = 4096;
            HEAP32[buf + 40 >>> 2 >>> 0] = 4096;
            HEAP32[buf + 8 >>> 2 >>> 0] = 1e6;
            HEAP32[buf + 12 >>> 2 >>> 0] = 5e5;
            HEAP32[buf + 16 >>> 2 >>> 0] = 5e5;
            HEAP32[buf + 20 >>> 2 >>> 0] = FS.nextInode;
            HEAP32[buf + 24 >>> 2 >>> 0] = 1e6;
            HEAP32[buf + 28 >>> 2 >>> 0] = 42;
            HEAP32[buf + 44 >>> 2 >>> 0] = 2;
            HEAP32[buf + 36 >>> 2 >>> 0] = 255;
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_statfs64.sig = "ippp";
        function ___syscall_fstatfs64(fd, size, buf) {
          size >>>= 0;
          buf >>>= 0;
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            return ___syscall_statfs64(0, size, buf);
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_fstatfs64.sig = "iipp";
        function ___syscall_ftruncate64(fd, length_low, length_high) {
          var length = convertI32PairToI53Checked(length_low, length_high);
          try {
            if (isNaN(length))
              return 61;
            FS.ftruncate(fd, length);
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_ftruncate64.sig = "iiii";
        var stringToUTF8 = (str, outPtr, maxBytesToWrite) => stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
        function ___syscall_getcwd(buf, size) {
          buf >>>= 0;
          size >>>= 0;
          try {
            if (size === 0)
              return -28;
            var cwd = FS.cwd();
            var cwdLengthInBytes = lengthBytesUTF8(cwd) + 1;
            if (size < cwdLengthInBytes)
              return -68;
            stringToUTF8(cwd, buf, size);
            return cwdLengthInBytes;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_getcwd.sig = "ipp";
        function ___syscall_getdents64(fd, dirp, count) {
          dirp >>>= 0;
          count >>>= 0;
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            stream.getdents || (stream.getdents = FS.readdir(stream.path));
            var struct_size = 280;
            var pos = 0;
            var off = FS.llseek(stream, 0, 1);
            var idx = Math.floor(off / struct_size);
            while (idx < stream.getdents.length && pos + struct_size <= count) {
              var id;
              var type;
              var name2 = stream.getdents[idx];
              if (name2 === ".") {
                id = stream.node.id;
                type = 4;
              } else if (name2 === "..") {
                var lookup = FS.lookupPath(stream.path, {
                  parent: true
                });
                id = lookup.node.id;
                type = 4;
              } else {
                var child = FS.lookupNode(stream.node, name2);
                id = child.id;
                type = FS.isChrdev(child.mode) ? 2 : FS.isDir(child.mode) ? 4 : FS.isLink(child.mode) ? 10 : 8;
              }
              tempI64 = [id >>> 0, (tempDouble = id, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[dirp + pos >>> 2 >>> 0] = tempI64[0], HEAP32[dirp + pos + 4 >>> 2 >>> 0] = tempI64[1];
              tempI64 = [(idx + 1) * struct_size >>> 0, (tempDouble = (idx + 1) * struct_size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[dirp + pos + 8 >>> 2 >>> 0] = tempI64[0], HEAP32[dirp + pos + 12 >>> 2 >>> 0] = tempI64[1];
              HEAP16[dirp + pos + 16 >>> 1 >>> 0] = 280;
              HEAP8[dirp + pos + 18 >>> 0 >>> 0] = type;
              stringToUTF8(name2, dirp + pos + 19, 256);
              pos += struct_size;
              idx += 1;
            }
            FS.llseek(stream, idx * struct_size, 0);
            return pos;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_getdents64.sig = "iipp";
        function ___syscall_getpeername(fd, addr2, addrlen, d1, d2, d3) {
          addr2 >>>= 0;
          addrlen >>>= 0;
          try {
            var sock = getSocketFromFD(fd);
            if (!sock.daddr) {
              return -53;
            }
            var errno = writeSockaddr(addr2, sock.family, DNS.lookup_name(sock.daddr), sock.dport, addrlen);
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_getpeername.sig = "iippiii";
        function ___syscall_getsockname(fd, addr2, addrlen, d1, d2, d3) {
          addr2 >>>= 0;
          addrlen >>>= 0;
          try {
            var sock = getSocketFromFD(fd);
            var errno = writeSockaddr(addr2, sock.family, DNS.lookup_name(sock.saddr || "0.0.0.0"), sock.sport, addrlen);
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_getsockname.sig = "iippiii";
        function ___syscall_getsockopt(fd, level, optname, optval, optlen, d1) {
          optval >>>= 0;
          optlen >>>= 0;
          try {
            var sock = getSocketFromFD(fd);
            if (level === 1) {
              if (optname === 4) {
                HEAP32[optval >>> 2 >>> 0] = sock.error;
                HEAP32[optlen >>> 2 >>> 0] = 4;
                sock.error = null;
                return 0;
              }
            }
            return -50;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_getsockopt.sig = "iiiippi";
        function ___syscall_ioctl(fd, op, varargs) {
          varargs >>>= 0;
          SYSCALLS.varargs = varargs;
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            switch (op) {
              case 21509: {
                if (!stream.tty)
                  return -59;
                return 0;
              }
              case 21505: {
                if (!stream.tty)
                  return -59;
                if (stream.tty.ops.ioctl_tcgets) {
                  var termios = stream.tty.ops.ioctl_tcgets(stream);
                  var argp = SYSCALLS.getp();
                  HEAP32[argp >>> 2 >>> 0] = termios.c_iflag || 0;
                  HEAP32[argp + 4 >>> 2 >>> 0] = termios.c_oflag || 0;
                  HEAP32[argp + 8 >>> 2 >>> 0] = termios.c_cflag || 0;
                  HEAP32[argp + 12 >>> 2 >>> 0] = termios.c_lflag || 0;
                  for (var i2 = 0; i2 < 32; i2++) {
                    HEAP8[argp + i2 + 17 >>> 0 >>> 0] = termios.c_cc[i2] || 0;
                  }
                  return 0;
                }
                return 0;
              }
              case 21510:
              case 21511:
              case 21512: {
                if (!stream.tty)
                  return -59;
                return 0;
              }
              case 21506:
              case 21507:
              case 21508: {
                if (!stream.tty)
                  return -59;
                if (stream.tty.ops.ioctl_tcsets) {
                  var argp = SYSCALLS.getp();
                  var c_iflag = HEAP32[argp >>> 2 >>> 0];
                  var c_oflag = HEAP32[argp + 4 >>> 2 >>> 0];
                  var c_cflag = HEAP32[argp + 8 >>> 2 >>> 0];
                  var c_lflag = HEAP32[argp + 12 >>> 2 >>> 0];
                  var c_cc = [];
                  for (var i2 = 0; i2 < 32; i2++) {
                    c_cc.push(HEAP8[argp + i2 + 17 >>> 0 >>> 0]);
                  }
                  return stream.tty.ops.ioctl_tcsets(stream.tty, op, {
                    c_iflag,
                    c_oflag,
                    c_cflag,
                    c_lflag,
                    c_cc
                  });
                }
                return 0;
              }
              case 21519: {
                if (!stream.tty)
                  return -59;
                var argp = SYSCALLS.getp();
                HEAP32[argp >>> 2 >>> 0] = 0;
                return 0;
              }
              case 21520: {
                if (!stream.tty)
                  return -59;
                return -28;
              }
              case 21531: {
                var argp = SYSCALLS.getp();
                return FS.ioctl(stream, op, argp);
              }
              case 21523: {
                if (!stream.tty)
                  return -59;
                if (stream.tty.ops.ioctl_tiocgwinsz) {
                  var winsize = stream.tty.ops.ioctl_tiocgwinsz(stream.tty);
                  var argp = SYSCALLS.getp();
                  HEAP16[argp >>> 1 >>> 0] = winsize[0];
                  HEAP16[argp + 2 >>> 1 >>> 0] = winsize[1];
                }
                return 0;
              }
              case 21524: {
                if (!stream.tty)
                  return -59;
                return 0;
              }
              case 21515: {
                if (!stream.tty)
                  return -59;
                return 0;
              }
              default:
                return -28;
            }
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_ioctl.sig = "iiip";
        function ___syscall_listen(fd, backlog) {
          try {
            var sock = getSocketFromFD(fd);
            sock.sock_ops.listen(sock, backlog);
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_listen.sig = "iiiiiii";
        function ___syscall_lstat64(path2, buf) {
          path2 >>>= 0;
          buf >>>= 0;
          try {
            path2 = SYSCALLS.getStr(path2);
            return SYSCALLS.doStat(FS.lstat, path2, buf);
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_lstat64.sig = "ipp";
        function ___syscall_mkdirat(dirfd, path2, mode) {
          path2 >>>= 0;
          try {
            path2 = SYSCALLS.getStr(path2);
            path2 = SYSCALLS.calculateAt(dirfd, path2);
            path2 = PATH.normalize(path2);
            if (path2[path2.length - 1] === "/")
              path2 = path2.substr(0, path2.length - 1);
            FS.mkdir(path2, mode, 0);
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_mkdirat.sig = "iipi";
        function ___syscall_mknodat(dirfd, path2, mode, dev) {
          path2 >>>= 0;
          try {
            path2 = SYSCALLS.getStr(path2);
            path2 = SYSCALLS.calculateAt(dirfd, path2);
            switch (mode & 61440) {
              case 32768:
              case 8192:
              case 24576:
              case 4096:
              case 49152:
                break;
              default:
                return -28;
            }
            FS.mknod(path2, mode, dev);
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_mknodat.sig = "iipii";
        function ___syscall_newfstatat(dirfd, path2, buf, flags2) {
          path2 >>>= 0;
          buf >>>= 0;
          try {
            path2 = SYSCALLS.getStr(path2);
            var nofollow = flags2 & 256;
            var allowEmpty = flags2 & 4096;
            flags2 = flags2 & ~6400;
            path2 = SYSCALLS.calculateAt(dirfd, path2, allowEmpty);
            return SYSCALLS.doStat(nofollow ? FS.lstat : FS.stat, path2, buf);
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_newfstatat.sig = "iippi";
        function ___syscall_openat(dirfd, path2, flags2, varargs) {
          path2 >>>= 0;
          varargs >>>= 0;
          SYSCALLS.varargs = varargs;
          try {
            path2 = SYSCALLS.getStr(path2);
            path2 = SYSCALLS.calculateAt(dirfd, path2);
            var mode = varargs ? SYSCALLS.get() : 0;
            return FS.open(path2, flags2, mode).fd;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_openat.sig = "iipip";
        var PIPEFS = {
          BUCKET_BUFFER_SIZE: 8192,
          mount(mount) {
            return FS.createNode(null, "/", 16384 | 511, 0);
          },
          createPipe() {
            var pipe = {
              buckets: [],
              refcnt: 2
            };
            pipe.buckets.push({
              buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
              offset: 0,
              roffset: 0
            });
            var rName = PIPEFS.nextname();
            var wName = PIPEFS.nextname();
            var rNode = FS.createNode(PIPEFS.root, rName, 4096, 0);
            var wNode = FS.createNode(PIPEFS.root, wName, 4096, 0);
            rNode.pipe = pipe;
            wNode.pipe = pipe;
            var readableStream = FS.createStream({
              path: rName,
              node: rNode,
              flags: 0,
              seekable: false,
              stream_ops: PIPEFS.stream_ops
            });
            rNode.stream = readableStream;
            var writableStream = FS.createStream({
              path: wName,
              node: wNode,
              flags: 1,
              seekable: false,
              stream_ops: PIPEFS.stream_ops
            });
            wNode.stream = writableStream;
            return {
              readable_fd: readableStream.fd,
              writable_fd: writableStream.fd
            };
          },
          stream_ops: {
            poll(stream) {
              var pipe = stream.node.pipe;
              if ((stream.flags & 2097155) === 1) {
                return 256 | 4;
              }
              if (pipe.buckets.length > 0) {
                for (var i2 = 0; i2 < pipe.buckets.length; i2++) {
                  var bucket = pipe.buckets[i2];
                  if (bucket.offset - bucket.roffset > 0) {
                    return 64 | 1;
                  }
                }
              }
              return 0;
            },
            ioctl(stream, request, varargs) {
              return 28;
            },
            fsync(stream) {
              return 28;
            },
            read(stream, buffer, offset, length, position) {
              var pipe = stream.node.pipe;
              var currentLength = 0;
              for (var i2 = 0; i2 < pipe.buckets.length; i2++) {
                var bucket = pipe.buckets[i2];
                currentLength += bucket.offset - bucket.roffset;
              }
              var data2 = buffer.subarray(offset, offset + length);
              if (length <= 0) {
                return 0;
              }
              if (currentLength == 0) {
                throw new FS.ErrnoError(6);
              }
              var toRead = Math.min(currentLength, length);
              var totalRead = toRead;
              var toRemove = 0;
              for (var i2 = 0; i2 < pipe.buckets.length; i2++) {
                var currBucket = pipe.buckets[i2];
                var bucketSize = currBucket.offset - currBucket.roffset;
                if (toRead <= bucketSize) {
                  var tmpSlice = currBucket.buffer.subarray(currBucket.roffset, currBucket.offset);
                  if (toRead < bucketSize) {
                    tmpSlice = tmpSlice.subarray(0, toRead);
                    currBucket.roffset += toRead;
                  } else {
                    toRemove++;
                  }
                  data2.set(tmpSlice);
                  break;
                } else {
                  var tmpSlice = currBucket.buffer.subarray(currBucket.roffset, currBucket.offset);
                  data2.set(tmpSlice);
                  data2 = data2.subarray(tmpSlice.byteLength);
                  toRead -= tmpSlice.byteLength;
                  toRemove++;
                }
              }
              if (toRemove && toRemove == pipe.buckets.length) {
                toRemove--;
                pipe.buckets[toRemove].offset = 0;
                pipe.buckets[toRemove].roffset = 0;
              }
              pipe.buckets.splice(0, toRemove);
              return totalRead;
            },
            write(stream, buffer, offset, length, position) {
              var pipe = stream.node.pipe;
              var data2 = buffer.subarray(offset, offset + length);
              var dataLen = data2.byteLength;
              if (dataLen <= 0) {
                return 0;
              }
              var currBucket = null;
              if (pipe.buckets.length == 0) {
                currBucket = {
                  buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
                  offset: 0,
                  roffset: 0
                };
                pipe.buckets.push(currBucket);
              } else {
                currBucket = pipe.buckets[pipe.buckets.length - 1];
              }
              assert(currBucket.offset <= PIPEFS.BUCKET_BUFFER_SIZE);
              var freeBytesInCurrBuffer = PIPEFS.BUCKET_BUFFER_SIZE - currBucket.offset;
              if (freeBytesInCurrBuffer >= dataLen) {
                currBucket.buffer.set(data2, currBucket.offset);
                currBucket.offset += dataLen;
                return dataLen;
              } else if (freeBytesInCurrBuffer > 0) {
                currBucket.buffer.set(data2.subarray(0, freeBytesInCurrBuffer), currBucket.offset);
                currBucket.offset += freeBytesInCurrBuffer;
                data2 = data2.subarray(freeBytesInCurrBuffer, data2.byteLength);
              }
              var numBuckets = data2.byteLength / PIPEFS.BUCKET_BUFFER_SIZE | 0;
              var remElements = data2.byteLength % PIPEFS.BUCKET_BUFFER_SIZE;
              for (var i2 = 0; i2 < numBuckets; i2++) {
                var newBucket = {
                  buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
                  offset: PIPEFS.BUCKET_BUFFER_SIZE,
                  roffset: 0
                };
                pipe.buckets.push(newBucket);
                newBucket.buffer.set(data2.subarray(0, PIPEFS.BUCKET_BUFFER_SIZE));
                data2 = data2.subarray(PIPEFS.BUCKET_BUFFER_SIZE, data2.byteLength);
              }
              if (remElements > 0) {
                var newBucket = {
                  buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
                  offset: data2.byteLength,
                  roffset: 0
                };
                pipe.buckets.push(newBucket);
                newBucket.buffer.set(data2);
              }
              return dataLen;
            },
            close(stream) {
              var pipe = stream.node.pipe;
              pipe.refcnt--;
              if (pipe.refcnt === 0) {
                pipe.buckets = null;
              }
            }
          },
          nextname() {
            if (!PIPEFS.nextname.current) {
              PIPEFS.nextname.current = 0;
            }
            return "pipe[" + PIPEFS.nextname.current++ + "]";
          }
        };
        function ___syscall_pipe(fdPtr) {
          fdPtr >>>= 0;
          try {
            if (fdPtr == 0) {
              throw new FS.ErrnoError(21);
            }
            var res = PIPEFS.createPipe();
            HEAP32[fdPtr >>> 2 >>> 0] = res.readable_fd;
            HEAP32[fdPtr + 4 >>> 2 >>> 0] = res.writable_fd;
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_pipe.sig = "ip";
        function ___syscall_poll(fds, nfds, timeout) {
          fds >>>= 0;
          try {
            var nonzero = 0;
            for (var i2 = 0; i2 < nfds; i2++) {
              var pollfd = fds + 8 * i2;
              var fd = HEAP32[pollfd >>> 2 >>> 0];
              var events = HEAP16[pollfd + 4 >>> 1 >>> 0];
              var mask = 32;
              var stream = FS.getStream(fd);
              if (stream) {
                mask = SYSCALLS.DEFAULT_POLLMASK;
                if (stream.stream_ops.poll) {
                  mask = stream.stream_ops.poll(stream, -1);
                }
              }
              mask &= events | 8 | 16;
              if (mask)
                nonzero++;
              HEAP16[pollfd + 6 >>> 1 >>> 0] = mask;
            }
            return nonzero;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_poll.sig = "ipii";
        function ___syscall_readlinkat(dirfd, path2, buf, bufsize) {
          path2 >>>= 0;
          buf >>>= 0;
          bufsize >>>= 0;
          try {
            path2 = SYSCALLS.getStr(path2);
            path2 = SYSCALLS.calculateAt(dirfd, path2);
            if (bufsize <= 0)
              return -28;
            var ret = FS.readlink(path2);
            var len2 = Math.min(bufsize, lengthBytesUTF8(ret));
            var endChar = HEAP8[buf + len2 >>> 0];
            stringToUTF8(ret, buf, bufsize + 1);
            HEAP8[buf + len2 >>> 0] = endChar;
            return len2;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_readlinkat.sig = "iippp";
        function ___syscall_recvfrom(fd, buf, len2, flags2, addr2, addrlen) {
          buf >>>= 0;
          len2 >>>= 0;
          addr2 >>>= 0;
          addrlen >>>= 0;
          try {
            var sock = getSocketFromFD(fd);
            var msg = sock.sock_ops.recvmsg(sock, len2);
            if (!msg)
              return 0;
            if (addr2) {
              var errno = writeSockaddr(addr2, sock.family, DNS.lookup_name(msg.addr), msg.port, addrlen);
            }
            HEAPU8.set(msg.buffer, buf >>> 0);
            return msg.buffer.byteLength;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_recvfrom.sig = "iippipp";
        function ___syscall_recvmsg(fd, message, flags2, d1, d2, d3) {
          message >>>= 0;
          try {
            var sock = getSocketFromFD(fd);
            var iov = HEAPU32[message + 8 >>> 2 >>> 0];
            var num = HEAP32[message + 12 >>> 2 >>> 0];
            var total = 0;
            for (var i2 = 0; i2 < num; i2++) {
              total += HEAP32[iov + (8 * i2 + 4) >>> 2 >>> 0];
            }
            var msg = sock.sock_ops.recvmsg(sock, total);
            if (!msg)
              return 0;
            var name2 = HEAPU32[message >>> 2 >>> 0];
            if (name2) {
              var errno = writeSockaddr(name2, sock.family, DNS.lookup_name(msg.addr), msg.port);
            }
            var bytesRead = 0;
            var bytesRemaining = msg.buffer.byteLength;
            for (var i2 = 0; bytesRemaining > 0 && i2 < num; i2++) {
              var iovbase = HEAPU32[iov + (8 * i2 + 0) >>> 2 >>> 0];
              var iovlen = HEAP32[iov + (8 * i2 + 4) >>> 2 >>> 0];
              if (!iovlen) {
                continue;
              }
              var length = Math.min(iovlen, bytesRemaining);
              var buf = msg.buffer.subarray(bytesRead, bytesRead + length);
              HEAPU8.set(buf, iovbase + bytesRead >>> 0);
              bytesRead += length;
              bytesRemaining -= length;
            }
            return bytesRead;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_recvmsg.sig = "iipiiii";
        function ___syscall_renameat(olddirfd, oldpath, newdirfd, newpath) {
          oldpath >>>= 0;
          newpath >>>= 0;
          try {
            oldpath = SYSCALLS.getStr(oldpath);
            newpath = SYSCALLS.getStr(newpath);
            oldpath = SYSCALLS.calculateAt(olddirfd, oldpath);
            newpath = SYSCALLS.calculateAt(newdirfd, newpath);
            FS.rename(oldpath, newpath);
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_renameat.sig = "iipip";
        function ___syscall_rmdir(path2) {
          path2 >>>= 0;
          try {
            path2 = SYSCALLS.getStr(path2);
            FS.rmdir(path2);
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_rmdir.sig = "ip";
        function ___syscall_sendmsg(fd, message, flags2, d1, d2, d3) {
          message >>>= 0;
          d1 >>>= 0;
          d2 >>>= 0;
          try {
            var sock = getSocketFromFD(fd);
            var iov = HEAPU32[message + 8 >>> 2 >>> 0];
            var num = HEAP32[message + 12 >>> 2 >>> 0];
            var addr2, port;
            var name2 = HEAPU32[message >>> 2 >>> 0];
            var namelen = HEAP32[message + 4 >>> 2 >>> 0];
            if (name2) {
              var info2 = readSockaddr(name2, namelen);
              if (info2.errno)
                return -info2.errno;
              port = info2.port;
              addr2 = DNS.lookup_addr(info2.addr) || info2.addr;
            }
            var total = 0;
            for (var i2 = 0; i2 < num; i2++) {
              total += HEAP32[iov + (8 * i2 + 4) >>> 2 >>> 0];
            }
            var view = new Uint8Array(total);
            var offset = 0;
            for (var i2 = 0; i2 < num; i2++) {
              var iovbase = HEAPU32[iov + (8 * i2 + 0) >>> 2 >>> 0];
              var iovlen = HEAP32[iov + (8 * i2 + 4) >>> 2 >>> 0];
              for (var j = 0; j < iovlen; j++) {
                view[offset++] = HEAP8[iovbase + j >>> 0 >>> 0];
              }
            }
            return sock.sock_ops.sendmsg(sock, view, 0, total, addr2, port);
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_sendmsg.sig = "iipippi";
        function ___syscall_sendto(fd, message, length, flags2, addr2, addr_len) {
          message >>>= 0;
          length >>>= 0;
          addr2 >>>= 0;
          addr_len >>>= 0;
          try {
            var sock = getSocketFromFD(fd);
            var dest = getSocketAddress(addr2, addr_len, true);
            if (!dest) {
              return FS.write(sock.stream, HEAP8, message, length);
            }
            return sock.sock_ops.sendmsg(sock, HEAP8, message, length, dest.addr, dest.port);
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_sendto.sig = "iippipp";
        function ___syscall_socket(domain, type, protocol) {
          try {
            var sock = SOCKFS.createSocket(domain, type, protocol);
            return sock.stream.fd;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_socket.sig = "iiiiiii";
        function ___syscall_stat64(path2, buf) {
          path2 >>>= 0;
          buf >>>= 0;
          try {
            path2 = SYSCALLS.getStr(path2);
            return SYSCALLS.doStat(FS.stat, path2, buf);
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_stat64.sig = "ipp";
        function ___syscall_symlink(target, linkpath) {
          target >>>= 0;
          linkpath >>>= 0;
          try {
            target = SYSCALLS.getStr(target);
            linkpath = SYSCALLS.getStr(linkpath);
            FS.symlink(target, linkpath);
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_symlink.sig = "ipp";
        function ___syscall_symlinkat(target, newdirfd, linkpath) {
          target >>>= 0;
          linkpath >>>= 0;
          try {
            linkpath = SYSCALLS.calculateAt(newdirfd, linkpath);
            FS.symlink(target, linkpath);
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_symlinkat.sig = "ipip";
        function ___syscall_truncate64(path2, length_low, length_high) {
          path2 >>>= 0;
          var length = convertI32PairToI53Checked(length_low, length_high);
          try {
            if (isNaN(length))
              return 61;
            path2 = SYSCALLS.getStr(path2);
            FS.truncate(path2, length);
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_truncate64.sig = "ipii";
        function ___syscall_unlinkat(dirfd, path2, flags2) {
          path2 >>>= 0;
          try {
            path2 = SYSCALLS.getStr(path2);
            path2 = SYSCALLS.calculateAt(dirfd, path2);
            if (flags2 === 0) {
              FS.unlink(path2);
            } else if (flags2 === 512) {
              FS.rmdir(path2);
            } else {
              abort("Invalid flags passed to unlinkat");
            }
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_unlinkat.sig = "iipi";
        var readI53FromI64 = (ptr2) => HEAPU32[ptr2 >>> 2 >>> 0] + HEAP32[ptr2 + 4 >>> 2 >>> 0] * 4294967296;
        function ___syscall_utimensat(dirfd, path2, times, flags2) {
          path2 >>>= 0;
          times >>>= 0;
          try {
            path2 = SYSCALLS.getStr(path2);
            path2 = SYSCALLS.calculateAt(dirfd, path2, true);
            if (!times) {
              var atime = Date.now();
              var mtime = atime;
            } else {
              var seconds = readI53FromI64(times);
              var nanoseconds = HEAP32[times + 8 >>> 2 >>> 0];
              atime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
              times += 16;
              seconds = readI53FromI64(times);
              nanoseconds = HEAP32[times + 8 >>> 2 >>> 0];
              mtime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
            }
            FS.utime(path2, atime, mtime);
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        ___syscall_utimensat.sig = "iippi";
        var ___table_base = new WebAssembly.Global({
          "value": "i32",
          "mutable": false
        }, 1);
        var ENV = {};
        var stringToUTF8OnStack = (str) => {
          var size = lengthBytesUTF8(str) + 1;
          var ret = stackAlloc(size);
          stringToUTF8(str, ret, size);
          return ret;
        };
        var withStackSave = (f) => {
          var stack = stackSave();
          var ret = f();
          stackRestore(stack);
          return ret;
        };
        var dlSetError = (msg) => {
          withStackSave(() => {
            var cmsg = stringToUTF8OnStack(msg);
            ___dl_seterr(cmsg, 0);
          });
        };
        var dlopenInternal = (handle2, jsflags) => {
          var filename = UTF8ToString(handle2 + 36);
          var flags2 = HEAP32[handle2 + 4 >>> 2 >>> 0];
          filename = PATH.normalize(filename);
          var searchpaths = [];
          var global2 = Boolean(flags2 & 256);
          var localScope2 = global2 ? null : {};
          var combinedFlags = {
            global: global2,
            nodelete: Boolean(flags2 & 4096),
            loadAsync: jsflags.loadAsync
          };
          if (jsflags.loadAsync) {
            return loadDynamicLibrary(filename, combinedFlags, localScope2, handle2);
          }
          try {
            return loadDynamicLibrary(filename, combinedFlags, localScope2, handle2);
          } catch (e) {
            dlSetError(`Could not load dynamic lib: ${filename}
${e}`);
            return 0;
          }
        };
        function __dlopen_js(handle2) {
          handle2 >>>= 0;
          return dlopenInternal(handle2, {
            loadAsync: false
          });
        }
        __dlopen_js.sig = "pp";
        function __dlsym_js(handle2, symbol, symbolIndex) {
          handle2 >>>= 0;
          symbol >>>= 0;
          symbolIndex >>>= 0;
          symbol = UTF8ToString(symbol);
          var result;
          var newSymIndex;
          var lib = LDSO.loadedLibsByHandle[handle2];
          if (!lib.exports.hasOwnProperty(symbol) || lib.exports[symbol].stub) {
            dlSetError(`Tried to lookup unknown symbol "${symbol}" in dynamic lib: ${lib.name}`);
            return 0;
          }
          newSymIndex = Object.keys(lib.exports).indexOf(symbol);
          var origSym = "orig$" + symbol;
          result = lib.exports[origSym];
          if (result) {
            newSymIndex = Object.keys(lib.exports).indexOf(origSym);
          } else
            result = lib.exports[symbol];
          if (typeof result == "function") {
            var addr2 = getFunctionAddress(result);
            if (addr2) {
              result = addr2;
            } else {
              result = addFunction(result, result.sig);
              HEAPU32[symbolIndex >>> 2 >>> 0] = newSymIndex;
            }
          }
          return result;
        }
        __dlsym_js.sig = "pppp";
        function __embind_register_bigint(primitiveType, name2, size, minRange, maxRange) {
          primitiveType >>>= 0;
          name2 >>>= 0;
          size >>>= 0;
        }
        __embind_register_bigint.sig = "vpppiiii";
        var embind_init_charCodes = () => {
          var codes = new Array(256);
          for (var i2 = 0; i2 < 256; ++i2) {
            codes[i2] = String.fromCharCode(i2);
          }
          embind_charCodes = codes;
        };
        var embind_charCodes;
        var readLatin1String = (ptr2) => {
          var ret = "";
          var c = ptr2;
          while (HEAPU8[c >>> 0]) {
            ret += embind_charCodes[HEAPU8[c++ >>> 0]];
          }
          return ret;
        };
        var awaitingDependencies = {};
        var registeredTypes = {};
        var typeDependencies = {};
        var BindingError;
        var throwBindingError = (message) => {
          throw new BindingError(message);
        };
        var InternalError;
        var throwInternalError = (message) => {
          throw new InternalError(message);
        };
        var whenDependentTypesAreResolved = (myTypes, dependentTypes, getTypeConverters) => {
          myTypes.forEach(function(type) {
            typeDependencies[type] = dependentTypes;
          });
          function onComplete(typeConverters2) {
            var myTypeConverters = getTypeConverters(typeConverters2);
            if (myTypeConverters.length !== myTypes.length) {
              throwInternalError("Mismatched type converter count");
            }
            for (var i2 = 0; i2 < myTypes.length; ++i2) {
              registerType(myTypes[i2], myTypeConverters[i2]);
            }
          }
          var typeConverters = new Array(dependentTypes.length);
          var unregisteredTypes = [];
          var registered = 0;
          dependentTypes.forEach((dt, i2) => {
            if (registeredTypes.hasOwnProperty(dt)) {
              typeConverters[i2] = registeredTypes[dt];
            } else {
              unregisteredTypes.push(dt);
              if (!awaitingDependencies.hasOwnProperty(dt)) {
                awaitingDependencies[dt] = [];
              }
              awaitingDependencies[dt].push(() => {
                typeConverters[i2] = registeredTypes[dt];
                ++registered;
                if (registered === unregisteredTypes.length) {
                  onComplete(typeConverters);
                }
              });
            }
          });
          if (0 === unregisteredTypes.length) {
            onComplete(typeConverters);
          }
        };
        function sharedRegisterType(rawType, registeredInstance, options = {}) {
          var name2 = registeredInstance.name;
          if (!rawType) {
            throwBindingError(`type "${name2}" must have a positive integer typeid pointer`);
          }
          if (registeredTypes.hasOwnProperty(rawType)) {
            if (options.ignoreDuplicateRegistrations) {
              return;
            } else {
              throwBindingError(`Cannot register type '${name2}' twice`);
            }
          }
          registeredTypes[rawType] = registeredInstance;
          delete typeDependencies[rawType];
          if (awaitingDependencies.hasOwnProperty(rawType)) {
            var callbacks = awaitingDependencies[rawType];
            delete awaitingDependencies[rawType];
            callbacks.forEach((cb) => cb());
          }
        }
        function registerType(rawType, registeredInstance, options = {}) {
          if (!("argPackAdvance" in registeredInstance)) {
            throw new TypeError("registerType registeredInstance requires argPackAdvance");
          }
          return sharedRegisterType(rawType, registeredInstance, options);
        }
        var GenericWireTypeSize = 8;
        function __embind_register_bool(rawType, name2, trueValue, falseValue) {
          rawType >>>= 0;
          name2 >>>= 0;
          name2 = readLatin1String(name2);
          registerType(rawType, {
            name: name2,
            "fromWireType": function(wt) {
              return !!wt;
            },
            "toWireType": function(destructors, o) {
              return o ? trueValue : falseValue;
            },
            "argPackAdvance": GenericWireTypeSize,
            "readValueFromPointer": function(pointer) {
              return this["fromWireType"](HEAPU8[pointer >>> 0]);
            },
            destructorFunction: null
          });
        }
        __embind_register_bool.sig = "vppii";
        class HandleAllocator {
          constructor() {
            this.allocated = [void 0];
            this.freelist = [];
          }
          get(id) {
            return this.allocated[id];
          }
          has(id) {
            return this.allocated[id] !== void 0;
          }
          allocate(handle2) {
            var id = this.freelist.pop() || this.allocated.length;
            this.allocated[id] = handle2;
            return id;
          }
          free(id) {
            this.allocated[id] = void 0;
            this.freelist.push(id);
          }
        }
        var emval_handles = new HandleAllocator();
        function __emval_decref(handle2) {
          handle2 >>>= 0;
          if (handle2 >= emval_handles.reserved && 0 === --emval_handles.get(handle2).refcount) {
            emval_handles.free(handle2);
          }
        }
        __emval_decref.sig = "vp";
        var count_emval_handles = () => {
          var count = 0;
          for (var i2 = emval_handles.reserved; i2 < emval_handles.allocated.length; ++i2) {
            if (emval_handles.allocated[i2] !== void 0) {
              ++count;
            }
          }
          return count;
        };
        var init_emval = () => {
          emval_handles.allocated.push({
            value: void 0
          }, {
            value: null
          }, {
            value: true
          }, {
            value: false
          });
          Object.assign(emval_handles, {
            reserved: emval_handles.allocated.length
          }), Module["count_emval_handles"] = count_emval_handles;
        };
        var Emval = {
          toValue: (handle2) => {
            if (!handle2) {
              throwBindingError("Cannot use deleted val. handle = " + handle2);
            }
            return emval_handles.get(handle2).value;
          },
          toHandle: (value) => {
            switch (value) {
              case void 0:
                return 1;
              case null:
                return 2;
              case true:
                return 3;
              case false:
                return 4;
              default: {
                return emval_handles.allocate({
                  refcount: 1,
                  value
                });
              }
            }
          }
        };
        function simpleReadValueFromPointer(pointer) {
          return this["fromWireType"](HEAP32[pointer >>> 2 >>> 0]);
        }
        var EmValType = {
          name: "emscripten::val",
          "fromWireType": (handle2) => {
            var rv = Emval.toValue(handle2);
            __emval_decref(handle2);
            return rv;
          },
          "toWireType": (destructors, value) => Emval.toHandle(value),
          "argPackAdvance": GenericWireTypeSize,
          "readValueFromPointer": simpleReadValueFromPointer,
          destructorFunction: null
        };
        function __embind_register_emval(rawType) {
          rawType >>>= 0;
          return registerType(rawType, EmValType);
        }
        __embind_register_emval.sig = "vp";
        var embindRepr = (v) => {
          if (v === null) {
            return "null";
          }
          var t = typeof v;
          if (t === "object" || t === "array" || t === "function") {
            return v.toString();
          } else {
            return "" + v;
          }
        };
        var floatReadValueFromPointer = (name2, width) => {
          switch (width) {
            case 4:
              return function(pointer) {
                return this["fromWireType"](HEAPF32[pointer >>> 2 >>> 0]);
              };
            case 8:
              return function(pointer) {
                return this["fromWireType"](HEAPF64[pointer >>> 3 >>> 0]);
              };
            default:
              throw new TypeError(`invalid float width (${width}): ${name2}`);
          }
        };
        var __embind_register_float = function(rawType, name2, size) {
          rawType >>>= 0;
          name2 >>>= 0;
          size >>>= 0;
          name2 = readLatin1String(name2);
          registerType(rawType, {
            name: name2,
            "fromWireType": (value) => value,
            "toWireType": (destructors, value) => value,
            "argPackAdvance": GenericWireTypeSize,
            "readValueFromPointer": floatReadValueFromPointer(name2, size),
            destructorFunction: null
          });
        };
        __embind_register_float.sig = "vppp";
        var integerReadValueFromPointer = (name2, width, signed) => {
          switch (width) {
            case 1:
              return signed ? (pointer) => HEAP8[pointer >>> 0 >>> 0] : (pointer) => HEAPU8[pointer >>> 0 >>> 0];
            case 2:
              return signed ? (pointer) => HEAP16[pointer >>> 1 >>> 0] : (pointer) => HEAPU16[pointer >>> 1 >>> 0];
            case 4:
              return signed ? (pointer) => HEAP32[pointer >>> 2 >>> 0] : (pointer) => HEAPU32[pointer >>> 2 >>> 0];
            default:
              throw new TypeError(`invalid integer width (${width}): ${name2}`);
          }
        };
        function __embind_register_integer(primitiveType, name2, size, minRange, maxRange) {
          primitiveType >>>= 0;
          name2 >>>= 0;
          size >>>= 0;
          name2 = readLatin1String(name2);
          if (maxRange === -1) {
            maxRange = 4294967295;
          }
          var fromWireType = (value) => value;
          if (minRange === 0) {
            var bitshift = 32 - 8 * size;
            fromWireType = (value) => value << bitshift >>> bitshift;
          }
          var isUnsignedType = name2.includes("unsigned");
          var checkAssertions = (value, toTypeName) => {
          };
          var toWireType;
          if (isUnsignedType) {
            toWireType = function(destructors, value) {
              checkAssertions(value, this.name);
              return value >>> 0;
            };
          } else {
            toWireType = function(destructors, value) {
              checkAssertions(value, this.name);
              return value;
            };
          }
          registerType(primitiveType, {
            name: name2,
            "fromWireType": fromWireType,
            "toWireType": toWireType,
            "argPackAdvance": GenericWireTypeSize,
            "readValueFromPointer": integerReadValueFromPointer(name2, size, minRange !== 0),
            destructorFunction: null
          });
        }
        __embind_register_integer.sig = "vpppii";
        function __embind_register_memory_view(rawType, dataTypeIndex, name2) {
          rawType >>>= 0;
          name2 >>>= 0;
          var typeMapping = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
          var TA = typeMapping[dataTypeIndex];
          function decodeMemoryView(handle2) {
            var size = HEAPU32[handle2 >>> 2 >>> 0];
            var data2 = HEAPU32[handle2 + 4 >>> 2 >>> 0];
            return new TA(HEAP8.buffer, data2, size);
          }
          name2 = readLatin1String(name2);
          registerType(rawType, {
            name: name2,
            "fromWireType": decodeMemoryView,
            "argPackAdvance": GenericWireTypeSize,
            "readValueFromPointer": decodeMemoryView
          }, {
            ignoreDuplicateRegistrations: true
          });
        }
        __embind_register_memory_view.sig = "vpip";
        function readPointer(pointer) {
          return this["fromWireType"](HEAPU32[pointer >>> 2 >>> 0]);
        }
        function __embind_register_std_string(rawType, name2) {
          rawType >>>= 0;
          name2 >>>= 0;
          name2 = readLatin1String(name2);
          var stdStringIsUTF8 = name2 === "std::string";
          registerType(rawType, {
            name: name2,
            "fromWireType"(value) {
              var length = HEAPU32[value >>> 2 >>> 0];
              var payload = value + 4;
              var str;
              if (stdStringIsUTF8) {
                var decodeStartPtr = payload;
                for (var i2 = 0; i2 <= length; ++i2) {
                  var currentBytePtr = payload + i2;
                  if (i2 == length || HEAPU8[currentBytePtr >>> 0] == 0) {
                    var maxRead = currentBytePtr - decodeStartPtr;
                    var stringSegment = UTF8ToString(decodeStartPtr, maxRead);
                    if (str === void 0) {
                      str = stringSegment;
                    } else {
                      str += String.fromCharCode(0);
                      str += stringSegment;
                    }
                    decodeStartPtr = currentBytePtr + 1;
                  }
                }
              } else {
                var a = new Array(length);
                for (var i2 = 0; i2 < length; ++i2) {
                  a[i2] = String.fromCharCode(HEAPU8[payload + i2 >>> 0]);
                }
                str = a.join("");
              }
              _free(value);
              return str;
            },
            "toWireType"(destructors, value) {
              if (value instanceof ArrayBuffer) {
                value = new Uint8Array(value);
              }
              var length;
              var valueIsOfTypeString = typeof value == "string";
              if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) {
                throwBindingError("Cannot pass non-string to std::string");
              }
              if (stdStringIsUTF8 && valueIsOfTypeString) {
                length = lengthBytesUTF8(value);
              } else {
                length = value.length;
              }
              var base = _malloc(4 + length + 1);
              var ptr2 = base + 4;
              HEAPU32[base >>> 2 >>> 0] = length;
              if (stdStringIsUTF8 && valueIsOfTypeString) {
                stringToUTF8(value, ptr2, length + 1);
              } else {
                if (valueIsOfTypeString) {
                  for (var i2 = 0; i2 < length; ++i2) {
                    var charCode = value.charCodeAt(i2);
                    if (charCode > 255) {
                      _free(ptr2);
                      throwBindingError("String has UTF-16 code units that do not fit in 8 bits");
                    }
                    HEAPU8[ptr2 + i2 >>> 0] = charCode;
                  }
                } else {
                  for (var i2 = 0; i2 < length; ++i2) {
                    HEAPU8[ptr2 + i2 >>> 0] = value[i2];
                  }
                }
              }
              if (destructors !== null) {
                destructors.push(_free, base);
              }
              return base;
            },
            "argPackAdvance": GenericWireTypeSize,
            "readValueFromPointer": readPointer,
            destructorFunction(ptr2) {
              _free(ptr2);
            }
          });
        }
        __embind_register_std_string.sig = "vpp";
        var UTF16Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf-16le") : void 0;
        var UTF16ToString = (ptr2, maxBytesToRead) => {
          var endPtr = ptr2;
          var idx = endPtr >> 1;
          var maxIdx = idx + maxBytesToRead / 2;
          while (!(idx >= maxIdx) && HEAPU16[idx >>> 0])
            ++idx;
          endPtr = idx << 1;
          if (endPtr - ptr2 > 32 && UTF16Decoder)
            return UTF16Decoder.decode(HEAPU8.subarray(ptr2 >>> 0, endPtr >>> 0));
          var str = "";
          for (var i2 = 0; !(i2 >= maxBytesToRead / 2); ++i2) {
            var codeUnit = HEAP16[ptr2 + i2 * 2 >>> 1 >>> 0];
            if (codeUnit == 0)
              break;
            str += String.fromCharCode(codeUnit);
          }
          return str;
        };
        var stringToUTF16 = (str, outPtr, maxBytesToWrite) => {
          maxBytesToWrite ?? (maxBytesToWrite = 2147483647);
          if (maxBytesToWrite < 2)
            return 0;
          maxBytesToWrite -= 2;
          var startPtr = outPtr;
          var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;
          for (var i2 = 0; i2 < numCharsToWrite; ++i2) {
            var codeUnit = str.charCodeAt(i2);
            HEAP16[outPtr >>> 1 >>> 0] = codeUnit;
            outPtr += 2;
          }
          HEAP16[outPtr >>> 1 >>> 0] = 0;
          return outPtr - startPtr;
        };
        var lengthBytesUTF16 = (str) => str.length * 2;
        var UTF32ToString = (ptr2, maxBytesToRead) => {
          var i2 = 0;
          var str = "";
          while (!(i2 >= maxBytesToRead / 4)) {
            var utf32 = HEAP32[ptr2 + i2 * 4 >>> 2 >>> 0];
            if (utf32 == 0)
              break;
            ++i2;
            if (utf32 >= 65536) {
              var ch = utf32 - 65536;
              str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
            } else {
              str += String.fromCharCode(utf32);
            }
          }
          return str;
        };
        var stringToUTF32 = (str, outPtr, maxBytesToWrite) => {
          outPtr >>>= 0;
          maxBytesToWrite ?? (maxBytesToWrite = 2147483647);
          if (maxBytesToWrite < 4)
            return 0;
          var startPtr = outPtr;
          var endPtr = startPtr + maxBytesToWrite - 4;
          for (var i2 = 0; i2 < str.length; ++i2) {
            var codeUnit = str.charCodeAt(i2);
            if (codeUnit >= 55296 && codeUnit <= 57343) {
              var trailSurrogate = str.charCodeAt(++i2);
              codeUnit = 65536 + ((codeUnit & 1023) << 10) | trailSurrogate & 1023;
            }
            HEAP32[outPtr >>> 2 >>> 0] = codeUnit;
            outPtr += 4;
            if (outPtr + 4 > endPtr)
              break;
          }
          HEAP32[outPtr >>> 2 >>> 0] = 0;
          return outPtr - startPtr;
        };
        var lengthBytesUTF32 = (str) => {
          var len2 = 0;
          for (var i2 = 0; i2 < str.length; ++i2) {
            var codeUnit = str.charCodeAt(i2);
            if (codeUnit >= 55296 && codeUnit <= 57343)
              ++i2;
            len2 += 4;
          }
          return len2;
        };
        var __embind_register_std_wstring = function(rawType, charSize, name2) {
          rawType >>>= 0;
          charSize >>>= 0;
          name2 >>>= 0;
          name2 = readLatin1String(name2);
          var decodeString, encodeString, getHeap, lengthBytesUTF, shift;
          if (charSize === 2) {
            decodeString = UTF16ToString;
            encodeString = stringToUTF16;
            lengthBytesUTF = lengthBytesUTF16;
            getHeap = () => HEAPU16;
            shift = 1;
          } else if (charSize === 4) {
            decodeString = UTF32ToString;
            encodeString = stringToUTF32;
            lengthBytesUTF = lengthBytesUTF32;
            getHeap = () => HEAPU32;
            shift = 2;
          }
          registerType(rawType, {
            name: name2,
            "fromWireType": (value) => {
              var length = HEAPU32[value >>> 2 >>> 0];
              var HEAP2 = getHeap();
              var str;
              var decodeStartPtr = value + 4;
              for (var i2 = 0; i2 <= length; ++i2) {
                var currentBytePtr = value + 4 + i2 * charSize;
                if (i2 == length || HEAP2[currentBytePtr >>> shift] == 0) {
                  var maxReadBytes = currentBytePtr - decodeStartPtr;
                  var stringSegment = decodeString(decodeStartPtr, maxReadBytes);
                  if (str === void 0) {
                    str = stringSegment;
                  } else {
                    str += String.fromCharCode(0);
                    str += stringSegment;
                  }
                  decodeStartPtr = currentBytePtr + charSize;
                }
              }
              _free(value);
              return str;
            },
            "toWireType": (destructors, value) => {
              if (!(typeof value == "string")) {
                throwBindingError(`Cannot pass non-string to C++ string type ${name2}`);
              }
              var length = lengthBytesUTF(value);
              var ptr2 = _malloc(4 + length + charSize);
              HEAPU32[ptr2 >>> 2 >>> 0] = length >> shift;
              encodeString(value, ptr2 + 4, length + charSize);
              if (destructors !== null) {
                destructors.push(_free, ptr2);
              }
              return ptr2;
            },
            "argPackAdvance": GenericWireTypeSize,
            "readValueFromPointer": simpleReadValueFromPointer,
            destructorFunction(ptr2) {
              _free(ptr2);
            }
          });
        };
        __embind_register_std_wstring.sig = "vppp";
        var __embind_register_void = function(rawType, name2) {
          rawType >>>= 0;
          name2 >>>= 0;
          name2 = readLatin1String(name2);
          registerType(rawType, {
            isVoid: true,
            name: name2,
            "argPackAdvance": 0,
            "fromWireType": () => void 0,
            "toWireType": (destructors, o) => void 0
          });
        };
        __embind_register_void.sig = "vpp";
        var handleException = (e) => {
          if (e instanceof ExitStatus || e == "unwind") {
            return EXITSTATUS;
          }
          quit_(1, e);
        };
        var runtimeKeepaliveCounter = 0;
        var keepRuntimeAlive = () => noExitRuntime || runtimeKeepaliveCounter > 0;
        var _proc_exit = (code) => {
          var _a;
          EXITSTATUS = code;
          if (!keepRuntimeAlive()) {
            (_a = Module["onExit"]) == null ? void 0 : _a.call(Module, code);
            ABORT = true;
          }
          quit_(code, new ExitStatus(code));
        };
        _proc_exit.sig = "vi";
        var exitJS = (status, implicit) => {
          EXITSTATUS = status;
          _proc_exit(status);
        };
        var _exit = exitJS;
        _exit.sig = "vi";
        var maybeExit = () => {
          if (!keepRuntimeAlive()) {
            try {
              _exit(EXITSTATUS);
            } catch (e) {
              handleException(e);
            }
          }
        };
        var callUserCallback = (func2) => {
          if (ABORT) {
            return;
          }
          try {
            func2();
            maybeExit();
          } catch (e) {
            handleException(e);
          }
        };
        function __emscripten_dlopen_js(handle2, onsuccess, onerror2, user_data) {
          handle2 >>>= 0;
          onsuccess >>>= 0;
          onerror2 >>>= 0;
          user_data >>>= 0;
          function errorCallback(e) {
            var filename = UTF8ToString(handle2 + 36);
            dlSetError(`'Could not load dynamic lib: ${filename}
${e}`);
            callUserCallback(() => getWasmTableEntry(onerror2)(handle2, user_data));
          }
          function successCallback() {
            callUserCallback(() => getWasmTableEntry(onsuccess)(handle2, user_data));
          }
          var promise = dlopenInternal(handle2, {
            loadAsync: true
          });
          if (promise) {
            promise.then(successCallback, errorCallback);
          } else {
            errorCallback();
          }
        }
        __emscripten_dlopen_js.sig = "vpppp";
        var nowIsMonotonic = 1;
        var __emscripten_get_now_is_monotonic = () => nowIsMonotonic;
        __emscripten_get_now_is_monotonic.sig = "i";
        function __emscripten_get_progname(str, len2) {
          str >>>= 0;
          stringToUTF8(thisProgram, str, len2);
        }
        __emscripten_get_progname.sig = "vpi";
        function __emscripten_lookup_name(name2) {
          name2 >>>= 0;
          var nameString = UTF8ToString(name2);
          return inetPton4(DNS.lookup_name(nameString));
        }
        __emscripten_lookup_name.sig = "ip";
        var __emscripten_runtime_keepalive_clear = () => {
          noExitRuntime = false;
          runtimeKeepaliveCounter = 0;
        };
        __emscripten_runtime_keepalive_clear.sig = "v";
        function __emscripten_set_offscreencanvas_size(target, width, height) {
          target >>>= 0;
          return -1;
        }
        __emscripten_set_offscreencanvas_size.sig = "ipii";
        function __emscripten_system(command) {
          command >>>= 0;
          if (ENVIRONMENT_IS_NODE) {
            if (!command)
              return 1;
            var cmdstr = UTF8ToString(command);
            if (!cmdstr.length)
              return 0;
            var cp = ["child_process"].map(require);
            var ret = cp.spawnSync(cmdstr, [], {
              shell: true,
              stdio: "inherit"
            });
            var _W_EXITCODE = (ret2, sig) => ret2 << 8 | sig;
            if (ret.status === null) {
              var signalToNumber = (sig) => {
                switch (sig) {
                  case "SIGHUP":
                    return 1;
                  case "SIGINT":
                    return 2;
                  case "SIGQUIT":
                    return 3;
                  case "SIGFPE":
                    return 8;
                  case "SIGKILL":
                    return 9;
                  case "SIGALRM":
                    return 14;
                  case "SIGTERM":
                    return 15;
                }
                return 2;
              };
              return _W_EXITCODE(0, signalToNumber(ret.signal));
            }
            return _W_EXITCODE(ret.status, 0);
          }
          if (!command)
            return 0;
          return -52;
        }
        __emscripten_system.sig = "ip";
        function __gmtime_js(time_low, time_high, tmPtr) {
          var time = convertI32PairToI53Checked(time_low, time_high);
          tmPtr >>>= 0;
          var date = new Date(time * 1e3);
          HEAP32[tmPtr >>> 2 >>> 0] = date.getUTCSeconds();
          HEAP32[tmPtr + 4 >>> 2 >>> 0] = date.getUTCMinutes();
          HEAP32[tmPtr + 8 >>> 2 >>> 0] = date.getUTCHours();
          HEAP32[tmPtr + 12 >>> 2 >>> 0] = date.getUTCDate();
          HEAP32[tmPtr + 16 >>> 2 >>> 0] = date.getUTCMonth();
          HEAP32[tmPtr + 20 >>> 2 >>> 0] = date.getUTCFullYear() - 1900;
          HEAP32[tmPtr + 24 >>> 2 >>> 0] = date.getUTCDay();
          var start2 = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
          var yday = (date.getTime() - start2) / (1e3 * 60 * 60 * 24) | 0;
          HEAP32[tmPtr + 28 >>> 2 >>> 0] = yday;
        }
        __gmtime_js.sig = "viip";
        var isLeapYear = (year) => year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
        var MONTH_DAYS_LEAP_CUMULATIVE = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
        var MONTH_DAYS_REGULAR_CUMULATIVE = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
        var ydayFromDate = (date) => {
          var leap = isLeapYear(date.getFullYear());
          var monthDaysCumulative = leap ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE;
          var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1;
          return yday;
        };
        function __localtime_js(time_low, time_high, tmPtr) {
          var time = convertI32PairToI53Checked(time_low, time_high);
          tmPtr >>>= 0;
          var date = new Date(time * 1e3);
          HEAP32[tmPtr >>> 2 >>> 0] = date.getSeconds();
          HEAP32[tmPtr + 4 >>> 2 >>> 0] = date.getMinutes();
          HEAP32[tmPtr + 8 >>> 2 >>> 0] = date.getHours();
          HEAP32[tmPtr + 12 >>> 2 >>> 0] = date.getDate();
          HEAP32[tmPtr + 16 >>> 2 >>> 0] = date.getMonth();
          HEAP32[tmPtr + 20 >>> 2 >>> 0] = date.getFullYear() - 1900;
          HEAP32[tmPtr + 24 >>> 2 >>> 0] = date.getDay();
          var yday = ydayFromDate(date) | 0;
          HEAP32[tmPtr + 28 >>> 2 >>> 0] = yday;
          HEAP32[tmPtr + 36 >>> 2 >>> 0] = -(date.getTimezoneOffset() * 60);
          var start2 = new Date(date.getFullYear(), 0, 1);
          var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
          var winterOffset = start2.getTimezoneOffset();
          var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;
          HEAP32[tmPtr + 32 >>> 2 >>> 0] = dst;
        }
        __localtime_js.sig = "viip";
        var __mktime_js = function(tmPtr) {
          tmPtr >>>= 0;
          var ret = (() => {
            var date = new Date(HEAP32[tmPtr + 20 >>> 2 >>> 0] + 1900, HEAP32[tmPtr + 16 >>> 2 >>> 0], HEAP32[tmPtr + 12 >>> 2 >>> 0], HEAP32[tmPtr + 8 >>> 2 >>> 0], HEAP32[tmPtr + 4 >>> 2 >>> 0], HEAP32[tmPtr >>> 2 >>> 0], 0);
            var dst = HEAP32[tmPtr + 32 >>> 2 >>> 0];
            var guessedOffset = date.getTimezoneOffset();
            var start2 = new Date(date.getFullYear(), 0, 1);
            var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
            var winterOffset = start2.getTimezoneOffset();
            var dstOffset = Math.min(winterOffset, summerOffset);
            if (dst < 0) {
              HEAP32[tmPtr + 32 >>> 2 >>> 0] = Number(summerOffset != winterOffset && dstOffset == guessedOffset);
            } else if (dst > 0 != (dstOffset == guessedOffset)) {
              var nonDstOffset = Math.max(winterOffset, summerOffset);
              var trueOffset = dst > 0 ? dstOffset : nonDstOffset;
              date.setTime(date.getTime() + (trueOffset - guessedOffset) * 6e4);
            }
            HEAP32[tmPtr + 24 >>> 2 >>> 0] = date.getDay();
            var yday = ydayFromDate(date) | 0;
            HEAP32[tmPtr + 28 >>> 2 >>> 0] = yday;
            HEAP32[tmPtr >>> 2 >>> 0] = date.getSeconds();
            HEAP32[tmPtr + 4 >>> 2 >>> 0] = date.getMinutes();
            HEAP32[tmPtr + 8 >>> 2 >>> 0] = date.getHours();
            HEAP32[tmPtr + 12 >>> 2 >>> 0] = date.getDate();
            HEAP32[tmPtr + 16 >>> 2 >>> 0] = date.getMonth();
            HEAP32[tmPtr + 20 >>> 2 >>> 0] = date.getYear();
            var timeMs = date.getTime();
            if (isNaN(timeMs)) {
              return -1;
            }
            return timeMs / 1e3;
          })();
          return setTempRet0((tempDouble = ret, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)), ret >>> 0;
        };
        __mktime_js.sig = "ip";
        function __mmap_js(len2, prot, flags2, fd, offset_low, offset_high, allocated, addr2) {
          len2 >>>= 0;
          var offset = convertI32PairToI53Checked(offset_low, offset_high);
          allocated >>>= 0;
          addr2 >>>= 0;
          try {
            if (isNaN(offset))
              return 61;
            var stream = SYSCALLS.getStreamFromFD(fd);
            var res = FS.mmap(stream, len2, offset, prot, flags2);
            var ptr2 = res.ptr;
            HEAP32[allocated >>> 2 >>> 0] = res.allocated;
            HEAPU32[addr2 >>> 2 >>> 0] = ptr2;
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        __mmap_js.sig = "ipiiiiipp";
        function __msync_js(addr2, len2, prot, flags2, fd, offset_low, offset_high) {
          addr2 >>>= 0;
          len2 >>>= 0;
          var offset = convertI32PairToI53Checked(offset_low, offset_high);
          try {
            if (isNaN(offset))
              return 61;
            SYSCALLS.doMsync(addr2, SYSCALLS.getStreamFromFD(fd), len2, flags2, offset);
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        __msync_js.sig = "ippiiiii";
        function __munmap_js(addr2, len2, prot, flags2, fd, offset_low, offset_high) {
          addr2 >>>= 0;
          len2 >>>= 0;
          var offset = convertI32PairToI53Checked(offset_low, offset_high);
          try {
            if (isNaN(offset))
              return 61;
            var stream = SYSCALLS.getStreamFromFD(fd);
            if (prot & 2) {
              SYSCALLS.doMsync(addr2, stream, len2, flags2, offset);
            }
            FS.munmap(stream);
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        __munmap_js.sig = "ippiiiii";
        var timers = {};
        var _emscripten_get_now;
        _emscripten_get_now = () => performance.now();
        _emscripten_get_now.sig = "d";
        var __setitimer_js = (which, timeout_ms) => {
          if (timers[which]) {
            clearTimeout(timers[which].id);
            delete timers[which];
          }
          if (!timeout_ms)
            return 0;
          var id = setTimeout(() => {
            delete timers[which];
            callUserCallback(() => __emscripten_timeout(which, _emscripten_get_now()));
          }, timeout_ms);
          timers[which] = {
            id,
            timeout_ms
          };
          return 0;
        };
        __setitimer_js.sig = "iid";
        var __timegm_js = function(tmPtr) {
          tmPtr >>>= 0;
          var ret = (() => {
            var time = Date.UTC(HEAP32[tmPtr + 20 >>> 2 >>> 0] + 1900, HEAP32[tmPtr + 16 >>> 2 >>> 0], HEAP32[tmPtr + 12 >>> 2 >>> 0], HEAP32[tmPtr + 8 >>> 2 >>> 0], HEAP32[tmPtr + 4 >>> 2 >>> 0], HEAP32[tmPtr >>> 2 >>> 0], 0);
            var date = new Date(time);
            HEAP32[tmPtr + 24 >>> 2 >>> 0] = date.getUTCDay();
            var start2 = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
            var yday = (date.getTime() - start2) / (1e3 * 60 * 60 * 24) | 0;
            HEAP32[tmPtr + 28 >>> 2 >>> 0] = yday;
            return date.getTime() / 1e3;
          })();
          return setTempRet0((tempDouble = ret, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)), ret >>> 0;
        };
        __timegm_js.sig = "ip";
        var stringToNewUTF8 = (str) => {
          var size = lengthBytesUTF8(str) + 1;
          var ret = _malloc(size);
          if (ret)
            stringToUTF8(str, ret, size);
          return ret;
        };
        function __tzset_js(timezone, daylight, tzname) {
          timezone >>>= 0;
          daylight >>>= 0;
          tzname >>>= 0;
          var currentYear = (/* @__PURE__ */ new Date()).getFullYear();
          var winter = new Date(currentYear, 0, 1);
          var summer = new Date(currentYear, 6, 1);
          var winterOffset = winter.getTimezoneOffset();
          var summerOffset = summer.getTimezoneOffset();
          var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
          HEAPU32[timezone >>> 2 >>> 0] = stdTimezoneOffset * 60;
          HEAP32[daylight >>> 2 >>> 0] = Number(winterOffset != summerOffset);
          function extractZone(date) {
            var match = date.toTimeString().match(/\(([A-Za-z ]+)\)$/);
            return match ? match[1] : "GMT";
          }
          var winterName = extractZone(winter);
          var summerName = extractZone(summer);
          var winterNamePtr = stringToNewUTF8(winterName);
          var summerNamePtr = stringToNewUTF8(summerName);
          if (summerOffset < winterOffset) {
            HEAPU32[tzname >>> 2 >>> 0] = winterNamePtr;
            HEAPU32[tzname + 4 >>> 2 >>> 0] = summerNamePtr;
          } else {
            HEAPU32[tzname >>> 2 >>> 0] = summerNamePtr;
            HEAPU32[tzname + 4 >>> 2 >>> 0] = winterNamePtr;
          }
        }
        __tzset_js.sig = "vppp";
        var _abort = () => {
          abort("");
        };
        _abort.sig = "v";
        var _emscripten_set_main_loop_timing = (mode, value) => {
          Browser.mainLoop.timingMode = mode;
          Browser.mainLoop.timingValue = value;
          if (!Browser.mainLoop.func) {
            return 1;
          }
          if (!Browser.mainLoop.running) {
            Browser.mainLoop.running = true;
          }
          if (mode == 0) {
            Browser.mainLoop.scheduler = function Browser_mainLoop_scheduler_setTimeout() {
              var timeUntilNextTick = Math.max(0, Browser.mainLoop.tickStartTime + value - _emscripten_get_now()) | 0;
              setTimeout(Browser.mainLoop.runner, timeUntilNextTick);
            };
            Browser.mainLoop.method = "timeout";
          } else if (mode == 1) {
            Browser.mainLoop.scheduler = function Browser_mainLoop_scheduler_rAF() {
              Browser.requestAnimationFrame(Browser.mainLoop.runner);
            };
            Browser.mainLoop.method = "rAF";
          } else if (mode == 2) {
            if (typeof Browser.setImmediate == "undefined") {
              if (typeof setImmediate == "undefined") {
                var setImmediates = [];
                var emscriptenMainLoopMessageId = "setimmediate";
                var Browser_setImmediate_messageHandler = (event2) => {
                  if (event2.data === emscriptenMainLoopMessageId || event2.data.target === emscriptenMainLoopMessageId) {
                    event2.stopPropagation();
                    setImmediates.shift()();
                  }
                };
                addEventListener("message", Browser_setImmediate_messageHandler, true);
                Browser.setImmediate = function Browser_emulated_setImmediate(func2) {
                  setImmediates.push(func2);
                  if (ENVIRONMENT_IS_WORKER) {
                    if (Module["setImmediates"] === void 0)
                      Module["setImmediates"] = [];
                    Module["setImmediates"].push(func2);
                    postMessage({
                      target: emscriptenMainLoopMessageId
                    });
                  } else
                    postMessage(emscriptenMainLoopMessageId, "*");
                };
              } else {
                Browser.setImmediate = setImmediate;
              }
            }
            Browser.mainLoop.scheduler = function Browser_mainLoop_scheduler_setImmediate() {
              Browser.setImmediate(Browser.mainLoop.runner);
            };
            Browser.mainLoop.method = "immediate";
          }
          return 0;
        };
        _emscripten_set_main_loop_timing.sig = "iii";
        var setMainLoop = (browserIterationFunc, fps, simulateInfiniteLoop, arg, noSetTiming) => {
          assert(!Browser.mainLoop.func, "emscripten_set_main_loop: there can only be one main loop function at once: call emscripten_cancel_main_loop to cancel the previous one before setting a new one with different parameters.");
          Browser.mainLoop.func = browserIterationFunc;
          Browser.mainLoop.arg = arg;
          var thisMainLoopId = Browser.mainLoop.currentlyRunningMainloop;
          function checkIsRunning() {
            if (thisMainLoopId < Browser.mainLoop.currentlyRunningMainloop) {
              return false;
            }
            return true;
          }
          Browser.mainLoop.running = false;
          Browser.mainLoop.runner = function Browser_mainLoop_runner() {
            var _a, _b;
            if (ABORT)
              return;
            if (Browser.mainLoop.queue.length > 0) {
              var start2 = Date.now();
              var blocker = Browser.mainLoop.queue.shift();
              blocker.func(blocker.arg);
              if (Browser.mainLoop.remainingBlockers) {
                var remaining = Browser.mainLoop.remainingBlockers;
                var next = remaining % 1 == 0 ? remaining - 1 : Math.floor(remaining);
                if (blocker.counted) {
                  Browser.mainLoop.remainingBlockers = next;
                } else {
                  next = next + 0.5;
                  Browser.mainLoop.remainingBlockers = (8 * remaining + next) / 9;
                }
              }
              Browser.mainLoop.updateStatus();
              if (!checkIsRunning())
                return;
              setTimeout(Browser.mainLoop.runner, 0);
              return;
            }
            if (!checkIsRunning())
              return;
            Browser.mainLoop.currentFrameNumber = Browser.mainLoop.currentFrameNumber + 1 | 0;
            if (Browser.mainLoop.timingMode == 1 && Browser.mainLoop.timingValue > 1 && Browser.mainLoop.currentFrameNumber % Browser.mainLoop.timingValue != 0) {
              Browser.mainLoop.scheduler();
              return;
            } else if (Browser.mainLoop.timingMode == 0) {
              Browser.mainLoop.tickStartTime = _emscripten_get_now();
            }
            Browser.mainLoop.runIter(browserIterationFunc);
            if (!checkIsRunning())
              return;
            if (typeof SDL == "object")
              (_b = (_a = SDL.audio) == null ? void 0 : _a.queueNewAudioData) == null ? void 0 : _b.call(_a);
            Browser.mainLoop.scheduler();
          };
          if (!noSetTiming) {
            if (fps && fps > 0) {
              _emscripten_set_main_loop_timing(0, 1e3 / fps);
            } else {
              _emscripten_set_main_loop_timing(1, 1);
            }
            Browser.mainLoop.scheduler();
          }
          if (simulateInfiniteLoop) {
            throw "unwind";
          }
        };
        var safeSetTimeout = (func2, timeout) => setTimeout(() => {
          callUserCallback(func2);
        }, timeout);
        var warnOnce = (text) => {
          warnOnce.shown || (warnOnce.shown = {});
          if (!warnOnce.shown[text]) {
            warnOnce.shown[text] = 1;
            if (ENVIRONMENT_IS_NODE)
              text = "warning: " + text;
            err(text);
          }
        };
        var Browser = {
          mainLoop: {
            running: false,
            scheduler: null,
            method: "",
            currentlyRunningMainloop: 0,
            func: null,
            arg: 0,
            timingMode: 0,
            timingValue: 0,
            currentFrameNumber: 0,
            queue: [],
            pause() {
              Browser.mainLoop.scheduler = null;
              Browser.mainLoop.currentlyRunningMainloop++;
            },
            resume() {
              Browser.mainLoop.currentlyRunningMainloop++;
              var timingMode = Browser.mainLoop.timingMode;
              var timingValue = Browser.mainLoop.timingValue;
              var func2 = Browser.mainLoop.func;
              Browser.mainLoop.func = null;
              setMainLoop(func2, 0, false, Browser.mainLoop.arg, true);
              _emscripten_set_main_loop_timing(timingMode, timingValue);
              Browser.mainLoop.scheduler();
            },
            updateStatus() {
              if (Module["setStatus"]) {
                var message = Module["statusMessage"] || "Please wait...";
                var remaining = Browser.mainLoop.remainingBlockers;
                var expected = Browser.mainLoop.expectedBlockers;
                if (remaining) {
                  if (remaining < expected) {
                    Module["setStatus"](message + " (" + (expected - remaining) + "/" + expected + ")");
                  } else {
                    Module["setStatus"](message);
                  }
                } else {
                  Module["setStatus"]("");
                }
              }
            },
            runIter(func2) {
              var _a;
              if (ABORT)
                return;
              if (Module["preMainLoop"]) {
                var preRet = Module["preMainLoop"]();
                if (preRet === false) {
                  return;
                }
              }
              callUserCallback(func2);
              (_a = Module["postMainLoop"]) == null ? void 0 : _a.call(Module);
            }
          },
          isFullscreen: false,
          pointerLock: false,
          moduleContextCreatedCallbacks: [],
          workers: [],
          init() {
            if (Browser.initted)
              return;
            Browser.initted = true;
            var imagePlugin = {};
            imagePlugin["canHandle"] = function imagePlugin_canHandle(name2) {
              return !Module.noImageDecoding && /\.(jpg|jpeg|png|bmp)$/i.test(name2);
            };
            imagePlugin["handle"] = function imagePlugin_handle(byteArray, name2, onload2, onerror2) {
              var b = new Blob([byteArray], {
                type: Browser.getMimetype(name2)
              });
              if (b.size !== byteArray.length) {
                b = new Blob([new Uint8Array(byteArray).buffer], {
                  type: Browser.getMimetype(name2)
                });
              }
              var url2 = URL.createObjectURL(b);
              var img = new Image();
              img.onload = () => {
                assert(img.complete, `Image ${name2} could not be decoded`);
                var canvas2 = document.createElement("canvas");
                canvas2.width = img.width;
                canvas2.height = img.height;
                var ctx = canvas2.getContext("2d");
                ctx.drawImage(img, 0, 0);
                preloadedImages[name2] = canvas2;
                URL.revokeObjectURL(url2);
                onload2 == null ? void 0 : onload2(byteArray);
              };
              img.onerror = (event2) => {
                err(`Image ${url2} could not be decoded`);
                onerror2 == null ? void 0 : onerror2();
              };
              img.src = url2;
            };
            preloadPlugins.push(imagePlugin);
            var audioPlugin = {};
            audioPlugin["canHandle"] = function audioPlugin_canHandle(name2) {
              return !Module.noAudioDecoding && name2.substr(-4) in {
                ".ogg": 1,
                ".wav": 1,
                ".mp3": 1
              };
            };
            audioPlugin["handle"] = function audioPlugin_handle(byteArray, name2, onload2, onerror2) {
              var done = false;
              function finish(audio2) {
                if (done)
                  return;
                done = true;
                preloadedAudios[name2] = audio2;
                onload2 == null ? void 0 : onload2(byteArray);
              }
              function fail() {
                if (done)
                  return;
                done = true;
                preloadedAudios[name2] = new Audio();
                onerror2 == null ? void 0 : onerror2();
              }
              var b = new Blob([byteArray], {
                type: Browser.getMimetype(name2)
              });
              var url2 = URL.createObjectURL(b);
              var audio = new Audio();
              audio.addEventListener("canplaythrough", () => finish(audio), false);
              audio.onerror = function audio_onerror(event2) {
                if (done)
                  return;
                err(`warning: browser could not fully decode audio ${name2}, trying slower base64 approach`);
                function encode64(data2) {
                  var BASE = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
                  var PAD = "=";
                  var ret = "";
                  var leftchar = 0;
                  var leftbits = 0;
                  for (var i2 = 0; i2 < data2.length; i2++) {
                    leftchar = leftchar << 8 | data2[i2];
                    leftbits += 8;
                    while (leftbits >= 6) {
                      var curr = leftchar >> leftbits - 6 & 63;
                      leftbits -= 6;
                      ret += BASE[curr];
                    }
                  }
                  if (leftbits == 2) {
                    ret += BASE[(leftchar & 3) << 4];
                    ret += PAD + PAD;
                  } else if (leftbits == 4) {
                    ret += BASE[(leftchar & 15) << 2];
                    ret += PAD;
                  }
                  return ret;
                }
                audio.src = "data:audio/x-" + name2.substr(-3) + ";base64," + encode64(byteArray);
                finish(audio);
              };
              audio.src = url2;
              safeSetTimeout(() => {
                finish(audio);
              }, 1e4);
            };
            preloadPlugins.push(audioPlugin);
            function pointerLockChange() {
              Browser.pointerLock = document["pointerLockElement"] === Module["canvas"] || document["mozPointerLockElement"] === Module["canvas"] || document["webkitPointerLockElement"] === Module["canvas"] || document["msPointerLockElement"] === Module["canvas"];
            }
            var canvas = Module["canvas"];
            if (canvas) {
              canvas.requestPointerLock = canvas["requestPointerLock"] || canvas["mozRequestPointerLock"] || canvas["webkitRequestPointerLock"] || canvas["msRequestPointerLock"] || (() => {
              });
              canvas.exitPointerLock = document["exitPointerLock"] || document["mozExitPointerLock"] || document["webkitExitPointerLock"] || document["msExitPointerLock"] || (() => {
              });
              canvas.exitPointerLock = canvas.exitPointerLock.bind(document);
              document.addEventListener("pointerlockchange", pointerLockChange, false);
              document.addEventListener("mozpointerlockchange", pointerLockChange, false);
              document.addEventListener("webkitpointerlockchange", pointerLockChange, false);
              document.addEventListener("mspointerlockchange", pointerLockChange, false);
              if (Module["elementPointerLock"]) {
                canvas.addEventListener("click", (ev) => {
                  if (!Browser.pointerLock && Module["canvas"].requestPointerLock) {
                    Module["canvas"].requestPointerLock();
                    ev.preventDefault();
                  }
                }, false);
              }
            }
          },
          createContext(canvas, useWebGL, setInModule, webGLContextAttributes) {
            if (useWebGL && Module.ctx && canvas == Module.canvas)
              return Module.ctx;
            var ctx;
            var contextHandle;
            if (useWebGL) {
              var contextAttributes = {
                antialias: false,
                alpha: false,
                majorVersion: 1
              };
              if (webGLContextAttributes) {
                for (var attribute in webGLContextAttributes) {
                  contextAttributes[attribute] = webGLContextAttributes[attribute];
                }
              }
              if (typeof GL != "undefined") {
                contextHandle = GL.createContext(canvas, contextAttributes);
                if (contextHandle) {
                  ctx = GL.getContext(contextHandle).GLctx;
                }
              }
            } else {
              ctx = canvas.getContext("2d");
            }
            if (!ctx)
              return null;
            if (setInModule) {
              if (!useWebGL)
                assert(typeof GLctx == "undefined", "cannot set in module if GLctx is used, but we are a non-GL context that would replace it");
              Module.ctx = ctx;
              if (useWebGL)
                GL.makeContextCurrent(contextHandle);
              Module.useWebGL = useWebGL;
              Browser.moduleContextCreatedCallbacks.forEach((callback) => callback());
              Browser.init();
            }
            return ctx;
          },
          destroyContext(canvas, useWebGL, setInModule) {
          },
          fullscreenHandlersInstalled: false,
          lockPointer: void 0,
          resizeCanvas: void 0,
          requestFullscreen(lockPointer, resizeCanvas) {
            Browser.lockPointer = lockPointer;
            Browser.resizeCanvas = resizeCanvas;
            if (typeof Browser.lockPointer == "undefined")
              Browser.lockPointer = true;
            if (typeof Browser.resizeCanvas == "undefined")
              Browser.resizeCanvas = false;
            var canvas = Module["canvas"];
            function fullscreenChange() {
              var _a, _b;
              Browser.isFullscreen = false;
              var canvasContainer2 = canvas.parentNode;
              if ((document["fullscreenElement"] || document["mozFullScreenElement"] || document["msFullscreenElement"] || document["webkitFullscreenElement"] || document["webkitCurrentFullScreenElement"]) === canvasContainer2) {
                canvas.exitFullscreen = Browser.exitFullscreen;
                if (Browser.lockPointer)
                  canvas.requestPointerLock();
                Browser.isFullscreen = true;
                if (Browser.resizeCanvas) {
                  Browser.setFullscreenCanvasSize();
                } else {
                  Browser.updateCanvasDimensions(canvas);
                }
              } else {
                canvasContainer2.parentNode.insertBefore(canvas, canvasContainer2);
                canvasContainer2.parentNode.removeChild(canvasContainer2);
                if (Browser.resizeCanvas) {
                  Browser.setWindowedCanvasSize();
                } else {
                  Browser.updateCanvasDimensions(canvas);
                }
              }
              (_a = Module["onFullScreen"]) == null ? void 0 : _a.call(Module, Browser.isFullscreen);
              (_b = Module["onFullscreen"]) == null ? void 0 : _b.call(Module, Browser.isFullscreen);
            }
            if (!Browser.fullscreenHandlersInstalled) {
              Browser.fullscreenHandlersInstalled = true;
              document.addEventListener("fullscreenchange", fullscreenChange, false);
              document.addEventListener("mozfullscreenchange", fullscreenChange, false);
              document.addEventListener("webkitfullscreenchange", fullscreenChange, false);
              document.addEventListener("MSFullscreenChange", fullscreenChange, false);
            }
            var canvasContainer = document.createElement("div");
            canvas.parentNode.insertBefore(canvasContainer, canvas);
            canvasContainer.appendChild(canvas);
            canvasContainer.requestFullscreen = canvasContainer["requestFullscreen"] || canvasContainer["mozRequestFullScreen"] || canvasContainer["msRequestFullscreen"] || (canvasContainer["webkitRequestFullscreen"] ? () => canvasContainer["webkitRequestFullscreen"](Element["ALLOW_KEYBOARD_INPUT"]) : null) || (canvasContainer["webkitRequestFullScreen"] ? () => canvasContainer["webkitRequestFullScreen"](Element["ALLOW_KEYBOARD_INPUT"]) : null);
            canvasContainer.requestFullscreen();
          },
          exitFullscreen() {
            if (!Browser.isFullscreen) {
              return false;
            }
            var CFS = document["exitFullscreen"] || document["cancelFullScreen"] || document["mozCancelFullScreen"] || document["msExitFullscreen"] || document["webkitCancelFullScreen"] || (() => {
            });
            CFS.apply(document, []);
            return true;
          },
          nextRAF: 0,
          fakeRequestAnimationFrame(func2) {
            var now = Date.now();
            if (Browser.nextRAF === 0) {
              Browser.nextRAF = now + 1e3 / 60;
            } else {
              while (now + 2 >= Browser.nextRAF) {
                Browser.nextRAF += 1e3 / 60;
              }
            }
            var delay = Math.max(Browser.nextRAF - now, 0);
            setTimeout(func2, delay);
          },
          requestAnimationFrame(func2) {
            if (typeof requestAnimationFrame == "function") {
              requestAnimationFrame(func2);
              return;
            }
            var RAF = Browser.fakeRequestAnimationFrame;
            RAF(func2);
          },
          safeSetTimeout(func2, timeout) {
            return safeSetTimeout(func2, timeout);
          },
          safeRequestAnimationFrame(func2) {
            return Browser.requestAnimationFrame(() => {
              callUserCallback(func2);
            });
          },
          getMimetype(name2) {
            return {
              "jpg": "image/jpeg",
              "jpeg": "image/jpeg",
              "png": "image/png",
              "bmp": "image/bmp",
              "ogg": "audio/ogg",
              "wav": "audio/wav",
              "mp3": "audio/mpeg"
            }[name2.substr(name2.lastIndexOf(".") + 1)];
          },
          getUserMedia(func2) {
            window.getUserMedia || (window.getUserMedia = navigator["getUserMedia"] || navigator["mozGetUserMedia"]);
            window.getUserMedia(func2);
          },
          getMovementX(event2) {
            return event2["movementX"] || event2["mozMovementX"] || event2["webkitMovementX"] || 0;
          },
          getMovementY(event2) {
            return event2["movementY"] || event2["mozMovementY"] || event2["webkitMovementY"] || 0;
          },
          getMouseWheelDelta(event2) {
            var delta = 0;
            switch (event2.type) {
              case "DOMMouseScroll":
                delta = event2.detail / 3;
                break;
              case "mousewheel":
                delta = event2.wheelDelta / 120;
                break;
              case "wheel":
                delta = event2.deltaY;
                switch (event2.deltaMode) {
                  case 0:
                    delta /= 100;
                    break;
                  case 1:
                    delta /= 3;
                    break;
                  case 2:
                    delta *= 80;
                    break;
                  default:
                    throw "unrecognized mouse wheel delta mode: " + event2.deltaMode;
                }
                break;
              default:
                throw "unrecognized mouse wheel event: " + event2.type;
            }
            return delta;
          },
          mouseX: 0,
          mouseY: 0,
          mouseMovementX: 0,
          mouseMovementY: 0,
          touches: {},
          lastTouches: {},
          calculateMouseCoords(pageX, pageY) {
            var rect = Module["canvas"].getBoundingClientRect();
            var cw = Module["canvas"].width;
            var ch = Module["canvas"].height;
            var scrollX = typeof window.scrollX != "undefined" ? window.scrollX : window.pageXOffset;
            var scrollY = typeof window.scrollY != "undefined" ? window.scrollY : window.pageYOffset;
            var adjustedX = pageX - (scrollX + rect.left);
            var adjustedY = pageY - (scrollY + rect.top);
            adjustedX = adjustedX * (cw / rect.width);
            adjustedY = adjustedY * (ch / rect.height);
            return {
              x: adjustedX,
              y: adjustedY
            };
          },
          setMouseCoords(pageX, pageY) {
            const {
              x,
              y
            } = Browser.calculateMouseCoords(pageX, pageY);
            Browser.mouseMovementX = x - Browser.mouseX;
            Browser.mouseMovementY = y - Browser.mouseY;
            Browser.mouseX = x;
            Browser.mouseY = y;
          },
          calculateMouseEvent(event2) {
            if (Browser.pointerLock) {
              if (event2.type != "mousemove" && "mozMovementX" in event2) {
                Browser.mouseMovementX = Browser.mouseMovementY = 0;
              } else {
                Browser.mouseMovementX = Browser.getMovementX(event2);
                Browser.mouseMovementY = Browser.getMovementY(event2);
              }
              if (typeof SDL != "undefined") {
                Browser.mouseX = SDL.mouseX + Browser.mouseMovementX;
                Browser.mouseY = SDL.mouseY + Browser.mouseMovementY;
              } else {
                Browser.mouseX += Browser.mouseMovementX;
                Browser.mouseY += Browser.mouseMovementY;
              }
            } else {
              if (event2.type === "touchstart" || event2.type === "touchend" || event2.type === "touchmove") {
                var touch = event2.touch;
                if (touch === void 0) {
                  return;
                }
                var coords = Browser.calculateMouseCoords(touch.pageX, touch.pageY);
                if (event2.type === "touchstart") {
                  Browser.lastTouches[touch.identifier] = coords;
                  Browser.touches[touch.identifier] = coords;
                } else if (event2.type === "touchend" || event2.type === "touchmove") {
                  var last = Browser.touches[touch.identifier];
                  last || (last = coords);
                  Browser.lastTouches[touch.identifier] = last;
                  Browser.touches[touch.identifier] = coords;
                }
                return;
              }
              Browser.setMouseCoords(event2.pageX, event2.pageY);
            }
          },
          resizeListeners: [],
          updateResizeListeners() {
            var canvas = Module["canvas"];
            Browser.resizeListeners.forEach((listener) => listener(canvas.width, canvas.height));
          },
          setCanvasSize(width, height, noUpdates) {
            var canvas = Module["canvas"];
            Browser.updateCanvasDimensions(canvas, width, height);
            if (!noUpdates)
              Browser.updateResizeListeners();
          },
          windowedWidth: 0,
          windowedHeight: 0,
          setFullscreenCanvasSize() {
            if (typeof SDL != "undefined") {
              var flags2 = HEAPU32[SDL.screen >>> 2 >>> 0];
              flags2 = flags2 | 8388608;
              HEAP32[SDL.screen >>> 2 >>> 0] = flags2;
            }
            Browser.updateCanvasDimensions(Module["canvas"]);
            Browser.updateResizeListeners();
          },
          setWindowedCanvasSize() {
            if (typeof SDL != "undefined") {
              var flags2 = HEAPU32[SDL.screen >>> 2 >>> 0];
              flags2 = flags2 & ~8388608;
              HEAP32[SDL.screen >>> 2 >>> 0] = flags2;
            }
            Browser.updateCanvasDimensions(Module["canvas"]);
            Browser.updateResizeListeners();
          },
          updateCanvasDimensions(canvas, wNative, hNative) {
            if (wNative && hNative) {
              canvas.widthNative = wNative;
              canvas.heightNative = hNative;
            } else {
              wNative = canvas.widthNative;
              hNative = canvas.heightNative;
            }
            var w = wNative;
            var h = hNative;
            if (Module["forcedAspectRatio"] && Module["forcedAspectRatio"] > 0) {
              if (w / h < Module["forcedAspectRatio"]) {
                w = Math.round(h * Module["forcedAspectRatio"]);
              } else {
                h = Math.round(w / Module["forcedAspectRatio"]);
              }
            }
            if ((document["fullscreenElement"] || document["mozFullScreenElement"] || document["msFullscreenElement"] || document["webkitFullscreenElement"] || document["webkitCurrentFullScreenElement"]) === canvas.parentNode && typeof screen != "undefined") {
              var factor = Math.min(screen.width / w, screen.height / h);
              w = Math.round(w * factor);
              h = Math.round(h * factor);
            }
            if (Browser.resizeCanvas) {
              if (canvas.width != w)
                canvas.width = w;
              if (canvas.height != h)
                canvas.height = h;
              if (typeof canvas.style != "undefined") {
                canvas.style.removeProperty("width");
                canvas.style.removeProperty("height");
              }
            } else {
              if (canvas.width != wNative)
                canvas.width = wNative;
              if (canvas.height != hNative)
                canvas.height = hNative;
              if (typeof canvas.style != "undefined") {
                if (w != wNative || h != hNative) {
                  canvas.style.setProperty("width", w + "px", "important");
                  canvas.style.setProperty("height", h + "px", "important");
                } else {
                  canvas.style.removeProperty("width");
                  canvas.style.removeProperty("height");
                }
              }
            }
          }
        };
        var AL = {
          QUEUE_INTERVAL: 25,
          QUEUE_LOOKAHEAD: 0.1,
          DEVICE_NAME: "Emscripten OpenAL",
          CAPTURE_DEVICE_NAME: "Emscripten OpenAL capture",
          ALC_EXTENSIONS: {
            ALC_SOFT_pause_device: true,
            ALC_SOFT_HRTF: true
          },
          AL_EXTENSIONS: {
            AL_EXT_float32: true,
            AL_SOFT_loop_points: true,
            AL_SOFT_source_length: true,
            AL_EXT_source_distance_model: true,
            AL_SOFT_source_spatialize: true
          },
          _alcErr: 0,
          alcErr: 0,
          deviceRefCounts: {},
          alcStringCache: {},
          paused: false,
          stringCache: {},
          contexts: {},
          currentCtx: null,
          buffers: {
            0: {
              id: 0,
              refCount: 0,
              audioBuf: null,
              frequency: 0,
              bytesPerSample: 2,
              channels: 1,
              length: 0
            }
          },
          paramArray: [],
          _nextId: 1,
          newId: () => AL.freeIds.length > 0 ? AL.freeIds.pop() : AL._nextId++,
          freeIds: [],
          scheduleContextAudio: (ctx) => {
            if (Browser.mainLoop.timingMode === 1 && document["visibilityState"] != "visible") {
              return;
            }
            for (var i2 in ctx.sources) {
              AL.scheduleSourceAudio(ctx.sources[i2]);
            }
          },
          scheduleSourceAudio: (src, lookahead) => {
            if (Browser.mainLoop.timingMode === 1 && document["visibilityState"] != "visible") {
              return;
            }
            if (src.state !== 4114) {
              return;
            }
            var currentTime = AL.updateSourceTime(src);
            var startTime = src.bufStartTime;
            var startOffset = src.bufOffset;
            var bufCursor = src.bufsProcessed;
            for (var i2 = 0; i2 < src.audioQueue.length; i2++) {
              var audioSrc = src.audioQueue[i2];
              startTime = audioSrc._startTime + audioSrc._duration;
              startOffset = 0;
              bufCursor += audioSrc._skipCount + 1;
            }
            if (!lookahead) {
              lookahead = AL.QUEUE_LOOKAHEAD;
            }
            var lookaheadTime = currentTime + lookahead;
            var skipCount = 0;
            while (startTime < lookaheadTime) {
              if (bufCursor >= src.bufQueue.length) {
                if (src.looping) {
                  bufCursor %= src.bufQueue.length;
                } else {
                  break;
                }
              }
              var buf = src.bufQueue[bufCursor % src.bufQueue.length];
              if (buf.length === 0) {
                skipCount++;
                if (skipCount === src.bufQueue.length) {
                  break;
                }
              } else {
                var audioSrc = src.context.audioCtx.createBufferSource();
                audioSrc.buffer = buf.audioBuf;
                audioSrc.playbackRate.value = src.playbackRate;
                if (buf.audioBuf._loopStart || buf.audioBuf._loopEnd) {
                  audioSrc.loopStart = buf.audioBuf._loopStart;
                  audioSrc.loopEnd = buf.audioBuf._loopEnd;
                }
                var duration = 0;
                if (src.type === 4136 && src.looping) {
                  duration = Number.POSITIVE_INFINITY;
                  audioSrc.loop = true;
                  if (buf.audioBuf._loopStart) {
                    audioSrc.loopStart = buf.audioBuf._loopStart;
                  }
                  if (buf.audioBuf._loopEnd) {
                    audioSrc.loopEnd = buf.audioBuf._loopEnd;
                  }
                } else {
                  duration = (buf.audioBuf.duration - startOffset) / src.playbackRate;
                }
                audioSrc._startOffset = startOffset;
                audioSrc._duration = duration;
                audioSrc._skipCount = skipCount;
                skipCount = 0;
                audioSrc.connect(src.gain);
                if (typeof audioSrc.start != "undefined") {
                  startTime = Math.max(startTime, src.context.audioCtx.currentTime);
                  audioSrc.start(startTime, startOffset);
                } else if (typeof audioSrc.noteOn != "undefined") {
                  startTime = Math.max(startTime, src.context.audioCtx.currentTime);
                  audioSrc.noteOn(startTime);
                }
                audioSrc._startTime = startTime;
                src.audioQueue.push(audioSrc);
                startTime += duration;
              }
              startOffset = 0;
              bufCursor++;
            }
          },
          updateSourceTime: (src) => {
            var currentTime = src.context.audioCtx.currentTime;
            if (src.state !== 4114) {
              return currentTime;
            }
            if (!isFinite(src.bufStartTime)) {
              src.bufStartTime = currentTime - src.bufOffset / src.playbackRate;
              src.bufOffset = 0;
            }
            var nextStartTime = 0;
            while (src.audioQueue.length) {
              var audioSrc = src.audioQueue[0];
              src.bufsProcessed += audioSrc._skipCount;
              nextStartTime = audioSrc._startTime + audioSrc._duration;
              if (currentTime < nextStartTime) {
                break;
              }
              src.audioQueue.shift();
              src.bufStartTime = nextStartTime;
              src.bufOffset = 0;
              src.bufsProcessed++;
            }
            if (src.bufsProcessed >= src.bufQueue.length && !src.looping) {
              AL.setSourceState(src, 4116);
            } else if (src.type === 4136 && src.looping) {
              var buf = src.bufQueue[0];
              if (buf.length === 0) {
                src.bufOffset = 0;
              } else {
                var delta = (currentTime - src.bufStartTime) * src.playbackRate;
                var loopStart = buf.audioBuf._loopStart || 0;
                var loopEnd = buf.audioBuf._loopEnd || buf.audioBuf.duration;
                if (loopEnd <= loopStart) {
                  loopEnd = buf.audioBuf.duration;
                }
                if (delta < loopEnd) {
                  src.bufOffset = delta;
                } else {
                  src.bufOffset = loopStart + (delta - loopStart) % (loopEnd - loopStart);
                }
              }
            } else if (src.audioQueue[0]) {
              src.bufOffset = (currentTime - src.audioQueue[0]._startTime) * src.playbackRate;
            } else {
              if (src.type !== 4136 && src.looping) {
                var srcDuration = AL.sourceDuration(src) / src.playbackRate;
                if (srcDuration > 0) {
                  src.bufStartTime += Math.floor((currentTime - src.bufStartTime) / srcDuration) * srcDuration;
                }
              }
              for (var i2 = 0; i2 < src.bufQueue.length; i2++) {
                if (src.bufsProcessed >= src.bufQueue.length) {
                  if (src.looping) {
                    src.bufsProcessed %= src.bufQueue.length;
                  } else {
                    AL.setSourceState(src, 4116);
                    break;
                  }
                }
                var buf = src.bufQueue[src.bufsProcessed];
                if (buf.length > 0) {
                  nextStartTime = src.bufStartTime + buf.audioBuf.duration / src.playbackRate;
                  if (currentTime < nextStartTime) {
                    src.bufOffset = (currentTime - src.bufStartTime) * src.playbackRate;
                    break;
                  }
                  src.bufStartTime = nextStartTime;
                }
                src.bufOffset = 0;
                src.bufsProcessed++;
              }
            }
            return currentTime;
          },
          cancelPendingSourceAudio: (src) => {
            AL.updateSourceTime(src);
            for (var i2 = 1; i2 < src.audioQueue.length; i2++) {
              var audioSrc = src.audioQueue[i2];
              audioSrc.stop();
            }
            if (src.audioQueue.length > 1) {
              src.audioQueue.length = 1;
            }
          },
          stopSourceAudio: (src) => {
            for (var i2 = 0; i2 < src.audioQueue.length; i2++) {
              src.audioQueue[i2].stop();
            }
            src.audioQueue.length = 0;
          },
          setSourceState: (src, state) => {
            if (state === 4114) {
              if (src.state === 4114 || src.state == 4116) {
                src.bufsProcessed = 0;
                src.bufOffset = 0;
              } else {
              }
              AL.stopSourceAudio(src);
              src.state = 4114;
              src.bufStartTime = Number.NEGATIVE_INFINITY;
              AL.scheduleSourceAudio(src);
            } else if (state === 4115) {
              if (src.state === 4114) {
                AL.updateSourceTime(src);
                AL.stopSourceAudio(src);
                src.state = 4115;
              }
            } else if (state === 4116) {
              if (src.state !== 4113) {
                src.state = 4116;
                src.bufsProcessed = src.bufQueue.length;
                src.bufStartTime = Number.NEGATIVE_INFINITY;
                src.bufOffset = 0;
                AL.stopSourceAudio(src);
              }
            } else if (state === 4113) {
              if (src.state !== 4113) {
                src.state = 4113;
                src.bufsProcessed = 0;
                src.bufStartTime = Number.NEGATIVE_INFINITY;
                src.bufOffset = 0;
                AL.stopSourceAudio(src);
              }
            }
          },
          initSourcePanner: (src) => {
            if (src.type === 4144) {
              return;
            }
            var templateBuf = AL.buffers[0];
            for (var i2 = 0; i2 < src.bufQueue.length; i2++) {
              if (src.bufQueue[i2].id !== 0) {
                templateBuf = src.bufQueue[i2];
                break;
              }
            }
            if (src.spatialize === 1 || src.spatialize === 2 && templateBuf.channels === 1) {
              if (src.panner) {
                return;
              }
              src.panner = src.context.audioCtx.createPanner();
              AL.updateSourceGlobal(src);
              AL.updateSourceSpace(src);
              src.panner.connect(src.context.gain);
              src.gain.disconnect();
              src.gain.connect(src.panner);
            } else {
              if (!src.panner) {
                return;
              }
              src.panner.disconnect();
              src.gain.disconnect();
              src.gain.connect(src.context.gain);
              src.panner = null;
            }
          },
          updateContextGlobal: (ctx) => {
            for (var i2 in ctx.sources) {
              AL.updateSourceGlobal(ctx.sources[i2]);
            }
          },
          updateSourceGlobal: (src) => {
            var panner = src.panner;
            if (!panner) {
              return;
            }
            panner.refDistance = src.refDistance;
            panner.maxDistance = src.maxDistance;
            panner.rolloffFactor = src.rolloffFactor;
            panner.panningModel = src.context.hrtf ? "HRTF" : "equalpower";
            var distanceModel = src.context.sourceDistanceModel ? src.distanceModel : src.context.distanceModel;
            switch (distanceModel) {
              case 0:
                panner.distanceModel = "inverse";
                panner.refDistance = 340282e33;
                break;
              case 53249:
              case 53250:
                panner.distanceModel = "inverse";
                break;
              case 53251:
              case 53252:
                panner.distanceModel = "linear";
                break;
              case 53253:
              case 53254:
                panner.distanceModel = "exponential";
                break;
            }
          },
          updateListenerSpace: (ctx) => {
            var listener = ctx.audioCtx.listener;
            if (listener.positionX) {
              listener.positionX.value = ctx.listener.position[0];
              listener.positionY.value = ctx.listener.position[1];
              listener.positionZ.value = ctx.listener.position[2];
            } else {
              listener.setPosition(ctx.listener.position[0], ctx.listener.position[1], ctx.listener.position[2]);
            }
            if (listener.forwardX) {
              listener.forwardX.value = ctx.listener.direction[0];
              listener.forwardY.value = ctx.listener.direction[1];
              listener.forwardZ.value = ctx.listener.direction[2];
              listener.upX.value = ctx.listener.up[0];
              listener.upY.value = ctx.listener.up[1];
              listener.upZ.value = ctx.listener.up[2];
            } else {
              listener.setOrientation(ctx.listener.direction[0], ctx.listener.direction[1], ctx.listener.direction[2], ctx.listener.up[0], ctx.listener.up[1], ctx.listener.up[2]);
            }
            for (var i2 in ctx.sources) {
              AL.updateSourceSpace(ctx.sources[i2]);
            }
          },
          updateSourceSpace: (src) => {
            if (!src.panner) {
              return;
            }
            var panner = src.panner;
            var posX = src.position[0];
            var posY = src.position[1];
            var posZ = src.position[2];
            var dirX = src.direction[0];
            var dirY = src.direction[1];
            var dirZ = src.direction[2];
            var listener = src.context.listener;
            var lPosX = listener.position[0];
            var lPosY = listener.position[1];
            var lPosZ = listener.position[2];
            if (src.relative) {
              var lBackX = -listener.direction[0];
              var lBackY = -listener.direction[1];
              var lBackZ = -listener.direction[2];
              var lUpX = listener.up[0];
              var lUpY = listener.up[1];
              var lUpZ = listener.up[2];
              var inverseMagnitude = (x, y, z) => {
                var length = Math.sqrt(x * x + y * y + z * z);
                if (length < Number.EPSILON) {
                  return 0;
                }
                return 1 / length;
              };
              var invMag = inverseMagnitude(lBackX, lBackY, lBackZ);
              lBackX *= invMag;
              lBackY *= invMag;
              lBackZ *= invMag;
              invMag = inverseMagnitude(lUpX, lUpY, lUpZ);
              lUpX *= invMag;
              lUpY *= invMag;
              lUpZ *= invMag;
              var lRightX = lUpY * lBackZ - lUpZ * lBackY;
              var lRightY = lUpZ * lBackX - lUpX * lBackZ;
              var lRightZ = lUpX * lBackY - lUpY * lBackX;
              invMag = inverseMagnitude(lRightX, lRightY, lRightZ);
              lRightX *= invMag;
              lRightY *= invMag;
              lRightZ *= invMag;
              lUpX = lBackY * lRightZ - lBackZ * lRightY;
              lUpY = lBackZ * lRightX - lBackX * lRightZ;
              lUpZ = lBackX * lRightY - lBackY * lRightX;
              var oldX = dirX;
              var oldY = dirY;
              var oldZ = dirZ;
              dirX = oldX * lRightX + oldY * lUpX + oldZ * lBackX;
              dirY = oldX * lRightY + oldY * lUpY + oldZ * lBackY;
              dirZ = oldX * lRightZ + oldY * lUpZ + oldZ * lBackZ;
              oldX = posX;
              oldY = posY;
              oldZ = posZ;
              posX = oldX * lRightX + oldY * lUpX + oldZ * lBackX;
              posY = oldX * lRightY + oldY * lUpY + oldZ * lBackY;
              posZ = oldX * lRightZ + oldY * lUpZ + oldZ * lBackZ;
              posX += lPosX;
              posY += lPosY;
              posZ += lPosZ;
            }
            if (panner.positionX) {
              if (posX != panner.positionX.value)
                panner.positionX.value = posX;
              if (posY != panner.positionY.value)
                panner.positionY.value = posY;
              if (posZ != panner.positionZ.value)
                panner.positionZ.value = posZ;
            } else {
              panner.setPosition(posX, posY, posZ);
            }
            if (panner.orientationX) {
              if (dirX != panner.orientationX.value)
                panner.orientationX.value = dirX;
              if (dirY != panner.orientationY.value)
                panner.orientationY.value = dirY;
              if (dirZ != panner.orientationZ.value)
                panner.orientationZ.value = dirZ;
            } else {
              panner.setOrientation(dirX, dirY, dirZ);
            }
            var oldShift = src.dopplerShift;
            var velX = src.velocity[0];
            var velY = src.velocity[1];
            var velZ = src.velocity[2];
            var lVelX = listener.velocity[0];
            var lVelY = listener.velocity[1];
            var lVelZ = listener.velocity[2];
            if (posX === lPosX && posY === lPosY && posZ === lPosZ || velX === lVelX && velY === lVelY && velZ === lVelZ) {
              src.dopplerShift = 1;
            } else {
              var speedOfSound = src.context.speedOfSound;
              var dopplerFactor = src.context.dopplerFactor;
              var slX = lPosX - posX;
              var slY = lPosY - posY;
              var slZ = lPosZ - posZ;
              var magSl = Math.sqrt(slX * slX + slY * slY + slZ * slZ);
              var vls = (slX * lVelX + slY * lVelY + slZ * lVelZ) / magSl;
              var vss = (slX * velX + slY * velY + slZ * velZ) / magSl;
              vls = Math.min(vls, speedOfSound / dopplerFactor);
              vss = Math.min(vss, speedOfSound / dopplerFactor);
              src.dopplerShift = (speedOfSound - dopplerFactor * vls) / (speedOfSound - dopplerFactor * vss);
            }
            if (src.dopplerShift !== oldShift) {
              AL.updateSourceRate(src);
            }
          },
          updateSourceRate: (src) => {
            if (src.state === 4114) {
              AL.cancelPendingSourceAudio(src);
              var audioSrc = src.audioQueue[0];
              if (!audioSrc) {
                return;
              }
              var duration;
              if (src.type === 4136 && src.looping) {
                duration = Number.POSITIVE_INFINITY;
              } else {
                duration = (audioSrc.buffer.duration - audioSrc._startOffset) / src.playbackRate;
              }
              audioSrc._duration = duration;
              audioSrc.playbackRate.value = src.playbackRate;
              AL.scheduleSourceAudio(src);
            }
          },
          sourceDuration: (src) => {
            var length = 0;
            for (var i2 = 0; i2 < src.bufQueue.length; i2++) {
              var audioBuf = src.bufQueue[i2].audioBuf;
              length += audioBuf ? audioBuf.duration : 0;
            }
            return length;
          },
          sourceTell: (src) => {
            AL.updateSourceTime(src);
            var offset = 0;
            for (var i2 = 0; i2 < src.bufsProcessed; i2++) {
              if (src.bufQueue[i2].audioBuf) {
                offset += src.bufQueue[i2].audioBuf.duration;
              }
            }
            offset += src.bufOffset;
            return offset;
          },
          sourceSeek: (src, offset) => {
            var playing = src.state == 4114;
            if (playing) {
              AL.setSourceState(src, 4113);
            }
            if (src.bufQueue[src.bufsProcessed].audioBuf !== null) {
              src.bufsProcessed = 0;
              while (offset > src.bufQueue[src.bufsProcessed].audioBuf.duration) {
                offset -= src.bufQueue[src.bufsProcessed].audiobuf.duration;
                src.bufsProcessed++;
              }
              src.bufOffset = offset;
            }
            if (playing) {
              AL.setSourceState(src, 4114);
            }
          },
          getGlobalParam: (funcname, param) => {
            if (!AL.currentCtx) {
              return null;
            }
            switch (param) {
              case 49152:
                return AL.currentCtx.dopplerFactor;
              case 49155:
                return AL.currentCtx.speedOfSound;
              case 53248:
                return AL.currentCtx.distanceModel;
              default:
                AL.currentCtx.err = 40962;
                return null;
            }
          },
          setGlobalParam: (funcname, param, value) => {
            if (!AL.currentCtx) {
              return;
            }
            switch (param) {
              case 49152:
                if (!Number.isFinite(value) || value < 0) {
                  AL.currentCtx.err = 40963;
                  return;
                }
                AL.currentCtx.dopplerFactor = value;
                AL.updateListenerSpace(AL.currentCtx);
                break;
              case 49155:
                if (!Number.isFinite(value) || value <= 0) {
                  AL.currentCtx.err = 40963;
                  return;
                }
                AL.currentCtx.speedOfSound = value;
                AL.updateListenerSpace(AL.currentCtx);
                break;
              case 53248:
                switch (value) {
                  case 0:
                  case 53249:
                  case 53250:
                  case 53251:
                  case 53252:
                  case 53253:
                  case 53254:
                    AL.currentCtx.distanceModel = value;
                    AL.updateContextGlobal(AL.currentCtx);
                    break;
                  default:
                    AL.currentCtx.err = 40963;
                    return;
                }
                break;
              default:
                AL.currentCtx.err = 40962;
                return;
            }
          },
          getListenerParam: (funcname, param) => {
            if (!AL.currentCtx) {
              return null;
            }
            switch (param) {
              case 4100:
                return AL.currentCtx.listener.position;
              case 4102:
                return AL.currentCtx.listener.velocity;
              case 4111:
                return AL.currentCtx.listener.direction.concat(AL.currentCtx.listener.up);
              case 4106:
                return AL.currentCtx.gain.gain.value;
              default:
                AL.currentCtx.err = 40962;
                return null;
            }
          },
          setListenerParam: (funcname, param, value) => {
            if (!AL.currentCtx) {
              return;
            }
            if (value === null) {
              AL.currentCtx.err = 40962;
              return;
            }
            var listener = AL.currentCtx.listener;
            switch (param) {
              case 4100:
                if (!Number.isFinite(value[0]) || !Number.isFinite(value[1]) || !Number.isFinite(value[2])) {
                  AL.currentCtx.err = 40963;
                  return;
                }
                listener.position[0] = value[0];
                listener.position[1] = value[1];
                listener.position[2] = value[2];
                AL.updateListenerSpace(AL.currentCtx);
                break;
              case 4102:
                if (!Number.isFinite(value[0]) || !Number.isFinite(value[1]) || !Number.isFinite(value[2])) {
                  AL.currentCtx.err = 40963;
                  return;
                }
                listener.velocity[0] = value[0];
                listener.velocity[1] = value[1];
                listener.velocity[2] = value[2];
                AL.updateListenerSpace(AL.currentCtx);
                break;
              case 4106:
                if (!Number.isFinite(value) || value < 0) {
                  AL.currentCtx.err = 40963;
                  return;
                }
                AL.currentCtx.gain.gain.value = value;
                break;
              case 4111:
                if (!Number.isFinite(value[0]) || !Number.isFinite(value[1]) || !Number.isFinite(value[2]) || !Number.isFinite(value[3]) || !Number.isFinite(value[4]) || !Number.isFinite(value[5])) {
                  AL.currentCtx.err = 40963;
                  return;
                }
                listener.direction[0] = value[0];
                listener.direction[1] = value[1];
                listener.direction[2] = value[2];
                listener.up[0] = value[3];
                listener.up[1] = value[4];
                listener.up[2] = value[5];
                AL.updateListenerSpace(AL.currentCtx);
                break;
              default:
                AL.currentCtx.err = 40962;
                return;
            }
          },
          getBufferParam: (funcname, bufferId, param) => {
            if (!AL.currentCtx) {
              return;
            }
            var buf = AL.buffers[bufferId];
            if (!buf || bufferId === 0) {
              AL.currentCtx.err = 40961;
              return;
            }
            switch (param) {
              case 8193:
                return buf.frequency;
              case 8194:
                return buf.bytesPerSample * 8;
              case 8195:
                return buf.channels;
              case 8196:
                return buf.length * buf.bytesPerSample * buf.channels;
              case 8213:
                if (buf.length === 0) {
                  return [0, 0];
                }
                return [(buf.audioBuf._loopStart || 0) * buf.frequency, (buf.audioBuf._loopEnd || buf.length) * buf.frequency];
              default:
                AL.currentCtx.err = 40962;
                return null;
            }
          },
          setBufferParam: (funcname, bufferId, param, value) => {
            if (!AL.currentCtx) {
              return;
            }
            var buf = AL.buffers[bufferId];
            if (!buf || bufferId === 0) {
              AL.currentCtx.err = 40961;
              return;
            }
            if (value === null) {
              AL.currentCtx.err = 40962;
              return;
            }
            switch (param) {
              case 8196:
                if (value !== 0) {
                  AL.currentCtx.err = 40963;
                  return;
                }
                break;
              case 8213:
                if (value[0] < 0 || value[0] > buf.length || value[1] < 0 || value[1] > buf.Length || value[0] >= value[1]) {
                  AL.currentCtx.err = 40963;
                  return;
                }
                if (buf.refCount > 0) {
                  AL.currentCtx.err = 40964;
                  return;
                }
                if (buf.audioBuf) {
                  buf.audioBuf._loopStart = value[0] / buf.frequency;
                  buf.audioBuf._loopEnd = value[1] / buf.frequency;
                }
                break;
              default:
                AL.currentCtx.err = 40962;
                return;
            }
          },
          getSourceParam: (funcname, sourceId, param) => {
            if (!AL.currentCtx) {
              return null;
            }
            var src = AL.currentCtx.sources[sourceId];
            if (!src) {
              AL.currentCtx.err = 40961;
              return null;
            }
            switch (param) {
              case 514:
                return src.relative;
              case 4097:
                return src.coneInnerAngle;
              case 4098:
                return src.coneOuterAngle;
              case 4099:
                return src.pitch;
              case 4100:
                return src.position;
              case 4101:
                return src.direction;
              case 4102:
                return src.velocity;
              case 4103:
                return src.looping;
              case 4105:
                if (src.type === 4136) {
                  return src.bufQueue[0].id;
                }
                return 0;
              case 4106:
                return src.gain.gain.value;
              case 4109:
                return src.minGain;
              case 4110:
                return src.maxGain;
              case 4112:
                return src.state;
              case 4117:
                if (src.bufQueue.length === 1 && src.bufQueue[0].id === 0) {
                  return 0;
                }
                return src.bufQueue.length;
              case 4118:
                if (src.bufQueue.length === 1 && src.bufQueue[0].id === 0 || src.looping) {
                  return 0;
                }
                return src.bufsProcessed;
              case 4128:
                return src.refDistance;
              case 4129:
                return src.rolloffFactor;
              case 4130:
                return src.coneOuterGain;
              case 4131:
                return src.maxDistance;
              case 4132:
                return AL.sourceTell(src);
              case 4133:
                var offset = AL.sourceTell(src);
                if (offset > 0) {
                  offset *= src.bufQueue[0].frequency;
                }
                return offset;
              case 4134:
                var offset = AL.sourceTell(src);
                if (offset > 0) {
                  offset *= src.bufQueue[0].frequency * src.bufQueue[0].bytesPerSample;
                }
                return offset;
              case 4135:
                return src.type;
              case 4628:
                return src.spatialize;
              case 8201:
                var length = 0;
                var bytesPerFrame = 0;
                for (var i2 = 0; i2 < src.bufQueue.length; i2++) {
                  length += src.bufQueue[i2].length;
                  if (src.bufQueue[i2].id !== 0) {
                    bytesPerFrame = src.bufQueue[i2].bytesPerSample * src.bufQueue[i2].channels;
                  }
                }
                return length * bytesPerFrame;
              case 8202:
                var length = 0;
                for (var i2 = 0; i2 < src.bufQueue.length; i2++) {
                  length += src.bufQueue[i2].length;
                }
                return length;
              case 8203:
                return AL.sourceDuration(src);
              case 53248:
                return src.distanceModel;
              default:
                AL.currentCtx.err = 40962;
                return null;
            }
          },
          setSourceParam: (funcname, sourceId, param, value) => {
            if (!AL.currentCtx) {
              return;
            }
            var src = AL.currentCtx.sources[sourceId];
            if (!src) {
              AL.currentCtx.err = 40961;
              return;
            }
            if (value === null) {
              AL.currentCtx.err = 40962;
              return;
            }
            switch (param) {
              case 514:
                if (value === 1) {
                  src.relative = true;
                  AL.updateSourceSpace(src);
                } else if (value === 0) {
                  src.relative = false;
                  AL.updateSourceSpace(src);
                } else {
                  AL.currentCtx.err = 40963;
                  return;
                }
                break;
              case 4097:
                if (!Number.isFinite(value)) {
                  AL.currentCtx.err = 40963;
                  return;
                }
                src.coneInnerAngle = value;
                if (src.panner) {
                  src.panner.coneInnerAngle = value % 360;
                }
                break;
              case 4098:
                if (!Number.isFinite(value)) {
                  AL.currentCtx.err = 40963;
                  return;
                }
                src.coneOuterAngle = value;
                if (src.panner) {
                  src.panner.coneOuterAngle = value % 360;
                }
                break;
              case 4099:
                if (!Number.isFinite(value) || value <= 0) {
                  AL.currentCtx.err = 40963;
                  return;
                }
                if (src.pitch === value) {
                  break;
                }
                src.pitch = value;
                AL.updateSourceRate(src);
                break;
              case 4100:
                if (!Number.isFinite(value[0]) || !Number.isFinite(value[1]) || !Number.isFinite(value[2])) {
                  AL.currentCtx.err = 40963;
                  return;
                }
                src.position[0] = value[0];
                src.position[1] = value[1];
                src.position[2] = value[2];
                AL.updateSourceSpace(src);
                break;
              case 4101:
                if (!Number.isFinite(value[0]) || !Number.isFinite(value[1]) || !Number.isFinite(value[2])) {
                  AL.currentCtx.err = 40963;
                  return;
                }
                src.direction[0] = value[0];
                src.direction[1] = value[1];
                src.direction[2] = value[2];
                AL.updateSourceSpace(src);
                break;
              case 4102:
                if (!Number.isFinite(value[0]) || !Number.isFinite(value[1]) || !Number.isFinite(value[2])) {
                  AL.currentCtx.err = 40963;
                  return;
                }
                src.velocity[0] = value[0];
                src.velocity[1] = value[1];
                src.velocity[2] = value[2];
                AL.updateSourceSpace(src);
                break;
              case 4103:
                if (value === 1) {
                  src.looping = true;
                  AL.updateSourceTime(src);
                  if (src.type === 4136 && src.audioQueue.length > 0) {
                    var audioSrc = src.audioQueue[0];
                    audioSrc.loop = true;
                    audioSrc._duration = Number.POSITIVE_INFINITY;
                  }
                } else if (value === 0) {
                  src.looping = false;
                  var currentTime = AL.updateSourceTime(src);
                  if (src.type === 4136 && src.audioQueue.length > 0) {
                    var audioSrc = src.audioQueue[0];
                    audioSrc.loop = false;
                    audioSrc._duration = src.bufQueue[0].audioBuf.duration / src.playbackRate;
                    audioSrc._startTime = currentTime - src.bufOffset / src.playbackRate;
                  }
                } else {
                  AL.currentCtx.err = 40963;
                  return;
                }
                break;
              case 4105:
                if (src.state === 4114 || src.state === 4115) {
                  AL.currentCtx.err = 40964;
                  return;
                }
                if (value === 0) {
                  for (var i2 in src.bufQueue) {
                    src.bufQueue[i2].refCount--;
                  }
                  src.bufQueue.length = 1;
                  src.bufQueue[0] = AL.buffers[0];
                  src.bufsProcessed = 0;
                  src.type = 4144;
                } else {
                  var buf = AL.buffers[value];
                  if (!buf) {
                    AL.currentCtx.err = 40963;
                    return;
                  }
                  for (var i2 in src.bufQueue) {
                    src.bufQueue[i2].refCount--;
                  }
                  src.bufQueue.length = 0;
                  buf.refCount++;
                  src.bufQueue = [buf];
                  src.bufsProcessed = 0;
                  src.type = 4136;
                }
                AL.initSourcePanner(src);
                AL.scheduleSourceAudio(src);
                break;
              case 4106:
                if (!Number.isFinite(value) || value < 0) {
                  AL.currentCtx.err = 40963;
                  return;
                }
                src.gain.gain.value = value;
                break;
              case 4109:
                if (!Number.isFinite(value) || value < 0 || value > Math.min(src.maxGain, 1)) {
                  AL.currentCtx.err = 40963;
                  return;
                }
                src.minGain = value;
                break;
              case 4110:
                if (!Number.isFinite(value) || value < Math.max(0, src.minGain) || value > 1) {
                  AL.currentCtx.err = 40963;
                  return;
                }
                src.maxGain = value;
                break;
              case 4128:
                if (!Number.isFinite(value) || value < 0) {
                  AL.currentCtx.err = 40963;
                  return;
                }
                src.refDistance = value;
                if (src.panner) {
                  src.panner.refDistance = value;
                }
                break;
              case 4129:
                if (!Number.isFinite(value) || value < 0) {
                  AL.currentCtx.err = 40963;
                  return;
                }
                src.rolloffFactor = value;
                if (src.panner) {
                  src.panner.rolloffFactor = value;
                }
                break;
              case 4130:
                if (!Number.isFinite(value) || value < 0 || value > 1) {
                  AL.currentCtx.err = 40963;
                  return;
                }
                src.coneOuterGain = value;
                if (src.panner) {
                  src.panner.coneOuterGain = value;
                }
                break;
              case 4131:
                if (!Number.isFinite(value) || value < 0) {
                  AL.currentCtx.err = 40963;
                  return;
                }
                src.maxDistance = value;
                if (src.panner) {
                  src.panner.maxDistance = value;
                }
                break;
              case 4132:
                if (value < 0 || value > AL.sourceDuration(src)) {
                  AL.currentCtx.err = 40963;
                  return;
                }
                AL.sourceSeek(src, value);
                break;
              case 4133:
                var srcLen = AL.sourceDuration(src);
                if (srcLen > 0) {
                  var frequency;
                  for (var bufId in src.bufQueue) {
                    if (bufId) {
                      frequency = src.bufQueue[bufId].frequency;
                      break;
                    }
                  }
                  value /= frequency;
                }
                if (value < 0 || value > srcLen) {
                  AL.currentCtx.err = 40963;
                  return;
                }
                AL.sourceSeek(src, value);
                break;
              case 4134:
                var srcLen = AL.sourceDuration(src);
                if (srcLen > 0) {
                  var bytesPerSec;
                  for (var bufId in src.bufQueue) {
                    if (bufId) {
                      var buf = src.bufQueue[bufId];
                      bytesPerSec = buf.frequency * buf.bytesPerSample * buf.channels;
                      break;
                    }
                  }
                  value /= bytesPerSec;
                }
                if (value < 0 || value > srcLen) {
                  AL.currentCtx.err = 40963;
                  return;
                }
                AL.sourceSeek(src, value);
                break;
              case 4628:
                if (value !== 0 && value !== 1 && value !== 2) {
                  AL.currentCtx.err = 40963;
                  return;
                }
                src.spatialize = value;
                AL.initSourcePanner(src);
                break;
              case 8201:
              case 8202:
              case 8203:
                AL.currentCtx.err = 40964;
                break;
              case 53248:
                switch (value) {
                  case 0:
                  case 53249:
                  case 53250:
                  case 53251:
                  case 53252:
                  case 53253:
                  case 53254:
                    src.distanceModel = value;
                    if (AL.currentCtx.sourceDistanceModel) {
                      AL.updateContextGlobal(AL.currentCtx);
                    }
                    break;
                  default:
                    AL.currentCtx.err = 40963;
                    return;
                }
                break;
              default:
                AL.currentCtx.err = 40962;
                return;
            }
          },
          captures: {},
          sharedCaptureAudioCtx: null,
          requireValidCaptureDevice: (deviceId, funcname) => {
            if (deviceId === 0) {
              AL.alcErr = 40961;
              return null;
            }
            var c = AL.captures[deviceId];
            if (!c) {
              AL.alcErr = 40961;
              return null;
            }
            var err2 = c.mediaStreamError;
            if (err2) {
              AL.alcErr = 40961;
              return null;
            }
            return c;
          }
        };
        var _alBuffer3f = (bufferId, param, value0, value1, value2) => {
          AL.setBufferParam("alBuffer3f", bufferId, param, null);
        };
        _alBuffer3f.sig = "viifff";
        var _alBuffer3i = (bufferId, param, value0, value1, value2) => {
          AL.setBufferParam("alBuffer3i", bufferId, param, null);
        };
        _alBuffer3i.sig = "viiiii";
        function _alBufferData(bufferId, format, pData, size, freq) {
          pData >>>= 0;
          if (!AL.currentCtx) {
            return;
          }
          var buf = AL.buffers[bufferId];
          if (!buf) {
            AL.currentCtx.err = 40963;
            return;
          }
          if (freq <= 0) {
            AL.currentCtx.err = 40963;
            return;
          }
          var audioBuf = null;
          try {
            switch (format) {
              case 4352:
                if (size > 0) {
                  audioBuf = AL.currentCtx.audioCtx.createBuffer(1, size, freq);
                  var channel0 = audioBuf.getChannelData(0);
                  for (var i2 = 0; i2 < size; ++i2) {
                    channel0[i2] = HEAPU8[pData++ >>> 0] * 78125e-7 - 1;
                  }
                }
                buf.bytesPerSample = 1;
                buf.channels = 1;
                buf.length = size;
                break;
              case 4353:
                if (size > 0) {
                  audioBuf = AL.currentCtx.audioCtx.createBuffer(1, size >> 1, freq);
                  var channel0 = audioBuf.getChannelData(0);
                  pData >>= 1;
                  for (var i2 = 0; i2 < size >> 1; ++i2) {
                    channel0[i2] = HEAP16[pData++ >>> 0] * 30517578125e-15;
                  }
                }
                buf.bytesPerSample = 2;
                buf.channels = 1;
                buf.length = size >> 1;
                break;
              case 4354:
                if (size > 0) {
                  audioBuf = AL.currentCtx.audioCtx.createBuffer(2, size >> 1, freq);
                  var channel0 = audioBuf.getChannelData(0);
                  var channel1 = audioBuf.getChannelData(1);
                  for (var i2 = 0; i2 < size >> 1; ++i2) {
                    channel0[i2] = HEAPU8[pData++ >>> 0] * 78125e-7 - 1;
                    channel1[i2] = HEAPU8[pData++ >>> 0] * 78125e-7 - 1;
                  }
                }
                buf.bytesPerSample = 1;
                buf.channels = 2;
                buf.length = size >> 1;
                break;
              case 4355:
                if (size > 0) {
                  audioBuf = AL.currentCtx.audioCtx.createBuffer(2, size >> 2, freq);
                  var channel0 = audioBuf.getChannelData(0);
                  var channel1 = audioBuf.getChannelData(1);
                  pData >>= 1;
                  for (var i2 = 0; i2 < size >> 2; ++i2) {
                    channel0[i2] = HEAP16[pData++ >>> 0] * 30517578125e-15;
                    channel1[i2] = HEAP16[pData++ >>> 0] * 30517578125e-15;
                  }
                }
                buf.bytesPerSample = 2;
                buf.channels = 2;
                buf.length = size >> 2;
                break;
              case 65552:
                if (size > 0) {
                  audioBuf = AL.currentCtx.audioCtx.createBuffer(1, size >> 2, freq);
                  var channel0 = audioBuf.getChannelData(0);
                  pData >>= 2;
                  for (var i2 = 0; i2 < size >> 2; ++i2) {
                    channel0[i2] = HEAPF32[pData++ >>> 0];
                  }
                }
                buf.bytesPerSample = 4;
                buf.channels = 1;
                buf.length = size >> 2;
                break;
              case 65553:
                if (size > 0) {
                  audioBuf = AL.currentCtx.audioCtx.createBuffer(2, size >> 3, freq);
                  var channel0 = audioBuf.getChannelData(0);
                  var channel1 = audioBuf.getChannelData(1);
                  pData >>= 2;
                  for (var i2 = 0; i2 < size >> 3; ++i2) {
                    channel0[i2] = HEAPF32[pData++ >>> 0];
                    channel1[i2] = HEAPF32[pData++ >>> 0];
                  }
                }
                buf.bytesPerSample = 4;
                buf.channels = 2;
                buf.length = size >> 3;
                break;
              default:
                AL.currentCtx.err = 40963;
                return;
            }
            buf.frequency = freq;
            buf.audioBuf = audioBuf;
          } catch (e) {
            AL.currentCtx.err = 40963;
            return;
          }
        }
        _alBufferData.sig = "viipii";
        var _alBufferf = (bufferId, param, value) => {
          AL.setBufferParam("alBufferf", bufferId, param, null);
        };
        _alBufferf.sig = "viif";
        function _alBufferfv(bufferId, param, pValues) {
          pValues >>>= 0;
          if (!AL.currentCtx) {
            return;
          }
          if (!pValues) {
            AL.currentCtx.err = 40963;
            return;
          }
          AL.setBufferParam("alBufferfv", bufferId, param, null);
        }
        _alBufferfv.sig = "viip";
        var _alBufferi = (bufferId, param, value) => {
          AL.setBufferParam("alBufferi", bufferId, param, null);
        };
        _alBufferi.sig = "viii";
        function _alBufferiv(bufferId, param, pValues) {
          pValues >>>= 0;
          if (!AL.currentCtx) {
            return;
          }
          if (!pValues) {
            AL.currentCtx.err = 40963;
            return;
          }
          switch (param) {
            case 8213:
              AL.paramArray[0] = HEAP32[pValues >>> 2 >>> 0];
              AL.paramArray[1] = HEAP32[pValues + 4 >>> 2 >>> 0];
              AL.setBufferParam("alBufferiv", bufferId, param, AL.paramArray);
              break;
            default:
              AL.setBufferParam("alBufferiv", bufferId, param, null);
              break;
          }
        }
        _alBufferiv.sig = "viip";
        function _alDeleteBuffers(count, pBufferIds) {
          pBufferIds >>>= 0;
          if (!AL.currentCtx) {
            return;
          }
          for (var i2 = 0; i2 < count; ++i2) {
            var bufId = HEAP32[pBufferIds + i2 * 4 >>> 2 >>> 0];
            if (bufId === 0) {
              continue;
            }
            if (!AL.buffers[bufId]) {
              AL.currentCtx.err = 40961;
              return;
            }
            if (AL.buffers[bufId].refCount) {
              AL.currentCtx.err = 40964;
              return;
            }
          }
          for (var i2 = 0; i2 < count; ++i2) {
            var bufId = HEAP32[pBufferIds + i2 * 4 >>> 2 >>> 0];
            if (bufId === 0) {
              continue;
            }
            AL.deviceRefCounts[AL.buffers[bufId].deviceId]--;
            delete AL.buffers[bufId];
            AL.freeIds.push(bufId);
          }
        }
        _alDeleteBuffers.sig = "vip";
        var _alSourcei = (sourceId, param, value) => {
          switch (param) {
            case 514:
            case 4097:
            case 4098:
            case 4103:
            case 4105:
            case 4128:
            case 4129:
            case 4131:
            case 4132:
            case 4133:
            case 4134:
            case 4628:
            case 8201:
            case 8202:
            case 53248:
              AL.setSourceParam("alSourcei", sourceId, param, value);
              break;
            default:
              AL.setSourceParam("alSourcei", sourceId, param, null);
              break;
          }
        };
        _alSourcei.sig = "viii";
        function _alDeleteSources(count, pSourceIds) {
          pSourceIds >>>= 0;
          if (!AL.currentCtx) {
            return;
          }
          for (var i2 = 0; i2 < count; ++i2) {
            var srcId = HEAP32[pSourceIds + i2 * 4 >>> 2 >>> 0];
            if (!AL.currentCtx.sources[srcId]) {
              AL.currentCtx.err = 40961;
              return;
            }
          }
          for (var i2 = 0; i2 < count; ++i2) {
            var srcId = HEAP32[pSourceIds + i2 * 4 >>> 2 >>> 0];
            AL.setSourceState(AL.currentCtx.sources[srcId], 4116);
            _alSourcei(srcId, 4105, 0);
            delete AL.currentCtx.sources[srcId];
            AL.freeIds.push(srcId);
          }
        }
        _alDeleteSources.sig = "vip";
        var _alDisable = (param) => {
          if (!AL.currentCtx) {
            return;
          }
          switch (param) {
            case "AL_SOURCE_DISTANCE_MODEL":
              AL.currentCtx.sourceDistanceModel = false;
              AL.updateContextGlobal(AL.currentCtx);
              break;
            default:
              AL.currentCtx.err = 40962;
              return;
          }
        };
        _alDisable.sig = "vi";
        var _alDistanceModel = (model) => {
          AL.setGlobalParam("alDistanceModel", 53248, model);
        };
        _alDistanceModel.sig = "vi";
        var _alDopplerFactor = (value) => {
          AL.setGlobalParam("alDopplerFactor", 49152, value);
        };
        _alDopplerFactor.sig = "vf";
        var _alDopplerVelocity = (value) => {
          warnOnce("alDopplerVelocity() is deprecated, and only kept for compatibility with OpenAL 1.0. Use alSpeedOfSound() instead.");
          if (!AL.currentCtx) {
            return;
          }
          if (value <= 0) {
            AL.currentCtx.err = 40963;
            return;
          }
        };
        _alDopplerVelocity.sig = "vf";
        var _alEnable = (param) => {
          if (!AL.currentCtx) {
            return;
          }
          switch (param) {
            case "AL_SOURCE_DISTANCE_MODEL":
              AL.currentCtx.sourceDistanceModel = true;
              AL.updateContextGlobal(AL.currentCtx);
              break;
            default:
              AL.currentCtx.err = 40962;
              return;
          }
        };
        _alEnable.sig = "vi";
        function _alGenBuffers(count, pBufferIds) {
          pBufferIds >>>= 0;
          if (!AL.currentCtx) {
            return;
          }
          for (var i2 = 0; i2 < count; ++i2) {
            var buf = {
              deviceId: AL.currentCtx.deviceId,
              id: AL.newId(),
              refCount: 0,
              audioBuf: null,
              frequency: 0,
              bytesPerSample: 2,
              channels: 1,
              length: 0
            };
            AL.deviceRefCounts[buf.deviceId]++;
            AL.buffers[buf.id] = buf;
            HEAP32[pBufferIds + i2 * 4 >>> 2 >>> 0] = buf.id;
          }
        }
        _alGenBuffers.sig = "vip";
        function _alGenSources(count, pSourceIds) {
          pSourceIds >>>= 0;
          if (!AL.currentCtx) {
            return;
          }
          for (var i2 = 0; i2 < count; ++i2) {
            var gain = AL.currentCtx.audioCtx.createGain();
            gain.connect(AL.currentCtx.gain);
            var src = {
              context: AL.currentCtx,
              id: AL.newId(),
              type: 4144,
              state: 4113,
              bufQueue: [AL.buffers[0]],
              audioQueue: [],
              looping: false,
              pitch: 1,
              dopplerShift: 1,
              gain,
              minGain: 0,
              maxGain: 1,
              panner: null,
              bufsProcessed: 0,
              bufStartTime: Number.NEGATIVE_INFINITY,
              bufOffset: 0,
              relative: false,
              refDistance: 1,
              maxDistance: 340282e33,
              rolloffFactor: 1,
              position: [0, 0, 0],
              velocity: [0, 0, 0],
              direction: [0, 0, 0],
              coneOuterGain: 0,
              coneInnerAngle: 360,
              coneOuterAngle: 360,
              distanceModel: 53250,
              spatialize: 2,
              get playbackRate() {
                return this.pitch * this.dopplerShift;
              }
            };
            AL.currentCtx.sources[src.id] = src;
            HEAP32[pSourceIds + i2 * 4 >>> 2 >>> 0] = src.id;
          }
        }
        _alGenSources.sig = "vip";
        var _alGetBoolean = (param) => {
          var val = AL.getGlobalParam("alGetBoolean", param);
          if (val === null) {
            return 0;
          }
          switch (param) {
            case 49152:
            case 49155:
            case 53248:
              return val !== 0 ? 1 : 0;
            default:
              AL.currentCtx.err = 40962;
              return 0;
          }
        };
        _alGetBoolean.sig = "ii";
        function _alGetBooleanv(param, pValues) {
          pValues >>>= 0;
          var val = AL.getGlobalParam("alGetBooleanv", param);
          if (val === null || !pValues) {
            return;
          }
          switch (param) {
            case 49152:
            case 49155:
            case 53248:
              HEAP8[pValues >>> 0 >>> 0] = val;
              break;
            default:
              AL.currentCtx.err = 40962;
              return;
          }
        }
        _alGetBooleanv.sig = "vip";
        function _alGetBuffer3f(bufferId, param, pValue0, pValue1, pValue2) {
          pValue0 >>>= 0;
          pValue1 >>>= 0;
          pValue2 >>>= 0;
          var val = AL.getBufferParam("alGetBuffer3f", bufferId, param);
          if (val === null) {
            return;
          }
          if (!pValue0 || !pValue1 || !pValue2) {
            AL.currentCtx.err = 40963;
            return;
          }
          AL.currentCtx.err = 40962;
        }
        _alGetBuffer3f.sig = "viippp";
        function _alGetBuffer3i(bufferId, param, pValue0, pValue1, pValue2) {
          pValue0 >>>= 0;
          pValue1 >>>= 0;
          pValue2 >>>= 0;
          var val = AL.getBufferParam("alGetBuffer3i", bufferId, param);
          if (val === null) {
            return;
          }
          if (!pValue0 || !pValue1 || !pValue2) {
            AL.currentCtx.err = 40963;
            return;
          }
          AL.currentCtx.err = 40962;
        }
        _alGetBuffer3i.sig = "viippp";
        function _alGetBufferf(bufferId, param, pValue) {
          pValue >>>= 0;
          var val = AL.getBufferParam("alGetBufferf", bufferId, param);
          if (val === null) {
            return;
          }
          if (!pValue) {
            AL.currentCtx.err = 40963;
            return;
          }
          AL.currentCtx.err = 40962;
        }
        _alGetBufferf.sig = "viip";
        function _alGetBufferfv(bufferId, param, pValues) {
          pValues >>>= 0;
          var val = AL.getBufferParam("alGetBufferfv", bufferId, param);
          if (val === null) {
            return;
          }
          if (!pValues) {
            AL.currentCtx.err = 40963;
            return;
          }
          AL.currentCtx.err = 40962;
        }
        _alGetBufferfv.sig = "viip";
        function _alGetBufferi(bufferId, param, pValue) {
          pValue >>>= 0;
          var val = AL.getBufferParam("alGetBufferi", bufferId, param);
          if (val === null) {
            return;
          }
          if (!pValue) {
            AL.currentCtx.err = 40963;
            return;
          }
          switch (param) {
            case 8193:
            case 8194:
            case 8195:
            case 8196:
              HEAP32[pValue >>> 2 >>> 0] = val;
              break;
            default:
              AL.currentCtx.err = 40962;
              return;
          }
        }
        _alGetBufferi.sig = "viip";
        function _alGetBufferiv(bufferId, param, pValues) {
          pValues >>>= 0;
          var val = AL.getBufferParam("alGetBufferiv", bufferId, param);
          if (val === null) {
            return;
          }
          if (!pValues) {
            AL.currentCtx.err = 40963;
            return;
          }
          switch (param) {
            case 8193:
            case 8194:
            case 8195:
            case 8196:
              HEAP32[pValues >>> 2 >>> 0] = val;
              break;
            case 8213:
              HEAP32[pValues >>> 2 >>> 0] = val[0];
              HEAP32[pValues + 4 >>> 2 >>> 0] = val[1];
              break;
            default:
              AL.currentCtx.err = 40962;
              return;
          }
        }
        _alGetBufferiv.sig = "viip";
        var _alGetDouble = (param) => {
          var val = AL.getGlobalParam("alGetDouble", param);
          if (val === null) {
            return 0;
          }
          switch (param) {
            case 49152:
            case 49155:
            case 53248:
              return val;
            default:
              AL.currentCtx.err = 40962;
              return 0;
          }
        };
        _alGetDouble.sig = "di";
        function _alGetDoublev(param, pValues) {
          pValues >>>= 0;
          var val = AL.getGlobalParam("alGetDoublev", param);
          if (val === null || !pValues) {
            return;
          }
          switch (param) {
            case 49152:
            case 49155:
            case 53248:
              HEAPF64[pValues >>> 3 >>> 0] = val;
              break;
            default:
              AL.currentCtx.err = 40962;
              return;
          }
        }
        _alGetDoublev.sig = "vip";
        function _alGetEnumValue(pEnumName) {
          pEnumName >>>= 0;
          if (!AL.currentCtx) {
            return 0;
          }
          if (!pEnumName) {
            AL.currentCtx.err = 40963;
            return 0;
          }
          var name2 = UTF8ToString(pEnumName);
          switch (name2) {
            case "AL_BITS":
              return 8194;
            case "AL_BUFFER":
              return 4105;
            case "AL_BUFFERS_PROCESSED":
              return 4118;
            case "AL_BUFFERS_QUEUED":
              return 4117;
            case "AL_BYTE_OFFSET":
              return 4134;
            case "AL_CHANNELS":
              return 8195;
            case "AL_CONE_INNER_ANGLE":
              return 4097;
            case "AL_CONE_OUTER_ANGLE":
              return 4098;
            case "AL_CONE_OUTER_GAIN":
              return 4130;
            case "AL_DIRECTION":
              return 4101;
            case "AL_DISTANCE_MODEL":
              return 53248;
            case "AL_DOPPLER_FACTOR":
              return 49152;
            case "AL_DOPPLER_VELOCITY":
              return 49153;
            case "AL_EXPONENT_DISTANCE":
              return 53253;
            case "AL_EXPONENT_DISTANCE_CLAMPED":
              return 53254;
            case "AL_EXTENSIONS":
              return 45060;
            case "AL_FORMAT_MONO16":
              return 4353;
            case "AL_FORMAT_MONO8":
              return 4352;
            case "AL_FORMAT_STEREO16":
              return 4355;
            case "AL_FORMAT_STEREO8":
              return 4354;
            case "AL_FREQUENCY":
              return 8193;
            case "AL_GAIN":
              return 4106;
            case "AL_INITIAL":
              return 4113;
            case "AL_INVALID":
              return -1;
            case "AL_ILLEGAL_ENUM":
            case "AL_INVALID_ENUM":
              return 40962;
            case "AL_INVALID_NAME":
              return 40961;
            case "AL_ILLEGAL_COMMAND":
            case "AL_INVALID_OPERATION":
              return 40964;
            case "AL_INVALID_VALUE":
              return 40963;
            case "AL_INVERSE_DISTANCE":
              return 53249;
            case "AL_INVERSE_DISTANCE_CLAMPED":
              return 53250;
            case "AL_LINEAR_DISTANCE":
              return 53251;
            case "AL_LINEAR_DISTANCE_CLAMPED":
              return 53252;
            case "AL_LOOPING":
              return 4103;
            case "AL_MAX_DISTANCE":
              return 4131;
            case "AL_MAX_GAIN":
              return 4110;
            case "AL_MIN_GAIN":
              return 4109;
            case "AL_NONE":
              return 0;
            case "AL_NO_ERROR":
              return 0;
            case "AL_ORIENTATION":
              return 4111;
            case "AL_OUT_OF_MEMORY":
              return 40965;
            case "AL_PAUSED":
              return 4115;
            case "AL_PENDING":
              return 8209;
            case "AL_PITCH":
              return 4099;
            case "AL_PLAYING":
              return 4114;
            case "AL_POSITION":
              return 4100;
            case "AL_PROCESSED":
              return 8210;
            case "AL_REFERENCE_DISTANCE":
              return 4128;
            case "AL_RENDERER":
              return 45059;
            case "AL_ROLLOFF_FACTOR":
              return 4129;
            case "AL_SAMPLE_OFFSET":
              return 4133;
            case "AL_SEC_OFFSET":
              return 4132;
            case "AL_SIZE":
              return 8196;
            case "AL_SOURCE_RELATIVE":
              return 514;
            case "AL_SOURCE_STATE":
              return 4112;
            case "AL_SOURCE_TYPE":
              return 4135;
            case "AL_SPEED_OF_SOUND":
              return 49155;
            case "AL_STATIC":
              return 4136;
            case "AL_STOPPED":
              return 4116;
            case "AL_STREAMING":
              return 4137;
            case "AL_UNDETERMINED":
              return 4144;
            case "AL_UNUSED":
              return 8208;
            case "AL_VELOCITY":
              return 4102;
            case "AL_VENDOR":
              return 45057;
            case "AL_VERSION":
              return 45058;
            case "AL_AUTO_SOFT":
              return 2;
            case "AL_SOURCE_DISTANCE_MODEL":
              return 512;
            case "AL_SOURCE_SPATIALIZE_SOFT":
              return 4628;
            case "AL_LOOP_POINTS_SOFT":
              return 8213;
            case "AL_BYTE_LENGTH_SOFT":
              return 8201;
            case "AL_SAMPLE_LENGTH_SOFT":
              return 8202;
            case "AL_SEC_LENGTH_SOFT":
              return 8203;
            case "AL_FORMAT_MONO_FLOAT32":
              return 65552;
            case "AL_FORMAT_STEREO_FLOAT32":
              return 65553;
            default:
              AL.currentCtx.err = 40963;
              return 0;
          }
        }
        _alGetEnumValue.sig = "ip";
        var _alGetError = () => {
          if (!AL.currentCtx) {
            return 40964;
          }
          var err2 = AL.currentCtx.err;
          AL.currentCtx.err = 0;
          return err2;
        };
        _alGetError.sig = "i";
        var _alGetFloat = (param) => {
          var val = AL.getGlobalParam("alGetFloat", param);
          if (val === null) {
            return 0;
          }
          switch (param) {
            case 49152:
            case 49155:
            case 53248:
              return val;
            default:
              return 0;
          }
        };
        _alGetFloat.sig = "fi";
        function _alGetFloatv(param, pValues) {
          pValues >>>= 0;
          var val = AL.getGlobalParam("alGetFloatv", param);
          if (val === null || !pValues) {
            return;
          }
          switch (param) {
            case 49152:
            case 49155:
            case 53248:
              HEAPF32[pValues >>> 2 >>> 0] = val;
              break;
            default:
              AL.currentCtx.err = 40962;
              return;
          }
        }
        _alGetFloatv.sig = "vip";
        var _alGetInteger = (param) => {
          var val = AL.getGlobalParam("alGetInteger", param);
          if (val === null) {
            return 0;
          }
          switch (param) {
            case 49152:
            case 49155:
            case 53248:
              return val;
            default:
              AL.currentCtx.err = 40962;
              return 0;
          }
        };
        _alGetInteger.sig = "ii";
        function _alGetIntegerv(param, pValues) {
          pValues >>>= 0;
          var val = AL.getGlobalParam("alGetIntegerv", param);
          if (val === null || !pValues) {
            return;
          }
          switch (param) {
            case 49152:
            case 49155:
            case 53248:
              HEAP32[pValues >>> 2 >>> 0] = val;
              break;
            default:
              AL.currentCtx.err = 40962;
              return;
          }
        }
        _alGetIntegerv.sig = "vip";
        function _alGetListener3f(param, pValue0, pValue1, pValue2) {
          pValue0 >>>= 0;
          pValue1 >>>= 0;
          pValue2 >>>= 0;
          var val = AL.getListenerParam("alGetListener3f", param);
          if (val === null) {
            return;
          }
          if (!pValue0 || !pValue1 || !pValue2) {
            AL.currentCtx.err = 40963;
            return;
          }
          switch (param) {
            case 4100:
            case 4102:
              HEAPF32[pValue0 >>> 2 >>> 0] = val[0];
              HEAPF32[pValue1 >>> 2 >>> 0] = val[1];
              HEAPF32[pValue2 >>> 2 >>> 0] = val[2];
              break;
            default:
              AL.currentCtx.err = 40962;
              return;
          }
        }
        _alGetListener3f.sig = "vippp";
        function _alGetListener3i(param, pValue0, pValue1, pValue2) {
          pValue0 >>>= 0;
          pValue1 >>>= 0;
          pValue2 >>>= 0;
          var val = AL.getListenerParam("alGetListener3i", param);
          if (val === null) {
            return;
          }
          if (!pValue0 || !pValue1 || !pValue2) {
            AL.currentCtx.err = 40963;
            return;
          }
          switch (param) {
            case 4100:
            case 4102:
              HEAP32[pValue0 >>> 2 >>> 0] = val[0];
              HEAP32[pValue1 >>> 2 >>> 0] = val[1];
              HEAP32[pValue2 >>> 2 >>> 0] = val[2];
              break;
            default:
              AL.currentCtx.err = 40962;
              return;
          }
        }
        _alGetListener3i.sig = "vippp";
        function _alGetListenerf(param, pValue) {
          pValue >>>= 0;
          var val = AL.getListenerParam("alGetListenerf", param);
          if (val === null) {
            return;
          }
          if (!pValue) {
            AL.currentCtx.err = 40963;
            return;
          }
          switch (param) {
            case 4106:
              HEAPF32[pValue >>> 2 >>> 0] = val;
              break;
            default:
              AL.currentCtx.err = 40962;
              return;
          }
        }
        _alGetListenerf.sig = "vip";
        function _alGetListenerfv(param, pValues) {
          pValues >>>= 0;
          var val = AL.getListenerParam("alGetListenerfv", param);
          if (val === null) {
            return;
          }
          if (!pValues) {
            AL.currentCtx.err = 40963;
            return;
          }
          switch (param) {
            case 4100:
            case 4102:
              HEAPF32[pValues >>> 2 >>> 0] = val[0];
              HEAPF32[pValues + 4 >>> 2 >>> 0] = val[1];
              HEAPF32[pValues + 8 >>> 2 >>> 0] = val[2];
              break;
            case 4111:
              HEAPF32[pValues >>> 2 >>> 0] = val[0];
              HEAPF32[pValues + 4 >>> 2 >>> 0] = val[1];
              HEAPF32[pValues + 8 >>> 2 >>> 0] = val[2];
              HEAPF32[pValues + 12 >>> 2 >>> 0] = val[3];
              HEAPF32[pValues + 16 >>> 2 >>> 0] = val[4];
              HEAPF32[pValues + 20 >>> 2 >>> 0] = val[5];
              break;
            default:
              AL.currentCtx.err = 40962;
              return;
          }
        }
        _alGetListenerfv.sig = "vip";
        function _alGetListeneri(param, pValue) {
          pValue >>>= 0;
          var val = AL.getListenerParam("alGetListeneri", param);
          if (val === null) {
            return;
          }
          if (!pValue) {
            AL.currentCtx.err = 40963;
            return;
          }
          AL.currentCtx.err = 40962;
        }
        _alGetListeneri.sig = "vip";
        function _alGetListeneriv(param, pValues) {
          pValues >>>= 0;
          var val = AL.getListenerParam("alGetListeneriv", param);
          if (val === null) {
            return;
          }
          if (!pValues) {
            AL.currentCtx.err = 40963;
            return;
          }
          switch (param) {
            case 4100:
            case 4102:
              HEAP32[pValues >>> 2 >>> 0] = val[0];
              HEAP32[pValues + 4 >>> 2 >>> 0] = val[1];
              HEAP32[pValues + 8 >>> 2 >>> 0] = val[2];
              break;
            case 4111:
              HEAP32[pValues >>> 2 >>> 0] = val[0];
              HEAP32[pValues + 4 >>> 2 >>> 0] = val[1];
              HEAP32[pValues + 8 >>> 2 >>> 0] = val[2];
              HEAP32[pValues + 12 >>> 2 >>> 0] = val[3];
              HEAP32[pValues + 16 >>> 2 >>> 0] = val[4];
              HEAP32[pValues + 20 >>> 2 >>> 0] = val[5];
              break;
            default:
              AL.currentCtx.err = 40962;
              return;
          }
        }
        _alGetListeneriv.sig = "vip";
        function _alGetSource3f(sourceId, param, pValue0, pValue1, pValue2) {
          pValue0 >>>= 0;
          pValue1 >>>= 0;
          pValue2 >>>= 0;
          var val = AL.getSourceParam("alGetSource3f", sourceId, param);
          if (val === null) {
            return;
          }
          if (!pValue0 || !pValue1 || !pValue2) {
            AL.currentCtx.err = 40963;
            return;
          }
          switch (param) {
            case 4100:
            case 4101:
            case 4102:
              HEAPF32[pValue0 >>> 2 >>> 0] = val[0];
              HEAPF32[pValue1 >>> 2 >>> 0] = val[1];
              HEAPF32[pValue2 >>> 2 >>> 0] = val[2];
              break;
            default:
              AL.currentCtx.err = 40962;
              return;
          }
        }
        _alGetSource3f.sig = "viippp";
        function _alGetSource3i(sourceId, param, pValue0, pValue1, pValue2) {
          pValue0 >>>= 0;
          pValue1 >>>= 0;
          pValue2 >>>= 0;
          var val = AL.getSourceParam("alGetSource3i", sourceId, param);
          if (val === null) {
            return;
          }
          if (!pValue0 || !pValue1 || !pValue2) {
            AL.currentCtx.err = 40963;
            return;
          }
          switch (param) {
            case 4100:
            case 4101:
            case 4102:
              HEAP32[pValue0 >>> 2 >>> 0] = val[0];
              HEAP32[pValue1 >>> 2 >>> 0] = val[1];
              HEAP32[pValue2 >>> 2 >>> 0] = val[2];
              break;
            default:
              AL.currentCtx.err = 40962;
              return;
          }
        }
        _alGetSource3i.sig = "viippp";
        function _alGetSourcef(sourceId, param, pValue) {
          pValue >>>= 0;
          var val = AL.getSourceParam("alGetSourcef", sourceId, param);
          if (val === null) {
            return;
          }
          if (!pValue) {
            AL.currentCtx.err = 40963;
            return;
          }
          switch (param) {
            case 4097:
            case 4098:
            case 4099:
            case 4106:
            case 4109:
            case 4110:
            case 4128:
            case 4129:
            case 4130:
            case 4131:
            case 4132:
            case 4133:
            case 4134:
            case 8203:
              HEAPF32[pValue >>> 2 >>> 0] = val;
              break;
            default:
              AL.currentCtx.err = 40962;
              return;
          }
        }
        _alGetSourcef.sig = "viip";
        function _alGetSourcefv(sourceId, param, pValues) {
          pValues >>>= 0;
          var val = AL.getSourceParam("alGetSourcefv", sourceId, param);
          if (val === null) {
            return;
          }
          if (!pValues) {
            AL.currentCtx.err = 40963;
            return;
          }
          switch (param) {
            case 4097:
            case 4098:
            case 4099:
            case 4106:
            case 4109:
            case 4110:
            case 4128:
            case 4129:
            case 4130:
            case 4131:
            case 4132:
            case 4133:
            case 4134:
            case 8203:
              HEAPF32[pValues >>> 2 >>> 0] = val[0];
              break;
            case 4100:
            case 4101:
            case 4102:
              HEAPF32[pValues >>> 2 >>> 0] = val[0];
              HEAPF32[pValues + 4 >>> 2 >>> 0] = val[1];
              HEAPF32[pValues + 8 >>> 2 >>> 0] = val[2];
              break;
            default:
              AL.currentCtx.err = 40962;
              return;
          }
        }
        _alGetSourcefv.sig = "viip";
        function _alGetSourcei(sourceId, param, pValue) {
          pValue >>>= 0;
          var val = AL.getSourceParam("alGetSourcei", sourceId, param);
          if (val === null) {
            return;
          }
          if (!pValue) {
            AL.currentCtx.err = 40963;
            return;
          }
          switch (param) {
            case 514:
            case 4097:
            case 4098:
            case 4103:
            case 4105:
            case 4112:
            case 4117:
            case 4118:
            case 4128:
            case 4129:
            case 4131:
            case 4132:
            case 4133:
            case 4134:
            case 4135:
            case 4628:
            case 8201:
            case 8202:
            case 53248:
              HEAP32[pValue >>> 2 >>> 0] = val;
              break;
            default:
              AL.currentCtx.err = 40962;
              return;
          }
        }
        _alGetSourcei.sig = "viip";
        function _alGetSourceiv(sourceId, param, pValues) {
          pValues >>>= 0;
          var val = AL.getSourceParam("alGetSourceiv", sourceId, param);
          if (val === null) {
            return;
          }
          if (!pValues) {
            AL.currentCtx.err = 40963;
            return;
          }
          switch (param) {
            case 514:
            case 4097:
            case 4098:
            case 4103:
            case 4105:
            case 4112:
            case 4117:
            case 4118:
            case 4128:
            case 4129:
            case 4131:
            case 4132:
            case 4133:
            case 4134:
            case 4135:
            case 4628:
            case 8201:
            case 8202:
            case 53248:
              HEAP32[pValues >>> 2 >>> 0] = val;
              break;
            case 4100:
            case 4101:
            case 4102:
              HEAP32[pValues >>> 2 >>> 0] = val[0];
              HEAP32[pValues + 4 >>> 2 >>> 0] = val[1];
              HEAP32[pValues + 8 >>> 2 >>> 0] = val[2];
              break;
            default:
              AL.currentCtx.err = 40962;
              return;
          }
        }
        _alGetSourceiv.sig = "viip";
        function _alGetString(param) {
          if (AL.stringCache[param]) {
            return AL.stringCache[param];
          }
          var ret;
          switch (param) {
            case 0:
              ret = "No Error";
              break;
            case 40961:
              ret = "Invalid Name";
              break;
            case 40962:
              ret = "Invalid Enum";
              break;
            case 40963:
              ret = "Invalid Value";
              break;
            case 40964:
              ret = "Invalid Operation";
              break;
            case 40965:
              ret = "Out of Memory";
              break;
            case 45057:
              ret = "Emscripten";
              break;
            case 45058:
              ret = "1.1";
              break;
            case 45059:
              ret = "WebAudio";
              break;
            case 45060:
              ret = "";
              for (var ext in AL.AL_EXTENSIONS) {
                ret = ret.concat(ext);
                ret = ret.concat(" ");
              }
              ret = ret.trim();
              break;
            default:
              if (AL.currentCtx) {
                AL.currentCtx.err = 40962;
              } else {
              }
              return 0;
          }
          ret = stringToNewUTF8(ret);
          AL.stringCache[param] = ret;
          return ret;
        }
        _alGetString.sig = "pi";
        var _alIsBuffer = (bufferId) => {
          if (!AL.currentCtx) {
            return false;
          }
          if (bufferId > AL.buffers.length) {
            return false;
          }
          if (!AL.buffers[bufferId]) {
            return false;
          }
          return true;
        };
        _alIsBuffer.sig = "ii";
        var _alIsEnabled = (param) => {
          if (!AL.currentCtx) {
            return 0;
          }
          switch (param) {
            case "AL_SOURCE_DISTANCE_MODEL":
              return AL.currentCtx.sourceDistanceModel ? 0 : 1;
            default:
              AL.currentCtx.err = 40962;
              return 0;
          }
        };
        _alIsEnabled.sig = "ii";
        function _alIsExtensionPresent(pExtName) {
          pExtName >>>= 0;
          var name2 = UTF8ToString(pExtName);
          return AL.AL_EXTENSIONS[name2] ? 1 : 0;
        }
        _alIsExtensionPresent.sig = "ip";
        var _alIsSource = (sourceId) => {
          if (!AL.currentCtx) {
            return false;
          }
          if (!AL.currentCtx.sources[sourceId]) {
            return false;
          }
          return true;
        };
        _alIsSource.sig = "ii";
        var _alListener3f = (param, value0, value1, value2) => {
          switch (param) {
            case 4100:
            case 4102:
              AL.paramArray[0] = value0;
              AL.paramArray[1] = value1;
              AL.paramArray[2] = value2;
              AL.setListenerParam("alListener3f", param, AL.paramArray);
              break;
            default:
              AL.setListenerParam("alListener3f", param, null);
              break;
          }
        };
        _alListener3f.sig = "vifff";
        var _alListener3i = (param, value0, value1, value2) => {
          switch (param) {
            case 4100:
            case 4102:
              AL.paramArray[0] = value0;
              AL.paramArray[1] = value1;
              AL.paramArray[2] = value2;
              AL.setListenerParam("alListener3i", param, AL.paramArray);
              break;
            default:
              AL.setListenerParam("alListener3i", param, null);
              break;
          }
        };
        _alListener3i.sig = "viiii";
        var _alListenerf = (param, value) => {
          switch (param) {
            case 4106:
              AL.setListenerParam("alListenerf", param, value);
              break;
            default:
              AL.setListenerParam("alListenerf", param, null);
              break;
          }
        };
        _alListenerf.sig = "vif";
        function _alListenerfv(param, pValues) {
          pValues >>>= 0;
          if (!AL.currentCtx) {
            return;
          }
          if (!pValues) {
            AL.currentCtx.err = 40963;
            return;
          }
          switch (param) {
            case 4100:
            case 4102:
              AL.paramArray[0] = HEAPF32[pValues >>> 2 >>> 0];
              AL.paramArray[1] = HEAPF32[pValues + 4 >>> 2 >>> 0];
              AL.paramArray[2] = HEAPF32[pValues + 8 >>> 2 >>> 0];
              AL.setListenerParam("alListenerfv", param, AL.paramArray);
              break;
            case 4111:
              AL.paramArray[0] = HEAPF32[pValues >>> 2 >>> 0];
              AL.paramArray[1] = HEAPF32[pValues + 4 >>> 2 >>> 0];
              AL.paramArray[2] = HEAPF32[pValues + 8 >>> 2 >>> 0];
              AL.paramArray[3] = HEAPF32[pValues + 12 >>> 2 >>> 0];
              AL.paramArray[4] = HEAPF32[pValues + 16 >>> 2 >>> 0];
              AL.paramArray[5] = HEAPF32[pValues + 20 >>> 2 >>> 0];
              AL.setListenerParam("alListenerfv", param, AL.paramArray);
              break;
            default:
              AL.setListenerParam("alListenerfv", param, null);
              break;
          }
        }
        _alListenerfv.sig = "vip";
        var _alListeneri = (param, value) => {
          AL.setListenerParam("alListeneri", param, null);
        };
        _alListeneri.sig = "vii";
        function _alListeneriv(param, pValues) {
          pValues >>>= 0;
          if (!AL.currentCtx) {
            return;
          }
          if (!pValues) {
            AL.currentCtx.err = 40963;
            return;
          }
          switch (param) {
            case 4100:
            case 4102:
              AL.paramArray[0] = HEAP32[pValues >>> 2 >>> 0];
              AL.paramArray[1] = HEAP32[pValues + 4 >>> 2 >>> 0];
              AL.paramArray[2] = HEAP32[pValues + 8 >>> 2 >>> 0];
              AL.setListenerParam("alListeneriv", param, AL.paramArray);
              break;
            case 4111:
              AL.paramArray[0] = HEAP32[pValues >>> 2 >>> 0];
              AL.paramArray[1] = HEAP32[pValues + 4 >>> 2 >>> 0];
              AL.paramArray[2] = HEAP32[pValues + 8 >>> 2 >>> 0];
              AL.paramArray[3] = HEAP32[pValues + 12 >>> 2 >>> 0];
              AL.paramArray[4] = HEAP32[pValues + 16 >>> 2 >>> 0];
              AL.paramArray[5] = HEAP32[pValues + 20 >>> 2 >>> 0];
              AL.setListenerParam("alListeneriv", param, AL.paramArray);
              break;
            default:
              AL.setListenerParam("alListeneriv", param, null);
              break;
          }
        }
        _alListeneriv.sig = "vip";
        var _alSource3f = (sourceId, param, value0, value1, value2) => {
          switch (param) {
            case 4100:
            case 4101:
            case 4102:
              AL.paramArray[0] = value0;
              AL.paramArray[1] = value1;
              AL.paramArray[2] = value2;
              AL.setSourceParam("alSource3f", sourceId, param, AL.paramArray);
              break;
            default:
              AL.setSourceParam("alSource3f", sourceId, param, null);
              break;
          }
        };
        _alSource3f.sig = "viifff";
        var _alSource3i = (sourceId, param, value0, value1, value2) => {
          switch (param) {
            case 4100:
            case 4101:
            case 4102:
              AL.paramArray[0] = value0;
              AL.paramArray[1] = value1;
              AL.paramArray[2] = value2;
              AL.setSourceParam("alSource3i", sourceId, param, AL.paramArray);
              break;
            default:
              AL.setSourceParam("alSource3i", sourceId, param, null);
              break;
          }
        };
        _alSource3i.sig = "viiiii";
        var _alSourcePause = (sourceId) => {
          if (!AL.currentCtx) {
            return;
          }
          var src = AL.currentCtx.sources[sourceId];
          if (!src) {
            AL.currentCtx.err = 40961;
            return;
          }
          AL.setSourceState(src, 4115);
        };
        _alSourcePause.sig = "vi";
        function _alSourcePausev(count, pSourceIds) {
          pSourceIds >>>= 0;
          if (!AL.currentCtx) {
            return;
          }
          if (!pSourceIds) {
            AL.currentCtx.err = 40963;
          }
          for (var i2 = 0; i2 < count; ++i2) {
            if (!AL.currentCtx.sources[HEAP32[pSourceIds + i2 * 4 >>> 2 >>> 0]]) {
              AL.currentCtx.err = 40961;
              return;
            }
          }
          for (var i2 = 0; i2 < count; ++i2) {
            var srcId = HEAP32[pSourceIds + i2 * 4 >>> 2 >>> 0];
            AL.setSourceState(AL.currentCtx.sources[srcId], 4115);
          }
        }
        _alSourcePausev.sig = "vip";
        var _alSourcePlay = (sourceId) => {
          if (!AL.currentCtx) {
            return;
          }
          var src = AL.currentCtx.sources[sourceId];
          if (!src) {
            AL.currentCtx.err = 40961;
            return;
          }
          AL.setSourceState(src, 4114);
        };
        _alSourcePlay.sig = "vi";
        function _alSourcePlayv(count, pSourceIds) {
          pSourceIds >>>= 0;
          if (!AL.currentCtx) {
            return;
          }
          if (!pSourceIds) {
            AL.currentCtx.err = 40963;
          }
          for (var i2 = 0; i2 < count; ++i2) {
            if (!AL.currentCtx.sources[HEAP32[pSourceIds + i2 * 4 >>> 2 >>> 0]]) {
              AL.currentCtx.err = 40961;
              return;
            }
          }
          for (var i2 = 0; i2 < count; ++i2) {
            var srcId = HEAP32[pSourceIds + i2 * 4 >>> 2 >>> 0];
            AL.setSourceState(AL.currentCtx.sources[srcId], 4114);
          }
        }
        _alSourcePlayv.sig = "vip";
        function _alSourceQueueBuffers(sourceId, count, pBufferIds) {
          pBufferIds >>>= 0;
          if (!AL.currentCtx) {
            return;
          }
          var src = AL.currentCtx.sources[sourceId];
          if (!src) {
            AL.currentCtx.err = 40961;
            return;
          }
          if (src.type === 4136) {
            AL.currentCtx.err = 40964;
            return;
          }
          if (count === 0) {
            return;
          }
          var templateBuf = AL.buffers[0];
          for (var i2 = 0; i2 < src.bufQueue.length; i2++) {
            if (src.bufQueue[i2].id !== 0) {
              templateBuf = src.bufQueue[i2];
              break;
            }
          }
          for (var i2 = 0; i2 < count; ++i2) {
            var bufId = HEAP32[pBufferIds + i2 * 4 >>> 2 >>> 0];
            var buf = AL.buffers[bufId];
            if (!buf) {
              AL.currentCtx.err = 40961;
              return;
            }
            if (templateBuf.id !== 0 && (buf.frequency !== templateBuf.frequency || buf.bytesPerSample !== templateBuf.bytesPerSample || buf.channels !== templateBuf.channels)) {
              AL.currentCtx.err = 40964;
            }
          }
          if (src.bufQueue.length === 1 && src.bufQueue[0].id === 0) {
            src.bufQueue.length = 0;
          }
          src.type = 4137;
          for (var i2 = 0; i2 < count; ++i2) {
            var bufId = HEAP32[pBufferIds + i2 * 4 >>> 2 >>> 0];
            var buf = AL.buffers[bufId];
            buf.refCount++;
            src.bufQueue.push(buf);
          }
          if (src.looping) {
            AL.cancelPendingSourceAudio(src);
          }
          AL.initSourcePanner(src);
          AL.scheduleSourceAudio(src);
        }
        _alSourceQueueBuffers.sig = "viip";
        var _alSourceRewind = (sourceId) => {
          if (!AL.currentCtx) {
            return;
          }
          var src = AL.currentCtx.sources[sourceId];
          if (!src) {
            AL.currentCtx.err = 40961;
            return;
          }
          AL.setSourceState(src, 4116);
          AL.setSourceState(src, 4113);
        };
        _alSourceRewind.sig = "vi";
        function _alSourceRewindv(count, pSourceIds) {
          pSourceIds >>>= 0;
          if (!AL.currentCtx) {
            return;
          }
          if (!pSourceIds) {
            AL.currentCtx.err = 40963;
          }
          for (var i2 = 0; i2 < count; ++i2) {
            if (!AL.currentCtx.sources[HEAP32[pSourceIds + i2 * 4 >>> 2 >>> 0]]) {
              AL.currentCtx.err = 40961;
              return;
            }
          }
          for (var i2 = 0; i2 < count; ++i2) {
            var srcId = HEAP32[pSourceIds + i2 * 4 >>> 2 >>> 0];
            AL.setSourceState(AL.currentCtx.sources[srcId], 4113);
          }
        }
        _alSourceRewindv.sig = "vip";
        var _alSourceStop = (sourceId) => {
          if (!AL.currentCtx) {
            return;
          }
          var src = AL.currentCtx.sources[sourceId];
          if (!src) {
            AL.currentCtx.err = 40961;
            return;
          }
          AL.setSourceState(src, 4116);
        };
        _alSourceStop.sig = "vi";
        function _alSourceStopv(count, pSourceIds) {
          pSourceIds >>>= 0;
          if (!AL.currentCtx) {
            return;
          }
          if (!pSourceIds) {
            AL.currentCtx.err = 40963;
          }
          for (var i2 = 0; i2 < count; ++i2) {
            if (!AL.currentCtx.sources[HEAP32[pSourceIds + i2 * 4 >>> 2 >>> 0]]) {
              AL.currentCtx.err = 40961;
              return;
            }
          }
          for (var i2 = 0; i2 < count; ++i2) {
            var srcId = HEAP32[pSourceIds + i2 * 4 >>> 2 >>> 0];
            AL.setSourceState(AL.currentCtx.sources[srcId], 4116);
          }
        }
        _alSourceStopv.sig = "vip";
        function _alSourceUnqueueBuffers(sourceId, count, pBufferIds) {
          pBufferIds >>>= 0;
          if (!AL.currentCtx) {
            return;
          }
          var src = AL.currentCtx.sources[sourceId];
          if (!src) {
            AL.currentCtx.err = 40961;
            return;
          }
          if (count > (src.bufQueue.length === 1 && src.bufQueue[0].id === 0 ? 0 : src.bufsProcessed)) {
            AL.currentCtx.err = 40963;
            return;
          }
          if (count === 0) {
            return;
          }
          for (var i2 = 0; i2 < count; i2++) {
            var buf = src.bufQueue.shift();
            buf.refCount--;
            HEAP32[pBufferIds + i2 * 4 >>> 2 >>> 0] = buf.id;
            src.bufsProcessed--;
          }
          if (src.bufQueue.length === 0) {
            src.bufQueue.push(AL.buffers[0]);
          }
          AL.initSourcePanner(src);
          AL.scheduleSourceAudio(src);
        }
        _alSourceUnqueueBuffers.sig = "viip";
        var _alSourcef = (sourceId, param, value) => {
          switch (param) {
            case 4097:
            case 4098:
            case 4099:
            case 4106:
            case 4109:
            case 4110:
            case 4128:
            case 4129:
            case 4130:
            case 4131:
            case 4132:
            case 4133:
            case 4134:
            case 8203:
              AL.setSourceParam("alSourcef", sourceId, param, value);
              break;
            default:
              AL.setSourceParam("alSourcef", sourceId, param, null);
              break;
          }
        };
        _alSourcef.sig = "viif";
        function _alSourcefv(sourceId, param, pValues) {
          pValues >>>= 0;
          if (!AL.currentCtx) {
            return;
          }
          if (!pValues) {
            AL.currentCtx.err = 40963;
            return;
          }
          switch (param) {
            case 4097:
            case 4098:
            case 4099:
            case 4106:
            case 4109:
            case 4110:
            case 4128:
            case 4129:
            case 4130:
            case 4131:
            case 4132:
            case 4133:
            case 4134:
            case 8203:
              var val = HEAPF32[pValues >>> 2 >>> 0];
              AL.setSourceParam("alSourcefv", sourceId, param, val);
              break;
            case 4100:
            case 4101:
            case 4102:
              AL.paramArray[0] = HEAPF32[pValues >>> 2 >>> 0];
              AL.paramArray[1] = HEAPF32[pValues + 4 >>> 2 >>> 0];
              AL.paramArray[2] = HEAPF32[pValues + 8 >>> 2 >>> 0];
              AL.setSourceParam("alSourcefv", sourceId, param, AL.paramArray);
              break;
            default:
              AL.setSourceParam("alSourcefv", sourceId, param, null);
              break;
          }
        }
        _alSourcefv.sig = "viip";
        function _alSourceiv(sourceId, param, pValues) {
          pValues >>>= 0;
          if (!AL.currentCtx) {
            return;
          }
          if (!pValues) {
            AL.currentCtx.err = 40963;
            return;
          }
          switch (param) {
            case 514:
            case 4097:
            case 4098:
            case 4103:
            case 4105:
            case 4128:
            case 4129:
            case 4131:
            case 4132:
            case 4133:
            case 4134:
            case 4628:
            case 8201:
            case 8202:
            case 53248:
              var val = HEAP32[pValues >>> 2 >>> 0];
              AL.setSourceParam("alSourceiv", sourceId, param, val);
              break;
            case 4100:
            case 4101:
            case 4102:
              AL.paramArray[0] = HEAP32[pValues >>> 2 >>> 0];
              AL.paramArray[1] = HEAP32[pValues + 4 >>> 2 >>> 0];
              AL.paramArray[2] = HEAP32[pValues + 8 >>> 2 >>> 0];
              AL.setSourceParam("alSourceiv", sourceId, param, AL.paramArray);
              break;
            default:
              AL.setSourceParam("alSourceiv", sourceId, param, null);
              break;
          }
        }
        _alSourceiv.sig = "viip";
        var _alSpeedOfSound = (value) => {
          AL.setGlobalParam("alSpeedOfSound", 49155, value);
        };
        _alSpeedOfSound.sig = "vf";
        var _alcCaptureCloseDevice = function(deviceId) {
          var _a, _b, _c, _d;
          deviceId >>>= 0;
          var c = AL.requireValidCaptureDevice(deviceId, "alcCaptureCloseDevice");
          if (!c)
            return false;
          delete AL.captures[deviceId];
          AL.freeIds.push(deviceId);
          (_a = c.mediaStreamSourceNode) == null ? void 0 : _a.disconnect();
          (_b = c.mergerNode) == null ? void 0 : _b.disconnect();
          (_c = c.splitterNode) == null ? void 0 : _c.disconnect();
          (_d = c.scriptProcessorNode) == null ? void 0 : _d.disconnect();
          if (c.mediaStream) {
            c.mediaStream.getTracks().forEach((track) => track.stop());
          }
          delete c.buffers;
          c.capturedFrameCount = 0;
          c.isCapturing = false;
          return true;
        };
        _alcCaptureCloseDevice.sig = "ip";
        var listenOnce = (object, event2, func2) => {
          object.addEventListener(event2, func2, {
            "once": true
          });
        };
        var autoResumeAudioContext = (ctx, elements) => {
          if (!elements) {
            elements = [document, document.getElementById("canvas")];
          }
          ["keydown", "mousedown", "touchstart"].forEach((event2) => {
            elements.forEach((element) => {
              if (element) {
                listenOnce(element, event2, () => {
                  if (ctx.state === "suspended")
                    ctx.resume();
                });
              }
            });
          });
        };
        function _alcCaptureOpenDevice(pDeviceName, requestedSampleRate, format, bufferFrameCapacity) {
          var _a;
          pDeviceName >>>= 0;
          var resolvedDeviceName = AL.CAPTURE_DEVICE_NAME;
          if (pDeviceName !== 0) {
            resolvedDeviceName = UTF8ToString(pDeviceName);
            if (resolvedDeviceName !== AL.CAPTURE_DEVICE_NAME) {
              AL.alcErr = 40965;
              return 0;
            }
          }
          if (bufferFrameCapacity < 0) {
            AL.alcErr = 40964;
            return 0;
          }
          navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;
          var has_getUserMedia = navigator.getUserMedia || navigator.mediaDevices && navigator.mediaDevices.getUserMedia;
          if (!has_getUserMedia) {
            AL.alcErr = 40965;
            return 0;
          }
          var AudioContext2 = window.AudioContext || window.webkitAudioContext;
          if (!AL.sharedCaptureAudioCtx) {
            try {
              AL.sharedCaptureAudioCtx = new AudioContext2();
            } catch (e) {
              AL.alcErr = 40965;
              return 0;
            }
          }
          autoResumeAudioContext(AL.sharedCaptureAudioCtx);
          var outputChannelCount;
          switch (format) {
            case 65552:
            case 4353:
            case 4352:
              outputChannelCount = 1;
              break;
            case 65553:
            case 4355:
            case 4354:
              outputChannelCount = 2;
              break;
            default:
              AL.alcErr = 40964;
              return 0;
          }
          function newF32Array(cap) {
            return new Float32Array(cap);
          }
          function newI16Array(cap) {
            return new Int16Array(cap);
          }
          function newU8Array(cap) {
            return new Uint8Array(cap);
          }
          var requestedSampleType;
          var newSampleArray;
          switch (format) {
            case 65552:
            case 65553:
              requestedSampleType = "f32";
              newSampleArray = newF32Array;
              break;
            case 4353:
            case 4355:
              requestedSampleType = "i16";
              newSampleArray = newI16Array;
              break;
            case 4352:
            case 4354:
              requestedSampleType = "u8";
              newSampleArray = newU8Array;
              break;
          }
          var buffers = [];
          try {
            for (var chan = 0; chan < outputChannelCount; ++chan) {
              buffers[chan] = newSampleArray(bufferFrameCapacity);
            }
          } catch (e) {
            AL.alcErr = 40965;
            return 0;
          }
          var newCapture = {
            audioCtx: AL.sharedCaptureAudioCtx,
            deviceName: resolvedDeviceName,
            requestedSampleRate,
            requestedSampleType,
            outputChannelCount,
            inputChannelCount: null,
            mediaStreamError: null,
            mediaStreamSourceNode: null,
            mediaStream: null,
            mergerNode: null,
            splitterNode: null,
            scriptProcessorNode: null,
            isCapturing: false,
            buffers,
            get bufferFrameCapacity() {
              return buffers[0].length;
            },
            capturePlayhead: 0,
            captureReadhead: 0,
            capturedFrameCount: 0
          };
          var onError = (mediaStreamError) => {
            newCapture.mediaStreamError = mediaStreamError;
          };
          var onSuccess = (mediaStream) => {
            newCapture.mediaStreamSourceNode = newCapture.audioCtx.createMediaStreamSource(mediaStream);
            newCapture.mediaStream = mediaStream;
            var inputChannelCount = 1;
            switch (newCapture.mediaStreamSourceNode.channelCountMode) {
              case "max":
                inputChannelCount = outputChannelCount;
                break;
              case "clamped-max":
                inputChannelCount = Math.min(outputChannelCount, newCapture.mediaStreamSourceNode.channelCount);
                break;
              case "explicit":
                inputChannelCount = newCapture.mediaStreamSourceNode.channelCount;
                break;
            }
            newCapture.inputChannelCount = inputChannelCount;
            var processorFrameCount = 512;
            newCapture.scriptProcessorNode = newCapture.audioCtx.createScriptProcessor(processorFrameCount, inputChannelCount, outputChannelCount);
            if (inputChannelCount > outputChannelCount) {
              newCapture.mergerNode = newCapture.audioCtx.createChannelMerger(inputChannelCount);
              newCapture.mediaStreamSourceNode.connect(newCapture.mergerNode);
              newCapture.mergerNode.connect(newCapture.scriptProcessorNode);
            } else if (inputChannelCount < outputChannelCount) {
              newCapture.splitterNode = newCapture.audioCtx.createChannelSplitter(outputChannelCount);
              newCapture.mediaStreamSourceNode.connect(newCapture.splitterNode);
              newCapture.splitterNode.connect(newCapture.scriptProcessorNode);
            } else {
              newCapture.mediaStreamSourceNode.connect(newCapture.scriptProcessorNode);
            }
            newCapture.scriptProcessorNode.connect(newCapture.audioCtx.destination);
            newCapture.scriptProcessorNode.onaudioprocess = (audioProcessingEvent) => {
              if (!newCapture.isCapturing) {
                return;
              }
              var c = newCapture;
              var srcBuf = audioProcessingEvent.inputBuffer;
              switch (format) {
                case 65552:
                  var channel0 = srcBuf.getChannelData(0);
                  for (var i2 = 0; i2 < srcBuf.length; ++i2) {
                    var wi = (c.capturePlayhead + i2) % c.bufferFrameCapacity;
                    c.buffers[0][wi] = channel0[i2];
                  }
                  break;
                case 65553:
                  var channel0 = srcBuf.getChannelData(0);
                  var channel1 = srcBuf.getChannelData(1);
                  for (var i2 = 0; i2 < srcBuf.length; ++i2) {
                    var wi = (c.capturePlayhead + i2) % c.bufferFrameCapacity;
                    c.buffers[0][wi] = channel0[i2];
                    c.buffers[1][wi] = channel1[i2];
                  }
                  break;
                case 4353:
                  var channel0 = srcBuf.getChannelData(0);
                  for (var i2 = 0; i2 < srcBuf.length; ++i2) {
                    var wi = (c.capturePlayhead + i2) % c.bufferFrameCapacity;
                    c.buffers[0][wi] = channel0[i2] * 32767;
                  }
                  break;
                case 4355:
                  var channel0 = srcBuf.getChannelData(0);
                  var channel1 = srcBuf.getChannelData(1);
                  for (var i2 = 0; i2 < srcBuf.length; ++i2) {
                    var wi = (c.capturePlayhead + i2) % c.bufferFrameCapacity;
                    c.buffers[0][wi] = channel0[i2] * 32767;
                    c.buffers[1][wi] = channel1[i2] * 32767;
                  }
                  break;
                case 4352:
                  var channel0 = srcBuf.getChannelData(0);
                  for (var i2 = 0; i2 < srcBuf.length; ++i2) {
                    var wi = (c.capturePlayhead + i2) % c.bufferFrameCapacity;
                    c.buffers[0][wi] = (channel0[i2] + 1) * 127;
                  }
                  break;
                case 4354:
                  var channel0 = srcBuf.getChannelData(0);
                  var channel1 = srcBuf.getChannelData(1);
                  for (var i2 = 0; i2 < srcBuf.length; ++i2) {
                    var wi = (c.capturePlayhead + i2) % c.bufferFrameCapacity;
                    c.buffers[0][wi] = (channel0[i2] + 1) * 127;
                    c.buffers[1][wi] = (channel1[i2] + 1) * 127;
                  }
                  break;
              }
              c.capturePlayhead += srcBuf.length;
              c.capturePlayhead %= c.bufferFrameCapacity;
              c.capturedFrameCount += srcBuf.length;
              c.capturedFrameCount = Math.min(c.capturedFrameCount, c.bufferFrameCapacity);
            };
          };
          if ((_a = navigator.mediaDevices) == null ? void 0 : _a.getUserMedia) {
            navigator.mediaDevices.getUserMedia({
              audio: true
            }).then(onSuccess).catch(onError);
          } else {
            navigator.getUserMedia({
              audio: true
            }, onSuccess, onError);
          }
          var id = AL.newId();
          AL.captures[id] = newCapture;
          return id;
        }
        _alcCaptureOpenDevice.sig = "ppiii";
        function _alcCaptureSamples(deviceId, pFrames, requestedFrameCount) {
          deviceId >>>= 0;
          pFrames >>>= 0;
          var c = AL.requireValidCaptureDevice(deviceId, "alcCaptureSamples");
          if (!c)
            return;
          var dstfreq = c.requestedSampleRate;
          var srcfreq = c.audioCtx.sampleRate;
          var fratio = srcfreq / dstfreq;
          if (requestedFrameCount < 0 || requestedFrameCount > c.capturedFrameCount / fratio) {
            AL.alcErr = 40964;
            return;
          }
          function setF32Sample(i3, sample) {
            HEAPF32[pFrames + 4 * i3 >>> 2 >>> 0] = sample;
          }
          function setI16Sample(i3, sample) {
            HEAP16[pFrames + 2 * i3 >>> 1 >>> 0] = sample;
          }
          function setU8Sample(i3, sample) {
            HEAP8[pFrames + i3 >>> 0 >>> 0] = sample;
          }
          var setSample;
          switch (c.requestedSampleType) {
            case "f32":
              setSample = setF32Sample;
              break;
            case "i16":
              setSample = setI16Sample;
              break;
            case "u8":
              setSample = setU8Sample;
              break;
            default:
              return;
          }
          if (Math.floor(fratio) == fratio) {
            for (var i2 = 0, frame_i = 0; frame_i < requestedFrameCount; ++frame_i) {
              for (var chan = 0; chan < c.buffers.length; ++chan, ++i2) {
                setSample(i2, c.buffers[chan][c.captureReadhead]);
              }
              c.captureReadhead = (fratio + c.captureReadhead) % c.bufferFrameCapacity;
            }
          } else {
            for (var i2 = 0, frame_i = 0; frame_i < requestedFrameCount; ++frame_i) {
              var lefti = Math.floor(c.captureReadhead);
              var righti = Math.ceil(c.captureReadhead);
              var d = c.captureReadhead - lefti;
              for (var chan = 0; chan < c.buffers.length; ++chan, ++i2) {
                var lefts = c.buffers[chan][lefti];
                var rights = c.buffers[chan][righti];
                setSample(i2, (1 - d) * lefts + d * rights);
              }
              c.captureReadhead = (c.captureReadhead + fratio) % c.bufferFrameCapacity;
            }
          }
          c.capturedFrameCount = 0;
        }
        _alcCaptureSamples.sig = "vppi";
        function _alcCaptureStart(deviceId) {
          deviceId >>>= 0;
          var c = AL.requireValidCaptureDevice(deviceId, "alcCaptureStart");
          if (!c)
            return;
          if (c.isCapturing) {
            return;
          }
          c.isCapturing = true;
          c.capturedFrameCount = 0;
          c.capturePlayhead = 0;
        }
        _alcCaptureStart.sig = "vp";
        function _alcCaptureStop(deviceId) {
          deviceId >>>= 0;
          var c = AL.requireValidCaptureDevice(deviceId, "alcCaptureStop");
          if (!c)
            return;
          c.isCapturing = false;
        }
        _alcCaptureStop.sig = "vp";
        function _alcCloseDevice(deviceId) {
          deviceId >>>= 0;
          if (!(deviceId in AL.deviceRefCounts) || AL.deviceRefCounts[deviceId] > 0) {
            return 0;
          }
          delete AL.deviceRefCounts[deviceId];
          AL.freeIds.push(deviceId);
          return 1;
        }
        _alcCloseDevice.sig = "ip";
        function _alcCreateContext(deviceId, pAttrList) {
          deviceId >>>= 0;
          pAttrList >>>= 0;
          if (!(deviceId in AL.deviceRefCounts)) {
            AL.alcErr = 40961;
            return 0;
          }
          var options = null;
          var attrs = [];
          var hrtf = null;
          pAttrList >>= 2;
          if (pAttrList) {
            var attr = 0;
            var val = 0;
            while (true) {
              attr = HEAP32[pAttrList++ >>> 0];
              attrs.push(attr);
              if (attr === 0) {
                break;
              }
              val = HEAP32[pAttrList++ >>> 0];
              attrs.push(val);
              switch (attr) {
                case 4103:
                  if (!options) {
                    options = {};
                  }
                  options.sampleRate = val;
                  break;
                case 4112:
                case 4113:
                  break;
                case 6546:
                  switch (val) {
                    case 0:
                      hrtf = false;
                      break;
                    case 1:
                      hrtf = true;
                      break;
                    case 2:
                      break;
                    default:
                      AL.alcErr = 40964;
                      return 0;
                  }
                  break;
                case 6550:
                  if (val !== 0) {
                    AL.alcErr = 40964;
                    return 0;
                  }
                  break;
                default:
                  AL.alcErr = 40964;
                  return 0;
              }
            }
          }
          var AudioContext2 = window.AudioContext || window.webkitAudioContext;
          var ac = null;
          try {
            if (options) {
              ac = new AudioContext2(options);
            } else {
              ac = new AudioContext2();
            }
          } catch (e) {
            if (e.name === "NotSupportedError") {
              AL.alcErr = 40964;
            } else {
              AL.alcErr = 40961;
            }
            return 0;
          }
          autoResumeAudioContext(ac);
          if (typeof ac.createGain == "undefined") {
            ac.createGain = ac.createGainNode;
          }
          var gain = ac.createGain();
          gain.connect(ac.destination);
          var ctx = {
            deviceId,
            id: AL.newId(),
            attrs,
            audioCtx: ac,
            listener: {
              position: [0, 0, 0],
              velocity: [0, 0, 0],
              direction: [0, 0, 0],
              up: [0, 0, 0]
            },
            sources: [],
            interval: setInterval(() => AL.scheduleContextAudio(ctx), AL.QUEUE_INTERVAL),
            gain,
            distanceModel: 53250,
            speedOfSound: 343.3,
            dopplerFactor: 1,
            sourceDistanceModel: false,
            hrtf: hrtf || false,
            _err: 0,
            get err() {
              return this._err;
            },
            set err(val2) {
              if (this._err === 0 || val2 === 0) {
                this._err = val2;
              }
            }
          };
          AL.deviceRefCounts[deviceId]++;
          AL.contexts[ctx.id] = ctx;
          if (hrtf !== null) {
            for (var ctxId in AL.contexts) {
              var c = AL.contexts[ctxId];
              if (c.deviceId === deviceId) {
                c.hrtf = hrtf;
                AL.updateContextGlobal(c);
              }
            }
          }
          return ctx.id;
        }
        _alcCreateContext.sig = "ppp";
        function _alcDestroyContext(contextId) {
          contextId >>>= 0;
          var ctx = AL.contexts[contextId];
          if (AL.currentCtx === ctx) {
            AL.alcErr = 40962;
            return;
          }
          if (AL.contexts[contextId].interval) {
            clearInterval(AL.contexts[contextId].interval);
          }
          AL.deviceRefCounts[ctx.deviceId]--;
          delete AL.contexts[contextId];
          AL.freeIds.push(contextId);
        }
        _alcDestroyContext.sig = "vp";
        function _alcGetContextsDevice(contextId) {
          contextId >>>= 0;
          if (contextId in AL.contexts) {
            return AL.contexts[contextId].deviceId;
          }
          return 0;
        }
        _alcGetContextsDevice.sig = "pp";
        function _alcGetCurrentContext() {
          if (AL.currentCtx !== null) {
            return AL.currentCtx.id;
          }
          return 0;
        }
        _alcGetCurrentContext.sig = "p";
        function _alcGetEnumValue(deviceId, pEnumName) {
          deviceId >>>= 0;
          pEnumName >>>= 0;
          if (deviceId !== 0 && !(deviceId in AL.deviceRefCounts)) {
            return 0;
          } else if (!pEnumName) {
            AL.alcErr = 40964;
            return 0;
          }
          var name2 = UTF8ToString(pEnumName);
          switch (name2) {
            case "ALC_NO_ERROR":
              return 0;
            case "ALC_INVALID_DEVICE":
              return 40961;
            case "ALC_INVALID_CONTEXT":
              return 40962;
            case "ALC_INVALID_ENUM":
              return 40963;
            case "ALC_INVALID_VALUE":
              return 40964;
            case "ALC_OUT_OF_MEMORY":
              return 40965;
            case "ALC_MAJOR_VERSION":
              return 4096;
            case "ALC_MINOR_VERSION":
              return 4097;
            case "ALC_ATTRIBUTES_SIZE":
              return 4098;
            case "ALC_ALL_ATTRIBUTES":
              return 4099;
            case "ALC_DEFAULT_DEVICE_SPECIFIER":
              return 4100;
            case "ALC_DEVICE_SPECIFIER":
              return 4101;
            case "ALC_EXTENSIONS":
              return 4102;
            case "ALC_FREQUENCY":
              return 4103;
            case "ALC_REFRESH":
              return 4104;
            case "ALC_SYNC":
              return 4105;
            case "ALC_MONO_SOURCES":
              return 4112;
            case "ALC_STEREO_SOURCES":
              return 4113;
            case "ALC_CAPTURE_DEVICE_SPECIFIER":
              return 784;
            case "ALC_CAPTURE_DEFAULT_DEVICE_SPECIFIER":
              return 785;
            case "ALC_CAPTURE_SAMPLES":
              return 786;
            case "ALC_HRTF_SOFT":
              return 6546;
            case "ALC_HRTF_ID_SOFT":
              return 6550;
            case "ALC_DONT_CARE_SOFT":
              return 2;
            case "ALC_HRTF_STATUS_SOFT":
              return 6547;
            case "ALC_NUM_HRTF_SPECIFIERS_SOFT":
              return 6548;
            case "ALC_HRTF_SPECIFIER_SOFT":
              return 6549;
            case "ALC_HRTF_DISABLED_SOFT":
              return 0;
            case "ALC_HRTF_ENABLED_SOFT":
              return 1;
            case "ALC_HRTF_DENIED_SOFT":
              return 2;
            case "ALC_HRTF_REQUIRED_SOFT":
              return 3;
            case "ALC_HRTF_HEADPHONES_DETECTED_SOFT":
              return 4;
            case "ALC_HRTF_UNSUPPORTED_FORMAT_SOFT":
              return 5;
            default:
              AL.alcErr = 40964;
              return 0;
          }
        }
        _alcGetEnumValue.sig = "ipp";
        function _alcGetError(deviceId) {
          deviceId >>>= 0;
          var err2 = AL.alcErr;
          AL.alcErr = 0;
          return err2;
        }
        _alcGetError.sig = "ip";
        function _alcGetIntegerv(deviceId, param, size, pValues) {
          deviceId >>>= 0;
          pValues >>>= 0;
          if (size === 0 || !pValues) {
            return;
          }
          switch (param) {
            case 4096:
              HEAP32[pValues >>> 2 >>> 0] = 1;
              break;
            case 4097:
              HEAP32[pValues >>> 2 >>> 0] = 1;
              break;
            case 4098:
              if (!(deviceId in AL.deviceRefCounts)) {
                AL.alcErr = 40961;
                return;
              }
              if (!AL.currentCtx) {
                AL.alcErr = 40962;
                return;
              }
              HEAP32[pValues >>> 2 >>> 0] = AL.currentCtx.attrs.length;
              break;
            case 4099:
              if (!(deviceId in AL.deviceRefCounts)) {
                AL.alcErr = 40961;
                return;
              }
              if (!AL.currentCtx) {
                AL.alcErr = 40962;
                return;
              }
              for (var i2 = 0; i2 < AL.currentCtx.attrs.length; i2++) {
                HEAP32[pValues + i2 * 4 >>> 2 >>> 0] = AL.currentCtx.attrs[i2];
              }
              break;
            case 4103:
              if (!(deviceId in AL.deviceRefCounts)) {
                AL.alcErr = 40961;
                return;
              }
              if (!AL.currentCtx) {
                AL.alcErr = 40962;
                return;
              }
              HEAP32[pValues >>> 2 >>> 0] = AL.currentCtx.audioCtx.sampleRate;
              break;
            case 4112:
            case 4113:
              if (!(deviceId in AL.deviceRefCounts)) {
                AL.alcErr = 40961;
                return;
              }
              if (!AL.currentCtx) {
                AL.alcErr = 40962;
                return;
              }
              HEAP32[pValues >>> 2 >>> 0] = 2147483647;
              break;
            case 6546:
            case 6547:
              if (!(deviceId in AL.deviceRefCounts)) {
                AL.alcErr = 40961;
                return;
              }
              var hrtfStatus = 0;
              for (var ctxId in AL.contexts) {
                var ctx = AL.contexts[ctxId];
                if (ctx.deviceId === deviceId) {
                  hrtfStatus = ctx.hrtf ? 1 : 0;
                }
              }
              HEAP32[pValues >>> 2 >>> 0] = hrtfStatus;
              break;
            case 6548:
              if (!(deviceId in AL.deviceRefCounts)) {
                AL.alcErr = 40961;
                return;
              }
              HEAP32[pValues >>> 2 >>> 0] = 1;
              break;
            case 131075:
              if (!(deviceId in AL.deviceRefCounts)) {
                AL.alcErr = 40961;
                return;
              }
              if (!AL.currentCtx) {
                AL.alcErr = 40962;
                return;
              }
              HEAP32[pValues >>> 2 >>> 0] = 1;
            case 786:
              var c = AL.requireValidCaptureDevice(deviceId, "alcGetIntegerv");
              if (!c) {
                return;
              }
              var n = c.capturedFrameCount;
              var dstfreq = c.requestedSampleRate;
              var srcfreq = c.audioCtx.sampleRate;
              var nsamples = Math.floor(n * (dstfreq / srcfreq));
              HEAP32[pValues >>> 2 >>> 0] = nsamples;
              break;
            default:
              AL.alcErr = 40963;
              return;
          }
        }
        _alcGetIntegerv.sig = "vpiip";
        function _alcGetString(deviceId, param) {
          deviceId >>>= 0;
          if (AL.alcStringCache[param]) {
            return AL.alcStringCache[param];
          }
          var ret;
          switch (param) {
            case 0:
              ret = "No Error";
              break;
            case 40961:
              ret = "Invalid Device";
              break;
            case 40962:
              ret = "Invalid Context";
              break;
            case 40963:
              ret = "Invalid Enum";
              break;
            case 40964:
              ret = "Invalid Value";
              break;
            case 40965:
              ret = "Out of Memory";
              break;
            case 4100:
              if (typeof AudioContext != "undefined" || typeof webkitAudioContext != "undefined") {
                ret = AL.DEVICE_NAME;
              } else {
                return 0;
              }
              break;
            case 4101:
              if (typeof AudioContext != "undefined" || typeof webkitAudioContext != "undefined") {
                ret = AL.DEVICE_NAME.concat("\0");
              } else {
                ret = "\0";
              }
              break;
            case 785:
              ret = AL.CAPTURE_DEVICE_NAME;
              break;
            case 784:
              if (deviceId === 0)
                ret = AL.CAPTURE_DEVICE_NAME.concat("\0");
              else {
                var c = AL.requireValidCaptureDevice(deviceId, "alcGetString");
                if (!c) {
                  return 0;
                }
                ret = c.deviceName;
              }
              break;
            case 4102:
              if (!deviceId) {
                AL.alcErr = 40961;
                return 0;
              }
              ret = "";
              for (var ext in AL.ALC_EXTENSIONS) {
                ret = ret.concat(ext);
                ret = ret.concat(" ");
              }
              ret = ret.trim();
              break;
            default:
              AL.alcErr = 40963;
              return 0;
          }
          ret = stringToNewUTF8(ret);
          AL.alcStringCache[param] = ret;
          return ret;
        }
        _alcGetString.sig = "ppi";
        function _alcIsExtensionPresent(deviceId, pExtName) {
          deviceId >>>= 0;
          pExtName >>>= 0;
          var name2 = UTF8ToString(pExtName);
          return AL.ALC_EXTENSIONS[name2] ? 1 : 0;
        }
        _alcIsExtensionPresent.sig = "ipp";
        function _alcMakeContextCurrent(contextId) {
          contextId >>>= 0;
          if (contextId === 0) {
            AL.currentCtx = null;
          } else {
            AL.currentCtx = AL.contexts[contextId];
          }
          return 1;
        }
        _alcMakeContextCurrent.sig = "ip";
        function _alcOpenDevice(pDeviceName) {
          pDeviceName >>>= 0;
          if (pDeviceName) {
            var name2 = UTF8ToString(pDeviceName);
            if (name2 !== AL.DEVICE_NAME) {
              return 0;
            }
          }
          if (typeof AudioContext != "undefined" || typeof webkitAudioContext != "undefined") {
            var deviceId = AL.newId();
            AL.deviceRefCounts[deviceId] = 0;
            return deviceId;
          }
          return 0;
        }
        _alcOpenDevice.sig = "pp";
        function _alcProcessContext(contextId) {
          contextId >>>= 0;
        }
        _alcProcessContext.sig = "vp";
        function _alcSuspendContext(contextId) {
          contextId >>>= 0;
        }
        _alcSuspendContext.sig = "vp";
        function _duckdb_web_fs_directory_create(path2, pathLen) {
          path2 >>>= 0;
          return globalThis.DUCKDB_RUNTIME.createDirectory(Module, path2, pathLen);
        }
        _duckdb_web_fs_directory_create.sig = "vpi";
        function _duckdb_web_fs_directory_exists(path2, pathLen) {
          path2 >>>= 0;
          return globalThis.DUCKDB_RUNTIME.checkDirectory(Module, path2, pathLen);
        }
        _duckdb_web_fs_directory_exists.sig = "ipi";
        function _duckdb_web_fs_directory_list_files(path2, pathLen) {
          path2 >>>= 0;
          return globalThis.DUCKDB_RUNTIME.listDirectoryEntries(Module, path2, pathLen);
        }
        _duckdb_web_fs_directory_list_files.sig = "ipi";
        function _duckdb_web_fs_directory_remove(path2, pathLen) {
          path2 >>>= 0;
          return globalThis.DUCKDB_RUNTIME.removeDirectory(Module, path2, pathLen);
        }
        _duckdb_web_fs_directory_remove.sig = "vpi";
        function _duckdb_web_fs_file_close(fileId) {
          return globalThis.DUCKDB_RUNTIME.closeFile(Module, fileId);
        }
        _duckdb_web_fs_file_close.sig = "vi";
        function _duckdb_web_fs_file_exists(path2, pathLen) {
          path2 >>>= 0;
          return globalThis.DUCKDB_RUNTIME.checkFile(Module, path2, pathLen);
        }
        _duckdb_web_fs_file_exists.sig = "ipi";
        function _duckdb_web_fs_file_get_last_modified_time(fileId) {
          return globalThis.DUCKDB_RUNTIME.getLastFileModificationTime(Module, fileId);
        }
        _duckdb_web_fs_file_get_last_modified_time.sig = "ii";
        function _duckdb_web_fs_file_move(from, fromLen, to, toLen) {
          from >>>= 0;
          to >>>= 0;
          return globalThis.DUCKDB_RUNTIME.moveFile(Module, from, fromLen, to, toLen);
        }
        _duckdb_web_fs_file_move.sig = "vpipi";
        function _duckdb_web_fs_file_open(fileId, flags2) {
          return globalThis.DUCKDB_RUNTIME.openFile(Module, fileId, flags2);
        }
        _duckdb_web_fs_file_open.sig = "pii";
        function _duckdb_web_fs_file_read(fileId, buf, size, location) {
          buf >>>= 0;
          return globalThis.DUCKDB_RUNTIME.readFile(Module, fileId, buf, size, location);
        }
        _duckdb_web_fs_file_read.sig = "iipid";
        function _duckdb_web_fs_file_truncate(fileId, newSize) {
          return globalThis.DUCKDB_RUNTIME.truncateFile(Module, fileId, newSize);
        }
        _duckdb_web_fs_file_truncate.sig = "vid";
        function _duckdb_web_fs_file_write(fileId, buf, size, location) {
          buf >>>= 0;
          return globalThis.DUCKDB_RUNTIME.writeFile(Module, fileId, buf, size, location);
        }
        _duckdb_web_fs_file_write.sig = "iipid";
        function _duckdb_web_fs_get_default_data_protocol(Module2) {
          return globalThis.DUCKDB_RUNTIME.getDefaultDataProtocol(Module2);
        }
        _duckdb_web_fs_get_default_data_protocol.sig = "i";
        function _duckdb_web_fs_glob(path2, pathLen) {
          path2 >>>= 0;
          return globalThis.DUCKDB_RUNTIME.glob(Module, path2, pathLen);
        }
        _duckdb_web_fs_glob.sig = "vpi";
        function _duckdb_web_test_platform_feature(feature) {
          return globalThis.DUCKDB_RUNTIME.testPlatformFeature(Module, feature);
        }
        _duckdb_web_test_platform_feature.sig = "ii";
        function _duckdb_web_udf_scalar_call(funcId, descPtr, descSize, ptrsPtr, ptrsSize, response) {
          funcId >>>= 0;
          descSize >>>= 0;
          ptrsSize >>>= 0;
          return globalThis.DUCKDB_RUNTIME.callScalarUDF(Module, funcId, descPtr, descSize, ptrsPtr, ptrsSize, response);
        }
        _duckdb_web_udf_scalar_call.sig = "vpipipi";
        var _emscripten_alcDevicePauseSOFT = (deviceId) => {
          if (!(deviceId in AL.deviceRefCounts)) {
            AL.alcErr = 40961;
            return;
          }
          if (AL.paused) {
            return;
          }
          AL.paused = true;
          for (var ctxId in AL.contexts) {
            var ctx = AL.contexts[ctxId];
            if (ctx.deviceId !== deviceId) {
              continue;
            }
            ctx.audioCtx.suspend();
            clearInterval(ctx.interval);
            ctx.interval = null;
          }
        };
        _emscripten_alcDevicePauseSOFT.sig = "vi";
        var _emscripten_alcDeviceResumeSOFT = (deviceId) => {
          if (!(deviceId in AL.deviceRefCounts)) {
            AL.alcErr = 40961;
            return;
          }
          if (!AL.paused) {
            return;
          }
          AL.paused = false;
          for (var ctxId in AL.contexts) {
            var ctx = AL.contexts[ctxId];
            if (ctx.deviceId !== deviceId) {
              continue;
            }
            ctx.interval = setInterval(() => AL.scheduleContextAudio(ctx), AL.QUEUE_INTERVAL);
            ctx.audioCtx.resume();
          }
        };
        _emscripten_alcDeviceResumeSOFT.sig = "vi";
        var _emscripten_alcGetStringiSOFT = (deviceId, param, index) => {
          if (!(deviceId in AL.deviceRefCounts)) {
            AL.alcErr = 40961;
            return 0;
          }
          if (AL.alcStringCache[param]) {
            return AL.alcStringCache[param];
          }
          var ret;
          switch (param) {
            case 6549:
              if (index === 0) {
                ret = "Web Audio HRTF";
              } else {
                AL.alcErr = 40964;
                return 0;
              }
              break;
            default:
              if (index !== 0) {
                AL.alcErr = 40963;
                return 0;
              }
              return _alcGetString(deviceId, param);
          }
          ret = stringToNewUTF8(ret);
          AL.alcStringCache[param] = ret;
          return ret;
        };
        _emscripten_alcGetStringiSOFT.sig = "iiii";
        var _emscripten_alcResetDeviceSOFT = (deviceId, pAttrList) => {
          if (!(deviceId in AL.deviceRefCounts)) {
            AL.alcErr = 40961;
            return 0;
          }
          var hrtf = null;
          pAttrList >>= 2;
          if (pAttrList) {
            var attr = 0;
            var val = 0;
            while (true) {
              attr = HEAP32[pAttrList++ >>> 0];
              if (attr === 0) {
                break;
              }
              val = HEAP32[pAttrList++ >>> 0];
              switch (attr) {
                case 6546:
                  if (val === 1) {
                    hrtf = true;
                  } else if (val === 0) {
                    hrtf = false;
                  }
                  break;
              }
            }
          }
          if (hrtf !== null) {
            for (var ctxId in AL.contexts) {
              var ctx = AL.contexts[ctxId];
              if (ctx.deviceId === deviceId) {
                ctx.hrtf = hrtf;
                AL.updateContextGlobal(ctx);
              }
            }
          }
          return 1;
        };
        _emscripten_alcResetDeviceSOFT.sig = "iii";
        var readEmAsmArgsArray = [];
        var readEmAsmArgs = (sigPtr, buf) => {
          readEmAsmArgsArray.length = 0;
          var ch;
          while (ch = HEAPU8[sigPtr++ >>> 0]) {
            var wide = ch != 105;
            wide &= ch != 112;
            buf += wide && buf % 8 ? 4 : 0;
            readEmAsmArgsArray.push(ch == 112 ? HEAPU32[buf >>> 2 >>> 0] : ch == 105 ? HEAP32[buf >>> 2 >>> 0] : HEAPF64[buf >>> 3 >>> 0]);
            buf += wide ? 8 : 4;
          }
          return readEmAsmArgsArray;
        };
        var runEmAsmFunction = (code, sigPtr, argbuf) => {
          var args2 = readEmAsmArgs(sigPtr, argbuf);
          return ASM_CONSTS[code].apply(null, args2);
        };
        function _emscripten_asm_const_int(code, sigPtr, argbuf) {
          code >>>= 0;
          sigPtr >>>= 0;
          argbuf >>>= 0;
          return runEmAsmFunction(code, sigPtr, argbuf);
        }
        _emscripten_asm_const_int.sig = "ippp";
        function _emscripten_asm_const_ptr(code, sigPtr, argbuf) {
          code >>>= 0;
          sigPtr >>>= 0;
          argbuf >>>= 0;
          return runEmAsmFunction(code, sigPtr, argbuf);
        }
        _emscripten_asm_const_ptr.sig = "pppp";
        function _emscripten_console_error(str) {
          str >>>= 0;
          console.error(UTF8ToString(str));
        }
        _emscripten_console_error.sig = "vp";
        function _emscripten_console_log(str) {
          str >>>= 0;
          console.log(UTF8ToString(str));
        }
        _emscripten_console_log.sig = "vp";
        function _emscripten_console_warn(str) {
          str >>>= 0;
          console.warn(UTF8ToString(str));
        }
        _emscripten_console_warn.sig = "vp";
        var _emscripten_date_now = () => Date.now();
        _emscripten_date_now.sig = "d";
        function _emscripten_err(str) {
          str >>>= 0;
          return err(UTF8ToString(str));
        }
        _emscripten_err.sig = "vp";
        var getHeapMax = () => 4294901760;
        function _emscripten_get_heap_max() {
          return getHeapMax();
        }
        _emscripten_get_heap_max.sig = "p";
        var _emscripten_get_now_res = () => {
          if (ENVIRONMENT_IS_NODE) {
            return 1;
          }
          return 1e3;
        };
        _emscripten_get_now_res.sig = "d";
        var webgl_enable_ANGLE_instanced_arrays = (ctx) => {
          var ext = ctx.getExtension("ANGLE_instanced_arrays");
          if (ext) {
            ctx["vertexAttribDivisor"] = (index, divisor) => ext["vertexAttribDivisorANGLE"](index, divisor);
            ctx["drawArraysInstanced"] = (mode, first, count, primcount) => ext["drawArraysInstancedANGLE"](mode, first, count, primcount);
            ctx["drawElementsInstanced"] = (mode, count, type, indices, primcount) => ext["drawElementsInstancedANGLE"](mode, count, type, indices, primcount);
            return 1;
          }
        };
        var webgl_enable_OES_vertex_array_object = (ctx) => {
          var ext = ctx.getExtension("OES_vertex_array_object");
          if (ext) {
            ctx["createVertexArray"] = () => ext["createVertexArrayOES"]();
            ctx["deleteVertexArray"] = (vao) => ext["deleteVertexArrayOES"](vao);
            ctx["bindVertexArray"] = (vao) => ext["bindVertexArrayOES"](vao);
            ctx["isVertexArray"] = (vao) => ext["isVertexArrayOES"](vao);
            return 1;
          }
        };
        var webgl_enable_WEBGL_draw_buffers = (ctx) => {
          var ext = ctx.getExtension("WEBGL_draw_buffers");
          if (ext) {
            ctx["drawBuffers"] = (n, bufs) => ext["drawBuffersWEBGL"](n, bufs);
            return 1;
          }
        };
        var webgl_enable_WEBGL_multi_draw = (ctx) => !!(ctx.multiDrawWebgl = ctx.getExtension("WEBGL_multi_draw"));
        var getEmscriptenSupportedExtensions = function(ctx) {
          var supportedExtensions = ["ANGLE_instanced_arrays", "EXT_blend_minmax", "EXT_disjoint_timer_query", "EXT_frag_depth", "EXT_shader_texture_lod", "EXT_sRGB", "OES_element_index_uint", "OES_fbo_render_mipmap", "OES_standard_derivatives", "OES_texture_float", "OES_texture_half_float", "OES_texture_half_float_linear", "OES_vertex_array_object", "WEBGL_color_buffer_float", "WEBGL_depth_texture", "WEBGL_draw_buffers", "EXT_color_buffer_half_float", "EXT_float_blend", "EXT_texture_compression_bptc", "EXT_texture_compression_rgtc", "EXT_texture_filter_anisotropic", "KHR_parallel_shader_compile", "OES_texture_float_linear", "WEBGL_compressed_texture_s3tc", "WEBGL_compressed_texture_s3tc_srgb", "WEBGL_debug_renderer_info", "WEBGL_debug_shaders", "WEBGL_lose_context", "WEBGL_multi_draw"];
          return (ctx.getSupportedExtensions() || []).filter((ext) => supportedExtensions.includes(ext));
        };
        var GL = {
          counter: 1,
          buffers: [],
          programs: [],
          framebuffers: [],
          renderbuffers: [],
          textures: [],
          shaders: [],
          vaos: [],
          contexts: [],
          offscreenCanvases: {},
          queries: [],
          stringCache: {},
          unpackAlignment: 4,
          recordError: function recordError(errorCode) {
            if (!GL.lastError) {
              GL.lastError = errorCode;
            }
          },
          getNewId: (table) => {
            var ret = GL.counter++;
            for (var i2 = table.length; i2 < ret; i2++) {
              table[i2] = null;
            }
            return ret;
          },
          getSource: (shader, count, string, length) => {
            var source = "";
            for (var i2 = 0; i2 < count; ++i2) {
              var len2 = length ? HEAP32[length + i2 * 4 >>> 2 >>> 0] : -1;
              source += UTF8ToString(HEAP32[string + i2 * 4 >>> 2 >>> 0], len2 < 0 ? void 0 : len2);
            }
            return source;
          },
          createContext: (canvas, webGLContextAttributes) => {
            if (!canvas.getContextSafariWebGL2Fixed) {
              let fixedGetContext2 = function(ver, attrs) {
                var gl = canvas.getContextSafariWebGL2Fixed(ver, attrs);
                return ver == "webgl" == gl instanceof WebGLRenderingContext ? gl : null;
              };
              var fixedGetContext = fixedGetContext2;
              canvas.getContextSafariWebGL2Fixed = canvas.getContext;
              canvas.getContext = fixedGetContext2;
            }
            var ctx = canvas.getContext("webgl", webGLContextAttributes);
            if (!ctx)
              return 0;
            var handle2 = GL.registerContext(ctx, webGLContextAttributes);
            return handle2;
          },
          registerContext: (ctx, webGLContextAttributes) => {
            var handle2 = GL.getNewId(GL.contexts);
            var context = {
              handle: handle2,
              attributes: webGLContextAttributes,
              version: webGLContextAttributes.majorVersion,
              GLctx: ctx
            };
            if (ctx.canvas)
              ctx.canvas.GLctxObject = context;
            GL.contexts[handle2] = context;
            if (typeof webGLContextAttributes.enableExtensionsByDefault == "undefined" || webGLContextAttributes.enableExtensionsByDefault) {
              GL.initExtensions(context);
            }
            return handle2;
          },
          makeContextCurrent: (contextHandle) => {
            var _a;
            GL.currentContext = GL.contexts[contextHandle];
            Module.ctx = GLctx = (_a = GL.currentContext) == null ? void 0 : _a.GLctx;
            return !(contextHandle && !GLctx);
          },
          getContext: (contextHandle) => GL.contexts[contextHandle],
          deleteContext: (contextHandle) => {
            if (GL.currentContext === GL.contexts[contextHandle]) {
              GL.currentContext = null;
            }
            if (typeof JSEvents == "object") {
              JSEvents.removeAllHandlersOnTarget(GL.contexts[contextHandle].GLctx.canvas);
            }
            if (GL.contexts[contextHandle] && GL.contexts[contextHandle].GLctx.canvas) {
              GL.contexts[contextHandle].GLctx.canvas.GLctxObject = void 0;
            }
            GL.contexts[contextHandle] = null;
          },
          initExtensions: (context) => {
            context || (context = GL.currentContext);
            if (context.initExtensionsDone)
              return;
            context.initExtensionsDone = true;
            var GLctx2 = context.GLctx;
            webgl_enable_ANGLE_instanced_arrays(GLctx2);
            webgl_enable_OES_vertex_array_object(GLctx2);
            webgl_enable_WEBGL_draw_buffers(GLctx2);
            {
              GLctx2.disjointTimerQueryExt = GLctx2.getExtension("EXT_disjoint_timer_query");
            }
            webgl_enable_WEBGL_multi_draw(GLctx2);
            getEmscriptenSupportedExtensions(GLctx2).forEach((ext) => {
              if (!ext.includes("lose_context") && !ext.includes("debug")) {
                GLctx2.getExtension(ext);
              }
            });
          }
        };
        function _glActiveTexture(x0) {
          GLctx.activeTexture(x0);
        }
        _glActiveTexture.sig = "vi";
        var _emscripten_glActiveTexture = _glActiveTexture;
        var _glAttachShader = (program, shader) => {
          GLctx.attachShader(GL.programs[program], GL.shaders[shader]);
        };
        _glAttachShader.sig = "vii";
        var _emscripten_glAttachShader = _glAttachShader;
        var _glBeginQueryEXT = (target, id) => {
          GLctx.disjointTimerQueryExt["beginQueryEXT"](target, GL.queries[id]);
        };
        _glBeginQueryEXT.sig = "vii";
        var _emscripten_glBeginQueryEXT = _glBeginQueryEXT;
        function _glBindAttribLocation(program, index, name2) {
          name2 >>>= 0;
          GLctx.bindAttribLocation(GL.programs[program], index, UTF8ToString(name2));
        }
        _glBindAttribLocation.sig = "viip";
        var _emscripten_glBindAttribLocation = _glBindAttribLocation;
        var _glBindBuffer = (target, buffer) => {
          GLctx.bindBuffer(target, GL.buffers[buffer]);
        };
        _glBindBuffer.sig = "vii";
        var _emscripten_glBindBuffer = _glBindBuffer;
        var _glBindFramebuffer = (target, framebuffer) => {
          GLctx.bindFramebuffer(target, GL.framebuffers[framebuffer]);
        };
        _glBindFramebuffer.sig = "vii";
        var _emscripten_glBindFramebuffer = _glBindFramebuffer;
        var _glBindRenderbuffer = (target, renderbuffer) => {
          GLctx.bindRenderbuffer(target, GL.renderbuffers[renderbuffer]);
        };
        _glBindRenderbuffer.sig = "vii";
        var _emscripten_glBindRenderbuffer = _glBindRenderbuffer;
        var _glBindTexture = (target, texture) => {
          GLctx.bindTexture(target, GL.textures[texture]);
        };
        _glBindTexture.sig = "vii";
        var _emscripten_glBindTexture = _glBindTexture;
        var _glBindVertexArray = (vao) => {
          GLctx.bindVertexArray(GL.vaos[vao]);
        };
        _glBindVertexArray.sig = "vi";
        var _glBindVertexArrayOES = _glBindVertexArray;
        _glBindVertexArrayOES.sig = "vi";
        var _emscripten_glBindVertexArrayOES = _glBindVertexArrayOES;
        function _glBlendColor(x0, x1, x2, x3) {
          GLctx.blendColor(x0, x1, x2, x3);
        }
        _glBlendColor.sig = "vffff";
        var _emscripten_glBlendColor = _glBlendColor;
        function _glBlendEquation(x0) {
          GLctx.blendEquation(x0);
        }
        _glBlendEquation.sig = "vi";
        var _emscripten_glBlendEquation = _glBlendEquation;
        function _glBlendEquationSeparate(x0, x1) {
          GLctx.blendEquationSeparate(x0, x1);
        }
        _glBlendEquationSeparate.sig = "vii";
        var _emscripten_glBlendEquationSeparate = _glBlendEquationSeparate;
        function _glBlendFunc(x0, x1) {
          GLctx.blendFunc(x0, x1);
        }
        _glBlendFunc.sig = "vii";
        var _emscripten_glBlendFunc = _glBlendFunc;
        function _glBlendFuncSeparate(x0, x1, x2, x3) {
          GLctx.blendFuncSeparate(x0, x1, x2, x3);
        }
        _glBlendFuncSeparate.sig = "viiii";
        var _emscripten_glBlendFuncSeparate = _glBlendFuncSeparate;
        function _glBufferData(target, size, data2, usage) {
          size >>>= 0;
          data2 >>>= 0;
          GLctx.bufferData(target, data2 ? HEAPU8.subarray(data2 >>> 0, data2 + size >>> 0) : size, usage);
        }
        _glBufferData.sig = "vippi";
        var _emscripten_glBufferData = _glBufferData;
        function _glBufferSubData(target, offset, size, data2) {
          offset >>>= 0;
          size >>>= 0;
          data2 >>>= 0;
          GLctx.bufferSubData(target, offset, HEAPU8.subarray(data2 >>> 0, data2 + size >>> 0));
        }
        _glBufferSubData.sig = "vippp";
        var _emscripten_glBufferSubData = _glBufferSubData;
        function _glCheckFramebufferStatus(x0) {
          return GLctx.checkFramebufferStatus(x0);
        }
        _glCheckFramebufferStatus.sig = "ii";
        var _emscripten_glCheckFramebufferStatus = _glCheckFramebufferStatus;
        function _glClear(x0) {
          GLctx.clear(x0);
        }
        _glClear.sig = "vi";
        var _emscripten_glClear = _glClear;
        function _glClearColor(x0, x1, x2, x3) {
          GLctx.clearColor(x0, x1, x2, x3);
        }
        _glClearColor.sig = "vffff";
        var _emscripten_glClearColor = _glClearColor;
        function _glClearDepthf(x0) {
          GLctx.clearDepth(x0);
        }
        _glClearDepthf.sig = "vf";
        var _emscripten_glClearDepthf = _glClearDepthf;
        function _glClearStencil(x0) {
          GLctx.clearStencil(x0);
        }
        _glClearStencil.sig = "vi";
        var _emscripten_glClearStencil = _glClearStencil;
        var _glColorMask = (red, green, blue, alpha) => {
          GLctx.colorMask(!!red, !!green, !!blue, !!alpha);
        };
        _glColorMask.sig = "viiii";
        var _emscripten_glColorMask = _glColorMask;
        var _glCompileShader = (shader) => {
          GLctx.compileShader(GL.shaders[shader]);
        };
        _glCompileShader.sig = "vi";
        var _emscripten_glCompileShader = _glCompileShader;
        function _glCompressedTexImage2D(target, level, internalFormat, width, height, border, imageSize, data2) {
          data2 >>>= 0;
          GLctx.compressedTexImage2D(target, level, internalFormat, width, height, border, data2 ? HEAPU8.subarray(data2 >>> 0, data2 + imageSize >>> 0) : null);
        }
        _glCompressedTexImage2D.sig = "viiiiiiip";
        var _emscripten_glCompressedTexImage2D = _glCompressedTexImage2D;
        function _glCompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data2) {
          data2 >>>= 0;
          GLctx.compressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, data2 ? HEAPU8.subarray(data2 >>> 0, data2 + imageSize >>> 0) : null);
        }
        _glCompressedTexSubImage2D.sig = "viiiiiiiip";
        var _emscripten_glCompressedTexSubImage2D = _glCompressedTexSubImage2D;
        function _glCopyTexImage2D(x0, x1, x2, x3, x4, x5, x6, x7) {
          GLctx.copyTexImage2D(x0, x1, x2, x3, x4, x5, x6, x7);
        }
        _glCopyTexImage2D.sig = "viiiiiiii";
        var _emscripten_glCopyTexImage2D = _glCopyTexImage2D;
        function _glCopyTexSubImage2D(x0, x1, x2, x3, x4, x5, x6, x7) {
          GLctx.copyTexSubImage2D(x0, x1, x2, x3, x4, x5, x6, x7);
        }
        _glCopyTexSubImage2D.sig = "viiiiiiii";
        var _emscripten_glCopyTexSubImage2D = _glCopyTexSubImage2D;
        var _glCreateProgram = () => {
          var id = GL.getNewId(GL.programs);
          var program = GLctx.createProgram();
          program.name = id;
          program.maxUniformLength = program.maxAttributeLength = program.maxUniformBlockNameLength = 0;
          program.uniformIdCounter = 1;
          GL.programs[id] = program;
          return id;
        };
        _glCreateProgram.sig = "i";
        var _emscripten_glCreateProgram = _glCreateProgram;
        var _glCreateShader = (shaderType) => {
          var id = GL.getNewId(GL.shaders);
          GL.shaders[id] = GLctx.createShader(shaderType);
          return id;
        };
        _glCreateShader.sig = "ii";
        var _emscripten_glCreateShader = _glCreateShader;
        function _glCullFace(x0) {
          GLctx.cullFace(x0);
        }
        _glCullFace.sig = "vi";
        var _emscripten_glCullFace = _glCullFace;
        function _glDeleteBuffers(n, buffers) {
          buffers >>>= 0;
          for (var i2 = 0; i2 < n; i2++) {
            var id = HEAP32[buffers + i2 * 4 >>> 2 >>> 0];
            var buffer = GL.buffers[id];
            if (!buffer)
              continue;
            GLctx.deleteBuffer(buffer);
            buffer.name = 0;
            GL.buffers[id] = null;
          }
        }
        _glDeleteBuffers.sig = "vip";
        var _emscripten_glDeleteBuffers = _glDeleteBuffers;
        function _glDeleteFramebuffers(n, framebuffers) {
          framebuffers >>>= 0;
          for (var i2 = 0; i2 < n; ++i2) {
            var id = HEAP32[framebuffers + i2 * 4 >>> 2 >>> 0];
            var framebuffer = GL.framebuffers[id];
            if (!framebuffer)
              continue;
            GLctx.deleteFramebuffer(framebuffer);
            framebuffer.name = 0;
            GL.framebuffers[id] = null;
          }
        }
        _glDeleteFramebuffers.sig = "vip";
        var _emscripten_glDeleteFramebuffers = _glDeleteFramebuffers;
        var _glDeleteProgram = (id) => {
          if (!id)
            return;
          var program = GL.programs[id];
          if (!program) {
            GL.recordError(1281);
            return;
          }
          GLctx.deleteProgram(program);
          program.name = 0;
          GL.programs[id] = null;
        };
        _glDeleteProgram.sig = "vi";
        var _emscripten_glDeleteProgram = _glDeleteProgram;
        function _glDeleteQueriesEXT(n, ids) {
          ids >>>= 0;
          for (var i2 = 0; i2 < n; i2++) {
            var id = HEAP32[ids + i2 * 4 >>> 2 >>> 0];
            var query = GL.queries[id];
            if (!query)
              continue;
            GLctx.disjointTimerQueryExt["deleteQueryEXT"](query);
            GL.queries[id] = null;
          }
        }
        _glDeleteQueriesEXT.sig = "vip";
        var _emscripten_glDeleteQueriesEXT = _glDeleteQueriesEXT;
        function _glDeleteRenderbuffers(n, renderbuffers) {
          renderbuffers >>>= 0;
          for (var i2 = 0; i2 < n; i2++) {
            var id = HEAP32[renderbuffers + i2 * 4 >>> 2 >>> 0];
            var renderbuffer = GL.renderbuffers[id];
            if (!renderbuffer)
              continue;
            GLctx.deleteRenderbuffer(renderbuffer);
            renderbuffer.name = 0;
            GL.renderbuffers[id] = null;
          }
        }
        _glDeleteRenderbuffers.sig = "vip";
        var _emscripten_glDeleteRenderbuffers = _glDeleteRenderbuffers;
        var _glDeleteShader = (id) => {
          if (!id)
            return;
          var shader = GL.shaders[id];
          if (!shader) {
            GL.recordError(1281);
            return;
          }
          GLctx.deleteShader(shader);
          GL.shaders[id] = null;
        };
        _glDeleteShader.sig = "vi";
        var _emscripten_glDeleteShader = _glDeleteShader;
        function _glDeleteTextures(n, textures) {
          textures >>>= 0;
          for (var i2 = 0; i2 < n; i2++) {
            var id = HEAP32[textures + i2 * 4 >>> 2 >>> 0];
            var texture = GL.textures[id];
            if (!texture)
              continue;
            GLctx.deleteTexture(texture);
            texture.name = 0;
            GL.textures[id] = null;
          }
        }
        _glDeleteTextures.sig = "vip";
        var _emscripten_glDeleteTextures = _glDeleteTextures;
        function _glDeleteVertexArrays(n, vaos) {
          vaos >>>= 0;
          for (var i2 = 0; i2 < n; i2++) {
            var id = HEAP32[vaos + i2 * 4 >>> 2 >>> 0];
            GLctx.deleteVertexArray(GL.vaos[id]);
            GL.vaos[id] = null;
          }
        }
        _glDeleteVertexArrays.sig = "vip";
        var _glDeleteVertexArraysOES = _glDeleteVertexArrays;
        _glDeleteVertexArraysOES.sig = "vip";
        var _emscripten_glDeleteVertexArraysOES = _glDeleteVertexArraysOES;
        function _glDepthFunc(x0) {
          GLctx.depthFunc(x0);
        }
        _glDepthFunc.sig = "vi";
        var _emscripten_glDepthFunc = _glDepthFunc;
        var _glDepthMask = (flag) => {
          GLctx.depthMask(!!flag);
        };
        _glDepthMask.sig = "vi";
        var _emscripten_glDepthMask = _glDepthMask;
        function _glDepthRangef(x0, x1) {
          GLctx.depthRange(x0, x1);
        }
        _glDepthRangef.sig = "vff";
        var _emscripten_glDepthRangef = _glDepthRangef;
        var _glDetachShader = (program, shader) => {
          GLctx.detachShader(GL.programs[program], GL.shaders[shader]);
        };
        _glDetachShader.sig = "vii";
        var _emscripten_glDetachShader = _glDetachShader;
        function _glDisable(x0) {
          GLctx.disable(x0);
        }
        _glDisable.sig = "vi";
        var _emscripten_glDisable = _glDisable;
        var _glDisableVertexAttribArray = (index) => {
          GLctx.disableVertexAttribArray(index);
        };
        _glDisableVertexAttribArray.sig = "vi";
        var _emscripten_glDisableVertexAttribArray = _glDisableVertexAttribArray;
        var _glDrawArrays = (mode, first, count) => {
          GLctx.drawArrays(mode, first, count);
        };
        _glDrawArrays.sig = "viii";
        var _emscripten_glDrawArrays = _glDrawArrays;
        var _glDrawArraysInstanced = (mode, first, count, primcount) => {
          GLctx.drawArraysInstanced(mode, first, count, primcount);
        };
        _glDrawArraysInstanced.sig = "viiii";
        var _glDrawArraysInstancedANGLE = _glDrawArraysInstanced;
        var _emscripten_glDrawArraysInstancedANGLE = _glDrawArraysInstancedANGLE;
        var tempFixedLengthArray = [];
        function _glDrawBuffers(n, bufs) {
          bufs >>>= 0;
          var bufArray = tempFixedLengthArray[n];
          for (var i2 = 0; i2 < n; i2++) {
            bufArray[i2] = HEAP32[bufs + i2 * 4 >>> 2 >>> 0];
          }
          GLctx.drawBuffers(bufArray);
        }
        _glDrawBuffers.sig = "vip";
        var _glDrawBuffersWEBGL = _glDrawBuffers;
        var _emscripten_glDrawBuffersWEBGL = _glDrawBuffersWEBGL;
        function _glDrawElements(mode, count, type, indices) {
          indices >>>= 0;
          GLctx.drawElements(mode, count, type, indices);
        }
        _glDrawElements.sig = "viiip";
        var _emscripten_glDrawElements = _glDrawElements;
        function _glDrawElementsInstanced(mode, count, type, indices, primcount) {
          indices >>>= 0;
          GLctx.drawElementsInstanced(mode, count, type, indices, primcount);
        }
        _glDrawElementsInstanced.sig = "viiipi";
        var _glDrawElementsInstancedANGLE = _glDrawElementsInstanced;
        var _emscripten_glDrawElementsInstancedANGLE = _glDrawElementsInstancedANGLE;
        function _glEnable(x0) {
          GLctx.enable(x0);
        }
        _glEnable.sig = "vi";
        var _emscripten_glEnable = _glEnable;
        var _glEnableVertexAttribArray = (index) => {
          GLctx.enableVertexAttribArray(index);
        };
        _glEnableVertexAttribArray.sig = "vi";
        var _emscripten_glEnableVertexAttribArray = _glEnableVertexAttribArray;
        var _glEndQueryEXT = (target) => {
          GLctx.disjointTimerQueryExt["endQueryEXT"](target);
        };
        _glEndQueryEXT.sig = "vi";
        var _emscripten_glEndQueryEXT = _glEndQueryEXT;
        function _glFinish() {
          GLctx.finish();
        }
        _glFinish.sig = "v";
        var _emscripten_glFinish = _glFinish;
        function _glFlush() {
          GLctx.flush();
        }
        _glFlush.sig = "v";
        var _emscripten_glFlush = _glFlush;
        var _glFramebufferRenderbuffer = (target, attachment, renderbuffertarget, renderbuffer) => {
          GLctx.framebufferRenderbuffer(target, attachment, renderbuffertarget, GL.renderbuffers[renderbuffer]);
        };
        _glFramebufferRenderbuffer.sig = "viiii";
        var _emscripten_glFramebufferRenderbuffer = _glFramebufferRenderbuffer;
        var _glFramebufferTexture2D = (target, attachment, textarget, texture, level) => {
          GLctx.framebufferTexture2D(target, attachment, textarget, GL.textures[texture], level);
        };
        _glFramebufferTexture2D.sig = "viiiii";
        var _emscripten_glFramebufferTexture2D = _glFramebufferTexture2D;
        function _glFrontFace(x0) {
          GLctx.frontFace(x0);
        }
        _glFrontFace.sig = "vi";
        var _emscripten_glFrontFace = _glFrontFace;
        var __glGenObject = (n, buffers, createFunction, objectTable) => {
          for (var i2 = 0; i2 < n; i2++) {
            var buffer = GLctx[createFunction]();
            var id = buffer && GL.getNewId(objectTable);
            if (buffer) {
              buffer.name = id;
              objectTable[id] = buffer;
            } else {
              GL.recordError(1282);
            }
            HEAP32[buffers + i2 * 4 >>> 2 >>> 0] = id;
          }
        };
        function _glGenBuffers(n, buffers) {
          buffers >>>= 0;
          __glGenObject(n, buffers, "createBuffer", GL.buffers);
        }
        _glGenBuffers.sig = "vip";
        var _emscripten_glGenBuffers = _glGenBuffers;
        function _glGenFramebuffers(n, ids) {
          ids >>>= 0;
          __glGenObject(n, ids, "createFramebuffer", GL.framebuffers);
        }
        _glGenFramebuffers.sig = "vip";
        var _emscripten_glGenFramebuffers = _glGenFramebuffers;
        function _glGenQueriesEXT(n, ids) {
          ids >>>= 0;
          for (var i2 = 0; i2 < n; i2++) {
            var query = GLctx.disjointTimerQueryExt["createQueryEXT"]();
            if (!query) {
              GL.recordError(1282);
              while (i2 < n)
                HEAP32[ids + i2++ * 4 >>> 2 >>> 0] = 0;
              return;
            }
            var id = GL.getNewId(GL.queries);
            query.name = id;
            GL.queries[id] = query;
            HEAP32[ids + i2 * 4 >>> 2 >>> 0] = id;
          }
        }
        _glGenQueriesEXT.sig = "vip";
        var _emscripten_glGenQueriesEXT = _glGenQueriesEXT;
        function _glGenRenderbuffers(n, renderbuffers) {
          renderbuffers >>>= 0;
          __glGenObject(n, renderbuffers, "createRenderbuffer", GL.renderbuffers);
        }
        _glGenRenderbuffers.sig = "vip";
        var _emscripten_glGenRenderbuffers = _glGenRenderbuffers;
        function _glGenTextures(n, textures) {
          textures >>>= 0;
          __glGenObject(n, textures, "createTexture", GL.textures);
        }
        _glGenTextures.sig = "vip";
        var _emscripten_glGenTextures = _glGenTextures;
        function _glGenVertexArrays(n, arrays) {
          arrays >>>= 0;
          __glGenObject(n, arrays, "createVertexArray", GL.vaos);
        }
        _glGenVertexArrays.sig = "vip";
        var _glGenVertexArraysOES = _glGenVertexArrays;
        _glGenVertexArraysOES.sig = "vip";
        var _emscripten_glGenVertexArraysOES = _glGenVertexArraysOES;
        function _glGenerateMipmap(x0) {
          GLctx.generateMipmap(x0);
        }
        _glGenerateMipmap.sig = "vi";
        var _emscripten_glGenerateMipmap = _glGenerateMipmap;
        var __glGetActiveAttribOrUniform = (funcName, program, index, bufSize, length, size, type, name2) => {
          program = GL.programs[program];
          var info2 = GLctx[funcName](program, index);
          if (info2) {
            var numBytesWrittenExclNull = name2 && stringToUTF8(info2.name, name2, bufSize);
            if (length)
              HEAP32[length >>> 2 >>> 0] = numBytesWrittenExclNull;
            if (size)
              HEAP32[size >>> 2 >>> 0] = info2.size;
            if (type)
              HEAP32[type >>> 2 >>> 0] = info2.type;
          }
        };
        function _glGetActiveAttrib(program, index, bufSize, length, size, type, name2) {
          length >>>= 0;
          size >>>= 0;
          type >>>= 0;
          name2 >>>= 0;
          __glGetActiveAttribOrUniform("getActiveAttrib", program, index, bufSize, length, size, type, name2);
        }
        _glGetActiveAttrib.sig = "viiipppp";
        var _emscripten_glGetActiveAttrib = _glGetActiveAttrib;
        function _glGetActiveUniform(program, index, bufSize, length, size, type, name2) {
          length >>>= 0;
          size >>>= 0;
          type >>>= 0;
          name2 >>>= 0;
          __glGetActiveAttribOrUniform("getActiveUniform", program, index, bufSize, length, size, type, name2);
        }
        _glGetActiveUniform.sig = "viiipppp";
        var _emscripten_glGetActiveUniform = _glGetActiveUniform;
        function _glGetAttachedShaders(program, maxCount, count, shaders) {
          count >>>= 0;
          shaders >>>= 0;
          var result = GLctx.getAttachedShaders(GL.programs[program]);
          var len2 = result.length;
          if (len2 > maxCount) {
            len2 = maxCount;
          }
          HEAP32[count >>> 2 >>> 0] = len2;
          for (var i2 = 0; i2 < len2; ++i2) {
            var id = GL.shaders.indexOf(result[i2]);
            HEAP32[shaders + i2 * 4 >>> 2 >>> 0] = id;
          }
        }
        _glGetAttachedShaders.sig = "viipp";
        var _emscripten_glGetAttachedShaders = _glGetAttachedShaders;
        function _glGetAttribLocation(program, name2) {
          name2 >>>= 0;
          return GLctx.getAttribLocation(GL.programs[program], UTF8ToString(name2));
        }
        _glGetAttribLocation.sig = "iip";
        var _emscripten_glGetAttribLocation = _glGetAttribLocation;
        var writeI53ToI64 = (ptr2, num) => {
          HEAPU32[ptr2 >>> 2 >>> 0] = num;
          var lower = HEAPU32[ptr2 >>> 2 >>> 0];
          HEAPU32[ptr2 + 4 >>> 2 >>> 0] = (num - lower) / 4294967296;
        };
        var emscriptenWebGLGet = (name_, p, type) => {
          if (!p) {
            GL.recordError(1281);
            return;
          }
          var ret = void 0;
          switch (name_) {
            case 36346:
              ret = 1;
              break;
            case 36344:
              if (type != 0 && type != 1) {
                GL.recordError(1280);
              }
              return;
            case 36345:
              ret = 0;
              break;
            case 34466:
              var formats = GLctx.getParameter(34467);
              ret = formats ? formats.length : 0;
              break;
          }
          if (ret === void 0) {
            var result = GLctx.getParameter(name_);
            switch (typeof result) {
              case "number":
                ret = result;
                break;
              case "boolean":
                ret = result ? 1 : 0;
                break;
              case "string":
                GL.recordError(1280);
                return;
              case "object":
                if (result === null) {
                  switch (name_) {
                    case 34964:
                    case 35725:
                    case 34965:
                    case 36006:
                    case 36007:
                    case 32873:
                    case 34229:
                    case 34068: {
                      ret = 0;
                      break;
                    }
                    default: {
                      GL.recordError(1280);
                      return;
                    }
                  }
                } else if (result instanceof Float32Array || result instanceof Uint32Array || result instanceof Int32Array || result instanceof Array) {
                  for (var i2 = 0; i2 < result.length; ++i2) {
                    switch (type) {
                      case 0:
                        HEAP32[p + i2 * 4 >>> 2 >>> 0] = result[i2];
                        break;
                      case 2:
                        HEAPF32[p + i2 * 4 >>> 2 >>> 0] = result[i2];
                        break;
                      case 4:
                        HEAP8[p + i2 >>> 0 >>> 0] = result[i2] ? 1 : 0;
                        break;
                    }
                  }
                  return;
                } else {
                  try {
                    ret = result.name | 0;
                  } catch (e) {
                    GL.recordError(1280);
                    err(`GL_INVALID_ENUM in glGet${type}v: Unknown object returned from WebGL getParameter(${name_})! (error: ${e})`);
                    return;
                  }
                }
                break;
              default:
                GL.recordError(1280);
                err(`GL_INVALID_ENUM in glGet${type}v: Native code calling glGet${type}v(${name_}) and it returns ${result} of type ${typeof result}!`);
                return;
            }
          }
          switch (type) {
            case 1:
              writeI53ToI64(p, ret);
              break;
            case 0:
              HEAP32[p >>> 2 >>> 0] = ret;
              break;
            case 2:
              HEAPF32[p >>> 2 >>> 0] = ret;
              break;
            case 4:
              HEAP8[p >>> 0 >>> 0] = ret ? 1 : 0;
              break;
          }
        };
        function _glGetBooleanv(name_, p) {
          p >>>= 0;
          return emscriptenWebGLGet(name_, p, 4);
        }
        _glGetBooleanv.sig = "vip";
        var _emscripten_glGetBooleanv = _glGetBooleanv;
        function _glGetBufferParameteriv(target, value, data2) {
          data2 >>>= 0;
          if (!data2) {
            GL.recordError(1281);
            return;
          }
          HEAP32[data2 >>> 2 >>> 0] = GLctx.getBufferParameter(target, value);
        }
        _glGetBufferParameteriv.sig = "viip";
        var _emscripten_glGetBufferParameteriv = _glGetBufferParameteriv;
        var _glGetError = () => {
          var error = GLctx.getError() || GL.lastError;
          GL.lastError = 0;
          return error;
        };
        _glGetError.sig = "i";
        var _emscripten_glGetError = _glGetError;
        function _glGetFloatv(name_, p) {
          p >>>= 0;
          return emscriptenWebGLGet(name_, p, 2);
        }
        _glGetFloatv.sig = "vip";
        var _emscripten_glGetFloatv = _glGetFloatv;
        function _glGetFramebufferAttachmentParameteriv(target, attachment, pname, params) {
          params >>>= 0;
          var result = GLctx.getFramebufferAttachmentParameter(target, attachment, pname);
          if (result instanceof WebGLRenderbuffer || result instanceof WebGLTexture) {
            result = result.name | 0;
          }
          HEAP32[params >>> 2 >>> 0] = result;
        }
        _glGetFramebufferAttachmentParameteriv.sig = "viiip";
        var _emscripten_glGetFramebufferAttachmentParameteriv = _glGetFramebufferAttachmentParameteriv;
        function _glGetIntegerv(name_, p) {
          p >>>= 0;
          return emscriptenWebGLGet(name_, p, 0);
        }
        _glGetIntegerv.sig = "vip";
        var _emscripten_glGetIntegerv = _glGetIntegerv;
        function _glGetProgramInfoLog(program, maxLength, length, infoLog) {
          length >>>= 0;
          infoLog >>>= 0;
          var log = GLctx.getProgramInfoLog(GL.programs[program]);
          if (log === null)
            log = "(unknown error)";
          var numBytesWrittenExclNull = maxLength > 0 && infoLog ? stringToUTF8(log, infoLog, maxLength) : 0;
          if (length)
            HEAP32[length >>> 2 >>> 0] = numBytesWrittenExclNull;
        }
        _glGetProgramInfoLog.sig = "viipp";
        var _emscripten_glGetProgramInfoLog = _glGetProgramInfoLog;
        function _glGetProgramiv(program, pname, p) {
          p >>>= 0;
          if (!p) {
            GL.recordError(1281);
            return;
          }
          if (program >= GL.counter) {
            GL.recordError(1281);
            return;
          }
          program = GL.programs[program];
          if (pname == 35716) {
            var log = GLctx.getProgramInfoLog(program);
            if (log === null)
              log = "(unknown error)";
            HEAP32[p >>> 2 >>> 0] = log.length + 1;
          } else if (pname == 35719) {
            if (!program.maxUniformLength) {
              for (var i2 = 0; i2 < GLctx.getProgramParameter(program, 35718); ++i2) {
                program.maxUniformLength = Math.max(program.maxUniformLength, GLctx.getActiveUniform(program, i2).name.length + 1);
              }
            }
            HEAP32[p >>> 2 >>> 0] = program.maxUniformLength;
          } else if (pname == 35722) {
            if (!program.maxAttributeLength) {
              for (var i2 = 0; i2 < GLctx.getProgramParameter(program, 35721); ++i2) {
                program.maxAttributeLength = Math.max(program.maxAttributeLength, GLctx.getActiveAttrib(program, i2).name.length + 1);
              }
            }
            HEAP32[p >>> 2 >>> 0] = program.maxAttributeLength;
          } else if (pname == 35381) {
            if (!program.maxUniformBlockNameLength) {
              for (var i2 = 0; i2 < GLctx.getProgramParameter(program, 35382); ++i2) {
                program.maxUniformBlockNameLength = Math.max(program.maxUniformBlockNameLength, GLctx.getActiveUniformBlockName(program, i2).length + 1);
              }
            }
            HEAP32[p >>> 2 >>> 0] = program.maxUniformBlockNameLength;
          } else {
            HEAP32[p >>> 2 >>> 0] = GLctx.getProgramParameter(program, pname);
          }
        }
        _glGetProgramiv.sig = "viip";
        var _emscripten_glGetProgramiv = _glGetProgramiv;
        function _glGetQueryObjecti64vEXT(id, pname, params) {
          params >>>= 0;
          if (!params) {
            GL.recordError(1281);
            return;
          }
          var query = GL.queries[id];
          var param;
          {
            param = GLctx.disjointTimerQueryExt["getQueryObjectEXT"](query, pname);
          }
          var ret;
          if (typeof param == "boolean") {
            ret = param ? 1 : 0;
          } else {
            ret = param;
          }
          writeI53ToI64(params, ret);
        }
        _glGetQueryObjecti64vEXT.sig = "viip";
        var _emscripten_glGetQueryObjecti64vEXT = _glGetQueryObjecti64vEXT;
        function _glGetQueryObjectivEXT(id, pname, params) {
          params >>>= 0;
          if (!params) {
            GL.recordError(1281);
            return;
          }
          var query = GL.queries[id];
          var param = GLctx.disjointTimerQueryExt["getQueryObjectEXT"](query, pname);
          var ret;
          if (typeof param == "boolean") {
            ret = param ? 1 : 0;
          } else {
            ret = param;
          }
          HEAP32[params >>> 2 >>> 0] = ret;
        }
        _glGetQueryObjectivEXT.sig = "viip";
        var _emscripten_glGetQueryObjectivEXT = _glGetQueryObjectivEXT;
        var _glGetQueryObjectui64vEXT = _glGetQueryObjecti64vEXT;
        var _emscripten_glGetQueryObjectui64vEXT = _glGetQueryObjectui64vEXT;
        var _glGetQueryObjectuivEXT = _glGetQueryObjectivEXT;
        var _emscripten_glGetQueryObjectuivEXT = _glGetQueryObjectuivEXT;
        function _glGetQueryivEXT(target, pname, params) {
          params >>>= 0;
          if (!params) {
            GL.recordError(1281);
            return;
          }
          HEAP32[params >>> 2 >>> 0] = GLctx.disjointTimerQueryExt["getQueryEXT"](target, pname);
        }
        _glGetQueryivEXT.sig = "viip";
        var _emscripten_glGetQueryivEXT = _glGetQueryivEXT;
        function _glGetRenderbufferParameteriv(target, pname, params) {
          params >>>= 0;
          if (!params) {
            GL.recordError(1281);
            return;
          }
          HEAP32[params >>> 2 >>> 0] = GLctx.getRenderbufferParameter(target, pname);
        }
        _glGetRenderbufferParameteriv.sig = "viip";
        var _emscripten_glGetRenderbufferParameteriv = _glGetRenderbufferParameteriv;
        function _glGetShaderInfoLog(shader, maxLength, length, infoLog) {
          length >>>= 0;
          infoLog >>>= 0;
          var log = GLctx.getShaderInfoLog(GL.shaders[shader]);
          if (log === null)
            log = "(unknown error)";
          var numBytesWrittenExclNull = maxLength > 0 && infoLog ? stringToUTF8(log, infoLog, maxLength) : 0;
          if (length)
            HEAP32[length >>> 2 >>> 0] = numBytesWrittenExclNull;
        }
        _glGetShaderInfoLog.sig = "viipp";
        var _emscripten_glGetShaderInfoLog = _glGetShaderInfoLog;
        function _glGetShaderPrecisionFormat(shaderType, precisionType, range, precision) {
          range >>>= 0;
          precision >>>= 0;
          var result = GLctx.getShaderPrecisionFormat(shaderType, precisionType);
          HEAP32[range >>> 2 >>> 0] = result.rangeMin;
          HEAP32[range + 4 >>> 2 >>> 0] = result.rangeMax;
          HEAP32[precision >>> 2 >>> 0] = result.precision;
        }
        _glGetShaderPrecisionFormat.sig = "viipp";
        var _emscripten_glGetShaderPrecisionFormat = _glGetShaderPrecisionFormat;
        function _glGetShaderSource(shader, bufSize, length, source) {
          length >>>= 0;
          source >>>= 0;
          var result = GLctx.getShaderSource(GL.shaders[shader]);
          if (!result)
            return;
          var numBytesWrittenExclNull = bufSize > 0 && source ? stringToUTF8(result, source, bufSize) : 0;
          if (length)
            HEAP32[length >>> 2 >>> 0] = numBytesWrittenExclNull;
        }
        _glGetShaderSource.sig = "viipp";
        var _emscripten_glGetShaderSource = _glGetShaderSource;
        function _glGetShaderiv(shader, pname, p) {
          p >>>= 0;
          if (!p) {
            GL.recordError(1281);
            return;
          }
          if (pname == 35716) {
            var log = GLctx.getShaderInfoLog(GL.shaders[shader]);
            if (log === null)
              log = "(unknown error)";
            var logLength = log ? log.length + 1 : 0;
            HEAP32[p >>> 2 >>> 0] = logLength;
          } else if (pname == 35720) {
            var source = GLctx.getShaderSource(GL.shaders[shader]);
            var sourceLength = source ? source.length + 1 : 0;
            HEAP32[p >>> 2 >>> 0] = sourceLength;
          } else {
            HEAP32[p >>> 2 >>> 0] = GLctx.getShaderParameter(GL.shaders[shader], pname);
          }
        }
        _glGetShaderiv.sig = "viip";
        var _emscripten_glGetShaderiv = _glGetShaderiv;
        var webglGetExtensions = function $webglGetExtensions() {
          var exts = getEmscriptenSupportedExtensions(GLctx);
          exts = exts.concat(exts.map((e) => "GL_" + e));
          return exts;
        };
        function _glGetString(name_) {
          var ret = GL.stringCache[name_];
          if (!ret) {
            switch (name_) {
              case 7939:
                ret = stringToNewUTF8(webglGetExtensions().join(" "));
                break;
              case 7936:
              case 7937:
              case 37445:
              case 37446:
                var s2 = GLctx.getParameter(name_);
                if (!s2) {
                  GL.recordError(1280);
                }
                ret = s2 ? stringToNewUTF8(s2) : 0;
                break;
              case 7938:
                var glVersion = GLctx.getParameter(7938);
                {
                  glVersion = `OpenGL ES 2.0 (${glVersion})`;
                }
                ret = stringToNewUTF8(glVersion);
                break;
              case 35724:
                var glslVersion = GLctx.getParameter(35724);
                var ver_re = /^WebGL GLSL ES ([0-9]\.[0-9][0-9]?)(?:$| .*)/;
                var ver_num = glslVersion.match(ver_re);
                if (ver_num !== null) {
                  if (ver_num[1].length == 3)
                    ver_num[1] = ver_num[1] + "0";
                  glslVersion = `OpenGL ES GLSL ES ${ver_num[1]} (${glslVersion})`;
                }
                ret = stringToNewUTF8(glslVersion);
                break;
              default:
                GL.recordError(1280);
            }
            GL.stringCache[name_] = ret;
          }
          return ret;
        }
        _glGetString.sig = "pi";
        var _emscripten_glGetString = _glGetString;
        function _glGetTexParameterfv(target, pname, params) {
          params >>>= 0;
          if (!params) {
            GL.recordError(1281);
            return;
          }
          HEAPF32[params >>> 2 >>> 0] = GLctx.getTexParameter(target, pname);
        }
        _glGetTexParameterfv.sig = "viip";
        var _emscripten_glGetTexParameterfv = _glGetTexParameterfv;
        function _glGetTexParameteriv(target, pname, params) {
          params >>>= 0;
          if (!params) {
            GL.recordError(1281);
            return;
          }
          HEAP32[params >>> 2 >>> 0] = GLctx.getTexParameter(target, pname);
        }
        _glGetTexParameteriv.sig = "viip";
        var _emscripten_glGetTexParameteriv = _glGetTexParameteriv;
        var webglGetLeftBracePos = (name2) => name2.slice(-1) == "]" && name2.lastIndexOf("[");
        var webglPrepareUniformLocationsBeforeFirstUse = (program) => {
          var uniformLocsById = program.uniformLocsById, uniformSizeAndIdsByName = program.uniformSizeAndIdsByName, i2, j;
          if (!uniformLocsById) {
            program.uniformLocsById = uniformLocsById = {};
            program.uniformArrayNamesById = {};
            for (i2 = 0; i2 < GLctx.getProgramParameter(program, 35718); ++i2) {
              var u = GLctx.getActiveUniform(program, i2);
              var nm = u.name;
              var sz = u.size;
              var lb = webglGetLeftBracePos(nm);
              var arrayName = lb > 0 ? nm.slice(0, lb) : nm;
              var id = program.uniformIdCounter;
              program.uniformIdCounter += sz;
              uniformSizeAndIdsByName[arrayName] = [sz, id];
              for (j = 0; j < sz; ++j) {
                uniformLocsById[id] = j;
                program.uniformArrayNamesById[id++] = arrayName;
              }
            }
          }
        };
        function _glGetUniformLocation(program, name2) {
          name2 >>>= 0;
          name2 = UTF8ToString(name2);
          if (program = GL.programs[program]) {
            webglPrepareUniformLocationsBeforeFirstUse(program);
            var uniformLocsById = program.uniformLocsById;
            var arrayIndex = 0;
            var uniformBaseName = name2;
            var leftBrace = webglGetLeftBracePos(name2);
            if (leftBrace > 0) {
              arrayIndex = jstoi_q(name2.slice(leftBrace + 1)) >>> 0;
              uniformBaseName = name2.slice(0, leftBrace);
            }
            var sizeAndId = program.uniformSizeAndIdsByName[uniformBaseName];
            if (sizeAndId && arrayIndex < sizeAndId[0]) {
              arrayIndex += sizeAndId[1];
              if (uniformLocsById[arrayIndex] = uniformLocsById[arrayIndex] || GLctx.getUniformLocation(program, name2)) {
                return arrayIndex;
              }
            }
          } else {
            GL.recordError(1281);
          }
          return -1;
        }
        _glGetUniformLocation.sig = "iip";
        var _emscripten_glGetUniformLocation = _glGetUniformLocation;
        var webglGetUniformLocation = (location) => {
          var p = GLctx.currentProgram;
          if (p) {
            var webglLoc = p.uniformLocsById[location];
            if (typeof webglLoc == "number") {
              p.uniformLocsById[location] = webglLoc = GLctx.getUniformLocation(p, p.uniformArrayNamesById[location] + (webglLoc > 0 ? `[${webglLoc}]` : ""));
            }
            return webglLoc;
          } else {
            GL.recordError(1282);
          }
        };
        var emscriptenWebGLGetUniform = (program, location, params, type) => {
          if (!params) {
            GL.recordError(1281);
            return;
          }
          program = GL.programs[program];
          webglPrepareUniformLocationsBeforeFirstUse(program);
          var data2 = GLctx.getUniform(program, webglGetUniformLocation(location));
          if (typeof data2 == "number" || typeof data2 == "boolean") {
            switch (type) {
              case 0:
                HEAP32[params >>> 2 >>> 0] = data2;
                break;
              case 2:
                HEAPF32[params >>> 2 >>> 0] = data2;
                break;
            }
          } else {
            for (var i2 = 0; i2 < data2.length; i2++) {
              switch (type) {
                case 0:
                  HEAP32[params + i2 * 4 >>> 2 >>> 0] = data2[i2];
                  break;
                case 2:
                  HEAPF32[params + i2 * 4 >>> 2 >>> 0] = data2[i2];
                  break;
              }
            }
          }
        };
        function _glGetUniformfv(program, location, params) {
          params >>>= 0;
          emscriptenWebGLGetUniform(program, location, params, 2);
        }
        _glGetUniformfv.sig = "viip";
        var _emscripten_glGetUniformfv = _glGetUniformfv;
        function _glGetUniformiv(program, location, params) {
          params >>>= 0;
          emscriptenWebGLGetUniform(program, location, params, 0);
        }
        _glGetUniformiv.sig = "viip";
        var _emscripten_glGetUniformiv = _glGetUniformiv;
        function _glGetVertexAttribPointerv(index, pname, pointer) {
          pointer >>>= 0;
          if (!pointer) {
            GL.recordError(1281);
            return;
          }
          HEAP32[pointer >>> 2 >>> 0] = GLctx.getVertexAttribOffset(index, pname);
        }
        _glGetVertexAttribPointerv.sig = "viip";
        var _emscripten_glGetVertexAttribPointerv = _glGetVertexAttribPointerv;
        var emscriptenWebGLGetVertexAttrib = (index, pname, params, type) => {
          if (!params) {
            GL.recordError(1281);
            return;
          }
          var data2 = GLctx.getVertexAttrib(index, pname);
          if (pname == 34975) {
            HEAP32[params >>> 2 >>> 0] = data2 && data2["name"];
          } else if (typeof data2 == "number" || typeof data2 == "boolean") {
            switch (type) {
              case 0:
                HEAP32[params >>> 2 >>> 0] = data2;
                break;
              case 2:
                HEAPF32[params >>> 2 >>> 0] = data2;
                break;
              case 5:
                HEAP32[params >>> 2 >>> 0] = Math.fround(data2);
                break;
            }
          } else {
            for (var i2 = 0; i2 < data2.length; i2++) {
              switch (type) {
                case 0:
                  HEAP32[params + i2 * 4 >>> 2 >>> 0] = data2[i2];
                  break;
                case 2:
                  HEAPF32[params + i2 * 4 >>> 2 >>> 0] = data2[i2];
                  break;
                case 5:
                  HEAP32[params + i2 * 4 >>> 2 >>> 0] = Math.fround(data2[i2]);
                  break;
              }
            }
          }
        };
        function _glGetVertexAttribfv(index, pname, params) {
          params >>>= 0;
          emscriptenWebGLGetVertexAttrib(index, pname, params, 2);
        }
        _glGetVertexAttribfv.sig = "viip";
        var _emscripten_glGetVertexAttribfv = _glGetVertexAttribfv;
        function _glGetVertexAttribiv(index, pname, params) {
          params >>>= 0;
          emscriptenWebGLGetVertexAttrib(index, pname, params, 5);
        }
        _glGetVertexAttribiv.sig = "viip";
        var _emscripten_glGetVertexAttribiv = _glGetVertexAttribiv;
        function _glHint(x0, x1) {
          GLctx.hint(x0, x1);
        }
        _glHint.sig = "vii";
        var _emscripten_glHint = _glHint;
        var _glIsBuffer = (buffer) => {
          var b = GL.buffers[buffer];
          if (!b)
            return 0;
          return GLctx.isBuffer(b);
        };
        _glIsBuffer.sig = "ii";
        var _emscripten_glIsBuffer = _glIsBuffer;
        function _glIsEnabled(x0) {
          return GLctx.isEnabled(x0);
        }
        _glIsEnabled.sig = "ii";
        var _emscripten_glIsEnabled = _glIsEnabled;
        var _glIsFramebuffer = (framebuffer) => {
          var fb = GL.framebuffers[framebuffer];
          if (!fb)
            return 0;
          return GLctx.isFramebuffer(fb);
        };
        _glIsFramebuffer.sig = "ii";
        var _emscripten_glIsFramebuffer = _glIsFramebuffer;
        var _glIsProgram = (program) => {
          program = GL.programs[program];
          if (!program)
            return 0;
          return GLctx.isProgram(program);
        };
        _glIsProgram.sig = "ii";
        var _emscripten_glIsProgram = _glIsProgram;
        var _glIsQueryEXT = (id) => {
          var query = GL.queries[id];
          if (!query)
            return 0;
          return GLctx.disjointTimerQueryExt["isQueryEXT"](query);
        };
        _glIsQueryEXT.sig = "ii";
        var _emscripten_glIsQueryEXT = _glIsQueryEXT;
        var _glIsRenderbuffer = (renderbuffer) => {
          var rb = GL.renderbuffers[renderbuffer];
          if (!rb)
            return 0;
          return GLctx.isRenderbuffer(rb);
        };
        _glIsRenderbuffer.sig = "ii";
        var _emscripten_glIsRenderbuffer = _glIsRenderbuffer;
        var _glIsShader = (shader) => {
          var s2 = GL.shaders[shader];
          if (!s2)
            return 0;
          return GLctx.isShader(s2);
        };
        _glIsShader.sig = "ii";
        var _emscripten_glIsShader = _glIsShader;
        var _glIsTexture = (id) => {
          var texture = GL.textures[id];
          if (!texture)
            return 0;
          return GLctx.isTexture(texture);
        };
        _glIsTexture.sig = "ii";
        var _emscripten_glIsTexture = _glIsTexture;
        var _glIsVertexArray = (array) => {
          var vao = GL.vaos[array];
          if (!vao)
            return 0;
          return GLctx.isVertexArray(vao);
        };
        _glIsVertexArray.sig = "ii";
        var _glIsVertexArrayOES = _glIsVertexArray;
        _glIsVertexArrayOES.sig = "ii";
        var _emscripten_glIsVertexArrayOES = _glIsVertexArrayOES;
        function _glLineWidth(x0) {
          GLctx.lineWidth(x0);
        }
        _glLineWidth.sig = "vf";
        var _emscripten_glLineWidth = _glLineWidth;
        var _glLinkProgram = (program) => {
          program = GL.programs[program];
          GLctx.linkProgram(program);
          program.uniformLocsById = 0;
          program.uniformSizeAndIdsByName = {};
        };
        _glLinkProgram.sig = "vi";
        var _emscripten_glLinkProgram = _glLinkProgram;
        var _glPixelStorei = (pname, param) => {
          if (pname == 3317) {
            GL.unpackAlignment = param;
          }
          GLctx.pixelStorei(pname, param);
        };
        _glPixelStorei.sig = "vii";
        var _emscripten_glPixelStorei = _glPixelStorei;
        function _glPolygonOffset(x0, x1) {
          GLctx.polygonOffset(x0, x1);
        }
        _glPolygonOffset.sig = "vff";
        var _emscripten_glPolygonOffset = _glPolygonOffset;
        var _glQueryCounterEXT = (id, target) => {
          GLctx.disjointTimerQueryExt["queryCounterEXT"](GL.queries[id], target);
        };
        _glQueryCounterEXT.sig = "vii";
        var _emscripten_glQueryCounterEXT = _glQueryCounterEXT;
        var computeUnpackAlignedImageSize = (width, height, sizePerPixel, alignment) => {
          function roundedToNextMultipleOf(x, y) {
            return x + y - 1 & -y;
          }
          var plainRowSize = width * sizePerPixel;
          var alignedRowSize = roundedToNextMultipleOf(plainRowSize, alignment);
          return height * alignedRowSize;
        };
        var colorChannelsInGlTextureFormat = (format) => {
          var colorChannels = {
            5: 3,
            6: 4,
            8: 2,
            29502: 3,
            29504: 4
          };
          return colorChannels[format - 6402] || 1;
        };
        var heapObjectForWebGLType = (type) => {
          type -= 5120;
          if (type == 1)
            return HEAPU8;
          if (type == 4)
            return HEAP32;
          if (type == 6)
            return HEAPF32;
          if (type == 5 || type == 28922)
            return HEAPU32;
          return HEAPU16;
        };
        var heapAccessShiftForWebGLHeap = (heap) => 31 - Math.clz32(heap.BYTES_PER_ELEMENT);
        var emscriptenWebGLGetTexPixelData = (type, format, width, height, pixels, internalFormat) => {
          var heap = heapObjectForWebGLType(type);
          var shift = heapAccessShiftForWebGLHeap(heap);
          var byteSize = 1 << shift;
          var sizePerPixel = colorChannelsInGlTextureFormat(format) * byteSize;
          var bytes = computeUnpackAlignedImageSize(width, height, sizePerPixel, GL.unpackAlignment);
          return heap.subarray(pixels >>> shift, pixels + bytes >>> shift);
        };
        function _glReadPixels(x, y, width, height, format, type, pixels) {
          pixels >>>= 0;
          var pixelData = emscriptenWebGLGetTexPixelData(type, format, width, height, pixels, format);
          if (!pixelData) {
            GL.recordError(1280);
            return;
          }
          GLctx.readPixels(x, y, width, height, format, type, pixelData);
        }
        _glReadPixels.sig = "viiiiiip";
        var _emscripten_glReadPixels = _glReadPixels;
        var _glReleaseShaderCompiler = () => {
        };
        _glReleaseShaderCompiler.sig = "v";
        var _emscripten_glReleaseShaderCompiler = _glReleaseShaderCompiler;
        function _glRenderbufferStorage(x0, x1, x2, x3) {
          GLctx.renderbufferStorage(x0, x1, x2, x3);
        }
        _glRenderbufferStorage.sig = "viiii";
        var _emscripten_glRenderbufferStorage = _glRenderbufferStorage;
        var _glSampleCoverage = (value, invert) => {
          GLctx.sampleCoverage(value, !!invert);
        };
        _glSampleCoverage.sig = "vfi";
        var _emscripten_glSampleCoverage = _glSampleCoverage;
        function _glScissor(x0, x1, x2, x3) {
          GLctx.scissor(x0, x1, x2, x3);
        }
        _glScissor.sig = "viiii";
        var _emscripten_glScissor = _glScissor;
        function _glShaderBinary(count, shaders, binaryformat, binary2, length) {
          shaders >>>= 0;
          binary2 >>>= 0;
          GL.recordError(1280);
        }
        _glShaderBinary.sig = "vipipi";
        var _emscripten_glShaderBinary = _glShaderBinary;
        function _glShaderSource(shader, count, string, length) {
          string >>>= 0;
          length >>>= 0;
          var source = GL.getSource(shader, count, string, length);
          GLctx.shaderSource(GL.shaders[shader], source);
        }
        _glShaderSource.sig = "viipp";
        var _emscripten_glShaderSource = _glShaderSource;
        function _glStencilFunc(x0, x1, x2) {
          GLctx.stencilFunc(x0, x1, x2);
        }
        _glStencilFunc.sig = "viii";
        var _emscripten_glStencilFunc = _glStencilFunc;
        function _glStencilFuncSeparate(x0, x1, x2, x3) {
          GLctx.stencilFuncSeparate(x0, x1, x2, x3);
        }
        _glStencilFuncSeparate.sig = "viiii";
        var _emscripten_glStencilFuncSeparate = _glStencilFuncSeparate;
        function _glStencilMask(x0) {
          GLctx.stencilMask(x0);
        }
        _glStencilMask.sig = "vi";
        var _emscripten_glStencilMask = _glStencilMask;
        function _glStencilMaskSeparate(x0, x1) {
          GLctx.stencilMaskSeparate(x0, x1);
        }
        _glStencilMaskSeparate.sig = "vii";
        var _emscripten_glStencilMaskSeparate = _glStencilMaskSeparate;
        function _glStencilOp(x0, x1, x2) {
          GLctx.stencilOp(x0, x1, x2);
        }
        _glStencilOp.sig = "viii";
        var _emscripten_glStencilOp = _glStencilOp;
        function _glStencilOpSeparate(x0, x1, x2, x3) {
          GLctx.stencilOpSeparate(x0, x1, x2, x3);
        }
        _glStencilOpSeparate.sig = "viiii";
        var _emscripten_glStencilOpSeparate = _glStencilOpSeparate;
        function _glTexImage2D(target, level, internalFormat, width, height, border, format, type, pixels) {
          pixels >>>= 0;
          GLctx.texImage2D(target, level, internalFormat, width, height, border, format, type, pixels ? emscriptenWebGLGetTexPixelData(type, format, width, height, pixels, internalFormat) : null);
        }
        _glTexImage2D.sig = "viiiiiiiip";
        var _emscripten_glTexImage2D = _glTexImage2D;
        function _glTexParameterf(x0, x1, x2) {
          GLctx.texParameterf(x0, x1, x2);
        }
        _glTexParameterf.sig = "viif";
        var _emscripten_glTexParameterf = _glTexParameterf;
        function _glTexParameterfv(target, pname, params) {
          params >>>= 0;
          var param = HEAPF32[params >>> 2 >>> 0];
          GLctx.texParameterf(target, pname, param);
        }
        _glTexParameterfv.sig = "viip";
        var _emscripten_glTexParameterfv = _glTexParameterfv;
        function _glTexParameteri(x0, x1, x2) {
          GLctx.texParameteri(x0, x1, x2);
        }
        _glTexParameteri.sig = "viii";
        var _emscripten_glTexParameteri = _glTexParameteri;
        function _glTexParameteriv(target, pname, params) {
          params >>>= 0;
          var param = HEAP32[params >>> 2 >>> 0];
          GLctx.texParameteri(target, pname, param);
        }
        _glTexParameteriv.sig = "viip";
        var _emscripten_glTexParameteriv = _glTexParameteriv;
        function _glTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels) {
          pixels >>>= 0;
          var pixelData = null;
          if (pixels)
            pixelData = emscriptenWebGLGetTexPixelData(type, format, width, height, pixels, 0);
          GLctx.texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixelData);
        }
        _glTexSubImage2D.sig = "viiiiiiiip";
        var _emscripten_glTexSubImage2D = _glTexSubImage2D;
        var _glUniform1f = (location, v0) => {
          GLctx.uniform1f(webglGetUniformLocation(location), v0);
        };
        _glUniform1f.sig = "vif";
        var _emscripten_glUniform1f = _glUniform1f;
        var miniTempWebGLFloatBuffers = [];
        function _glUniform1fv(location, count, value) {
          value >>>= 0;
          if (count <= 288) {
            var view = miniTempWebGLFloatBuffers[count - 1];
            for (var i2 = 0; i2 < count; ++i2) {
              view[i2] = HEAPF32[value + 4 * i2 >>> 2 >>> 0];
            }
          } else {
            var view = HEAPF32.subarray(value >>> 2 >>> 0, value + count * 4 >>> 2 >>> 0);
          }
          GLctx.uniform1fv(webglGetUniformLocation(location), view);
        }
        _glUniform1fv.sig = "viip";
        var _emscripten_glUniform1fv = _glUniform1fv;
        var _glUniform1i = (location, v0) => {
          GLctx.uniform1i(webglGetUniformLocation(location), v0);
        };
        _glUniform1i.sig = "vii";
        var _emscripten_glUniform1i = _glUniform1i;
        var miniTempWebGLIntBuffers = [];
        function _glUniform1iv(location, count, value) {
          value >>>= 0;
          if (count <= 288) {
            var view = miniTempWebGLIntBuffers[count - 1];
            for (var i2 = 0; i2 < count; ++i2) {
              view[i2] = HEAP32[value + 4 * i2 >>> 2 >>> 0];
            }
          } else {
            var view = HEAP32.subarray(value >>> 2 >>> 0, value + count * 4 >>> 2 >>> 0);
          }
          GLctx.uniform1iv(webglGetUniformLocation(location), view);
        }
        _glUniform1iv.sig = "viip";
        var _emscripten_glUniform1iv = _glUniform1iv;
        var _glUniform2f = (location, v0, v1) => {
          GLctx.uniform2f(webglGetUniformLocation(location), v0, v1);
        };
        _glUniform2f.sig = "viff";
        var _emscripten_glUniform2f = _glUniform2f;
        function _glUniform2fv(location, count, value) {
          value >>>= 0;
          if (count <= 144) {
            var view = miniTempWebGLFloatBuffers[2 * count - 1];
            for (var i2 = 0; i2 < 2 * count; i2 += 2) {
              view[i2] = HEAPF32[value + 4 * i2 >>> 2 >>> 0];
              view[i2 + 1] = HEAPF32[value + (4 * i2 + 4) >>> 2 >>> 0];
            }
          } else {
            var view = HEAPF32.subarray(value >>> 2 >>> 0, value + count * 8 >>> 2 >>> 0);
          }
          GLctx.uniform2fv(webglGetUniformLocation(location), view);
        }
        _glUniform2fv.sig = "viip";
        var _emscripten_glUniform2fv = _glUniform2fv;
        var _glUniform2i = (location, v0, v1) => {
          GLctx.uniform2i(webglGetUniformLocation(location), v0, v1);
        };
        _glUniform2i.sig = "viii";
        var _emscripten_glUniform2i = _glUniform2i;
        function _glUniform2iv(location, count, value) {
          value >>>= 0;
          if (count <= 144) {
            var view = miniTempWebGLIntBuffers[2 * count - 1];
            for (var i2 = 0; i2 < 2 * count; i2 += 2) {
              view[i2] = HEAP32[value + 4 * i2 >>> 2 >>> 0];
              view[i2 + 1] = HEAP32[value + (4 * i2 + 4) >>> 2 >>> 0];
            }
          } else {
            var view = HEAP32.subarray(value >>> 2 >>> 0, value + count * 8 >>> 2 >>> 0);
          }
          GLctx.uniform2iv(webglGetUniformLocation(location), view);
        }
        _glUniform2iv.sig = "viip";
        var _emscripten_glUniform2iv = _glUniform2iv;
        var _glUniform3f = (location, v0, v1, v2) => {
          GLctx.uniform3f(webglGetUniformLocation(location), v0, v1, v2);
        };
        _glUniform3f.sig = "vifff";
        var _emscripten_glUniform3f = _glUniform3f;
        function _glUniform3fv(location, count, value) {
          value >>>= 0;
          if (count <= 96) {
            var view = miniTempWebGLFloatBuffers[3 * count - 1];
            for (var i2 = 0; i2 < 3 * count; i2 += 3) {
              view[i2] = HEAPF32[value + 4 * i2 >>> 2 >>> 0];
              view[i2 + 1] = HEAPF32[value + (4 * i2 + 4) >>> 2 >>> 0];
              view[i2 + 2] = HEAPF32[value + (4 * i2 + 8) >>> 2 >>> 0];
            }
          } else {
            var view = HEAPF32.subarray(value >>> 2 >>> 0, value + count * 12 >>> 2 >>> 0);
          }
          GLctx.uniform3fv(webglGetUniformLocation(location), view);
        }
        _glUniform3fv.sig = "viip";
        var _emscripten_glUniform3fv = _glUniform3fv;
        var _glUniform3i = (location, v0, v1, v2) => {
          GLctx.uniform3i(webglGetUniformLocation(location), v0, v1, v2);
        };
        _glUniform3i.sig = "viiii";
        var _emscripten_glUniform3i = _glUniform3i;
        function _glUniform3iv(location, count, value) {
          value >>>= 0;
          if (count <= 96) {
            var view = miniTempWebGLIntBuffers[3 * count - 1];
            for (var i2 = 0; i2 < 3 * count; i2 += 3) {
              view[i2] = HEAP32[value + 4 * i2 >>> 2 >>> 0];
              view[i2 + 1] = HEAP32[value + (4 * i2 + 4) >>> 2 >>> 0];
              view[i2 + 2] = HEAP32[value + (4 * i2 + 8) >>> 2 >>> 0];
            }
          } else {
            var view = HEAP32.subarray(value >>> 2 >>> 0, value + count * 12 >>> 2 >>> 0);
          }
          GLctx.uniform3iv(webglGetUniformLocation(location), view);
        }
        _glUniform3iv.sig = "viip";
        var _emscripten_glUniform3iv = _glUniform3iv;
        var _glUniform4f = (location, v0, v1, v2, v3) => {
          GLctx.uniform4f(webglGetUniformLocation(location), v0, v1, v2, v3);
        };
        _glUniform4f.sig = "viffff";
        var _emscripten_glUniform4f = _glUniform4f;
        function _glUniform4fv(location, count, value) {
          value >>>= 0;
          if (count <= 72) {
            var view = miniTempWebGLFloatBuffers[4 * count - 1];
            var heap = HEAPF32;
            value >>= 2;
            for (var i2 = 0; i2 < 4 * count; i2 += 4) {
              var dst = value + i2;
              view[i2] = heap[dst >>> 0];
              view[i2 + 1] = heap[dst + 1 >>> 0];
              view[i2 + 2] = heap[dst + 2 >>> 0];
              view[i2 + 3] = heap[dst + 3 >>> 0];
            }
          } else {
            var view = HEAPF32.subarray(value >>> 2 >>> 0, value + count * 16 >>> 2 >>> 0);
          }
          GLctx.uniform4fv(webglGetUniformLocation(location), view);
        }
        _glUniform4fv.sig = "viip";
        var _emscripten_glUniform4fv = _glUniform4fv;
        var _glUniform4i = (location, v0, v1, v2, v3) => {
          GLctx.uniform4i(webglGetUniformLocation(location), v0, v1, v2, v3);
        };
        _glUniform4i.sig = "viiiii";
        var _emscripten_glUniform4i = _glUniform4i;
        function _glUniform4iv(location, count, value) {
          value >>>= 0;
          if (count <= 72) {
            var view = miniTempWebGLIntBuffers[4 * count - 1];
            for (var i2 = 0; i2 < 4 * count; i2 += 4) {
              view[i2] = HEAP32[value + 4 * i2 >>> 2 >>> 0];
              view[i2 + 1] = HEAP32[value + (4 * i2 + 4) >>> 2 >>> 0];
              view[i2 + 2] = HEAP32[value + (4 * i2 + 8) >>> 2 >>> 0];
              view[i2 + 3] = HEAP32[value + (4 * i2 + 12) >>> 2 >>> 0];
            }
          } else {
            var view = HEAP32.subarray(value >>> 2 >>> 0, value + count * 16 >>> 2 >>> 0);
          }
          GLctx.uniform4iv(webglGetUniformLocation(location), view);
        }
        _glUniform4iv.sig = "viip";
        var _emscripten_glUniform4iv = _glUniform4iv;
        function _glUniformMatrix2fv(location, count, transpose, value) {
          value >>>= 0;
          if (count <= 72) {
            var view = miniTempWebGLFloatBuffers[4 * count - 1];
            for (var i2 = 0; i2 < 4 * count; i2 += 4) {
              view[i2] = HEAPF32[value + 4 * i2 >>> 2 >>> 0];
              view[i2 + 1] = HEAPF32[value + (4 * i2 + 4) >>> 2 >>> 0];
              view[i2 + 2] = HEAPF32[value + (4 * i2 + 8) >>> 2 >>> 0];
              view[i2 + 3] = HEAPF32[value + (4 * i2 + 12) >>> 2 >>> 0];
            }
          } else {
            var view = HEAPF32.subarray(value >>> 2 >>> 0, value + count * 16 >>> 2 >>> 0);
          }
          GLctx.uniformMatrix2fv(webglGetUniformLocation(location), !!transpose, view);
        }
        _glUniformMatrix2fv.sig = "viiip";
        var _emscripten_glUniformMatrix2fv = _glUniformMatrix2fv;
        function _glUniformMatrix3fv(location, count, transpose, value) {
          value >>>= 0;
          if (count <= 32) {
            var view = miniTempWebGLFloatBuffers[9 * count - 1];
            for (var i2 = 0; i2 < 9 * count; i2 += 9) {
              view[i2] = HEAPF32[value + 4 * i2 >>> 2 >>> 0];
              view[i2 + 1] = HEAPF32[value + (4 * i2 + 4) >>> 2 >>> 0];
              view[i2 + 2] = HEAPF32[value + (4 * i2 + 8) >>> 2 >>> 0];
              view[i2 + 3] = HEAPF32[value + (4 * i2 + 12) >>> 2 >>> 0];
              view[i2 + 4] = HEAPF32[value + (4 * i2 + 16) >>> 2 >>> 0];
              view[i2 + 5] = HEAPF32[value + (4 * i2 + 20) >>> 2 >>> 0];
              view[i2 + 6] = HEAPF32[value + (4 * i2 + 24) >>> 2 >>> 0];
              view[i2 + 7] = HEAPF32[value + (4 * i2 + 28) >>> 2 >>> 0];
              view[i2 + 8] = HEAPF32[value + (4 * i2 + 32) >>> 2 >>> 0];
            }
          } else {
            var view = HEAPF32.subarray(value >>> 2 >>> 0, value + count * 36 >>> 2 >>> 0);
          }
          GLctx.uniformMatrix3fv(webglGetUniformLocation(location), !!transpose, view);
        }
        _glUniformMatrix3fv.sig = "viiip";
        var _emscripten_glUniformMatrix3fv = _glUniformMatrix3fv;
        function _glUniformMatrix4fv(location, count, transpose, value) {
          value >>>= 0;
          if (count <= 18) {
            var view = miniTempWebGLFloatBuffers[16 * count - 1];
            var heap = HEAPF32;
            value >>= 2;
            for (var i2 = 0; i2 < 16 * count; i2 += 16) {
              var dst = value + i2;
              view[i2] = heap[dst >>> 0];
              view[i2 + 1] = heap[dst + 1 >>> 0];
              view[i2 + 2] = heap[dst + 2 >>> 0];
              view[i2 + 3] = heap[dst + 3 >>> 0];
              view[i2 + 4] = heap[dst + 4 >>> 0];
              view[i2 + 5] = heap[dst + 5 >>> 0];
              view[i2 + 6] = heap[dst + 6 >>> 0];
              view[i2 + 7] = heap[dst + 7 >>> 0];
              view[i2 + 8] = heap[dst + 8 >>> 0];
              view[i2 + 9] = heap[dst + 9 >>> 0];
              view[i2 + 10] = heap[dst + 10 >>> 0];
              view[i2 + 11] = heap[dst + 11 >>> 0];
              view[i2 + 12] = heap[dst + 12 >>> 0];
              view[i2 + 13] = heap[dst + 13 >>> 0];
              view[i2 + 14] = heap[dst + 14 >>> 0];
              view[i2 + 15] = heap[dst + 15 >>> 0];
            }
          } else {
            var view = HEAPF32.subarray(value >>> 2 >>> 0, value + count * 64 >>> 2 >>> 0);
          }
          GLctx.uniformMatrix4fv(webglGetUniformLocation(location), !!transpose, view);
        }
        _glUniformMatrix4fv.sig = "viiip";
        var _emscripten_glUniformMatrix4fv = _glUniformMatrix4fv;
        var _glUseProgram = (program) => {
          program = GL.programs[program];
          GLctx.useProgram(program);
          GLctx.currentProgram = program;
        };
        _glUseProgram.sig = "vi";
        var _emscripten_glUseProgram = _glUseProgram;
        var _glValidateProgram = (program) => {
          GLctx.validateProgram(GL.programs[program]);
        };
        _glValidateProgram.sig = "vi";
        var _emscripten_glValidateProgram = _glValidateProgram;
        function _glVertexAttrib1f(x0, x1) {
          GLctx.vertexAttrib1f(x0, x1);
        }
        _glVertexAttrib1f.sig = "vif";
        var _emscripten_glVertexAttrib1f = _glVertexAttrib1f;
        function _glVertexAttrib1fv(index, v) {
          v >>>= 0;
          GLctx.vertexAttrib1f(index, HEAPF32[v >>> 2]);
        }
        _glVertexAttrib1fv.sig = "vip";
        var _emscripten_glVertexAttrib1fv = _glVertexAttrib1fv;
        function _glVertexAttrib2f(x0, x1, x2) {
          GLctx.vertexAttrib2f(x0, x1, x2);
        }
        _glVertexAttrib2f.sig = "viff";
        var _emscripten_glVertexAttrib2f = _glVertexAttrib2f;
        function _glVertexAttrib2fv(index, v) {
          v >>>= 0;
          GLctx.vertexAttrib2f(index, HEAPF32[v >>> 2], HEAPF32[v + 4 >>> 2]);
        }
        _glVertexAttrib2fv.sig = "vip";
        var _emscripten_glVertexAttrib2fv = _glVertexAttrib2fv;
        function _glVertexAttrib3f(x0, x1, x2, x3) {
          GLctx.vertexAttrib3f(x0, x1, x2, x3);
        }
        _glVertexAttrib3f.sig = "vifff";
        var _emscripten_glVertexAttrib3f = _glVertexAttrib3f;
        function _glVertexAttrib3fv(index, v) {
          v >>>= 0;
          GLctx.vertexAttrib3f(index, HEAPF32[v >>> 2], HEAPF32[v + 4 >>> 2], HEAPF32[v + 8 >>> 2]);
        }
        _glVertexAttrib3fv.sig = "vip";
        var _emscripten_glVertexAttrib3fv = _glVertexAttrib3fv;
        function _glVertexAttrib4f(x0, x1, x2, x3, x4) {
          GLctx.vertexAttrib4f(x0, x1, x2, x3, x4);
        }
        _glVertexAttrib4f.sig = "viffff";
        var _emscripten_glVertexAttrib4f = _glVertexAttrib4f;
        function _glVertexAttrib4fv(index, v) {
          v >>>= 0;
          GLctx.vertexAttrib4f(index, HEAPF32[v >>> 2], HEAPF32[v + 4 >>> 2], HEAPF32[v + 8 >>> 2], HEAPF32[v + 12 >>> 2]);
        }
        _glVertexAttrib4fv.sig = "vip";
        var _emscripten_glVertexAttrib4fv = _glVertexAttrib4fv;
        var _glVertexAttribDivisor = (index, divisor) => {
          GLctx.vertexAttribDivisor(index, divisor);
        };
        _glVertexAttribDivisor.sig = "vii";
        var _glVertexAttribDivisorANGLE = _glVertexAttribDivisor;
        var _emscripten_glVertexAttribDivisorANGLE = _glVertexAttribDivisorANGLE;
        function _glVertexAttribPointer(index, size, type, normalized, stride, ptr2) {
          ptr2 >>>= 0;
          GLctx.vertexAttribPointer(index, size, type, !!normalized, stride, ptr2);
        }
        _glVertexAttribPointer.sig = "viiiiip";
        var _emscripten_glVertexAttribPointer = _glVertexAttribPointer;
        function _glViewport(x0, x1, x2, x3) {
          GLctx.viewport(x0, x1, x2, x3);
        }
        _glViewport.sig = "viiii";
        var _emscripten_glViewport = _glViewport;
        function _emscripten_memcpy_js(dest, src, num) {
          dest >>>= 0;
          src >>>= 0;
          num >>>= 0;
          return HEAPU8.copyWithin(dest >>> 0, src >>> 0, src + num >>> 0);
        }
        _emscripten_memcpy_js.sig = "vppp";
        function _emscripten_out(str) {
          str >>>= 0;
          return out(UTF8ToString(str));
        }
        _emscripten_out.sig = "vp";
        var promiseMap = new HandleAllocator();
        var makePromise = () => {
          var promiseInfo = {};
          promiseInfo.promise = new Promise((resolve, reject) => {
            promiseInfo.reject = reject;
            promiseInfo.resolve = resolve;
          });
          promiseInfo.id = promiseMap.allocate(promiseInfo);
          return promiseInfo;
        };
        function _emscripten_promise_create() {
          return makePromise().id;
        }
        _emscripten_promise_create.sig = "p";
        function _emscripten_promise_destroy(id) {
          id >>>= 0;
          promiseMap.free(id);
        }
        _emscripten_promise_destroy.sig = "vp";
        var getPromise = (id) => promiseMap.get(id).promise;
        function _emscripten_promise_resolve(id, result, value) {
          id >>>= 0;
          value >>>= 0;
          var info2 = promiseMap.get(id);
          switch (result) {
            case 0:
              info2.resolve(value);
              return;
            case 1:
              info2.resolve(getPromise(value));
              return;
            case 2:
              info2.resolve(getPromise(value));
              _emscripten_promise_destroy(value);
              return;
            case 3:
              info2.reject(value);
              return;
          }
        }
        _emscripten_promise_resolve.sig = "vpip";
        var growMemory = (size) => {
          var b = wasmMemory.buffer;
          var pages = (size - b.byteLength + 65535) / 65536;
          try {
            wasmMemory.grow(pages);
            updateMemoryViews();
            return 1;
          } catch (e) {
          }
        };
        function _emscripten_resize_heap(requestedSize) {
          requestedSize >>>= 0;
          var oldSize = HEAPU8.length;
          var maxHeapSize = getHeapMax();
          if (requestedSize > maxHeapSize) {
            return false;
          }
          var alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;
          for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
            var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
            overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
            var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
            var replacement = growMemory(newSize);
            if (replacement) {
              return true;
            }
          }
          return false;
        }
        _emscripten_resize_heap.sig = "ip";
        function _emscripten_wget_data(url2, pbuffer, pnum, perror) {
          url2 >>>= 0;
          pbuffer >>>= 0;
          pnum >>>= 0;
          perror >>>= 0;
          throw "Please compile your program with async support in order to use asynchronous operations like emscripten_wget_data";
        }
        _emscripten_wget_data.sig = "vpppp";
        var getExecutableName = () => thisProgram || "./this.program";
        var getEnvStrings = () => {
          if (!getEnvStrings.strings) {
            var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
            var env = {
              "USER": "web_user",
              "LOGNAME": "web_user",
              "PATH": "/",
              "PWD": "/",
              "HOME": "/home/web_user",
              "LANG": lang,
              "_": getExecutableName()
            };
            for (var x in ENV) {
              if (ENV[x] === void 0)
                delete env[x];
              else
                env[x] = ENV[x];
            }
            var strings = [];
            for (var x in env) {
              strings.push(`${x}=${env[x]}`);
            }
            getEnvStrings.strings = strings;
          }
          return getEnvStrings.strings;
        };
        var stringToAscii = (str, buffer) => {
          for (var i2 = 0; i2 < str.length; ++i2) {
            HEAP8[buffer++ >>> 0 >>> 0] = str.charCodeAt(i2);
          }
          HEAP8[buffer >>> 0 >>> 0] = 0;
        };
        var _environ_get = function(__environ, environ_buf) {
          __environ >>>= 0;
          environ_buf >>>= 0;
          var bufSize = 0;
          getEnvStrings().forEach((string, i2) => {
            var ptr2 = environ_buf + bufSize;
            HEAPU32[__environ + i2 * 4 >>> 2 >>> 0] = ptr2;
            stringToAscii(string, ptr2);
            bufSize += string.length + 1;
          });
          return 0;
        };
        _environ_get.sig = "ipp";
        var _environ_sizes_get = function(penviron_count, penviron_buf_size) {
          penviron_count >>>= 0;
          penviron_buf_size >>>= 0;
          var strings = getEnvStrings();
          HEAPU32[penviron_count >>> 2 >>> 0] = strings.length;
          var bufSize = 0;
          strings.forEach((string) => bufSize += string.length + 1);
          HEAPU32[penviron_buf_size >>> 2 >>> 0] = bufSize;
          return 0;
        };
        _environ_sizes_get.sig = "ipp";
        function _fd_close(fd) {
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            FS.close(stream);
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return e.errno;
          }
        }
        _fd_close.sig = "ii";
        function _fd_fdstat_get(fd, pbuf) {
          pbuf >>>= 0;
          try {
            var rightsBase = 0;
            var rightsInheriting = 0;
            var flags2 = 0;
            {
              var stream = SYSCALLS.getStreamFromFD(fd);
              var type = stream.tty ? 2 : FS.isDir(stream.mode) ? 3 : FS.isLink(stream.mode) ? 7 : 4;
            }
            HEAP8[pbuf >>> 0 >>> 0] = type;
            HEAP16[pbuf + 2 >>> 1 >>> 0] = flags2;
            tempI64 = [rightsBase >>> 0, (tempDouble = rightsBase, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[pbuf + 8 >>> 2 >>> 0] = tempI64[0], HEAP32[pbuf + 12 >>> 2 >>> 0] = tempI64[1];
            tempI64 = [rightsInheriting >>> 0, (tempDouble = rightsInheriting, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[pbuf + 16 >>> 2 >>> 0] = tempI64[0], HEAP32[pbuf + 20 >>> 2 >>> 0] = tempI64[1];
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return e.errno;
          }
        }
        _fd_fdstat_get.sig = "iip";
        var doReadv = (stream, iov, iovcnt, offset) => {
          var ret = 0;
          for (var i2 = 0; i2 < iovcnt; i2++) {
            var ptr2 = HEAPU32[iov >>> 2 >>> 0];
            var len2 = HEAPU32[iov + 4 >>> 2 >>> 0];
            iov += 8;
            var curr = FS.read(stream, HEAP8, ptr2, len2, offset);
            if (curr < 0)
              return -1;
            ret += curr;
            if (curr < len2)
              break;
            if (typeof offset !== "undefined") {
              offset += curr;
            }
          }
          return ret;
        };
        function _fd_pread(fd, iov, iovcnt, offset_low, offset_high, pnum) {
          iov >>>= 0;
          iovcnt >>>= 0;
          var offset = convertI32PairToI53Checked(offset_low, offset_high);
          pnum >>>= 0;
          try {
            if (isNaN(offset))
              return 61;
            var stream = SYSCALLS.getStreamFromFD(fd);
            var num = doReadv(stream, iov, iovcnt, offset);
            HEAPU32[pnum >>> 2 >>> 0] = num;
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return e.errno;
          }
        }
        _fd_pread.sig = "iippiip";
        var doWritev = (stream, iov, iovcnt, offset) => {
          var ret = 0;
          for (var i2 = 0; i2 < iovcnt; i2++) {
            var ptr2 = HEAPU32[iov >>> 2 >>> 0];
            var len2 = HEAPU32[iov + 4 >>> 2 >>> 0];
            iov += 8;
            var curr = FS.write(stream, HEAP8, ptr2, len2, offset);
            if (curr < 0)
              return -1;
            ret += curr;
            if (typeof offset !== "undefined") {
              offset += curr;
            }
          }
          return ret;
        };
        function _fd_pwrite(fd, iov, iovcnt, offset_low, offset_high, pnum) {
          iov >>>= 0;
          iovcnt >>>= 0;
          var offset = convertI32PairToI53Checked(offset_low, offset_high);
          pnum >>>= 0;
          try {
            if (isNaN(offset))
              return 61;
            var stream = SYSCALLS.getStreamFromFD(fd);
            var num = doWritev(stream, iov, iovcnt, offset);
            HEAPU32[pnum >>> 2 >>> 0] = num;
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return e.errno;
          }
        }
        _fd_pwrite.sig = "iippiip";
        function _fd_read(fd, iov, iovcnt, pnum) {
          iov >>>= 0;
          iovcnt >>>= 0;
          pnum >>>= 0;
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            var num = doReadv(stream, iov, iovcnt);
            HEAPU32[pnum >>> 2 >>> 0] = num;
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return e.errno;
          }
        }
        _fd_read.sig = "iippp";
        function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
          var offset = convertI32PairToI53Checked(offset_low, offset_high);
          newOffset >>>= 0;
          try {
            if (isNaN(offset))
              return 61;
            var stream = SYSCALLS.getStreamFromFD(fd);
            FS.llseek(stream, offset, whence);
            tempI64 = [stream.position >>> 0, (tempDouble = stream.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[newOffset >>> 2 >>> 0] = tempI64[0], HEAP32[newOffset + 4 >>> 2 >>> 0] = tempI64[1];
            if (stream.getdents && offset === 0 && whence === 0)
              stream.getdents = null;
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return e.errno;
          }
        }
        _fd_seek.sig = "iiiiip";
        function _fd_sync(fd) {
          var _a;
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            if ((_a = stream.stream_ops) == null ? void 0 : _a.fsync) {
              return stream.stream_ops.fsync(stream);
            }
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return e.errno;
          }
        }
        _fd_sync.sig = "ii";
        function _fd_write(fd, iov, iovcnt, pnum) {
          iov >>>= 0;
          iovcnt >>>= 0;
          pnum >>>= 0;
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            var num = doWritev(stream, iov, iovcnt);
            HEAPU32[pnum >>> 2 >>> 0] = num;
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return e.errno;
          }
        }
        _fd_write.sig = "iippp";
        function _getaddrinfo(node, service, hint, out2) {
          node >>>= 0;
          service >>>= 0;
          hint >>>= 0;
          out2 >>>= 0;
          var addrs = [];
          var canon = null;
          var addr2 = 0;
          var port = 0;
          var flags2 = 0;
          var family = 0;
          var type = 0;
          var proto = 0;
          var ai, last;
          function allocaddrinfo(family2, type2, proto2, canon2, addr3, port2) {
            var sa, salen, ai2;
            var errno;
            salen = family2 === 10 ? 28 : 16;
            addr3 = family2 === 10 ? inetNtop6(addr3) : inetNtop4(addr3);
            sa = _malloc(salen);
            errno = writeSockaddr(sa, family2, addr3, port2);
            assert(!errno);
            ai2 = _malloc(32);
            HEAP32[ai2 + 4 >>> 2 >>> 0] = family2;
            HEAP32[ai2 + 8 >>> 2 >>> 0] = type2;
            HEAP32[ai2 + 12 >>> 2 >>> 0] = proto2;
            HEAPU32[ai2 + 24 >>> 2 >>> 0] = canon2;
            HEAPU32[ai2 + 20 >>> 2 >>> 0] = sa;
            if (family2 === 10) {
              HEAP32[ai2 + 16 >>> 2 >>> 0] = 28;
            } else {
              HEAP32[ai2 + 16 >>> 2 >>> 0] = 16;
            }
            HEAP32[ai2 + 28 >>> 2 >>> 0] = 0;
            return ai2;
          }
          if (hint) {
            flags2 = HEAP32[hint >>> 2 >>> 0];
            family = HEAP32[hint + 4 >>> 2 >>> 0];
            type = HEAP32[hint + 8 >>> 2 >>> 0];
            proto = HEAP32[hint + 12 >>> 2 >>> 0];
          }
          if (type && !proto) {
            proto = type === 2 ? 17 : 6;
          }
          if (!type && proto) {
            type = proto === 17 ? 2 : 1;
          }
          if (proto === 0) {
            proto = 6;
          }
          if (type === 0) {
            type = 1;
          }
          if (!node && !service) {
            return -2;
          }
          if (flags2 & ~(1 | 2 | 4 | 1024 | 8 | 16 | 32)) {
            return -1;
          }
          if (hint !== 0 && HEAP32[hint >>> 2 >>> 0] & 2 && !node) {
            return -1;
          }
          if (flags2 & 32) {
            return -2;
          }
          if (type !== 0 && type !== 1 && type !== 2) {
            return -7;
          }
          if (family !== 0 && family !== 2 && family !== 10) {
            return -6;
          }
          if (service) {
            service = UTF8ToString(service);
            port = parseInt(service, 10);
            if (isNaN(port)) {
              if (flags2 & 1024) {
                return -2;
              }
              return -8;
            }
          }
          if (!node) {
            if (family === 0) {
              family = 2;
            }
            if ((flags2 & 1) === 0) {
              if (family === 2) {
                addr2 = _htonl(2130706433);
              } else {
                addr2 = [0, 0, 0, 1];
              }
            }
            ai = allocaddrinfo(family, type, proto, null, addr2, port);
            HEAPU32[out2 >>> 2 >>> 0] = ai;
            return 0;
          }
          node = UTF8ToString(node);
          addr2 = inetPton4(node);
          if (addr2 !== null) {
            if (family === 0 || family === 2) {
              family = 2;
            } else if (family === 10 && flags2 & 8) {
              addr2 = [0, 0, _htonl(65535), addr2];
              family = 10;
            } else {
              return -2;
            }
          } else {
            addr2 = inetPton6(node);
            if (addr2 !== null) {
              if (family === 0 || family === 10) {
                family = 10;
              } else {
                return -2;
              }
            }
          }
          if (addr2 != null) {
            ai = allocaddrinfo(family, type, proto, node, addr2, port);
            HEAPU32[out2 >>> 2 >>> 0] = ai;
            return 0;
          }
          if (flags2 & 4) {
            return -2;
          }
          node = DNS.lookup_name(node);
          addr2 = inetPton4(node);
          if (family === 0) {
            family = 2;
          } else if (family === 10) {
            addr2 = [0, 0, _htonl(65535), addr2];
          }
          ai = allocaddrinfo(family, type, proto, null, addr2, port);
          HEAPU32[out2 >>> 2 >>> 0] = ai;
          return 0;
        }
        _getaddrinfo.sig = "ipppp";
        function _getentropy(buffer, size) {
          buffer >>>= 0;
          size >>>= 0;
          randomFill(HEAPU8.subarray(buffer >>> 0, buffer + size >>> 0));
          return 0;
        }
        _getentropy.sig = "ipp";
        function _getnameinfo(sa, salen, node, nodelen, serv, servlen, flags2) {
          sa >>>= 0;
          node >>>= 0;
          serv >>>= 0;
          var info2 = readSockaddr(sa, salen);
          if (info2.errno) {
            return -6;
          }
          var port = info2.port;
          var addr2 = info2.addr;
          var overflowed = false;
          if (node && nodelen) {
            var lookup;
            if (flags2 & 1 || !(lookup = DNS.lookup_addr(addr2))) {
              if (flags2 & 8) {
                return -2;
              }
            } else {
              addr2 = lookup;
            }
            var numBytesWrittenExclNull = stringToUTF8(addr2, node, nodelen);
            if (numBytesWrittenExclNull + 1 >= nodelen) {
              overflowed = true;
            }
          }
          if (serv && servlen) {
            port = "" + port;
            var numBytesWrittenExclNull = stringToUTF8(port, serv, servlen);
            if (numBytesWrittenExclNull + 1 >= servlen) {
              overflowed = true;
            }
          }
          if (overflowed) {
            return -12;
          }
          return 0;
        }
        _getnameinfo.sig = "ipipipii";
        function _pthread_kill() {
          return wasmImports["pthread_kill"].apply(null, arguments);
        }
        _pthread_kill.stub = true;
        var arraySum = (array, index) => {
          var sum = 0;
          for (var i2 = 0; i2 <= index; sum += array[i2++]) {
          }
          return sum;
        };
        var MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        var MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        var addDays = (date, days) => {
          var newDate = new Date(date.getTime());
          while (days > 0) {
            var leap = isLeapYear(newDate.getFullYear());
            var currentMonth = newDate.getMonth();
            var daysInCurrentMonth = (leap ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[currentMonth];
            if (days > daysInCurrentMonth - newDate.getDate()) {
              days -= daysInCurrentMonth - newDate.getDate() + 1;
              newDate.setDate(1);
              if (currentMonth < 11) {
                newDate.setMonth(currentMonth + 1);
              } else {
                newDate.setMonth(0);
                newDate.setFullYear(newDate.getFullYear() + 1);
              }
            } else {
              newDate.setDate(newDate.getDate() + days);
              return newDate;
            }
          }
          return newDate;
        };
        var writeArrayToMemory = (array, buffer) => {
          HEAP8.set(array, buffer >>> 0);
        };
        function _strftime(s2, maxsize, format, tm) {
          s2 >>>= 0;
          maxsize >>>= 0;
          format >>>= 0;
          tm >>>= 0;
          var tm_zone = HEAPU32[tm + 40 >>> 2 >>> 0];
          var date = {
            tm_sec: HEAP32[tm >>> 2 >>> 0],
            tm_min: HEAP32[tm + 4 >>> 2 >>> 0],
            tm_hour: HEAP32[tm + 8 >>> 2 >>> 0],
            tm_mday: HEAP32[tm + 12 >>> 2 >>> 0],
            tm_mon: HEAP32[tm + 16 >>> 2 >>> 0],
            tm_year: HEAP32[tm + 20 >>> 2 >>> 0],
            tm_wday: HEAP32[tm + 24 >>> 2 >>> 0],
            tm_yday: HEAP32[tm + 28 >>> 2 >>> 0],
            tm_isdst: HEAP32[tm + 32 >>> 2 >>> 0],
            tm_gmtoff: HEAP32[tm + 36 >>> 2 >>> 0],
            tm_zone: tm_zone ? UTF8ToString(tm_zone) : ""
          };
          var pattern = UTF8ToString(format);
          var EXPANSION_RULES_1 = {
            "%c": "%a %b %d %H:%M:%S %Y",
            "%D": "%m/%d/%y",
            "%F": "%Y-%m-%d",
            "%h": "%b",
            "%r": "%I:%M:%S %p",
            "%R": "%H:%M",
            "%T": "%H:%M:%S",
            "%x": "%m/%d/%y",
            "%X": "%H:%M:%S",
            "%Ec": "%c",
            "%EC": "%C",
            "%Ex": "%m/%d/%y",
            "%EX": "%H:%M:%S",
            "%Ey": "%y",
            "%EY": "%Y",
            "%Od": "%d",
            "%Oe": "%e",
            "%OH": "%H",
            "%OI": "%I",
            "%Om": "%m",
            "%OM": "%M",
            "%OS": "%S",
            "%Ou": "%u",
            "%OU": "%U",
            "%OV": "%V",
            "%Ow": "%w",
            "%OW": "%W",
            "%Oy": "%y"
          };
          for (var rule in EXPANSION_RULES_1) {
            pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_1[rule]);
          }
          var WEEKDAYS = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
          var MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
          function leadingSomething(value, digits, character) {
            var str = typeof value == "number" ? value.toString() : value || "";
            while (str.length < digits) {
              str = character[0] + str;
            }
            return str;
          }
          function leadingNulls(value, digits) {
            return leadingSomething(value, digits, "0");
          }
          function compareByDay(date1, date2) {
            function sgn(value) {
              return value < 0 ? -1 : value > 0 ? 1 : 0;
            }
            var compare;
            if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {
              if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {
                compare = sgn(date1.getDate() - date2.getDate());
              }
            }
            return compare;
          }
          function getFirstWeekStartDate(janFourth) {
            switch (janFourth.getDay()) {
              case 0:
                return new Date(janFourth.getFullYear() - 1, 11, 29);
              case 1:
                return janFourth;
              case 2:
                return new Date(janFourth.getFullYear(), 0, 3);
              case 3:
                return new Date(janFourth.getFullYear(), 0, 2);
              case 4:
                return new Date(janFourth.getFullYear(), 0, 1);
              case 5:
                return new Date(janFourth.getFullYear() - 1, 11, 31);
              case 6:
                return new Date(janFourth.getFullYear() - 1, 11, 30);
            }
          }
          function getWeekBasedYear(date2) {
            var thisDate = addDays(new Date(date2.tm_year + 1900, 0, 1), date2.tm_yday);
            var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);
            var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);
            var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
            var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
            if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {
              if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {
                return thisDate.getFullYear() + 1;
              }
              return thisDate.getFullYear();
            }
            return thisDate.getFullYear() - 1;
          }
          var EXPANSION_RULES_2 = {
            "%a": (date2) => WEEKDAYS[date2.tm_wday].substring(0, 3),
            "%A": (date2) => WEEKDAYS[date2.tm_wday],
            "%b": (date2) => MONTHS[date2.tm_mon].substring(0, 3),
            "%B": (date2) => MONTHS[date2.tm_mon],
            "%C": (date2) => {
              var year = date2.tm_year + 1900;
              return leadingNulls(year / 100 | 0, 2);
            },
            "%d": (date2) => leadingNulls(date2.tm_mday, 2),
            "%e": (date2) => leadingSomething(date2.tm_mday, 2, " "),
            "%g": (date2) => getWeekBasedYear(date2).toString().substring(2),
            "%G": getWeekBasedYear,
            "%H": (date2) => leadingNulls(date2.tm_hour, 2),
            "%I": (date2) => {
              var twelveHour = date2.tm_hour;
              if (twelveHour == 0)
                twelveHour = 12;
              else if (twelveHour > 12)
                twelveHour -= 12;
              return leadingNulls(twelveHour, 2);
            },
            "%j": (date2) => leadingNulls(date2.tm_mday + arraySum(isLeapYear(date2.tm_year + 1900) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, date2.tm_mon - 1), 3),
            "%m": (date2) => leadingNulls(date2.tm_mon + 1, 2),
            "%M": (date2) => leadingNulls(date2.tm_min, 2),
            "%n": () => "\n",
            "%p": (date2) => {
              if (date2.tm_hour >= 0 && date2.tm_hour < 12) {
                return "AM";
              }
              return "PM";
            },
            "%S": (date2) => leadingNulls(date2.tm_sec, 2),
            "%t": () => "	",
            "%u": (date2) => date2.tm_wday || 7,
            "%U": (date2) => {
              var days = date2.tm_yday + 7 - date2.tm_wday;
              return leadingNulls(Math.floor(days / 7), 2);
            },
            "%V": (date2) => {
              var val = Math.floor((date2.tm_yday + 7 - (date2.tm_wday + 6) % 7) / 7);
              if ((date2.tm_wday + 371 - date2.tm_yday - 2) % 7 <= 2) {
                val++;
              }
              if (!val) {
                val = 52;
                var dec31 = (date2.tm_wday + 7 - date2.tm_yday - 1) % 7;
                if (dec31 == 4 || dec31 == 5 && isLeapYear(date2.tm_year % 400 - 1)) {
                  val++;
                }
              } else if (val == 53) {
                var jan1 = (date2.tm_wday + 371 - date2.tm_yday) % 7;
                if (jan1 != 4 && (jan1 != 3 || !isLeapYear(date2.tm_year)))
                  val = 1;
              }
              return leadingNulls(val, 2);
            },
            "%w": (date2) => date2.tm_wday,
            "%W": (date2) => {
              var days = date2.tm_yday + 7 - (date2.tm_wday + 6) % 7;
              return leadingNulls(Math.floor(days / 7), 2);
            },
            "%y": (date2) => (date2.tm_year + 1900).toString().substring(2),
            "%Y": (date2) => date2.tm_year + 1900,
            "%z": (date2) => {
              var off = date2.tm_gmtoff;
              var ahead = off >= 0;
              off = Math.abs(off) / 60;
              off = off / 60 * 100 + off % 60;
              return (ahead ? "+" : "-") + String("0000" + off).slice(-4);
            },
            "%Z": (date2) => date2.tm_zone,
            "%%": () => "%"
          };
          pattern = pattern.replace(/%%/g, "\0\0");
          for (var rule in EXPANSION_RULES_2) {
            if (pattern.includes(rule)) {
              pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_2[rule](date));
            }
          }
          pattern = pattern.replace(/\0\0/g, "%");
          var bytes = intArrayFromString(pattern, false);
          if (bytes.length > maxsize) {
            return 0;
          }
          writeArrayToMemory(bytes, s2);
          return bytes.length - 1;
        }
        _strftime.sig = "ppppp";
        function _strftime_l(s2, maxsize, format, tm, loc) {
          s2 >>>= 0;
          maxsize >>>= 0;
          format >>>= 0;
          tm >>>= 0;
          loc >>>= 0;
          return _strftime(s2, maxsize, format, tm);
        }
        _strftime_l.sig = "pppppp";
        function _strptime(buf, format, tm) {
          buf >>>= 0;
          format >>>= 0;
          tm >>>= 0;
          var pattern = UTF8ToString(format);
          var SPECIAL_CHARS = "\\!@#$^&*()+=-[]/{}|:<>?,.";
          for (var i2 = 0, ii = SPECIAL_CHARS.length; i2 < ii; ++i2) {
            pattern = pattern.replace(new RegExp("\\" + SPECIAL_CHARS[i2], "g"), "\\" + SPECIAL_CHARS[i2]);
          }
          var EQUIVALENT_MATCHERS = {
            "A": "%a",
            "B": "%b",
            "c": "%a %b %d %H:%M:%S %Y",
            "D": "%m\\/%d\\/%y",
            "e": "%d",
            "F": "%Y-%m-%d",
            "h": "%b",
            "R": "%H\\:%M",
            "r": "%I\\:%M\\:%S\\s%p",
            "T": "%H\\:%M\\:%S",
            "x": "%m\\/%d\\/(?:%y|%Y)",
            "X": "%H\\:%M\\:%S"
          };
          var DATE_PATTERNS = {
            "a": "(?:Sun(?:day)?)|(?:Mon(?:day)?)|(?:Tue(?:sday)?)|(?:Wed(?:nesday)?)|(?:Thu(?:rsday)?)|(?:Fri(?:day)?)|(?:Sat(?:urday)?)",
            "b": "(?:Jan(?:uary)?)|(?:Feb(?:ruary)?)|(?:Mar(?:ch)?)|(?:Apr(?:il)?)|May|(?:Jun(?:e)?)|(?:Jul(?:y)?)|(?:Aug(?:ust)?)|(?:Sep(?:tember)?)|(?:Oct(?:ober)?)|(?:Nov(?:ember)?)|(?:Dec(?:ember)?)",
            "C": "\\d\\d",
            "d": "0[1-9]|[1-9](?!\\d)|1\\d|2\\d|30|31",
            "H": "\\d(?!\\d)|[0,1]\\d|20|21|22|23",
            "I": "\\d(?!\\d)|0\\d|10|11|12",
            "j": "00[1-9]|0?[1-9](?!\\d)|0?[1-9]\\d(?!\\d)|[1,2]\\d\\d|3[0-6]\\d",
            "m": "0[1-9]|[1-9](?!\\d)|10|11|12",
            "M": "0\\d|\\d(?!\\d)|[1-5]\\d",
            "n": " ",
            "p": "AM|am|PM|pm|A\\.M\\.|a\\.m\\.|P\\.M\\.|p\\.m\\.",
            "S": "0\\d|\\d(?!\\d)|[1-5]\\d|60",
            "U": "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
            "W": "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
            "w": "[0-6]",
            "y": "\\d\\d",
            "Y": "\\d\\d\\d\\d",
            "t": " ",
            "z": "Z|(?:[\\+\\-]\\d\\d:?(?:\\d\\d)?)"
          };
          var MONTH_NUMBERS = {
            JAN: 0,
            FEB: 1,
            MAR: 2,
            APR: 3,
            MAY: 4,
            JUN: 5,
            JUL: 6,
            AUG: 7,
            SEP: 8,
            OCT: 9,
            NOV: 10,
            DEC: 11
          };
          var DAY_NUMBERS_SUN_FIRST = {
            SUN: 0,
            MON: 1,
            TUE: 2,
            WED: 3,
            THU: 4,
            FRI: 5,
            SAT: 6
          };
          var DAY_NUMBERS_MON_FIRST = {
            MON: 0,
            TUE: 1,
            WED: 2,
            THU: 3,
            FRI: 4,
            SAT: 5,
            SUN: 6
          };
          var capture = [];
          var pattern_out = pattern.replace(/%(.)/g, (m, c) => EQUIVALENT_MATCHERS[c] || m).replace(/%(.)/g, (_, c) => {
            let pat = DATE_PATTERNS[c];
            if (pat) {
              capture.push(c);
              return `(${pat})`;
            } else {
              return c;
            }
          }).replace(/\s+/g, "\\s*");
          var matches = new RegExp("^" + pattern_out, "i").exec(UTF8ToString(buf));
          function initDate() {
            function fixup(value2, min, max) {
              return typeof value2 != "number" || isNaN(value2) ? min : value2 >= min ? value2 <= max ? value2 : max : min;
            }
            return {
              year: fixup(HEAP32[tm + 20 >>> 2 >>> 0] + 1900, 1970, 9999),
              month: fixup(HEAP32[tm + 16 >>> 2 >>> 0], 0, 11),
              day: fixup(HEAP32[tm + 12 >>> 2 >>> 0], 1, 31),
              hour: fixup(HEAP32[tm + 8 >>> 2 >>> 0], 0, 23),
              min: fixup(HEAP32[tm + 4 >>> 2 >>> 0], 0, 59),
              sec: fixup(HEAP32[tm >>> 2 >>> 0], 0, 59),
              gmtoff: 0
            };
          }
          if (matches) {
            var date = initDate();
            var value;
            var getMatch = (symbol) => {
              var pos = capture.indexOf(symbol);
              if (pos >= 0) {
                return matches[pos + 1];
              }
              return;
            };
            if (value = getMatch("S")) {
              date.sec = jstoi_q(value);
            }
            if (value = getMatch("M")) {
              date.min = jstoi_q(value);
            }
            if (value = getMatch("H")) {
              date.hour = jstoi_q(value);
            } else if (value = getMatch("I")) {
              var hour = jstoi_q(value);
              if (value = getMatch("p")) {
                hour += value.toUpperCase()[0] === "P" ? 12 : 0;
              }
              date.hour = hour;
            }
            if (value = getMatch("Y")) {
              date.year = jstoi_q(value);
            } else if (value = getMatch("y")) {
              var year = jstoi_q(value);
              if (value = getMatch("C")) {
                year += jstoi_q(value) * 100;
              } else {
                year += year < 69 ? 2e3 : 1900;
              }
              date.year = year;
            }
            if (value = getMatch("m")) {
              date.month = jstoi_q(value) - 1;
            } else if (value = getMatch("b")) {
              date.month = MONTH_NUMBERS[value.substring(0, 3).toUpperCase()] || 0;
            }
            if (value = getMatch("d")) {
              date.day = jstoi_q(value);
            } else if (value = getMatch("j")) {
              var day = jstoi_q(value);
              var leapYear = isLeapYear(date.year);
              for (var month = 0; month < 12; ++month) {
                var daysUntilMonth = arraySum(leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, month - 1);
                if (day <= daysUntilMonth + (leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[month]) {
                  date.day = day - daysUntilMonth;
                }
              }
            } else if (value = getMatch("a")) {
              var weekDay = value.substring(0, 3).toUpperCase();
              if (value = getMatch("U")) {
                var weekDayNumber = DAY_NUMBERS_SUN_FIRST[weekDay];
                var weekNumber = jstoi_q(value);
                var janFirst = new Date(date.year, 0, 1);
                var endDate;
                if (janFirst.getDay() === 0) {
                  endDate = addDays(janFirst, weekDayNumber + 7 * (weekNumber - 1));
                } else {
                  endDate = addDays(janFirst, 7 - janFirst.getDay() + weekDayNumber + 7 * (weekNumber - 1));
                }
                date.day = endDate.getDate();
                date.month = endDate.getMonth();
              } else if (value = getMatch("W")) {
                var weekDayNumber = DAY_NUMBERS_MON_FIRST[weekDay];
                var weekNumber = jstoi_q(value);
                var janFirst = new Date(date.year, 0, 1);
                var endDate;
                if (janFirst.getDay() === 1) {
                  endDate = addDays(janFirst, weekDayNumber + 7 * (weekNumber - 1));
                } else {
                  endDate = addDays(janFirst, 7 - janFirst.getDay() + 1 + weekDayNumber + 7 * (weekNumber - 1));
                }
                date.day = endDate.getDate();
                date.month = endDate.getMonth();
              }
            }
            if (value = getMatch("z")) {
              if (value.toLowerCase() === "z") {
                date.gmtoff = 0;
              } else {
                var match = value.match(/^((?:\-|\+)\d\d):?(\d\d)?/);
                date.gmtoff = match[1] * 3600;
                if (match[2]) {
                  date.gmtoff += date.gmtoff > 0 ? match[2] * 60 : -match[2] * 60;
                }
              }
            }
            var fullDate = new Date(date.year, date.month, date.day, date.hour, date.min, date.sec, 0);
            HEAP32[tm >>> 2 >>> 0] = fullDate.getSeconds();
            HEAP32[tm + 4 >>> 2 >>> 0] = fullDate.getMinutes();
            HEAP32[tm + 8 >>> 2 >>> 0] = fullDate.getHours();
            HEAP32[tm + 12 >>> 2 >>> 0] = fullDate.getDate();
            HEAP32[tm + 16 >>> 2 >>> 0] = fullDate.getMonth();
            HEAP32[tm + 20 >>> 2 >>> 0] = fullDate.getFullYear() - 1900;
            HEAP32[tm + 24 >>> 2 >>> 0] = fullDate.getDay();
            HEAP32[tm + 28 >>> 2 >>> 0] = arraySum(isLeapYear(fullDate.getFullYear()) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, fullDate.getMonth() - 1) + fullDate.getDate() - 1;
            HEAP32[tm + 32 >>> 2 >>> 0] = 0;
            HEAP32[tm + 36 >>> 2 >>> 0] = date.gmtoff;
            return buf + intArrayFromString(matches[0]).length - 1;
          }
          return 0;
        }
        _strptime.sig = "pppp";
        var getCFunc = (ident) => {
          var func2 = Module["_" + ident];
          return func2;
        };
        var ccall = (ident, returnType, argTypes, args2, opts) => {
          var toC = {
            "string": (str) => {
              var ret2 = 0;
              if (str !== null && str !== void 0 && str !== 0) {
                ret2 = stringToUTF8OnStack(str);
              }
              return ret2;
            },
            "array": (arr) => {
              var ret2 = stackAlloc(arr.length);
              writeArrayToMemory(arr, ret2);
              return ret2;
            }
          };
          function convertReturnValue(ret2) {
            if (returnType === "string") {
              return UTF8ToString(ret2);
            }
            if (returnType === "boolean")
              return Boolean(ret2);
            return ret2;
          }
          var func2 = getCFunc(ident);
          var cArgs = [];
          var stack = 0;
          if (args2) {
            for (var i2 = 0; i2 < args2.length; i2++) {
              var converter = toC[argTypes[i2]];
              if (converter) {
                if (stack === 0)
                  stack = stackSave();
                cArgs[i2] = converter(args2[i2]);
              } else {
                cArgs[i2] = args2[i2];
              }
            }
          }
          var ret = func2.apply(null, cArgs);
          function onDone(ret2) {
            if (stack !== 0)
              stackRestore(stack);
            return convertReturnValue(ret2);
          }
          ret = onDone(ret);
          return ret;
        };
        var writeI53ToI64Clamped = (ptr2, num) => {
          if (num > 9223372036854776e3) {
            HEAPU32[ptr2 >>> 2 >>> 0] = 4294967295;
            HEAPU32[ptr2 + 4 >>> 2 >>> 0] = 2147483647;
          } else if (num < -9223372036854776e3) {
            HEAPU32[ptr2 >>> 2 >>> 0] = 0;
            HEAPU32[ptr2 + 4 >>> 2 >>> 0] = 2147483648;
          } else {
            writeI53ToI64(ptr2, num);
          }
        };
        var writeI53ToI64Signaling = (ptr2, num) => {
          if (num > 9223372036854776e3 || num < -9223372036854776e3) {
            throw `RangeError: ${num}`;
          }
          writeI53ToI64(ptr2, num);
        };
        var writeI53ToU64Clamped = (ptr2, num) => {
          if (num > 18446744073709552e3) {
            HEAPU32[ptr2 >>> 2 >>> 0] = 4294967295;
            HEAPU32[ptr2 + 4 >>> 2 >>> 0] = 4294967295;
          } else if (num < 0) {
            HEAPU32[ptr2 >>> 2 >>> 0] = 0;
            HEAPU32[ptr2 + 4 >>> 2 >>> 0] = 0;
          } else {
            writeI53ToI64(ptr2, num);
          }
        };
        var writeI53ToU64Signaling = (ptr2, num) => {
          if (num < 0 || num > 18446744073709552e3) {
            throw `RangeError: ${num}`;
          }
          writeI53ToI64(ptr2, num);
        };
        var readI53FromU64 = (ptr2) => HEAPU32[ptr2 >>> 2 >>> 0] + HEAPU32[ptr2 + 4 >>> 2 >>> 0] * 4294967296;
        var convertI32PairToI53 = (lo, hi) => (lo >>> 0) + hi * 4294967296;
        var convertU32PairToI53 = (lo, hi) => (lo >>> 0) + (hi >>> 0) * 4294967296;
        var ptrToString = (ptr2) => "0x" + ptr2.toString(16).padStart(8, "0");
        function _emscripten_notify_memory_growth(memoryIndex) {
          memoryIndex >>>= 0;
          updateMemoryViews();
        }
        _emscripten_notify_memory_growth.sig = "vp";
        function ___asctime_r(tmPtr, buf) {
          tmPtr >>>= 0;
          buf >>>= 0;
          var date = {
            tm_sec: HEAP32[tmPtr >>> 2 >>> 0],
            tm_min: HEAP32[tmPtr + 4 >>> 2 >>> 0],
            tm_hour: HEAP32[tmPtr + 8 >>> 2 >>> 0],
            tm_mday: HEAP32[tmPtr + 12 >>> 2 >>> 0],
            tm_mon: HEAP32[tmPtr + 16 >>> 2 >>> 0],
            tm_year: HEAP32[tmPtr + 20 >>> 2 >>> 0],
            tm_wday: HEAP32[tmPtr + 24 >>> 2 >>> 0]
          };
          var days = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
          var months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
          var s2 = days[date.tm_wday] + " " + months[date.tm_mon] + (date.tm_mday < 10 ? "  " : " ") + date.tm_mday + (date.tm_hour < 10 ? " 0" : " ") + date.tm_hour + (date.tm_min < 10 ? ":0" : ":") + date.tm_min + (date.tm_sec < 10 ? ":0" : ":") + date.tm_sec + " " + (1900 + date.tm_year) + "\n";
          stringToUTF8(s2, buf, 26);
          return buf;
        }
        ___asctime_r.sig = "ppp";
        function _strptime_l(buf, format, tm, locale) {
          buf >>>= 0;
          format >>>= 0;
          tm >>>= 0;
          locale >>>= 0;
          return _strptime(buf, format, tm);
        }
        _strptime_l.sig = "ppppp";
        var ERRNO_CODES = {
          "EPERM": 63,
          "ENOENT": 44,
          "ESRCH": 71,
          "EINTR": 27,
          "EIO": 29,
          "ENXIO": 60,
          "E2BIG": 1,
          "ENOEXEC": 45,
          "EBADF": 8,
          "ECHILD": 12,
          "EAGAIN": 6,
          "EWOULDBLOCK": 6,
          "ENOMEM": 48,
          "EACCES": 2,
          "EFAULT": 21,
          "ENOTBLK": 105,
          "EBUSY": 10,
          "EEXIST": 20,
          "EXDEV": 75,
          "ENODEV": 43,
          "ENOTDIR": 54,
          "EISDIR": 31,
          "EINVAL": 28,
          "ENFILE": 41,
          "EMFILE": 33,
          "ENOTTY": 59,
          "ETXTBSY": 74,
          "EFBIG": 22,
          "ENOSPC": 51,
          "ESPIPE": 70,
          "EROFS": 69,
          "EMLINK": 34,
          "EPIPE": 64,
          "EDOM": 18,
          "ERANGE": 68,
          "ENOMSG": 49,
          "EIDRM": 24,
          "ECHRNG": 106,
          "EL2NSYNC": 156,
          "EL3HLT": 107,
          "EL3RST": 108,
          "ELNRNG": 109,
          "EUNATCH": 110,
          "ENOCSI": 111,
          "EL2HLT": 112,
          "EDEADLK": 16,
          "ENOLCK": 46,
          "EBADE": 113,
          "EBADR": 114,
          "EXFULL": 115,
          "ENOANO": 104,
          "EBADRQC": 103,
          "EBADSLT": 102,
          "EDEADLOCK": 16,
          "EBFONT": 101,
          "ENOSTR": 100,
          "ENODATA": 116,
          "ETIME": 117,
          "ENOSR": 118,
          "ENONET": 119,
          "ENOPKG": 120,
          "EREMOTE": 121,
          "ENOLINK": 47,
          "EADV": 122,
          "ESRMNT": 123,
          "ECOMM": 124,
          "EPROTO": 65,
          "EMULTIHOP": 36,
          "EDOTDOT": 125,
          "EBADMSG": 9,
          "ENOTUNIQ": 126,
          "EBADFD": 127,
          "EREMCHG": 128,
          "ELIBACC": 129,
          "ELIBBAD": 130,
          "ELIBSCN": 131,
          "ELIBMAX": 132,
          "ELIBEXEC": 133,
          "ENOSYS": 52,
          "ENOTEMPTY": 55,
          "ENAMETOOLONG": 37,
          "ELOOP": 32,
          "EOPNOTSUPP": 138,
          "EPFNOSUPPORT": 139,
          "ECONNRESET": 15,
          "ENOBUFS": 42,
          "EAFNOSUPPORT": 5,
          "EPROTOTYPE": 67,
          "ENOTSOCK": 57,
          "ENOPROTOOPT": 50,
          "ESHUTDOWN": 140,
          "ECONNREFUSED": 14,
          "EADDRINUSE": 3,
          "ECONNABORTED": 13,
          "ENETUNREACH": 40,
          "ENETDOWN": 38,
          "ETIMEDOUT": 73,
          "EHOSTDOWN": 142,
          "EHOSTUNREACH": 23,
          "EINPROGRESS": 26,
          "EALREADY": 7,
          "EDESTADDRREQ": 17,
          "EMSGSIZE": 35,
          "EPROTONOSUPPORT": 66,
          "ESOCKTNOSUPPORT": 137,
          "EADDRNOTAVAIL": 4,
          "ENETRESET": 39,
          "EISCONN": 30,
          "ENOTCONN": 53,
          "ETOOMANYREFS": 141,
          "EUSERS": 136,
          "EDQUOT": 19,
          "ESTALE": 72,
          "ENOTSUP": 138,
          "ENOMEDIUM": 148,
          "EILSEQ": 25,
          "EOVERFLOW": 61,
          "ECANCELED": 11,
          "ENOTRECOVERABLE": 56,
          "EOWNERDEAD": 62,
          "ESTRPIPE": 135
        };
        var ERRNO_MESSAGES = {
          0: "Success",
          1: "Arg list too long",
          2: "Permission denied",
          3: "Address already in use",
          4: "Address not available",
          5: "Address family not supported by protocol family",
          6: "No more processes",
          7: "Socket already connected",
          8: "Bad file number",
          9: "Trying to read unreadable message",
          10: "Mount device busy",
          11: "Operation canceled",
          12: "No children",
          13: "Connection aborted",
          14: "Connection refused",
          15: "Connection reset by peer",
          16: "File locking deadlock error",
          17: "Destination address required",
          18: "Math arg out of domain of func",
          19: "Quota exceeded",
          20: "File exists",
          21: "Bad address",
          22: "File too large",
          23: "Host is unreachable",
          24: "Identifier removed",
          25: "Illegal byte sequence",
          26: "Connection already in progress",
          27: "Interrupted system call",
          28: "Invalid argument",
          29: "I/O error",
          30: "Socket is already connected",
          31: "Is a directory",
          32: "Too many symbolic links",
          33: "Too many open files",
          34: "Too many links",
          35: "Message too long",
          36: "Multihop attempted",
          37: "File or path name too long",
          38: "Network interface is not configured",
          39: "Connection reset by network",
          40: "Network is unreachable",
          41: "Too many open files in system",
          42: "No buffer space available",
          43: "No such device",
          44: "No such file or directory",
          45: "Exec format error",
          46: "No record locks available",
          47: "The link has been severed",
          48: "Not enough core",
          49: "No message of desired type",
          50: "Protocol not available",
          51: "No space left on device",
          52: "Function not implemented",
          53: "Socket is not connected",
          54: "Not a directory",
          55: "Directory not empty",
          56: "State not recoverable",
          57: "Socket operation on non-socket",
          59: "Not a typewriter",
          60: "No such device or address",
          61: "Value too large for defined data type",
          62: "Previous owner died",
          63: "Not super-user",
          64: "Broken pipe",
          65: "Protocol error",
          66: "Unknown protocol",
          67: "Protocol wrong type for socket",
          68: "Math result not representable",
          69: "Read only file system",
          70: "Illegal seek",
          71: "No such process",
          72: "Stale file handle",
          73: "Connection timed out",
          74: "Text file busy",
          75: "Cross-device link",
          100: "Device not a stream",
          101: "Bad font file fmt",
          102: "Invalid slot",
          103: "Invalid request code",
          104: "No anode",
          105: "Block device required",
          106: "Channel number out of range",
          107: "Level 3 halted",
          108: "Level 3 reset",
          109: "Link number out of range",
          110: "Protocol driver not attached",
          111: "No CSI structure available",
          112: "Level 2 halted",
          113: "Invalid exchange",
          114: "Invalid request descriptor",
          115: "Exchange full",
          116: "No data (for no delay io)",
          117: "Timer expired",
          118: "Out of streams resources",
          119: "Machine is not on the network",
          120: "Package not installed",
          121: "The object is remote",
          122: "Advertise error",
          123: "Srmount error",
          124: "Communication error on send",
          125: "Cross mount point (not really error)",
          126: "Given log. name not unique",
          127: "f.d. invalid for this operation",
          128: "Remote address changed",
          129: "Can   access a needed shared lib",
          130: "Accessing a corrupted shared lib",
          131: ".lib section in a.out corrupted",
          132: "Attempting to link in too many libs",
          133: "Attempting to exec a shared library",
          135: "Streams pipe error",
          136: "Too many users",
          137: "Socket type not supported",
          138: "Not supported",
          139: "Protocol family not supported",
          140: "Can't send after socket shutdown",
          141: "Too many references",
          142: "Host is down",
          148: "No medium (in tape drive)",
          156: "Level 2 not synchronized"
        };
        var Protocols = {
          list: [],
          map: {}
        };
        var _setprotoent = (stayopen) => {
          function allocprotoent(name2, proto, aliases) {
            var nameBuf = _malloc(name2.length + 1);
            stringToAscii(name2, nameBuf);
            var j = 0;
            var length = aliases.length;
            var aliasListBuf = _malloc((length + 1) * 4);
            for (var i2 = 0; i2 < length; i2++, j += 4) {
              var alias = aliases[i2];
              var aliasBuf = _malloc(alias.length + 1);
              stringToAscii(alias, aliasBuf);
              HEAPU32[aliasListBuf + j >>> 2 >>> 0] = aliasBuf;
            }
            HEAPU32[aliasListBuf + j >>> 2 >>> 0] = 0;
            var pe = _malloc(12);
            HEAPU32[pe >>> 2 >>> 0] = nameBuf;
            HEAPU32[pe + 4 >>> 2 >>> 0] = aliasListBuf;
            HEAP32[pe + 8 >>> 2 >>> 0] = proto;
            return pe;
          }
          var list = Protocols.list;
          var map = Protocols.map;
          if (list.length === 0) {
            var entry = allocprotoent("tcp", 6, ["TCP"]);
            list.push(entry);
            map["tcp"] = map["6"] = entry;
            entry = allocprotoent("udp", 17, ["UDP"]);
            list.push(entry);
            map["udp"] = map["17"] = entry;
          }
          _setprotoent.index = 0;
        };
        _setprotoent.sig = "vi";
        var _endprotoent = () => {
        };
        _endprotoent.sig = "v";
        function _getprotoent(number) {
          if (_setprotoent.index === Protocols.list.length) {
            return 0;
          }
          var result = Protocols.list[_setprotoent.index++];
          return result;
        }
        _getprotoent.sig = "p";
        function _getprotobyname(name2) {
          name2 >>>= 0;
          name2 = UTF8ToString(name2);
          _setprotoent(true);
          var result = Protocols.map[name2];
          return result;
        }
        _getprotobyname.sig = "pp";
        function _getprotobynumber(number) {
          _setprotoent(true);
          var result = Protocols.map[number];
          return result;
        }
        _getprotobynumber.sig = "pi";
        function _emscripten_run_script(ptr) {
          ptr >>>= 0;
          eval(UTF8ToString(ptr));
        }
        _emscripten_run_script.sig = "vp";
        function _emscripten_run_script_int(ptr) {
          ptr >>>= 0;
          return eval(UTF8ToString(ptr)) | 0;
        }
        _emscripten_run_script_int.sig = "ip";
        function _emscripten_run_script_string(ptr) {
          ptr >>>= 0;
          var s = eval(UTF8ToString(ptr));
          if (s == null) {
            return 0;
          }
          s += "";
          var me = _emscripten_run_script_string;
          var len = lengthBytesUTF8(s);
          if (!me.bufferSize || me.bufferSize < len + 1) {
            if (me.bufferSize)
              _free(me.buffer);
            me.bufferSize = len + 1;
            me.buffer = _malloc(me.bufferSize);
          }
          stringToUTF8(s, me.buffer, me.bufferSize);
          return me.buffer;
        }
        _emscripten_run_script_string.sig = "pp";
        var _emscripten_random = () => Math.random();
        _emscripten_random.sig = "f";
        function jsStackTrace() {
          var error = new Error();
          if (!error.stack) {
            try {
              throw new Error();
            } catch (e) {
              error = e;
            }
            if (!error.stack) {
              return "(no stack trace available)";
            }
          }
          return error.stack.toString();
        }
        function getCallstack(flags2) {
          var callstack = jsStackTrace();
          var iThisFunc = callstack.lastIndexOf("_emscripten_log");
          var iThisFunc2 = callstack.lastIndexOf("_emscripten_get_callstack");
          var iNextLine = callstack.indexOf("\n", Math.max(iThisFunc, iThisFunc2)) + 1;
          callstack = callstack.slice(iNextLine);
          if (flags2 & 8 && typeof emscripten_source_map == "undefined") {
            warnOnce('Source map information is not available, emscripten_log with EM_LOG_C_STACK will be ignored. Build with "--pre-js $EMSCRIPTEN/src/emscripten-source-map.min.js" linker flag to add source map loading to code.');
            flags2 ^= 8;
            flags2 |= 16;
          }
          var lines = callstack.split("\n");
          callstack = "";
          var newFirefoxRe = new RegExp("\\s*(.*?)@(.*?):([0-9]+):([0-9]+)");
          var firefoxRe = new RegExp("\\s*(.*?)@(.*):(.*)(:(.*))?");
          var chromeRe = new RegExp("\\s*at (.*?) \\((.*):(.*):(.*)\\)");
          for (var l in lines) {
            var line = lines[l];
            var symbolName = "";
            var file = "";
            var lineno = 0;
            var column = 0;
            var parts2 = chromeRe.exec(line);
            if (parts2 && parts2.length == 5) {
              symbolName = parts2[1];
              file = parts2[2];
              lineno = parts2[3];
              column = parts2[4];
            } else {
              parts2 = newFirefoxRe.exec(line);
              if (!parts2)
                parts2 = firefoxRe.exec(line);
              if (parts2 && parts2.length >= 4) {
                symbolName = parts2[1];
                file = parts2[2];
                lineno = parts2[3];
                column = parts2[4] | 0;
              } else {
                callstack += line + "\n";
                continue;
              }
            }
            var haveSourceMap = false;
            if (flags2 & 8) {
              var orig = emscripten_source_map.originalPositionFor({
                line: lineno,
                column
              });
              haveSourceMap = orig == null ? void 0 : orig.source;
              if (haveSourceMap) {
                if (flags2 & 64) {
                  orig.source = orig.source.substring(orig.source.replace(/\\/g, "/").lastIndexOf("/") + 1);
                }
                callstack += `    at ${symbolName} (${orig.source}:${orig.line}:${orig.column})
`;
              }
            }
            if (flags2 & 16 || !haveSourceMap) {
              if (flags2 & 64) {
                file = file.substring(file.replace(/\\/g, "/").lastIndexOf("/") + 1);
              }
              callstack += (haveSourceMap ? `     = ${symbolName}` : `    at ${symbolName}`) + ` (${file}:${lineno}:${column})
`;
            }
          }
          callstack = callstack.replace(/\s+$/, "");
          return callstack;
        }
        function _emscripten_get_callstack(flags2, str, maxbytes) {
          str >>>= 0;
          var callstack = getCallstack(flags2);
          if (!str || maxbytes <= 0) {
            return lengthBytesUTF8(callstack) + 1;
          }
          var bytesWrittenExcludingNull = stringToUTF8(callstack, str, maxbytes);
          return bytesWrittenExcludingNull + 1;
        }
        _emscripten_get_callstack.sig = "iipi";
        var emscriptenLog = (flags2, str) => {
          if (flags2 & 24) {
            str = str.replace(/\s+$/, "");
            str += (str.length > 0 ? "\n" : "") + getCallstack(flags2);
          }
          if (flags2 & 1) {
            if (flags2 & 4) {
              console.error(str);
            } else if (flags2 & 2) {
              console.warn(str);
            } else if (flags2 & 512) {
              console.info(str);
            } else if (flags2 & 256) {
              console.debug(str);
            } else {
              console.log(str);
            }
          } else if (flags2 & 6) {
            err(str);
          } else {
            out(str);
          }
        };
        var reallyNegative = (x) => x < 0 || x === 0 && 1 / x === -Infinity;
        var reSign = (value, bits) => {
          if (value <= 0) {
            return value;
          }
          var half = bits <= 32 ? Math.abs(1 << bits - 1) : Math.pow(2, bits - 1);
          if (value >= half && (bits <= 32 || value > half)) {
            value = -2 * half + value;
          }
          return value;
        };
        var unSign = (value, bits) => {
          if (value >= 0) {
            return value;
          }
          return bits <= 32 ? 2 * Math.abs(1 << bits - 1) + value : Math.pow(2, bits) + value;
        };
        var strLen = (ptr2) => {
          var end = ptr2;
          while (HEAPU8[end >>> 0])
            ++end;
          return end - ptr2;
        };
        var formatString = (format, varargs) => {
          var textIndex = format;
          var argIndex = varargs;
          function prepVararg(ptr3, type) {
            if (type === "double" || type === "i64") {
              if (ptr3 & 7) {
                ptr3 += 4;
              }
            } else {
            }
            return ptr3;
          }
          function getNextArg(type) {
            var ret2;
            argIndex = prepVararg(argIndex, type);
            if (type === "double") {
              ret2 = HEAPF64[argIndex >>> 3 >>> 0];
              argIndex += 8;
            } else if (type == "i64") {
              ret2 = [HEAP32[argIndex >>> 2 >>> 0], HEAP32[argIndex + 4 >>> 2 >>> 0]];
              argIndex += 8;
            } else {
              type = "i32";
              ret2 = HEAP32[argIndex >>> 2 >>> 0];
              argIndex += 4;
            }
            return ret2;
          }
          var ret = [];
          var curr, next, currArg;
          while (1) {
            var startTextIndex = textIndex;
            curr = HEAP8[textIndex >>> 0 >>> 0];
            if (curr === 0)
              break;
            next = HEAP8[textIndex + 1 >>> 0 >>> 0];
            if (curr == 37) {
              var flagAlwaysSigned = false;
              var flagLeftAlign = false;
              var flagAlternative = false;
              var flagZeroPad = false;
              var flagPadSign = false;
              flagsLoop:
                while (1) {
                  switch (next) {
                    case 43:
                      flagAlwaysSigned = true;
                      break;
                    case 45:
                      flagLeftAlign = true;
                      break;
                    case 35:
                      flagAlternative = true;
                      break;
                    case 48:
                      if (flagZeroPad) {
                        break flagsLoop;
                      } else {
                        flagZeroPad = true;
                        break;
                      }
                    case 32:
                      flagPadSign = true;
                      break;
                    default:
                      break flagsLoop;
                  }
                  textIndex++;
                  next = HEAP8[textIndex + 1 >>> 0 >>> 0];
                }
              var width = 0;
              if (next == 42) {
                width = getNextArg("i32");
                textIndex++;
                next = HEAP8[textIndex + 1 >>> 0 >>> 0];
              } else {
                while (next >= 48 && next <= 57) {
                  width = width * 10 + (next - 48);
                  textIndex++;
                  next = HEAP8[textIndex + 1 >>> 0 >>> 0];
                }
              }
              var precisionSet = false, precision = -1;
              if (next == 46) {
                precision = 0;
                precisionSet = true;
                textIndex++;
                next = HEAP8[textIndex + 1 >>> 0 >>> 0];
                if (next == 42) {
                  precision = getNextArg("i32");
                  textIndex++;
                } else {
                  while (1) {
                    var precisionChr = HEAP8[textIndex + 1 >>> 0 >>> 0];
                    if (precisionChr < 48 || precisionChr > 57)
                      break;
                    precision = precision * 10 + (precisionChr - 48);
                    textIndex++;
                  }
                }
                next = HEAP8[textIndex + 1 >>> 0 >>> 0];
              }
              if (precision < 0) {
                precision = 6;
                precisionSet = false;
              }
              var argSize;
              switch (String.fromCharCode(next)) {
                case "h":
                  var nextNext = HEAP8[textIndex + 2 >>> 0 >>> 0];
                  if (nextNext == 104) {
                    textIndex++;
                    argSize = 1;
                  } else {
                    argSize = 2;
                  }
                  break;
                case "l":
                  var nextNext = HEAP8[textIndex + 2 >>> 0 >>> 0];
                  if (nextNext == 108) {
                    textIndex++;
                    argSize = 8;
                  } else {
                    argSize = 4;
                  }
                  break;
                case "L":
                case "q":
                case "j":
                  argSize = 8;
                  break;
                case "z":
                case "t":
                case "I":
                  argSize = 4;
                  break;
                default:
                  argSize = null;
              }
              if (argSize)
                textIndex++;
              next = HEAP8[textIndex + 1 >>> 0 >>> 0];
              switch (String.fromCharCode(next)) {
                case "d":
                case "i":
                case "u":
                case "o":
                case "x":
                case "X":
                case "p": {
                  var signed = next == 100 || next == 105;
                  argSize = argSize || 4;
                  currArg = getNextArg("i" + argSize * 8);
                  var argText;
                  if (argSize == 8) {
                    currArg = next == 117 ? convertU32PairToI53(currArg[0], currArg[1]) : convertI32PairToI53(currArg[0], currArg[1]);
                  }
                  if (argSize <= 4) {
                    var limit = Math.pow(256, argSize) - 1;
                    currArg = (signed ? reSign : unSign)(currArg & limit, argSize * 8);
                  }
                  var currAbsArg = Math.abs(currArg);
                  var prefix = "";
                  if (next == 100 || next == 105) {
                    argText = reSign(currArg, 8 * argSize).toString(10);
                  } else if (next == 117) {
                    argText = unSign(currArg, 8 * argSize).toString(10);
                    currArg = Math.abs(currArg);
                  } else if (next == 111) {
                    argText = (flagAlternative ? "0" : "") + currAbsArg.toString(8);
                  } else if (next == 120 || next == 88) {
                    prefix = flagAlternative && currArg != 0 ? "0x" : "";
                    if (currArg < 0) {
                      currArg = -currArg;
                      argText = (currAbsArg - 1).toString(16);
                      var buffer = [];
                      for (var i2 = 0; i2 < argText.length; i2++) {
                        buffer.push((15 - parseInt(argText[i2], 16)).toString(16));
                      }
                      argText = buffer.join("");
                      while (argText.length < argSize * 2)
                        argText = "f" + argText;
                    } else {
                      argText = currAbsArg.toString(16);
                    }
                    if (next == 88) {
                      prefix = prefix.toUpperCase();
                      argText = argText.toUpperCase();
                    }
                  } else if (next == 112) {
                    if (currAbsArg === 0) {
                      argText = "(nil)";
                    } else {
                      prefix = "0x";
                      argText = currAbsArg.toString(16);
                    }
                  }
                  if (precisionSet) {
                    while (argText.length < precision) {
                      argText = "0" + argText;
                    }
                  }
                  if (currArg >= 0) {
                    if (flagAlwaysSigned) {
                      prefix = "+" + prefix;
                    } else if (flagPadSign) {
                      prefix = " " + prefix;
                    }
                  }
                  if (argText.charAt(0) == "-") {
                    prefix = "-" + prefix;
                    argText = argText.substr(1);
                  }
                  while (prefix.length + argText.length < width) {
                    if (flagLeftAlign) {
                      argText += " ";
                    } else {
                      if (flagZeroPad) {
                        argText = "0" + argText;
                      } else {
                        prefix = " " + prefix;
                      }
                    }
                  }
                  argText = prefix + argText;
                  argText.split("").forEach(function(chr) {
                    ret.push(chr.charCodeAt(0));
                  });
                  break;
                }
                case "f":
                case "F":
                case "e":
                case "E":
                case "g":
                case "G": {
                  currArg = getNextArg("double");
                  var argText;
                  if (isNaN(currArg)) {
                    argText = "nan";
                    flagZeroPad = false;
                  } else if (!isFinite(currArg)) {
                    argText = (currArg < 0 ? "-" : "") + "inf";
                    flagZeroPad = false;
                  } else {
                    var isGeneral = false;
                    var effectivePrecision = Math.min(precision, 20);
                    if (next == 103 || next == 71) {
                      isGeneral = true;
                      precision = precision || 1;
                      var exponent = parseInt(currArg.toExponential(effectivePrecision).split("e")[1], 10);
                      if (precision > exponent && exponent >= -4) {
                        next = (next == 103 ? "f" : "F").charCodeAt(0);
                        precision -= exponent + 1;
                      } else {
                        next = (next == 103 ? "e" : "E").charCodeAt(0);
                        precision--;
                      }
                      effectivePrecision = Math.min(precision, 20);
                    }
                    if (next == 101 || next == 69) {
                      argText = currArg.toExponential(effectivePrecision);
                      if (/[eE][-+]\d$/.test(argText)) {
                        argText = argText.slice(0, -1) + "0" + argText.slice(-1);
                      }
                    } else if (next == 102 || next == 70) {
                      argText = currArg.toFixed(effectivePrecision);
                      if (currArg === 0 && reallyNegative(currArg)) {
                        argText = "-" + argText;
                      }
                    }
                    var parts2 = argText.split("e");
                    if (isGeneral && !flagAlternative) {
                      while (parts2[0].length > 1 && parts2[0].includes(".") && (parts2[0].slice(-1) == "0" || parts2[0].slice(-1) == ".")) {
                        parts2[0] = parts2[0].slice(0, -1);
                      }
                    } else {
                      if (flagAlternative && argText.indexOf(".") == -1)
                        parts2[0] += ".";
                      while (precision > effectivePrecision++)
                        parts2[0] += "0";
                    }
                    argText = parts2[0] + (parts2.length > 1 ? "e" + parts2[1] : "");
                    if (next == 69)
                      argText = argText.toUpperCase();
                    if (currArg >= 0) {
                      if (flagAlwaysSigned) {
                        argText = "+" + argText;
                      } else if (flagPadSign) {
                        argText = " " + argText;
                      }
                    }
                  }
                  while (argText.length < width) {
                    if (flagLeftAlign) {
                      argText += " ";
                    } else {
                      if (flagZeroPad && (argText[0] == "-" || argText[0] == "+")) {
                        argText = argText[0] + "0" + argText.slice(1);
                      } else {
                        argText = (flagZeroPad ? "0" : " ") + argText;
                      }
                    }
                  }
                  if (next < 97)
                    argText = argText.toUpperCase();
                  argText.split("").forEach(function(chr) {
                    ret.push(chr.charCodeAt(0));
                  });
                  break;
                }
                case "s": {
                  var arg = getNextArg("i8*");
                  var argLength = arg ? strLen(arg) : "(null)".length;
                  if (precisionSet)
                    argLength = Math.min(argLength, precision);
                  if (!flagLeftAlign) {
                    while (argLength < width--) {
                      ret.push(32);
                    }
                  }
                  if (arg) {
                    for (var i2 = 0; i2 < argLength; i2++) {
                      ret.push(HEAPU8[arg++ >>> 0 >>> 0]);
                    }
                  } else {
                    ret = ret.concat(intArrayFromString("(null)".substr(0, argLength), true));
                  }
                  if (flagLeftAlign) {
                    while (argLength < width--) {
                      ret.push(32);
                    }
                  }
                  break;
                }
                case "c": {
                  if (flagLeftAlign)
                    ret.push(getNextArg("i8"));
                  while (--width > 0) {
                    ret.push(32);
                  }
                  if (!flagLeftAlign)
                    ret.push(getNextArg("i8"));
                  break;
                }
                case "n": {
                  var ptr2 = getNextArg("i32*");
                  HEAP32[ptr2 >>> 2 >>> 0] = ret.length;
                  break;
                }
                case "%": {
                  ret.push(curr);
                  break;
                }
                default: {
                  for (var i2 = startTextIndex; i2 < textIndex + 2; i2++) {
                    ret.push(HEAP8[i2 >>> 0 >>> 0]);
                  }
                }
              }
              textIndex += 2;
            } else {
              ret.push(curr);
              textIndex += 1;
            }
          }
          return ret;
        };
        function _emscripten_log(flags2, format, varargs) {
          format >>>= 0;
          varargs >>>= 0;
          var result = formatString(format, varargs);
          var str = UTF8ArrayToString(result, 0);
          emscriptenLog(flags2, str);
        }
        _emscripten_log.sig = "vipp";
        function _emscripten_get_compiler_setting(name2) {
          name2 >>>= 0;
          throw "You must build with -sRETAIN_COMPILER_SETTINGS for getCompilerSetting or emscripten_get_compiler_setting to work";
        }
        _emscripten_get_compiler_setting.sig = "pp";
        var _emscripten_has_asyncify = () => 0;
        _emscripten_has_asyncify.sig = "i";
        function _emscripten_debugger() {
          debugger;
        }
        _emscripten_debugger.sig = "v";
        function _emscripten_print_double(x, to, max) {
          to >>>= 0;
          var str = x + "";
          if (to)
            return stringToUTF8(str, to, max);
          else
            return lengthBytesUTF8(str);
        }
        _emscripten_print_double.sig = "idpi";
        var convertFrameToPC = (frame) => {
          abort("Cannot use convertFrameToPC (needed by __builtin_return_address) without -sUSE_OFFSET_CONVERTER");
          return 0;
        };
        function _emscripten_return_address(level) {
          var callstack = jsStackTrace().split("\n");
          if (callstack[0] == "Error") {
            callstack.shift();
          }
          var caller = callstack[level + 3];
          return convertFrameToPC(caller);
        }
        _emscripten_return_address.sig = "pi";
        var UNWIND_CACHE = {};
        var saveInUnwindCache = (callstack) => {
          callstack.forEach((frame) => {
            var pc = convertFrameToPC(frame);
            if (pc) {
              UNWIND_CACHE[pc] = frame;
            }
          });
        };
        function _emscripten_stack_snapshot() {
          var callstack = jsStackTrace().split("\n");
          if (callstack[0] == "Error") {
            callstack.shift();
          }
          saveInUnwindCache(callstack);
          UNWIND_CACHE.last_addr = convertFrameToPC(callstack[3]);
          UNWIND_CACHE.last_stack = callstack;
          return UNWIND_CACHE.last_addr;
        }
        _emscripten_stack_snapshot.sig = "p";
        function _emscripten_stack_unwind_buffer(addr2, buffer, count) {
          addr2 >>>= 0;
          buffer >>>= 0;
          var stack;
          if (UNWIND_CACHE.last_addr == addr2) {
            stack = UNWIND_CACHE.last_stack;
          } else {
            stack = jsStackTrace().split("\n");
            if (stack[0] == "Error") {
              stack.shift();
            }
            saveInUnwindCache(stack);
          }
          var offset = 3;
          while (stack[offset] && convertFrameToPC(stack[offset]) != addr2) {
            ++offset;
          }
          for (var i2 = 0; i2 < count && stack[i2 + offset]; ++i2) {
            HEAP32[buffer + i2 * 4 >>> 2 >>> 0] = convertFrameToPC(stack[i2 + offset]);
          }
          return i2;
        }
        _emscripten_stack_unwind_buffer.sig = "ippi";
        function _emscripten_pc_get_function(pc) {
          pc >>>= 0;
          abort("Cannot use emscripten_pc_get_function without -sUSE_OFFSET_CONVERTER");
          return 0;
        }
        _emscripten_pc_get_function.sig = "pp";
        var convertPCtoSourceLocation = (pc) => {
          if (UNWIND_CACHE.last_get_source_pc == pc)
            return UNWIND_CACHE.last_source;
          var match;
          var source;
          if (!source) {
            var frame = UNWIND_CACHE[pc];
            if (!frame)
              return null;
            if (match = /\((.*):(\d+):(\d+)\)$/.exec(frame)) {
              source = {
                file: match[1],
                line: match[2],
                column: match[3]
              };
            } else if (match = /@(.*):(\d+):(\d+)/.exec(frame)) {
              source = {
                file: match[1],
                line: match[2],
                column: match[3]
              };
            }
          }
          UNWIND_CACHE.last_get_source_pc = pc;
          UNWIND_CACHE.last_source = source;
          return source;
        };
        function _emscripten_pc_get_file(pc) {
          pc >>>= 0;
          var result = convertPCtoSourceLocation(pc);
          if (!result)
            return 0;
          if (_emscripten_pc_get_file.ret)
            _free(_emscripten_pc_get_file.ret);
          _emscripten_pc_get_file.ret = stringToNewUTF8(result.file);
          return _emscripten_pc_get_file.ret;
        }
        _emscripten_pc_get_file.sig = "pp";
        function _emscripten_pc_get_line(pc) {
          pc >>>= 0;
          var result = convertPCtoSourceLocation(pc);
          return result ? result.line : 0;
        }
        _emscripten_pc_get_line.sig = "ip";
        function _emscripten_pc_get_column(pc) {
          pc >>>= 0;
          var result = convertPCtoSourceLocation(pc);
          return result ? result.column || 0 : 0;
        }
        _emscripten_pc_get_column.sig = "ip";
        function _emscripten_get_module_name(buf, length) {
          buf >>>= 0;
          length >>>= 0;
          return stringToUTF8(wasmBinaryFile, buf, length);
        }
        _emscripten_get_module_name.sig = "ppp";
        function _emscripten_asm_const_double(code, sigPtr, argbuf) {
          code >>>= 0;
          sigPtr >>>= 0;
          argbuf >>>= 0;
          return runEmAsmFunction(code, sigPtr, argbuf);
        }
        _emscripten_asm_const_double.sig = "dppp";
        var runMainThreadEmAsm = (code, sigPtr, argbuf, sync2) => {
          var args2 = readEmAsmArgs(sigPtr, argbuf);
          return ASM_CONSTS[code].apply(null, args2);
        };
        function _emscripten_asm_const_int_sync_on_main_thread(code, sigPtr, argbuf) {
          code >>>= 0;
          sigPtr >>>= 0;
          argbuf >>>= 0;
          return runMainThreadEmAsm(code, sigPtr, argbuf, 1);
        }
        _emscripten_asm_const_int_sync_on_main_thread.sig = "ippp";
        function _emscripten_asm_const_ptr_sync_on_main_thread(code, sigPtr, argbuf) {
          code >>>= 0;
          sigPtr >>>= 0;
          argbuf >>>= 0;
          return runMainThreadEmAsm(code, sigPtr, argbuf, 1);
        }
        _emscripten_asm_const_ptr_sync_on_main_thread.sig = "pppp";
        var _emscripten_asm_const_double_sync_on_main_thread = _emscripten_asm_const_int_sync_on_main_thread;
        _emscripten_asm_const_double_sync_on_main_thread.sig = "dppp";
        function _emscripten_asm_const_async_on_main_thread(code, sigPtr, argbuf) {
          code >>>= 0;
          sigPtr >>>= 0;
          argbuf >>>= 0;
          return runMainThreadEmAsm(code, sigPtr, argbuf, 0);
        }
        _emscripten_asm_const_async_on_main_thread.sig = "vppp";
        var jstoi_s = Number;
        function __Unwind_Backtrace(func2, arg) {
          func2 >>>= 0;
          arg >>>= 0;
          var trace = getCallstack();
          var parts2 = trace.split("\n");
          for (var i2 = 0; i2 < parts2.length; i2++) {
            var ret = getWasmTableEntry(func2)(0, arg);
            if (ret !== 0)
              return;
          }
        }
        __Unwind_Backtrace.sig = "ipp";
        function __Unwind_GetIPInfo(context, ipBefore) {
          context >>>= 0;
          ipBefore >>>= 0;
          return abort("Unwind_GetIPInfo");
        }
        __Unwind_GetIPInfo.sig = "ppp";
        function __Unwind_FindEnclosingFunction(ip) {
          ip >>>= 0;
          return 0;
        }
        __Unwind_FindEnclosingFunction.sig = "pp";
        var createDyncallWrapper = (sig) => {
          var sections = [];
          var prelude = [0, 97, 115, 109, 1, 0, 0, 0];
          sections.push(prelude);
          var wrappersig = [sig[0].replace("j", "i"), "i", sig.slice(1).replace(/j/g, "ii")].join("");
          var typeSectionBody = [3];
          generateFuncType(wrappersig, typeSectionBody);
          generateFuncType(sig, typeSectionBody);
          generateFuncType("vi", typeSectionBody);
          var typeSection = [1];
          uleb128Encode(typeSectionBody.length, typeSection);
          typeSection.push.apply(typeSection, typeSectionBody);
          sections.push(typeSection);
          var importSection = [2, 15, 2, 1, 101, 1, 116, 1, 112, 0, 0, 1, 101, 1, 114, 0, 2];
          sections.push(importSection);
          var functionSection = [3, 2, 1, 0];
          sections.push(functionSection);
          var exportSection = [7, 5, 1, 1, 102, 0, 1];
          sections.push(exportSection);
          var convert_code = [];
          if (sig[0] === "j") {
            convert_code = [1, 1, 126];
          } else {
            convert_code.push(0);
          }
          function localGet(j2) {
            convert_code.push(32);
            uleb128Encode(j2, convert_code);
          }
          var j = 1;
          for (var i2 = 1; i2 < sig.length; i2++) {
            if (sig[i2] == "j") {
              localGet(j + 1);
              convert_code.push(173, 66, 32, 134);
              localGet(j);
              convert_code.push(172, 132);
              j += 2;
            } else {
              localGet(j);
              j++;
            }
          }
          convert_code.push(32, 0, 17, 1, 0);
          if (sig[0] === "j") {
            convert_code.push(34);
            uleb128Encode(j, convert_code);
            convert_code.push(66, 32, 136, 167, 16, 0);
            localGet(j);
            convert_code.push(167);
          }
          convert_code.push(11);
          var codeBody = [1];
          uleb128Encode(convert_code.length, codeBody);
          codeBody.push.apply(codeBody, convert_code);
          var codeSection = [10];
          uleb128Encode(codeBody.length, codeSection);
          codeSection.push.apply(codeSection, codeBody);
          sections.push(codeSection);
          var bytes = new Uint8Array([].concat.apply([], sections));
          var module2 = new WebAssembly.Module(bytes);
          var instance2 = new WebAssembly.Instance(module2, {
            "e": {
              "t": wasmTable,
              "r": setTempRet0
            }
          });
          var wrappedFunc = instance2.exports["f"];
          return wrappedFunc;
        };
        var dynCallLegacy = (sig, ptr2, args2) => {
          if (!("dynCall_" + sig in Module)) {
            Module["dynCall_" + sig] = createDyncallWrapper(sig);
          }
          var f = Module["dynCall_" + sig];
          return args2 && args2.length ? f.apply(null, [ptr2].concat(args2)) : f.call(null, ptr2);
        };
        var dynCall = (sig, ptr2, args2) => {
          if (sig.includes("j")) {
            return dynCallLegacy(sig, ptr2, args2);
          }
          var rtn = getWasmTableEntry(ptr2).apply(null, args2);
          return rtn;
        };
        var getDynCaller = (sig, ptr2) => {
          var argCache = [];
          return function() {
            argCache.length = 0;
            Object.assign(argCache, arguments);
            return dynCall(sig, ptr2, argCache);
          };
        };
        var _emscripten_exit_with_live_runtime = () => {
          throw "unwind";
        };
        _emscripten_exit_with_live_runtime.sig = "v";
        var _emscripten_force_exit = (status) => {
          __emscripten_runtime_keepalive_clear();
          _exit(status);
        };
        _emscripten_force_exit.sig = "vi";
        function _emscripten_outn(str, len2) {
          str >>>= 0;
          len2 >>>= 0;
          return out(UTF8ToString(str, len2));
        }
        _emscripten_outn.sig = "vpp";
        function _emscripten_errn(str, len2) {
          str >>>= 0;
          len2 >>>= 0;
          return err(UTF8ToString(str, len2));
        }
        _emscripten_errn.sig = "vpp";
        var _emscripten_throw_number = (number) => {
          throw number;
        };
        _emscripten_throw_number.sig = "vd";
        function _emscripten_throw_string(str) {
          str >>>= 0;
          throw UTF8ToString(str);
        }
        _emscripten_throw_string.sig = "vp";
        var runtimeKeepalivePush = () => {
          runtimeKeepaliveCounter += 1;
        };
        runtimeKeepalivePush.sig = "v";
        var runtimeKeepalivePop = () => {
          runtimeKeepaliveCounter -= 1;
        };
        runtimeKeepalivePop.sig = "v";
        var _emscripten_runtime_keepalive_push = runtimeKeepalivePush;
        _emscripten_runtime_keepalive_push.sig = "v";
        var _emscripten_runtime_keepalive_pop = runtimeKeepalivePop;
        _emscripten_runtime_keepalive_pop.sig = "v";
        var _emscripten_runtime_keepalive_check = keepRuntimeAlive;
        _emscripten_runtime_keepalive_check.sig = "i";
        var asmjsMangle = (x) => {
          var unmangledSymbols = ["stackAlloc", "stackSave", "stackRestore", "getTempRet0", "setTempRet0"];
          if (x == "__main_argc_argv") {
            x = "main";
          }
          return x.indexOf("dynCall_") == 0 || unmangledSymbols.includes(x) ? x : "_" + x;
        };
        var ___global_base = 1024;
        function __emscripten_fs_load_embedded_files(ptr2) {
          ptr2 >>>= 0;
          do {
            var name_addr = HEAPU32[ptr2 >>> 2 >>> 0];
            ptr2 += 4;
            var len2 = HEAPU32[ptr2 >>> 2 >>> 0];
            ptr2 += 4;
            var content = HEAPU32[ptr2 >>> 2 >>> 0];
            ptr2 += 4;
            var name2 = UTF8ToString(name_addr);
            FS.createPath("/", PATH.dirname(name2), true, true);
            FS.createDataFile(name2, null, HEAP8.subarray(content >>> 0, content + len2 >>> 0), true, true, true);
          } while (HEAPU32[ptr2 >>> 2 >>> 0]);
        }
        __emscripten_fs_load_embedded_files.sig = "vp";
        var POINTER_SIZE = 4;
        function getNativeTypeSize(type) {
          switch (type) {
            case "i1":
            case "i8":
            case "u8":
              return 1;
            case "i16":
            case "u16":
              return 2;
            case "i32":
            case "u32":
              return 4;
            case "i64":
            case "u64":
              return 8;
            case "float":
              return 4;
            case "double":
              return 8;
            default: {
              if (type[type.length - 1] === "*") {
                return POINTER_SIZE;
              }
              if (type[0] === "i") {
                const bits = Number(type.substr(1));
                assert(bits % 8 === 0, `getNativeTypeSize invalid bits ${bits}, ${type} type`);
                return bits / 8;
              }
              return 0;
            }
          }
        }
        var STACK_SIZE = 65536;
        var STACK_ALIGN = 16;
        var ASSERTIONS = 0;
        var cwrap = (ident, returnType, argTypes, opts) => {
          var numericArgs = !argTypes || argTypes.every((type) => type === "number" || type === "boolean");
          var numericRet = returnType !== "string";
          if (numericRet && numericArgs && !opts) {
            return getCFunc(ident);
          }
          return function() {
            return ccall(ident, returnType, argTypes, arguments, opts);
          };
        };
        var removeFunction = (index) => {
          functionsInTableMap.delete(getWasmTableEntry(index));
          setWasmTableEntry(index, null);
          freeTableIndexes.push(index);
        };
        var _emscripten_math_cbrt = (x) => Math.cbrt(x);
        _emscripten_math_cbrt.sig = "dd";
        var _emscripten_math_pow = (x, y) => Math.pow(x, y);
        _emscripten_math_pow.sig = "ddd";
        var _emscripten_math_random = () => Math.random();
        _emscripten_math_random.sig = "d";
        var _emscripten_math_sign = (x) => Math.sign(x);
        _emscripten_math_sign.sig = "dd";
        var _emscripten_math_sqrt = (x) => Math.sqrt(x);
        _emscripten_math_sqrt.sig = "dd";
        var _emscripten_math_exp = (x) => Math.exp(x);
        _emscripten_math_exp.sig = "dd";
        var _emscripten_math_expm1 = (x) => Math.expm1(x);
        _emscripten_math_expm1.sig = "dd";
        var _emscripten_math_fmod = (x, y) => x % y;
        _emscripten_math_fmod.sig = "ddd";
        var _emscripten_math_log = (x) => Math.log(x);
        _emscripten_math_log.sig = "dd";
        var _emscripten_math_log1p = (x) => Math.log1p(x);
        _emscripten_math_log1p.sig = "dd";
        var _emscripten_math_log10 = (x) => Math.log10(x);
        _emscripten_math_log10.sig = "dd";
        var _emscripten_math_log2 = (x) => Math.log2(x);
        _emscripten_math_log2.sig = "dd";
        var _emscripten_math_round = (x) => Math.round(x);
        _emscripten_math_round.sig = "dd";
        var _emscripten_math_acos = (x) => Math.acos(x);
        _emscripten_math_acos.sig = "dd";
        var _emscripten_math_acosh = (x) => Math.acosh(x);
        _emscripten_math_acosh.sig = "dd";
        var _emscripten_math_asin = (x) => Math.asin(x);
        _emscripten_math_asin.sig = "dd";
        var _emscripten_math_asinh = (x) => Math.asinh(x);
        _emscripten_math_asinh.sig = "dd";
        var _emscripten_math_atan = (x) => Math.atan(x);
        _emscripten_math_atan.sig = "dd";
        var _emscripten_math_atanh = (x) => Math.atanh(x);
        _emscripten_math_atanh.sig = "dd";
        var _emscripten_math_atan2 = (y, x) => Math.atan2(y, x);
        _emscripten_math_atan2.sig = "ddd";
        var _emscripten_math_cos = (x) => Math.cos(x);
        _emscripten_math_cos.sig = "dd";
        var _emscripten_math_cosh = (x) => Math.cosh(x);
        _emscripten_math_cosh.sig = "dd";
        function _emscripten_math_hypot(count, varargs) {
          varargs >>>= 0;
          var args2 = [];
          for (var i2 = 0; i2 < count; ++i2) {
            args2.push(HEAPF64[varargs + i2 * 8 >>> 3 >>> 0]);
          }
          return Math.hypot.apply(null, args2);
        }
        _emscripten_math_hypot.sig = "dip";
        var _emscripten_math_sin = (x) => Math.sin(x);
        _emscripten_math_sin.sig = "dd";
        var _emscripten_math_sinh = (x) => Math.sinh(x);
        _emscripten_math_sinh.sig = "dd";
        var _emscripten_math_tan = (x) => Math.tan(x);
        _emscripten_math_tan.sig = "dd";
        var _emscripten_math_tanh = (x) => Math.tanh(x);
        _emscripten_math_tanh.sig = "dd";
        function intArrayToString(array) {
          var ret = [];
          for (var i2 = 0; i2 < array.length; i2++) {
            var chr = array[i2];
            if (chr > 255) {
              chr &= 255;
            }
            ret.push(String.fromCharCode(chr));
          }
          return ret.join("");
        }
        var AsciiToString = (ptr2) => {
          ptr2 >>>= 0;
          var str = "";
          while (1) {
            var ch = HEAPU8[ptr2++ >>> 0 >>> 0];
            if (!ch)
              return str;
            str += String.fromCharCode(ch);
          }
        };
        var JSEvents = {
          removeAllEventListeners() {
            while (JSEvents.eventHandlers.length) {
              JSEvents._removeHandler(JSEvents.eventHandlers.length - 1);
            }
            JSEvents.deferredCalls = [];
          },
          inEventHandler: 0,
          deferredCalls: [],
          deferCall(targetFunction, precedence, argsList) {
            function arraysHaveEqualContent(arrA, arrB) {
              if (arrA.length != arrB.length)
                return false;
              for (var i3 in arrA) {
                if (arrA[i3] != arrB[i3])
                  return false;
              }
              return true;
            }
            for (var i2 in JSEvents.deferredCalls) {
              var call = JSEvents.deferredCalls[i2];
              if (call.targetFunction == targetFunction && arraysHaveEqualContent(call.argsList, argsList)) {
                return;
              }
            }
            JSEvents.deferredCalls.push({
              targetFunction,
              precedence,
              argsList
            });
            JSEvents.deferredCalls.sort((x, y) => x.precedence < y.precedence);
          },
          removeDeferredCalls(targetFunction) {
            for (var i2 = 0; i2 < JSEvents.deferredCalls.length; ++i2) {
              if (JSEvents.deferredCalls[i2].targetFunction == targetFunction) {
                JSEvents.deferredCalls.splice(i2, 1);
                --i2;
              }
            }
          },
          canPerformEventHandlerRequests() {
            if (navigator.userActivation) {
              return navigator.userActivation.isActive;
            }
            return JSEvents.inEventHandler && JSEvents.currentEventHandler.allowsDeferredCalls;
          },
          runDeferredCalls() {
            if (!JSEvents.canPerformEventHandlerRequests()) {
              return;
            }
            for (var i2 = 0; i2 < JSEvents.deferredCalls.length; ++i2) {
              var call = JSEvents.deferredCalls[i2];
              JSEvents.deferredCalls.splice(i2, 1);
              --i2;
              call.targetFunction.apply(null, call.argsList);
            }
          },
          eventHandlers: [],
          removeAllHandlersOnTarget: (target, eventTypeString) => {
            for (var i2 = 0; i2 < JSEvents.eventHandlers.length; ++i2) {
              if (JSEvents.eventHandlers[i2].target == target && (!eventTypeString || eventTypeString == JSEvents.eventHandlers[i2].eventTypeString)) {
                JSEvents._removeHandler(i2--);
              }
            }
          },
          _removeHandler(i2) {
            var h = JSEvents.eventHandlers[i2];
            h.target.removeEventListener(h.eventTypeString, h.eventListenerFunc, h.useCapture);
            JSEvents.eventHandlers.splice(i2, 1);
          },
          registerOrRemoveHandler(eventHandler) {
            if (!eventHandler.target) {
              return -4;
            }
            if (eventHandler.callbackfunc) {
              eventHandler.eventListenerFunc = function(event2) {
                ++JSEvents.inEventHandler;
                JSEvents.currentEventHandler = eventHandler;
                JSEvents.runDeferredCalls();
                eventHandler.handlerFunc(event2);
                JSEvents.runDeferredCalls();
                --JSEvents.inEventHandler;
              };
              eventHandler.target.addEventListener(eventHandler.eventTypeString, eventHandler.eventListenerFunc, eventHandler.useCapture);
              JSEvents.eventHandlers.push(eventHandler);
            } else {
              for (var i2 = 0; i2 < JSEvents.eventHandlers.length; ++i2) {
                if (JSEvents.eventHandlers[i2].target == eventHandler.target && JSEvents.eventHandlers[i2].eventTypeString == eventHandler.eventTypeString) {
                  JSEvents._removeHandler(i2--);
                }
              }
            }
            return 0;
          },
          getNodeNameForTarget(target) {
            if (!target)
              return "";
            if (target == window)
              return "#window";
            if (target == screen)
              return "#screen";
            return (target == null ? void 0 : target.nodeName) || "";
          },
          fullscreenEnabled() {
            return document.fullscreenEnabled || document.webkitFullscreenEnabled;
          }
        };
        var maybeCStringToJsString = (cString) => cString > 2 ? UTF8ToString(cString) : cString;
        var specialHTMLTargets = [0, typeof document != "undefined" ? document : 0, typeof window != "undefined" ? window : 0];
        var findEventTarget = (target) => {
          target = maybeCStringToJsString(target);
          var domElement = specialHTMLTargets[target] || (typeof document != "undefined" ? document.querySelector(target) : void 0);
          return domElement;
        };
        var registerKeyEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
          if (!JSEvents.keyEvent)
            JSEvents.keyEvent = _malloc(176);
          var keyEventHandlerFunc = (e) => {
            var keyEventData = JSEvents.keyEvent;
            HEAPF64[keyEventData >>> 3 >>> 0] = e.timeStamp;
            var idx = keyEventData >>> 2;
            HEAP32[idx + 2 >>> 0] = e.location;
            HEAP32[idx + 3 >>> 0] = e.ctrlKey;
            HEAP32[idx + 4 >>> 0] = e.shiftKey;
            HEAP32[idx + 5 >>> 0] = e.altKey;
            HEAP32[idx + 6 >>> 0] = e.metaKey;
            HEAP32[idx + 7 >>> 0] = e.repeat;
            HEAP32[idx + 8 >>> 0] = e.charCode;
            HEAP32[idx + 9 >>> 0] = e.keyCode;
            HEAP32[idx + 10 >>> 0] = e.which;
            stringToUTF8(e.key || "", keyEventData + 44, 32);
            stringToUTF8(e.code || "", keyEventData + 76, 32);
            stringToUTF8(e.char || "", keyEventData + 108, 32);
            stringToUTF8(e.locale || "", keyEventData + 140, 32);
            if (getWasmTableEntry(callbackfunc)(eventTypeId, keyEventData, userData))
              e.preventDefault();
          };
          var eventHandler = {
            target: findEventTarget(target),
            eventTypeString,
            callbackfunc,
            handlerFunc: keyEventHandlerFunc,
            useCapture
          };
          return JSEvents.registerOrRemoveHandler(eventHandler);
        };
        var findCanvasEventTarget = findEventTarget;
        function _emscripten_set_keypress_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
          target >>>= 0;
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          return registerKeyEventCallback(target, userData, useCapture, callbackfunc, 1, "keypress", targetThread);
        }
        _emscripten_set_keypress_callback_on_thread.sig = "ippipp";
        function _emscripten_set_keydown_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
          target >>>= 0;
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          return registerKeyEventCallback(target, userData, useCapture, callbackfunc, 2, "keydown", targetThread);
        }
        _emscripten_set_keydown_callback_on_thread.sig = "ippipp";
        function _emscripten_set_keyup_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
          target >>>= 0;
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          return registerKeyEventCallback(target, userData, useCapture, callbackfunc, 3, "keyup", targetThread);
        }
        _emscripten_set_keyup_callback_on_thread.sig = "ippipp";
        var getBoundingClientRect = (e) => specialHTMLTargets.indexOf(e) < 0 ? e.getBoundingClientRect() : {
          "left": 0,
          "top": 0
        };
        var fillMouseEventData = (eventStruct, e, target) => {
          HEAPF64[eventStruct >>> 3 >>> 0] = e.timeStamp;
          var idx = eventStruct >>> 2;
          HEAP32[idx + 2 >>> 0] = e.screenX;
          HEAP32[idx + 3 >>> 0] = e.screenY;
          HEAP32[idx + 4 >>> 0] = e.clientX;
          HEAP32[idx + 5 >>> 0] = e.clientY;
          HEAP32[idx + 6 >>> 0] = e.ctrlKey;
          HEAP32[idx + 7 >>> 0] = e.shiftKey;
          HEAP32[idx + 8 >>> 0] = e.altKey;
          HEAP32[idx + 9 >>> 0] = e.metaKey;
          HEAP16[idx * 2 + 20 >>> 0] = e.button;
          HEAP16[idx * 2 + 21 >>> 0] = e.buttons;
          HEAP32[idx + 11 >>> 0] = e["movementX"];
          HEAP32[idx + 12 >>> 0] = e["movementY"];
          var rect = getBoundingClientRect(target);
          HEAP32[idx + 13 >>> 0] = e.clientX - rect.left;
          HEAP32[idx + 14 >>> 0] = e.clientY - rect.top;
        };
        var registerMouseEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
          if (!JSEvents.mouseEvent)
            JSEvents.mouseEvent = _malloc(72);
          target = findEventTarget(target);
          var mouseEventHandlerFunc = (e = event) => {
            fillMouseEventData(JSEvents.mouseEvent, e, target);
            if (getWasmTableEntry(callbackfunc)(eventTypeId, JSEvents.mouseEvent, userData))
              e.preventDefault();
          };
          var eventHandler = {
            target,
            allowsDeferredCalls: eventTypeString != "mousemove" && eventTypeString != "mouseenter" && eventTypeString != "mouseleave",
            eventTypeString,
            callbackfunc,
            handlerFunc: mouseEventHandlerFunc,
            useCapture
          };
          return JSEvents.registerOrRemoveHandler(eventHandler);
        };
        function _emscripten_set_click_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
          target >>>= 0;
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          return registerMouseEventCallback(target, userData, useCapture, callbackfunc, 4, "click", targetThread);
        }
        _emscripten_set_click_callback_on_thread.sig = "ippipp";
        function _emscripten_set_mousedown_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
          target >>>= 0;
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          return registerMouseEventCallback(target, userData, useCapture, callbackfunc, 5, "mousedown", targetThread);
        }
        _emscripten_set_mousedown_callback_on_thread.sig = "ippipp";
        function _emscripten_set_mouseup_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
          target >>>= 0;
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          return registerMouseEventCallback(target, userData, useCapture, callbackfunc, 6, "mouseup", targetThread);
        }
        _emscripten_set_mouseup_callback_on_thread.sig = "ippipp";
        function _emscripten_set_dblclick_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
          target >>>= 0;
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          return registerMouseEventCallback(target, userData, useCapture, callbackfunc, 7, "dblclick", targetThread);
        }
        _emscripten_set_dblclick_callback_on_thread.sig = "ippipp";
        function _emscripten_set_mousemove_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
          target >>>= 0;
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          return registerMouseEventCallback(target, userData, useCapture, callbackfunc, 8, "mousemove", targetThread);
        }
        _emscripten_set_mousemove_callback_on_thread.sig = "ippipp";
        function _emscripten_set_mouseenter_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
          target >>>= 0;
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          return registerMouseEventCallback(target, userData, useCapture, callbackfunc, 33, "mouseenter", targetThread);
        }
        _emscripten_set_mouseenter_callback_on_thread.sig = "ippipp";
        function _emscripten_set_mouseleave_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
          target >>>= 0;
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          return registerMouseEventCallback(target, userData, useCapture, callbackfunc, 34, "mouseleave", targetThread);
        }
        _emscripten_set_mouseleave_callback_on_thread.sig = "ippipp";
        function _emscripten_set_mouseover_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
          target >>>= 0;
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          return registerMouseEventCallback(target, userData, useCapture, callbackfunc, 35, "mouseover", targetThread);
        }
        _emscripten_set_mouseover_callback_on_thread.sig = "ippipp";
        function _emscripten_set_mouseout_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
          target >>>= 0;
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          return registerMouseEventCallback(target, userData, useCapture, callbackfunc, 36, "mouseout", targetThread);
        }
        _emscripten_set_mouseout_callback_on_thread.sig = "ippipp";
        function _emscripten_get_mouse_status(mouseState) {
          mouseState >>>= 0;
          if (!JSEvents.mouseEvent)
            return -7;
          HEAP8.set(HEAP8.subarray(JSEvents.mouseEvent >>> 0, JSEvents.mouseEvent + 72 >>> 0), mouseState >>> 0);
          return 0;
        }
        _emscripten_get_mouse_status.sig = "ip";
        var registerWheelEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
          if (!JSEvents.wheelEvent)
            JSEvents.wheelEvent = _malloc(104);
          var wheelHandlerFunc = (e = event) => {
            var wheelEvent = JSEvents.wheelEvent;
            fillMouseEventData(wheelEvent, e, target);
            HEAPF64[wheelEvent + 72 >>> 3 >>> 0] = e["deltaX"];
            HEAPF64[wheelEvent + 80 >>> 3 >>> 0] = e["deltaY"];
            HEAPF64[wheelEvent + 88 >>> 3 >>> 0] = e["deltaZ"];
            HEAP32[wheelEvent + 96 >>> 2 >>> 0] = e["deltaMode"];
            if (getWasmTableEntry(callbackfunc)(eventTypeId, wheelEvent, userData))
              e.preventDefault();
          };
          var eventHandler = {
            target,
            allowsDeferredCalls: true,
            eventTypeString,
            callbackfunc,
            handlerFunc: wheelHandlerFunc,
            useCapture
          };
          return JSEvents.registerOrRemoveHandler(eventHandler);
        };
        function _emscripten_set_wheel_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
          target >>>= 0;
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          target = findEventTarget(target);
          if (!target)
            return -4;
          if (typeof target.onwheel != "undefined") {
            return registerWheelEventCallback(target, userData, useCapture, callbackfunc, 9, "wheel", targetThread);
          } else {
            return -1;
          }
        }
        _emscripten_set_wheel_callback_on_thread.sig = "ippipp";
        var registerUiEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
          if (!JSEvents.uiEvent)
            JSEvents.uiEvent = _malloc(36);
          target = findEventTarget(target);
          var uiEventHandlerFunc = (e = event) => {
            if (e.target != target) {
              return;
            }
            var b = document.body;
            if (!b) {
              return;
            }
            var uiEvent = JSEvents.uiEvent;
            HEAP32[uiEvent >>> 2 >>> 0] = e.detail;
            HEAP32[uiEvent + 4 >>> 2 >>> 0] = b.clientWidth;
            HEAP32[uiEvent + 8 >>> 2 >>> 0] = b.clientHeight;
            HEAP32[uiEvent + 12 >>> 2 >>> 0] = innerWidth;
            HEAP32[uiEvent + 16 >>> 2 >>> 0] = innerHeight;
            HEAP32[uiEvent + 20 >>> 2 >>> 0] = outerWidth;
            HEAP32[uiEvent + 24 >>> 2 >>> 0] = outerHeight;
            HEAP32[uiEvent + 28 >>> 2 >>> 0] = pageXOffset;
            HEAP32[uiEvent + 32 >>> 2 >>> 0] = pageYOffset;
            if (getWasmTableEntry(callbackfunc)(eventTypeId, uiEvent, userData))
              e.preventDefault();
          };
          var eventHandler = {
            target,
            eventTypeString,
            callbackfunc,
            handlerFunc: uiEventHandlerFunc,
            useCapture
          };
          return JSEvents.registerOrRemoveHandler(eventHandler);
        };
        function _emscripten_set_resize_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
          target >>>= 0;
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          return registerUiEventCallback(target, userData, useCapture, callbackfunc, 10, "resize", targetThread);
        }
        _emscripten_set_resize_callback_on_thread.sig = "ippipp";
        function _emscripten_set_scroll_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
          target >>>= 0;
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          return registerUiEventCallback(target, userData, useCapture, callbackfunc, 11, "scroll", targetThread);
        }
        _emscripten_set_scroll_callback_on_thread.sig = "ippipp";
        var registerFocusEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
          if (!JSEvents.focusEvent)
            JSEvents.focusEvent = _malloc(256);
          var focusEventHandlerFunc = (e = event) => {
            var nodeName = JSEvents.getNodeNameForTarget(e.target);
            var id = e.target.id ? e.target.id : "";
            var focusEvent = JSEvents.focusEvent;
            stringToUTF8(nodeName, focusEvent + 0, 128);
            stringToUTF8(id, focusEvent + 128, 128);
            if (getWasmTableEntry(callbackfunc)(eventTypeId, focusEvent, userData))
              e.preventDefault();
          };
          var eventHandler = {
            target: findEventTarget(target),
            eventTypeString,
            callbackfunc,
            handlerFunc: focusEventHandlerFunc,
            useCapture
          };
          return JSEvents.registerOrRemoveHandler(eventHandler);
        };
        function _emscripten_set_blur_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
          target >>>= 0;
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          return registerFocusEventCallback(target, userData, useCapture, callbackfunc, 12, "blur", targetThread);
        }
        _emscripten_set_blur_callback_on_thread.sig = "ippipp";
        function _emscripten_set_focus_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
          target >>>= 0;
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          return registerFocusEventCallback(target, userData, useCapture, callbackfunc, 13, "focus", targetThread);
        }
        _emscripten_set_focus_callback_on_thread.sig = "ippipp";
        function _emscripten_set_focusin_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
          target >>>= 0;
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          return registerFocusEventCallback(target, userData, useCapture, callbackfunc, 14, "focusin", targetThread);
        }
        _emscripten_set_focusin_callback_on_thread.sig = "ippipp";
        function _emscripten_set_focusout_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
          target >>>= 0;
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          return registerFocusEventCallback(target, userData, useCapture, callbackfunc, 15, "focusout", targetThread);
        }
        _emscripten_set_focusout_callback_on_thread.sig = "ippipp";
        var fillDeviceOrientationEventData = (eventStruct, e, target) => {
          HEAPF64[eventStruct >>> 3 >>> 0] = e.alpha;
          HEAPF64[eventStruct + 8 >>> 3 >>> 0] = e.beta;
          HEAPF64[eventStruct + 16 >>> 3 >>> 0] = e.gamma;
          HEAP32[eventStruct + 24 >>> 2 >>> 0] = e.absolute;
        };
        var registerDeviceOrientationEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
          if (!JSEvents.deviceOrientationEvent)
            JSEvents.deviceOrientationEvent = _malloc(32);
          var deviceOrientationEventHandlerFunc = (e = event) => {
            fillDeviceOrientationEventData(JSEvents.deviceOrientationEvent, e, target);
            if (getWasmTableEntry(callbackfunc)(eventTypeId, JSEvents.deviceOrientationEvent, userData))
              e.preventDefault();
          };
          var eventHandler = {
            target: findEventTarget(target),
            eventTypeString,
            callbackfunc,
            handlerFunc: deviceOrientationEventHandlerFunc,
            useCapture
          };
          return JSEvents.registerOrRemoveHandler(eventHandler);
        };
        function _emscripten_set_deviceorientation_callback_on_thread(userData, useCapture, callbackfunc, targetThread) {
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          return registerDeviceOrientationEventCallback(2, userData, useCapture, callbackfunc, 16, "deviceorientation", targetThread);
        }
        _emscripten_set_deviceorientation_callback_on_thread.sig = "ipipp";
        function _emscripten_get_deviceorientation_status(orientationState) {
          orientationState >>>= 0;
          if (!JSEvents.deviceOrientationEvent)
            return -7;
          HEAP32.set(HEAP32.subarray(JSEvents.deviceOrientationEvent >>> 0, 32 >>> 0), orientationState >>> 0);
          return 0;
        }
        _emscripten_get_deviceorientation_status.sig = "ip";
        var fillDeviceMotionEventData = (eventStruct, e, target) => {
          var supportedFields = 0;
          var a = e["acceleration"];
          supportedFields |= a && 1;
          var ag = e["accelerationIncludingGravity"];
          supportedFields |= ag && 2;
          var rr = e["rotationRate"];
          supportedFields |= rr && 4;
          a = a || {};
          ag = ag || {};
          rr = rr || {};
          HEAPF64[eventStruct >>> 3 >>> 0] = a["x"];
          HEAPF64[eventStruct + 8 >>> 3 >>> 0] = a["y"];
          HEAPF64[eventStruct + 16 >>> 3 >>> 0] = a["z"];
          HEAPF64[eventStruct + 24 >>> 3 >>> 0] = ag["x"];
          HEAPF64[eventStruct + 32 >>> 3 >>> 0] = ag["y"];
          HEAPF64[eventStruct + 40 >>> 3 >>> 0] = ag["z"];
          HEAPF64[eventStruct + 48 >>> 3 >>> 0] = rr["alpha"];
          HEAPF64[eventStruct + 56 >>> 3 >>> 0] = rr["beta"];
          HEAPF64[eventStruct + 64 >>> 3 >>> 0] = rr["gamma"];
        };
        var registerDeviceMotionEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
          if (!JSEvents.deviceMotionEvent)
            JSEvents.deviceMotionEvent = _malloc(80);
          var deviceMotionEventHandlerFunc = (e = event) => {
            fillDeviceMotionEventData(JSEvents.deviceMotionEvent, e, target);
            if (getWasmTableEntry(callbackfunc)(eventTypeId, JSEvents.deviceMotionEvent, userData))
              e.preventDefault();
          };
          var eventHandler = {
            target: findEventTarget(target),
            eventTypeString,
            callbackfunc,
            handlerFunc: deviceMotionEventHandlerFunc,
            useCapture
          };
          return JSEvents.registerOrRemoveHandler(eventHandler);
        };
        function _emscripten_set_devicemotion_callback_on_thread(userData, useCapture, callbackfunc, targetThread) {
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          return registerDeviceMotionEventCallback(2, userData, useCapture, callbackfunc, 17, "devicemotion", targetThread);
        }
        _emscripten_set_devicemotion_callback_on_thread.sig = "ipipp";
        function _emscripten_get_devicemotion_status(motionState) {
          motionState >>>= 0;
          if (!JSEvents.deviceMotionEvent)
            return -7;
          HEAP32.set(HEAP32.subarray(JSEvents.deviceMotionEvent >>> 0, 80 >>> 0), motionState >>> 0);
          return 0;
        }
        _emscripten_get_devicemotion_status.sig = "ip";
        var screenOrientation = () => {
          if (!screen)
            return void 0;
          return screen.orientation || screen.mozOrientation || screen.webkitOrientation || screen.msOrientation;
        };
        var fillOrientationChangeEventData = (eventStruct) => {
          var orientations = ["portrait-primary", "portrait-secondary", "landscape-primary", "landscape-secondary"];
          var orientations2 = ["portrait", "portrait", "landscape", "landscape"];
          var orientationString = screenOrientation();
          var orientation2 = orientations.indexOf(orientationString);
          if (orientation2 == -1) {
            orientation2 = orientations2.indexOf(orientationString);
          }
          HEAP32[eventStruct >>> 2 >>> 0] = 1 << orientation2;
          HEAP32[eventStruct + 4 >>> 2 >>> 0] = orientation2;
        };
        var registerOrientationChangeEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
          if (!JSEvents.orientationChangeEvent)
            JSEvents.orientationChangeEvent = _malloc(8);
          var orientationChangeEventHandlerFunc = (e = event) => {
            var orientationChangeEvent = JSEvents.orientationChangeEvent;
            fillOrientationChangeEventData(orientationChangeEvent);
            if (getWasmTableEntry(callbackfunc)(eventTypeId, orientationChangeEvent, userData))
              e.preventDefault();
          };
          if (eventTypeId == 18 && screen.mozOrientation !== void 0) {
            eventTypeString = "mozorientationchange";
          }
          var eventHandler = {
            target,
            eventTypeString,
            callbackfunc,
            handlerFunc: orientationChangeEventHandlerFunc,
            useCapture
          };
          return JSEvents.registerOrRemoveHandler(eventHandler);
        };
        function _emscripten_set_orientationchange_callback_on_thread(userData, useCapture, callbackfunc, targetThread) {
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          if (!screen || !screen["addEventListener"])
            return -1;
          return registerOrientationChangeEventCallback(screen, userData, useCapture, callbackfunc, 18, "orientationchange", targetThread);
        }
        _emscripten_set_orientationchange_callback_on_thread.sig = "ipipp";
        function _emscripten_get_orientation_status(orientationChangeEvent) {
          orientationChangeEvent >>>= 0;
          if (!screenOrientation() && typeof orientation == "undefined")
            return -1;
          fillOrientationChangeEventData(orientationChangeEvent);
          return 0;
        }
        _emscripten_get_orientation_status.sig = "ip";
        var _emscripten_lock_orientation = (allowedOrientations) => {
          var orientations = [];
          if (allowedOrientations & 1)
            orientations.push("portrait-primary");
          if (allowedOrientations & 2)
            orientations.push("portrait-secondary");
          if (allowedOrientations & 4)
            orientations.push("landscape-primary");
          if (allowedOrientations & 8)
            orientations.push("landscape-secondary");
          var succeeded;
          if (screen.lockOrientation) {
            succeeded = screen.lockOrientation(orientations);
          } else if (screen.mozLockOrientation) {
            succeeded = screen.mozLockOrientation(orientations);
          } else if (screen.webkitLockOrientation) {
            succeeded = screen.webkitLockOrientation(orientations);
          } else if (screen.msLockOrientation) {
            succeeded = screen.msLockOrientation(orientations);
          } else {
            return -1;
          }
          if (succeeded) {
            return 0;
          }
          return -6;
        };
        _emscripten_lock_orientation.sig = "ii";
        var _emscripten_unlock_orientation = () => {
          if (screen.unlockOrientation) {
            screen.unlockOrientation();
          } else if (screen.mozUnlockOrientation) {
            screen.mozUnlockOrientation();
          } else if (screen.webkitUnlockOrientation) {
            screen.webkitUnlockOrientation();
          } else if (screen.msUnlockOrientation) {
            screen.msUnlockOrientation();
          } else {
            return -1;
          }
          return 0;
        };
        _emscripten_unlock_orientation.sig = "i";
        var fillFullscreenChangeEventData = (eventStruct) => {
          var fullscreenElement = document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement;
          var isFullscreen = !!fullscreenElement;
          HEAP32[eventStruct >>> 2 >>> 0] = isFullscreen;
          HEAP32[eventStruct + 4 >>> 2 >>> 0] = JSEvents.fullscreenEnabled();
          var reportedElement = isFullscreen ? fullscreenElement : JSEvents.previousFullscreenElement;
          var nodeName = JSEvents.getNodeNameForTarget(reportedElement);
          var id = (reportedElement == null ? void 0 : reportedElement.id) || "";
          stringToUTF8(nodeName, eventStruct + 8, 128);
          stringToUTF8(id, eventStruct + 136, 128);
          HEAP32[eventStruct + 264 >>> 2 >>> 0] = reportedElement ? reportedElement.clientWidth : 0;
          HEAP32[eventStruct + 268 >>> 2 >>> 0] = reportedElement ? reportedElement.clientHeight : 0;
          HEAP32[eventStruct + 272 >>> 2 >>> 0] = screen.width;
          HEAP32[eventStruct + 276 >>> 2 >>> 0] = screen.height;
          if (isFullscreen) {
            JSEvents.previousFullscreenElement = fullscreenElement;
          }
        };
        var registerFullscreenChangeEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
          if (!JSEvents.fullscreenChangeEvent)
            JSEvents.fullscreenChangeEvent = _malloc(280);
          var fullscreenChangeEventhandlerFunc = (e = event) => {
            var fullscreenChangeEvent = JSEvents.fullscreenChangeEvent;
            fillFullscreenChangeEventData(fullscreenChangeEvent);
            if (getWasmTableEntry(callbackfunc)(eventTypeId, fullscreenChangeEvent, userData))
              e.preventDefault();
          };
          var eventHandler = {
            target,
            eventTypeString,
            callbackfunc,
            handlerFunc: fullscreenChangeEventhandlerFunc,
            useCapture
          };
          return JSEvents.registerOrRemoveHandler(eventHandler);
        };
        function _emscripten_set_fullscreenchange_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
          target >>>= 0;
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          if (!JSEvents.fullscreenEnabled())
            return -1;
          target = findEventTarget(target);
          if (!target)
            return -4;
          registerFullscreenChangeEventCallback(target, userData, useCapture, callbackfunc, 19, "webkitfullscreenchange", targetThread);
          return registerFullscreenChangeEventCallback(target, userData, useCapture, callbackfunc, 19, "fullscreenchange", targetThread);
        }
        _emscripten_set_fullscreenchange_callback_on_thread.sig = "ippipp";
        function _emscripten_get_fullscreen_status(fullscreenStatus) {
          fullscreenStatus >>>= 0;
          if (!JSEvents.fullscreenEnabled())
            return -1;
          fillFullscreenChangeEventData(fullscreenStatus);
          return 0;
        }
        _emscripten_get_fullscreen_status.sig = "ip";
        function _emscripten_get_canvas_element_size(target, width, height) {
          target >>>= 0;
          width >>>= 0;
          height >>>= 0;
          var canvas = findCanvasEventTarget(target);
          if (!canvas)
            return -4;
          HEAP32[width >>> 2 >>> 0] = canvas.width;
          HEAP32[height >>> 2 >>> 0] = canvas.height;
        }
        _emscripten_get_canvas_element_size.sig = "ippp";
        var getCanvasElementSize = (target) => withStackSave(() => {
          var w = stackAlloc(8);
          var h = w + 4;
          var targetInt = stringToUTF8OnStack(target.id);
          var ret = _emscripten_get_canvas_element_size(targetInt, w, h);
          var size = [HEAP32[w >>> 2 >>> 0], HEAP32[h >>> 2 >>> 0]];
          return size;
        });
        function _emscripten_set_canvas_element_size(target, width, height) {
          target >>>= 0;
          var canvas = findCanvasEventTarget(target);
          if (!canvas)
            return -4;
          canvas.width = width;
          canvas.height = height;
          return 0;
        }
        _emscripten_set_canvas_element_size.sig = "ipii";
        var setCanvasElementSize = (target, width, height) => {
          if (!target.controlTransferredOffscreen) {
            target.width = width;
            target.height = height;
          } else {
            withStackSave(() => {
              var targetInt = stringToUTF8OnStack(target.id);
              _emscripten_set_canvas_element_size(targetInt, width, height);
            });
          }
        };
        var registerRestoreOldStyle = (canvas) => {
          var canvasSize = getCanvasElementSize(canvas);
          var oldWidth = canvasSize[0];
          var oldHeight = canvasSize[1];
          var oldCssWidth = canvas.style.width;
          var oldCssHeight = canvas.style.height;
          var oldBackgroundColor = canvas.style.backgroundColor;
          var oldDocumentBackgroundColor = document.body.style.backgroundColor;
          var oldPaddingLeft = canvas.style.paddingLeft;
          var oldPaddingRight = canvas.style.paddingRight;
          var oldPaddingTop = canvas.style.paddingTop;
          var oldPaddingBottom = canvas.style.paddingBottom;
          var oldMarginLeft = canvas.style.marginLeft;
          var oldMarginRight = canvas.style.marginRight;
          var oldMarginTop = canvas.style.marginTop;
          var oldMarginBottom = canvas.style.marginBottom;
          var oldDocumentBodyMargin = document.body.style.margin;
          var oldDocumentOverflow = document.documentElement.style.overflow;
          var oldDocumentScroll = document.body.scroll;
          var oldImageRendering = canvas.style.imageRendering;
          function restoreOldStyle() {
            var fullscreenElement = document.fullscreenElement || document.webkitFullscreenElement;
            if (!fullscreenElement) {
              document.removeEventListener("fullscreenchange", restoreOldStyle);
              document.removeEventListener("webkitfullscreenchange", restoreOldStyle);
              setCanvasElementSize(canvas, oldWidth, oldHeight);
              canvas.style.width = oldCssWidth;
              canvas.style.height = oldCssHeight;
              canvas.style.backgroundColor = oldBackgroundColor;
              if (!oldDocumentBackgroundColor)
                document.body.style.backgroundColor = "white";
              document.body.style.backgroundColor = oldDocumentBackgroundColor;
              canvas.style.paddingLeft = oldPaddingLeft;
              canvas.style.paddingRight = oldPaddingRight;
              canvas.style.paddingTop = oldPaddingTop;
              canvas.style.paddingBottom = oldPaddingBottom;
              canvas.style.marginLeft = oldMarginLeft;
              canvas.style.marginRight = oldMarginRight;
              canvas.style.marginTop = oldMarginTop;
              canvas.style.marginBottom = oldMarginBottom;
              document.body.style.margin = oldDocumentBodyMargin;
              document.documentElement.style.overflow = oldDocumentOverflow;
              document.body.scroll = oldDocumentScroll;
              canvas.style.imageRendering = oldImageRendering;
              if (canvas.GLctxObject)
                canvas.GLctxObject.GLctx.viewport(0, 0, oldWidth, oldHeight);
              if (currentFullscreenStrategy.canvasResizedCallback) {
                getWasmTableEntry(currentFullscreenStrategy.canvasResizedCallback)(37, 0, currentFullscreenStrategy.canvasResizedCallbackUserData);
              }
            }
          }
          document.addEventListener("fullscreenchange", restoreOldStyle);
          document.addEventListener("webkitfullscreenchange", restoreOldStyle);
          return restoreOldStyle;
        };
        var setLetterbox = (element, topBottom, leftRight) => {
          element.style.paddingLeft = element.style.paddingRight = leftRight + "px";
          element.style.paddingTop = element.style.paddingBottom = topBottom + "px";
        };
        var JSEvents_resizeCanvasForFullscreen = (target, strategy) => {
          var restoreOldStyle = registerRestoreOldStyle(target);
          var cssWidth = strategy.softFullscreen ? innerWidth : screen.width;
          var cssHeight = strategy.softFullscreen ? innerHeight : screen.height;
          var rect = getBoundingClientRect(target);
          var windowedCssWidth = rect.width;
          var windowedCssHeight = rect.height;
          var canvasSize = getCanvasElementSize(target);
          var windowedRttWidth = canvasSize[0];
          var windowedRttHeight = canvasSize[1];
          if (strategy.scaleMode == 3) {
            setLetterbox(target, (cssHeight - windowedCssHeight) / 2, (cssWidth - windowedCssWidth) / 2);
            cssWidth = windowedCssWidth;
            cssHeight = windowedCssHeight;
          } else if (strategy.scaleMode == 2) {
            if (cssWidth * windowedRttHeight < windowedRttWidth * cssHeight) {
              var desiredCssHeight = windowedRttHeight * cssWidth / windowedRttWidth;
              setLetterbox(target, (cssHeight - desiredCssHeight) / 2, 0);
              cssHeight = desiredCssHeight;
            } else {
              var desiredCssWidth = windowedRttWidth * cssHeight / windowedRttHeight;
              setLetterbox(target, 0, (cssWidth - desiredCssWidth) / 2);
              cssWidth = desiredCssWidth;
            }
          }
          if (!target.style.backgroundColor)
            target.style.backgroundColor = "black";
          if (!document.body.style.backgroundColor)
            document.body.style.backgroundColor = "black";
          target.style.width = cssWidth + "px";
          target.style.height = cssHeight + "px";
          if (strategy.filteringMode == 1) {
            target.style.imageRendering = "optimizeSpeed";
            target.style.imageRendering = "-moz-crisp-edges";
            target.style.imageRendering = "-o-crisp-edges";
            target.style.imageRendering = "-webkit-optimize-contrast";
            target.style.imageRendering = "optimize-contrast";
            target.style.imageRendering = "crisp-edges";
            target.style.imageRendering = "pixelated";
          }
          var dpiScale = strategy.canvasResolutionScaleMode == 2 ? devicePixelRatio : 1;
          if (strategy.canvasResolutionScaleMode != 0) {
            var newWidth = cssWidth * dpiScale | 0;
            var newHeight = cssHeight * dpiScale | 0;
            setCanvasElementSize(target, newWidth, newHeight);
            if (target.GLctxObject)
              target.GLctxObject.GLctx.viewport(0, 0, newWidth, newHeight);
          }
          return restoreOldStyle;
        };
        var JSEvents_requestFullscreen = (target, strategy) => {
          if (strategy.scaleMode != 0 || strategy.canvasResolutionScaleMode != 0) {
            JSEvents_resizeCanvasForFullscreen(target, strategy);
          }
          if (target.requestFullscreen) {
            target.requestFullscreen();
          } else if (target.webkitRequestFullscreen) {
            target.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
          } else {
            return JSEvents.fullscreenEnabled() ? -3 : -1;
          }
          currentFullscreenStrategy = strategy;
          if (strategy.canvasResizedCallback) {
            getWasmTableEntry(strategy.canvasResizedCallback)(37, 0, strategy.canvasResizedCallbackUserData);
          }
          return 0;
        };
        var hideEverythingExceptGivenElement = (onlyVisibleElement) => {
          var child = onlyVisibleElement;
          var parent = child.parentNode;
          var hiddenElements = [];
          while (child != document.body) {
            var children = parent.children;
            for (var i2 = 0; i2 < children.length; ++i2) {
              if (children[i2] != child) {
                hiddenElements.push({
                  node: children[i2],
                  displayState: children[i2].style.display
                });
                children[i2].style.display = "none";
              }
            }
            child = parent;
            parent = parent.parentNode;
          }
          return hiddenElements;
        };
        var restoreHiddenElements = (hiddenElements) => {
          for (var i2 = 0; i2 < hiddenElements.length; ++i2) {
            hiddenElements[i2].node.style.display = hiddenElements[i2].displayState;
          }
        };
        var currentFullscreenStrategy = {};
        var restoreOldWindowedStyle = null;
        var softFullscreenResizeWebGLRenderTarget = () => {
          var dpr = devicePixelRatio;
          var inHiDPIFullscreenMode = currentFullscreenStrategy.canvasResolutionScaleMode == 2;
          var inAspectRatioFixedFullscreenMode = currentFullscreenStrategy.scaleMode == 2;
          var inPixelPerfectFullscreenMode = currentFullscreenStrategy.canvasResolutionScaleMode != 0;
          var inCenteredWithoutScalingFullscreenMode = currentFullscreenStrategy.scaleMode == 3;
          var screenWidth = inHiDPIFullscreenMode ? Math.round(innerWidth * dpr) : innerWidth;
          var screenHeight = inHiDPIFullscreenMode ? Math.round(innerHeight * dpr) : innerHeight;
          var w = screenWidth;
          var h = screenHeight;
          var canvas = currentFullscreenStrategy.target;
          var canvasSize = getCanvasElementSize(canvas);
          var x = canvasSize[0];
          var y = canvasSize[1];
          var topMargin;
          if (inAspectRatioFixedFullscreenMode) {
            if (w * y < x * h)
              h = w * y / x | 0;
            else if (w * y > x * h)
              w = h * x / y | 0;
            topMargin = (screenHeight - h) / 2 | 0;
          }
          if (inPixelPerfectFullscreenMode) {
            setCanvasElementSize(canvas, w, h);
            if (canvas.GLctxObject)
              canvas.GLctxObject.GLctx.viewport(0, 0, w, h);
          }
          if (inHiDPIFullscreenMode) {
            topMargin /= dpr;
            w /= dpr;
            h /= dpr;
            w = Math.round(w * 1e4) / 1e4;
            h = Math.round(h * 1e4) / 1e4;
            topMargin = Math.round(topMargin * 1e4) / 1e4;
          }
          if (inCenteredWithoutScalingFullscreenMode) {
            var t = (innerHeight - jstoi_q(canvas.style.height)) / 2;
            var b = (innerWidth - jstoi_q(canvas.style.width)) / 2;
            setLetterbox(canvas, t, b);
          } else {
            canvas.style.width = w + "px";
            canvas.style.height = h + "px";
            var b = (innerWidth - w) / 2;
            setLetterbox(canvas, topMargin, b);
          }
          if (!inCenteredWithoutScalingFullscreenMode && currentFullscreenStrategy.canvasResizedCallback) {
            getWasmTableEntry(currentFullscreenStrategy.canvasResizedCallback)(37, 0, currentFullscreenStrategy.canvasResizedCallbackUserData);
          }
        };
        var doRequestFullscreen = (target, strategy) => {
          if (!JSEvents.fullscreenEnabled())
            return -1;
          target = findEventTarget(target);
          if (!target)
            return -4;
          if (!target.requestFullscreen && !target.webkitRequestFullscreen) {
            return -3;
          }
          var canPerformRequests = JSEvents.canPerformEventHandlerRequests();
          if (!canPerformRequests) {
            if (strategy.deferUntilInEventHandler) {
              JSEvents.deferCall(JSEvents_requestFullscreen, 1, [target, strategy]);
              return 1;
            }
            return -2;
          }
          return JSEvents_requestFullscreen(target, strategy);
        };
        function _emscripten_request_fullscreen(target, deferUntilInEventHandler) {
          target >>>= 0;
          var strategy = {
            scaleMode: 0,
            canvasResolutionScaleMode: 0,
            filteringMode: 0,
            deferUntilInEventHandler,
            canvasResizedCallbackTargetThread: 2
          };
          return doRequestFullscreen(target, strategy);
        }
        _emscripten_request_fullscreen.sig = "ipi";
        function _emscripten_request_fullscreen_strategy(target, deferUntilInEventHandler, fullscreenStrategy) {
          target >>>= 0;
          fullscreenStrategy >>>= 0;
          var strategy = {
            scaleMode: HEAP32[fullscreenStrategy >>> 2 >>> 0],
            canvasResolutionScaleMode: HEAP32[fullscreenStrategy + 4 >>> 2 >>> 0],
            filteringMode: HEAP32[fullscreenStrategy + 8 >>> 2 >>> 0],
            deferUntilInEventHandler,
            canvasResizedCallback: HEAP32[fullscreenStrategy + 12 >>> 2 >>> 0],
            canvasResizedCallbackUserData: HEAP32[fullscreenStrategy + 16 >>> 2 >>> 0]
          };
          return doRequestFullscreen(target, strategy);
        }
        _emscripten_request_fullscreen_strategy.sig = "ipip";
        function _emscripten_enter_soft_fullscreen(target, fullscreenStrategy) {
          target >>>= 0;
          fullscreenStrategy >>>= 0;
          target = findEventTarget(target);
          if (!target)
            return -4;
          var strategy = {
            scaleMode: HEAP32[fullscreenStrategy >>> 2 >>> 0],
            canvasResolutionScaleMode: HEAP32[fullscreenStrategy + 4 >>> 2 >>> 0],
            filteringMode: HEAP32[fullscreenStrategy + 8 >>> 2 >>> 0],
            canvasResizedCallback: HEAP32[fullscreenStrategy + 12 >>> 2 >>> 0],
            canvasResizedCallbackUserData: HEAP32[fullscreenStrategy + 16 >>> 2 >>> 0],
            target,
            softFullscreen: true
          };
          var restoreOldStyle = JSEvents_resizeCanvasForFullscreen(target, strategy);
          document.documentElement.style.overflow = "hidden";
          document.body.scroll = "no";
          document.body.style.margin = "0px";
          var hiddenElements = hideEverythingExceptGivenElement(target);
          function restoreWindowedState() {
            restoreOldStyle();
            restoreHiddenElements(hiddenElements);
            removeEventListener("resize", softFullscreenResizeWebGLRenderTarget);
            if (strategy.canvasResizedCallback) {
              getWasmTableEntry(strategy.canvasResizedCallback)(37, 0, strategy.canvasResizedCallbackUserData);
            }
            currentFullscreenStrategy = 0;
          }
          restoreOldWindowedStyle = restoreWindowedState;
          currentFullscreenStrategy = strategy;
          addEventListener("resize", softFullscreenResizeWebGLRenderTarget);
          if (strategy.canvasResizedCallback) {
            getWasmTableEntry(strategy.canvasResizedCallback)(37, 0, strategy.canvasResizedCallbackUserData);
          }
          return 0;
        }
        _emscripten_enter_soft_fullscreen.sig = "ipp";
        var _emscripten_exit_soft_fullscreen = () => {
          restoreOldWindowedStyle == null ? void 0 : restoreOldWindowedStyle();
          restoreOldWindowedStyle = null;
          return 0;
        };
        _emscripten_exit_soft_fullscreen.sig = "i";
        var _emscripten_exit_fullscreen = () => {
          if (!JSEvents.fullscreenEnabled())
            return -1;
          JSEvents.removeDeferredCalls(JSEvents_requestFullscreen);
          var d = specialHTMLTargets[1];
          if (d.exitFullscreen) {
            d.fullscreenElement && d.exitFullscreen();
          } else if (d.webkitExitFullscreen) {
            d.webkitFullscreenElement && d.webkitExitFullscreen();
          } else {
            return -1;
          }
          return 0;
        };
        _emscripten_exit_fullscreen.sig = "i";
        var fillPointerlockChangeEventData = (eventStruct) => {
          var pointerLockElement = document.pointerLockElement || document.mozPointerLockElement || document.webkitPointerLockElement || document.msPointerLockElement;
          var isPointerlocked = !!pointerLockElement;
          HEAP32[eventStruct >>> 2 >>> 0] = isPointerlocked;
          var nodeName = JSEvents.getNodeNameForTarget(pointerLockElement);
          var id = (pointerLockElement == null ? void 0 : pointerLockElement.id) || "";
          stringToUTF8(nodeName, eventStruct + 4, 128);
          stringToUTF8(id, eventStruct + 132, 128);
        };
        var registerPointerlockChangeEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
          if (!JSEvents.pointerlockChangeEvent)
            JSEvents.pointerlockChangeEvent = _malloc(260);
          var pointerlockChangeEventHandlerFunc = (e = event) => {
            var pointerlockChangeEvent = JSEvents.pointerlockChangeEvent;
            fillPointerlockChangeEventData(pointerlockChangeEvent);
            if (getWasmTableEntry(callbackfunc)(eventTypeId, pointerlockChangeEvent, userData))
              e.preventDefault();
          };
          var eventHandler = {
            target,
            eventTypeString,
            callbackfunc,
            handlerFunc: pointerlockChangeEventHandlerFunc,
            useCapture
          };
          return JSEvents.registerOrRemoveHandler(eventHandler);
        };
        function _emscripten_set_pointerlockchange_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
          target >>>= 0;
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          if (!document || !document.body || !document.body.requestPointerLock && !document.body.mozRequestPointerLock && !document.body.webkitRequestPointerLock && !document.body.msRequestPointerLock) {
            return -1;
          }
          target = findEventTarget(target);
          if (!target)
            return -4;
          registerPointerlockChangeEventCallback(target, userData, useCapture, callbackfunc, 20, "mozpointerlockchange", targetThread);
          registerPointerlockChangeEventCallback(target, userData, useCapture, callbackfunc, 20, "webkitpointerlockchange", targetThread);
          registerPointerlockChangeEventCallback(target, userData, useCapture, callbackfunc, 20, "mspointerlockchange", targetThread);
          return registerPointerlockChangeEventCallback(target, userData, useCapture, callbackfunc, 20, "pointerlockchange", targetThread);
        }
        _emscripten_set_pointerlockchange_callback_on_thread.sig = "ippipp";
        var registerPointerlockErrorEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
          var pointerlockErrorEventHandlerFunc = (e = event) => {
            if (getWasmTableEntry(callbackfunc)(eventTypeId, 0, userData))
              e.preventDefault();
          };
          var eventHandler = {
            target,
            eventTypeString,
            callbackfunc,
            handlerFunc: pointerlockErrorEventHandlerFunc,
            useCapture
          };
          return JSEvents.registerOrRemoveHandler(eventHandler);
        };
        function _emscripten_set_pointerlockerror_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
          target >>>= 0;
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          if (!document || !document.body.requestPointerLock && !document.body.mozRequestPointerLock && !document.body.webkitRequestPointerLock && !document.body.msRequestPointerLock) {
            return -1;
          }
          target = findEventTarget(target);
          if (!target)
            return -4;
          registerPointerlockErrorEventCallback(target, userData, useCapture, callbackfunc, 38, "mozpointerlockerror", targetThread);
          registerPointerlockErrorEventCallback(target, userData, useCapture, callbackfunc, 38, "webkitpointerlockerror", targetThread);
          registerPointerlockErrorEventCallback(target, userData, useCapture, callbackfunc, 38, "mspointerlockerror", targetThread);
          return registerPointerlockErrorEventCallback(target, userData, useCapture, callbackfunc, 38, "pointerlockerror", targetThread);
        }
        _emscripten_set_pointerlockerror_callback_on_thread.sig = "ippipp";
        function _emscripten_get_pointerlock_status(pointerlockStatus) {
          pointerlockStatus >>>= 0;
          if (pointerlockStatus)
            fillPointerlockChangeEventData(pointerlockStatus);
          if (!document.body || !document.body.requestPointerLock && !document.body.mozRequestPointerLock && !document.body.webkitRequestPointerLock && !document.body.msRequestPointerLock) {
            return -1;
          }
          return 0;
        }
        _emscripten_get_pointerlock_status.sig = "ip";
        var requestPointerLock = (target) => {
          if (target.requestPointerLock) {
            target.requestPointerLock();
          } else {
            if (document.body.requestPointerLock) {
              return -3;
            }
            return -1;
          }
          return 0;
        };
        function _emscripten_request_pointerlock(target, deferUntilInEventHandler) {
          target >>>= 0;
          target = findEventTarget(target);
          if (!target)
            return -4;
          if (!target.requestPointerLock) {
            return -1;
          }
          var canPerformRequests = JSEvents.canPerformEventHandlerRequests();
          if (!canPerformRequests) {
            if (deferUntilInEventHandler) {
              JSEvents.deferCall(requestPointerLock, 2, [target]);
              return 1;
            }
            return -2;
          }
          return requestPointerLock(target);
        }
        _emscripten_request_pointerlock.sig = "ipi";
        var _emscripten_exit_pointerlock = () => {
          JSEvents.removeDeferredCalls(requestPointerLock);
          if (document.exitPointerLock) {
            document.exitPointerLock();
          } else {
            return -1;
          }
          return 0;
        };
        _emscripten_exit_pointerlock.sig = "i";
        var _emscripten_vibrate = (msecs) => {
          if (!navigator.vibrate)
            return -1;
          navigator.vibrate(msecs);
          return 0;
        };
        _emscripten_vibrate.sig = "ii";
        function _emscripten_vibrate_pattern(msecsArray, numEntries) {
          msecsArray >>>= 0;
          if (!navigator.vibrate)
            return -1;
          var vibrateList = [];
          for (var i2 = 0; i2 < numEntries; ++i2) {
            var msecs = HEAP32[msecsArray + i2 * 4 >>> 2 >>> 0];
            vibrateList.push(msecs);
          }
          navigator.vibrate(vibrateList);
          return 0;
        }
        _emscripten_vibrate_pattern.sig = "ipi";
        var fillVisibilityChangeEventData = (eventStruct) => {
          var visibilityStates = ["hidden", "visible", "prerender", "unloaded"];
          var visibilityState = visibilityStates.indexOf(document.visibilityState);
          HEAP32[eventStruct >>> 2 >>> 0] = document.hidden;
          HEAP32[eventStruct + 4 >>> 2 >>> 0] = visibilityState;
        };
        var registerVisibilityChangeEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
          if (!JSEvents.visibilityChangeEvent)
            JSEvents.visibilityChangeEvent = _malloc(8);
          var visibilityChangeEventHandlerFunc = (e = event) => {
            var visibilityChangeEvent = JSEvents.visibilityChangeEvent;
            fillVisibilityChangeEventData(visibilityChangeEvent);
            if (getWasmTableEntry(callbackfunc)(eventTypeId, visibilityChangeEvent, userData))
              e.preventDefault();
          };
          var eventHandler = {
            target,
            eventTypeString,
            callbackfunc,
            handlerFunc: visibilityChangeEventHandlerFunc,
            useCapture
          };
          return JSEvents.registerOrRemoveHandler(eventHandler);
        };
        function _emscripten_set_visibilitychange_callback_on_thread(userData, useCapture, callbackfunc, targetThread) {
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          if (!specialHTMLTargets[1]) {
            return -4;
          }
          return registerVisibilityChangeEventCallback(specialHTMLTargets[1], userData, useCapture, callbackfunc, 21, "visibilitychange", targetThread);
        }
        _emscripten_set_visibilitychange_callback_on_thread.sig = "ipipp";
        function _emscripten_get_visibility_status(visibilityStatus) {
          visibilityStatus >>>= 0;
          if (typeof document.visibilityState == "undefined" && typeof document.hidden == "undefined") {
            return -1;
          }
          fillVisibilityChangeEventData(visibilityStatus);
          return 0;
        }
        _emscripten_get_visibility_status.sig = "ip";
        var registerTouchEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
          if (!JSEvents.touchEvent)
            JSEvents.touchEvent = _malloc(1696);
          target = findEventTarget(target);
          var touchEventHandlerFunc = (e) => {
            var t, touches = {}, et = e.touches;
            for (var i2 = 0; i2 < et.length; ++i2) {
              t = et[i2];
              t.isChanged = t.onTarget = 0;
              touches[t.identifier] = t;
            }
            for (var i2 = 0; i2 < e.changedTouches.length; ++i2) {
              t = e.changedTouches[i2];
              t.isChanged = 1;
              touches[t.identifier] = t;
            }
            for (var i2 = 0; i2 < e.targetTouches.length; ++i2) {
              touches[e.targetTouches[i2].identifier].onTarget = 1;
            }
            var touchEvent = JSEvents.touchEvent;
            HEAPF64[touchEvent >>> 3 >>> 0] = e.timeStamp;
            var idx = touchEvent >>> 2;
            HEAP32[idx + 3 >>> 0] = e.ctrlKey;
            HEAP32[idx + 4 >>> 0] = e.shiftKey;
            HEAP32[idx + 5 >>> 0] = e.altKey;
            HEAP32[idx + 6 >>> 0] = e.metaKey;
            idx += 7;
            var targetRect = getBoundingClientRect(target);
            var numTouches = 0;
            for (var i2 in touches) {
              t = touches[i2];
              HEAP32[idx + 0 >>> 0] = t.identifier;
              HEAP32[idx + 1 >>> 0] = t.screenX;
              HEAP32[idx + 2 >>> 0] = t.screenY;
              HEAP32[idx + 3 >>> 0] = t.clientX;
              HEAP32[idx + 4 >>> 0] = t.clientY;
              HEAP32[idx + 5 >>> 0] = t.pageX;
              HEAP32[idx + 6 >>> 0] = t.pageY;
              HEAP32[idx + 7 >>> 0] = t.isChanged;
              HEAP32[idx + 8 >>> 0] = t.onTarget;
              HEAP32[idx + 9 >>> 0] = t.clientX - targetRect.left;
              HEAP32[idx + 10 >>> 0] = t.clientY - targetRect.top;
              idx += 13;
              if (++numTouches > 31) {
                break;
              }
            }
            HEAP32[touchEvent + 8 >>> 2 >>> 0] = numTouches;
            if (getWasmTableEntry(callbackfunc)(eventTypeId, touchEvent, userData))
              e.preventDefault();
          };
          var eventHandler = {
            target,
            allowsDeferredCalls: eventTypeString == "touchstart" || eventTypeString == "touchend",
            eventTypeString,
            callbackfunc,
            handlerFunc: touchEventHandlerFunc,
            useCapture
          };
          return JSEvents.registerOrRemoveHandler(eventHandler);
        };
        function _emscripten_set_touchstart_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
          target >>>= 0;
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          return registerTouchEventCallback(target, userData, useCapture, callbackfunc, 22, "touchstart", targetThread);
        }
        _emscripten_set_touchstart_callback_on_thread.sig = "ippipp";
        function _emscripten_set_touchend_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
          target >>>= 0;
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          return registerTouchEventCallback(target, userData, useCapture, callbackfunc, 23, "touchend", targetThread);
        }
        _emscripten_set_touchend_callback_on_thread.sig = "ippipp";
        function _emscripten_set_touchmove_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
          target >>>= 0;
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          return registerTouchEventCallback(target, userData, useCapture, callbackfunc, 24, "touchmove", targetThread);
        }
        _emscripten_set_touchmove_callback_on_thread.sig = "ippipp";
        function _emscripten_set_touchcancel_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
          target >>>= 0;
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          return registerTouchEventCallback(target, userData, useCapture, callbackfunc, 25, "touchcancel", targetThread);
        }
        _emscripten_set_touchcancel_callback_on_thread.sig = "ippipp";
        var fillGamepadEventData = (eventStruct, e) => {
          HEAPF64[eventStruct >>> 3 >>> 0] = e.timestamp;
          for (var i2 = 0; i2 < e.axes.length; ++i2) {
            HEAPF64[eventStruct + i2 * 8 + 16 >>> 3 >>> 0] = e.axes[i2];
          }
          for (var i2 = 0; i2 < e.buttons.length; ++i2) {
            if (typeof e.buttons[i2] == "object") {
              HEAPF64[eventStruct + i2 * 8 + 528 >>> 3 >>> 0] = e.buttons[i2].value;
            } else {
              HEAPF64[eventStruct + i2 * 8 + 528 >>> 3 >>> 0] = e.buttons[i2];
            }
          }
          for (var i2 = 0; i2 < e.buttons.length; ++i2) {
            if (typeof e.buttons[i2] == "object") {
              HEAP32[eventStruct + i2 * 4 + 1040 >>> 2 >>> 0] = e.buttons[i2].pressed;
            } else {
              HEAP32[eventStruct + i2 * 4 + 1040 >>> 2 >>> 0] = e.buttons[i2] == 1;
            }
          }
          HEAP32[eventStruct + 1296 >>> 2 >>> 0] = e.connected;
          HEAP32[eventStruct + 1300 >>> 2 >>> 0] = e.index;
          HEAP32[eventStruct + 8 >>> 2 >>> 0] = e.axes.length;
          HEAP32[eventStruct + 12 >>> 2 >>> 0] = e.buttons.length;
          stringToUTF8(e.id, eventStruct + 1304, 64);
          stringToUTF8(e.mapping, eventStruct + 1368, 64);
        };
        var registerGamepadEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
          if (!JSEvents.gamepadEvent)
            JSEvents.gamepadEvent = _malloc(1432);
          var gamepadEventHandlerFunc = (e = event) => {
            var gamepadEvent = JSEvents.gamepadEvent;
            fillGamepadEventData(gamepadEvent, e["gamepad"]);
            if (getWasmTableEntry(callbackfunc)(eventTypeId, gamepadEvent, userData))
              e.preventDefault();
          };
          var eventHandler = {
            target: findEventTarget(target),
            allowsDeferredCalls: true,
            eventTypeString,
            callbackfunc,
            handlerFunc: gamepadEventHandlerFunc,
            useCapture
          };
          return JSEvents.registerOrRemoveHandler(eventHandler);
        };
        var _emscripten_sample_gamepad_data = () => {
          try {
            if (navigator.getGamepads)
              return (JSEvents.lastGamepadState = navigator.getGamepads()) ? 0 : -1;
          } catch (e) {
            navigator.getGamepads = null;
          }
          return -1;
        };
        _emscripten_sample_gamepad_data.sig = "i";
        function _emscripten_set_gamepadconnected_callback_on_thread(userData, useCapture, callbackfunc, targetThread) {
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          if (_emscripten_sample_gamepad_data())
            return -1;
          return registerGamepadEventCallback(2, userData, useCapture, callbackfunc, 26, "gamepadconnected", targetThread);
        }
        _emscripten_set_gamepadconnected_callback_on_thread.sig = "ipipp";
        function _emscripten_set_gamepaddisconnected_callback_on_thread(userData, useCapture, callbackfunc, targetThread) {
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          if (_emscripten_sample_gamepad_data())
            return -1;
          return registerGamepadEventCallback(2, userData, useCapture, callbackfunc, 27, "gamepaddisconnected", targetThread);
        }
        _emscripten_set_gamepaddisconnected_callback_on_thread.sig = "ipipp";
        var _emscripten_get_num_gamepads = () => JSEvents.lastGamepadState.length;
        _emscripten_get_num_gamepads.sig = "i";
        function _emscripten_get_gamepad_status(index, gamepadState) {
          gamepadState >>>= 0;
          if (index < 0 || index >= JSEvents.lastGamepadState.length)
            return -5;
          if (!JSEvents.lastGamepadState[index])
            return -7;
          fillGamepadEventData(gamepadState, JSEvents.lastGamepadState[index]);
          return 0;
        }
        _emscripten_get_gamepad_status.sig = "iip";
        var registerBeforeUnloadEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString) => {
          var beforeUnloadEventHandlerFunc = (e = event) => {
            var confirmationMessage = getWasmTableEntry(callbackfunc)(eventTypeId, 0, userData);
            if (confirmationMessage) {
              confirmationMessage = UTF8ToString(confirmationMessage);
            }
            if (confirmationMessage) {
              e.preventDefault();
              e.returnValue = confirmationMessage;
              return confirmationMessage;
            }
          };
          var eventHandler = {
            target: findEventTarget(target),
            eventTypeString,
            callbackfunc,
            handlerFunc: beforeUnloadEventHandlerFunc,
            useCapture
          };
          return JSEvents.registerOrRemoveHandler(eventHandler);
        };
        function _emscripten_set_beforeunload_callback_on_thread(userData, callbackfunc, targetThread) {
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          if (typeof onbeforeunload == "undefined")
            return -1;
          if (targetThread !== 1)
            return -5;
          return registerBeforeUnloadEventCallback(2, userData, true, callbackfunc, 28, "beforeunload");
        }
        _emscripten_set_beforeunload_callback_on_thread.sig = "ippp";
        var fillBatteryEventData = (eventStruct, e) => {
          HEAPF64[eventStruct >>> 3 >>> 0] = e.chargingTime;
          HEAPF64[eventStruct + 8 >>> 3 >>> 0] = e.dischargingTime;
          HEAPF64[eventStruct + 16 >>> 3 >>> 0] = e.level;
          HEAP32[eventStruct + 24 >>> 2 >>> 0] = e.charging;
        };
        var battery = () => navigator.battery || navigator.mozBattery || navigator.webkitBattery;
        var registerBatteryEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
          if (!JSEvents.batteryEvent)
            JSEvents.batteryEvent = _malloc(32);
          var batteryEventHandlerFunc = (e = event) => {
            var batteryEvent = JSEvents.batteryEvent;
            fillBatteryEventData(batteryEvent, battery());
            if (getWasmTableEntry(callbackfunc)(eventTypeId, batteryEvent, userData))
              e.preventDefault();
          };
          var eventHandler = {
            target: findEventTarget(target),
            eventTypeString,
            callbackfunc,
            handlerFunc: batteryEventHandlerFunc,
            useCapture
          };
          return JSEvents.registerOrRemoveHandler(eventHandler);
        };
        function _emscripten_set_batterychargingchange_callback_on_thread(userData, callbackfunc, targetThread) {
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          if (!battery())
            return -1;
          return registerBatteryEventCallback(battery(), userData, true, callbackfunc, 29, "chargingchange", targetThread);
        }
        _emscripten_set_batterychargingchange_callback_on_thread.sig = "ippp";
        function _emscripten_set_batterylevelchange_callback_on_thread(userData, callbackfunc, targetThread) {
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          if (!battery())
            return -1;
          return registerBatteryEventCallback(battery(), userData, true, callbackfunc, 30, "levelchange", targetThread);
        }
        _emscripten_set_batterylevelchange_callback_on_thread.sig = "ippp";
        function _emscripten_get_battery_status(batteryState) {
          batteryState >>>= 0;
          if (!battery())
            return -1;
          fillBatteryEventData(batteryState, battery());
          return 0;
        }
        _emscripten_get_battery_status.sig = "ip";
        function _emscripten_set_element_css_size(target, width, height) {
          target >>>= 0;
          target = findEventTarget(target);
          if (!target)
            return -4;
          target.style.width = width + "px";
          target.style.height = height + "px";
          return 0;
        }
        _emscripten_set_element_css_size.sig = "ipdd";
        function _emscripten_get_element_css_size(target, width, height) {
          target >>>= 0;
          width >>>= 0;
          height >>>= 0;
          target = findEventTarget(target);
          if (!target)
            return -4;
          var rect = getBoundingClientRect(target);
          HEAPF64[width >>> 3 >>> 0] = rect.width;
          HEAPF64[height >>> 3 >>> 0] = rect.height;
          return 0;
        }
        _emscripten_get_element_css_size.sig = "ippp";
        var _emscripten_html5_remove_all_event_listeners = () => JSEvents.removeAllEventListeners();
        _emscripten_html5_remove_all_event_listeners.sig = "v";
        var _emscripten_request_animation_frame = function(cb, userData) {
          cb >>>= 0;
          userData >>>= 0;
          return requestAnimationFrame((timeStamp) => getWasmTableEntry(cb)(timeStamp, userData));
        };
        _emscripten_request_animation_frame.sig = "ipp";
        var _emscripten_cancel_animation_frame = (id) => cancelAnimationFrame(id);
        _emscripten_cancel_animation_frame.sig = "vi";
        function _emscripten_request_animation_frame_loop(cb, userData) {
          cb >>>= 0;
          userData >>>= 0;
          function tick(timeStamp) {
            if (getWasmTableEntry(cb)(timeStamp, userData)) {
              requestAnimationFrame(tick);
            }
          }
          return requestAnimationFrame(tick);
        }
        _emscripten_request_animation_frame_loop.sig = "vpp";
        var _emscripten_performance_now = () => performance.now();
        _emscripten_performance_now.sig = "d";
        var _emscripten_get_device_pixel_ratio = () => typeof devicePixelRatio == "number" && devicePixelRatio || 1;
        _emscripten_get_device_pixel_ratio.sig = "d";
        var demangle = (func2) => func2;
        var demangleAll = (text) => {
          var regex = /\b_Z[\w\d_]+/g;
          return text.replace(regex, function(x) {
            var y = demangle(x);
            return x === y ? x : y + " [" + x + "]";
          });
        };
        function stackTrace() {
          var js = jsStackTrace();
          if (Module["extraStackTrace"])
            js += "\n" + Module["extraStackTrace"]();
          return demangleAll(js);
        }
        function _random_get(buf, buf_len) {
          buf >>>= 0;
          buf_len >>>= 0;
          try {
            _getentropy(buf, buf_len);
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return e.errno;
          }
        }
        _random_get.sig = "ipp";
        var checkWasiClock = (clock_id) => clock_id == 0 || clock_id == 1 || clock_id == 2 || clock_id == 3;
        function _clock_time_get(clk_id, ignored_precision_low, ignored_precision_high, ptime) {
          var ignored_precision = convertI32PairToI53Checked(ignored_precision_low, ignored_precision_high);
          ptime >>>= 0;
          if (!checkWasiClock(clk_id)) {
            return 28;
          }
          var now;
          if (clk_id === 0) {
            now = Date.now();
          } else if (nowIsMonotonic) {
            now = _emscripten_get_now();
          } else {
            return 52;
          }
          var nsec = Math.round(now * 1e3 * 1e3);
          HEAP32[ptime >>> 2 >>> 0] = nsec >>> 0;
          HEAP32[ptime + 4 >>> 2 >>> 0] = nsec / Math.pow(2, 32) >>> 0;
          return 0;
        }
        _clock_time_get.sig = "iiiip";
        function _clock_res_get(clk_id, pres) {
          pres >>>= 0;
          if (!checkWasiClock(clk_id)) {
            return 28;
          }
          var nsec;
          if (clk_id === 0) {
            nsec = 1e3 * 1e3;
          } else if (nowIsMonotonic) {
            nsec = _emscripten_get_now_res();
          } else {
            return 52;
          }
          HEAP32[pres >>> 2 >>> 0] = nsec >>> 0;
          HEAP32[pres + 4 >>> 2 >>> 0] = nsec / Math.pow(2, 32) >>> 0;
          return 0;
        }
        _clock_res_get.sig = "iip";
        var wasiRightsToMuslOFlags = (rights) => {
          if (rights & 2 && rights & 64) {
            return 2;
          }
          if (rights & 2) {
            return 0;
          }
          if (rights & 64) {
            return 1;
          }
          throw new FS.ErrnoError(28);
        };
        var wasiOFlagsToMuslOFlags = (oflags) => {
          var musl_oflags = 0;
          if (oflags & 1) {
            musl_oflags |= 64;
          }
          if (oflags & 8) {
            musl_oflags |= 512;
          }
          if (oflags & 2) {
            musl_oflags |= 65536;
          }
          if (oflags & 4) {
            musl_oflags |= 128;
          }
          return musl_oflags;
        };
        var _emscripten_unwind_to_js_event_loop = () => {
          throw "unwind";
        };
        _emscripten_unwind_to_js_event_loop.sig = "v";
        var setImmediateWrapped = (func2) => {
          setImmediateWrapped.mapping || (setImmediateWrapped.mapping = []);
          var id = setImmediateWrapped.mapping.length;
          setImmediateWrapped.mapping[id] = setImmediate(() => {
            setImmediateWrapped.mapping[id] = void 0;
            func2();
          });
          return id;
        };
        var clearImmediateWrapped = (id) => {
          clearImmediate(setImmediateWrapped.mapping[id]);
          setImmediateWrapped.mapping[id] = void 0;
        };
        var polyfillSetImmediate = () => {
        };
        var _emscripten_set_immediate = function(cb, userData) {
          cb >>>= 0;
          userData >>>= 0;
          return emSetImmediate(() => {
            callUserCallback(() => getWasmTableEntry(cb)(userData));
          });
        };
        _emscripten_set_immediate.sig = "ipp";
        var _emscripten_clear_immediate = (id) => {
          emClearImmediate(id);
        };
        _emscripten_clear_immediate.sig = "vi";
        var _emscripten_set_immediate_loop = function(cb, userData) {
          cb >>>= 0;
          userData >>>= 0;
          function tick() {
            callUserCallback(() => {
              if (getWasmTableEntry(cb)(userData)) {
                emSetImmediate(tick);
              } else {
              }
            });
          }
          emSetImmediate(tick);
        };
        _emscripten_set_immediate_loop.sig = "vpp";
        var _emscripten_set_timeout = function(cb, msecs, userData) {
          cb >>>= 0;
          userData >>>= 0;
          return safeSetTimeout(() => getWasmTableEntry(cb)(userData), msecs);
        };
        _emscripten_set_timeout.sig = "ipdp";
        var _emscripten_clear_timeout = clearTimeout;
        _emscripten_clear_timeout.sig = "vi";
        var _emscripten_set_timeout_loop = function(cb, msecs, userData) {
          cb >>>= 0;
          userData >>>= 0;
          function tick() {
            var t = _emscripten_get_now();
            var n = t + msecs;
            callUserCallback(() => {
              if (getWasmTableEntry(cb)(t, userData)) {
                setTimeout(tick, n - _emscripten_get_now());
              }
            });
          }
          return setTimeout(tick, 0);
        };
        _emscripten_set_timeout_loop.sig = "vpdp";
        var _emscripten_set_interval = function(cb, msecs, userData) {
          cb >>>= 0;
          userData >>>= 0;
          return setInterval(() => {
            callUserCallback(() => getWasmTableEntry(cb)(userData));
          }, msecs);
        };
        _emscripten_set_interval.sig = "ipdp";
        var _emscripten_clear_interval = (id) => {
          clearInterval(id);
        };
        _emscripten_clear_interval.sig = "vi";
        var idsToPromises = (idBuf, size) => {
          var promises = [];
          for (var i2 = 0; i2 < size; i2++) {
            var id = HEAP32[idBuf + i2 * 4 >>> 2 >>> 0];
            promises[i2] = getPromise(id);
          }
          return promises;
        };
        var makePromiseCallback = (callback, userData) => (value) => {
          var stack = stackSave();
          var resultPtr = stackAlloc(POINTER_SIZE);
          HEAPU32[resultPtr >>> 2 >>> 0] = 0;
          try {
            var result = getWasmTableEntry(callback)(resultPtr, userData, value);
            var resultVal = HEAPU32[resultPtr >>> 2 >>> 0];
          } catch (e) {
            if (typeof e !== "number") {
              throw 0;
            }
            throw e;
          } finally {
            stackRestore(stack);
          }
          switch (result) {
            case 0:
              return resultVal;
            case 1:
              return getPromise(resultVal);
            case 2:
              var ret = getPromise(resultVal);
              _emscripten_promise_destroy(resultVal);
              return ret;
            case 3:
              throw resultVal;
          }
        };
        function _emscripten_promise_then(id, onFulfilled, onRejected, userData) {
          id >>>= 0;
          onFulfilled >>>= 0;
          onRejected >>>= 0;
          userData >>>= 0;
          var promise = getPromise(id);
          var newId = promiseMap.allocate({
            promise: promise.then(makePromiseCallback(onFulfilled, userData), makePromiseCallback(onRejected, userData))
          });
          return newId;
        }
        _emscripten_promise_then.sig = "ppppp";
        var _emscripten_promise_all = function(idBuf, resultBuf, size) {
          idBuf >>>= 0;
          resultBuf >>>= 0;
          size >>>= 0;
          var promises = idsToPromises(idBuf, size);
          var id = promiseMap.allocate({
            promise: Promise.all(promises).then((results) => {
              if (resultBuf) {
                for (var i2 = 0; i2 < size; i2++) {
                  var result = results[i2];
                  HEAPU32[resultBuf + i2 * 4 >>> 2 >>> 0] = result;
                }
              }
              return resultBuf;
            })
          });
          return id;
        };
        _emscripten_promise_all.sig = "pppp";
        var setPromiseResult = (ptr2, fulfill, value) => {
          var result = fulfill ? 0 : 3;
          HEAP32[ptr2 >>> 2 >>> 0] = result;
          HEAPU32[ptr2 + 4 >>> 2 >>> 0] = value;
        };
        var _emscripten_promise_all_settled = function(idBuf, resultBuf, size) {
          idBuf >>>= 0;
          resultBuf >>>= 0;
          size >>>= 0;
          var promises = idsToPromises(idBuf, size);
          var id = promiseMap.allocate({
            promise: Promise.allSettled(promises).then((results) => {
              if (resultBuf) {
                var offset = resultBuf;
                for (var i2 = 0; i2 < size; i2++, offset += 8) {
                  if (results[i2].status === "fulfilled") {
                    setPromiseResult(offset, true, results[i2].value);
                  } else {
                    setPromiseResult(offset, false, results[i2].reason);
                  }
                }
              }
              return resultBuf;
            })
          });
          return id;
        };
        _emscripten_promise_all_settled.sig = "pppp";
        var _emscripten_promise_any = function(idBuf, errorBuf, size) {
          idBuf >>>= 0;
          errorBuf >>>= 0;
          size >>>= 0;
          var promises = idsToPromises(idBuf, size);
          var id = promiseMap.allocate({
            promise: Promise.any(promises).catch((err2) => {
              if (errorBuf) {
                for (var i2 = 0; i2 < size; i2++) {
                  HEAPU32[errorBuf + i2 * 4 >>> 2 >>> 0] = err2.errors[i2];
                }
              }
              throw errorBuf;
            })
          });
          return id;
        };
        _emscripten_promise_any.sig = "pppp";
        function _emscripten_promise_race(idBuf, size) {
          idBuf >>>= 0;
          size >>>= 0;
          var promises = idsToPromises(idBuf, size);
          var id = promiseMap.allocate({
            promise: Promise.race(promises)
          });
          return id;
        }
        _emscripten_promise_race.sig = "ppp";
        function _emscripten_promise_await(returnValuePtr, id) {
          returnValuePtr >>>= 0;
          id >>>= 0;
          abort("emscripten_promise_await is only available with ASYNCIFY");
        }
        _emscripten_promise_await.sig = "vpp";
        var getExceptionMessageCommon = (ptr2) => withStackSave(() => {
          var type_addr_addr = stackAlloc(4);
          var message_addr_addr = stackAlloc(4);
          ___get_exception_message(ptr2, type_addr_addr, message_addr_addr);
          var type_addr = HEAPU32[type_addr_addr >>> 2 >>> 0];
          var message_addr = HEAPU32[message_addr_addr >>> 2 >>> 0];
          var type = UTF8ToString(type_addr);
          _free(type_addr);
          var message;
          if (message_addr) {
            message = UTF8ToString(message_addr);
            _free(message_addr);
          }
          return [type, message];
        });
        var getCppExceptionTag = () => ___cpp_exception;
        var getCppExceptionThrownObjectFromWebAssemblyException = (ex) => {
          var unwind_header = ex.getArg(getCppExceptionTag(), 0);
          return ___thrown_object_from_unwind_exception(unwind_header);
        };
        var incrementExceptionRefcount = (ex) => {
          var ptr2 = getCppExceptionThrownObjectFromWebAssemblyException(ex);
          ___cxa_increment_exception_refcount(ptr2);
        };
        var decrementExceptionRefcount = (ex) => {
          var ptr2 = getCppExceptionThrownObjectFromWebAssemblyException(ex);
          ___cxa_decrement_exception_refcount(ptr2);
        };
        var getExceptionMessage = (ex) => {
          var ptr2 = getCppExceptionThrownObjectFromWebAssemblyException(ex);
          return getExceptionMessageCommon(ptr2);
        };
        var _emscripten_run_preload_plugins = function(file, onload2, onerror2) {
          file >>>= 0;
          onload2 >>>= 0;
          onerror2 >>>= 0;
          var _file = UTF8ToString(file);
          var data2 = FS.analyzePath(_file);
          if (!data2.exists)
            return -1;
          FS.createPreloadedFile(PATH.dirname(_file), PATH.basename(_file), new Uint8Array(data2.object.contents), true, true, () => {
            if (onload2)
              getWasmTableEntry(onload2)(file);
          }, () => {
            if (onerror2)
              getWasmTableEntry(onerror2)(file);
          }, true);
          return 0;
        };
        _emscripten_run_preload_plugins.sig = "ippp";
        var Browser_asyncPrepareDataCounter = 0;
        var _emscripten_run_preload_plugins_data = function(data2, size, suffix, arg, onload2, onerror2) {
          data2 >>>= 0;
          suffix >>>= 0;
          arg >>>= 0;
          onload2 >>>= 0;
          onerror2 >>>= 0;
          var _suffix = UTF8ToString(suffix);
          var name2 = "prepare_data_" + Browser_asyncPrepareDataCounter++ + "." + _suffix;
          var cname = stringToNewUTF8(name2);
          FS.createPreloadedFile("/", name2, HEAPU8.subarray(data2 >>> 0, data2 + size >>> 0), true, true, () => {
            if (onload2)
              getWasmTableEntry(onload2)(arg, cname);
          }, () => {
            if (onerror2)
              getWasmTableEntry(onerror2)(arg);
          }, true);
        };
        _emscripten_run_preload_plugins_data.sig = "vpipppp";
        var _emscripten_async_run_script = function(script2, millis) {
          script2 >>>= 0;
          safeSetTimeout(() => _emscripten_run_script(script2), millis);
        };
        _emscripten_async_run_script.sig = "vpi";
        var _emscripten_async_load_script = function(url, onload, onerror) {
          url >>>= 0;
          onload >>>= 0;
          onerror >>>= 0;
          url = UTF8ToString(url);
          onload = getWasmTableEntry(onload);
          onerror = getWasmTableEntry(onerror);
          assert(runDependencies === 0, "async_load_script must be run when no other dependencies are active");
          var loadDone = () => {
            if (onload) {
              if (runDependencies > 0) {
                dependenciesFulfilled = onload;
              } else {
                onload();
              }
            }
          };
          var loadError = () => {
            onerror == null ? void 0 : onerror();
          };
          if (ENVIRONMENT_IS_NODE) {
            readAsync(url, (data) => {
              eval(data);
              loadDone();
            }, loadError, false);
            return;
          }
          var script = document.createElement("script");
          script.onload = loadDone;
          script.onerror = loadError;
          script.src = url;
          document.body.appendChild(script);
        };
        _emscripten_async_load_script.sig = "vppp";
        function _emscripten_get_main_loop_timing(mode, value) {
          mode >>>= 0;
          value >>>= 0;
          if (mode)
            HEAP32[mode >>> 2 >>> 0] = Browser.mainLoop.timingMode;
          if (value)
            HEAP32[value >>> 2 >>> 0] = Browser.mainLoop.timingValue;
        }
        _emscripten_get_main_loop_timing.sig = "vpp";
        function _emscripten_set_main_loop(func2, fps, simulateInfiniteLoop) {
          func2 >>>= 0;
          var browserIterationFunc = getWasmTableEntry(func2);
          setMainLoop(browserIterationFunc, fps, simulateInfiniteLoop);
        }
        _emscripten_set_main_loop.sig = "vpii";
        var _emscripten_set_main_loop_arg = function(func2, arg, fps, simulateInfiniteLoop) {
          func2 >>>= 0;
          arg >>>= 0;
          var browserIterationFunc = () => getWasmTableEntry(func2)(arg);
          setMainLoop(browserIterationFunc, fps, simulateInfiniteLoop, arg);
        };
        _emscripten_set_main_loop_arg.sig = "vppii";
        var _emscripten_cancel_main_loop = () => {
          Browser.mainLoop.pause();
          Browser.mainLoop.func = null;
        };
        _emscripten_cancel_main_loop.sig = "v";
        var _emscripten_pause_main_loop = () => {
          Browser.mainLoop.pause();
        };
        _emscripten_pause_main_loop.sig = "v";
        var _emscripten_resume_main_loop = () => {
          Browser.mainLoop.resume();
        };
        _emscripten_resume_main_loop.sig = "v";
        var __emscripten_push_main_loop_blocker = function(func2, arg, name2) {
          func2 >>>= 0;
          arg >>>= 0;
          name2 >>>= 0;
          Browser.mainLoop.queue.push({
            func: () => {
              getWasmTableEntry(func2)(arg);
            },
            name: UTF8ToString(name2),
            counted: true
          });
          Browser.mainLoop.updateStatus();
        };
        __emscripten_push_main_loop_blocker.sig = "vppp";
        var __emscripten_push_uncounted_main_loop_blocker = function(func2, arg, name2) {
          func2 >>>= 0;
          arg >>>= 0;
          name2 >>>= 0;
          Browser.mainLoop.queue.push({
            func: () => {
              getWasmTableEntry(func2)(arg);
            },
            name: UTF8ToString(name2),
            counted: false
          });
          Browser.mainLoop.updateStatus();
        };
        __emscripten_push_uncounted_main_loop_blocker.sig = "vppp";
        var _emscripten_set_main_loop_expected_blockers = (num) => {
          Browser.mainLoop.expectedBlockers = num;
          Browser.mainLoop.remainingBlockers = num;
          Browser.mainLoop.updateStatus();
        };
        _emscripten_set_main_loop_expected_blockers.sig = "vi";
        function _emscripten_async_call(func2, arg, millis) {
          func2 >>>= 0;
          arg >>>= 0;
          function wrapper() {
            getWasmTableEntry(func2)(arg);
          }
          if (millis >= 0 || ENVIRONMENT_IS_NODE) {
            safeSetTimeout(wrapper, millis);
          } else {
            Browser.safeRequestAnimationFrame(wrapper);
          }
        }
        _emscripten_async_call.sig = "vppi";
        function _emscripten_get_window_title() {
          var buflen = 256;
          if (!_emscripten_get_window_title.buffer) {
            _emscripten_get_window_title.buffer = _malloc(buflen);
          }
          stringToUTF8(document.title, _emscripten_get_window_title.buffer, buflen);
          return _emscripten_get_window_title.buffer;
        }
        _emscripten_get_window_title.sig = "p";
        function _emscripten_set_window_title(title) {
          title >>>= 0;
          return document.title = UTF8ToString(title);
        }
        _emscripten_set_window_title.sig = "vp";
        function _emscripten_get_screen_size(width, height) {
          width >>>= 0;
          height >>>= 0;
          HEAP32[width >>> 2 >>> 0] = screen.width;
          HEAP32[height >>> 2 >>> 0] = screen.height;
        }
        _emscripten_get_screen_size.sig = "vpp";
        var _emscripten_hide_mouse = () => {
          var styleSheet = document.styleSheets[0];
          var rules = styleSheet.cssRules;
          for (var i2 = 0; i2 < rules.length; i2++) {
            if (rules[i2].cssText.substr(0, 6) == "canvas") {
              styleSheet.deleteRule(i2);
              i2--;
            }
          }
          styleSheet.insertRule("canvas.emscripten { border: 1px solid black; cursor: none; }", 0);
        };
        _emscripten_hide_mouse.sig = "v";
        var _emscripten_set_canvas_size = (width, height) => {
          Browser.setCanvasSize(width, height);
        };
        _emscripten_set_canvas_size.sig = "vii";
        function _emscripten_get_canvas_size(width, height, isFullscreen) {
          width >>>= 0;
          height >>>= 0;
          isFullscreen >>>= 0;
          var canvas = Module["canvas"];
          HEAP32[width >>> 2 >>> 0] = canvas.width;
          HEAP32[height >>> 2 >>> 0] = canvas.height;
          HEAP32[isFullscreen >>> 2 >>> 0] = Browser.isFullscreen ? 1 : 0;
        }
        _emscripten_get_canvas_size.sig = "vppp";
        function _emscripten_create_worker(url2) {
          url2 >>>= 0;
          url2 = UTF8ToString(url2);
          var id = Browser.workers.length;
          var info2 = {
            worker: new Worker(url2),
            callbacks: [],
            awaited: 0,
            buffer: 0,
            bufferSize: 0
          };
          info2.worker.onmessage = function info_worker_onmessage(msg) {
            if (ABORT)
              return;
            var info3 = Browser.workers[id];
            if (!info3)
              return;
            var callbackId = msg.data["callbackId"];
            var callbackInfo = info3.callbacks[callbackId];
            if (!callbackInfo)
              return;
            if (msg.data["finalResponse"]) {
              info3.awaited--;
              info3.callbacks[callbackId] = null;
            }
            var data2 = msg.data["data"];
            if (data2) {
              if (!data2.byteLength)
                data2 = new Uint8Array(data2);
              if (!info3.buffer || info3.bufferSize < data2.length) {
                if (info3.buffer)
                  _free(info3.buffer);
                info3.bufferSize = data2.length;
                info3.buffer = _malloc(data2.length);
              }
              HEAPU8.set(data2, info3.buffer >>> 0);
              callbackInfo.func(info3.buffer, data2.length, callbackInfo.arg);
            } else {
              callbackInfo.func(0, 0, callbackInfo.arg);
            }
          };
          Browser.workers.push(info2);
          return id;
        }
        _emscripten_create_worker.sig = "ip";
        var _emscripten_destroy_worker = (id) => {
          var info2 = Browser.workers[id];
          info2.worker.terminate();
          if (info2.buffer)
            _free(info2.buffer);
          Browser.workers[id] = null;
        };
        _emscripten_destroy_worker.sig = "vi";
        function _emscripten_call_worker(id, funcName, data2, size, callback, arg) {
          funcName >>>= 0;
          data2 >>>= 0;
          callback >>>= 0;
          arg >>>= 0;
          funcName = UTF8ToString(funcName);
          var info2 = Browser.workers[id];
          var callbackId = -1;
          if (callback) {
            callbackId = info2.callbacks.length;
            info2.callbacks.push({
              func: getWasmTableEntry(callback),
              arg
            });
            info2.awaited++;
          }
          var transferObject = {
            "funcName": funcName,
            "callbackId": callbackId,
            "data": data2 ? new Uint8Array(HEAPU8.subarray(data2 >>> 0, data2 + size >>> 0)) : 0
          };
          if (data2) {
            info2.worker.postMessage(transferObject, [transferObject.data.buffer]);
          } else {
            info2.worker.postMessage(transferObject);
          }
        }
        _emscripten_call_worker.sig = "vippipp";
        var _emscripten_get_worker_queue_size = (id) => {
          var info2 = Browser.workers[id];
          if (!info2)
            return -1;
          return info2.awaited;
        };
        _emscripten_get_worker_queue_size.sig = "ii";
        function _emscripten_get_preloaded_image_data(path2, w, h) {
          path2 >>>= 0;
          w >>>= 0;
          h >>>= 0;
          if ((path2 | 0) === path2)
            path2 = UTF8ToString(path2);
          path2 = PATH_FS.resolve(path2);
          var canvas = preloadedImages[path2];
          if (canvas) {
            var ctx = canvas.getContext("2d");
            var image = ctx.getImageData(0, 0, canvas.width, canvas.height);
            var buf = _malloc(canvas.width * canvas.height * 4);
            HEAPU8.set(image.data, buf >>> 0);
            HEAP32[w >>> 2 >>> 0] = canvas.width;
            HEAP32[h >>> 2 >>> 0] = canvas.height;
            return buf;
          }
          return 0;
        }
        _emscripten_get_preloaded_image_data.sig = "pppp";
        function _emscripten_get_preloaded_image_data_from_FILE(file, w, h) {
          file >>>= 0;
          w >>>= 0;
          h >>>= 0;
          var fd = _fileno(file);
          var stream = FS.getStream(fd);
          if (stream) {
            return _emscripten_get_preloaded_image_data(stream.path, w, h);
          }
          return 0;
        }
        _emscripten_get_preloaded_image_data_from_FILE.sig = "pppp";
        var wget = {
          wgetRequests: {},
          nextWgetRequestHandle: 0,
          getNextWgetRequestHandle() {
            var handle2 = wget.nextWgetRequestHandle;
            wget.nextWgetRequestHandle++;
            return handle2;
          }
        };
        var FS_mkdirTree = (path2, mode) => FS.mkdirTree(path2, mode);
        var FS_unlink = (path2) => FS.unlink(path2);
        var _emscripten_async_wget = function(url2, file, onload2, onerror2) {
          url2 >>>= 0;
          file >>>= 0;
          onload2 >>>= 0;
          onerror2 >>>= 0;
          var _url = UTF8ToString(url2);
          var _file = UTF8ToString(file);
          _file = PATH_FS.resolve(_file);
          function doCallback(callback) {
            if (callback) {
              callUserCallback(() => {
                withStackSave(() => {
                  getWasmTableEntry(callback)(stringToUTF8OnStack(_file));
                });
              });
            }
          }
          var destinationDirectory = PATH.dirname(_file);
          FS_createPreloadedFile(destinationDirectory, PATH.basename(_file), _url, true, true, () => doCallback(onload2), () => doCallback(onerror2), false, false, () => {
            try {
              FS_unlink(_file);
            } catch (e) {
            }
            FS_mkdirTree(destinationDirectory);
          });
        };
        _emscripten_async_wget.sig = "vpppp";
        var _emscripten_async_wget_data = function(url2, userdata, onload2, onerror2) {
          url2 >>>= 0;
          userdata >>>= 0;
          onload2 >>>= 0;
          onerror2 >>>= 0;
          asyncLoad(UTF8ToString(url2), (byteArray) => {
            callUserCallback(() => {
              var buffer = _malloc(byteArray.length);
              HEAPU8.set(byteArray, buffer >>> 0);
              getWasmTableEntry(onload2)(userdata, buffer, byteArray.length);
              _free(buffer);
            });
          }, () => {
            if (onerror2) {
              callUserCallback(() => {
                getWasmTableEntry(onerror2)(userdata);
              });
            }
          }, true);
        };
        _emscripten_async_wget_data.sig = "vpppp";
        var _emscripten_async_wget2 = function(url2, file, request, param, userdata, onload2, onerror2, onprogress) {
          url2 >>>= 0;
          file >>>= 0;
          request >>>= 0;
          param >>>= 0;
          userdata >>>= 0;
          onload2 >>>= 0;
          onerror2 >>>= 0;
          onprogress >>>= 0;
          var _url = UTF8ToString(url2);
          var _file = UTF8ToString(file);
          _file = PATH_FS.resolve(_file);
          var _request = UTF8ToString(request);
          var _param = UTF8ToString(param);
          var index = _file.lastIndexOf("/");
          var http = new XMLHttpRequest();
          http.open(_request, _url, true);
          http.responseType = "arraybuffer";
          var handle2 = wget.getNextWgetRequestHandle();
          var destinationDirectory = PATH.dirname(_file);
          http.onload = (e) => {
            if (http.status >= 200 && http.status < 300) {
              try {
                FS.unlink(_file);
              } catch (e2) {
              }
              FS.mkdirTree(destinationDirectory);
              FS.createDataFile(_file.substr(0, index), _file.substr(index + 1), new Uint8Array(http.response), true, true, false);
              if (onload2) {
                withStackSave(() => {
                  getWasmTableEntry(onload2)(handle2, userdata, stringToUTF8OnStack(_file));
                });
              }
            } else {
              if (onerror2)
                getWasmTableEntry(onerror2)(handle2, userdata, http.status);
            }
            delete wget.wgetRequests[handle2];
          };
          http.onerror = (e) => {
            if (onerror2)
              getWasmTableEntry(onerror2)(handle2, userdata, http.status);
            delete wget.wgetRequests[handle2];
          };
          http.onprogress = (e) => {
            if (e.lengthComputable || e.lengthComputable === void 0 && e.total != 0) {
              var percentComplete = e.loaded / e.total * 100;
              if (onprogress)
                getWasmTableEntry(onprogress)(handle2, userdata, percentComplete);
            }
          };
          http.onabort = (e) => {
            delete wget.wgetRequests[handle2];
          };
          if (_request == "POST") {
            http.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
            http.send(_param);
          } else {
            http.send(null);
          }
          wget.wgetRequests[handle2] = http;
          return handle2;
        };
        _emscripten_async_wget2.sig = "ipppppppp";
        var _emscripten_async_wget2_data = function(url2, request, param, userdata, free, onload2, onerror2, onprogress) {
          url2 >>>= 0;
          request >>>= 0;
          param >>>= 0;
          userdata >>>= 0;
          onload2 >>>= 0;
          onerror2 >>>= 0;
          onprogress >>>= 0;
          var _url = UTF8ToString(url2);
          var _request = UTF8ToString(request);
          var _param = UTF8ToString(param);
          var http = new XMLHttpRequest();
          http.open(_request, _url, true);
          http.responseType = "arraybuffer";
          var handle2 = wget.getNextWgetRequestHandle();
          function onerrorjs() {
            if (onerror2) {
              withStackSave(() => {
                var statusText = 0;
                if (http.statusText) {
                  statusText = stringToUTF8OnStack(http.statusText);
                }
                getWasmTableEntry(onerror2)(handle2, userdata, http.status, statusText);
              });
            }
          }
          http.onload = (e) => {
            if (http.status >= 200 && http.status < 300 || http.status === 0 && _url.substr(0, 4).toLowerCase() != "http") {
              var byteArray = new Uint8Array(http.response);
              var buffer = _malloc(byteArray.length);
              HEAPU8.set(byteArray, buffer >>> 0);
              if (onload2)
                getWasmTableEntry(onload2)(handle2, userdata, buffer, byteArray.length);
              if (free)
                _free(buffer);
            } else {
              onerrorjs();
            }
            delete wget.wgetRequests[handle2];
          };
          http.onerror = (e) => {
            onerrorjs();
            delete wget.wgetRequests[handle2];
          };
          http.onprogress = (e) => {
            if (onprogress)
              getWasmTableEntry(onprogress)(handle2, userdata, e.loaded, e.lengthComputable || e.lengthComputable === void 0 ? e.total : 0);
          };
          http.onabort = (e) => {
            delete wget.wgetRequests[handle2];
          };
          if (_request == "POST") {
            http.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
            http.send(_param);
          } else {
            http.send(null);
          }
          wget.wgetRequests[handle2] = http;
          return handle2;
        };
        _emscripten_async_wget2_data.sig = "ippppippp";
        var _emscripten_async_wget2_abort = (handle2) => {
          var http = wget.wgetRequests[handle2];
          http == null ? void 0 : http.abort();
        };
        _emscripten_async_wget2_abort.sig = "vi";
        function __dlsym_catchup_js(handle2, symbolIndex) {
          handle2 >>>= 0;
          var lib = LDSO.loadedLibsByHandle[handle2];
          var symDict = lib.exports;
          var symName = Object.keys(symDict)[symbolIndex];
          var sym = symDict[symName];
          var result = addFunction(sym, sym.sig);
          return result;
        }
        __dlsym_catchup_js.sig = "ppi";
        var _setNetworkCallback = (event2, userData, callback) => {
          function _callback(data2) {
            try {
              if (event2 === "error") {
                withStackSave(function() {
                  var msg = stringToUTF8OnStack(data2[2]);
                  getWasmTableEntry(callback)(data2[0], data2[1], msg, userData);
                });
              } else {
                getWasmTableEntry(callback)(data2, userData);
              }
            } catch (e) {
              if (!(e instanceof ExitStatus)) {
                if (e && typeof e == "object" && e.stack)
                  err("exception thrown: " + [e, e.stack]);
                throw e;
              }
            }
          }
          Module["websocket"]["on"](event2, callback ? _callback : null);
        };
        function _emscripten_set_socket_error_callback(userData, callback) {
          userData >>>= 0;
          callback >>>= 0;
          _setNetworkCallback("error", userData, callback);
        }
        _emscripten_set_socket_error_callback.sig = "vpp";
        function _emscripten_set_socket_open_callback(userData, callback) {
          userData >>>= 0;
          callback >>>= 0;
          _setNetworkCallback("open", userData, callback);
        }
        _emscripten_set_socket_open_callback.sig = "vpp";
        function _emscripten_set_socket_listen_callback(userData, callback) {
          userData >>>= 0;
          callback >>>= 0;
          _setNetworkCallback("listen", userData, callback);
        }
        _emscripten_set_socket_listen_callback.sig = "vpp";
        function _emscripten_set_socket_connection_callback(userData, callback) {
          userData >>>= 0;
          callback >>>= 0;
          _setNetworkCallback("connection", userData, callback);
        }
        _emscripten_set_socket_connection_callback.sig = "vpp";
        function _emscripten_set_socket_message_callback(userData, callback) {
          userData >>>= 0;
          callback >>>= 0;
          _setNetworkCallback("message", userData, callback);
        }
        _emscripten_set_socket_message_callback.sig = "vpp";
        function _emscripten_set_socket_close_callback(userData, callback) {
          userData >>>= 0;
          callback >>>= 0;
          _setNetworkCallback("close", userData, callback);
        }
        _emscripten_set_socket_close_callback.sig = "vpp";
        function _emscripten_webgl_enable_ANGLE_instanced_arrays(ctx) {
          ctx >>>= 0;
          return webgl_enable_ANGLE_instanced_arrays(GL.contexts[ctx].GLctx);
        }
        _emscripten_webgl_enable_ANGLE_instanced_arrays.sig = "ip";
        function _emscripten_webgl_enable_OES_vertex_array_object(ctx) {
          ctx >>>= 0;
          return webgl_enable_OES_vertex_array_object(GL.contexts[ctx].GLctx);
        }
        _emscripten_webgl_enable_OES_vertex_array_object.sig = "ip";
        function _emscripten_webgl_enable_WEBGL_draw_buffers(ctx) {
          ctx >>>= 0;
          return webgl_enable_WEBGL_draw_buffers(GL.contexts[ctx].GLctx);
        }
        _emscripten_webgl_enable_WEBGL_draw_buffers.sig = "ip";
        function _emscripten_webgl_enable_WEBGL_multi_draw(ctx) {
          ctx >>>= 0;
          return webgl_enable_WEBGL_multi_draw(GL.contexts[ctx].GLctx);
        }
        _emscripten_webgl_enable_WEBGL_multi_draw.sig = "ip";
        function _glVertexPointer(size, type, stride, ptr2) {
          ptr2 >>>= 0;
          throw "Legacy GL function (glVertexPointer) called. If you want legacy GL emulation, you need to compile with -sLEGACY_GL_EMULATION to enable legacy GL emulation.";
        }
        _glVertexPointer.sig = "viiip";
        var _glMatrixMode = () => {
          throw "Legacy GL function (glMatrixMode) called. If you want legacy GL emulation, you need to compile with -sLEGACY_GL_EMULATION to enable legacy GL emulation.";
        };
        _glMatrixMode.sig = "vi";
        var _glBegin = () => {
          throw "Legacy GL function (glBegin) called. If you want legacy GL emulation, you need to compile with -sLEGACY_GL_EMULATION to enable legacy GL emulation.";
        };
        _glBegin.sig = "vi";
        var _glLoadIdentity = () => {
          throw "Legacy GL function (glLoadIdentity) called. If you want legacy GL emulation, you need to compile with -sLEGACY_GL_EMULATION to enable legacy GL emulation.";
        };
        _glLoadIdentity.sig = "v";
        var _glVertexAttribDivisorNV = _glVertexAttribDivisor;
        var _glDrawArraysInstancedNV = _glDrawArraysInstanced;
        var _glDrawElementsInstancedNV = _glDrawElementsInstanced;
        var _glVertexAttribDivisorEXT = _glVertexAttribDivisor;
        var _glDrawArraysInstancedEXT = _glDrawArraysInstanced;
        var _glDrawElementsInstancedEXT = _glDrawElementsInstanced;
        var _glVertexAttribDivisorARB = _glVertexAttribDivisor;
        var _glDrawArraysInstancedARB = _glDrawArraysInstanced;
        var _glDrawElementsInstancedARB = _glDrawElementsInstanced;
        var _glDrawBuffersEXT = _glDrawBuffers;
        function _glMultiDrawArraysWEBGL(mode, firsts, counts, drawcount) {
          firsts >>>= 0;
          counts >>>= 0;
          GLctx.multiDrawWebgl["multiDrawArraysWEBGL"](mode, HEAP32, firsts >> 2, HEAP32, counts >> 2, drawcount);
        }
        _glMultiDrawArraysWEBGL.sig = "vippi";
        var _glMultiDrawArrays = _glMultiDrawArraysWEBGL;
        _glMultiDrawArrays.sig = "vippi";
        var _glMultiDrawArraysANGLE = _glMultiDrawArraysWEBGL;
        function _glMultiDrawArraysInstancedWEBGL(mode, firsts, counts, instanceCounts, drawcount) {
          firsts >>>= 0;
          counts >>>= 0;
          instanceCounts >>>= 0;
          GLctx.multiDrawWebgl["multiDrawArraysInstancedWEBGL"](mode, HEAP32, firsts >> 2, HEAP32, counts >> 2, HEAP32, instanceCounts >> 2, drawcount);
        }
        _glMultiDrawArraysInstancedWEBGL.sig = "vipppi";
        var _glMultiDrawArraysInstancedANGLE = _glMultiDrawArraysInstancedWEBGL;
        function _glMultiDrawElementsWEBGL(mode, counts, type, offsets, drawcount) {
          counts >>>= 0;
          offsets >>>= 0;
          GLctx.multiDrawWebgl["multiDrawElementsWEBGL"](mode, HEAP32, counts >> 2, type, HEAP32, offsets >> 2, drawcount);
        }
        _glMultiDrawElementsWEBGL.sig = "vipipi";
        var _glMultiDrawElements = _glMultiDrawElementsWEBGL;
        _glMultiDrawElements.sig = "vipipi";
        var _glMultiDrawElementsANGLE = _glMultiDrawElementsWEBGL;
        function _glMultiDrawElementsInstancedWEBGL(mode, counts, type, offsets, instanceCounts, drawcount) {
          counts >>>= 0;
          offsets >>>= 0;
          instanceCounts >>>= 0;
          GLctx.multiDrawWebgl["multiDrawElementsInstancedWEBGL"](mode, HEAP32, counts >> 2, type, HEAP32, offsets >> 2, HEAP32, instanceCounts >> 2, drawcount);
        }
        _glMultiDrawElementsInstancedWEBGL.sig = "vipippi";
        var _glMultiDrawElementsInstancedANGLE = _glMultiDrawElementsInstancedWEBGL;
        function _glClearDepth(x0) {
          GLctx.clearDepth(x0);
        }
        _glClearDepth.sig = "vd";
        function _glDepthRange(x0, x1) {
          GLctx.depthRange(x0, x1);
        }
        _glDepthRange.sig = "vdd";
        var _emscripten_glGenVertexArrays = _glGenVertexArrays;
        var _emscripten_glDeleteVertexArrays = _glDeleteVertexArrays;
        var _emscripten_glBindVertexArray = _glBindVertexArray;
        var _emscripten_glIsVertexArray = _glIsVertexArray;
        var _emscripten_glVertexPointer = _glVertexPointer;
        var _emscripten_glMatrixMode = _glMatrixMode;
        var _emscripten_glBegin = _glBegin;
        var _emscripten_glLoadIdentity = _glLoadIdentity;
        var _emscripten_glVertexAttribDivisor = _glVertexAttribDivisor;
        var _emscripten_glDrawArraysInstanced = _glDrawArraysInstanced;
        var _emscripten_glDrawElementsInstanced = _glDrawElementsInstanced;
        var _emscripten_glVertexAttribDivisorNV = _glVertexAttribDivisorNV;
        var _emscripten_glDrawArraysInstancedNV = _glDrawArraysInstancedNV;
        var _emscripten_glDrawElementsInstancedNV = _glDrawElementsInstancedNV;
        var _emscripten_glVertexAttribDivisorEXT = _glVertexAttribDivisorEXT;
        var _emscripten_glDrawArraysInstancedEXT = _glDrawArraysInstancedEXT;
        var _emscripten_glDrawElementsInstancedEXT = _glDrawElementsInstancedEXT;
        var _emscripten_glVertexAttribDivisorARB = _glVertexAttribDivisorARB;
        var _emscripten_glDrawArraysInstancedARB = _glDrawArraysInstancedARB;
        var _emscripten_glDrawElementsInstancedARB = _glDrawElementsInstancedARB;
        var _emscripten_glDrawBuffers = _glDrawBuffers;
        var _emscripten_glDrawBuffersEXT = _glDrawBuffersEXT;
        var _emscripten_glMultiDrawArrays = _glMultiDrawArrays;
        var _emscripten_glMultiDrawArraysANGLE = _glMultiDrawArraysANGLE;
        var _emscripten_glMultiDrawArraysWEBGL = _glMultiDrawArraysWEBGL;
        var _emscripten_glMultiDrawArraysInstancedANGLE = _glMultiDrawArraysInstancedANGLE;
        var _emscripten_glMultiDrawArraysInstancedWEBGL = _glMultiDrawArraysInstancedWEBGL;
        var _emscripten_glMultiDrawElements = _glMultiDrawElements;
        var _emscripten_glMultiDrawElementsANGLE = _glMultiDrawElementsANGLE;
        var _emscripten_glMultiDrawElementsWEBGL = _glMultiDrawElementsWEBGL;
        var _emscripten_glMultiDrawElementsInstancedANGLE = _glMultiDrawElementsInstancedANGLE;
        var _emscripten_glMultiDrawElementsInstancedWEBGL = _glMultiDrawElementsInstancedWEBGL;
        var _emscripten_glClearDepth = _glClearDepth;
        var _emscripten_glDepthRange = _glDepthRange;
        var writeGLArray = (arr, dst, dstLength, heapType) => {
          var len2 = arr.length;
          var writeLength = dstLength < len2 ? dstLength : len2;
          var heap = heapType ? HEAPF32 : HEAP32;
          for (var i2 = 0; i2 < writeLength; ++i2) {
            heap[(dst >> 2) + i2 >>> 0] = arr[i2];
          }
          return len2;
        };
        function _emscripten_webgl_init_context_attributes(attributes) {
          attributes >>>= 0;
          var a = attributes >> 2;
          for (var i2 = 0; i2 < 56 >> 2; ++i2) {
            HEAP32[a + i2 >>> 0] = 0;
          }
          HEAP32[a + (0 >> 2) >>> 0] = HEAP32[a + (4 >> 2) >>> 0] = HEAP32[a + (12 >> 2) >>> 0] = HEAP32[a + (16 >> 2) >>> 0] = HEAP32[a + (32 >> 2) >>> 0] = HEAP32[a + (40 >> 2) >>> 0] = 1;
        }
        _emscripten_webgl_init_context_attributes.sig = "vp";
        var emscripten_webgl_power_preferences = ["default", "low-power", "high-performance"];
        function _emscripten_webgl_do_create_context(target, attributes) {
          target >>>= 0;
          attributes >>>= 0;
          var a = attributes >> 2;
          var powerPreference = HEAP32[a + (24 >> 2) >>> 0];
          var contextAttributes = {
            "alpha": !!HEAP32[a + (0 >> 2) >>> 0],
            "depth": !!HEAP32[a + (4 >> 2) >>> 0],
            "stencil": !!HEAP32[a + (8 >> 2) >>> 0],
            "antialias": !!HEAP32[a + (12 >> 2) >>> 0],
            "premultipliedAlpha": !!HEAP32[a + (16 >> 2) >>> 0],
            "preserveDrawingBuffer": !!HEAP32[a + (20 >> 2) >>> 0],
            "powerPreference": emscripten_webgl_power_preferences[powerPreference],
            "failIfMajorPerformanceCaveat": !!HEAP32[a + (28 >> 2) >>> 0],
            majorVersion: HEAP32[a + (32 >> 2) >>> 0],
            minorVersion: HEAP32[a + (36 >> 2) >>> 0],
            enableExtensionsByDefault: HEAP32[a + (40 >> 2) >>> 0],
            explicitSwapControl: HEAP32[a + (44 >> 2) >>> 0],
            proxyContextToMainThread: HEAP32[a + (48 >> 2) >>> 0],
            renderViaOffscreenBackBuffer: HEAP32[a + (52 >> 2) >>> 0]
          };
          var canvas = findCanvasEventTarget(target);
          if (!canvas) {
            return 0;
          }
          if (contextAttributes.explicitSwapControl) {
            return 0;
          }
          var contextHandle = GL.createContext(canvas, contextAttributes);
          return contextHandle;
        }
        _emscripten_webgl_do_create_context.sig = "ppp";
        var _emscripten_webgl_create_context = _emscripten_webgl_do_create_context;
        _emscripten_webgl_create_context.sig = "ppp";
        function _emscripten_webgl_do_get_current_context() {
          return GL.currentContext ? GL.currentContext.handle : 0;
        }
        _emscripten_webgl_do_get_current_context.sig = "p";
        var _emscripten_webgl_get_current_context = _emscripten_webgl_do_get_current_context;
        _emscripten_webgl_get_current_context.sig = "p";
        var _emscripten_webgl_do_commit_frame = () => {
          if (!GL.currentContext || !GL.currentContext.GLctx) {
            return -3;
          }
          if (!GL.currentContext.attributes.explicitSwapControl) {
            return -3;
          }
          return 0;
        };
        _emscripten_webgl_do_commit_frame.sig = "i";
        var _emscripten_webgl_commit_frame = _emscripten_webgl_do_commit_frame;
        _emscripten_webgl_commit_frame.sig = "i";
        function _emscripten_webgl_make_context_current(contextHandle) {
          contextHandle >>>= 0;
          var success = GL.makeContextCurrent(contextHandle);
          return success ? 0 : -5;
        }
        _emscripten_webgl_make_context_current.sig = "ip";
        function _emscripten_webgl_get_drawing_buffer_size(contextHandle, width, height) {
          contextHandle >>>= 0;
          width >>>= 0;
          height >>>= 0;
          var GLContext = GL.getContext(contextHandle);
          if (!GLContext || !GLContext.GLctx || !width || !height) {
            return -5;
          }
          HEAP32[width >>> 2 >>> 0] = GLContext.GLctx.drawingBufferWidth;
          HEAP32[height >>> 2 >>> 0] = GLContext.GLctx.drawingBufferHeight;
          return 0;
        }
        _emscripten_webgl_get_drawing_buffer_size.sig = "ippp";
        function _emscripten_webgl_get_context_attributes(c, a) {
          c >>>= 0;
          a >>>= 0;
          if (!a)
            return -5;
          c = GL.contexts[c];
          if (!c)
            return -3;
          var t = c.GLctx;
          if (!t)
            return -3;
          t = t.getContextAttributes();
          HEAP32[a >>> 2 >>> 0] = t.alpha;
          HEAP32[a + 4 >>> 2 >>> 0] = t.depth;
          HEAP32[a + 8 >>> 2 >>> 0] = t.stencil;
          HEAP32[a + 12 >>> 2 >>> 0] = t.antialias;
          HEAP32[a + 16 >>> 2 >>> 0] = t.premultipliedAlpha;
          HEAP32[a + 20 >>> 2 >>> 0] = t.preserveDrawingBuffer;
          var power = t["powerPreference"] && emscripten_webgl_power_preferences.indexOf(t["powerPreference"]);
          HEAP32[a + 24 >>> 2 >>> 0] = power;
          HEAP32[a + 28 >>> 2 >>> 0] = t.failIfMajorPerformanceCaveat;
          HEAP32[a + 32 >>> 2 >>> 0] = c.version;
          HEAP32[a + 36 >>> 2 >>> 0] = 0;
          HEAP32[a + 40 >>> 2 >>> 0] = c.attributes.enableExtensionsByDefault;
          return 0;
        }
        _emscripten_webgl_get_context_attributes.sig = "ipp";
        function _emscripten_webgl_destroy_context(contextHandle) {
          contextHandle >>>= 0;
          if (GL.currentContext == contextHandle)
            GL.currentContext = 0;
          GL.deleteContext(contextHandle);
        }
        _emscripten_webgl_destroy_context.sig = "ip";
        function _emscripten_webgl_enable_extension(contextHandle, extension) {
          contextHandle >>>= 0;
          extension >>>= 0;
          var context = GL.getContext(contextHandle);
          var extString = UTF8ToString(extension);
          if (extString.startsWith("GL_"))
            extString = extString.substr(3);
          if (extString == "ANGLE_instanced_arrays")
            webgl_enable_ANGLE_instanced_arrays(GLctx);
          if (extString == "OES_vertex_array_object")
            webgl_enable_OES_vertex_array_object(GLctx);
          if (extString == "WEBGL_draw_buffers")
            webgl_enable_WEBGL_draw_buffers(GLctx);
          if (extString == "WEBGL_multi_draw")
            webgl_enable_WEBGL_multi_draw(GLctx);
          var ext = context.GLctx.getExtension(extString);
          return !!ext;
        }
        _emscripten_webgl_enable_extension.sig = "ipp";
        var _emscripten_supports_offscreencanvas = () => 0;
        _emscripten_supports_offscreencanvas.sig = "i";
        var registerWebGlEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
          var webGlEventHandlerFunc = (e = event) => {
            if (getWasmTableEntry(callbackfunc)(eventTypeId, 0, userData))
              e.preventDefault();
          };
          var eventHandler = {
            target: findEventTarget(target),
            eventTypeString,
            callbackfunc,
            handlerFunc: webGlEventHandlerFunc,
            useCapture
          };
          JSEvents.registerOrRemoveHandler(eventHandler);
        };
        function _emscripten_set_webglcontextlost_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
          target >>>= 0;
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          registerWebGlEventCallback(target, userData, useCapture, callbackfunc, 31, "webglcontextlost", targetThread);
          return 0;
        }
        _emscripten_set_webglcontextlost_callback_on_thread.sig = "ippipp";
        function _emscripten_set_webglcontextrestored_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
          target >>>= 0;
          userData >>>= 0;
          callbackfunc >>>= 0;
          targetThread >>>= 0;
          registerWebGlEventCallback(target, userData, useCapture, callbackfunc, 32, "webglcontextrestored", targetThread);
          return 0;
        }
        _emscripten_set_webglcontextrestored_callback_on_thread.sig = "ippipp";
        function _emscripten_is_webgl_context_lost(contextHandle) {
          contextHandle >>>= 0;
          return !GL.contexts[contextHandle] || GL.contexts[contextHandle].GLctx.isContextLost();
        }
        _emscripten_is_webgl_context_lost.sig = "ip";
        function _emscripten_webgl_get_supported_extensions() {
          return stringToNewUTF8(GLctx.getSupportedExtensions().join(" "));
        }
        _emscripten_webgl_get_supported_extensions.sig = "p";
        var _emscripten_webgl_get_program_parameter_d = (program, param) => GLctx.getProgramParameter(GL.programs[program], param);
        _emscripten_webgl_get_program_parameter_d.sig = "dii";
        function _emscripten_webgl_get_program_info_log_utf8(program) {
          return stringToNewUTF8(GLctx.getProgramInfoLog(GL.programs[program]));
        }
        _emscripten_webgl_get_program_info_log_utf8.sig = "pi";
        var _emscripten_webgl_get_shader_parameter_d = (shader, param) => GLctx.getShaderParameter(GL.shaders[shader], param);
        _emscripten_webgl_get_shader_parameter_d.sig = "dii";
        function _emscripten_webgl_get_shader_info_log_utf8(shader) {
          return stringToNewUTF8(GLctx.getShaderInfoLog(GL.shaders[shader]));
        }
        _emscripten_webgl_get_shader_info_log_utf8.sig = "pi";
        function _emscripten_webgl_get_shader_source_utf8(shader) {
          return stringToNewUTF8(GLctx.getShaderSource(GL.shaders[shader]));
        }
        _emscripten_webgl_get_shader_source_utf8.sig = "pi";
        var _emscripten_webgl_get_vertex_attrib_d = (index, param) => GLctx.getVertexAttrib(index, param);
        _emscripten_webgl_get_vertex_attrib_d.sig = "dii";
        var _emscripten_webgl_get_vertex_attrib_o = (index, param) => {
          var obj = GLctx.getVertexAttrib(index, param);
          return obj == null ? void 0 : obj.name;
        };
        _emscripten_webgl_get_vertex_attrib_o.sig = "iii";
        function _emscripten_webgl_get_vertex_attrib_v(index, param, dst, dstLength, dstType) {
          dst >>>= 0;
          return writeGLArray(GLctx.getVertexAttrib(index, param), dst, dstLength, dstType);
        }
        _emscripten_webgl_get_vertex_attrib_v.sig = "iiipii";
        var _emscripten_webgl_get_uniform_d = (program, location) => GLctx.getUniform(GL.programs[program], webglGetUniformLocation(location));
        _emscripten_webgl_get_uniform_d.sig = "dii";
        function _emscripten_webgl_get_uniform_v(program, location, dst, dstLength, dstType) {
          dst >>>= 0;
          return writeGLArray(GLctx.getUniform(GL.programs[program], webglGetUniformLocation(location)), dst, dstLength, dstType);
        }
        _emscripten_webgl_get_uniform_v.sig = "iiipii";
        function _emscripten_webgl_get_parameter_v(param, dst, dstLength, dstType) {
          dst >>>= 0;
          return writeGLArray(GLctx.getParameter(param), dst, dstLength, dstType);
        }
        _emscripten_webgl_get_parameter_v.sig = "iipii";
        var _emscripten_webgl_get_parameter_d = (param) => GLctx.getParameter(param);
        _emscripten_webgl_get_parameter_d.sig = "di";
        var _emscripten_webgl_get_parameter_o = (param) => {
          var obj = GLctx.getParameter(param);
          return obj == null ? void 0 : obj.name;
        };
        _emscripten_webgl_get_parameter_o.sig = "ii";
        function _emscripten_webgl_get_parameter_utf8(param) {
          return stringToNewUTF8(GLctx.getParameter(param));
        }
        _emscripten_webgl_get_parameter_utf8.sig = "pi";
        function _emscripten_webgl_get_parameter_i64v(param, dst) {
          dst >>>= 0;
          return writeI53ToI64(dst, GLctx.getParameter(param));
        }
        _emscripten_webgl_get_parameter_i64v.sig = "vip";
        var _glutPostRedisplay = () => {
          if (GLUT.displayFunc && !GLUT.requestedAnimationFrame) {
            GLUT.requestedAnimationFrame = true;
            Browser.requestAnimationFrame(function() {
              GLUT.requestedAnimationFrame = false;
              Browser.mainLoop.runIter(function() {
                getWasmTableEntry(GLUT.displayFunc)();
              });
            });
          }
        };
        _glutPostRedisplay.sig = "v";
        var GLUT = {
          initTime: null,
          idleFunc: null,
          displayFunc: null,
          keyboardFunc: null,
          keyboardUpFunc: null,
          specialFunc: null,
          specialUpFunc: null,
          reshapeFunc: null,
          motionFunc: null,
          passiveMotionFunc: null,
          mouseFunc: null,
          buttons: 0,
          modifiers: 0,
          initWindowWidth: 256,
          initWindowHeight: 256,
          initDisplayMode: 18,
          windowX: 0,
          windowY: 0,
          windowWidth: 0,
          windowHeight: 0,
          requestedAnimationFrame: false,
          saveModifiers: (event2) => {
            GLUT.modifiers = 0;
            if (event2["shiftKey"])
              GLUT.modifiers += 1;
            if (event2["ctrlKey"])
              GLUT.modifiers += 2;
            if (event2["altKey"])
              GLUT.modifiers += 4;
          },
          onMousemove: (event2) => {
            var lastX = Browser.mouseX;
            var lastY = Browser.mouseY;
            Browser.calculateMouseEvent(event2);
            var newX = Browser.mouseX;
            var newY = Browser.mouseY;
            if (newX == lastX && newY == lastY)
              return;
            if (GLUT.buttons == 0 && event2.target == Module["canvas"] && GLUT.passiveMotionFunc) {
              event2.preventDefault();
              GLUT.saveModifiers(event2);
              getWasmTableEntry(GLUT.passiveMotionFunc)(lastX, lastY);
            } else if (GLUT.buttons != 0 && GLUT.motionFunc) {
              event2.preventDefault();
              GLUT.saveModifiers(event2);
              getWasmTableEntry(GLUT.motionFunc)(lastX, lastY);
            }
          },
          getSpecialKey: (keycode) => {
            var key = null;
            switch (keycode) {
              case 8:
                key = 120;
                break;
              case 46:
                key = 111;
                break;
              case 112:
                key = 1;
                break;
              case 113:
                key = 2;
                break;
              case 114:
                key = 3;
                break;
              case 115:
                key = 4;
                break;
              case 116:
                key = 5;
                break;
              case 117:
                key = 6;
                break;
              case 118:
                key = 7;
                break;
              case 119:
                key = 8;
                break;
              case 120:
                key = 9;
                break;
              case 121:
                key = 10;
                break;
              case 122:
                key = 11;
                break;
              case 123:
                key = 12;
                break;
              case 37:
                key = 100;
                break;
              case 38:
                key = 101;
                break;
              case 39:
                key = 102;
                break;
              case 40:
                key = 103;
                break;
              case 33:
                key = 104;
                break;
              case 34:
                key = 105;
                break;
              case 36:
                key = 106;
                break;
              case 35:
                key = 107;
                break;
              case 45:
                key = 108;
                break;
              case 16:
              case 5:
                key = 112;
                break;
              case 6:
                key = 113;
                break;
              case 17:
              case 3:
                key = 114;
                break;
              case 4:
                key = 115;
                break;
              case 18:
              case 2:
                key = 116;
                break;
              case 1:
                key = 117;
                break;
            }
            return key;
          },
          getASCIIKey: (event2) => {
            if (event2["ctrlKey"] || event2["altKey"] || event2["metaKey"])
              return null;
            var keycode = event2["keyCode"];
            if (48 <= keycode && keycode <= 57)
              return keycode;
            if (65 <= keycode && keycode <= 90)
              return event2["shiftKey"] ? keycode : keycode + 32;
            if (96 <= keycode && keycode <= 105)
              return keycode - 48;
            if (106 <= keycode && keycode <= 111)
              return keycode - 106 + 42;
            switch (keycode) {
              case 9:
              case 13:
              case 27:
              case 32:
              case 61:
                return keycode;
            }
            var s2 = event2["shiftKey"];
            switch (keycode) {
              case 186:
                return s2 ? 58 : 59;
              case 187:
                return s2 ? 43 : 61;
              case 188:
                return s2 ? 60 : 44;
              case 189:
                return s2 ? 95 : 45;
              case 190:
                return s2 ? 62 : 46;
              case 191:
                return s2 ? 63 : 47;
              case 219:
                return s2 ? 123 : 91;
              case 220:
                return s2 ? 124 : 47;
              case 221:
                return s2 ? 125 : 93;
              case 222:
                return s2 ? 34 : 39;
            }
            return null;
          },
          onKeydown: (event2) => {
            if (GLUT.specialFunc || GLUT.keyboardFunc) {
              var key = GLUT.getSpecialKey(event2["keyCode"]);
              if (key !== null) {
                if (GLUT.specialFunc) {
                  event2.preventDefault();
                  GLUT.saveModifiers(event2);
                  getWasmTableEntry(GLUT.specialFunc)(key, Browser.mouseX, Browser.mouseY);
                }
              } else {
                key = GLUT.getASCIIKey(event2);
                if (key !== null && GLUT.keyboardFunc) {
                  event2.preventDefault();
                  GLUT.saveModifiers(event2);
                  getWasmTableEntry(GLUT.keyboardFunc)(key, Browser.mouseX, Browser.mouseY);
                }
              }
            }
          },
          onKeyup: (event2) => {
            if (GLUT.specialUpFunc || GLUT.keyboardUpFunc) {
              var key = GLUT.getSpecialKey(event2["keyCode"]);
              if (key !== null) {
                if (GLUT.specialUpFunc) {
                  event2.preventDefault();
                  GLUT.saveModifiers(event2);
                  getWasmTableEntry(GLUT.specialUpFunc)(key, Browser.mouseX, Browser.mouseY);
                }
              } else {
                key = GLUT.getASCIIKey(event2);
                if (key !== null && GLUT.keyboardUpFunc) {
                  event2.preventDefault();
                  GLUT.saveModifiers(event2);
                  getWasmTableEntry(GLUT.keyboardUpFunc)(key, Browser.mouseX, Browser.mouseY);
                }
              }
            }
          },
          touchHandler: (event2) => {
            if (event2.target != Module["canvas"]) {
              return;
            }
            var touches = event2.changedTouches, main = touches[0], type = "";
            switch (event2.type) {
              case "touchstart":
                type = "mousedown";
                break;
              case "touchmove":
                type = "mousemove";
                break;
              case "touchend":
                type = "mouseup";
                break;
              default:
                return;
            }
            var simulatedEvent = document.createEvent("MouseEvent");
            simulatedEvent.initMouseEvent(type, true, true, window, 1, main.screenX, main.screenY, main.clientX, main.clientY, false, false, false, false, 0, null);
            main.target.dispatchEvent(simulatedEvent);
            event2.preventDefault();
          },
          onMouseButtonDown: (event2) => {
            Browser.calculateMouseEvent(event2);
            GLUT.buttons |= 1 << event2["button"];
            if (event2.target == Module["canvas"] && GLUT.mouseFunc) {
              try {
                event2.target.setCapture();
              } catch (e) {
              }
              event2.preventDefault();
              GLUT.saveModifiers(event2);
              getWasmTableEntry(GLUT.mouseFunc)(event2["button"], 0, Browser.mouseX, Browser.mouseY);
            }
          },
          onMouseButtonUp: (event2) => {
            Browser.calculateMouseEvent(event2);
            GLUT.buttons &= ~(1 << event2["button"]);
            if (GLUT.mouseFunc) {
              event2.preventDefault();
              GLUT.saveModifiers(event2);
              getWasmTableEntry(GLUT.mouseFunc)(event2["button"], 1, Browser.mouseX, Browser.mouseY);
            }
          },
          onMouseWheel: (event2) => {
            Browser.calculateMouseEvent(event2);
            var e = window.event || event2;
            var delta = -Browser.getMouseWheelDelta(event2);
            delta = delta == 0 ? 0 : delta > 0 ? Math.max(delta, 1) : Math.min(delta, -1);
            var button = 3;
            if (delta < 0) {
              button = 4;
            }
            if (GLUT.mouseFunc) {
              event2.preventDefault();
              GLUT.saveModifiers(event2);
              getWasmTableEntry(GLUT.mouseFunc)(button, 0, Browser.mouseX, Browser.mouseY);
            }
          },
          onFullscreenEventChange: (event2) => {
            var width;
            var height;
            if (document["fullscreen"] || document["fullScreen"] || document["mozFullScreen"] || document["webkitIsFullScreen"]) {
              width = screen["width"];
              height = screen["height"];
            } else {
              width = GLUT.windowWidth;
              height = GLUT.windowHeight;
              document.removeEventListener("fullscreenchange", GLUT.onFullscreenEventChange, true);
              document.removeEventListener("mozfullscreenchange", GLUT.onFullscreenEventChange, true);
              document.removeEventListener("webkitfullscreenchange", GLUT.onFullscreenEventChange, true);
            }
            Browser.setCanvasSize(width, height, true);
            if (GLUT.reshapeFunc) {
              getWasmTableEntry(GLUT.reshapeFunc)(width, height);
            }
            _glutPostRedisplay();
          }
        };
        var _glutGetModifiers = () => GLUT.modifiers;
        _glutGetModifiers.sig = "i";
        function _glutInit(argcp, argv) {
          argcp >>>= 0;
          argv >>>= 0;
          GLUT.initTime = Date.now();
          var isTouchDevice = "ontouchstart" in document.documentElement;
          if (isTouchDevice) {
            window.addEventListener("touchmove", GLUT.touchHandler, true);
            window.addEventListener("touchstart", GLUT.touchHandler, true);
            window.addEventListener("touchend", GLUT.touchHandler, true);
          }
          window.addEventListener("keydown", GLUT.onKeydown, true);
          window.addEventListener("keyup", GLUT.onKeyup, true);
          window.addEventListener("mousemove", GLUT.onMousemove, true);
          window.addEventListener("mousedown", GLUT.onMouseButtonDown, true);
          window.addEventListener("mouseup", GLUT.onMouseButtonUp, true);
          window.addEventListener("mousewheel", GLUT.onMouseWheel, true);
          window.addEventListener("DOMMouseScroll", GLUT.onMouseWheel, true);
          Browser.resizeListeners.push(function(width, height) {
            if (GLUT.reshapeFunc) {
              getWasmTableEntry(GLUT.reshapeFunc)(width, height);
            }
          });
          __ATEXIT__.push(function() {
            if (isTouchDevice) {
              window.removeEventListener("touchmove", GLUT.touchHandler, true);
              window.removeEventListener("touchstart", GLUT.touchHandler, true);
              window.removeEventListener("touchend", GLUT.touchHandler, true);
            }
            window.removeEventListener("keydown", GLUT.onKeydown, true);
            window.removeEventListener("keyup", GLUT.onKeyup, true);
            window.removeEventListener("mousemove", GLUT.onMousemove, true);
            window.removeEventListener("mousedown", GLUT.onMouseButtonDown, true);
            window.removeEventListener("mouseup", GLUT.onMouseButtonUp, true);
            window.removeEventListener("mousewheel", GLUT.onMouseWheel, true);
            window.removeEventListener("DOMMouseScroll", GLUT.onMouseWheel, true);
            Module["canvas"].width = Module["canvas"].height = 1;
          });
        }
        _glutInit.sig = "vpp";
        var _glutInitWindowSize = (width, height) => {
          Browser.setCanvasSize(GLUT.initWindowWidth = width, GLUT.initWindowHeight = height);
        };
        _glutInitWindowSize.sig = "vii";
        var _glutInitWindowPosition = (x, y) => {
        };
        _glutInitWindowPosition.sig = "vii";
        var _glutGet = (type) => {
          switch (type) {
            case 100:
              return 0;
            case 101:
              return 0;
            case 102:
              return Module["canvas"].width;
            case 103:
              return Module["canvas"].height;
            case 200:
              return Module["canvas"].width;
            case 201:
              return Module["canvas"].height;
            case 500:
              return 0;
            case 501:
              return 0;
            case 502:
              return GLUT.initWindowWidth;
            case 503:
              return GLUT.initWindowHeight;
            case 700:
              var now = Date.now();
              return now - GLUT.initTime;
            case 105:
              return Module.ctx.getContextAttributes().stencil ? 8 : 0;
            case 106:
              return Module.ctx.getContextAttributes().depth ? 8 : 0;
            case 110:
              return Module.ctx.getContextAttributes().alpha ? 8 : 0;
            case 120:
              return Module.ctx.getContextAttributes().antialias ? 1 : 0;
            default:
              throw "glutGet(" + type + ") not implemented yet";
          }
        };
        _glutGet.sig = "ii";
        function _glutIdleFunc(func2) {
          func2 >>>= 0;
          function callback() {
            if (GLUT.idleFunc) {
              getWasmTableEntry(GLUT.idleFunc)();
              safeSetTimeout(callback, 4);
            }
          }
          if (!GLUT.idleFunc) {
            safeSetTimeout(callback, 0);
          }
          GLUT.idleFunc = func2;
        }
        _glutIdleFunc.sig = "vp";
        var _glutTimerFunc = function(msec, func2, value) {
          func2 >>>= 0;
          return safeSetTimeout(() => getWasmTableEntry(func2)(value), msec);
        };
        _glutTimerFunc.sig = "vipi";
        function _glutDisplayFunc(func2) {
          func2 >>>= 0;
          GLUT.displayFunc = func2;
        }
        _glutDisplayFunc.sig = "vp";
        function _glutKeyboardFunc(func2) {
          func2 >>>= 0;
          GLUT.keyboardFunc = func2;
        }
        _glutKeyboardFunc.sig = "vp";
        function _glutKeyboardUpFunc(func2) {
          func2 >>>= 0;
          GLUT.keyboardUpFunc = func2;
        }
        _glutKeyboardUpFunc.sig = "vp";
        function _glutSpecialFunc(func2) {
          func2 >>>= 0;
          GLUT.specialFunc = func2;
        }
        _glutSpecialFunc.sig = "vp";
        function _glutSpecialUpFunc(func2) {
          func2 >>>= 0;
          GLUT.specialUpFunc = func2;
        }
        _glutSpecialUpFunc.sig = "vp";
        function _glutReshapeFunc(func2) {
          func2 >>>= 0;
          GLUT.reshapeFunc = func2;
        }
        _glutReshapeFunc.sig = "vp";
        function _glutMotionFunc(func2) {
          func2 >>>= 0;
          GLUT.motionFunc = func2;
        }
        _glutMotionFunc.sig = "vp";
        function _glutPassiveMotionFunc(func2) {
          func2 >>>= 0;
          GLUT.passiveMotionFunc = func2;
        }
        _glutPassiveMotionFunc.sig = "vp";
        function _glutMouseFunc(func2) {
          func2 >>>= 0;
          GLUT.mouseFunc = func2;
        }
        _glutMouseFunc.sig = "vp";
        var _glutSetCursor = (cursor) => {
          var cursorStyle = "auto";
          switch (cursor) {
            case 0:
              break;
            case 1:
              break;
            case 2:
              cursorStyle = "pointer";
              break;
            case 3:
              break;
            case 4:
              cursorStyle = "help";
              break;
            case 5:
              break;
            case 6:
              break;
            case 7:
              cursorStyle = "wait";
              break;
            case 8:
              cursorStyle = "text";
              break;
            case 9:
            case 102:
              cursorStyle = "crosshair";
              break;
            case 10:
              cursorStyle = "ns-resize";
              break;
            case 11:
              cursorStyle = "ew-resize";
              break;
            case 12:
              cursorStyle = "n-resize";
              break;
            case 13:
              cursorStyle = "s-resize";
              break;
            case 14:
              cursorStyle = "w-resize";
              break;
            case 15:
              cursorStyle = "e-resize";
              break;
            case 16:
              cursorStyle = "nw-resize";
              break;
            case 17:
              cursorStyle = "ne-resize";
              break;
            case 18:
              cursorStyle = "se-resize";
              break;
            case 19:
              cursorStyle = "sw-resize";
              break;
            case 100:
              break;
            case 101:
              cursorStyle = "none";
              break;
            default:
              throw "glutSetCursor: Unknown cursor type: " + cursor;
          }
          Module["canvas"].style.cursor = cursorStyle;
        };
        _glutSetCursor.sig = "vi";
        function _glutCreateWindow(name2) {
          name2 >>>= 0;
          var contextAttributes = {
            antialias: (GLUT.initDisplayMode & 128) != 0,
            depth: (GLUT.initDisplayMode & 16) != 0,
            stencil: (GLUT.initDisplayMode & 32) != 0,
            alpha: (GLUT.initDisplayMode & 8) != 0
          };
          Module.ctx = Browser.createContext(Module["canvas"], true, true, contextAttributes);
          return Module.ctx ? 1 : 0;
        }
        _glutCreateWindow.sig = "ip";
        var _glutDestroyWindow = (name2) => {
          Module.ctx = Browser.destroyContext(Module["canvas"], true, true);
          return 1;
        };
        _glutDestroyWindow.sig = "vi";
        var _glutReshapeWindow = (width, height) => {
          Browser.exitFullscreen();
          Browser.setCanvasSize(width, height, true);
          if (GLUT.reshapeFunc) {
            getWasmTableEntry(GLUT.reshapeFunc)(width, height);
          }
          _glutPostRedisplay();
        };
        _glutReshapeWindow.sig = "vii";
        var _glutPositionWindow = (x, y) => {
          Browser.exitFullscreen();
          _glutPostRedisplay();
        };
        _glutPositionWindow.sig = "vii";
        var _glutFullScreen = () => {
          GLUT.windowX = 0;
          GLUT.windowY = 0;
          GLUT.windowWidth = Module["canvas"].width;
          GLUT.windowHeight = Module["canvas"].height;
          document.addEventListener("fullscreenchange", GLUT.onFullscreenEventChange, true);
          document.addEventListener("mozfullscreenchange", GLUT.onFullscreenEventChange, true);
          document.addEventListener("webkitfullscreenchange", GLUT.onFullscreenEventChange, true);
          Browser.requestFullscreen(false, false);
        };
        _glutFullScreen.sig = "v";
        var _glutInitDisplayMode = (mode) => GLUT.initDisplayMode = mode;
        _glutInitDisplayMode.sig = "vi";
        var _glutSwapBuffers = () => {
        };
        _glutSwapBuffers.sig = "v";
        var _glutMainLoop = () => {
          _glutReshapeWindow(Module["canvas"].width, Module["canvas"].height);
          _glutPostRedisplay();
          throw "unwind";
        };
        _glutMainLoop.sig = "v";
        function _XOpenDisplay(name2) {
          name2 >>>= 0;
          return 1;
        }
        _XOpenDisplay.sig = "pp";
        function _XCreateWindow(display, parent, x, y, width, height, border_width, depth, class_, visual, valuemask, attributes) {
          display >>>= 0;
          parent >>>= 0;
          visual >>>= 0;
          valuemask >>>= 0;
          attributes >>>= 0;
          Browser.setCanvasSize(width, height);
          return 2;
        }
        _XCreateWindow.sig = "pppiiiiiiippp";
        function _XChangeWindowAttributes(display, window2, valuemask, attributes) {
          display >>>= 0;
          window2 >>>= 0;
          valuemask >>>= 0;
          attributes >>>= 0;
        }
        _XChangeWindowAttributes.sig = "ipppp";
        function _XSetWMHints(display, win, hints) {
          display >>>= 0;
          win >>>= 0;
          hints >>>= 0;
        }
        _XSetWMHints.sig = "ippp";
        function _XMapWindow(display, win) {
          display >>>= 0;
          win >>>= 0;
        }
        _XMapWindow.sig = "ipp";
        function _XStoreName(display, win, name2) {
          display >>>= 0;
          win >>>= 0;
          name2 >>>= 0;
        }
        _XStoreName.sig = "ippp";
        function _XInternAtom(display, name_, hmm) {
          display >>>= 0;
          name_ >>>= 0;
          return 0;
        }
        _XInternAtom.sig = "pppi";
        function _XSendEvent(display, win, propagate, event_mask, even_send) {
          display >>>= 0;
          win >>>= 0;
          event_mask >>>= 0;
          even_send >>>= 0;
        }
        _XSendEvent.sig = "ippipp";
        function _XPending(display) {
          display >>>= 0;
          return 0;
        }
        _XPending.sig = "ip";
        var EGL = {
          errorCode: 12288,
          defaultDisplayInitialized: false,
          currentContext: 0,
          currentReadSurface: 0,
          currentDrawSurface: 0,
          contextAttributes: {
            alpha: false,
            depth: false,
            stencil: false,
            antialias: false
          },
          stringCache: {},
          setErrorCode(code) {
            EGL.errorCode = code;
          },
          chooseConfig(display, attribList, config, config_size, numConfigs) {
            if (display != 62e3) {
              EGL.setErrorCode(12296);
              return 0;
            }
            if (attribList) {
              for (; ; ) {
                var param = HEAP32[attribList >>> 2 >>> 0];
                if (param == 12321) {
                  var alphaSize = HEAP32[attribList + 4 >>> 2 >>> 0];
                  EGL.contextAttributes.alpha = alphaSize > 0;
                } else if (param == 12325) {
                  var depthSize = HEAP32[attribList + 4 >>> 2 >>> 0];
                  EGL.contextAttributes.depth = depthSize > 0;
                } else if (param == 12326) {
                  var stencilSize = HEAP32[attribList + 4 >>> 2 >>> 0];
                  EGL.contextAttributes.stencil = stencilSize > 0;
                } else if (param == 12337) {
                  var samples = HEAP32[attribList + 4 >>> 2 >>> 0];
                  EGL.contextAttributes.antialias = samples > 0;
                } else if (param == 12338) {
                  var samples = HEAP32[attribList + 4 >>> 2 >>> 0];
                  EGL.contextAttributes.antialias = samples == 1;
                } else if (param == 12544) {
                  var requestedPriority = HEAP32[attribList + 4 >>> 2 >>> 0];
                  EGL.contextAttributes.lowLatency = requestedPriority != 12547;
                } else if (param == 12344) {
                  break;
                }
                attribList += 8;
              }
            }
            if ((!config || !config_size) && !numConfigs) {
              EGL.setErrorCode(12300);
              return 0;
            }
            if (numConfigs) {
              HEAP32[numConfigs >>> 2 >>> 0] = 1;
            }
            if (config && config_size > 0) {
              HEAPU32[config >>> 2 >>> 0] = 62002;
            }
            EGL.setErrorCode(12288);
            return 1;
          }
        };
        function _eglGetDisplay(nativeDisplayType) {
          nativeDisplayType >>>= 0;
          EGL.setErrorCode(12288);
          if (nativeDisplayType != 0 && nativeDisplayType != 1) {
            return 0;
          }
          return 62e3;
        }
        _eglGetDisplay.sig = "pp";
        function _eglInitialize(display, majorVersion, minorVersion) {
          display >>>= 0;
          majorVersion >>>= 0;
          minorVersion >>>= 0;
          if (display != 62e3) {
            EGL.setErrorCode(12296);
            return 0;
          }
          if (majorVersion) {
            HEAP32[majorVersion >>> 2 >>> 0] = 1;
          }
          if (minorVersion) {
            HEAP32[minorVersion >>> 2 >>> 0] = 4;
          }
          EGL.defaultDisplayInitialized = true;
          EGL.setErrorCode(12288);
          return 1;
        }
        _eglInitialize.sig = "ippp";
        function _eglTerminate(display) {
          display >>>= 0;
          if (display != 62e3) {
            EGL.setErrorCode(12296);
            return 0;
          }
          EGL.currentContext = 0;
          EGL.currentReadSurface = 0;
          EGL.currentDrawSurface = 0;
          EGL.defaultDisplayInitialized = false;
          EGL.setErrorCode(12288);
          return 1;
        }
        _eglTerminate.sig = "ip";
        function _eglGetConfigs(display, configs, config_size, numConfigs) {
          display >>>= 0;
          configs >>>= 0;
          numConfigs >>>= 0;
          return EGL.chooseConfig(display, 0, configs, config_size, numConfigs);
        }
        _eglGetConfigs.sig = "ippip";
        function _eglChooseConfig(display, attrib_list, configs, config_size, numConfigs) {
          display >>>= 0;
          attrib_list >>>= 0;
          configs >>>= 0;
          numConfigs >>>= 0;
          return EGL.chooseConfig(display, attrib_list, configs, config_size, numConfigs);
        }
        _eglChooseConfig.sig = "ipppip";
        function _eglGetConfigAttrib(display, config, attribute, value) {
          display >>>= 0;
          config >>>= 0;
          value >>>= 0;
          if (display != 62e3) {
            EGL.setErrorCode(12296);
            return 0;
          }
          if (config != 62002) {
            EGL.setErrorCode(12293);
            return 0;
          }
          if (!value) {
            EGL.setErrorCode(12300);
            return 0;
          }
          EGL.setErrorCode(12288);
          switch (attribute) {
            case 12320:
              HEAP32[value >>> 2 >>> 0] = EGL.contextAttributes.alpha ? 32 : 24;
              return 1;
            case 12321:
              HEAP32[value >>> 2 >>> 0] = EGL.contextAttributes.alpha ? 8 : 0;
              return 1;
            case 12322:
              HEAP32[value >>> 2 >>> 0] = 8;
              return 1;
            case 12323:
              HEAP32[value >>> 2 >>> 0] = 8;
              return 1;
            case 12324:
              HEAP32[value >>> 2 >>> 0] = 8;
              return 1;
            case 12325:
              HEAP32[value >>> 2 >>> 0] = EGL.contextAttributes.depth ? 24 : 0;
              return 1;
            case 12326:
              HEAP32[value >>> 2 >>> 0] = EGL.contextAttributes.stencil ? 8 : 0;
              return 1;
            case 12327:
              HEAP32[value >>> 2 >>> 0] = 12344;
              return 1;
            case 12328:
              HEAP32[value >>> 2 >>> 0] = 62002;
              return 1;
            case 12329:
              HEAP32[value >>> 2 >>> 0] = 0;
              return 1;
            case 12330:
              HEAP32[value >>> 2 >>> 0] = 4096;
              return 1;
            case 12331:
              HEAP32[value >>> 2 >>> 0] = 16777216;
              return 1;
            case 12332:
              HEAP32[value >>> 2 >>> 0] = 4096;
              return 1;
            case 12333:
              HEAP32[value >>> 2 >>> 0] = 0;
              return 1;
            case 12334:
              HEAP32[value >>> 2 >>> 0] = 0;
              return 1;
            case 12335:
              HEAP32[value >>> 2 >>> 0] = 12344;
              return 1;
            case 12337:
              HEAP32[value >>> 2 >>> 0] = EGL.contextAttributes.antialias ? 4 : 0;
              return 1;
            case 12338:
              HEAP32[value >>> 2 >>> 0] = EGL.contextAttributes.antialias ? 1 : 0;
              return 1;
            case 12339:
              HEAP32[value >>> 2 >>> 0] = 4;
              return 1;
            case 12340:
              HEAP32[value >>> 2 >>> 0] = 12344;
              return 1;
            case 12341:
            case 12342:
            case 12343:
              HEAP32[value >>> 2 >>> 0] = -1;
              return 1;
            case 12345:
            case 12346:
              HEAP32[value >>> 2 >>> 0] = 0;
              return 1;
            case 12347:
              HEAP32[value >>> 2 >>> 0] = 0;
              return 1;
            case 12348:
              HEAP32[value >>> 2 >>> 0] = 1;
              return 1;
            case 12349:
            case 12350:
              HEAP32[value >>> 2 >>> 0] = 0;
              return 1;
            case 12351:
              HEAP32[value >>> 2 >>> 0] = 12430;
              return 1;
            case 12352:
              HEAP32[value >>> 2 >>> 0] = 4;
              return 1;
            case 12354:
              HEAP32[value >>> 2 >>> 0] = 0;
              return 1;
            default:
              EGL.setErrorCode(12292);
              return 0;
          }
        }
        _eglGetConfigAttrib.sig = "ippip";
        function _eglCreateWindowSurface(display, config, win, attrib_list) {
          display >>>= 0;
          config >>>= 0;
          attrib_list >>>= 0;
          if (display != 62e3) {
            EGL.setErrorCode(12296);
            return 0;
          }
          if (config != 62002) {
            EGL.setErrorCode(12293);
            return 0;
          }
          EGL.setErrorCode(12288);
          return 62006;
        }
        _eglCreateWindowSurface.sig = "pppip";
        function _eglDestroySurface(display, surface) {
          display >>>= 0;
          surface >>>= 0;
          if (display != 62e3) {
            EGL.setErrorCode(12296);
            return 0;
          }
          if (surface != 62006) {
            EGL.setErrorCode(12301);
            return 1;
          }
          if (EGL.currentReadSurface == surface) {
            EGL.currentReadSurface = 0;
          }
          if (EGL.currentDrawSurface == surface) {
            EGL.currentDrawSurface = 0;
          }
          EGL.setErrorCode(12288);
          return 1;
        }
        _eglDestroySurface.sig = "ipp";
        function _eglCreateContext(display, config, hmm, contextAttribs) {
          display >>>= 0;
          config >>>= 0;
          hmm >>>= 0;
          contextAttribs >>>= 0;
          if (display != 62e3) {
            EGL.setErrorCode(12296);
            return 0;
          }
          var glesContextVersion = 1;
          for (; ; ) {
            var param = HEAP32[contextAttribs >>> 2 >>> 0];
            if (param == 12440) {
              glesContextVersion = HEAP32[contextAttribs + 4 >>> 2 >>> 0];
            } else if (param == 12344) {
              break;
            } else {
              EGL.setErrorCode(12292);
              return 0;
            }
            contextAttribs += 8;
          }
          if (glesContextVersion != 2) {
            EGL.setErrorCode(12293);
            return 0;
          }
          EGL.contextAttributes.majorVersion = glesContextVersion - 1;
          EGL.contextAttributes.minorVersion = 0;
          EGL.context = GL.createContext(Module["canvas"], EGL.contextAttributes);
          if (EGL.context != 0) {
            EGL.setErrorCode(12288);
            GL.makeContextCurrent(EGL.context);
            Module.useWebGL = true;
            Browser.moduleContextCreatedCallbacks.forEach(function(callback) {
              callback();
            });
            GL.makeContextCurrent(null);
            return 62004;
          } else {
            EGL.setErrorCode(12297);
            return 0;
          }
        }
        _eglCreateContext.sig = "ppppp";
        function _eglDestroyContext(display, context) {
          display >>>= 0;
          context >>>= 0;
          if (display != 62e3) {
            EGL.setErrorCode(12296);
            return 0;
          }
          if (context != 62004) {
            EGL.setErrorCode(12294);
            return 0;
          }
          GL.deleteContext(EGL.context);
          EGL.setErrorCode(12288);
          if (EGL.currentContext == context) {
            EGL.currentContext = 0;
          }
          return 1;
        }
        _eglDestroyContext.sig = "ipp";
        function _eglQuerySurface(display, surface, attribute, value) {
          display >>>= 0;
          surface >>>= 0;
          value >>>= 0;
          if (display != 62e3) {
            EGL.setErrorCode(12296);
            return 0;
          }
          if (surface != 62006) {
            EGL.setErrorCode(12301);
            return 0;
          }
          if (!value) {
            EGL.setErrorCode(12300);
            return 0;
          }
          EGL.setErrorCode(12288);
          switch (attribute) {
            case 12328:
              HEAP32[value >>> 2 >>> 0] = 62002;
              return 1;
            case 12376:
              return 1;
            case 12375:
              HEAP32[value >>> 2 >>> 0] = Module["canvas"].width;
              return 1;
            case 12374:
              HEAP32[value >>> 2 >>> 0] = Module["canvas"].height;
              return 1;
            case 12432:
              HEAP32[value >>> 2 >>> 0] = -1;
              return 1;
            case 12433:
              HEAP32[value >>> 2 >>> 0] = -1;
              return 1;
            case 12434:
              HEAP32[value >>> 2 >>> 0] = -1;
              return 1;
            case 12422:
              HEAP32[value >>> 2 >>> 0] = 12420;
              return 1;
            case 12441:
              HEAP32[value >>> 2 >>> 0] = 12442;
              return 1;
            case 12435:
              HEAP32[value >>> 2 >>> 0] = 12437;
              return 1;
            case 12416:
            case 12417:
            case 12418:
            case 12419:
              return 1;
            default:
              EGL.setErrorCode(12292);
              return 0;
          }
        }
        _eglQuerySurface.sig = "ippip";
        function _eglQueryContext(display, context, attribute, value) {
          display >>>= 0;
          context >>>= 0;
          value >>>= 0;
          if (display != 62e3) {
            EGL.setErrorCode(12296);
            return 0;
          }
          if (context != 62004) {
            EGL.setErrorCode(12294);
            return 0;
          }
          if (!value) {
            EGL.setErrorCode(12300);
            return 0;
          }
          EGL.setErrorCode(12288);
          switch (attribute) {
            case 12328:
              HEAP32[value >>> 2 >>> 0] = 62002;
              return 1;
            case 12439:
              HEAP32[value >>> 2 >>> 0] = 12448;
              return 1;
            case 12440:
              HEAP32[value >>> 2 >>> 0] = EGL.contextAttributes.majorVersion + 1;
              return 1;
            case 12422:
              HEAP32[value >>> 2 >>> 0] = 12420;
              return 1;
            default:
              EGL.setErrorCode(12292);
              return 0;
          }
        }
        _eglQueryContext.sig = "ippip";
        var _eglGetError = () => EGL.errorCode;
        _eglGetError.sig = "i";
        function _eglQueryString(display, name2) {
          display >>>= 0;
          if (display != 62e3) {
            EGL.setErrorCode(12296);
            return 0;
          }
          EGL.setErrorCode(12288);
          if (EGL.stringCache[name2])
            return EGL.stringCache[name2];
          var ret;
          switch (name2) {
            case 12371:
              ret = stringToNewUTF8("Emscripten");
              break;
            case 12372:
              ret = stringToNewUTF8("1.4 Emscripten EGL");
              break;
            case 12373:
              ret = stringToNewUTF8("");
              break;
            case 12429:
              ret = stringToNewUTF8("OpenGL_ES");
              break;
            default:
              EGL.setErrorCode(12300);
              return 0;
          }
          EGL.stringCache[name2] = ret;
          return ret;
        }
        _eglQueryString.sig = "ppi";
        var _eglBindAPI = (api) => {
          if (api == 12448) {
            EGL.setErrorCode(12288);
            return 1;
          }
          EGL.setErrorCode(12300);
          return 0;
        };
        _eglBindAPI.sig = "ii";
        var _eglQueryAPI = () => {
          EGL.setErrorCode(12288);
          return 12448;
        };
        _eglQueryAPI.sig = "i";
        var _eglWaitClient = () => {
          EGL.setErrorCode(12288);
          return 1;
        };
        _eglWaitClient.sig = "i";
        var _eglWaitNative = (nativeEngineId) => {
          EGL.setErrorCode(12288);
          return 1;
        };
        _eglWaitNative.sig = "ii";
        var _eglWaitGL = _eglWaitClient;
        _eglWaitGL.sig = "i";
        function _eglSwapInterval(display, interval) {
          display >>>= 0;
          if (display != 62e3) {
            EGL.setErrorCode(12296);
            return 0;
          }
          if (interval == 0)
            _emscripten_set_main_loop_timing(0, 0);
          else
            _emscripten_set_main_loop_timing(1, interval);
          EGL.setErrorCode(12288);
          return 1;
        }
        _eglSwapInterval.sig = "ipi";
        function _eglMakeCurrent(display, draw, read, context) {
          display >>>= 0;
          draw >>>= 0;
          read >>>= 0;
          context >>>= 0;
          if (display != 62e3) {
            EGL.setErrorCode(12296);
            return 0;
          }
          if (context != 0 && context != 62004) {
            EGL.setErrorCode(12294);
            return 0;
          }
          if (read != 0 && read != 62006 || draw != 0 && draw != 62006) {
            EGL.setErrorCode(12301);
            return 0;
          }
          GL.makeContextCurrent(context ? EGL.context : null);
          EGL.currentContext = context;
          EGL.currentDrawSurface = draw;
          EGL.currentReadSurface = read;
          EGL.setErrorCode(12288);
          return 1;
        }
        _eglMakeCurrent.sig = "ipppp";
        function _eglGetCurrentContext() {
          return EGL.currentContext;
        }
        _eglGetCurrentContext.sig = "p";
        function _eglGetCurrentSurface(readdraw) {
          if (readdraw == 12378) {
            return EGL.currentReadSurface;
          } else if (readdraw == 12377) {
            return EGL.currentDrawSurface;
          } else {
            EGL.setErrorCode(12300);
            return 0;
          }
        }
        _eglGetCurrentSurface.sig = "pi";
        function _eglGetCurrentDisplay() {
          return EGL.currentContext ? 62e3 : 0;
        }
        _eglGetCurrentDisplay.sig = "p";
        function _eglSwapBuffers(dpy, surface) {
          dpy >>>= 0;
          surface >>>= 0;
          if (!EGL.defaultDisplayInitialized) {
            EGL.setErrorCode(12289);
          } else if (!Module.ctx) {
            EGL.setErrorCode(12290);
          } else if (Module.ctx.isContextLost()) {
            EGL.setErrorCode(12302);
          } else {
            EGL.setErrorCode(12288);
            return 1;
          }
          return 0;
        }
        _eglSwapBuffers.sig = "ipp";
        var _eglReleaseThread = () => {
          EGL.currentContext = 0;
          EGL.currentReadSurface = 0;
          EGL.currentDrawSurface = 0;
          EGL.setErrorCode(12288);
          return 1;
        };
        _eglReleaseThread.sig = "i";
        function _uuid_clear(uu) {
          uu >>>= 0;
          return zeroMemory(uu, 16);
        }
        _uuid_clear.sig = "vp";
        function _uuid_compare(uu1, uu2) {
          uu1 >>>= 0;
          uu2 >>>= 0;
          return _memcmp(uu1, uu2, 16);
        }
        _uuid_compare.sig = "ipp";
        function _uuid_copy(dst, src) {
          dst >>>= 0;
          src >>>= 0;
          return _memcpy(dst, src, 16);
        }
        _uuid_copy.sig = "vpp";
        function _uuid_generate(out2) {
          out2 >>>= 0;
          var uuid = null;
          if (ENVIRONMENT_IS_NODE) {
            try {
              var rb = require("crypto")["randomBytes"];
              uuid = rb(16);
            } catch (e) {
            }
          } else if (ENVIRONMENT_IS_WEB && typeof window.crypto != "undefined" && typeof window.crypto.getRandomValues != "undefined") {
            uuid = new Uint8Array(16);
            window.crypto.getRandomValues(uuid);
          }
          if (!uuid) {
            uuid = new Array(16);
            var d = (/* @__PURE__ */ new Date()).getTime();
            for (var i2 = 0; i2 < 16; i2++) {
              var r = (d + Math.random() * 256) % 256 | 0;
              d = d / 256 | 0;
              uuid[i2] = r;
            }
          }
          uuid[6] = uuid[6] & 15 | 64;
          uuid[8] = uuid[8] & 63 | 128;
          writeArrayToMemory(uuid, out2);
        }
        _uuid_generate.sig = "vp";
        function _uuid_is_null(uu) {
          uu >>>= 0;
          for (var i2 = 0; i2 < 4; i2++, uu = uu + 4 | 0) {
            var val = HEAP32[uu >>> 2 >>> 0];
            if (val) {
              return 0;
            }
          }
          return 1;
        }
        _uuid_is_null.sig = "ip";
        function _uuid_parse(inp, uu) {
          inp >>>= 0;
          uu >>>= 0;
          inp = UTF8ToString(inp);
          if (inp.length === 36) {
            var i2 = 0;
            var uuid = new Array(16);
            inp.toLowerCase().replace(/[0-9a-f]{2}/g, function(byte) {
              if (i2 < 16) {
                uuid[i2++] = parseInt(byte, 16);
              }
            });
            if (i2 < 16) {
              return -1;
            }
            writeArrayToMemory(uuid, uu);
            return 0;
          }
          return -1;
        }
        _uuid_parse.sig = "ipp";
        function _uuid_unparse(uu, out2, upper) {
          uu >>>= 0;
          out2 >>>= 0;
          var i2 = 0;
          var uuid = "xxxx-xx-xx-xx-xxxxxx".replace(/[x]/g, function(c) {
            var r = upper ? HEAPU8[uu + i2 >>> 0 >>> 0].toString(16).toUpperCase() : HEAPU8[uu + i2 >>> 0 >>> 0].toString(16);
            r = r.length === 1 ? "0" + r : r;
            i2++;
            return r;
          });
          stringToUTF8(uuid, out2, 37);
        }
        _uuid_unparse.sig = "vpp";
        function _uuid_unparse_lower(uu, out2) {
          uu >>>= 0;
          out2 >>>= 0;
          _uuid_unparse(uu, out2);
        }
        _uuid_unparse_lower.sig = "vpp";
        function _uuid_unparse_upper(uu, out2) {
          uu >>>= 0;
          out2 >>>= 0;
          _uuid_unparse(uu, out2, true);
        }
        _uuid_unparse_upper.sig = "vpp";
        function _uuid_type(uu) {
          uu >>>= 0;
          return 4;
        }
        _uuid_type.sig = "ip";
        function _uuid_variant(uu) {
          uu >>>= 0;
          return 1;
        }
        _uuid_variant.sig = "ip";
        var GLEW = {
          isLinaroFork: 1,
          extensions: null,
          error: {
            0: null,
            1: null,
            2: null,
            3: null,
            4: null,
            5: null,
            6: null,
            7: null,
            8: null
          },
          version: {
            1: null,
            2: null,
            3: null,
            4: null
          },
          errorStringConstantFromCode(error) {
            if (GLEW.isLinaroFork) {
              switch (error) {
                case 4:
                  return "OpenGL ES lib expected, found OpenGL lib";
                case 5:
                  return "OpenGL lib expected, found OpenGL ES lib";
                case 6:
                  return "Missing EGL version";
                case 7:
                  return "EGL 1.1 and up are supported";
                default:
                  break;
              }
            }
            switch (error) {
              case 0:
                return "No error";
              case 1:
                return "Missing GL version";
              case 2:
                return "GL 1.1 and up are supported";
              case 3:
                return "GLX 1.2 and up are supported";
              default:
                return null;
            }
          },
          errorString(error) {
            if (!GLEW.error[error]) {
              var string = GLEW.errorStringConstantFromCode(error);
              if (!string) {
                string = "Unknown error";
                error = 8;
              }
              GLEW.error[error] = stringToNewUTF8(string);
            }
            return GLEW.error[error];
          },
          versionStringConstantFromCode(name2) {
            switch (name2) {
              case 1:
                return "1.10.0";
              case 2:
                return "1";
              case 3:
                return "10";
              case 4:
                return "0";
              default:
                return null;
            }
          },
          versionString(name2) {
            if (!GLEW.version[name2]) {
              var string = GLEW.versionStringConstantFromCode(name2);
              if (!string)
                return 0;
              GLEW.version[name2] = stringToNewUTF8(string);
            }
            return GLEW.version[name2];
          },
          extensionIsSupported(name2) {
            GLEW.extensions || (GLEW.extensions = webglGetExtensions());
            if (GLEW.extensions.includes(name2))
              return 1;
            return GLEW.extensions.includes("GL_" + name2);
          }
        };
        var _glewInit = () => 0;
        _glewInit.sig = "i";
        function _glewIsSupported(name2) {
          name2 >>>= 0;
          var exts = UTF8ToString(name2).split(" ");
          for (var i2 = 0; i2 < exts.length; ++i2) {
            if (!GLEW.extensionIsSupported(exts[i2]))
              return 0;
          }
          return 1;
        }
        _glewIsSupported.sig = "ip";
        function _glewGetExtension(name2) {
          name2 >>>= 0;
          return GLEW.extensionIsSupported(UTF8ToString(name2));
        }
        _glewGetExtension.sig = "ip";
        function _glewGetErrorString(error) {
          return GLEW.errorString(error);
        }
        _glewGetErrorString.sig = "pi";
        function _glewGetString(name2) {
          return GLEW.versionString(name2);
        }
        _glewGetString.sig = "pi";
        var IDBStore = {
          indexedDB() {
            if (typeof indexedDB != "undefined")
              return indexedDB;
            var ret = null;
            if (typeof window == "object")
              ret = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
            assert(ret, "IDBStore used, but indexedDB not supported");
            return ret;
          },
          DB_VERSION: 22,
          DB_STORE_NAME: "FILE_DATA",
          dbs: {},
          blobs: [0],
          getDB(name2, callback) {
            var db2 = IDBStore.dbs[name2];
            if (db2) {
              return callback(null, db2);
            }
            var req;
            try {
              req = IDBStore.indexedDB().open(name2, IDBStore.DB_VERSION);
            } catch (e) {
              return callback(e);
            }
            req.onupgradeneeded = (e) => {
              var db3 = e.target.result;
              var transaction = e.target.transaction;
              var fileStore;
              if (db3.objectStoreNames.contains(IDBStore.DB_STORE_NAME)) {
                fileStore = transaction.objectStore(IDBStore.DB_STORE_NAME);
              } else {
                fileStore = db3.createObjectStore(IDBStore.DB_STORE_NAME);
              }
            };
            req.onsuccess = () => {
              db2 = req.result;
              IDBStore.dbs[name2] = db2;
              callback(null, db2);
            };
            req.onerror = function(event2) {
              callback(event2.target.error || "unknown error");
              event2.preventDefault();
            };
          },
          getStore(dbName, type, callback) {
            IDBStore.getDB(dbName, (error, db2) => {
              if (error)
                return callback(error);
              var transaction = db2.transaction([IDBStore.DB_STORE_NAME], type);
              transaction.onerror = (event2) => {
                callback(event2.target.error || "unknown error");
                event2.preventDefault();
              };
              var store = transaction.objectStore(IDBStore.DB_STORE_NAME);
              callback(null, store);
            });
          },
          getFile(dbName, id, callback) {
            IDBStore.getStore(dbName, "readonly", (err2, store) => {
              if (err2)
                return callback(err2);
              var req = store.get(id);
              req.onsuccess = (event2) => {
                var result = event2.target.result;
                if (!result) {
                  return callback(`file ${id} not found`);
                }
                return callback(null, result);
              };
              req.onerror = callback;
            });
          },
          setFile(dbName, id, data2, callback) {
            IDBStore.getStore(dbName, "readwrite", (err2, store) => {
              if (err2)
                return callback(err2);
              var req = store.put(data2, id);
              req.onsuccess = (event2) => callback();
              req.onerror = callback;
            });
          },
          deleteFile(dbName, id, callback) {
            IDBStore.getStore(dbName, "readwrite", (err2, store) => {
              if (err2)
                return callback(err2);
              var req = store.delete(id);
              req.onsuccess = (event2) => callback();
              req.onerror = callback;
            });
          },
          existsFile(dbName, id, callback) {
            IDBStore.getStore(dbName, "readonly", (err2, store) => {
              if (err2)
                return callback(err2);
              var req = store.count(id);
              req.onsuccess = (event2) => callback(null, event2.target.result > 0);
              req.onerror = callback;
            });
          },
          clearStore(dbName, callback) {
            IDBStore.getStore(dbName, "readwrite", (err2, store) => {
              if (err2)
                return callback(err2);
              var req = store.clear();
              req.onsuccess = (event2) => callback();
              req.onerror = callback;
            });
          }
        };
        var _emscripten_idb_async_load = function(db2, id, arg, onload2, onerror2) {
          db2 >>>= 0;
          id >>>= 0;
          arg >>>= 0;
          onload2 >>>= 0;
          onerror2 >>>= 0;
          IDBStore.getFile(UTF8ToString(db2), UTF8ToString(id), (error, byteArray) => {
            callUserCallback(() => {
              if (error) {
                if (onerror2)
                  getWasmTableEntry(onerror2)(arg);
                return;
              }
              var buffer = _malloc(byteArray.length);
              HEAPU8.set(byteArray, buffer >>> 0);
              getWasmTableEntry(onload2)(arg, buffer, byteArray.length);
              _free(buffer);
            });
          });
        };
        _emscripten_idb_async_load.sig = "vppppp";
        var _emscripten_idb_async_store = function(db2, id, ptr2, num, arg, onstore, onerror2) {
          db2 >>>= 0;
          id >>>= 0;
          ptr2 >>>= 0;
          arg >>>= 0;
          onstore >>>= 0;
          onerror2 >>>= 0;
          IDBStore.setFile(UTF8ToString(db2), UTF8ToString(id), new Uint8Array(HEAPU8.subarray(ptr2 >>> 0, ptr2 + num >>> 0)), (error) => {
            callUserCallback(() => {
              if (error) {
                if (onerror2)
                  getWasmTableEntry(onerror2)(arg);
                return;
              }
              if (onstore)
                getWasmTableEntry(onstore)(arg);
            });
          });
        };
        _emscripten_idb_async_store.sig = "vpppippp";
        var _emscripten_idb_async_delete = function(db2, id, arg, ondelete, onerror2) {
          db2 >>>= 0;
          id >>>= 0;
          arg >>>= 0;
          ondelete >>>= 0;
          onerror2 >>>= 0;
          IDBStore.deleteFile(UTF8ToString(db2), UTF8ToString(id), (error) => {
            callUserCallback(() => {
              if (error) {
                if (onerror2)
                  getWasmTableEntry(onerror2)(arg);
                return;
              }
              if (ondelete)
                getWasmTableEntry(ondelete)(arg);
            });
          });
        };
        _emscripten_idb_async_delete.sig = "vppppp";
        var _emscripten_idb_async_exists = function(db2, id, arg, oncheck, onerror2) {
          db2 >>>= 0;
          id >>>= 0;
          arg >>>= 0;
          oncheck >>>= 0;
          onerror2 >>>= 0;
          IDBStore.existsFile(UTF8ToString(db2), UTF8ToString(id), (error, exists) => {
            callUserCallback(() => {
              if (error) {
                if (onerror2)
                  getWasmTableEntry(onerror2)(arg);
                return;
              }
              if (oncheck)
                getWasmTableEntry(oncheck)(arg, exists);
            });
          });
        };
        _emscripten_idb_async_exists.sig = "vppppp";
        var _emscripten_idb_async_clear = function(db2, arg, onclear, onerror2) {
          db2 >>>= 0;
          arg >>>= 0;
          onclear >>>= 0;
          onerror2 >>>= 0;
          IDBStore.clearStore(UTF8ToString(db2), (error) => {
            callUserCallback(() => {
              if (error) {
                if (onerror2)
                  getWasmTableEntry(onerror2)(arg);
                return;
              }
              if (onclear)
                getWasmTableEntry(onclear)(arg);
            });
          });
        };
        _emscripten_idb_async_clear.sig = "vpppp";
        function _emscripten_idb_load(db2, id, pbuffer, pnum, perror) {
          db2 >>>= 0;
          id >>>= 0;
          pbuffer >>>= 0;
          pnum >>>= 0;
          perror >>>= 0;
          throw "Please compile your program with async support in order to use synchronous operations like emscripten_idb_load, etc.";
        }
        _emscripten_idb_load.sig = "vppppp";
        function _emscripten_idb_store(db2, id, ptr2, num, perror) {
          db2 >>>= 0;
          id >>>= 0;
          ptr2 >>>= 0;
          perror >>>= 0;
          throw "Please compile your program with async support in order to use synchronous operations like emscripten_idb_store, etc.";
        }
        _emscripten_idb_store.sig = "vpppip";
        function _emscripten_idb_delete(db2, id, perror) {
          db2 >>>= 0;
          id >>>= 0;
          perror >>>= 0;
          throw "Please compile your program with async support in order to use synchronous operations like emscripten_idb_delete, etc.";
        }
        _emscripten_idb_delete.sig = "vppp";
        function _emscripten_idb_exists(db2, id, pexists, perror) {
          db2 >>>= 0;
          id >>>= 0;
          pexists >>>= 0;
          perror >>>= 0;
          throw "Please compile your program with async support in order to use synchronous operations like emscripten_idb_exists, etc.";
        }
        _emscripten_idb_exists.sig = "vpppp";
        function _emscripten_idb_clear(db2, perror) {
          db2 >>>= 0;
          perror >>>= 0;
          throw "Please compile your program with async support in order to use synchronous operations like emscripten_idb_clear, etc.";
        }
        _emscripten_idb_clear.sig = "vpp";
        var runAndAbortIfError = (func2) => {
          try {
            return func2();
          } catch (e) {
            abort(e);
          }
        };
        var _emscripten_sleep = () => {
          throw "Please compile your program with async support in order to use asynchronous operations like emscripten_sleep";
        };
        _emscripten_sleep.sig = "vi";
        function _emscripten_scan_registers(func2) {
          func2 >>>= 0;
          throw "Please compile your program with async support in order to use asynchronous operations like emscripten_scan_registers";
        }
        _emscripten_scan_registers.sig = "vp";
        function _emscripten_fiber_swap(oldFiber, newFiber) {
          oldFiber >>>= 0;
          newFiber >>>= 0;
          throw "Please compile your program with async support in order to use asynchronous operations like emscripten_fiber_swap";
        }
        _emscripten_fiber_swap.sig = "vpp";
        var _SDL_GetTicks = () => Date.now() - SDL.startTime | 0;
        _SDL_GetTicks.sig = "i";
        function _SDL_LockSurface(surf) {
          surf >>>= 0;
          var surfData = SDL.surfaces[surf];
          surfData.locked++;
          if (surfData.locked > 1)
            return 0;
          if (!surfData.buffer) {
            surfData.buffer = _malloc(surfData.width * surfData.height * 4);
            HEAPU32[surf + 20 >>> 2 >>> 0] = surfData.buffer;
          }
          HEAPU32[surf + 20 >>> 2 >>> 0] = surfData.buffer;
          if (surf == SDL.screen && Module.screenIsReadOnly && surfData.image)
            return 0;
          if (SDL.defaults.discardOnLock) {
            if (!surfData.image) {
              surfData.image = surfData.ctx.createImageData(surfData.width, surfData.height);
            }
            if (!SDL.defaults.opaqueFrontBuffer)
              return;
          } else {
            surfData.image = surfData.ctx.getImageData(0, 0, surfData.width, surfData.height);
          }
          if (surf == SDL.screen && SDL.defaults.opaqueFrontBuffer) {
            var data2 = surfData.image.data;
            var num = data2.length;
            for (var i2 = 0; i2 < num / 4; i2++) {
              data2[i2 * 4 + 3] = 255;
            }
          }
          if (SDL.defaults.copyOnLock && !SDL.defaults.discardOnLock) {
            if (surfData.isFlagSet(2097152)) {
              throw "CopyOnLock is not supported for SDL_LockSurface with SDL_HWPALETTE flag set" + new Error().stack;
            } else {
              HEAPU8.set(surfData.image.data, surfData.buffer >>> 0);
            }
          }
          return 0;
        }
        _SDL_LockSurface.sig = "ip";
        var SDL_ttfContext = () => SDL.ttfContext;
        var SDL_audio = () => SDL.audio;
        var SDL = {
          defaults: {
            width: 320,
            height: 200,
            copyOnLock: true,
            discardOnLock: false,
            opaqueFrontBuffer: true
          },
          version: null,
          surfaces: {},
          canvasPool: [],
          events: [],
          fonts: [null],
          audios: [null],
          rwops: [null],
          music: {
            audio: null,
            volume: 1
          },
          mixerFrequency: 22050,
          mixerFormat: 32784,
          mixerNumChannels: 2,
          mixerChunkSize: 1024,
          channelMinimumNumber: 0,
          GL: false,
          glAttributes: {
            0: 3,
            1: 3,
            2: 2,
            3: 0,
            4: 0,
            5: 1,
            6: 16,
            7: 0,
            8: 0,
            9: 0,
            10: 0,
            11: 0,
            12: 0,
            13: 0,
            14: 0,
            15: 1,
            16: 0,
            17: 0,
            18: 0
          },
          keyboardState: null,
          keyboardMap: {},
          canRequestFullscreen: false,
          isRequestingFullscreen: false,
          textInput: false,
          startTime: null,
          initFlags: 0,
          buttonState: 0,
          modState: 0,
          DOMButtons: [0, 0, 0],
          DOMEventToSDLEvent: {},
          TOUCH_DEFAULT_ID: 0,
          eventHandler: null,
          eventHandlerContext: null,
          eventHandlerTemp: 0,
          keyCodes: {
            16: 1249,
            17: 1248,
            18: 1250,
            20: 1081,
            33: 1099,
            34: 1102,
            35: 1101,
            36: 1098,
            37: 1104,
            38: 1106,
            39: 1103,
            40: 1105,
            44: 316,
            45: 1097,
            46: 127,
            91: 1251,
            93: 1125,
            96: 1122,
            97: 1113,
            98: 1114,
            99: 1115,
            100: 1116,
            101: 1117,
            102: 1118,
            103: 1119,
            104: 1120,
            105: 1121,
            106: 1109,
            107: 1111,
            109: 1110,
            110: 1123,
            111: 1108,
            112: 1082,
            113: 1083,
            114: 1084,
            115: 1085,
            116: 1086,
            117: 1087,
            118: 1088,
            119: 1089,
            120: 1090,
            121: 1091,
            122: 1092,
            123: 1093,
            124: 1128,
            125: 1129,
            126: 1130,
            127: 1131,
            128: 1132,
            129: 1133,
            130: 1134,
            131: 1135,
            132: 1136,
            133: 1137,
            134: 1138,
            135: 1139,
            144: 1107,
            160: 94,
            161: 33,
            162: 34,
            163: 35,
            164: 36,
            165: 37,
            166: 38,
            167: 95,
            168: 40,
            169: 41,
            170: 42,
            171: 43,
            172: 124,
            173: 45,
            174: 123,
            175: 125,
            176: 126,
            181: 127,
            182: 129,
            183: 128,
            188: 44,
            190: 46,
            191: 47,
            192: 96,
            219: 91,
            220: 92,
            221: 93,
            222: 39,
            224: 1251
          },
          scanCodes: {
            8: 42,
            9: 43,
            13: 40,
            27: 41,
            32: 44,
            35: 204,
            39: 53,
            44: 54,
            46: 55,
            47: 56,
            48: 39,
            49: 30,
            50: 31,
            51: 32,
            52: 33,
            53: 34,
            54: 35,
            55: 36,
            56: 37,
            57: 38,
            58: 203,
            59: 51,
            61: 46,
            91: 47,
            92: 49,
            93: 48,
            96: 52,
            97: 4,
            98: 5,
            99: 6,
            100: 7,
            101: 8,
            102: 9,
            103: 10,
            104: 11,
            105: 12,
            106: 13,
            107: 14,
            108: 15,
            109: 16,
            110: 17,
            111: 18,
            112: 19,
            113: 20,
            114: 21,
            115: 22,
            116: 23,
            117: 24,
            118: 25,
            119: 26,
            120: 27,
            121: 28,
            122: 29,
            127: 76,
            305: 224,
            308: 226,
            316: 70
          },
          loadRect: (rect) => ({
            x: HEAP32[rect + 0 >>> 2 >>> 0],
            y: HEAP32[rect + 4 >>> 2 >>> 0],
            w: HEAP32[rect + 8 >>> 2 >>> 0],
            h: HEAP32[rect + 12 >>> 2 >>> 0]
          }),
          updateRect: (rect, r) => {
            HEAP32[rect >>> 2 >>> 0] = r.x;
            HEAP32[rect + 4 >>> 2 >>> 0] = r.y;
            HEAP32[rect + 8 >>> 2 >>> 0] = r.w;
            HEAP32[rect + 12 >>> 2 >>> 0] = r.h;
          },
          intersectionOfRects: (first, second) => {
            var leftX = Math.max(first.x, second.x);
            var leftY = Math.max(first.y, second.y);
            var rightX = Math.min(first.x + first.w, second.x + second.w);
            var rightY = Math.min(first.y + first.h, second.y + second.h);
            return {
              x: leftX,
              y: leftY,
              w: Math.max(leftX, rightX) - leftX,
              h: Math.max(leftY, rightY) - leftY
            };
          },
          checkPixelFormat: (fmt) => {
          },
          loadColorToCSSRGB: (color) => {
            var rgba = HEAP32[color >>> 2 >>> 0];
            return "rgb(" + (rgba & 255) + "," + (rgba >> 8 & 255) + "," + (rgba >> 16 & 255) + ")";
          },
          loadColorToCSSRGBA: (color) => {
            var rgba = HEAP32[color >>> 2 >>> 0];
            return "rgba(" + (rgba & 255) + "," + (rgba >> 8 & 255) + "," + (rgba >> 16 & 255) + "," + (rgba >> 24 & 255) / 255 + ")";
          },
          translateColorToCSSRGBA: (rgba) => "rgba(" + (rgba & 255) + "," + (rgba >> 8 & 255) + "," + (rgba >> 16 & 255) + "," + (rgba >>> 24) / 255 + ")",
          translateRGBAToCSSRGBA: (r, g, b, a) => "rgba(" + (r & 255) + "," + (g & 255) + "," + (b & 255) + "," + (a & 255) / 255 + ")",
          translateRGBAToColor: (r, g, b, a) => r | g << 8 | b << 16 | a << 24,
          makeSurface: (width, height, flags2, usePageCanvas, source, rmask, gmask, bmask, amask) => {
            var is_SDL_HWSURFACE = flags2 & 1;
            var is_SDL_HWPALETTE = flags2 & 2097152;
            var is_SDL_OPENGL = flags2 & 67108864;
            var surf = _malloc(60);
            var pixelFormat = _malloc(44);
            var bpp = is_SDL_HWPALETTE ? 1 : 4;
            var buffer = 0;
            if (!is_SDL_HWSURFACE && !is_SDL_OPENGL) {
              buffer = _malloc(width * height * 4);
            }
            HEAP32[surf >>> 2 >>> 0] = flags2;
            HEAPU32[surf + 4 >>> 2 >>> 0] = pixelFormat;
            HEAP32[surf + 8 >>> 2 >>> 0] = width;
            HEAP32[surf + 12 >>> 2 >>> 0] = height;
            HEAP32[surf + 16 >>> 2 >>> 0] = width * bpp;
            HEAPU32[surf + 20 >>> 2 >>> 0] = buffer;
            HEAP32[surf + 36 >>> 2 >>> 0] = 0;
            HEAP32[surf + 40 >>> 2 >>> 0] = 0;
            HEAP32[surf + 44 >>> 2 >>> 0] = Module["canvas"].width;
            HEAP32[surf + 48 >>> 2 >>> 0] = Module["canvas"].height;
            HEAP32[surf + 56 >>> 2 >>> 0] = 1;
            HEAP32[pixelFormat >>> 2 >>> 0] = -2042224636;
            HEAP32[pixelFormat + 4 >>> 2 >>> 0] = 0;
            HEAP8[pixelFormat + 8 >>> 0 >>> 0] = bpp * 8;
            HEAP8[pixelFormat + 9 >>> 0 >>> 0] = bpp;
            HEAP32[pixelFormat + 12 >>> 2 >>> 0] = rmask || 255;
            HEAP32[pixelFormat + 16 >>> 2 >>> 0] = gmask || 65280;
            HEAP32[pixelFormat + 20 >>> 2 >>> 0] = bmask || 16711680;
            HEAP32[pixelFormat + 24 >>> 2 >>> 0] = amask || 4278190080;
            SDL.GL = SDL.GL || is_SDL_OPENGL;
            var canvas;
            if (!usePageCanvas) {
              if (SDL.canvasPool.length > 0) {
                canvas = SDL.canvasPool.pop();
              } else {
                canvas = document.createElement("canvas");
              }
              canvas.width = width;
              canvas.height = height;
            } else {
              canvas = Module["canvas"];
            }
            var webGLContextAttributes = {
              antialias: SDL.glAttributes[13] != 0 && SDL.glAttributes[14] > 1,
              depth: SDL.glAttributes[6] > 0,
              stencil: SDL.glAttributes[7] > 0,
              alpha: SDL.glAttributes[3] > 0
            };
            var ctx = Browser.createContext(canvas, is_SDL_OPENGL, usePageCanvas, webGLContextAttributes);
            SDL.surfaces[surf] = {
              width,
              height,
              canvas,
              ctx,
              surf,
              buffer,
              pixelFormat,
              alpha: 255,
              flags: flags2,
              locked: 0,
              usePageCanvas,
              source,
              isFlagSet: (flag) => flags2 & flag
            };
            return surf;
          },
          copyIndexedColorData: (surfData, rX, rY, rW, rH) => {
            if (!surfData.colors) {
              return;
            }
            var fullWidth = Module["canvas"].width;
            var fullHeight = Module["canvas"].height;
            var startX = rX || 0;
            var startY = rY || 0;
            var endX = (rW || fullWidth - startX) + startX;
            var endY = (rH || fullHeight - startY) + startY;
            var buffer = surfData.buffer;
            if (!surfData.image.data32) {
              surfData.image.data32 = new Uint32Array(surfData.image.data.buffer);
            }
            var data32 = surfData.image.data32;
            var colors32 = surfData.colors32;
            for (var y = startY; y < endY; ++y) {
              var base = y * fullWidth;
              for (var x = startX; x < endX; ++x) {
                data32[base + x] = colors32[HEAPU8[buffer + base + x >>> 0 >>> 0]];
              }
            }
          },
          freeSurface: (surf) => {
            var refcountPointer = surf + 56;
            var refcount = HEAP32[refcountPointer >>> 2 >>> 0];
            if (refcount > 1) {
              HEAP32[refcountPointer >>> 2 >>> 0] = refcount - 1;
              return;
            }
            var info2 = SDL.surfaces[surf];
            if (!info2.usePageCanvas && info2.canvas)
              SDL.canvasPool.push(info2.canvas);
            if (info2.buffer)
              _free(info2.buffer);
            _free(info2.pixelFormat);
            _free(surf);
            SDL.surfaces[surf] = null;
            if (surf === SDL.screen) {
              SDL.screen = null;
            }
          },
          blitSurface: (src, srcrect, dst, dstrect, scale) => {
            var srcData = SDL.surfaces[src];
            var dstData = SDL.surfaces[dst];
            var sr, dr;
            if (srcrect) {
              sr = SDL.loadRect(srcrect);
            } else {
              sr = {
                x: 0,
                y: 0,
                w: srcData.width,
                h: srcData.height
              };
            }
            if (dstrect) {
              dr = SDL.loadRect(dstrect);
            } else {
              dr = {
                x: 0,
                y: 0,
                w: srcData.width,
                h: srcData.height
              };
            }
            if (dstData.clipRect) {
              var widthScale = !scale || sr.w === 0 ? 1 : sr.w / dr.w;
              var heightScale = !scale || sr.h === 0 ? 1 : sr.h / dr.h;
              dr = SDL.intersectionOfRects(dstData.clipRect, dr);
              sr.w = dr.w * widthScale;
              sr.h = dr.h * heightScale;
              if (dstrect) {
                SDL.updateRect(dstrect, dr);
              }
            }
            var blitw, blith;
            if (scale) {
              blitw = dr.w;
              blith = dr.h;
            } else {
              blitw = sr.w;
              blith = sr.h;
            }
            if (sr.w === 0 || sr.h === 0 || blitw === 0 || blith === 0) {
              return 0;
            }
            var oldAlpha = dstData.ctx.globalAlpha;
            dstData.ctx.globalAlpha = srcData.alpha / 255;
            dstData.ctx.drawImage(srcData.canvas, sr.x, sr.y, sr.w, sr.h, dr.x, dr.y, blitw, blith);
            dstData.ctx.globalAlpha = oldAlpha;
            if (dst != SDL.screen) {
              warnOnce("WARNING: copying canvas data to memory for compatibility");
              _SDL_LockSurface(dst);
              dstData.locked--;
            }
            return 0;
          },
          downFingers: {},
          savedKeydown: null,
          receiveEvent: (event2) => {
            function unpressAllPressedKeys() {
              for (var code in SDL.keyboardMap) {
                SDL.events.push({
                  type: "keyup",
                  keyCode: SDL.keyboardMap[code]
                });
              }
            }
            switch (event2.type) {
              case "touchstart":
              case "touchmove": {
                event2.preventDefault();
                var touches = [];
                if (event2.type === "touchstart") {
                  for (var i2 = 0; i2 < event2.touches.length; i2++) {
                    var touch = event2.touches[i2];
                    if (SDL.downFingers[touch.identifier] != true) {
                      SDL.downFingers[touch.identifier] = true;
                      touches.push(touch);
                    }
                  }
                } else {
                  touches = event2.touches;
                }
                var firstTouch = touches[0];
                if (firstTouch) {
                  if (event2.type == "touchstart") {
                    SDL.DOMButtons[0] = 1;
                  }
                  var mouseEventType;
                  switch (event2.type) {
                    case "touchstart":
                      mouseEventType = "mousedown";
                      break;
                    case "touchmove":
                      mouseEventType = "mousemove";
                      break;
                  }
                  var mouseEvent = {
                    type: mouseEventType,
                    button: 0,
                    pageX: firstTouch.clientX,
                    pageY: firstTouch.clientY
                  };
                  SDL.events.push(mouseEvent);
                }
                for (var i2 = 0; i2 < touches.length; i2++) {
                  var touch = touches[i2];
                  SDL.events.push({
                    type: event2.type,
                    touch
                  });
                }
                break;
              }
              case "touchend": {
                event2.preventDefault();
                for (var i2 = 0; i2 < event2.changedTouches.length; i2++) {
                  var touch = event2.changedTouches[i2];
                  if (SDL.downFingers[touch.identifier] === true) {
                    delete SDL.downFingers[touch.identifier];
                  }
                }
                var mouseEvent = {
                  type: "mouseup",
                  button: 0,
                  pageX: event2.changedTouches[0].clientX,
                  pageY: event2.changedTouches[0].clientY
                };
                SDL.DOMButtons[0] = 0;
                SDL.events.push(mouseEvent);
                for (var i2 = 0; i2 < event2.changedTouches.length; i2++) {
                  var touch = event2.changedTouches[i2];
                  SDL.events.push({
                    type: "touchend",
                    touch
                  });
                }
                break;
              }
              case "DOMMouseScroll":
              case "mousewheel":
              case "wheel":
                var delta = -Browser.getMouseWheelDelta(event2);
                delta = delta == 0 ? 0 : delta > 0 ? Math.max(delta, 1) : Math.min(delta, -1);
                var button = delta > 0 ? 3 : 4;
                SDL.events.push({
                  type: "mousedown",
                  button,
                  pageX: event2.pageX,
                  pageY: event2.pageY
                });
                SDL.events.push({
                  type: "mouseup",
                  button,
                  pageX: event2.pageX,
                  pageY: event2.pageY
                });
                SDL.events.push({
                  type: "wheel",
                  deltaX: 0,
                  deltaY: delta
                });
                event2.preventDefault();
                break;
              case "mousemove":
                if (SDL.DOMButtons[0] === 1) {
                  SDL.events.push({
                    type: "touchmove",
                    touch: {
                      identifier: 0,
                      deviceID: -1,
                      pageX: event2.pageX,
                      pageY: event2.pageY
                    }
                  });
                }
                if (Browser.pointerLock) {
                  if ("mozMovementX" in event2) {
                    event2["movementX"] = event2["mozMovementX"];
                    event2["movementY"] = event2["mozMovementY"];
                  }
                  if (event2["movementX"] == 0 && event2["movementY"] == 0) {
                    event2.preventDefault();
                    return;
                  }
                }
              case "keydown":
              case "keyup":
              case "keypress":
              case "mousedown":
              case "mouseup":
                if (event2.type !== "keydown" || !SDL_unicode() && !SDL.textInput || (event2.keyCode === 8 || event2.keyCode === 9)) {
                  event2.preventDefault();
                }
                if (event2.type == "mousedown") {
                  SDL.DOMButtons[event2.button] = 1;
                  SDL.events.push({
                    type: "touchstart",
                    touch: {
                      identifier: 0,
                      deviceID: -1,
                      pageX: event2.pageX,
                      pageY: event2.pageY
                    }
                  });
                } else if (event2.type == "mouseup") {
                  if (!SDL.DOMButtons[event2.button]) {
                    return;
                  }
                  SDL.events.push({
                    type: "touchend",
                    touch: {
                      identifier: 0,
                      deviceID: -1,
                      pageX: event2.pageX,
                      pageY: event2.pageY
                    }
                  });
                  SDL.DOMButtons[event2.button] = 0;
                }
                if (event2.type === "keydown" || event2.type === "mousedown") {
                  SDL.canRequestFullscreen = true;
                } else if (event2.type === "keyup" || event2.type === "mouseup") {
                  if (SDL.isRequestingFullscreen) {
                    Module["requestFullscreen"](true, true);
                    SDL.isRequestingFullscreen = false;
                  }
                  SDL.canRequestFullscreen = false;
                }
                if (event2.type === "keypress" && SDL.savedKeydown) {
                  SDL.savedKeydown.keypressCharCode = event2.charCode;
                  SDL.savedKeydown = null;
                } else if (event2.type === "keydown") {
                  SDL.savedKeydown = event2;
                }
                if (event2.type !== "keypress" || SDL.textInput) {
                  SDL.events.push(event2);
                }
                break;
              case "mouseout":
                for (var i2 = 0; i2 < 3; i2++) {
                  if (SDL.DOMButtons[i2]) {
                    SDL.events.push({
                      type: "mouseup",
                      button: i2,
                      pageX: event2.pageX,
                      pageY: event2.pageY
                    });
                    SDL.DOMButtons[i2] = 0;
                  }
                }
                event2.preventDefault();
                break;
              case "focus":
                SDL.events.push(event2);
                event2.preventDefault();
                break;
              case "blur":
                SDL.events.push(event2);
                unpressAllPressedKeys();
                event2.preventDefault();
                break;
              case "visibilitychange":
                SDL.events.push({
                  type: "visibilitychange",
                  visible: !document.hidden
                });
                unpressAllPressedKeys();
                event2.preventDefault();
                break;
              case "unload":
                if (Browser.mainLoop.runner) {
                  SDL.events.push(event2);
                  Browser.mainLoop.runner();
                }
                return;
              case "resize":
                SDL.events.push(event2);
                if (event2.preventDefault) {
                  event2.preventDefault();
                }
                break;
            }
            if (SDL.events.length >= 1e4) {
              err("SDL event queue full, dropping events");
              SDL.events = SDL.events.slice(0, 1e4);
            }
            SDL.flushEventsToHandler();
            return;
          },
          lookupKeyCodeForEvent: (event2) => {
            var code = event2.keyCode;
            if (code >= 65 && code <= 90) {
              code += 32;
            } else {
              code = SDL.keyCodes[event2.keyCode] || event2.keyCode;
              if (event2.location === 2 && code >= (224 | 1 << 10) && code <= (227 | 1 << 10)) {
                code += 4;
              }
            }
            return code;
          },
          handleEvent: (event2) => {
            if (event2.handled)
              return;
            event2.handled = true;
            switch (event2.type) {
              case "touchstart":
              case "touchend":
              case "touchmove": {
                Browser.calculateMouseEvent(event2);
                break;
              }
              case "keydown":
              case "keyup": {
                var down = event2.type === "keydown";
                var code = SDL.lookupKeyCodeForEvent(event2);
                HEAP8[SDL.keyboardState + code >>> 0 >>> 0] = down;
                SDL.modState = (HEAP8[SDL.keyboardState + 1248 >>> 0 >>> 0] ? 64 : 0) | (HEAP8[SDL.keyboardState + 1249 >>> 0 >>> 0] ? 1 : 0) | (HEAP8[SDL.keyboardState + 1250 >>> 0 >>> 0] ? 256 : 0) | (HEAP8[SDL.keyboardState + 1252 >>> 0 >>> 0] ? 128 : 0) | (HEAP8[SDL.keyboardState + 1253 >>> 0 >>> 0] ? 2 : 0) | (HEAP8[SDL.keyboardState + 1254 >>> 0 >>> 0] ? 512 : 0);
                if (down) {
                  SDL.keyboardMap[code] = event2.keyCode;
                } else {
                  delete SDL.keyboardMap[code];
                }
                break;
              }
              case "mousedown":
              case "mouseup":
                if (event2.type == "mousedown") {
                  SDL.buttonState |= 1 << event2.button;
                } else if (event2.type == "mouseup") {
                  SDL.buttonState &= ~(1 << event2.button);
                }
              case "mousemove": {
                Browser.calculateMouseEvent(event2);
                break;
              }
            }
          },
          flushEventsToHandler: () => {
            if (!SDL.eventHandler)
              return;
            while (SDL.pollEvent(SDL.eventHandlerTemp)) {
              getWasmTableEntry(SDL.eventHandler)(SDL.eventHandlerContext, SDL.eventHandlerTemp);
            }
          },
          pollEvent: (ptr2) => {
            if (SDL.initFlags & 512 && SDL.joystickEventState) {
              SDL.queryJoysticks();
            }
            if (ptr2) {
              while (SDL.events.length > 0) {
                if (SDL.makeCEvent(SDL.events.shift(), ptr2) !== false)
                  return 1;
              }
              return 0;
            }
            return SDL.events.length > 0;
          },
          makeCEvent: (event2, ptr2) => {
            if (typeof event2 == "number") {
              _memcpy(ptr2, event2, 28);
              _free(event2);
              return;
            }
            SDL.handleEvent(event2);
            switch (event2.type) {
              case "keydown":
              case "keyup": {
                var down = event2.type === "keydown";
                var key = SDL.lookupKeyCodeForEvent(event2);
                var scan;
                if (key >= 1024) {
                  scan = key - 1024;
                } else {
                  scan = SDL.scanCodes[key] || key;
                }
                HEAP32[ptr2 >>> 2 >>> 0] = SDL.DOMEventToSDLEvent[event2.type];
                HEAP8[ptr2 + 8 >>> 0 >>> 0] = down ? 1 : 0;
                HEAP8[ptr2 + 9 >>> 0 >>> 0] = 0;
                HEAP32[ptr2 + 12 >>> 2 >>> 0] = scan;
                HEAP32[ptr2 + 16 >>> 2 >>> 0] = key;
                HEAP16[ptr2 + 20 >>> 1 >>> 0] = SDL.modState;
                HEAP32[ptr2 + 24 >>> 2 >>> 0] = event2.keypressCharCode || key;
                break;
              }
              case "keypress": {
                HEAP32[ptr2 >>> 2 >>> 0] = SDL.DOMEventToSDLEvent[event2.type];
                var cStr = intArrayFromString(String.fromCharCode(event2.charCode));
                for (var i2 = 0; i2 < cStr.length; ++i2) {
                  HEAP8[ptr2 + (8 + i2) >>> 0 >>> 0] = cStr[i2];
                }
                break;
              }
              case "mousedown":
              case "mouseup":
              case "mousemove": {
                if (event2.type != "mousemove") {
                  var down = event2.type === "mousedown";
                  HEAP32[ptr2 >>> 2 >>> 0] = SDL.DOMEventToSDLEvent[event2.type];
                  HEAP32[ptr2 + 4 >>> 2 >>> 0] = 0;
                  HEAP32[ptr2 + 8 >>> 2 >>> 0] = 0;
                  HEAP32[ptr2 + 12 >>> 2 >>> 0] = 0;
                  HEAP8[ptr2 + 16 >>> 0 >>> 0] = event2.button + 1;
                  HEAP8[ptr2 + 17 >>> 0 >>> 0] = down ? 1 : 0;
                  HEAP32[ptr2 + 20 >>> 2 >>> 0] = Browser.mouseX;
                  HEAP32[ptr2 + 24 >>> 2 >>> 0] = Browser.mouseY;
                } else {
                  HEAP32[ptr2 >>> 2 >>> 0] = SDL.DOMEventToSDLEvent[event2.type];
                  HEAP32[ptr2 + 4 >>> 2 >>> 0] = 0;
                  HEAP32[ptr2 + 8 >>> 2 >>> 0] = 0;
                  HEAP32[ptr2 + 12 >>> 2 >>> 0] = 0;
                  HEAP32[ptr2 + 16 >>> 2 >>> 0] = SDL.buttonState;
                  HEAP32[ptr2 + 20 >>> 2 >>> 0] = Browser.mouseX;
                  HEAP32[ptr2 + 24 >>> 2 >>> 0] = Browser.mouseY;
                  HEAP32[ptr2 + 28 >>> 2 >>> 0] = Browser.mouseMovementX;
                  HEAP32[ptr2 + 32 >>> 2 >>> 0] = Browser.mouseMovementY;
                }
                break;
              }
              case "wheel": {
                HEAP32[ptr2 >>> 2 >>> 0] = SDL.DOMEventToSDLEvent[event2.type];
                HEAP32[ptr2 + 16 >>> 2 >>> 0] = event2.deltaX;
                HEAP32[ptr2 + 20 >>> 2 >>> 0] = event2.deltaY;
                break;
              }
              case "touchstart":
              case "touchend":
              case "touchmove": {
                var touch = event2.touch;
                if (!Browser.touches[touch.identifier])
                  break;
                var w = Module["canvas"].width;
                var h = Module["canvas"].height;
                var x = Browser.touches[touch.identifier].x / w;
                var y = Browser.touches[touch.identifier].y / h;
                var lx = Browser.lastTouches[touch.identifier].x / w;
                var ly = Browser.lastTouches[touch.identifier].y / h;
                var dx = x - lx;
                var dy = y - ly;
                if (touch["deviceID"] === void 0)
                  touch.deviceID = SDL.TOUCH_DEFAULT_ID;
                if (dx === 0 && dy === 0 && event2.type === "touchmove")
                  return false;
                HEAP32[ptr2 >>> 2 >>> 0] = SDL.DOMEventToSDLEvent[event2.type];
                HEAP32[ptr2 + 4 >>> 2 >>> 0] = _SDL_GetTicks();
                tempI64 = [touch.deviceID >>> 0, (tempDouble = touch.deviceID, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[ptr2 + 8 >>> 2 >>> 0] = tempI64[0], HEAP32[ptr2 + 12 >>> 2 >>> 0] = tempI64[1];
                tempI64 = [touch.identifier >>> 0, (tempDouble = touch.identifier, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[ptr2 + 16 >>> 2 >>> 0] = tempI64[0], HEAP32[ptr2 + 20 >>> 2 >>> 0] = tempI64[1];
                HEAPF32[ptr2 + 24 >>> 2 >>> 0] = x;
                HEAPF32[ptr2 + 28 >>> 2 >>> 0] = y;
                HEAPF32[ptr2 + 32 >>> 2 >>> 0] = dx;
                HEAPF32[ptr2 + 36 >>> 2 >>> 0] = dy;
                if (touch.force !== void 0) {
                  HEAPF32[ptr2 + 40 >>> 2 >>> 0] = touch.force;
                } else {
                  HEAPF32[ptr2 + 40 >>> 2 >>> 0] = event2.type == "touchend" ? 0 : 1;
                }
                break;
              }
              case "unload": {
                HEAP32[ptr2 >>> 2 >>> 0] = SDL.DOMEventToSDLEvent[event2.type];
                break;
              }
              case "resize": {
                HEAP32[ptr2 >>> 2 >>> 0] = SDL.DOMEventToSDLEvent[event2.type];
                HEAP32[ptr2 + 4 >>> 2 >>> 0] = event2.w;
                HEAP32[ptr2 + 8 >>> 2 >>> 0] = event2.h;
                break;
              }
              case "joystick_button_up":
              case "joystick_button_down": {
                var state = event2.type === "joystick_button_up" ? 0 : 1;
                HEAP32[ptr2 >>> 2 >>> 0] = SDL.DOMEventToSDLEvent[event2.type];
                HEAP8[ptr2 + 4 >>> 0 >>> 0] = event2.index;
                HEAP8[ptr2 + 5 >>> 0 >>> 0] = event2.button;
                HEAP8[ptr2 + 6 >>> 0 >>> 0] = state;
                break;
              }
              case "joystick_axis_motion": {
                HEAP32[ptr2 >>> 2 >>> 0] = SDL.DOMEventToSDLEvent[event2.type];
                HEAP8[ptr2 + 4 >>> 0 >>> 0] = event2.index;
                HEAP8[ptr2 + 5 >>> 0 >>> 0] = event2.axis;
                HEAP32[ptr2 + 8 >>> 2 >>> 0] = SDL.joystickAxisValueConversion(event2.value);
                break;
              }
              case "focus": {
                var SDL_WINDOWEVENT_FOCUS_GAINED = 12;
                HEAP32[ptr2 >>> 2 >>> 0] = SDL.DOMEventToSDLEvent[event2.type];
                HEAP32[ptr2 + 4 >>> 2 >>> 0] = 0;
                HEAP8[ptr2 + 8 >>> 0 >>> 0] = SDL_WINDOWEVENT_FOCUS_GAINED;
                break;
              }
              case "blur": {
                var SDL_WINDOWEVENT_FOCUS_LOST = 13;
                HEAP32[ptr2 >>> 2 >>> 0] = SDL.DOMEventToSDLEvent[event2.type];
                HEAP32[ptr2 + 4 >>> 2 >>> 0] = 0;
                HEAP8[ptr2 + 8 >>> 0 >>> 0] = SDL_WINDOWEVENT_FOCUS_LOST;
                break;
              }
              case "visibilitychange": {
                var SDL_WINDOWEVENT_SHOWN = 1;
                var SDL_WINDOWEVENT_HIDDEN = 2;
                var visibilityEventID = event2.visible ? SDL_WINDOWEVENT_SHOWN : SDL_WINDOWEVENT_HIDDEN;
                HEAP32[ptr2 >>> 2 >>> 0] = SDL.DOMEventToSDLEvent[event2.type];
                HEAP32[ptr2 + 4 >>> 2 >>> 0] = 0;
                HEAP8[ptr2 + 8 >>> 0 >>> 0] = visibilityEventID;
                break;
              }
              default:
                throw "Unhandled SDL event: " + event2.type;
            }
          },
          makeFontString: (height, fontName) => {
            if (fontName.charAt(0) != "'" && fontName.charAt(0) != '"') {
              fontName = '"' + fontName + '"';
            }
            return height + "px " + fontName + ", serif";
          },
          estimateTextWidth: (fontData, text) => {
            var h = fontData.size;
            var fontString = SDL.makeFontString(h, fontData.name);
            var tempCtx = SDL_ttfContext();
            tempCtx.font = fontString;
            var ret = tempCtx.measureText(text).width | 0;
            return ret;
          },
          allocateChannels: (num) => {
            if (SDL.numChannels && SDL.numChannels >= num && num != 0)
              return;
            SDL.numChannels = num;
            SDL.channels = [];
            for (var i2 = 0; i2 < num; i2++) {
              SDL.channels[i2] = {
                audio: null,
                volume: 1
              };
            }
          },
          setGetVolume: (info2, volume) => {
            if (!info2)
              return 0;
            var ret = info2.volume * 128;
            if (volume != -1) {
              info2.volume = Math.min(Math.max(volume, 0), 128) / 128;
              if (info2.audio) {
                try {
                  info2.audio.volume = info2.volume;
                  if (info2.audio.webAudioGainNode)
                    info2.audio.webAudioGainNode["gain"]["value"] = info2.volume;
                } catch (e) {
                  err(`setGetVolume failed to set audio volume: ${e}`);
                }
              }
            }
            return ret;
          },
          setPannerPosition: (info2, x, y, z) => {
            if (!info2)
              return;
            if (info2.audio) {
              if (info2.audio.webAudioPannerNode) {
                info2.audio.webAudioPannerNode["setPosition"](x, y, z);
              }
            }
          },
          playWebAudio: (audio) => {
            if (!audio)
              return;
            if (audio.webAudioNode)
              return;
            if (!SDL.webAudioAvailable())
              return;
            try {
              var webAudio = audio.resource.webAudio;
              audio.paused = false;
              if (!webAudio.decodedBuffer) {
                if (webAudio.onDecodeComplete === void 0)
                  abort("Cannot play back audio object that was not loaded");
                webAudio.onDecodeComplete.push(() => {
                  if (!audio.paused)
                    SDL.playWebAudio(audio);
                });
                return;
              }
              audio.webAudioNode = SDL.audioContext["createBufferSource"]();
              audio.webAudioNode["buffer"] = webAudio.decodedBuffer;
              audio.webAudioNode["loop"] = audio.loop;
              audio.webAudioNode["onended"] = audio["onended"];
              audio.webAudioPannerNode = SDL.audioContext["createPanner"]();
              audio.webAudioPannerNode["setPosition"](0, 0, -0.5);
              audio.webAudioPannerNode["panningModel"] = "equalpower";
              audio.webAudioGainNode = SDL.audioContext["createGain"]();
              audio.webAudioGainNode["gain"]["value"] = audio.volume;
              audio.webAudioNode["connect"](audio.webAudioPannerNode);
              audio.webAudioPannerNode["connect"](audio.webAudioGainNode);
              audio.webAudioGainNode["connect"](SDL.audioContext["destination"]);
              audio.webAudioNode["start"](0, audio.currentPosition);
              audio.startTime = SDL.audioContext["currentTime"] - audio.currentPosition;
            } catch (e) {
              err(`playWebAudio failed: ${e}`);
            }
          },
          pauseWebAudio: (audio) => {
            if (!audio)
              return;
            if (audio.webAudioNode) {
              try {
                audio.currentPosition = (SDL.audioContext["currentTime"] - audio.startTime) % audio.resource.webAudio.decodedBuffer.duration;
                audio.webAudioNode["onended"] = void 0;
                audio.webAudioNode.stop(0);
                audio.webAudioNode = void 0;
              } catch (e) {
                err(`pauseWebAudio failed: ${e}`);
              }
            }
            audio.paused = true;
          },
          openAudioContext: () => {
            if (!SDL.audioContext) {
              if (typeof AudioContext != "undefined")
                SDL.audioContext = new AudioContext();
              else if (typeof webkitAudioContext != "undefined")
                SDL.audioContext = new webkitAudioContext();
            }
          },
          webAudioAvailable: () => !!SDL.audioContext,
          fillWebAudioBufferFromHeap: (heapPtr, sizeSamplesPerChannel, dstAudioBuffer) => {
            var audio = SDL_audio();
            var numChannels = audio.channels;
            for (var c = 0; c < numChannels; ++c) {
              var channelData = dstAudioBuffer["getChannelData"](c);
              if (channelData.length != sizeSamplesPerChannel) {
                throw "Web Audio output buffer length mismatch! Destination size: " + channelData.length + " samples vs expected " + sizeSamplesPerChannel + " samples!";
              }
              if (audio.format == 32784) {
                for (var j = 0; j < sizeSamplesPerChannel; ++j) {
                  channelData[j] = HEAP16[heapPtr + (j * numChannels + c) * 2 >>> 1 >>> 0] / 32768;
                }
              } else if (audio.format == 8) {
                for (var j = 0; j < sizeSamplesPerChannel; ++j) {
                  var v = HEAP8[heapPtr + (j * numChannels + c) >>> 0 >>> 0];
                  channelData[j] = (v >= 0 ? v - 128 : v + 128) / 128;
                }
              } else if (audio.format == 33056) {
                for (var j = 0; j < sizeSamplesPerChannel; ++j) {
                  channelData[j] = HEAPF32[heapPtr + (j * numChannels + c) * 4 >>> 2 >>> 0];
                }
              } else {
                throw "Invalid SDL audio format " + audio.format + "!";
              }
            }
          },
          joystickEventState: 1,
          lastJoystickState: {},
          joystickNamePool: {},
          recordJoystickState: (joystick, state) => {
            var buttons = new Array(state.buttons.length);
            for (var i2 = 0; i2 < state.buttons.length; i2++) {
              buttons[i2] = SDL.getJoystickButtonState(state.buttons[i2]);
            }
            SDL.lastJoystickState[joystick] = {
              buttons,
              axes: state.axes.slice(0),
              timestamp: state.timestamp,
              index: state.index,
              id: state.id
            };
          },
          getJoystickButtonState: (button) => {
            if (typeof button == "object") {
              return button["pressed"];
            }
            return button > 0;
          },
          queryJoysticks: () => {
            for (var joystick in SDL.lastJoystickState) {
              var state = SDL.getGamepad(joystick - 1);
              var prevState = SDL.lastJoystickState[joystick];
              if (typeof state == "undefined")
                return;
              if (state === null)
                return;
              if (typeof state.timestamp != "number" || state.timestamp != prevState.timestamp || !state.timestamp) {
                var i2;
                for (i2 = 0; i2 < state.buttons.length; i2++) {
                  var buttonState = SDL.getJoystickButtonState(state.buttons[i2]);
                  if (buttonState !== prevState.buttons[i2]) {
                    SDL.events.push({
                      type: buttonState ? "joystick_button_down" : "joystick_button_up",
                      joystick,
                      index: joystick - 1,
                      button: i2
                    });
                  }
                }
                for (i2 = 0; i2 < state.axes.length; i2++) {
                  if (state.axes[i2] !== prevState.axes[i2]) {
                    SDL.events.push({
                      type: "joystick_axis_motion",
                      joystick,
                      index: joystick - 1,
                      axis: i2,
                      value: state.axes[i2]
                    });
                  }
                }
                SDL.recordJoystickState(joystick, state);
              }
            }
          },
          joystickAxisValueConversion: (value) => {
            value = Math.min(1, Math.max(value, -1));
            return Math.ceil((value + 1) * 32767.5 - 32768);
          },
          getGamepads: () => {
            var fcn = navigator.getGamepads || navigator.webkitGamepads || navigator.mozGamepads || navigator.gamepads || navigator.webkitGetGamepads;
            if (fcn !== void 0) {
              return fcn.apply(navigator);
            }
            return [];
          },
          getGamepad: (deviceIndex) => {
            var gamepads = SDL.getGamepads();
            if (gamepads.length > deviceIndex && deviceIndex >= 0) {
              return gamepads[deviceIndex];
            }
            return null;
          }
        };
        var SDL_unicode = () => SDL.unicode;
        function _SDL_Linked_Version() {
          if (SDL.version === null) {
            SDL.version = _malloc(3);
            HEAP8[SDL.version + 0 >>> 0 >>> 0] = 1;
            HEAP8[SDL.version + 1 >>> 0 >>> 0] = 3;
            HEAP8[SDL.version + 2 >>> 0 >>> 0] = 0;
          }
          return SDL.version;
        }
        _SDL_Linked_Version.sig = "p";
        var _SDL_Init = (initFlags) => {
          SDL.startTime = Date.now();
          SDL.initFlags = initFlags;
          if (!Module["doNotCaptureKeyboard"]) {
            var keyboardListeningElement = Module["keyboardListeningElement"] || document;
            keyboardListeningElement.addEventListener("keydown", SDL.receiveEvent);
            keyboardListeningElement.addEventListener("keyup", SDL.receiveEvent);
            keyboardListeningElement.addEventListener("keypress", SDL.receiveEvent);
            window.addEventListener("focus", SDL.receiveEvent);
            window.addEventListener("blur", SDL.receiveEvent);
            document.addEventListener("visibilitychange", SDL.receiveEvent);
          }
          window.addEventListener("unload", SDL.receiveEvent);
          SDL.keyboardState = _malloc(65536);
          zeroMemory(SDL.keyboardState, 65536);
          SDL.DOMEventToSDLEvent["keydown"] = 768;
          SDL.DOMEventToSDLEvent["keyup"] = 769;
          SDL.DOMEventToSDLEvent["keypress"] = 771;
          SDL.DOMEventToSDLEvent["mousedown"] = 1025;
          SDL.DOMEventToSDLEvent["mouseup"] = 1026;
          SDL.DOMEventToSDLEvent["mousemove"] = 1024;
          SDL.DOMEventToSDLEvent["wheel"] = 1027;
          SDL.DOMEventToSDLEvent["touchstart"] = 1792;
          SDL.DOMEventToSDLEvent["touchend"] = 1793;
          SDL.DOMEventToSDLEvent["touchmove"] = 1794;
          SDL.DOMEventToSDLEvent["unload"] = 256;
          SDL.DOMEventToSDLEvent["resize"] = 28673;
          SDL.DOMEventToSDLEvent["visibilitychange"] = 512;
          SDL.DOMEventToSDLEvent["focus"] = 512;
          SDL.DOMEventToSDLEvent["blur"] = 512;
          SDL.DOMEventToSDLEvent["joystick_axis_motion"] = 1536;
          SDL.DOMEventToSDLEvent["joystick_button_down"] = 1539;
          SDL.DOMEventToSDLEvent["joystick_button_up"] = 1540;
          return 0;
        };
        _SDL_Init.sig = "ii";
        var _SDL_WasInit = (flags2) => {
          if (SDL.startTime === null) {
            _SDL_Init(0);
          }
          return 1;
        };
        _SDL_WasInit.sig = "ii";
        function _SDL_GetVideoInfo() {
          var ret = _malloc(20);
          zeroMemory(ret, 3);
          HEAP32[ret + 12 >>> 2 >>> 0] = Module["canvas"].width;
          HEAP32[ret + 16 >>> 2 >>> 0] = Module["canvas"].height;
          return ret;
        }
        _SDL_GetVideoInfo.sig = "p";
        function _SDL_ListModes(format, flags2) {
          format >>>= 0;
          return -1;
        }
        _SDL_ListModes.sig = "ppi";
        var _SDL_VideoModeOK = (width, height, depth, flags2) => depth;
        _SDL_VideoModeOK.sig = "iiiii";
        function _SDL_VideoDriverName(buf, max_size) {
          buf >>>= 0;
          if (SDL.startTime === null) {
            return 0;
          }
          var driverName = [101, 109, 115, 99, 114, 105, 112, 116, 101, 110, 95, 115, 100, 108, 95, 100, 114, 105, 118, 101, 114];
          var index = 0;
          var size = driverName.length;
          if (max_size <= size) {
            size = max_size - 1;
          }
          while (index < size) {
            var value = driverName[index];
            HEAP8[buf + index >>> 0 >>> 0] = value;
            index++;
          }
          HEAP8[buf + index >>> 0 >>> 0] = 0;
          return buf;
        }
        _SDL_VideoDriverName.sig = "ppi";
        var _SDL_AudioDriverName = _SDL_VideoDriverName;
        _SDL_AudioDriverName.sig = "ppi";
        var _SDL_SetVideoMode = function(width, height, depth, flags2) {
          ["touchstart", "touchend", "touchmove", "mousedown", "mouseup", "mousemove", "mousewheel", "wheel", "mouseout", "DOMMouseScroll"].forEach((e) => Module["canvas"].addEventListener(e, SDL.receiveEvent, true));
          var canvas = Module["canvas"];
          if (width == 0 && height == 0) {
            width = canvas.width;
            height = canvas.height;
          }
          if (!SDL.addedResizeListener) {
            SDL.addedResizeListener = true;
            Browser.resizeListeners.push((w, h) => {
              if (!SDL.settingVideoMode) {
                SDL.receiveEvent({
                  type: "resize",
                  w,
                  h
                });
              }
            });
          }
          SDL.settingVideoMode = true;
          Browser.setCanvasSize(width, height);
          SDL.settingVideoMode = false;
          if (SDL.screen) {
            SDL.freeSurface(SDL.screen);
            assert(!SDL.screen);
          }
          if (SDL.GL)
            flags2 = flags2 | 67108864;
          SDL.screen = SDL.makeSurface(width, height, flags2, true, "screen");
          return SDL.screen;
        };
        _SDL_SetVideoMode.sig = "piiii";
        function _SDL_GetVideoSurface() {
          return SDL.screen;
        }
        _SDL_GetVideoSurface.sig = "p";
        var _SDL_AudioQuit = () => {
          for (var i2 = 0; i2 < SDL.numChannels; ++i2) {
            var chan = SDL.channels[i2];
            if (chan.audio) {
              chan.audio.pause();
              chan.audio = void 0;
            }
          }
          var audio = SDL.music.audio;
          audio == null ? void 0 : audio.pause();
          SDL.music.audio = void 0;
        };
        _SDL_AudioQuit.sig = "v";
        var _SDL_VideoQuit = () => out("SDL_VideoQuit called (and ignored)");
        _SDL_VideoQuit.sig = "v";
        var _SDL_QuitSubSystem = (flags2) => out("SDL_QuitSubSystem called (and ignored)");
        _SDL_QuitSubSystem.sig = "vi";
        var _SDL_Quit = () => {
          _SDL_AudioQuit();
          out("SDL_Quit called (and ignored)");
        };
        _SDL_Quit.sig = "v";
        function _SDL_UnlockSurface(surf) {
          surf >>>= 0;
          assert(!SDL.GL);
          var surfData = SDL.surfaces[surf];
          if (!surfData.locked || --surfData.locked > 0) {
            return;
          }
          if (surfData.isFlagSet(2097152)) {
            SDL.copyIndexedColorData(surfData);
          } else if (!surfData.colors) {
            var data2 = surfData.image.data;
            var buffer = surfData.buffer;
            assert(buffer % 4 == 0, "Invalid buffer offset: " + buffer);
            var src = buffer >> 2;
            var dst = 0;
            var isScreen = surf == SDL.screen;
            var num;
            if (typeof CanvasPixelArray != "undefined" && data2 instanceof CanvasPixelArray) {
              num = data2.length;
              while (dst < num) {
                var val = HEAP32[src >>> 0];
                data2[dst] = val & 255;
                data2[dst + 1] = val >> 8 & 255;
                data2[dst + 2] = val >> 16 & 255;
                data2[dst + 3] = isScreen ? 255 : val >> 24 & 255;
                src++;
                dst += 4;
              }
            } else {
              var data32 = new Uint32Array(data2.buffer);
              if (isScreen && SDL.defaults.opaqueFrontBuffer) {
                num = data32.length;
                data32.set(HEAP32.subarray(src >>> 0, src + num >>> 0));
                var data8 = new Uint8Array(data2.buffer);
                var i2 = 3;
                var j = i2 + 4 * num;
                if (num % 8 == 0) {
                  while (i2 < j) {
                    data8[i2] = 255;
                    i2 = i2 + 4 | 0;
                    data8[i2] = 255;
                    i2 = i2 + 4 | 0;
                    data8[i2] = 255;
                    i2 = i2 + 4 | 0;
                    data8[i2] = 255;
                    i2 = i2 + 4 | 0;
                    data8[i2] = 255;
                    i2 = i2 + 4 | 0;
                    data8[i2] = 255;
                    i2 = i2 + 4 | 0;
                    data8[i2] = 255;
                    i2 = i2 + 4 | 0;
                    data8[i2] = 255;
                    i2 = i2 + 4 | 0;
                  }
                } else {
                  while (i2 < j) {
                    data8[i2] = 255;
                    i2 = i2 + 4 | 0;
                  }
                }
              } else {
                data32.set(HEAP32.subarray(src >>> 0, src + data32.length >>> 0));
              }
            }
          } else {
            var width = Module["canvas"].width;
            var height = Module["canvas"].height;
            var s2 = surfData.buffer;
            var data2 = surfData.image.data;
            var colors = surfData.colors;
            for (var y = 0; y < height; y++) {
              var base = y * width * 4;
              for (var x = 0; x < width; x++) {
                var val = HEAPU8[s2++ >>> 0 >>> 0] * 4;
                var start2 = base + x * 4;
                data2[start2] = colors[val];
                data2[start2 + 1] = colors[val + 1];
                data2[start2 + 2] = colors[val + 2];
              }
              s2 += width * 3;
            }
          }
          surfData.ctx.putImageData(surfData.image, 0, 0);
        }
        _SDL_UnlockSurface.sig = "vp";
        function _SDL_Flip(surf) {
          surf >>>= 0;
        }
        _SDL_Flip.sig = "ip";
        function _SDL_UpdateRect(surf, x, y, w, h) {
          surf >>>= 0;
        }
        _SDL_UpdateRect.sig = "vpiiii";
        function _SDL_UpdateRects(surf, numrects, rects) {
          surf >>>= 0;
          rects >>>= 0;
        }
        _SDL_UpdateRects.sig = "vpip";
        var _SDL_Delay = (delay) => {
          if (!ENVIRONMENT_IS_WORKER)
            abort("SDL_Delay called on the main thread! Potential infinite loop, quitting. (consider building with async support like ASYNCIFY)");
          var now = Date.now();
          while (Date.now() - now < delay) {
          }
        };
        _SDL_Delay.sig = "vi";
        function _SDL_WM_SetCaption(title, icon) {
          title >>>= 0;
          icon >>>= 0;
          if (title) {
            _emscripten_set_window_title(title);
          }
          icon && (icon = UTF8ToString(icon));
        }
        _SDL_WM_SetCaption.sig = "vpp";
        var _SDL_EnableKeyRepeat = (delay, interval) => {
        };
        _SDL_EnableKeyRepeat.sig = "iii";
        function _SDL_GetKeyboardState(numKeys) {
          numKeys >>>= 0;
          if (numKeys) {
            HEAP32[numKeys >>> 2 >>> 0] = 65536;
          }
          return SDL.keyboardState;
        }
        _SDL_GetKeyboardState.sig = "pp";
        var _SDL_GetKeyState = () => _SDL_GetKeyboardState(0);
        function _SDL_GetKeyName(key) {
          SDL.keyName || (SDL.keyName = stringToNewUTF8("unknown key"));
          return SDL.keyName;
        }
        _SDL_GetKeyName.sig = "pi";
        var _SDL_GetModState = () => SDL.modState;
        _SDL_GetModState.sig = "i";
        function _SDL_GetMouseState(x, y) {
          x >>>= 0;
          y >>>= 0;
          if (x)
            HEAP32[x >>> 2 >>> 0] = Browser.mouseX;
          if (y)
            HEAP32[y >>> 2 >>> 0] = Browser.mouseY;
          return SDL.buttonState;
        }
        _SDL_GetMouseState.sig = "ipp";
        var _SDL_WarpMouse = (x, y) => {
        };
        _SDL_WarpMouse.sig = "vii";
        var _SDL_ShowCursor = (toggle) => {
          switch (toggle) {
            case 0:
              if (Browser.isFullscreen) {
                Module["canvas"].requestPointerLock();
                return 0;
              }
              return 1;
            case 1:
              Module["canvas"].exitPointerLock();
              return 1;
            case -1:
              return !Browser.pointerLock;
            default:
              err(`SDL_ShowCursor called with unknown toggle parameter value: ${toggle}`);
              break;
          }
        };
        _SDL_ShowCursor.sig = "ii";
        function _SDL_GetError() {
          SDL.errorMessage || (SDL.errorMessage = stringToNewUTF8("unknown SDL-emscripten error"));
          return SDL.errorMessage;
        }
        _SDL_GetError.sig = "p";
        function _SDL_SetError(fmt, varargs) {
          fmt >>>= 0;
          varargs >>>= 0;
        }
        _SDL_SetError.sig = "vpp";
        function _SDL_CreateRGBSurface(flags2, width, height, depth, rmask, gmask, bmask, amask) {
          return SDL.makeSurface(width, height, flags2, false, "CreateRGBSurface", rmask, gmask, bmask, amask);
        }
        _SDL_CreateRGBSurface.sig = "piiiiiiii";
        function _SDL_CreateRGBSurfaceFrom(pixels, width, height, depth, pitch, rmask, gmask, bmask, amask) {
          pixels >>>= 0;
          var surf = SDL.makeSurface(width, height, 0, false, "CreateRGBSurfaceFrom", rmask, gmask, bmask, amask);
          if (depth !== 32) {
            err("TODO: Partially unimplemented SDL_CreateRGBSurfaceFrom called!");
            return surf;
          }
          var data2 = SDL.surfaces[surf];
          var image = data2.ctx.createImageData(width, height);
          var pitchOfDst = width * 4;
          for (var row = 0; row < height; ++row) {
            var baseOfSrc = row * pitch;
            var baseOfDst = row * pitchOfDst;
            for (var col = 0; col < width * 4; ++col) {
              image.data[baseOfDst + col] = HEAPU8[pixels + (baseOfDst + col) >>> 0 >>> 0];
            }
          }
          data2.ctx.putImageData(image, 0, 0);
          return surf;
        }
        _SDL_CreateRGBSurfaceFrom.sig = "ppiiiiiiii";
        function _SDL_ConvertSurface(surf, format, flags2) {
          surf >>>= 0;
          format >>>= 0;
          if (format) {
            SDL.checkPixelFormat(format);
          }
          var oldData = SDL.surfaces[surf];
          var ret = SDL.makeSurface(oldData.width, oldData.height, oldData.flags, false, "copy:" + oldData.source);
          var newData = SDL.surfaces[ret];
          newData.ctx.globalCompositeOperation = "copy";
          newData.ctx.drawImage(oldData.canvas, 0, 0);
          newData.ctx.globalCompositeOperation = oldData.ctx.globalCompositeOperation;
          return ret;
        }
        _SDL_ConvertSurface.sig = "pppi";
        function _SDL_DisplayFormatAlpha(surf) {
          surf >>>= 0;
          return _SDL_ConvertSurface(surf, 0, 0);
        }
        _SDL_DisplayFormatAlpha.sig = "pp";
        function _SDL_FreeSurface(surf) {
          surf >>>= 0;
          if (surf)
            SDL.freeSurface(surf);
        }
        _SDL_FreeSurface.sig = "vp";
        function _SDL_UpperBlit(src, srcrect, dst, dstrect) {
          src >>>= 0;
          srcrect >>>= 0;
          dst >>>= 0;
          dstrect >>>= 0;
          return SDL.blitSurface(src, srcrect, dst, dstrect, false);
        }
        _SDL_UpperBlit.sig = "ipppp";
        function _SDL_UpperBlitScaled(src, srcrect, dst, dstrect) {
          src >>>= 0;
          srcrect >>>= 0;
          dst >>>= 0;
          dstrect >>>= 0;
          return SDL.blitSurface(src, srcrect, dst, dstrect, true);
        }
        _SDL_UpperBlitScaled.sig = "ipppp";
        var _SDL_LowerBlit = _SDL_UpperBlit;
        _SDL_LowerBlit.sig = "ipppp";
        var _SDL_LowerBlitScaled = _SDL_UpperBlitScaled;
        _SDL_LowerBlitScaled.sig = "ipppp";
        function _SDL_GetClipRect(surf, rect) {
          surf >>>= 0;
          rect >>>= 0;
          assert(rect);
          var surfData = SDL.surfaces[surf];
          var r = surfData.clipRect || {
            x: 0,
            y: 0,
            w: surfData.width,
            h: surfData.height
          };
          SDL.updateRect(rect, r);
        }
        _SDL_GetClipRect.sig = "vpp";
        function _SDL_SetClipRect(surf, rect) {
          surf >>>= 0;
          rect >>>= 0;
          var surfData = SDL.surfaces[surf];
          if (rect) {
            surfData.clipRect = SDL.intersectionOfRects({
              x: 0,
              y: 0,
              w: surfData.width,
              h: surfData.height
            }, SDL.loadRect(rect));
          } else {
            delete surfData.clipRect;
          }
        }
        _SDL_SetClipRect.sig = "ipp";
        function _SDL_FillRect(surf, rect, color) {
          surf >>>= 0;
          rect >>>= 0;
          var surfData = SDL.surfaces[surf];
          assert(!surfData.locked);
          if (surfData.isFlagSet(2097152)) {
            color = surfData.colors32[color];
          }
          var r = rect ? SDL.loadRect(rect) : {
            x: 0,
            y: 0,
            w: surfData.width,
            h: surfData.height
          };
          if (surfData.clipRect) {
            r = SDL.intersectionOfRects(surfData.clipRect, r);
            if (rect) {
              SDL.updateRect(rect, r);
            }
          }
          surfData.ctx.save();
          surfData.ctx.fillStyle = SDL.translateColorToCSSRGBA(color);
          surfData.ctx.fillRect(r.x, r.y, r.w, r.h);
          surfData.ctx.restore();
          return 0;
        }
        _SDL_FillRect.sig = "ippi";
        function _zoomSurface(src, x, y, smooth) {
          src >>>= 0;
          var srcData = SDL.surfaces[src];
          var w = srcData.width * x;
          var h = srcData.height * y;
          var ret = SDL.makeSurface(Math.abs(w), Math.abs(h), srcData.flags, false, "zoomSurface");
          var dstData = SDL.surfaces[ret];
          if (x >= 0 && y >= 0)
            dstData.ctx.drawImage(srcData.canvas, 0, 0, w, h);
          else {
            dstData.ctx.save();
            dstData.ctx.scale(x < 0 ? -1 : 1, y < 0 ? -1 : 1);
            dstData.ctx.drawImage(srcData.canvas, w < 0 ? w : 0, h < 0 ? h : 0, Math.abs(w), Math.abs(h));
            dstData.ctx.restore();
          }
          return ret;
        }
        _zoomSurface.sig = "ppddi";
        function _rotozoomSurface(src, angle, zoom, smooth) {
          src >>>= 0;
          if (angle % 360 === 0) {
            return _zoomSurface(src, zoom, zoom, smooth);
          }
          var srcData = SDL.surfaces[src];
          var w = srcData.width * zoom;
          var h = srcData.height * zoom;
          var diagonal = Math.ceil(Math.sqrt(Math.pow(w, 2) + Math.pow(h, 2)));
          var ret = SDL.makeSurface(diagonal, diagonal, srcData.flags, false, "rotozoomSurface");
          var dstData = SDL.surfaces[ret];
          dstData.ctx.translate(diagonal / 2, diagonal / 2);
          dstData.ctx.rotate(-angle * Math.PI / 180);
          dstData.ctx.drawImage(srcData.canvas, -w / 2, -h / 2, w, h);
          return ret;
        }
        _rotozoomSurface.sig = "ppddi";
        function _SDL_SetAlpha(surf, flag, alpha) {
          surf >>>= 0;
          var surfData = SDL.surfaces[surf];
          surfData.alpha = alpha;
          if (!(flag & 65536)) {
            surfData.alpha = 255;
          }
        }
        _SDL_SetAlpha.sig = "ipii";
        function _SDL_SetColorKey(surf, flag, key) {
          surf >>>= 0;
          warnOnce("SDL_SetColorKey is a no-op for performance reasons");
          return 0;
        }
        _SDL_SetColorKey.sig = "ipii";
        function _SDL_PollEvent(ptr2) {
          ptr2 >>>= 0;
          return SDL.pollEvent(ptr2);
        }
        _SDL_PollEvent.sig = "ip";
        function _SDL_PushEvent(ptr2) {
          ptr2 >>>= 0;
          var copy = _malloc(28);
          _memcpy(copy, ptr2, 28);
          SDL.events.push(copy);
          return 0;
        }
        _SDL_PushEvent.sig = "ip";
        function _SDL_PeepEvents(events, requestedEventCount, action, from, to) {
          events >>>= 0;
          switch (action) {
            case 2: {
              assert(requestedEventCount == 1);
              var index = 0;
              var retrievedEventCount = 0;
              while (index < SDL.events.length && retrievedEventCount < requestedEventCount) {
                var event2 = SDL.events[index];
                var type = SDL.DOMEventToSDLEvent[event2.type];
                if (from <= type && type <= to) {
                  if (SDL.makeCEvent(event2, events) === false) {
                    index++;
                  } else {
                    SDL.events.splice(index, 1);
                    retrievedEventCount++;
                  }
                } else {
                  index++;
                }
              }
              return retrievedEventCount;
            }
            default:
              throw "SDL_PeepEvents does not yet support that action: " + action;
          }
        }
        _SDL_PeepEvents.sig = "ipiiii";
        var _SDL_PumpEvents = () => SDL.events.forEach(SDL.handleEvent);
        _SDL_PumpEvents.sig = "v";
        function _emscripten_SDL_SetEventHandler(handler, userdata) {
          handler >>>= 0;
          userdata >>>= 0;
          SDL.eventHandler = handler;
          SDL.eventHandlerContext = userdata;
          if (!SDL.eventHandlerTemp)
            SDL.eventHandlerTemp = _malloc(28);
        }
        _emscripten_SDL_SetEventHandler.sig = "vpp";
        function _SDL_SetColors(surf, colors, firstColor, nColors) {
          surf >>>= 0;
          colors >>>= 0;
          var surfData = SDL.surfaces[surf];
          if (!surfData.colors) {
            var buffer = new ArrayBuffer(256 * 4);
            surfData.colors = new Uint8Array(buffer);
            surfData.colors32 = new Uint32Array(buffer);
          }
          for (var i2 = 0; i2 < nColors; ++i2) {
            var index = (firstColor + i2) * 4;
            surfData.colors[index] = HEAPU8[colors + i2 * 4 >>> 0 >>> 0];
            surfData.colors[index + 1] = HEAPU8[colors + (i2 * 4 + 1) >>> 0 >>> 0];
            surfData.colors[index + 2] = HEAPU8[colors + (i2 * 4 + 2) >>> 0 >>> 0];
            surfData.colors[index + 3] = 255;
          }
          return 1;
        }
        _SDL_SetColors.sig = "ippii";
        function _SDL_SetPalette(surf, flags2, colors, firstColor, nColors) {
          surf >>>= 0;
          colors >>>= 0;
          return _SDL_SetColors(surf, colors, firstColor, nColors);
        }
        _SDL_SetPalette.sig = "ipipii";
        function _SDL_MapRGB(fmt, r, g, b) {
          fmt >>>= 0;
          SDL.checkPixelFormat(fmt);
          return r & 255 | (g & 255) << 8 | (b & 255) << 16 | 4278190080;
        }
        _SDL_MapRGB.sig = "ipiii";
        function _SDL_MapRGBA(fmt, r, g, b, a) {
          fmt >>>= 0;
          SDL.checkPixelFormat(fmt);
          return r & 255 | (g & 255) << 8 | (b & 255) << 16 | (a & 255) << 24;
        }
        _SDL_MapRGBA.sig = "ipiiii";
        function _SDL_GetRGB(pixel, fmt, r, g, b) {
          fmt >>>= 0;
          r >>>= 0;
          g >>>= 0;
          b >>>= 0;
          SDL.checkPixelFormat(fmt);
          if (r) {
            HEAP8[r >>> 0 >>> 0] = pixel & 255;
          }
          if (g) {
            HEAP8[g >>> 0 >>> 0] = pixel >> 8 & 255;
          }
          if (b) {
            HEAP8[b >>> 0 >>> 0] = pixel >> 16 & 255;
          }
        }
        _SDL_GetRGB.sig = "vipppp";
        function _SDL_GetRGBA(pixel, fmt, r, g, b, a) {
          fmt >>>= 0;
          r >>>= 0;
          g >>>= 0;
          b >>>= 0;
          a >>>= 0;
          SDL.checkPixelFormat(fmt);
          if (r) {
            HEAP8[r >>> 0 >>> 0] = pixel & 255;
          }
          if (g) {
            HEAP8[g >>> 0 >>> 0] = pixel >> 8 & 255;
          }
          if (b) {
            HEAP8[b >>> 0 >>> 0] = pixel >> 16 & 255;
          }
          if (a) {
            HEAP8[a >>> 0 >>> 0] = pixel >> 24 & 255;
          }
        }
        _SDL_GetRGBA.sig = "vippppp";
        var _SDL_GetAppState = () => {
          var state = 0;
          if (Browser.pointerLock) {
            state |= 1;
          }
          if (document.hasFocus()) {
            state |= 2;
          }
          state |= 4;
          return state;
        };
        _SDL_GetAppState.sig = "i";
        var _SDL_WM_GrabInput = () => {
        };
        _SDL_WM_GrabInput.sig = "ii";
        function _SDL_WM_ToggleFullScreen(surf) {
          surf >>>= 0;
          if (Browser.exitFullscreen()) {
            return 1;
          }
          if (!SDL.canRequestFullscreen) {
            return 0;
          }
          SDL.isRequestingFullscreen = true;
          return 1;
        }
        _SDL_WM_ToggleFullScreen.sig = "ip";
        var _IMG_Init = (flags2) => flags2;
        _IMG_Init.sig = "ii";
        function _SDL_FreeRW(rwopsID) {
          rwopsID >>>= 0;
          SDL.rwops[rwopsID] = null;
          while (SDL.rwops.length > 0 && SDL.rwops[SDL.rwops.length - 1] === null) {
            SDL.rwops.pop();
          }
        }
        _SDL_FreeRW.sig = "vp";
        var _IMG_Load_RW = function(rwopsID, freeSrc) {
          rwopsID >>>= 0;
          try {
            var cleanup = () => {
              if (rwops && freeSrc)
                _SDL_FreeRW(rwopsID);
            };
            var addCleanup = (func2) => {
              var old = cleanup;
              cleanup = () => {
                old();
                func2();
              };
            };
            var callStbImage = (func2, params) => withStackSave(() => {
              var x = stackAlloc(4);
              var y = stackAlloc(4);
              var comp = stackAlloc(4);
              var data3 = Module["_" + func2].apply(null, params.concat([x, y, comp, 0]));
              if (!data3)
                return null;
              addCleanup(() => Module["_stbi_image_free"](data3));
              return {
                rawData: true,
                data: data3,
                width: HEAP32[x >>> 2 >>> 0],
                height: HEAP32[y >>> 2 >>> 0],
                size: HEAP32[x >>> 2 >>> 0] * HEAP32[y >>> 2 >>> 0] * HEAP32[comp >>> 2 >>> 0],
                bpp: HEAP32[comp >>> 2 >>> 0]
              };
            });
            var rwops = SDL.rwops[rwopsID];
            if (rwops === void 0) {
              return 0;
            }
            var raw;
            var filename = rwops.filename;
            if (filename === void 0) {
              warnOnce("Only file names that have been preloaded are supported for IMG_Load_RW. Consider using STB_IMAGE=1 if you want synchronous image decoding (see settings.js), or package files with --use-preload-plugins");
              return 0;
            }
            if (!raw) {
              filename = PATH_FS.resolve(filename);
              raw = preloadedImages[filename];
              if (!raw) {
                if (raw === null)
                  err("Trying to reuse preloaded image, but freePreloadedMediaOnUse is set!");
                warnOnce("Cannot find preloaded image " + filename);
                warnOnce("Cannot find preloaded image " + filename + ". Consider using STB_IMAGE=1 if you want synchronous image decoding (see settings.js), or package files with --use-preload-plugins");
                return 0;
              } else if (Module["freePreloadedMediaOnUse"]) {
                preloadedImages[filename] = null;
              }
            }
            var surf = SDL.makeSurface(raw.width, raw.height, 0, false, "load:" + filename);
            var surfData = SDL.surfaces[surf];
            surfData.ctx.globalCompositeOperation = "copy";
            if (!raw.rawData) {
              surfData.ctx.drawImage(raw, 0, 0, raw.width, raw.height, 0, 0, raw.width, raw.height);
            } else {
              var imageData = surfData.ctx.getImageData(0, 0, surfData.width, surfData.height);
              if (raw.bpp == 4) {
                imageData.data.set(HEAPU8.subarray(raw.data >>> 0, raw.data + raw.size >>> 0));
              } else if (raw.bpp == 3) {
                var pixels = raw.size / 3;
                var data2 = imageData.data;
                var sourcePtr = raw.data;
                var destPtr = 0;
                for (var i2 = 0; i2 < pixels; i2++) {
                  data2[destPtr++] = HEAPU8[sourcePtr++ >>> 0 >>> 0];
                  data2[destPtr++] = HEAPU8[sourcePtr++ >>> 0 >>> 0];
                  data2[destPtr++] = HEAPU8[sourcePtr++ >>> 0 >>> 0];
                  data2[destPtr++] = 255;
                }
              } else if (raw.bpp == 2) {
                var pixels = raw.size;
                var data2 = imageData.data;
                var sourcePtr = raw.data;
                var destPtr = 0;
                for (var i2 = 0; i2 < pixels; i2++) {
                  var gray = HEAPU8[sourcePtr++ >>> 0 >>> 0];
                  var alpha = HEAPU8[sourcePtr++ >>> 0 >>> 0];
                  data2[destPtr++] = gray;
                  data2[destPtr++] = gray;
                  data2[destPtr++] = gray;
                  data2[destPtr++] = alpha;
                }
              } else if (raw.bpp == 1) {
                var pixels = raw.size;
                var data2 = imageData.data;
                var sourcePtr = raw.data;
                var destPtr = 0;
                for (var i2 = 0; i2 < pixels; i2++) {
                  var value = HEAPU8[sourcePtr++ >>> 0 >>> 0];
                  data2[destPtr++] = value;
                  data2[destPtr++] = value;
                  data2[destPtr++] = value;
                  data2[destPtr++] = 255;
                }
              } else {
                err(`cannot handle bpp ${raw.bpp}`);
                return 0;
              }
              surfData.ctx.putImageData(imageData, 0, 0);
            }
            surfData.ctx.globalCompositeOperation = "source-over";
            _SDL_LockSurface(surf);
            surfData.locked--;
            if (SDL.GL) {
              surfData.canvas = surfData.ctx = null;
            }
            return surf;
          } finally {
            cleanup();
          }
        };
        _IMG_Load_RW.sig = "ppi";
        var _SDL_LoadBMP_RW = _IMG_Load_RW;
        _SDL_LoadBMP_RW.sig = "ppi";
        function _SDL_RWFromFile(_name, mode) {
          _name >>>= 0;
          mode >>>= 0;
          var id = SDL.rwops.length;
          var filename = UTF8ToString(_name);
          SDL.rwops.push({
            filename,
            mimetype: Browser.getMimetype(filename)
          });
          return id;
        }
        _SDL_RWFromFile.sig = "ppp";
        function _IMG_Load(filename) {
          filename >>>= 0;
          var rwops = _SDL_RWFromFile(filename, 0);
          var result = _IMG_Load_RW(rwops, 1);
          return result;
        }
        _IMG_Load.sig = "pp";
        var _IMG_Quit = () => out("IMG_Quit called (and ignored)");
        _IMG_Quit.sig = "v";
        function _SDL_OpenAudio(desired, obtained) {
          desired >>>= 0;
          obtained >>>= 0;
          try {
            SDL.audio = {
              freq: HEAPU32[desired >>> 2 >>> 0],
              format: HEAPU16[desired + 4 >>> 1 >>> 0],
              channels: HEAPU8[desired + 6 >>> 0 >>> 0],
              samples: HEAPU16[desired + 8 >>> 1 >>> 0],
              callback: HEAPU32[desired + 16 >>> 2 >>> 0],
              userdata: HEAPU32[desired + 20 >>> 2 >>> 0],
              paused: true,
              timer: null
            };
            if (SDL.audio.format == 8) {
              SDL.audio.silence = 128;
            } else if (SDL.audio.format == 32784) {
              SDL.audio.silence = 0;
            } else if (SDL.audio.format == 33056) {
              SDL.audio.silence = 0;
            } else {
              throw "Invalid SDL audio format " + SDL.audio.format + "!";
            }
            if (SDL.audio.freq <= 0) {
              throw "Unsupported sound frequency " + SDL.audio.freq + "!";
            } else if (SDL.audio.freq <= 22050) {
              SDL.audio.freq = 22050;
            } else if (SDL.audio.freq <= 32e3) {
              SDL.audio.freq = 32e3;
            } else if (SDL.audio.freq <= 44100) {
              SDL.audio.freq = 44100;
            } else if (SDL.audio.freq <= 48e3) {
              SDL.audio.freq = 48e3;
            } else if (SDL.audio.freq <= 96e3) {
              SDL.audio.freq = 96e3;
            } else {
              throw `Unsupported sound frequency ${SDL.audio.freq}!`;
            }
            if (SDL.audio.channels == 0) {
              SDL.audio.channels = 1;
            } else if (SDL.audio.channels < 0 || SDL.audio.channels > 32) {
              throw `Unsupported number of audio channels for SDL audio: ${SDL.audio.channels}!`;
            } else if (SDL.audio.channels != 1 && SDL.audio.channels != 2) {
              out(`Warning: Using untested number of audio channels ${SDL.audio.channels}`);
            }
            if (SDL.audio.samples < 128 || SDL.audio.samples > 524288) {
              throw `Unsupported audio callback buffer size ${SDL.audio.samples}!`;
            } else if ((SDL.audio.samples & SDL.audio.samples - 1) != 0) {
              throw `Audio callback buffer size ${SDL.audio.samples} must be a power-of-two!`;
            }
            var totalSamples = SDL.audio.samples * SDL.audio.channels;
            if (SDL.audio.format == 8) {
              SDL.audio.bytesPerSample = 1;
            } else if (SDL.audio.format == 32784) {
              SDL.audio.bytesPerSample = 2;
            } else if (SDL.audio.format == 33056) {
              SDL.audio.bytesPerSample = 4;
            } else {
              throw `Invalid SDL audio format ${SDL.audio.format}!`;
            }
            SDL.audio.bufferSize = totalSamples * SDL.audio.bytesPerSample;
            SDL.audio.bufferDurationSecs = SDL.audio.bufferSize / SDL.audio.bytesPerSample / SDL.audio.channels / SDL.audio.freq;
            SDL.audio.bufferingDelay = 50 / 1e3;
            SDL.audio.buffer = _malloc(SDL.audio.bufferSize);
            SDL.audio.numSimultaneouslyQueuedBuffers = Module["SDL_numSimultaneouslyQueuedBuffers"] || 5;
            SDL.audio.queueNewAudioData = () => {
              if (!SDL.audio)
                return;
              for (var i2 = 0; i2 < SDL.audio.numSimultaneouslyQueuedBuffers; ++i2) {
                var secsUntilNextPlayStart = SDL.audio.nextPlayTime - SDL.audioContext["currentTime"];
                if (secsUntilNextPlayStart >= SDL.audio.bufferingDelay + SDL.audio.bufferDurationSecs * SDL.audio.numSimultaneouslyQueuedBuffers)
                  return;
                getWasmTableEntry(SDL.audio.callback)(SDL.audio.userdata, SDL.audio.buffer, SDL.audio.bufferSize);
                SDL.audio.pushAudio(SDL.audio.buffer, SDL.audio.bufferSize);
              }
            };
            SDL.audio.caller = () => {
              if (!SDL.audio)
                return;
              --SDL.audio.numAudioTimersPending;
              SDL.audio.queueNewAudioData();
              var secsUntilNextPlayStart = SDL.audio.nextPlayTime - SDL.audioContext["currentTime"];
              var preemptBufferFeedSecs = SDL.audio.bufferDurationSecs / 2;
              if (SDL.audio.numAudioTimersPending < SDL.audio.numSimultaneouslyQueuedBuffers) {
                ++SDL.audio.numAudioTimersPending;
                SDL.audio.timer = safeSetTimeout(SDL.audio.caller, Math.max(0, 1e3 * (secsUntilNextPlayStart - preemptBufferFeedSecs)));
                if (SDL.audio.numAudioTimersPending < SDL.audio.numSimultaneouslyQueuedBuffers) {
                  ++SDL.audio.numAudioTimersPending;
                  safeSetTimeout(SDL.audio.caller, 1);
                }
              }
            };
            SDL.audio.audioOutput = new Audio();
            SDL.openAudioContext();
            if (!SDL.audioContext)
              throw "Web Audio API is not available!";
            autoResumeAudioContext(SDL.audioContext);
            SDL.audio.nextPlayTime = 0;
            SDL.audio.pushAudio = function(ptr2, sizeBytes) {
              try {
                if (SDL.audio.paused)
                  return;
                var sizeSamples = sizeBytes / SDL.audio.bytesPerSample;
                var sizeSamplesPerChannel = sizeSamples / SDL.audio.channels;
                if (sizeSamplesPerChannel != SDL.audio.samples) {
                  throw "Received mismatching audio buffer size!";
                }
                var source = SDL.audioContext["createBufferSource"]();
                var soundBuffer = SDL.audioContext["createBuffer"](SDL.audio.channels, sizeSamplesPerChannel, SDL.audio.freq);
                source["connect"](SDL.audioContext["destination"]);
                SDL.fillWebAudioBufferFromHeap(ptr2, sizeSamplesPerChannel, soundBuffer);
                source["buffer"] = soundBuffer;
                var curtime = SDL.audioContext["currentTime"];
                var playtime = Math.max(curtime + SDL.audio.bufferingDelay, SDL.audio.nextPlayTime);
                if (typeof source["start"] != "undefined") {
                  source["start"](playtime);
                } else if (typeof source["noteOn"] != "undefined") {
                  source["noteOn"](playtime);
                }
                SDL.audio.nextPlayTime = playtime + SDL.audio.bufferDurationSecs;
              } catch (e) {
                err(`Web Audio API error playing back audio: ${e.toString()}`);
              }
            };
            if (obtained) {
              HEAP32[obtained >>> 2 >>> 0] = SDL.audio.freq;
              HEAP16[obtained + 4 >>> 1 >>> 0] = SDL.audio.format;
              HEAP8[obtained + 6 >>> 0 >>> 0] = SDL.audio.channels;
              HEAP8[obtained + 7 >>> 0 >>> 0] = SDL.audio.silence;
              HEAP16[obtained + 8 >>> 1 >>> 0] = SDL.audio.samples;
              HEAPU32[obtained + 16 >>> 2 >>> 0] = SDL.audio.callback;
              HEAPU32[obtained + 20 >>> 2 >>> 0] = SDL.audio.userdata;
            }
            SDL.allocateChannels(32);
          } catch (e) {
            err(`Initializing SDL audio threw an exception: "${e.toString()}"! Continuing without audio`);
            SDL.audio = null;
            SDL.allocateChannels(0);
            if (obtained) {
              HEAP32[obtained >>> 2 >>> 0] = 0;
              HEAP16[obtained + 4 >>> 1 >>> 0] = 0;
              HEAP8[obtained + 6 >>> 0 >>> 0] = 0;
              HEAP8[obtained + 7 >>> 0 >>> 0] = 0;
              HEAP16[obtained + 8 >>> 1 >>> 0] = 0;
              HEAPU32[obtained + 16 >>> 2 >>> 0] = 0;
              HEAPU32[obtained + 20 >>> 2 >>> 0] = 0;
            }
          }
          if (!SDL.audio) {
            return -1;
          }
          return 0;
        }
        _SDL_OpenAudio.sig = "ipp";
        var _SDL_PauseAudio = (pauseOn) => {
          if (!SDL.audio) {
            return;
          }
          if (pauseOn) {
            if (SDL.audio.timer !== void 0) {
              clearTimeout(SDL.audio.timer);
              SDL.audio.numAudioTimersPending = 0;
              SDL.audio.timer = void 0;
            }
          } else if (!SDL.audio.timer) {
            SDL.audio.numAudioTimersPending = 1;
            SDL.audio.timer = safeSetTimeout(SDL.audio.caller, 1);
          }
          SDL.audio.paused = pauseOn;
        };
        _SDL_PauseAudio.sig = "vi";
        var _SDL_CloseAudio = () => {
          if (SDL.audio) {
            if (SDL.audio.callbackRemover) {
              SDL.audio.callbackRemover();
              SDL.audio.callbackRemover = null;
            }
            _SDL_PauseAudio(1);
            _free(SDL.audio.buffer);
            SDL.audio = null;
            SDL.allocateChannels(0);
          }
        };
        _SDL_CloseAudio.sig = "v";
        var _SDL_LockAudio = () => {
        };
        _SDL_LockAudio.sig = "v";
        var _SDL_UnlockAudio = () => {
        };
        _SDL_UnlockAudio.sig = "v";
        function _SDL_CreateMutex() {
          return 0;
        }
        _SDL_CreateMutex.sig = "p";
        function _SDL_mutexP(mutex) {
          mutex >>>= 0;
          return 0;
        }
        _SDL_mutexP.sig = "ip";
        function _SDL_mutexV(mutex) {
          mutex >>>= 0;
          return 0;
        }
        _SDL_mutexV.sig = "ip";
        function _SDL_DestroyMutex(mutex) {
          mutex >>>= 0;
        }
        _SDL_DestroyMutex.sig = "vp";
        function _SDL_CreateCond() {
          return 0;
        }
        _SDL_CreateCond.sig = "p";
        function _SDL_CondSignal(cond) {
          cond >>>= 0;
        }
        _SDL_CondSignal.sig = "ip";
        function _SDL_CondWait(cond, mutex) {
          cond >>>= 0;
          mutex >>>= 0;
        }
        _SDL_CondWait.sig = "ipp";
        function _SDL_DestroyCond(cond) {
          cond >>>= 0;
        }
        _SDL_DestroyCond.sig = "vp";
        var _SDL_StartTextInput = () => {
          SDL.textInput = true;
        };
        _SDL_StartTextInput.sig = "v";
        var _SDL_StopTextInput = () => {
          SDL.textInput = false;
        };
        _SDL_StopTextInput.sig = "v";
        var _Mix_Init = (flags2) => {
          if (!flags2)
            return 0;
          return 8;
        };
        _Mix_Init.sig = "ii";
        var _Mix_Quit = () => {
        };
        _Mix_Quit.sig = "v";
        var _Mix_OpenAudio = (frequency, format, channels, chunksize) => {
          SDL.openAudioContext();
          autoResumeAudioContext(SDL.audioContext);
          SDL.allocateChannels(32);
          SDL.mixerFrequency = frequency;
          SDL.mixerFormat = format;
          SDL.mixerNumChannels = channels;
          SDL.mixerChunkSize = chunksize;
          return 0;
        };
        _Mix_OpenAudio.sig = "iiiii";
        var _Mix_CloseAudio = _SDL_CloseAudio;
        _Mix_CloseAudio.sig = "v";
        var _Mix_AllocateChannels = (num) => {
          SDL.allocateChannels(num);
          return num;
        };
        _Mix_AllocateChannels.sig = "ii";
        function _Mix_ChannelFinished(func2) {
          func2 >>>= 0;
          SDL.channelFinished = func2;
        }
        _Mix_ChannelFinished.sig = "vp";
        var _Mix_Volume = (channel, volume) => {
          if (channel == -1) {
            for (var i2 = 0; i2 < SDL.numChannels - 1; i2++) {
              _Mix_Volume(i2, volume);
            }
            return _Mix_Volume(SDL.numChannels - 1, volume);
          }
          return SDL.setGetVolume(SDL.channels[channel], volume);
        };
        _Mix_Volume.sig = "iii";
        var _Mix_SetPanning = (channel, left, right) => {
          left /= 255;
          right /= 255;
          SDL.setPannerPosition(SDL.channels[channel], right - left, 0, 0.1);
          return 1;
        };
        _Mix_SetPanning.sig = "iiii";
        function _Mix_LoadWAV_RW(rwopsID, freesrc) {
          rwopsID >>>= 0;
          var rwops = SDL.rwops[rwopsID];
          if (rwops === void 0)
            return 0;
          var filename = "";
          var audio;
          var webAudio;
          var bytes;
          if (rwops.filename !== void 0) {
            filename = PATH_FS.resolve(rwops.filename);
            var raw = preloadedAudios[filename];
            if (!raw) {
              if (raw === null)
                err("Trying to reuse preloaded audio, but freePreloadedMediaOnUse is set!");
              if (!Module.noAudioDecoding)
                warnOnce("Cannot find preloaded audio " + filename);
              try {
                bytes = FS.readFile(filename);
              } catch (e) {
                err(`Couldn't find file for: ${filename}`);
                return 0;
              }
            }
            if (Module["freePreloadedMediaOnUse"]) {
              preloadedAudios[filename] = null;
            }
            audio = raw;
          } else if (rwops.bytes !== void 0) {
            if (SDL.webAudioAvailable())
              bytes = HEAPU8.buffer.slice(rwops.bytes, rwops.bytes + rwops.count);
            else
              bytes = HEAPU8.subarray(rwops.bytes >>> 0, rwops.bytes + rwops.count >>> 0);
          } else {
            return 0;
          }
          var arrayBuffer = bytes ? bytes.buffer || bytes : bytes;
          var canPlayWithWebAudio = Module["SDL_canPlayWithWebAudio"] === void 0 || Module["SDL_canPlayWithWebAudio"](filename, arrayBuffer);
          if (bytes !== void 0 && SDL.webAudioAvailable() && canPlayWithWebAudio) {
            audio = void 0;
            webAudio = {};
            webAudio.onDecodeComplete = [];
            var onDecodeComplete = (data2) => {
              webAudio.decodedBuffer = data2;
              webAudio.onDecodeComplete.forEach((e) => e());
              webAudio.onDecodeComplete = void 0;
            };
            SDL.audioContext["decodeAudioData"](arrayBuffer, onDecodeComplete);
          } else if (audio === void 0 && bytes) {
            var blob = new Blob([bytes], {
              type: rwops.mimetype
            });
            var url2 = URL.createObjectURL(blob);
            audio = new Audio();
            audio.src = url2;
            audio.mozAudioChannelType = "content";
          }
          var id = SDL.audios.length;
          SDL.audios.push({
            source: filename,
            audio,
            webAudio
          });
          return id;
        }
        _Mix_LoadWAV_RW.sig = "ppi";
        function _Mix_LoadWAV(filename) {
          filename >>>= 0;
          var rwops = _SDL_RWFromFile(filename, 0);
          var result = _Mix_LoadWAV_RW(rwops, 0);
          _SDL_FreeRW(rwops);
          return result;
        }
        _Mix_LoadWAV.sig = "pp";
        function _Mix_QuickLoad_RAW(mem, len2) {
          mem >>>= 0;
          var audio;
          var webAudio;
          var numSamples = len2 >> 1;
          var buffer = new Float32Array(numSamples);
          for (var i2 = 0; i2 < numSamples; ++i2) {
            buffer[i2] = HEAP16[mem + i2 * 2 >>> 1 >>> 0] / 32768;
          }
          if (SDL.webAudioAvailable()) {
            webAudio = {};
            webAudio.decodedBuffer = buffer;
          } else {
            audio = new Audio();
            audio.mozAudioChannelType = "content";
            audio.numChannels = SDL.mixerNumChannels;
            audio.frequency = SDL.mixerFrequency;
          }
          var id = SDL.audios.length;
          SDL.audios.push({
            source: "",
            audio,
            webAudio,
            buffer
          });
          return id;
        }
        _Mix_QuickLoad_RAW.sig = "ppi";
        function _Mix_FreeChunk(id) {
          id >>>= 0;
          SDL.audios[id] = null;
        }
        _Mix_FreeChunk.sig = "vp";
        var _Mix_ReserveChannels = (num) => {
          SDL.channelMinimumNumber = num;
        };
        _Mix_ReserveChannels.sig = "ii";
        function _Mix_PlayChannelTimed(channel, id, loops, ticks) {
          id >>>= 0;
          assert(ticks == -1);
          var info2 = SDL.audios[id];
          if (!info2)
            return -1;
          if (!info2.audio && !info2.webAudio)
            return -1;
          if (channel == -1) {
            for (var i2 = SDL.channelMinimumNumber; i2 < SDL.numChannels; i2++) {
              if (!SDL.channels[i2].audio) {
                channel = i2;
                break;
              }
            }
            if (channel == -1) {
              err(`All ${SDL.numChannels}  channels in use!`);
              return -1;
            }
          }
          var channelInfo = SDL.channels[channel];
          var audio;
          if (info2.webAudio) {
            audio = {};
            audio.resource = info2;
            audio.paused = false;
            audio.currentPosition = 0;
            audio.play = function() {
              SDL.playWebAudio(this);
            };
            audio.pause = function() {
              SDL.pauseWebAudio(this);
            };
          } else {
            audio = info2.audio.cloneNode(true);
            audio.numChannels = info2.audio.numChannels;
            audio.frequency = info2.audio.frequency;
          }
          audio["onended"] = function() {
            if (channelInfo.audio == this) {
              channelInfo.audio.paused = true;
              channelInfo.audio = null;
            }
            if (SDL.channelFinished)
              getWasmTableEntry(SDL.channelFinished)(channel);
          };
          channelInfo.audio = audio;
          audio.loop = loops != 0;
          audio.volume = channelInfo.volume;
          audio.play();
          return channel;
        }
        _Mix_PlayChannelTimed.sig = "iipii";
        var _Mix_FadingChannel = (channel) => 0;
        _Mix_FadingChannel.sig = "ii";
        var _Mix_HaltChannel = (channel) => {
          function halt(channel2) {
            var info2 = SDL.channels[channel2];
            if (info2.audio) {
              info2.audio.pause();
              info2.audio = null;
            }
            if (SDL.channelFinished) {
              getWasmTableEntry(SDL.channelFinished)(channel2);
            }
          }
          if (channel != -1) {
            halt(channel);
          } else {
            for (var i2 = 0; i2 < SDL.channels.length; ++i2)
              halt(i2);
          }
          return 0;
        };
        _Mix_HaltChannel.sig = "ii";
        var _Mix_HaltMusic = () => {
          var audio = SDL.music.audio;
          if (audio) {
            audio.src = audio.src;
            audio.currentPosition = 0;
            audio.pause();
          }
          SDL.music.audio = null;
          if (SDL.hookMusicFinished) {
            getWasmTableEntry(SDL.hookMusicFinished)();
          }
          return 0;
        };
        _Mix_HaltMusic.sig = "i";
        function _Mix_HookMusicFinished(func2) {
          func2 >>>= 0;
          SDL.hookMusicFinished = func2;
          if (SDL.music.audio) {
            SDL.music.audio["onended"] = _Mix_HaltMusic;
          }
        }
        _Mix_HookMusicFinished.sig = "vp";
        var _Mix_VolumeMusic = (volume) => SDL.setGetVolume(SDL.music, volume);
        _Mix_VolumeMusic.sig = "ii";
        var _Mix_LoadMUS_RW = _Mix_LoadWAV_RW;
        _Mix_LoadMUS_RW.sig = "pp";
        function _Mix_LoadMUS(filename) {
          filename >>>= 0;
          var rwops = _SDL_RWFromFile(filename, 0);
          var result = _Mix_LoadMUS_RW(rwops, 0);
          _SDL_FreeRW(rwops);
          return result;
        }
        _Mix_LoadMUS.sig = "pp";
        var _Mix_FreeMusic = _Mix_FreeChunk;
        _Mix_FreeMusic.sig = "vp";
        function _Mix_PlayMusic(id, loops) {
          id >>>= 0;
          if (SDL.music.audio) {
            if (!SDL.music.audio.paused)
              err(`Music is already playing. ${SDL.music.source}`);
            SDL.music.audio.pause();
          }
          var info2 = SDL.audios[id];
          var audio;
          if (info2.webAudio) {
            audio = {};
            audio.resource = info2;
            audio.paused = false;
            audio.currentPosition = 0;
            audio.play = function() {
              SDL.playWebAudio(this);
            };
            audio.pause = function() {
              SDL.pauseWebAudio(this);
            };
          } else if (info2.audio) {
            audio = info2.audio;
          }
          audio["onended"] = function() {
            if (SDL.music.audio == this)
              _Mix_HaltMusic();
          };
          audio.loop = loops != 0 && loops != 1;
          audio.volume = SDL.music.volume;
          SDL.music.audio = audio;
          audio.play();
          return 0;
        }
        _Mix_PlayMusic.sig = "ipi";
        var _Mix_PauseMusic = () => {
          var audio = SDL.music.audio;
          audio == null ? void 0 : audio.pause();
        };
        _Mix_PauseMusic.sig = "v";
        var _Mix_ResumeMusic = () => {
          var audio = SDL.music.audio;
          audio == null ? void 0 : audio.play();
        };
        _Mix_ResumeMusic.sig = "v";
        var _Mix_FadeInMusicPos = _Mix_PlayMusic;
        _Mix_FadeInMusicPos.sig = "ipiid";
        var _Mix_FadeOutMusic = _Mix_HaltMusic;
        _Mix_FadeOutMusic.sig = "ii";
        var _Mix_PlayingMusic = () => SDL.music.audio && !SDL.music.audio.paused ? 1 : 0;
        _Mix_PlayingMusic.sig = "i";
        var _Mix_Playing = (channel) => {
          if (channel === -1) {
            var count = 0;
            for (var i2 = 0; i2 < SDL.channels.length; i2++) {
              count += _Mix_Playing(i2);
            }
            return count;
          }
          var info2 = SDL.channels[channel];
          if ((info2 == null ? void 0 : info2.audio) && !info2.audio.paused) {
            return 1;
          }
          return 0;
        };
        _Mix_Playing.sig = "ii";
        var _Mix_Pause = (channel) => {
          if (channel === -1) {
            for (var i2 = 0; i2 < SDL.channels.length; i2++) {
              _Mix_Pause(i2);
            }
            return;
          }
          var info2 = SDL.channels[channel];
          if (info2 == null ? void 0 : info2.audio) {
            info2.audio.pause();
          } else {
          }
        };
        _Mix_Pause.sig = "vi";
        var _Mix_Paused = (channel) => {
          var _a;
          if (channel === -1) {
            var pausedCount = 0;
            for (var i2 = 0; i2 < SDL.channels.length; i2++) {
              pausedCount += _Mix_Paused(i2);
            }
            return pausedCount;
          }
          var info2 = SDL.channels[channel];
          if ((_a = info2 == null ? void 0 : info2.audio) == null ? void 0 : _a.paused) {
            return 1;
          }
          return 0;
        };
        _Mix_Paused.sig = "ii";
        var _Mix_PausedMusic = () => {
          var _a;
          return ((_a = SDL.music.audio) == null ? void 0 : _a.paused) ? 1 : 0;
        };
        _Mix_PausedMusic.sig = "i";
        var _Mix_Resume = (channel) => {
          if (channel === -1) {
            for (var i2 = 0; i2 < SDL.channels.length; i2++) {
              _Mix_Resume(i2);
            }
            return;
          }
          var info2 = SDL.channels[channel];
          if (info2 == null ? void 0 : info2.audio)
            info2.audio.play();
        };
        _Mix_Resume.sig = "vi";
        var _TTF_Init = () => {
          try {
            var offscreenCanvas = new OffscreenCanvas(0, 0);
            SDL.ttfContext = offscreenCanvas.getContext("2d");
            if (typeof SDL.ttfContext.measureText != "function") {
              throw "bad context";
            }
          } catch (ex) {
            var canvas = document.createElement("canvas");
            SDL.ttfContext = canvas.getContext("2d");
          }
          return 0;
        };
        _TTF_Init.sig = "i";
        function _TTF_OpenFont(name2, size) {
          name2 >>>= 0;
          name2 = PATH.normalize(UTF8ToString(name2));
          var id = SDL.fonts.length;
          SDL.fonts.push({
            name: name2,
            size
          });
          return id;
        }
        _TTF_OpenFont.sig = "ppi";
        function _TTF_CloseFont(font) {
          font >>>= 0;
          SDL.fonts[font] = null;
        }
        _TTF_CloseFont.sig = "vp";
        function _TTF_RenderText_Solid(font, text, color) {
          font >>>= 0;
          text >>>= 0;
          color >>>= 0;
          text = UTF8ToString(text) || " ";
          var fontData = SDL.fonts[font];
          var w = SDL.estimateTextWidth(fontData, text);
          var h = fontData.size;
          color = SDL.loadColorToCSSRGB(color);
          var fontString = SDL.makeFontString(h, fontData.name);
          var surf = SDL.makeSurface(w, h, 0, false, "text:" + text);
          var surfData = SDL.surfaces[surf];
          surfData.ctx.save();
          surfData.ctx.fillStyle = color;
          surfData.ctx.font = fontString;
          surfData.ctx.textBaseline = "bottom";
          surfData.ctx.fillText(text, 0, h | 0);
          surfData.ctx.restore();
          return surf;
        }
        _TTF_RenderText_Solid.sig = "pppp";
        var _TTF_RenderText_Blended = _TTF_RenderText_Solid;
        _TTF_RenderText_Blended.sig = "pppp";
        var _TTF_RenderText_Shaded = _TTF_RenderText_Solid;
        _TTF_RenderText_Shaded.sig = "ppppp";
        var _TTF_RenderUTF8_Solid = _TTF_RenderText_Solid;
        _TTF_RenderUTF8_Solid.sig = "pppp";
        function _TTF_SizeText(font, text, w, h) {
          font >>>= 0;
          text >>>= 0;
          w >>>= 0;
          h >>>= 0;
          var fontData = SDL.fonts[font];
          if (w) {
            HEAP32[w >>> 2 >>> 0] = SDL.estimateTextWidth(fontData, UTF8ToString(text));
          }
          if (h) {
            HEAP32[h >>> 2 >>> 0] = fontData.size;
          }
          return 0;
        }
        _TTF_SizeText.sig = "ipppp";
        var _TTF_SizeUTF8 = _TTF_SizeText;
        _TTF_SizeUTF8.sig = "ipppp";
        function _TTF_GlyphMetrics(font, ch, minx, maxx, miny, maxy, advance) {
          font >>>= 0;
          minx >>>= 0;
          maxx >>>= 0;
          miny >>>= 0;
          maxy >>>= 0;
          advance >>>= 0;
          var fontData = SDL.fonts[font];
          var width = SDL.estimateTextWidth(fontData, String.fromCharCode(ch));
          if (advance) {
            HEAP32[advance >>> 2 >>> 0] = width;
          }
          if (minx) {
            HEAP32[minx >>> 2 >>> 0] = 0;
          }
          if (maxx) {
            HEAP32[maxx >>> 2 >>> 0] = width;
          }
          if (miny) {
            HEAP32[miny >>> 2 >>> 0] = 0;
          }
          if (maxy) {
            HEAP32[maxy >>> 2 >>> 0] = fontData.size;
          }
        }
        _TTF_GlyphMetrics.sig = "ipippppp";
        function _TTF_FontAscent(font) {
          font >>>= 0;
          var fontData = SDL.fonts[font];
          return fontData.size * 0.98 | 0;
        }
        _TTF_FontAscent.sig = "ip";
        function _TTF_FontDescent(font) {
          font >>>= 0;
          var fontData = SDL.fonts[font];
          return fontData.size * 0.02 | 0;
        }
        _TTF_FontDescent.sig = "ip";
        function _TTF_FontHeight(font) {
          font >>>= 0;
          var fontData = SDL.fonts[font];
          return fontData.size;
        }
        _TTF_FontHeight.sig = "ip";
        var _TTF_FontLineSkip = _TTF_FontHeight;
        _TTF_FontLineSkip.sig = "ip";
        var _TTF_Quit = () => out("TTF_Quit called (and ignored)");
        _TTF_Quit.sig = "v";
        var SDL_gfx = {
          drawRectangle: (surf, x1, y1, x2, y2, action, cssColor) => {
            x1 = x1 << 16 >> 16;
            y1 = y1 << 16 >> 16;
            x2 = x2 << 16 >> 16;
            y2 = y2 << 16 >> 16;
            var surfData = SDL.surfaces[surf];
            assert(!surfData.locked);
            var x = x1 < x2 ? x1 : x2;
            var y = y1 < y2 ? y1 : y2;
            var w = Math.abs(x2 - x1);
            var h = Math.abs(y2 - y1);
            surfData.ctx.save();
            surfData.ctx[action + "Style"] = cssColor;
            surfData.ctx[action + "Rect"](x, y, w, h);
            surfData.ctx.restore();
          },
          drawLine: (surf, x1, y1, x2, y2, cssColor) => {
            x1 = x1 << 16 >> 16;
            y1 = y1 << 16 >> 16;
            x2 = x2 << 16 >> 16;
            y2 = y2 << 16 >> 16;
            var surfData = SDL.surfaces[surf];
            assert(!surfData.locked);
            surfData.ctx.save();
            surfData.ctx.strokeStyle = cssColor;
            surfData.ctx.beginPath();
            surfData.ctx.moveTo(x1, y1);
            surfData.ctx.lineTo(x2, y2);
            surfData.ctx.stroke();
            surfData.ctx.restore();
          },
          drawEllipse: (surf, x, y, rx, ry, action, cssColor) => {
            x = x << 16 >> 16;
            y = y << 16 >> 16;
            rx = rx << 16 >> 16;
            ry = ry << 16 >> 16;
            var surfData = SDL.surfaces[surf];
            assert(!surfData.locked);
            surfData.ctx.save();
            surfData.ctx.beginPath();
            surfData.ctx.translate(x, y);
            surfData.ctx.scale(rx, ry);
            surfData.ctx.arc(0, 0, 1, 0, 2 * Math.PI);
            surfData.ctx.restore();
            surfData.ctx.save();
            surfData.ctx[action + "Style"] = cssColor;
            surfData.ctx[action]();
            surfData.ctx.restore();
          },
          translateColorToCSSRGBA: (rgba) => `rgba(${rgba >>> 24},${rgba >> 16 & 255},${rgba >> 8 & 255},${rgba & 255})`
        };
        function _boxColor(surf, x1, y1, x2, y2, color) {
          surf >>>= 0;
          return SDL_gfx.drawRectangle(surf, x1, y1, x2, y2, "fill", SDL_gfx.translateColorToCSSRGBA(color));
        }
        _boxColor.sig = "ipiiiii";
        function _boxRGBA(surf, x1, y1, x2, y2, r, g, b, a) {
          surf >>>= 0;
          return SDL_gfx.drawRectangle(surf, x1, y1, x2, y2, "fill", SDL.translateRGBAToCSSRGBA(r, g, b, a));
        }
        _boxRGBA.sig = "ipiiiiiiii";
        function _rectangleColor(surf, x1, y1, x2, y2, color) {
          surf >>>= 0;
          return SDL_gfx.drawRectangle(surf, x1, y1, x2, y2, "stroke", SDL_gfx.translateColorToCSSRGBA(color));
        }
        _rectangleColor.sig = "ipiiiii";
        function _rectangleRGBA(surf, x1, y1, x2, y2, r, g, b, a) {
          surf >>>= 0;
          return SDL_gfx.drawRectangle(surf, x1, y1, x2, y2, "stroke", SDL.translateRGBAToCSSRGBA(r, g, b, a));
        }
        _rectangleRGBA.sig = "ipiiiiiiii";
        function _ellipseColor(surf, x, y, rx, ry, color) {
          surf >>>= 0;
          return SDL_gfx.drawEllipse(surf, x, y, rx, ry, "stroke", SDL_gfx.translateColorToCSSRGBA(color));
        }
        _ellipseColor.sig = "ipiiiii";
        function _ellipseRGBA(surf, x, y, rx, ry, r, g, b, a) {
          surf >>>= 0;
          return SDL_gfx.drawEllipse(surf, x, y, rx, ry, "stroke", SDL.translateRGBAToCSSRGBA(r, g, b, a));
        }
        _ellipseRGBA.sig = "ipiiiiiiii";
        function _filledEllipseColor(surf, x, y, rx, ry, color) {
          surf >>>= 0;
          return SDL_gfx.drawEllipse(surf, x, y, rx, ry, "fill", SDL_gfx.translateColorToCSSRGBA(color));
        }
        _filledEllipseColor.sig = "ipiiiii";
        function _filledEllipseRGBA(surf, x, y, rx, ry, r, g, b, a) {
          surf >>>= 0;
          return SDL_gfx.drawEllipse(surf, x, y, rx, ry, "fill", SDL.translateRGBAToCSSRGBA(r, g, b, a));
        }
        _filledEllipseRGBA.sig = "ipiiiiiiii";
        function _lineColor(surf, x1, y1, x2, y2, color) {
          surf >>>= 0;
          return SDL_gfx.drawLine(surf, x1, y1, x2, y2, SDL_gfx.translateColorToCSSRGBA(color));
        }
        _lineColor.sig = "ipiiiii";
        function _lineRGBA(surf, x1, y1, x2, y2, r, g, b, a) {
          surf >>>= 0;
          return SDL_gfx.drawLine(surf, x1, y1, x2, y2, SDL.translateRGBAToCSSRGBA(r, g, b, a));
        }
        _lineRGBA.sig = "ipiiiiiiii";
        function _pixelRGBA(surf, x1, y1, r, g, b, a) {
          surf >>>= 0;
          return _boxRGBA(surf, x1, y1, x1, y1, r, g, b, a);
        }
        _pixelRGBA.sig = "ipiiiiii";
        var _SDL_GL_SetAttribute = (attr, value) => {
          if (!(attr in SDL.glAttributes)) {
            abort("Unknown SDL GL attribute (" + attr + "). Please check if your SDL version is supported.");
          }
          SDL.glAttributes[attr] = value;
        };
        _SDL_GL_SetAttribute.sig = "iii";
        function _SDL_GL_GetAttribute(attr, value) {
          value >>>= 0;
          if (!(attr in SDL.glAttributes)) {
            abort("Unknown SDL GL attribute (" + attr + "). Please check if your SDL version is supported.");
          }
          if (value)
            HEAP32[value >>> 2 >>> 0] = SDL.glAttributes[attr];
          return 0;
        }
        _SDL_GL_GetAttribute.sig = "iip";
        var _SDL_GL_SwapBuffers = () => {
          var _a;
          (_a = Browser.doSwapBuffers) == null ? void 0 : _a.call(Browser);
        };
        _SDL_GL_SwapBuffers.sig = "v";
        function _SDL_GL_ExtensionSupported(extension) {
          extension >>>= 0;
          return Module.ctx.getExtension(extension) | 0;
        }
        _SDL_GL_ExtensionSupported.sig = "ip";
        function _SDL_DestroyWindow(window2) {
          window2 >>>= 0;
        }
        _SDL_DestroyWindow.sig = "vp";
        function _SDL_DestroyRenderer(renderer) {
          renderer >>>= 0;
        }
        _SDL_DestroyRenderer.sig = "vp";
        function _SDL_GetWindowFlags(window2) {
          window2 >>>= 0;
          if (Browser.isFullscreen) {
            return 1;
          }
          return 0;
        }
        _SDL_GetWindowFlags.sig = "ip";
        function _SDL_GL_SwapWindow(window2) {
          window2 >>>= 0;
        }
        _SDL_GL_SwapWindow.sig = "vp";
        function _SDL_GL_MakeCurrent(window2, context) {
          window2 >>>= 0;
          context >>>= 0;
        }
        _SDL_GL_MakeCurrent.sig = "ipp";
        function _SDL_GL_DeleteContext(context) {
          context >>>= 0;
        }
        _SDL_GL_DeleteContext.sig = "vp";
        var _SDL_GL_GetSwapInterval = () => {
          if (Browser.mainLoop.timingMode == 1)
            return Browser.mainLoop.timingValue;
          else
            return 0;
        };
        _SDL_GL_GetSwapInterval.sig = "i";
        var _SDL_GL_SetSwapInterval = (state) => {
          _emscripten_set_main_loop_timing(1, state);
        };
        _SDL_GL_SetSwapInterval.sig = "ii";
        function _SDL_SetWindowTitle(window2, title) {
          window2 >>>= 0;
          title >>>= 0;
          if (title)
            document.title = UTF8ToString(title);
        }
        _SDL_SetWindowTitle.sig = "vpp";
        function _SDL_GetWindowSize(window2, width, height) {
          window2 >>>= 0;
          width >>>= 0;
          height >>>= 0;
          var w = Module["canvas"].width;
          var h = Module["canvas"].height;
          if (width)
            HEAP32[width >>> 2 >>> 0] = w;
          if (height)
            HEAP32[height >>> 2 >>> 0] = h;
        }
        _SDL_GetWindowSize.sig = "vppp";
        function _SDL_LogSetOutputFunction(callback, userdata) {
          callback >>>= 0;
          userdata >>>= 0;
        }
        _SDL_LogSetOutputFunction.sig = "vpp";
        function _SDL_SetWindowFullscreen(window2, fullscreen) {
          window2 >>>= 0;
          if (Browser.isFullscreen) {
            Module["canvas"].exitFullscreen();
            return 1;
          }
          return 0;
        }
        _SDL_SetWindowFullscreen.sig = "ipi";
        var _SDL_ClearError = () => {
        };
        _SDL_ClearError.sig = "v";
        var _SDL_SetGamma = (r, g, b) => -1;
        _SDL_SetGamma.sig = "ifff";
        function _SDL_SetGammaRamp(redTable, greenTable, blueTable) {
          redTable >>>= 0;
          greenTable >>>= 0;
          blueTable >>>= 0;
          return -1;
        }
        _SDL_SetGammaRamp.sig = "ippp";
        var _SDL_NumJoysticks = () => {
          var count = 0;
          var gamepads = SDL.getGamepads();
          for (var i2 = 0; i2 < gamepads.length; i2++) {
            if (gamepads[i2] !== void 0)
              count++;
          }
          return count;
        };
        _SDL_NumJoysticks.sig = "i";
        function _SDL_JoystickName(deviceIndex) {
          var gamepad = SDL.getGamepad(deviceIndex);
          if (gamepad) {
            var name2 = gamepad.id;
            if (SDL.joystickNamePool.hasOwnProperty(name2)) {
              return SDL.joystickNamePool[name2];
            }
            return SDL.joystickNamePool[name2] = stringToNewUTF8(name2);
          }
          return 0;
        }
        _SDL_JoystickName.sig = "pi";
        function _SDL_JoystickOpen(deviceIndex) {
          var gamepad = SDL.getGamepad(deviceIndex);
          if (gamepad) {
            var joystick = deviceIndex + 1;
            SDL.recordJoystickState(joystick, gamepad);
            return joystick;
          }
          return 0;
        }
        _SDL_JoystickOpen.sig = "pi";
        var _SDL_JoystickOpened = (deviceIndex) => SDL.lastJoystickState.hasOwnProperty(deviceIndex + 1) ? 1 : 0;
        _SDL_JoystickOpened.sig = "ii";
        function _SDL_JoystickIndex(joystick) {
          joystick >>>= 0;
          return joystick - 1;
        }
        _SDL_JoystickIndex.sig = "ip";
        function _SDL_JoystickNumAxes(joystick) {
          joystick >>>= 0;
          var gamepad = SDL.getGamepad(joystick - 1);
          if (gamepad) {
            return gamepad.axes.length;
          }
          return 0;
        }
        _SDL_JoystickNumAxes.sig = "ip";
        function _SDL_JoystickNumBalls(joystick) {
          joystick >>>= 0;
          return 0;
        }
        _SDL_JoystickNumBalls.sig = "ip";
        function _SDL_JoystickNumHats(joystick) {
          joystick >>>= 0;
          return 0;
        }
        _SDL_JoystickNumHats.sig = "ip";
        function _SDL_JoystickNumButtons(joystick) {
          joystick >>>= 0;
          var gamepad = SDL.getGamepad(joystick - 1);
          if (gamepad) {
            return gamepad.buttons.length;
          }
          return 0;
        }
        _SDL_JoystickNumButtons.sig = "ip";
        var _SDL_JoystickUpdate = () => SDL.queryJoysticks();
        _SDL_JoystickUpdate.sig = "v";
        var _SDL_JoystickEventState = (state) => {
          if (state < 0) {
            return SDL.joystickEventState;
          }
          return SDL.joystickEventState = state;
        };
        _SDL_JoystickEventState.sig = "ii";
        function _SDL_JoystickGetAxis(joystick, axis) {
          joystick >>>= 0;
          var gamepad = SDL.getGamepad(joystick - 1);
          if (gamepad && gamepad.axes.length > axis) {
            return SDL.joystickAxisValueConversion(gamepad.axes[axis]);
          }
          return 0;
        }
        _SDL_JoystickGetAxis.sig = "ipi";
        function _SDL_JoystickGetHat(joystick, hat) {
          joystick >>>= 0;
          return 0;
        }
        _SDL_JoystickGetHat.sig = "ipi";
        function _SDL_JoystickGetBall(joystick, ball, dxptr, dyptr) {
          joystick >>>= 0;
          dxptr >>>= 0;
          dyptr >>>= 0;
          return -1;
        }
        _SDL_JoystickGetBall.sig = "ipipp";
        function _SDL_JoystickGetButton(joystick, button) {
          joystick >>>= 0;
          var gamepad = SDL.getGamepad(joystick - 1);
          if (gamepad && gamepad.buttons.length > button) {
            return SDL.getJoystickButtonState(gamepad.buttons[button]) ? 1 : 0;
          }
          return 0;
        }
        _SDL_JoystickGetButton.sig = "ipi";
        function _SDL_JoystickClose(joystick) {
          joystick >>>= 0;
          delete SDL.lastJoystickState[joystick];
        }
        _SDL_JoystickClose.sig = "vp";
        var _SDL_InitSubSystem = (flags2) => 0;
        _SDL_InitSubSystem.sig = "ii";
        function _SDL_RWFromConstMem(mem, size) {
          mem >>>= 0;
          var id = SDL.rwops.length;
          SDL.rwops.push({
            bytes: mem,
            count: size
          });
          return id;
        }
        _SDL_RWFromConstMem.sig = "ppi";
        var _SDL_RWFromMem = _SDL_RWFromConstMem;
        _SDL_RWFromMem.sig = "ppi";
        var _SDL_GetNumAudioDrivers = () => 1;
        _SDL_GetNumAudioDrivers.sig = "i";
        function _SDL_GetCurrentAudioDriver() {
          return stringToNewUTF8("Emscripten Audio");
        }
        _SDL_GetCurrentAudioDriver.sig = "p";
        var _SDL_GetScancodeFromKey = (key) => SDL.scanCodes[key];
        _SDL_GetScancodeFromKey.sig = "ii";
        function _SDL_GetAudioDriver(index) {
          return _SDL_GetCurrentAudioDriver();
        }
        _SDL_GetAudioDriver.sig = "pi";
        var _SDL_EnableUNICODE = (on) => {
          var ret = SDL.unicode || 0;
          SDL.unicode = on;
          return ret;
        };
        _SDL_EnableUNICODE.sig = "ii";
        var _SDL_AddTimer = function(interval, callback, param) {
          callback >>>= 0;
          param >>>= 0;
          return safeSetTimeout(() => getWasmTableEntry(callback)(interval, param), interval);
        };
        _SDL_AddTimer.sig = "iipp";
        var _SDL_RemoveTimer = (id) => {
          clearTimeout(id);
          return true;
        };
        _SDL_RemoveTimer.sig = "ii";
        function _SDL_CreateThread(fs5, data2, pfnBeginThread, pfnEndThread) {
          fs5 >>>= 0;
          data2 >>>= 0;
          throw "SDL threads cannot be supported in the web platform because they assume shared state. See emscripten_create_worker etc. for a message-passing concurrency model that does let you run code in another thread.";
        }
        _SDL_CreateThread.sig = "ppp";
        function _SDL_WaitThread(thread, status) {
          thread >>>= 0;
          status >>>= 0;
          throw "SDL_WaitThread";
        }
        _SDL_WaitThread.sig = "vpp";
        function _SDL_GetThreadID(thread) {
          thread >>>= 0;
          throw "SDL_GetThreadID";
        }
        _SDL_GetThreadID.sig = "pp";
        function _SDL_ThreadID() {
          return 0;
        }
        _SDL_ThreadID.sig = "p";
        function _SDL_AllocRW() {
          throw "SDL_AllocRW: TODO";
        }
        _SDL_AllocRW.sig = "p";
        function _SDL_CondBroadcast(cond) {
          cond >>>= 0;
          throw "SDL_CondBroadcast: TODO";
        }
        _SDL_CondBroadcast.sig = "ip";
        function _SDL_CondWaitTimeout(cond, mutex, ms) {
          cond >>>= 0;
          mutex >>>= 0;
          throw "SDL_CondWaitTimeout: TODO";
        }
        _SDL_CondWaitTimeout.sig = "ippi";
        var _SDL_WM_IconifyWindow = () => {
          throw "SDL_WM_IconifyWindow TODO";
        };
        _SDL_WM_IconifyWindow.sig = "i";
        function _Mix_SetPostMix(func2, arg) {
          func2 >>>= 0;
          arg >>>= 0;
          return warnOnce("Mix_SetPostMix: TODO");
        }
        _Mix_SetPostMix.sig = "vpp";
        function _Mix_VolumeChunk(chunk, volume) {
          chunk >>>= 0;
          throw "Mix_VolumeChunk: TODO";
        }
        _Mix_VolumeChunk.sig = "ipi";
        var _Mix_SetPosition = (channel, angle, distance) => {
          throw "Mix_SetPosition: TODO";
        };
        _Mix_SetPosition.sig = "iiii";
        function _Mix_QuerySpec(frequency, format, channels) {
          frequency >>>= 0;
          format >>>= 0;
          channels >>>= 0;
          throw "Mix_QuerySpec: TODO";
        }
        _Mix_QuerySpec.sig = "ippp";
        function _Mix_FadeInChannelTimed(channel, chunk, loop, ms, ticks) {
          chunk >>>= 0;
          throw "Mix_FadeInChannelTimed";
        }
        _Mix_FadeInChannelTimed.sig = "iipiii";
        var _Mix_FadeOutChannel = () => {
          throw "Mix_FadeOutChannel";
        };
        _Mix_FadeOutChannel.sig = "iii";
        function _Mix_Linked_Version() {
          throw "Mix_Linked_Version: TODO";
        }
        _Mix_Linked_Version.sig = "p";
        function _SDL_SaveBMP_RW(surface, dst, freedst) {
          surface >>>= 0;
          dst >>>= 0;
          throw "SDL_SaveBMP_RW: TODO";
        }
        _SDL_SaveBMP_RW.sig = "ippi";
        function _SDL_WM_SetIcon(icon, mask) {
          icon >>>= 0;
          mask >>>= 0;
        }
        _SDL_WM_SetIcon.sig = "vpp";
        var _SDL_HasRDTSC = () => 0;
        _SDL_HasRDTSC.sig = "i";
        var _SDL_HasMMX = () => 0;
        _SDL_HasMMX.sig = "i";
        var _SDL_HasMMXExt = () => 0;
        _SDL_HasMMXExt.sig = "i";
        var _SDL_Has3DNow = () => 0;
        _SDL_Has3DNow.sig = "i";
        var _SDL_Has3DNowExt = () => 0;
        _SDL_Has3DNowExt.sig = "i";
        var _SDL_HasSSE = () => 0;
        _SDL_HasSSE.sig = "i";
        var _SDL_HasSSE2 = () => 0;
        _SDL_HasSSE2.sig = "i";
        var _SDL_HasAltiVec = () => 0;
        _SDL_HasAltiVec.sig = "i";
        var ALLOC_NORMAL = 0;
        var ALLOC_STACK = 1;
        var allocate = (slab, allocator) => {
          var ret;
          if (allocator == ALLOC_STACK) {
            ret = stackAlloc(slab.length);
          } else {
            ret = _malloc(slab.length);
          }
          if (!slab.subarray && !slab.slice) {
            slab = new Uint8Array(slab);
          }
          HEAPU8.set(slab, ret >>> 0);
          return ret;
        };
        var writeStringToMemory = (string, buffer, dontAddNull) => {
          warnOnce("writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!");
          var lastChar, end;
          if (dontAddNull) {
            end = buffer + lengthBytesUTF8(string);
            lastChar = HEAP8[end >>> 0];
          }
          stringToUTF8(string, buffer, Infinity);
          if (dontAddNull)
            HEAP8[end >>> 0] = lastChar;
        };
        var writeAsciiToMemory = (str, buffer, dontAddNull) => {
          for (var i2 = 0; i2 < str.length; ++i2) {
            HEAP8[buffer++ >>> 0 >>> 0] = str.charCodeAt(i2);
          }
          if (!dontAddNull)
            HEAP8[buffer >>> 0 >>> 0] = 0;
        };
        var allocateUTF8 = stringToNewUTF8;
        var allocateUTF8OnStack = stringToUTF8OnStack;
        var setErrNo = (value) => {
          HEAP32[___errno_location() >>> 2 >>> 0] = value;
          return value;
        };
        var _emscripten_is_main_browser_thread = () => !ENVIRONMENT_IS_WORKER;
        var tupleRegistrations = {};
        var structRegistrations = {};
        var getTypeName = (type) => {
          var ptr2 = ___getTypeName(type);
          var rv = readLatin1String(ptr2);
          _free(ptr2);
          return rv;
        };
        var getFunctionName = (signature) => {
          signature = signature.trim();
          const argsIndex = signature.indexOf("(");
          if (argsIndex !== -1) {
            return signature.substr(0, argsIndex);
          } else {
            return signature;
          }
        };
        var getFunctionArgsName = (signature) => {
          signature = signature.trim();
          const argsIndex = signature.indexOf("(") + 1;
          if (argsIndex !== 0) {
            return signature.substr(argsIndex, signature.length - argsIndex - 1).replaceAll(" ", "").split(",").filter((n) => n.length);
          } else {
            return [];
          }
        };
        var heap32VectorToArray = (count, firstElement) => {
          var array = [];
          for (var i2 = 0; i2 < count; i2++) {
            array.push(HEAPU32[firstElement + i2 * 4 >>> 2 >>> 0]);
          }
          return array;
        };
        var requireRegisteredType = (rawType, humanName) => {
          var impl = registeredTypes[rawType];
          if (void 0 === impl) {
            throwBindingError(humanName + " has unknown type " + getTypeName(rawType));
          }
          return impl;
        };
        function usesDestructorStack(argTypes) {
          for (var i2 = 1; i2 < argTypes.length; ++i2) {
            if (argTypes[i2] !== null && argTypes[i2].destructorFunction === void 0) {
              return true;
            }
          }
          return false;
        }
        function createJsInvoker(humanName, argTypes, isClassMethodFunc, returns, isAsync) {
          var needsDestructorStack = usesDestructorStack(argTypes);
          var argCount = argTypes.length;
          var argsList = "";
          var argsListWired = "";
          for (var i2 = 0; i2 < argCount - 2; ++i2) {
            argsList += (i2 !== 0 ? ", " : "") + "arg" + i2;
            argsListWired += (i2 !== 0 ? ", " : "") + "arg" + i2 + "Wired";
          }
          var invokerFnBody = `
        return function (${argsList}) {
        if (arguments.length !== ${argCount - 2}) {
          throwBindingError('function ${humanName} called with ' + arguments.length + ' arguments, expected ${argCount - 2}');
        }`;
          if (needsDestructorStack) {
            invokerFnBody += "var destructors = [];\n";
          }
          var dtorStack = needsDestructorStack ? "destructors" : "null";
          var args1 = ["throwBindingError", "invoker", "fn", "runDestructors", "retType", "classParam"];
          if (isClassMethodFunc) {
            invokerFnBody += "var thisWired = classParam['toWireType'](" + dtorStack + ", this);\n";
          }
          for (var i2 = 0; i2 < argCount - 2; ++i2) {
            invokerFnBody += "var arg" + i2 + "Wired = argType" + i2 + "['toWireType'](" + dtorStack + ", arg" + i2 + "); // " + argTypes[i2 + 2].name + "\n";
            args1.push("argType" + i2);
          }
          if (isClassMethodFunc) {
            argsListWired = "thisWired" + (argsListWired.length > 0 ? ", " : "") + argsListWired;
          }
          invokerFnBody += (returns || isAsync ? "var rv = " : "") + "invoker(fn" + (argsListWired.length > 0 ? ", " : "") + argsListWired + ");\n";
          if (needsDestructorStack) {
            invokerFnBody += "runDestructors(destructors);\n";
          } else {
            for (var i2 = isClassMethodFunc ? 1 : 2; i2 < argTypes.length; ++i2) {
              var paramName = i2 === 1 ? "thisWired" : "arg" + (i2 - 2) + "Wired";
              if (argTypes[i2].destructorFunction !== null) {
                invokerFnBody += paramName + "_dtor(" + paramName + "); // " + argTypes[i2].name + "\n";
                args1.push(paramName + "_dtor");
              }
            }
          }
          if (returns) {
            invokerFnBody += "var ret = retType['fromWireType'](rv);\nreturn ret;\n";
          } else {
          }
          invokerFnBody += "}\n";
          return [args1, invokerFnBody];
        }
        var createNamedFunction = (name2, body2) => Object.defineProperty(body2, "name", {
          value: name2
        });
        var extendError = (baseErrorType, errorName) => {
          var errorClass = createNamedFunction(errorName, function(message) {
            this.name = errorName;
            this.message = message;
            var stack = new Error(message).stack;
            if (stack !== void 0) {
              this.stack = this.toString() + "\n" + stack.replace(/^Error(:[^\n]*)?\n/, "");
            }
          });
          errorClass.prototype = Object.create(baseErrorType.prototype);
          errorClass.prototype.constructor = errorClass;
          errorClass.prototype.toString = function() {
            if (this.message === void 0) {
              return this.name;
            } else {
              return `${this.name}: ${this.message}`;
            }
          };
          return errorClass;
        };
        var UnboundTypeError;
        var PureVirtualError;
        var registeredInstances = {};
        var getInheritedInstanceCount = () => Object.keys(registeredInstances).length;
        var getLiveInheritedInstances = () => {
          var rv = [];
          for (var k in registeredInstances) {
            if (registeredInstances.hasOwnProperty(k)) {
              rv.push(registeredInstances[k]);
            }
          }
          return rv;
        };
        var deletionQueue = [];
        var flushPendingDeletes = () => {
          while (deletionQueue.length) {
            var obj = deletionQueue.pop();
            obj.$$.deleteScheduled = false;
            obj["delete"]();
          }
        };
        var delayFunction;
        var setDelayFunction = (fn) => {
          delayFunction = fn;
          if (deletionQueue.length && delayFunction) {
            delayFunction(flushPendingDeletes);
          }
        };
        var init_embind = () => {
          Module["getInheritedInstanceCount"] = getInheritedInstanceCount;
          Module["getLiveInheritedInstances"] = getLiveInheritedInstances;
          Module["flushPendingDeletes"] = flushPendingDeletes;
          Module["setDelayFunction"] = setDelayFunction;
        };
        var throwUnboundTypeError = (message, types) => {
          var unboundTypes = [];
          var seen = {};
          function visit(type) {
            if (seen[type]) {
              return;
            }
            if (registeredTypes[type]) {
              return;
            }
            if (typeDependencies[type]) {
              typeDependencies[type].forEach(visit);
              return;
            }
            unboundTypes.push(type);
            seen[type] = true;
          }
          types.forEach(visit);
          throw new UnboundTypeError(`${message}: ` + unboundTypes.map(getTypeName).join([", "]));
        };
        var ensureOverloadTable = (proto, methodName, humanName) => {
          if (void 0 === proto[methodName].overloadTable) {
            var prevFunc = proto[methodName];
            proto[methodName] = function() {
              if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {
                throwBindingError(`Function '${humanName}' called with an invalid number of arguments (${arguments.length}) - expects one of (${proto[methodName].overloadTable})!`);
              }
              return proto[methodName].overloadTable[arguments.length].apply(this, arguments);
            };
            proto[methodName].overloadTable = [];
            proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;
          }
        };
        var exposePublicSymbol = (name2, value, numArguments) => {
          if (Module.hasOwnProperty(name2)) {
            if (void 0 === numArguments || void 0 !== Module[name2].overloadTable && void 0 !== Module[name2].overloadTable[numArguments]) {
              throwBindingError(`Cannot register public name '${name2}' twice`);
            }
            ensureOverloadTable(Module, name2, name2);
            if (Module.hasOwnProperty(numArguments)) {
              throwBindingError(`Cannot register multiple overloads of a function with the same number of arguments (${numArguments})!`);
            }
            Module[name2].overloadTable[numArguments] = value;
          } else {
            Module[name2] = value;
            if (void 0 !== numArguments) {
              Module[name2].numArguments = numArguments;
            }
          }
        };
        var replacePublicSymbol = (name2, value, numArguments) => {
          if (!Module.hasOwnProperty(name2)) {
            throwInternalError("Replacing nonexistant public symbol");
          }
          if (void 0 !== Module[name2].overloadTable && void 0 !== numArguments) {
            Module[name2].overloadTable[numArguments] = value;
          } else {
            Module[name2] = value;
            Module[name2].argCount = numArguments;
          }
        };
        var getBasestPointer = (class_, ptr2) => {
          if (ptr2 === void 0) {
            throwBindingError("ptr should not be undefined");
          }
          while (class_.baseClass) {
            ptr2 = class_.upcast(ptr2);
            class_ = class_.baseClass;
          }
          return ptr2;
        };
        var registerInheritedInstance = (class_, ptr2, instance2) => {
          ptr2 = getBasestPointer(class_, ptr2);
          if (registeredInstances.hasOwnProperty(ptr2)) {
            throwBindingError(`Tried to register registered instance: ${ptr2}`);
          } else {
            registeredInstances[ptr2] = instance2;
          }
        };
        var unregisterInheritedInstance = (class_, ptr2) => {
          ptr2 = getBasestPointer(class_, ptr2);
          if (registeredInstances.hasOwnProperty(ptr2)) {
            delete registeredInstances[ptr2];
          } else {
            throwBindingError(`Tried to unregister unregistered instance: ${ptr2}`);
          }
        };
        var getInheritedInstance = (class_, ptr2) => {
          ptr2 = getBasestPointer(class_, ptr2);
          return registeredInstances[ptr2];
        };
        var registeredPointers = {};
        var enumReadValueFromPointer = (name2, width, signed) => {
          switch (width) {
            case 1:
              return signed ? function(pointer) {
                return this["fromWireType"](HEAP8[pointer >>> 0 >>> 0]);
              } : function(pointer) {
                return this["fromWireType"](HEAPU8[pointer >>> 0 >>> 0]);
              };
            case 2:
              return signed ? function(pointer) {
                return this["fromWireType"](HEAP16[pointer >>> 1 >>> 0]);
              } : function(pointer) {
                return this["fromWireType"](HEAPU16[pointer >>> 1 >>> 0]);
              };
            case 4:
              return signed ? function(pointer) {
                return this["fromWireType"](HEAP32[pointer >>> 2 >>> 0]);
              } : function(pointer) {
                return this["fromWireType"](HEAPU32[pointer >>> 2 >>> 0]);
              };
            default:
              throw new TypeError(`invalid integer width (${width}): ${name2}`);
          }
        };
        function __embind_register_user_type(rawType, name2) {
          rawType >>>= 0;
          name2 >>>= 0;
          __embind_register_emval(rawType);
        }
        __embind_register_user_type.sig = "vpp";
        function __embind_register_optional(rawOptionalType, rawType) {
          rawOptionalType >>>= 0;
          rawType >>>= 0;
          __embind_register_emval(rawOptionalType);
        }
        __embind_register_optional.sig = "vpp";
        var runDestructors = (destructors) => {
          while (destructors.length) {
            var ptr2 = destructors.pop();
            var del = destructors.pop();
            del(ptr2);
          }
        };
        function newFunc(constructor, argumentList) {
          if (!(constructor instanceof Function)) {
            throw new TypeError(`new_ called with constructor type ${typeof constructor} which is not a function`);
          }
          var dummy = createNamedFunction(constructor.name || "unknownFunctionName", function() {
          });
          dummy.prototype = constructor.prototype;
          var obj = new dummy();
          var r = constructor.apply(obj, argumentList);
          return r instanceof Object ? r : obj;
        }
        function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc, isAsync) {
          var argCount = argTypes.length;
          if (argCount < 2) {
            throwBindingError("argTypes array size mismatch! Must at least get return value and 'this' types!");
          }
          var isClassMethodFunc = argTypes[1] !== null && classType !== null;
          var needsDestructorStack = usesDestructorStack(argTypes);
          var returns = argTypes[0].name !== "void";
          var closureArgs = [throwBindingError, cppInvokerFunc, cppTargetFunc, runDestructors, argTypes[0], argTypes[1]];
          for (var i2 = 0; i2 < argCount - 2; ++i2) {
            closureArgs.push(argTypes[i2 + 2]);
          }
          if (!needsDestructorStack) {
            for (var i2 = isClassMethodFunc ? 1 : 2; i2 < argTypes.length; ++i2) {
              if (argTypes[i2].destructorFunction !== null) {
                closureArgs.push(argTypes[i2].destructorFunction);
              }
            }
          }
          let [args2, invokerFnBody] = createJsInvoker(humanName, argTypes, isClassMethodFunc, returns, isAsync);
          args2.push(invokerFnBody);
          var invokerFn = newFunc(Function, args2).apply(null, closureArgs);
          return createNamedFunction(humanName, invokerFn);
        }
        var embind__requireFunction = (signature, rawFunction) => {
          signature = readLatin1String(signature);
          function makeDynCaller() {
            if (signature.includes("j")) {
              return getDynCaller(signature, rawFunction);
            }
            return getWasmTableEntry(rawFunction);
          }
          var fp = makeDynCaller();
          if (typeof fp != "function") {
            throwBindingError(`unknown function pointer with signature ${signature}: ${rawFunction}`);
          }
          return fp;
        };
        function __embind_register_function(name2, argCount, rawArgTypesAddr, signature, rawInvoker, fn, isAsync) {
          name2 >>>= 0;
          rawArgTypesAddr >>>= 0;
          signature >>>= 0;
          rawInvoker >>>= 0;
          fn >>>= 0;
          var argTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
          name2 = readLatin1String(name2);
          name2 = getFunctionName(name2);
          rawInvoker = embind__requireFunction(signature, rawInvoker);
          exposePublicSymbol(name2, function() {
            throwUnboundTypeError(`Cannot call ${name2} due to unbound types`, argTypes);
          }, argCount - 1);
          whenDependentTypesAreResolved([], argTypes, function(argTypes2) {
            var invokerArgsArray = [argTypes2[0], null].concat(argTypes2.slice(1));
            replacePublicSymbol(name2, craftInvokerFunction(name2, invokerArgsArray, null, rawInvoker, fn, isAsync), argCount - 1);
            return [];
          });
        }
        __embind_register_function.sig = "vpippppi";
        function __embind_register_value_array(rawType, name2, constructorSignature, rawConstructor, destructorSignature, rawDestructor) {
          rawType >>>= 0;
          name2 >>>= 0;
          constructorSignature >>>= 0;
          rawConstructor >>>= 0;
          destructorSignature >>>= 0;
          rawDestructor >>>= 0;
          tupleRegistrations[rawType] = {
            name: readLatin1String(name2),
            rawConstructor: embind__requireFunction(constructorSignature, rawConstructor),
            rawDestructor: embind__requireFunction(destructorSignature, rawDestructor),
            elements: []
          };
        }
        __embind_register_value_array.sig = "vpppppp";
        function __embind_register_value_array_element(rawTupleType, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {
          rawTupleType >>>= 0;
          getterReturnType >>>= 0;
          getterSignature >>>= 0;
          getter >>>= 0;
          getterContext >>>= 0;
          setterArgumentType >>>= 0;
          setterSignature >>>= 0;
          setter >>>= 0;
          setterContext >>>= 0;
          tupleRegistrations[rawTupleType].elements.push({
            getterReturnType,
            getter: embind__requireFunction(getterSignature, getter),
            getterContext,
            setterArgumentType,
            setter: embind__requireFunction(setterSignature, setter),
            setterContext
          });
        }
        __embind_register_value_array_element.sig = "vppppppppp";
        var __embind_finalize_value_array = function(rawTupleType) {
          rawTupleType >>>= 0;
          var reg = tupleRegistrations[rawTupleType];
          delete tupleRegistrations[rawTupleType];
          var elements = reg.elements;
          var elementsLength = elements.length;
          var elementTypes = elements.map((elt) => elt.getterReturnType).concat(elements.map((elt) => elt.setterArgumentType));
          var rawConstructor = reg.rawConstructor;
          var rawDestructor = reg.rawDestructor;
          whenDependentTypesAreResolved([rawTupleType], elementTypes, function(elementTypes2) {
            elements.forEach((elt, i2) => {
              var getterReturnType = elementTypes2[i2];
              var getter = elt.getter;
              var getterContext = elt.getterContext;
              var setterArgumentType = elementTypes2[i2 + elementsLength];
              var setter = elt.setter;
              var setterContext = elt.setterContext;
              elt.read = (ptr2) => getterReturnType["fromWireType"](getter(getterContext, ptr2));
              elt.write = (ptr2, o) => {
                var destructors = [];
                setter(setterContext, ptr2, setterArgumentType["toWireType"](destructors, o));
                runDestructors(destructors);
              };
            });
            return [{
              name: reg.name,
              "fromWireType": (ptr2) => {
                var rv = new Array(elementsLength);
                for (var i2 = 0; i2 < elementsLength; ++i2) {
                  rv[i2] = elements[i2].read(ptr2);
                }
                rawDestructor(ptr2);
                return rv;
              },
              "toWireType": (destructors, o) => {
                if (elementsLength !== o.length) {
                  throw new TypeError(`Incorrect number of tuple elements for ${reg.name}: expected=${elementsLength}, actual=${o.length}`);
                }
                var ptr2 = rawConstructor();
                for (var i2 = 0; i2 < elementsLength; ++i2) {
                  elements[i2].write(ptr2, o[i2]);
                }
                if (destructors !== null) {
                  destructors.push(rawDestructor, ptr2);
                }
                return ptr2;
              },
              "argPackAdvance": GenericWireTypeSize,
              "readValueFromPointer": simpleReadValueFromPointer,
              destructorFunction: rawDestructor
            }];
          });
        };
        __embind_finalize_value_array.sig = "vp";
        function __embind_register_value_object(rawType, name2, constructorSignature, rawConstructor, destructorSignature, rawDestructor) {
          rawType >>>= 0;
          name2 >>>= 0;
          constructorSignature >>>= 0;
          rawConstructor >>>= 0;
          destructorSignature >>>= 0;
          rawDestructor >>>= 0;
          structRegistrations[rawType] = {
            name: readLatin1String(name2),
            rawConstructor: embind__requireFunction(constructorSignature, rawConstructor),
            rawDestructor: embind__requireFunction(destructorSignature, rawDestructor),
            fields: []
          };
        }
        __embind_register_value_object.sig = "vpppppp";
        function __embind_register_value_object_field(structType, fieldName, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {
          structType >>>= 0;
          fieldName >>>= 0;
          getterReturnType >>>= 0;
          getterSignature >>>= 0;
          getter >>>= 0;
          getterContext >>>= 0;
          setterArgumentType >>>= 0;
          setterSignature >>>= 0;
          setter >>>= 0;
          setterContext >>>= 0;
          structRegistrations[structType].fields.push({
            fieldName: readLatin1String(fieldName),
            getterReturnType,
            getter: embind__requireFunction(getterSignature, getter),
            getterContext,
            setterArgumentType,
            setter: embind__requireFunction(setterSignature, setter),
            setterContext
          });
        }
        __embind_register_value_object_field.sig = "vpppppppppp";
        var __embind_finalize_value_object = function(structType) {
          structType >>>= 0;
          var reg = structRegistrations[structType];
          delete structRegistrations[structType];
          var rawConstructor = reg.rawConstructor;
          var rawDestructor = reg.rawDestructor;
          var fieldRecords = reg.fields;
          var fieldTypes = fieldRecords.map((field) => field.getterReturnType).concat(fieldRecords.map((field) => field.setterArgumentType));
          whenDependentTypesAreResolved([structType], fieldTypes, (fieldTypes2) => {
            var fields = {};
            fieldRecords.forEach((field, i2) => {
              var fieldName = field.fieldName;
              var getterReturnType = fieldTypes2[i2];
              var getter = field.getter;
              var getterContext = field.getterContext;
              var setterArgumentType = fieldTypes2[i2 + fieldRecords.length];
              var setter = field.setter;
              var setterContext = field.setterContext;
              fields[fieldName] = {
                read: (ptr2) => getterReturnType["fromWireType"](getter(getterContext, ptr2)),
                write: (ptr2, o) => {
                  var destructors = [];
                  setter(setterContext, ptr2, setterArgumentType["toWireType"](destructors, o));
                  runDestructors(destructors);
                }
              };
            });
            return [{
              name: reg.name,
              "fromWireType": (ptr2) => {
                var rv = {};
                for (var i2 in fields) {
                  rv[i2] = fields[i2].read(ptr2);
                }
                rawDestructor(ptr2);
                return rv;
              },
              "toWireType": (destructors, o) => {
                for (var fieldName in fields) {
                  if (!(fieldName in o)) {
                    throw new TypeError(`Missing field: "${fieldName}"`);
                  }
                }
                var ptr2 = rawConstructor();
                for (fieldName in fields) {
                  fields[fieldName].write(ptr2, o[fieldName]);
                }
                if (destructors !== null) {
                  destructors.push(rawDestructor, ptr2);
                }
                return ptr2;
              },
              "argPackAdvance": GenericWireTypeSize,
              "readValueFromPointer": simpleReadValueFromPointer,
              destructorFunction: rawDestructor
            }];
          });
        };
        __embind_finalize_value_object.sig = "vp";
        var upcastPointer = (ptr2, ptrClass, desiredClass) => {
          while (ptrClass !== desiredClass) {
            if (!ptrClass.upcast) {
              throwBindingError(`Expected null or instance of ${desiredClass.name}, got an instance of ${ptrClass.name}`);
            }
            ptr2 = ptrClass.upcast(ptr2);
            ptrClass = ptrClass.baseClass;
          }
          return ptr2;
        };
        function genericPointerToWireType(destructors, handle2) {
          var ptr2;
          if (handle2 === null) {
            if (this.isReference) {
              throwBindingError(`null is not a valid ${this.name}`);
            }
            if (this.isSmartPointer) {
              ptr2 = this.rawConstructor();
              if (destructors !== null) {
                destructors.push(this.rawDestructor, ptr2);
              }
              return ptr2;
            } else {
              return 0;
            }
          }
          if (!handle2 || !handle2.$$) {
            throwBindingError(`Cannot pass "${embindRepr(handle2)}" as a ${this.name}`);
          }
          if (!handle2.$$.ptr) {
            throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);
          }
          if (!this.isConst && handle2.$$.ptrType.isConst) {
            throwBindingError(`Cannot convert argument of type ${handle2.$$.smartPtrType ? handle2.$$.smartPtrType.name : handle2.$$.ptrType.name} to parameter type ${this.name}`);
          }
          var handleClass = handle2.$$.ptrType.registeredClass;
          ptr2 = upcastPointer(handle2.$$.ptr, handleClass, this.registeredClass);
          if (this.isSmartPointer) {
            if (void 0 === handle2.$$.smartPtr) {
              throwBindingError("Passing raw pointer to smart pointer is illegal");
            }
            switch (this.sharingPolicy) {
              case 0:
                if (handle2.$$.smartPtrType === this) {
                  ptr2 = handle2.$$.smartPtr;
                } else {
                  throwBindingError(`Cannot convert argument of type ${handle2.$$.smartPtrType ? handle2.$$.smartPtrType.name : handle2.$$.ptrType.name} to parameter type ${this.name}`);
                }
                break;
              case 1:
                ptr2 = handle2.$$.smartPtr;
                break;
              case 2:
                if (handle2.$$.smartPtrType === this) {
                  ptr2 = handle2.$$.smartPtr;
                } else {
                  var clonedHandle = handle2["clone"]();
                  ptr2 = this.rawShare(ptr2, Emval.toHandle(() => clonedHandle["delete"]()));
                  if (destructors !== null) {
                    destructors.push(this.rawDestructor, ptr2);
                  }
                }
                break;
              default:
                throwBindingError("Unsupporting sharing policy");
            }
          }
          return ptr2;
        }
        function constNoSmartPtrRawPointerToWireType(destructors, handle2) {
          if (handle2 === null) {
            if (this.isReference) {
              throwBindingError(`null is not a valid ${this.name}`);
            }
            return 0;
          }
          if (!handle2.$$) {
            throwBindingError(`Cannot pass "${embindRepr(handle2)}" as a ${this.name}`);
          }
          if (!handle2.$$.ptr) {
            throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);
          }
          var handleClass = handle2.$$.ptrType.registeredClass;
          var ptr2 = upcastPointer(handle2.$$.ptr, handleClass, this.registeredClass);
          return ptr2;
        }
        function nonConstNoSmartPtrRawPointerToWireType(destructors, handle2) {
          if (handle2 === null) {
            if (this.isReference) {
              throwBindingError(`null is not a valid ${this.name}`);
            }
            return 0;
          }
          if (!handle2.$$) {
            throwBindingError(`Cannot pass "${embindRepr(handle2)}" as a ${this.name}`);
          }
          if (!handle2.$$.ptr) {
            throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);
          }
          if (handle2.$$.ptrType.isConst) {
            throwBindingError(`Cannot convert argument of type ${handle2.$$.ptrType.name} to parameter type ${this.name}`);
          }
          var handleClass = handle2.$$.ptrType.registeredClass;
          var ptr2 = upcastPointer(handle2.$$.ptr, handleClass, this.registeredClass);
          return ptr2;
        }
        function RegisteredPointer(name2, registeredClass, isReference, isConst, isSmartPointer, pointeeType, sharingPolicy, rawGetPointee, rawConstructor, rawShare, rawDestructor) {
          this.name = name2;
          this.registeredClass = registeredClass;
          this.isReference = isReference;
          this.isConst = isConst;
          this.isSmartPointer = isSmartPointer;
          this.pointeeType = pointeeType;
          this.sharingPolicy = sharingPolicy;
          this.rawGetPointee = rawGetPointee;
          this.rawConstructor = rawConstructor;
          this.rawShare = rawShare;
          this.rawDestructor = rawDestructor;
          if (!isSmartPointer && registeredClass.baseClass === void 0) {
            if (isConst) {
              this["toWireType"] = constNoSmartPtrRawPointerToWireType;
              this.destructorFunction = null;
            } else {
              this["toWireType"] = nonConstNoSmartPtrRawPointerToWireType;
              this.destructorFunction = null;
            }
          } else {
            this["toWireType"] = genericPointerToWireType;
          }
        }
        var downcastPointer = (ptr2, ptrClass, desiredClass) => {
          if (ptrClass === desiredClass) {
            return ptr2;
          }
          if (void 0 === desiredClass.baseClass) {
            return null;
          }
          var rv = downcastPointer(ptr2, ptrClass, desiredClass.baseClass);
          if (rv === null) {
            return null;
          }
          return desiredClass.downcast(rv);
        };
        var finalizationRegistry = false;
        var detachFinalizer = (handle2) => {
        };
        var runDestructor = ($$) => {
          if ($$.smartPtr) {
            $$.smartPtrType.rawDestructor($$.smartPtr);
          } else {
            $$.ptrType.registeredClass.rawDestructor($$.ptr);
          }
        };
        var releaseClassHandle = ($$) => {
          $$.count.value -= 1;
          var toDelete = 0 === $$.count.value;
          if (toDelete) {
            runDestructor($$);
          }
        };
        var attachFinalizer = (handle2) => {
          if ("undefined" === typeof FinalizationRegistry) {
            attachFinalizer = (handle3) => handle3;
            return handle2;
          }
          finalizationRegistry = new FinalizationRegistry((info2) => {
            releaseClassHandle(info2.$$);
          });
          attachFinalizer = (handle3) => {
            var $$ = handle3.$$;
            var hasSmartPtr = !!$$.smartPtr;
            if (hasSmartPtr) {
              var info2 = {
                $$
              };
              finalizationRegistry.register(handle3, info2, handle3);
            }
            return handle3;
          };
          detachFinalizer = (handle3) => finalizationRegistry.unregister(handle3);
          return attachFinalizer(handle2);
        };
        var makeClassHandle = (prototype, record) => {
          if (!record.ptrType || !record.ptr) {
            throwInternalError("makeClassHandle requires ptr and ptrType");
          }
          var hasSmartPtrType = !!record.smartPtrType;
          var hasSmartPtr = !!record.smartPtr;
          if (hasSmartPtrType !== hasSmartPtr) {
            throwInternalError("Both smartPtrType and smartPtr must be specified");
          }
          record.count = {
            value: 1
          };
          return attachFinalizer(Object.create(prototype, {
            $$: {
              value: record,
              writable: true
            }
          }));
        };
        function RegisteredPointer_fromWireType(ptr2) {
          var rawPointer = this.getPointee(ptr2);
          if (!rawPointer) {
            this.destructor(ptr2);
            return null;
          }
          var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);
          if (void 0 !== registeredInstance) {
            if (0 === registeredInstance.$$.count.value) {
              registeredInstance.$$.ptr = rawPointer;
              registeredInstance.$$.smartPtr = ptr2;
              return registeredInstance["clone"]();
            } else {
              var rv = registeredInstance["clone"]();
              this.destructor(ptr2);
              return rv;
            }
          }
          function makeDefaultHandle() {
            if (this.isSmartPointer) {
              return makeClassHandle(this.registeredClass.instancePrototype, {
                ptrType: this.pointeeType,
                ptr: rawPointer,
                smartPtrType: this,
                smartPtr: ptr2
              });
            } else {
              return makeClassHandle(this.registeredClass.instancePrototype, {
                ptrType: this,
                ptr: ptr2
              });
            }
          }
          var actualType = this.registeredClass.getActualType(rawPointer);
          var registeredPointerRecord = registeredPointers[actualType];
          if (!registeredPointerRecord) {
            return makeDefaultHandle.call(this);
          }
          var toType;
          if (this.isConst) {
            toType = registeredPointerRecord.constPointerType;
          } else {
            toType = registeredPointerRecord.pointerType;
          }
          var dp = downcastPointer(rawPointer, this.registeredClass, toType.registeredClass);
          if (dp === null) {
            return makeDefaultHandle.call(this);
          }
          if (this.isSmartPointer) {
            return makeClassHandle(toType.registeredClass.instancePrototype, {
              ptrType: toType,
              ptr: dp,
              smartPtrType: this,
              smartPtr: ptr2
            });
          } else {
            return makeClassHandle(toType.registeredClass.instancePrototype, {
              ptrType: toType,
              ptr: dp
            });
          }
        }
        var init_RegisteredPointer = () => {
          Object.assign(RegisteredPointer.prototype, {
            getPointee(ptr2) {
              if (this.rawGetPointee) {
                ptr2 = this.rawGetPointee(ptr2);
              }
              return ptr2;
            },
            destructor(ptr2) {
              var _a;
              (_a = this.rawDestructor) == null ? void 0 : _a.call(this, ptr2);
            },
            "argPackAdvance": GenericWireTypeSize,
            "readValueFromPointer": readPointer,
            "fromWireType": RegisteredPointer_fromWireType
          });
        };
        var detachFinalizer_deps = ["$finalizationRegistry"];
        function ClassHandle() {
        }
        var shallowCopyInternalPointer = (o) => ({
          count: o.count,
          deleteScheduled: o.deleteScheduled,
          preservePointerOnDelete: o.preservePointerOnDelete,
          ptr: o.ptr,
          ptrType: o.ptrType,
          smartPtr: o.smartPtr,
          smartPtrType: o.smartPtrType
        });
        var throwInstanceAlreadyDeleted = (obj) => {
          function getInstanceTypeName(handle2) {
            return handle2.$$.ptrType.registeredClass.name;
          }
          throwBindingError(getInstanceTypeName(obj) + " instance already deleted");
        };
        var init_ClassHandle = () => {
          Object.assign(ClassHandle.prototype, {
            "isAliasOf"(other) {
              if (!(this instanceof ClassHandle)) {
                return false;
              }
              if (!(other instanceof ClassHandle)) {
                return false;
              }
              var leftClass = this.$$.ptrType.registeredClass;
              var left = this.$$.ptr;
              other.$$ = other.$$;
              var rightClass = other.$$.ptrType.registeredClass;
              var right = other.$$.ptr;
              while (leftClass.baseClass) {
                left = leftClass.upcast(left);
                leftClass = leftClass.baseClass;
              }
              while (rightClass.baseClass) {
                right = rightClass.upcast(right);
                rightClass = rightClass.baseClass;
              }
              return leftClass === rightClass && left === right;
            },
            "clone"() {
              if (!this.$$.ptr) {
                throwInstanceAlreadyDeleted(this);
              }
              if (this.$$.preservePointerOnDelete) {
                this.$$.count.value += 1;
                return this;
              } else {
                var clone = attachFinalizer(Object.create(Object.getPrototypeOf(this), {
                  $$: {
                    value: shallowCopyInternalPointer(this.$$)
                  }
                }));
                clone.$$.count.value += 1;
                clone.$$.deleteScheduled = false;
                return clone;
              }
            },
            "delete"() {
              if (!this.$$.ptr) {
                throwInstanceAlreadyDeleted(this);
              }
              if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
                throwBindingError("Object already scheduled for deletion");
              }
              detachFinalizer(this);
              releaseClassHandle(this.$$);
              if (!this.$$.preservePointerOnDelete) {
                this.$$.smartPtr = void 0;
                this.$$.ptr = void 0;
              }
            },
            "isDeleted"() {
              return !this.$$.ptr;
            },
            "deleteLater"() {
              if (!this.$$.ptr) {
                throwInstanceAlreadyDeleted(this);
              }
              if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
                throwBindingError("Object already scheduled for deletion");
              }
              deletionQueue.push(this);
              if (deletionQueue.length === 1 && delayFunction) {
                delayFunction(flushPendingDeletes);
              }
              this.$$.deleteScheduled = true;
              return this;
            }
          });
        };
        function RegisteredClass(name2, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast) {
          this.name = name2;
          this.constructor = constructor;
          this.instancePrototype = instancePrototype;
          this.rawDestructor = rawDestructor;
          this.baseClass = baseClass;
          this.getActualType = getActualType;
          this.upcast = upcast;
          this.downcast = downcast;
          this.pureVirtualFunctions = [];
        }
        var char_0 = 48;
        var char_9 = 57;
        var makeLegalFunctionName = (name2) => {
          if (void 0 === name2) {
            return "_unknown";
          }
          name2 = name2.replace(/[^a-zA-Z0-9_]/g, "$");
          var f = name2.charCodeAt(0);
          if (f >= char_0 && f <= char_9) {
            return `_${name2}`;
          }
          return name2;
        };
        function __embind_register_class(rawType, rawPointerType, rawConstPointerType, baseClassRawType, getActualTypeSignature, getActualType, upcastSignature, upcast, downcastSignature, downcast, name2, destructorSignature, rawDestructor) {
          rawType >>>= 0;
          rawPointerType >>>= 0;
          rawConstPointerType >>>= 0;
          baseClassRawType >>>= 0;
          getActualTypeSignature >>>= 0;
          getActualType >>>= 0;
          upcastSignature >>>= 0;
          upcast >>>= 0;
          downcastSignature >>>= 0;
          downcast >>>= 0;
          name2 >>>= 0;
          destructorSignature >>>= 0;
          rawDestructor >>>= 0;
          name2 = readLatin1String(name2);
          getActualType = embind__requireFunction(getActualTypeSignature, getActualType);
          upcast && (upcast = embind__requireFunction(upcastSignature, upcast));
          downcast && (downcast = embind__requireFunction(downcastSignature, downcast));
          rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);
          var legalFunctionName = makeLegalFunctionName(name2);
          exposePublicSymbol(legalFunctionName, function() {
            throwUnboundTypeError(`Cannot construct ${name2} due to unbound types`, [baseClassRawType]);
          });
          whenDependentTypesAreResolved([rawType, rawPointerType, rawConstPointerType], baseClassRawType ? [baseClassRawType] : [], function(base) {
            var _a;
            base = base[0];
            var baseClass;
            var basePrototype;
            if (baseClassRawType) {
              baseClass = base.registeredClass;
              basePrototype = baseClass.instancePrototype;
            } else {
              basePrototype = ClassHandle.prototype;
            }
            var constructor = createNamedFunction(name2, function() {
              if (Object.getPrototypeOf(this) !== instancePrototype) {
                throw new BindingError("Use 'new' to construct " + name2);
              }
              if (void 0 === registeredClass.constructor_body) {
                throw new BindingError(name2 + " has no accessible constructor");
              }
              var body2 = registeredClass.constructor_body[arguments.length];
              if (void 0 === body2) {
                throw new BindingError(`Tried to invoke ctor of ${name2} with invalid number of parameters (${arguments.length}) - expected (${Object.keys(registeredClass.constructor_body).toString()}) parameters instead!`);
              }
              return body2.apply(this, arguments);
            });
            var instancePrototype = Object.create(basePrototype, {
              constructor: {
                value: constructor
              }
            });
            constructor.prototype = instancePrototype;
            var registeredClass = new RegisteredClass(name2, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast);
            if (registeredClass.baseClass) {
              (_a = registeredClass.baseClass).__derivedClasses ?? (_a.__derivedClasses = []);
              registeredClass.baseClass.__derivedClasses.push(registeredClass);
            }
            var referenceConverter = new RegisteredPointer(name2, registeredClass, true, false, false);
            var pointerConverter = new RegisteredPointer(name2 + "*", registeredClass, false, false, false);
            var constPointerConverter = new RegisteredPointer(name2 + " const*", registeredClass, false, true, false);
            registeredPointers[rawType] = {
              pointerType: pointerConverter,
              constPointerType: constPointerConverter
            };
            replacePublicSymbol(legalFunctionName, constructor);
            return [referenceConverter, pointerConverter, constPointerConverter];
          });
        }
        __embind_register_class.sig = "vppppppppppppp";
        function __embind_register_class_constructor(rawClassType, argCount, rawArgTypesAddr, invokerSignature, invoker, rawConstructor) {
          rawClassType >>>= 0;
          rawArgTypesAddr >>>= 0;
          invokerSignature >>>= 0;
          invoker >>>= 0;
          rawConstructor >>>= 0;
          var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
          invoker = embind__requireFunction(invokerSignature, invoker);
          var args2 = [rawConstructor];
          var destructors = [];
          whenDependentTypesAreResolved([], [rawClassType], function(classType) {
            classType = classType[0];
            var humanName = `constructor ${classType.name}`;
            if (void 0 === classType.registeredClass.constructor_body) {
              classType.registeredClass.constructor_body = [];
            }
            if (void 0 !== classType.registeredClass.constructor_body[argCount - 1]) {
              throw new BindingError(`Cannot register multiple constructors with identical number of parameters (${argCount - 1}) for class '${classType.name}'! Overload resolution is currently only performed using the parameter count, not actual type info!`);
            }
            classType.registeredClass.constructor_body[argCount - 1] = () => {
              throwUnboundTypeError(`Cannot construct ${classType.name} due to unbound types`, rawArgTypes);
            };
            whenDependentTypesAreResolved([], rawArgTypes, (argTypes) => {
              argTypes.splice(1, 0, null);
              classType.registeredClass.constructor_body[argCount - 1] = craftInvokerFunction(humanName, argTypes, null, invoker, rawConstructor);
              return [];
            });
            return [];
          });
        }
        __embind_register_class_constructor.sig = "vpipppp";
        var validateThis = (this_, classType, humanName) => {
          if (!(this_ instanceof Object)) {
            throwBindingError(`${humanName} with invalid "this": ${this_}`);
          }
          if (!(this_ instanceof classType.registeredClass.constructor)) {
            throwBindingError(`${humanName} incompatible with "this" of type ${this_.constructor.name}`);
          }
          if (!this_.$$.ptr) {
            throwBindingError(`cannot call emscripten binding method ${humanName} on deleted object`);
          }
          return upcastPointer(this_.$$.ptr, this_.$$.ptrType.registeredClass, classType.registeredClass);
        };
        function __embind_register_class_function(rawClassType, methodName, argCount, rawArgTypesAddr, invokerSignature, rawInvoker, context, isPureVirtual, isAsync) {
          rawClassType >>>= 0;
          methodName >>>= 0;
          rawArgTypesAddr >>>= 0;
          invokerSignature >>>= 0;
          rawInvoker >>>= 0;
          context >>>= 0;
          var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
          methodName = readLatin1String(methodName);
          methodName = getFunctionName(methodName);
          rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);
          whenDependentTypesAreResolved([], [rawClassType], function(classType) {
            classType = classType[0];
            var humanName = `${classType.name}.${methodName}`;
            if (methodName.startsWith("@@")) {
              methodName = Symbol[methodName.substring(2)];
            }
            if (isPureVirtual) {
              classType.registeredClass.pureVirtualFunctions.push(methodName);
            }
            function unboundTypesHandler() {
              throwUnboundTypeError(`Cannot call ${humanName} due to unbound types`, rawArgTypes);
            }
            var proto = classType.registeredClass.instancePrototype;
            var method = proto[methodName];
            if (void 0 === method || void 0 === method.overloadTable && method.className !== classType.name && method.argCount === argCount - 2) {
              unboundTypesHandler.argCount = argCount - 2;
              unboundTypesHandler.className = classType.name;
              proto[methodName] = unboundTypesHandler;
            } else {
              ensureOverloadTable(proto, methodName, humanName);
              proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;
            }
            whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
              var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context, isAsync);
              if (void 0 === proto[methodName].overloadTable) {
                memberFunction.argCount = argCount - 2;
                proto[methodName] = memberFunction;
              } else {
                proto[methodName].overloadTable[argCount - 2] = memberFunction;
              }
              return [];
            });
            return [];
          });
        }
        __embind_register_class_function.sig = "vppippppii";
        function __embind_register_class_property(classType, fieldName, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {
          classType >>>= 0;
          fieldName >>>= 0;
          getterReturnType >>>= 0;
          getterSignature >>>= 0;
          getter >>>= 0;
          getterContext >>>= 0;
          setterArgumentType >>>= 0;
          setterSignature >>>= 0;
          setter >>>= 0;
          setterContext >>>= 0;
          fieldName = readLatin1String(fieldName);
          getter = embind__requireFunction(getterSignature, getter);
          whenDependentTypesAreResolved([], [classType], function(classType2) {
            classType2 = classType2[0];
            var humanName = `${classType2.name}.${fieldName}`;
            var desc = {
              get() {
                throwUnboundTypeError(`Cannot access ${humanName} due to unbound types`, [getterReturnType, setterArgumentType]);
              },
              enumerable: true,
              configurable: true
            };
            if (setter) {
              desc.set = () => throwUnboundTypeError(`Cannot access ${humanName} due to unbound types`, [getterReturnType, setterArgumentType]);
            } else {
              desc.set = (v) => throwBindingError(humanName + " is a read-only property");
            }
            Object.defineProperty(classType2.registeredClass.instancePrototype, fieldName, desc);
            whenDependentTypesAreResolved([], setter ? [getterReturnType, setterArgumentType] : [getterReturnType], function(types) {
              var getterReturnType2 = types[0];
              var desc2 = {
                get() {
                  var ptr2 = validateThis(this, classType2, humanName + " getter");
                  return getterReturnType2["fromWireType"](getter(getterContext, ptr2));
                },
                enumerable: true
              };
              if (setter) {
                setter = embind__requireFunction(setterSignature, setter);
                var setterArgumentType2 = types[1];
                desc2.set = function(v) {
                  var ptr2 = validateThis(this, classType2, humanName + " setter");
                  var destructors = [];
                  setter(setterContext, ptr2, setterArgumentType2["toWireType"](destructors, v));
                  runDestructors(destructors);
                };
              }
              Object.defineProperty(classType2.registeredClass.instancePrototype, fieldName, desc2);
              return [];
            });
            return [];
          });
        }
        __embind_register_class_property.sig = "vpppppppppp";
        function __embind_register_class_class_function(rawClassType, methodName, argCount, rawArgTypesAddr, invokerSignature, rawInvoker, fn, isAsync) {
          rawClassType >>>= 0;
          methodName >>>= 0;
          rawArgTypesAddr >>>= 0;
          invokerSignature >>>= 0;
          rawInvoker >>>= 0;
          fn >>>= 0;
          var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
          methodName = readLatin1String(methodName);
          methodName = getFunctionName(methodName);
          rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);
          whenDependentTypesAreResolved([], [rawClassType], function(classType) {
            classType = classType[0];
            var humanName = `${classType.name}.${methodName}`;
            function unboundTypesHandler() {
              throwUnboundTypeError(`Cannot call ${humanName} due to unbound types`, rawArgTypes);
            }
            if (methodName.startsWith("@@")) {
              methodName = Symbol[methodName.substring(2)];
            }
            var proto = classType.registeredClass.constructor;
            if (void 0 === proto[methodName]) {
              unboundTypesHandler.argCount = argCount - 1;
              proto[methodName] = unboundTypesHandler;
            } else {
              ensureOverloadTable(proto, methodName, humanName);
              proto[methodName].overloadTable[argCount - 1] = unboundTypesHandler;
            }
            whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
              var invokerArgsArray = [argTypes[0], null].concat(argTypes.slice(1));
              var func2 = craftInvokerFunction(humanName, invokerArgsArray, null, rawInvoker, fn, isAsync);
              if (void 0 === proto[methodName].overloadTable) {
                func2.argCount = argCount - 1;
                proto[methodName] = func2;
              } else {
                proto[methodName].overloadTable[argCount - 1] = func2;
              }
              if (classType.registeredClass.__derivedClasses) {
                for (const derivedClass of classType.registeredClass.__derivedClasses) {
                  if (!derivedClass.constructor.hasOwnProperty(methodName)) {
                    derivedClass.constructor[methodName] = func2;
                  }
                }
              }
              return [];
            });
            return [];
          });
        }
        __embind_register_class_class_function.sig = "vppippppi";
        function __embind_register_class_class_property(rawClassType, fieldName, rawFieldType, rawFieldPtr, getterSignature, getter, setterSignature, setter) {
          rawClassType >>>= 0;
          fieldName >>>= 0;
          rawFieldType >>>= 0;
          rawFieldPtr >>>= 0;
          getterSignature >>>= 0;
          getter >>>= 0;
          setterSignature >>>= 0;
          setter >>>= 0;
          fieldName = readLatin1String(fieldName);
          getter = embind__requireFunction(getterSignature, getter);
          whenDependentTypesAreResolved([], [rawClassType], function(classType) {
            classType = classType[0];
            var humanName = `${classType.name}.${fieldName}`;
            var desc = {
              get() {
                throwUnboundTypeError(`Cannot access ${humanName} due to unbound types`, [rawFieldType]);
              },
              enumerable: true,
              configurable: true
            };
            if (setter) {
              desc.set = () => {
                throwUnboundTypeError(`Cannot access ${humanName} due to unbound types`, [rawFieldType]);
              };
            } else {
              desc.set = (v) => {
                throwBindingError(`${humanName} is a read-only property`);
              };
            }
            Object.defineProperty(classType.registeredClass.constructor, fieldName, desc);
            whenDependentTypesAreResolved([], [rawFieldType], function(fieldType) {
              fieldType = fieldType[0];
              var desc2 = {
                get() {
                  return fieldType["fromWireType"](getter(rawFieldPtr));
                },
                enumerable: true
              };
              if (setter) {
                setter = embind__requireFunction(setterSignature, setter);
                desc2.set = (v) => {
                  var destructors = [];
                  setter(rawFieldPtr, fieldType["toWireType"](destructors, v));
                  runDestructors(destructors);
                };
              }
              Object.defineProperty(classType.registeredClass.constructor, fieldName, desc2);
              return [];
            });
            return [];
          });
        }
        __embind_register_class_class_property.sig = "vpppppppp";
        function __embind_create_inheriting_constructor(constructorName, wrapperType, properties) {
          constructorName >>>= 0;
          wrapperType >>>= 0;
          properties >>>= 0;
          constructorName = readLatin1String(constructorName);
          wrapperType = requireRegisteredType(wrapperType, "wrapper");
          properties = Emval.toValue(properties);
          var arraySlice = [].slice;
          var registeredClass = wrapperType.registeredClass;
          var wrapperPrototype = registeredClass.instancePrototype;
          var baseClass = registeredClass.baseClass;
          var baseClassPrototype = baseClass.instancePrototype;
          var baseConstructor = registeredClass.baseClass.constructor;
          var ctor = createNamedFunction(constructorName, function() {
            registeredClass.baseClass.pureVirtualFunctions.forEach(function(name2) {
              if (this[name2] === baseClassPrototype[name2]) {
                throw new PureVirtualError(`Pure virtual function ${name2} must be implemented in JavaScript`);
              }
            }.bind(this));
            Object.defineProperty(this, "__parent", {
              value: wrapperPrototype
            });
            this["__construct"].apply(this, arraySlice.call(arguments));
          });
          wrapperPrototype["__construct"] = function __construct() {
            if (this === wrapperPrototype) {
              throwBindingError("Pass correct 'this' to __construct");
            }
            var inner = baseConstructor["implement"].apply(void 0, [this].concat(arraySlice.call(arguments)));
            detachFinalizer(inner);
            var $$ = inner.$$;
            inner["notifyOnDestruction"]();
            $$.preservePointerOnDelete = true;
            Object.defineProperties(this, {
              $$: {
                value: $$
              }
            });
            attachFinalizer(this);
            registerInheritedInstance(registeredClass, $$.ptr, this);
          };
          wrapperPrototype["__destruct"] = function __destruct() {
            if (this === wrapperPrototype) {
              throwBindingError("Pass correct 'this' to __destruct");
            }
            detachFinalizer(this);
            unregisterInheritedInstance(registeredClass, this.$$.ptr);
          };
          ctor.prototype = Object.create(wrapperPrototype);
          Object.assign(ctor.prototype, properties);
          return Emval.toHandle(ctor);
        }
        __embind_create_inheriting_constructor.sig = "pppp";
        function __embind_register_smart_ptr(rawType, rawPointeeType, name2, sharingPolicy, getPointeeSignature, rawGetPointee, constructorSignature, rawConstructor, shareSignature, rawShare, destructorSignature, rawDestructor) {
          rawType >>>= 0;
          rawPointeeType >>>= 0;
          name2 >>>= 0;
          getPointeeSignature >>>= 0;
          rawGetPointee >>>= 0;
          constructorSignature >>>= 0;
          rawConstructor >>>= 0;
          shareSignature >>>= 0;
          rawShare >>>= 0;
          destructorSignature >>>= 0;
          rawDestructor >>>= 0;
          name2 = readLatin1String(name2);
          rawGetPointee = embind__requireFunction(getPointeeSignature, rawGetPointee);
          rawConstructor = embind__requireFunction(constructorSignature, rawConstructor);
          rawShare = embind__requireFunction(shareSignature, rawShare);
          rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);
          whenDependentTypesAreResolved([rawType], [rawPointeeType], function(pointeeType) {
            pointeeType = pointeeType[0];
            var registeredPointer = new RegisteredPointer(name2, pointeeType.registeredClass, false, false, true, pointeeType, sharingPolicy, rawGetPointee, rawConstructor, rawShare, rawDestructor);
            return [registeredPointer];
          });
        }
        __embind_register_smart_ptr.sig = "vpppipppppppp";
        function __embind_register_enum(rawType, name2, size, isSigned) {
          rawType >>>= 0;
          name2 >>>= 0;
          size >>>= 0;
          name2 = readLatin1String(name2);
          function ctor() {
          }
          ctor.values = {};
          registerType(rawType, {
            name: name2,
            constructor: ctor,
            "fromWireType": function(c) {
              return this.constructor.values[c];
            },
            "toWireType": (destructors, c) => c.value,
            "argPackAdvance": GenericWireTypeSize,
            "readValueFromPointer": enumReadValueFromPointer(name2, size, isSigned),
            destructorFunction: null
          });
          exposePublicSymbol(name2, ctor);
        }
        __embind_register_enum.sig = "vpppi";
        function __embind_register_enum_value(rawEnumType, name2, enumValue) {
          rawEnumType >>>= 0;
          name2 >>>= 0;
          var enumType = requireRegisteredType(rawEnumType, "enum");
          name2 = readLatin1String(name2);
          var Enum = enumType.constructor;
          var Value = Object.create(enumType.constructor.prototype, {
            value: {
              value: enumValue
            },
            constructor: {
              value: createNamedFunction(`${enumType.name}_${name2}`, function() {
              })
            }
          });
          Enum.values[enumValue] = Value;
          Enum[name2] = Value;
        }
        __embind_register_enum_value.sig = "vppi";
        function __embind_register_constant(name2, type, value) {
          name2 >>>= 0;
          type >>>= 0;
          name2 = readLatin1String(name2);
          whenDependentTypesAreResolved([], [type], function(type2) {
            type2 = type2[0];
            Module[name2] = type2["fromWireType"](value);
            return [];
          });
        }
        __embind_register_constant.sig = "vppd";
        var emval_symbols = {};
        function __emval_register_symbol(address) {
          address >>>= 0;
          emval_symbols[address] = readLatin1String(address);
        }
        __emval_register_symbol.sig = "vp";
        var getStringOrSymbol = (address) => {
          var symbol = emval_symbols[address];
          if (symbol === void 0) {
            return readLatin1String(address);
          }
          return symbol;
        };
        function __emval_incref(handle2) {
          handle2 >>>= 0;
          if (handle2 > 4) {
            emval_handles.get(handle2).refcount += 1;
          }
        }
        __emval_incref.sig = "vp";
        function __emval_run_destructors(handle2) {
          handle2 >>>= 0;
          var destructors = Emval.toValue(handle2);
          runDestructors(destructors);
          __emval_decref(handle2);
        }
        __emval_run_destructors.sig = "vp";
        function __emval_new_array() {
          return Emval.toHandle([]);
        }
        __emval_new_array.sig = "p";
        function __emval_new_array_from_memory_view(view) {
          view >>>= 0;
          view = Emval.toValue(view);
          var a = new Array(view.length);
          for (var i2 = 0; i2 < view.length; i2++)
            a[i2] = view[i2];
          return Emval.toHandle(a);
        }
        __emval_new_array_from_memory_view.sig = "pp";
        function __emval_new_object() {
          return Emval.toHandle({});
        }
        __emval_new_object.sig = "p";
        function __emval_new_cstring(v) {
          v >>>= 0;
          return Emval.toHandle(getStringOrSymbol(v));
        }
        __emval_new_cstring.sig = "pp";
        function __emval_new_u8string(v) {
          v >>>= 0;
          return Emval.toHandle(UTF8ToString(v));
        }
        __emval_new_u8string.sig = "pp";
        function __emval_new_u16string(v) {
          v >>>= 0;
          return Emval.toHandle(UTF16ToString(v));
        }
        __emval_new_u16string.sig = "pp";
        function __emval_take_value(type, arg) {
          type >>>= 0;
          arg >>>= 0;
          type = requireRegisteredType(type, "_emval_take_value");
          var v = type["readValueFromPointer"](arg);
          return Emval.toHandle(v);
        }
        __emval_take_value.sig = "ppp";
        var emval_get_global = () => {
          if (typeof globalThis == "object") {
            return globalThis;
          }
          return (/* @__PURE__ */ function() {
            return Function;
          }())("return this")();
        };
        function __emval_get_global(name2) {
          name2 >>>= 0;
          if (name2 === 0) {
            return Emval.toHandle(emval_get_global());
          } else {
            name2 = getStringOrSymbol(name2);
            return Emval.toHandle(emval_get_global()[name2]);
          }
        }
        __emval_get_global.sig = "pp";
        function __emval_get_module_property(name2) {
          name2 >>>= 0;
          name2 = getStringOrSymbol(name2);
          return Emval.toHandle(Module[name2]);
        }
        __emval_get_module_property.sig = "pp";
        function __emval_get_property(handle2, key) {
          handle2 >>>= 0;
          key >>>= 0;
          handle2 = Emval.toValue(handle2);
          key = Emval.toValue(key);
          return Emval.toHandle(handle2[key]);
        }
        __emval_get_property.sig = "ppp";
        function __emval_set_property(handle2, key, value) {
          handle2 >>>= 0;
          key >>>= 0;
          value >>>= 0;
          handle2 = Emval.toValue(handle2);
          key = Emval.toValue(key);
          value = Emval.toValue(value);
          handle2[key] = value;
        }
        __emval_set_property.sig = "vppp";
        var emval_returnValue = (returnType, destructorsRef, handle2) => {
          var destructors = [];
          var result = returnType["toWireType"](destructors, handle2);
          if (destructors.length) {
            HEAPU32[destructorsRef >>> 2 >>> 0] = Emval.toHandle(destructors);
          }
          return result;
        };
        function __emval_as(handle2, returnType, destructorsRef) {
          handle2 >>>= 0;
          returnType >>>= 0;
          destructorsRef >>>= 0;
          handle2 = Emval.toValue(handle2);
          returnType = requireRegisteredType(returnType, "emval::as");
          return emval_returnValue(returnType, destructorsRef, handle2);
        }
        __emval_as.sig = "dppp";
        function __emval_as_int64(handle2, returnType) {
          handle2 >>>= 0;
          returnType >>>= 0;
          handle2 = Emval.toValue(handle2);
          returnType = requireRegisteredType(returnType, "emval::as");
          return returnType["toWireType"](null, handle2);
        }
        __emval_as_int64.sig = "ipp";
        function __emval_as_uint64(handle2, returnType) {
          handle2 >>>= 0;
          returnType >>>= 0;
          handle2 = Emval.toValue(handle2);
          returnType = requireRegisteredType(returnType, "emval::as");
          return returnType["toWireType"](null, handle2);
        }
        __emval_as_uint64.sig = "ipp";
        function __emval_equals(first, second) {
          first >>>= 0;
          second >>>= 0;
          first = Emval.toValue(first);
          second = Emval.toValue(second);
          return first == second;
        }
        __emval_equals.sig = "ipp";
        function __emval_strictly_equals(first, second) {
          first >>>= 0;
          second >>>= 0;
          first = Emval.toValue(first);
          second = Emval.toValue(second);
          return first === second;
        }
        __emval_strictly_equals.sig = "ipp";
        function __emval_greater_than(first, second) {
          first >>>= 0;
          second >>>= 0;
          first = Emval.toValue(first);
          second = Emval.toValue(second);
          return first > second;
        }
        __emval_greater_than.sig = "ipp";
        function __emval_less_than(first, second) {
          first >>>= 0;
          second >>>= 0;
          first = Emval.toValue(first);
          second = Emval.toValue(second);
          return first < second;
        }
        __emval_less_than.sig = "ipp";
        function __emval_not(object) {
          object >>>= 0;
          object = Emval.toValue(object);
          return !object;
        }
        __emval_not.sig = "ip";
        var emval_methodCallers = [];
        function __emval_call(caller, handle2, destructorsRef, args2) {
          caller >>>= 0;
          handle2 >>>= 0;
          destructorsRef >>>= 0;
          args2 >>>= 0;
          caller = emval_methodCallers[caller];
          handle2 = Emval.toValue(handle2);
          return caller(null, handle2, destructorsRef, args2);
        }
        __emval_call.sig = "dpppp";
        var emval_lookupTypes = (argCount, argTypes) => {
          var a = new Array(argCount);
          for (var i2 = 0; i2 < argCount; ++i2) {
            a[i2] = requireRegisteredType(HEAPU32[argTypes + i2 * 4 >>> 2 >>> 0], "parameter " + i2);
          }
          return a;
        };
        var emval_addMethodCaller = (caller) => {
          var id = emval_methodCallers.length;
          emval_methodCallers.push(caller);
          return id;
        };
        var reflectConstruct = Reflect.construct;
        function __emval_get_method_caller(argCount, argTypes, kind) {
          argTypes >>>= 0;
          var types = emval_lookupTypes(argCount, argTypes);
          var retType = types.shift();
          argCount--;
          var functionBody = `return function (obj, func, destructorsRef, args) {
`;
          var offset = 0;
          var argsList = [];
          if (kind === 0) {
            argsList.push("obj");
          }
          var params = ["retType"];
          var args2 = [retType];
          for (var i2 = 0; i2 < argCount; ++i2) {
            argsList.push("arg" + i2);
            params.push("argType" + i2);
            args2.push(types[i2]);
            functionBody += `  var arg${i2} = argType${i2}.readValueFromPointer(args${offset ? "+" + offset : ""});
`;
            offset += types[i2]["argPackAdvance"];
          }
          var invoker = kind === 1 ? "new func" : "func.call";
          functionBody += `  var rv = ${invoker}(${argsList.join(", ")});
`;
          if (!retType.isVoid) {
            params.push("emval_returnValue");
            args2.push(emval_returnValue);
            functionBody += "  return emval_returnValue(retType, destructorsRef, rv);\n";
          }
          functionBody += "};\n";
          params.push(functionBody);
          var invokerFunction = newFunc(Function, params).apply(null, args2);
          var functionName = `methodCaller<(${types.map((t) => t.name).join(", ")}) => ${retType.name}>`;
          return emval_addMethodCaller(createNamedFunction(functionName, invokerFunction));
        }
        __emval_get_method_caller.sig = "pipi";
        function __emval_call_method(caller, objHandle, methodName, destructorsRef, args2) {
          caller >>>= 0;
          objHandle >>>= 0;
          methodName >>>= 0;
          destructorsRef >>>= 0;
          args2 >>>= 0;
          caller = emval_methodCallers[caller];
          objHandle = Emval.toValue(objHandle);
          methodName = getStringOrSymbol(methodName);
          return caller(objHandle, objHandle[methodName], destructorsRef, args2);
        }
        __emval_call_method.sig = "dppppp";
        function __emval_typeof(handle2) {
          handle2 >>>= 0;
          handle2 = Emval.toValue(handle2);
          return Emval.toHandle(typeof handle2);
        }
        __emval_typeof.sig = "pp";
        function __emval_instanceof(object, constructor) {
          object >>>= 0;
          constructor >>>= 0;
          object = Emval.toValue(object);
          constructor = Emval.toValue(constructor);
          return object instanceof constructor;
        }
        __emval_instanceof.sig = "ipp";
        function __emval_is_number(handle2) {
          handle2 >>>= 0;
          handle2 = Emval.toValue(handle2);
          return typeof handle2 == "number";
        }
        __emval_is_number.sig = "ip";
        function __emval_is_string(handle2) {
          handle2 >>>= 0;
          handle2 = Emval.toValue(handle2);
          return typeof handle2 == "string";
        }
        __emval_is_string.sig = "ip";
        function __emval_in(item, object) {
          item >>>= 0;
          object >>>= 0;
          item = Emval.toValue(item);
          object = Emval.toValue(object);
          return item in object;
        }
        __emval_in.sig = "ipp";
        function __emval_delete(object, property) {
          object >>>= 0;
          property >>>= 0;
          object = Emval.toValue(object);
          property = Emval.toValue(property);
          return delete object[property];
        }
        __emval_delete.sig = "ipp";
        function __emval_throw(object) {
          object >>>= 0;
          object = Emval.toValue(object);
          throw object;
        }
        __emval_throw.sig = "ip";
        function __emval_iter_begin(iterable) {
          iterable >>>= 0;
          iterable = Emval.toValue(iterable);
          return Emval.toHandle(iterable[Symbol.iterator]());
        }
        __emval_iter_begin.sig = "pp";
        function __emval_iter_next(iterator) {
          iterator >>>= 0;
          iterator = Emval.toValue(iterator);
          var result = iterator.next();
          return result.done ? 0 : Emval.toHandle(result.value);
        }
        __emval_iter_next.sig = "pp";
        var __emval_coro_suspend = function(promiseHandle, awaiterPtr) {
          promiseHandle >>>= 0;
          awaiterPtr >>>= 0;
          Emval.toValue(promiseHandle).then((result) => {
            __emval_coro_resume(awaiterPtr, Emval.toHandle(result));
          });
        };
        __emval_coro_suspend.sig = "vpp";
        var __emval_coro_make_promise = function(resolveHandlePtr, rejectHandlePtr) {
          resolveHandlePtr >>>= 0;
          rejectHandlePtr >>>= 0;
          return Emval.toHandle(new Promise((resolve, reject) => {
            const rejectWithCurrentException = () => {
              try {
                ___cxa_rethrow();
              } catch (e) {
                reject(e);
              }
            };
            HEAPU32[resolveHandlePtr >>> 2 >>> 0] = Emval.toHandle(resolve);
            HEAPU32[rejectHandlePtr >>> 2 >>> 0] = Emval.toHandle(rejectWithCurrentException);
          }));
        };
        __emval_coro_make_promise.sig = "ppp";
        function _duckdb_web_fs_file_sync(fileId) {
          return globalThis.DUCKDB_RUNTIME.syncFile(Module, fileId);
        }
        _duckdb_web_fs_file_sync.sig = "vi";
        function _duckdb_web_fs_file_remove(path2, pathLen) {
          return globalThis.DUCKDB_RUNTIME.removeFile(Module, path2, pathLen);
        }
        registerWasmPlugin();
        var FSNode = function(parent, name2, mode, rdev) {
          if (!parent) {
            parent = this;
          }
          this.parent = parent;
          this.mount = parent.mount;
          this.mounted = null;
          this.id = FS.nextInode++;
          this.name = name2;
          this.mode = mode;
          this.node_ops = {};
          this.stream_ops = {};
          this.rdev = rdev;
        };
        var readMode = 292 | 73;
        var writeMode = 146;
        Object.defineProperties(FSNode.prototype, {
          read: {
            get: function() {
              return (this.mode & readMode) === readMode;
            },
            set: function(val) {
              val ? this.mode |= readMode : this.mode &= ~readMode;
            }
          },
          write: {
            get: function() {
              return (this.mode & writeMode) === writeMode;
            },
            set: function(val) {
              val ? this.mode |= writeMode : this.mode &= ~writeMode;
            }
          },
          isFolder: {
            get: function() {
              return FS.isDir(this.mode);
            }
          },
          isDevice: {
            get: function() {
              return FS.isChrdev(this.mode);
            }
          }
        });
        FS.FSNode = FSNode;
        FS.createPreloadedFile = FS_createPreloadedFile;
        FS.staticInit();
        embind_init_charCodes();
        BindingError = Module["BindingError"] = class BindingError extends Error {
          constructor(message) {
            super(message);
            this.name = "BindingError";
          }
        };
        InternalError = Module["InternalError"] = class InternalError extends Error {
          constructor(message) {
            super(message);
            this.name = "InternalError";
          }
        };
        init_emval();
        Module["requestFullscreen"] = Browser.requestFullscreen;
        Module["requestAnimationFrame"] = Browser.requestAnimationFrame;
        Module["setCanvasSize"] = Browser.setCanvasSize;
        Module["pauseMainLoop"] = Browser.mainLoop.pause;
        Module["resumeMainLoop"] = Browser.mainLoop.resume;
        Module["getUserMedia"] = Browser.getUserMedia;
        Module["createContext"] = Browser.createContext;
        var preloadedImages = {};
        var preloadedAudios = {};
        var GLctx;
        for (var i = 0; i < 32; ++i)
          tempFixedLengthArray.push(new Array(i));
        var miniTempWebGLFloatBuffersStorage = new Float32Array(288);
        for (var i = 0; i < 288; ++i) {
          miniTempWebGLFloatBuffers[i] = miniTempWebGLFloatBuffersStorage.subarray(0, i + 1);
        }
        var miniTempWebGLIntBuffersStorage = new Int32Array(288);
        for (var i = 0; i < 288; ++i) {
          miniTempWebGLIntBuffers[i] = miniTempWebGLIntBuffersStorage.subarray(0, i + 1);
        }
        var emSetImmediate;
        var emClearImmediate;
        if (typeof setImmediate != "undefined") {
          emSetImmediate = setImmediateWrapped;
          emClearImmediate = clearImmediateWrapped;
        } else if (typeof addEventListener == "function") {
          var __setImmediate_id_counter = 0;
          var __setImmediate_queue = [];
          var __setImmediate_message_id = "_si";
          var __setImmediate_cb = (e) => {
            if (e.data === __setImmediate_message_id) {
              e.stopPropagation();
              __setImmediate_queue.shift()();
              ++__setImmediate_id_counter;
            }
          };
          addEventListener("message", __setImmediate_cb, true);
          emSetImmediate = (func2) => {
            postMessage(__setImmediate_message_id, "*");
            return __setImmediate_id_counter + __setImmediate_queue.push(func2) - 1;
          };
          emClearImmediate = (id) => {
            var index = id - __setImmediate_id_counter;
            if (index >= 0 && index < __setImmediate_queue.length)
              __setImmediate_queue[index] = () => {
              };
          };
        }
        UnboundTypeError = Module["UnboundTypeError"] = extendError(Error, "UnboundTypeError");
        PureVirtualError = Module["PureVirtualError"] = extendError(Error, "PureVirtualError");
        init_embind();
        init_RegisteredPointer();
        init_ClassHandle();
        var wasmImports = {
          IMG_Init: _IMG_Init,
          IMG_Load: _IMG_Load,
          IMG_Load_RW: _IMG_Load_RW,
          IMG_Quit: _IMG_Quit,
          Mix_AllocateChannels: _Mix_AllocateChannels,
          Mix_ChannelFinished: _Mix_ChannelFinished,
          Mix_CloseAudio: _Mix_CloseAudio,
          Mix_FadeInChannelTimed: _Mix_FadeInChannelTimed,
          Mix_FadeInMusicPos: _Mix_FadeInMusicPos,
          Mix_FadeOutChannel: _Mix_FadeOutChannel,
          Mix_FadeOutMusic: _Mix_FadeOutMusic,
          Mix_FadingChannel: _Mix_FadingChannel,
          Mix_FreeChunk: _Mix_FreeChunk,
          Mix_FreeMusic: _Mix_FreeMusic,
          Mix_HaltChannel: _Mix_HaltChannel,
          Mix_HaltMusic: _Mix_HaltMusic,
          Mix_HookMusicFinished: _Mix_HookMusicFinished,
          Mix_Init: _Mix_Init,
          Mix_Linked_Version: _Mix_Linked_Version,
          Mix_LoadMUS: _Mix_LoadMUS,
          Mix_LoadMUS_RW: _Mix_LoadMUS_RW,
          Mix_LoadWAV: _Mix_LoadWAV,
          Mix_LoadWAV_RW: _Mix_LoadWAV_RW,
          Mix_OpenAudio: _Mix_OpenAudio,
          Mix_Pause: _Mix_Pause,
          Mix_PauseMusic: _Mix_PauseMusic,
          Mix_Paused: _Mix_Paused,
          Mix_PausedMusic: _Mix_PausedMusic,
          Mix_PlayChannelTimed: _Mix_PlayChannelTimed,
          Mix_PlayMusic: _Mix_PlayMusic,
          Mix_Playing: _Mix_Playing,
          Mix_PlayingMusic: _Mix_PlayingMusic,
          Mix_QuerySpec: _Mix_QuerySpec,
          Mix_QuickLoad_RAW: _Mix_QuickLoad_RAW,
          Mix_Quit: _Mix_Quit,
          Mix_ReserveChannels: _Mix_ReserveChannels,
          Mix_Resume: _Mix_Resume,
          Mix_ResumeMusic: _Mix_ResumeMusic,
          Mix_SetPanning: _Mix_SetPanning,
          Mix_SetPosition: _Mix_SetPosition,
          Mix_SetPostMix: _Mix_SetPostMix,
          Mix_Volume: _Mix_Volume,
          Mix_VolumeChunk: _Mix_VolumeChunk,
          Mix_VolumeMusic: _Mix_VolumeMusic,
          SDL_AddTimer: _SDL_AddTimer,
          SDL_AllocRW: _SDL_AllocRW,
          SDL_AudioDriverName: _SDL_AudioDriverName,
          SDL_AudioQuit: _SDL_AudioQuit,
          SDL_ClearError: _SDL_ClearError,
          SDL_CloseAudio: _SDL_CloseAudio,
          SDL_CondBroadcast: _SDL_CondBroadcast,
          SDL_CondSignal: _SDL_CondSignal,
          SDL_CondWait: _SDL_CondWait,
          SDL_CondWaitTimeout: _SDL_CondWaitTimeout,
          SDL_ConvertSurface: _SDL_ConvertSurface,
          SDL_CreateCond: _SDL_CreateCond,
          SDL_CreateMutex: _SDL_CreateMutex,
          SDL_CreateRGBSurface: _SDL_CreateRGBSurface,
          SDL_CreateRGBSurfaceFrom: _SDL_CreateRGBSurfaceFrom,
          SDL_CreateThread: _SDL_CreateThread,
          SDL_Delay: _SDL_Delay,
          SDL_DestroyCond: _SDL_DestroyCond,
          SDL_DestroyMutex: _SDL_DestroyMutex,
          SDL_DestroyRenderer: _SDL_DestroyRenderer,
          SDL_DestroyWindow: _SDL_DestroyWindow,
          SDL_DisplayFormatAlpha: _SDL_DisplayFormatAlpha,
          SDL_EnableKeyRepeat: _SDL_EnableKeyRepeat,
          SDL_EnableUNICODE: _SDL_EnableUNICODE,
          SDL_FillRect: _SDL_FillRect,
          SDL_Flip: _SDL_Flip,
          SDL_FreeRW: _SDL_FreeRW,
          SDL_FreeSurface: _SDL_FreeSurface,
          SDL_GL_DeleteContext: _SDL_GL_DeleteContext,
          SDL_GL_ExtensionSupported: _SDL_GL_ExtensionSupported,
          SDL_GL_GetAttribute: _SDL_GL_GetAttribute,
          SDL_GL_GetSwapInterval: _SDL_GL_GetSwapInterval,
          SDL_GL_MakeCurrent: _SDL_GL_MakeCurrent,
          SDL_GL_SetAttribute: _SDL_GL_SetAttribute,
          SDL_GL_SetSwapInterval: _SDL_GL_SetSwapInterval,
          SDL_GL_SwapBuffers: _SDL_GL_SwapBuffers,
          SDL_GL_SwapWindow: _SDL_GL_SwapWindow,
          SDL_GetAppState: _SDL_GetAppState,
          SDL_GetAudioDriver: _SDL_GetAudioDriver,
          SDL_GetClipRect: _SDL_GetClipRect,
          SDL_GetCurrentAudioDriver: _SDL_GetCurrentAudioDriver,
          SDL_GetError: _SDL_GetError,
          SDL_GetKeyName: _SDL_GetKeyName,
          SDL_GetKeyState: _SDL_GetKeyState,
          SDL_GetKeyboardState: _SDL_GetKeyboardState,
          SDL_GetModState: _SDL_GetModState,
          SDL_GetMouseState: _SDL_GetMouseState,
          SDL_GetNumAudioDrivers: _SDL_GetNumAudioDrivers,
          SDL_GetRGB: _SDL_GetRGB,
          SDL_GetRGBA: _SDL_GetRGBA,
          SDL_GetScancodeFromKey: _SDL_GetScancodeFromKey,
          SDL_GetThreadID: _SDL_GetThreadID,
          SDL_GetTicks: _SDL_GetTicks,
          SDL_GetVideoInfo: _SDL_GetVideoInfo,
          SDL_GetVideoSurface: _SDL_GetVideoSurface,
          SDL_GetWindowFlags: _SDL_GetWindowFlags,
          SDL_GetWindowSize: _SDL_GetWindowSize,
          SDL_Has3DNow: _SDL_Has3DNow,
          SDL_Has3DNowExt: _SDL_Has3DNowExt,
          SDL_HasAltiVec: _SDL_HasAltiVec,
          SDL_HasMMX: _SDL_HasMMX,
          SDL_HasMMXExt: _SDL_HasMMXExt,
          SDL_HasRDTSC: _SDL_HasRDTSC,
          SDL_HasSSE: _SDL_HasSSE,
          SDL_HasSSE2: _SDL_HasSSE2,
          SDL_Init: _SDL_Init,
          SDL_InitSubSystem: _SDL_InitSubSystem,
          SDL_JoystickClose: _SDL_JoystickClose,
          SDL_JoystickEventState: _SDL_JoystickEventState,
          SDL_JoystickGetAxis: _SDL_JoystickGetAxis,
          SDL_JoystickGetBall: _SDL_JoystickGetBall,
          SDL_JoystickGetButton: _SDL_JoystickGetButton,
          SDL_JoystickGetHat: _SDL_JoystickGetHat,
          SDL_JoystickIndex: _SDL_JoystickIndex,
          SDL_JoystickName: _SDL_JoystickName,
          SDL_JoystickNumAxes: _SDL_JoystickNumAxes,
          SDL_JoystickNumBalls: _SDL_JoystickNumBalls,
          SDL_JoystickNumButtons: _SDL_JoystickNumButtons,
          SDL_JoystickNumHats: _SDL_JoystickNumHats,
          SDL_JoystickOpen: _SDL_JoystickOpen,
          SDL_JoystickOpened: _SDL_JoystickOpened,
          SDL_JoystickUpdate: _SDL_JoystickUpdate,
          SDL_Linked_Version: _SDL_Linked_Version,
          SDL_ListModes: _SDL_ListModes,
          SDL_LoadBMP_RW: _SDL_LoadBMP_RW,
          SDL_LockAudio: _SDL_LockAudio,
          SDL_LockSurface: _SDL_LockSurface,
          SDL_LogSetOutputFunction: _SDL_LogSetOutputFunction,
          SDL_LowerBlit: _SDL_LowerBlit,
          SDL_LowerBlitScaled: _SDL_LowerBlitScaled,
          SDL_MapRGB: _SDL_MapRGB,
          SDL_MapRGBA: _SDL_MapRGBA,
          SDL_NumJoysticks: _SDL_NumJoysticks,
          SDL_OpenAudio: _SDL_OpenAudio,
          SDL_PauseAudio: _SDL_PauseAudio,
          SDL_PeepEvents: _SDL_PeepEvents,
          SDL_PollEvent: _SDL_PollEvent,
          SDL_PumpEvents: _SDL_PumpEvents,
          SDL_PushEvent: _SDL_PushEvent,
          SDL_Quit: _SDL_Quit,
          SDL_QuitSubSystem: _SDL_QuitSubSystem,
          SDL_RWFromConstMem: _SDL_RWFromConstMem,
          SDL_RWFromFile: _SDL_RWFromFile,
          SDL_RWFromMem: _SDL_RWFromMem,
          SDL_RemoveTimer: _SDL_RemoveTimer,
          SDL_SaveBMP_RW: _SDL_SaveBMP_RW,
          SDL_SetAlpha: _SDL_SetAlpha,
          SDL_SetClipRect: _SDL_SetClipRect,
          SDL_SetColorKey: _SDL_SetColorKey,
          SDL_SetColors: _SDL_SetColors,
          SDL_SetError: _SDL_SetError,
          SDL_SetGamma: _SDL_SetGamma,
          SDL_SetGammaRamp: _SDL_SetGammaRamp,
          SDL_SetPalette: _SDL_SetPalette,
          SDL_SetVideoMode: _SDL_SetVideoMode,
          SDL_SetWindowFullscreen: _SDL_SetWindowFullscreen,
          SDL_SetWindowTitle: _SDL_SetWindowTitle,
          SDL_ShowCursor: _SDL_ShowCursor,
          SDL_StartTextInput: _SDL_StartTextInput,
          SDL_StopTextInput: _SDL_StopTextInput,
          SDL_ThreadID: _SDL_ThreadID,
          SDL_UnlockAudio: _SDL_UnlockAudio,
          SDL_UnlockSurface: _SDL_UnlockSurface,
          SDL_UpdateRect: _SDL_UpdateRect,
          SDL_UpdateRects: _SDL_UpdateRects,
          SDL_UpperBlit: _SDL_UpperBlit,
          SDL_UpperBlitScaled: _SDL_UpperBlitScaled,
          SDL_VideoDriverName: _SDL_VideoDriverName,
          SDL_VideoModeOK: _SDL_VideoModeOK,
          SDL_VideoQuit: _SDL_VideoQuit,
          SDL_WM_GrabInput: _SDL_WM_GrabInput,
          SDL_WM_IconifyWindow: _SDL_WM_IconifyWindow,
          SDL_WM_SetCaption: _SDL_WM_SetCaption,
          SDL_WM_SetIcon: _SDL_WM_SetIcon,
          SDL_WM_ToggleFullScreen: _SDL_WM_ToggleFullScreen,
          SDL_WaitThread: _SDL_WaitThread,
          SDL_WarpMouse: _SDL_WarpMouse,
          SDL_WasInit: _SDL_WasInit,
          SDL_mutexP: _SDL_mutexP,
          SDL_mutexV: _SDL_mutexV,
          TTF_CloseFont: _TTF_CloseFont,
          TTF_FontAscent: _TTF_FontAscent,
          TTF_FontDescent: _TTF_FontDescent,
          TTF_FontHeight: _TTF_FontHeight,
          TTF_FontLineSkip: _TTF_FontLineSkip,
          TTF_GlyphMetrics: _TTF_GlyphMetrics,
          TTF_Init: _TTF_Init,
          TTF_OpenFont: _TTF_OpenFont,
          TTF_Quit: _TTF_Quit,
          TTF_RenderText_Blended: _TTF_RenderText_Blended,
          TTF_RenderText_Shaded: _TTF_RenderText_Shaded,
          TTF_RenderText_Solid: _TTF_RenderText_Solid,
          TTF_RenderUTF8_Solid: _TTF_RenderUTF8_Solid,
          TTF_SizeText: _TTF_SizeText,
          TTF_SizeUTF8: _TTF_SizeUTF8,
          XChangeWindowAttributes: _XChangeWindowAttributes,
          XCreateWindow: _XCreateWindow,
          XInternAtom: _XInternAtom,
          XMapWindow: _XMapWindow,
          XOpenDisplay: _XOpenDisplay,
          XPending: _XPending,
          XSendEvent: _XSendEvent,
          XSetWMHints: _XSetWMHints,
          XStoreName: _XStoreName,
          _Unwind_Backtrace: __Unwind_Backtrace,
          _Unwind_FindEnclosingFunction: __Unwind_FindEnclosingFunction,
          _Unwind_GetIPInfo: __Unwind_GetIPInfo,
          __asctime_r: ___asctime_r,
          __assert_fail: ___assert_fail,
          __c_longjmp: ___c_longjmp,
          __call_sighandler: ___call_sighandler,
          __cpp_exception: ___cpp_exception,
          __global_base: ___global_base,
          __heap_base: ___heap_base,
          __indirect_function_table: wasmTable,
          __memory_base: ___memory_base,
          __stack_high: ___stack_high,
          __stack_low: ___stack_low,
          __stack_pointer: ___stack_pointer,
          __syscall__newselect: ___syscall__newselect,
          __syscall_accept4: ___syscall_accept4,
          __syscall_bind: ___syscall_bind,
          __syscall_chdir: ___syscall_chdir,
          __syscall_chmod: ___syscall_chmod,
          __syscall_connect: ___syscall_connect,
          __syscall_dup: ___syscall_dup,
          __syscall_dup3: ___syscall_dup3,
          __syscall_faccessat: ___syscall_faccessat,
          __syscall_fadvise64: ___syscall_fadvise64,
          __syscall_fallocate: ___syscall_fallocate,
          __syscall_fchdir: ___syscall_fchdir,
          __syscall_fchmod: ___syscall_fchmod,
          __syscall_fchmodat: ___syscall_fchmodat,
          __syscall_fchown32: ___syscall_fchown32,
          __syscall_fchownat: ___syscall_fchownat,
          __syscall_fcntl64: ___syscall_fcntl64,
          __syscall_fdatasync: ___syscall_fdatasync,
          __syscall_fstat64: ___syscall_fstat64,
          __syscall_fstatfs64: ___syscall_fstatfs64,
          __syscall_ftruncate64: ___syscall_ftruncate64,
          __syscall_getcwd: ___syscall_getcwd,
          __syscall_getdents64: ___syscall_getdents64,
          __syscall_getpeername: ___syscall_getpeername,
          __syscall_getsockname: ___syscall_getsockname,
          __syscall_getsockopt: ___syscall_getsockopt,
          __syscall_ioctl: ___syscall_ioctl,
          __syscall_listen: ___syscall_listen,
          __syscall_lstat64: ___syscall_lstat64,
          __syscall_mkdirat: ___syscall_mkdirat,
          __syscall_mknodat: ___syscall_mknodat,
          __syscall_newfstatat: ___syscall_newfstatat,
          __syscall_openat: ___syscall_openat,
          __syscall_pipe: ___syscall_pipe,
          __syscall_poll: ___syscall_poll,
          __syscall_readlinkat: ___syscall_readlinkat,
          __syscall_recvfrom: ___syscall_recvfrom,
          __syscall_recvmsg: ___syscall_recvmsg,
          __syscall_renameat: ___syscall_renameat,
          __syscall_rmdir: ___syscall_rmdir,
          __syscall_sendmsg: ___syscall_sendmsg,
          __syscall_sendto: ___syscall_sendto,
          __syscall_socket: ___syscall_socket,
          __syscall_stat64: ___syscall_stat64,
          __syscall_statfs64: ___syscall_statfs64,
          __syscall_symlink: ___syscall_symlink,
          __syscall_symlinkat: ___syscall_symlinkat,
          __syscall_truncate64: ___syscall_truncate64,
          __syscall_unlinkat: ___syscall_unlinkat,
          __syscall_utimensat: ___syscall_utimensat,
          __table_base: ___table_base,
          _dlopen_js: __dlopen_js,
          _dlsym_catchup_js: __dlsym_catchup_js,
          _dlsym_js: __dlsym_js,
          _embind_create_inheriting_constructor: __embind_create_inheriting_constructor,
          _embind_finalize_value_array: __embind_finalize_value_array,
          _embind_finalize_value_object: __embind_finalize_value_object,
          _embind_register_bigint: __embind_register_bigint,
          _embind_register_bool: __embind_register_bool,
          _embind_register_class: __embind_register_class,
          _embind_register_class_class_function: __embind_register_class_class_function,
          _embind_register_class_class_property: __embind_register_class_class_property,
          _embind_register_class_constructor: __embind_register_class_constructor,
          _embind_register_class_function: __embind_register_class_function,
          _embind_register_class_property: __embind_register_class_property,
          _embind_register_constant: __embind_register_constant,
          _embind_register_emval: __embind_register_emval,
          _embind_register_enum: __embind_register_enum,
          _embind_register_enum_value: __embind_register_enum_value,
          _embind_register_float: __embind_register_float,
          _embind_register_function: __embind_register_function,
          _embind_register_integer: __embind_register_integer,
          _embind_register_memory_view: __embind_register_memory_view,
          _embind_register_optional: __embind_register_optional,
          _embind_register_smart_ptr: __embind_register_smart_ptr,
          _embind_register_std_string: __embind_register_std_string,
          _embind_register_std_wstring: __embind_register_std_wstring,
          _embind_register_user_type: __embind_register_user_type,
          _embind_register_value_array: __embind_register_value_array,
          _embind_register_value_array_element: __embind_register_value_array_element,
          _embind_register_value_object: __embind_register_value_object,
          _embind_register_value_object_field: __embind_register_value_object_field,
          _embind_register_void: __embind_register_void,
          _emscripten_dlopen_js: __emscripten_dlopen_js,
          _emscripten_fs_load_embedded_files: __emscripten_fs_load_embedded_files,
          _emscripten_get_now_is_monotonic: __emscripten_get_now_is_monotonic,
          _emscripten_get_progname: __emscripten_get_progname,
          _emscripten_lookup_name: __emscripten_lookup_name,
          _emscripten_push_main_loop_blocker: __emscripten_push_main_loop_blocker,
          _emscripten_push_uncounted_main_loop_blocker: __emscripten_push_uncounted_main_loop_blocker,
          _emscripten_runtime_keepalive_clear: __emscripten_runtime_keepalive_clear,
          _emscripten_set_offscreencanvas_size: __emscripten_set_offscreencanvas_size,
          _emscripten_system: __emscripten_system,
          _emval_as: __emval_as,
          _emval_as_int64: __emval_as_int64,
          _emval_as_uint64: __emval_as_uint64,
          _emval_call: __emval_call,
          _emval_call_method: __emval_call_method,
          _emval_coro_make_promise: __emval_coro_make_promise,
          _emval_coro_suspend: __emval_coro_suspend,
          _emval_decref: __emval_decref,
          _emval_delete: __emval_delete,
          _emval_equals: __emval_equals,
          _emval_get_global: __emval_get_global,
          _emval_get_method_caller: __emval_get_method_caller,
          _emval_get_module_property: __emval_get_module_property,
          _emval_get_property: __emval_get_property,
          _emval_greater_than: __emval_greater_than,
          _emval_in: __emval_in,
          _emval_incref: __emval_incref,
          _emval_instanceof: __emval_instanceof,
          _emval_is_number: __emval_is_number,
          _emval_is_string: __emval_is_string,
          _emval_iter_begin: __emval_iter_begin,
          _emval_iter_next: __emval_iter_next,
          _emval_less_than: __emval_less_than,
          _emval_new_array: __emval_new_array,
          _emval_new_array_from_memory_view: __emval_new_array_from_memory_view,
          _emval_new_cstring: __emval_new_cstring,
          _emval_new_object: __emval_new_object,
          _emval_new_u16string: __emval_new_u16string,
          _emval_new_u8string: __emval_new_u8string,
          _emval_not: __emval_not,
          _emval_register_symbol: __emval_register_symbol,
          _emval_run_destructors: __emval_run_destructors,
          _emval_set_property: __emval_set_property,
          _emval_strictly_equals: __emval_strictly_equals,
          _emval_take_value: __emval_take_value,
          _emval_throw: __emval_throw,
          _emval_typeof: __emval_typeof,
          _glGenObject: __glGenObject,
          _glGetActiveAttribOrUniform: __glGetActiveAttribOrUniform,
          _gmtime_js: __gmtime_js,
          _localtime_js: __localtime_js,
          _mktime_js: __mktime_js,
          _mmap_js: __mmap_js,
          _msync_js: __msync_js,
          _munmap_js: __munmap_js,
          _setitimer_js: __setitimer_js,
          _timegm_js: __timegm_js,
          _tzset_js: __tzset_js,
          abort: _abort,
          alBuffer3f: _alBuffer3f,
          alBuffer3i: _alBuffer3i,
          alBufferData: _alBufferData,
          alBufferf: _alBufferf,
          alBufferfv: _alBufferfv,
          alBufferi: _alBufferi,
          alBufferiv: _alBufferiv,
          alDeleteBuffers: _alDeleteBuffers,
          alDeleteSources: _alDeleteSources,
          alDisable: _alDisable,
          alDistanceModel: _alDistanceModel,
          alDopplerFactor: _alDopplerFactor,
          alDopplerVelocity: _alDopplerVelocity,
          alEnable: _alEnable,
          alGenBuffers: _alGenBuffers,
          alGenSources: _alGenSources,
          alGetBoolean: _alGetBoolean,
          alGetBooleanv: _alGetBooleanv,
          alGetBuffer3f: _alGetBuffer3f,
          alGetBuffer3i: _alGetBuffer3i,
          alGetBufferf: _alGetBufferf,
          alGetBufferfv: _alGetBufferfv,
          alGetBufferi: _alGetBufferi,
          alGetBufferiv: _alGetBufferiv,
          alGetDouble: _alGetDouble,
          alGetDoublev: _alGetDoublev,
          alGetEnumValue: _alGetEnumValue,
          alGetError: _alGetError,
          alGetFloat: _alGetFloat,
          alGetFloatv: _alGetFloatv,
          alGetInteger: _alGetInteger,
          alGetIntegerv: _alGetIntegerv,
          alGetListener3f: _alGetListener3f,
          alGetListener3i: _alGetListener3i,
          alGetListenerf: _alGetListenerf,
          alGetListenerfv: _alGetListenerfv,
          alGetListeneri: _alGetListeneri,
          alGetListeneriv: _alGetListeneriv,
          alGetSource3f: _alGetSource3f,
          alGetSource3i: _alGetSource3i,
          alGetSourcef: _alGetSourcef,
          alGetSourcefv: _alGetSourcefv,
          alGetSourcei: _alGetSourcei,
          alGetSourceiv: _alGetSourceiv,
          alGetString: _alGetString,
          alIsBuffer: _alIsBuffer,
          alIsEnabled: _alIsEnabled,
          alIsExtensionPresent: _alIsExtensionPresent,
          alIsSource: _alIsSource,
          alListener3f: _alListener3f,
          alListener3i: _alListener3i,
          alListenerf: _alListenerf,
          alListenerfv: _alListenerfv,
          alListeneri: _alListeneri,
          alListeneriv: _alListeneriv,
          alSource3f: _alSource3f,
          alSource3i: _alSource3i,
          alSourcePause: _alSourcePause,
          alSourcePausev: _alSourcePausev,
          alSourcePlay: _alSourcePlay,
          alSourcePlayv: _alSourcePlayv,
          alSourceQueueBuffers: _alSourceQueueBuffers,
          alSourceRewind: _alSourceRewind,
          alSourceRewindv: _alSourceRewindv,
          alSourceStop: _alSourceStop,
          alSourceStopv: _alSourceStopv,
          alSourceUnqueueBuffers: _alSourceUnqueueBuffers,
          alSourcef: _alSourcef,
          alSourcefv: _alSourcefv,
          alSourcei: _alSourcei,
          alSourceiv: _alSourceiv,
          alSpeedOfSound: _alSpeedOfSound,
          alcCaptureCloseDevice: _alcCaptureCloseDevice,
          alcCaptureOpenDevice: _alcCaptureOpenDevice,
          alcCaptureSamples: _alcCaptureSamples,
          alcCaptureStart: _alcCaptureStart,
          alcCaptureStop: _alcCaptureStop,
          alcCloseDevice: _alcCloseDevice,
          alcCreateContext: _alcCreateContext,
          alcDestroyContext: _alcDestroyContext,
          alcGetContextsDevice: _alcGetContextsDevice,
          alcGetCurrentContext: _alcGetCurrentContext,
          alcGetEnumValue: _alcGetEnumValue,
          alcGetError: _alcGetError,
          alcGetIntegerv: _alcGetIntegerv,
          alcGetString: _alcGetString,
          alcIsExtensionPresent: _alcIsExtensionPresent,
          alcMakeContextCurrent: _alcMakeContextCurrent,
          alcOpenDevice: _alcOpenDevice,
          alcProcessContext: _alcProcessContext,
          alcSuspendContext: _alcSuspendContext,
          boxColor: _boxColor,
          boxRGBA: _boxRGBA,
          clock_res_get: _clock_res_get,
          clock_time_get: _clock_time_get,
          duckdb_web_fs_directory_create: _duckdb_web_fs_directory_create,
          duckdb_web_fs_directory_exists: _duckdb_web_fs_directory_exists,
          duckdb_web_fs_directory_list_files: _duckdb_web_fs_directory_list_files,
          duckdb_web_fs_directory_remove: _duckdb_web_fs_directory_remove,
          duckdb_web_fs_file_close: _duckdb_web_fs_file_close,
          duckdb_web_fs_file_exists: _duckdb_web_fs_file_exists,
          duckdb_web_fs_file_get_last_modified_time: _duckdb_web_fs_file_get_last_modified_time,
          duckdb_web_fs_file_move: _duckdb_web_fs_file_move,
          duckdb_web_fs_file_open: _duckdb_web_fs_file_open,
          duckdb_web_fs_file_read: _duckdb_web_fs_file_read,
          duckdb_web_fs_file_remove: _duckdb_web_fs_file_remove,
          duckdb_web_fs_file_sync: _duckdb_web_fs_file_sync,
          duckdb_web_fs_file_truncate: _duckdb_web_fs_file_truncate,
          duckdb_web_fs_file_write: _duckdb_web_fs_file_write,
          duckdb_web_fs_get_default_data_protocol: _duckdb_web_fs_get_default_data_protocol,
          duckdb_web_fs_glob: _duckdb_web_fs_glob,
          duckdb_web_test_platform_feature: _duckdb_web_test_platform_feature,
          duckdb_web_udf_scalar_call: _duckdb_web_udf_scalar_call,
          eglBindAPI: _eglBindAPI,
          eglChooseConfig: _eglChooseConfig,
          eglCreateContext: _eglCreateContext,
          eglCreateWindowSurface: _eglCreateWindowSurface,
          eglDestroyContext: _eglDestroyContext,
          eglDestroySurface: _eglDestroySurface,
          eglGetConfigAttrib: _eglGetConfigAttrib,
          eglGetConfigs: _eglGetConfigs,
          eglGetCurrentContext: _eglGetCurrentContext,
          eglGetCurrentDisplay: _eglGetCurrentDisplay,
          eglGetCurrentSurface: _eglGetCurrentSurface,
          eglGetDisplay: _eglGetDisplay,
          eglGetError: _eglGetError,
          eglInitialize: _eglInitialize,
          eglMakeCurrent: _eglMakeCurrent,
          eglQueryAPI: _eglQueryAPI,
          eglQueryContext: _eglQueryContext,
          eglQueryString: _eglQueryString,
          eglQuerySurface: _eglQuerySurface,
          eglReleaseThread: _eglReleaseThread,
          eglSwapBuffers: _eglSwapBuffers,
          eglSwapInterval: _eglSwapInterval,
          eglTerminate: _eglTerminate,
          eglWaitClient: _eglWaitClient,
          eglWaitGL: _eglWaitGL,
          eglWaitNative: _eglWaitNative,
          ellipseColor: _ellipseColor,
          ellipseRGBA: _ellipseRGBA,
          emscripten_SDL_SetEventHandler: _emscripten_SDL_SetEventHandler,
          emscripten_alcDevicePauseSOFT: _emscripten_alcDevicePauseSOFT,
          emscripten_alcDeviceResumeSOFT: _emscripten_alcDeviceResumeSOFT,
          emscripten_alcGetStringiSOFT: _emscripten_alcGetStringiSOFT,
          emscripten_alcResetDeviceSOFT: _emscripten_alcResetDeviceSOFT,
          emscripten_asm_const_async_on_main_thread: _emscripten_asm_const_async_on_main_thread,
          emscripten_asm_const_double: _emscripten_asm_const_double,
          emscripten_asm_const_double_sync_on_main_thread: _emscripten_asm_const_double_sync_on_main_thread,
          emscripten_asm_const_int: _emscripten_asm_const_int,
          emscripten_asm_const_int_sync_on_main_thread: _emscripten_asm_const_int_sync_on_main_thread,
          emscripten_asm_const_ptr: _emscripten_asm_const_ptr,
          emscripten_asm_const_ptr_sync_on_main_thread: _emscripten_asm_const_ptr_sync_on_main_thread,
          emscripten_async_call: _emscripten_async_call,
          emscripten_async_load_script: _emscripten_async_load_script,
          emscripten_async_run_script: _emscripten_async_run_script,
          emscripten_async_wget: _emscripten_async_wget,
          emscripten_async_wget2: _emscripten_async_wget2,
          emscripten_async_wget2_abort: _emscripten_async_wget2_abort,
          emscripten_async_wget2_data: _emscripten_async_wget2_data,
          emscripten_async_wget_data: _emscripten_async_wget_data,
          emscripten_call_worker: _emscripten_call_worker,
          emscripten_cancel_animation_frame: _emscripten_cancel_animation_frame,
          emscripten_cancel_main_loop: _emscripten_cancel_main_loop,
          emscripten_clear_immediate: _emscripten_clear_immediate,
          emscripten_clear_interval: _emscripten_clear_interval,
          emscripten_clear_timeout: _emscripten_clear_timeout,
          emscripten_console_error: _emscripten_console_error,
          emscripten_console_log: _emscripten_console_log,
          emscripten_console_warn: _emscripten_console_warn,
          emscripten_create_worker: _emscripten_create_worker,
          emscripten_date_now: _emscripten_date_now,
          emscripten_debugger: _emscripten_debugger,
          emscripten_destroy_worker: _emscripten_destroy_worker,
          emscripten_enter_soft_fullscreen: _emscripten_enter_soft_fullscreen,
          emscripten_err: _emscripten_err,
          emscripten_errn: _emscripten_errn,
          emscripten_exit_fullscreen: _emscripten_exit_fullscreen,
          emscripten_exit_pointerlock: _emscripten_exit_pointerlock,
          emscripten_exit_soft_fullscreen: _emscripten_exit_soft_fullscreen,
          emscripten_exit_with_live_runtime: _emscripten_exit_with_live_runtime,
          emscripten_fiber_swap: _emscripten_fiber_swap,
          emscripten_force_exit: _emscripten_force_exit,
          emscripten_get_battery_status: _emscripten_get_battery_status,
          emscripten_get_callstack: _emscripten_get_callstack,
          emscripten_get_canvas_element_size: _emscripten_get_canvas_element_size,
          emscripten_get_canvas_size: _emscripten_get_canvas_size,
          emscripten_get_compiler_setting: _emscripten_get_compiler_setting,
          emscripten_get_device_pixel_ratio: _emscripten_get_device_pixel_ratio,
          emscripten_get_devicemotion_status: _emscripten_get_devicemotion_status,
          emscripten_get_deviceorientation_status: _emscripten_get_deviceorientation_status,
          emscripten_get_element_css_size: _emscripten_get_element_css_size,
          emscripten_get_fullscreen_status: _emscripten_get_fullscreen_status,
          emscripten_get_gamepad_status: _emscripten_get_gamepad_status,
          emscripten_get_heap_max: _emscripten_get_heap_max,
          emscripten_get_main_loop_timing: _emscripten_get_main_loop_timing,
          emscripten_get_module_name: _emscripten_get_module_name,
          emscripten_get_mouse_status: _emscripten_get_mouse_status,
          emscripten_get_now: _emscripten_get_now,
          emscripten_get_now_res: _emscripten_get_now_res,
          emscripten_get_num_gamepads: _emscripten_get_num_gamepads,
          emscripten_get_orientation_status: _emscripten_get_orientation_status,
          emscripten_get_pointerlock_status: _emscripten_get_pointerlock_status,
          emscripten_get_preloaded_image_data: _emscripten_get_preloaded_image_data,
          emscripten_get_preloaded_image_data_from_FILE: _emscripten_get_preloaded_image_data_from_FILE,
          emscripten_get_screen_size: _emscripten_get_screen_size,
          emscripten_get_visibility_status: _emscripten_get_visibility_status,
          emscripten_get_window_title: _emscripten_get_window_title,
          emscripten_get_worker_queue_size: _emscripten_get_worker_queue_size,
          emscripten_glActiveTexture: _emscripten_glActiveTexture,
          emscripten_glAttachShader: _emscripten_glAttachShader,
          emscripten_glBegin: _emscripten_glBegin,
          emscripten_glBeginQueryEXT: _emscripten_glBeginQueryEXT,
          emscripten_glBindAttribLocation: _emscripten_glBindAttribLocation,
          emscripten_glBindBuffer: _emscripten_glBindBuffer,
          emscripten_glBindFramebuffer: _emscripten_glBindFramebuffer,
          emscripten_glBindRenderbuffer: _emscripten_glBindRenderbuffer,
          emscripten_glBindTexture: _emscripten_glBindTexture,
          emscripten_glBindVertexArray: _emscripten_glBindVertexArray,
          emscripten_glBindVertexArrayOES: _emscripten_glBindVertexArrayOES,
          emscripten_glBlendColor: _emscripten_glBlendColor,
          emscripten_glBlendEquation: _emscripten_glBlendEquation,
          emscripten_glBlendEquationSeparate: _emscripten_glBlendEquationSeparate,
          emscripten_glBlendFunc: _emscripten_glBlendFunc,
          emscripten_glBlendFuncSeparate: _emscripten_glBlendFuncSeparate,
          emscripten_glBufferData: _emscripten_glBufferData,
          emscripten_glBufferSubData: _emscripten_glBufferSubData,
          emscripten_glCheckFramebufferStatus: _emscripten_glCheckFramebufferStatus,
          emscripten_glClear: _emscripten_glClear,
          emscripten_glClearColor: _emscripten_glClearColor,
          emscripten_glClearDepth: _emscripten_glClearDepth,
          emscripten_glClearDepthf: _emscripten_glClearDepthf,
          emscripten_glClearStencil: _emscripten_glClearStencil,
          emscripten_glColorMask: _emscripten_glColorMask,
          emscripten_glCompileShader: _emscripten_glCompileShader,
          emscripten_glCompressedTexImage2D: _emscripten_glCompressedTexImage2D,
          emscripten_glCompressedTexSubImage2D: _emscripten_glCompressedTexSubImage2D,
          emscripten_glCopyTexImage2D: _emscripten_glCopyTexImage2D,
          emscripten_glCopyTexSubImage2D: _emscripten_glCopyTexSubImage2D,
          emscripten_glCreateProgram: _emscripten_glCreateProgram,
          emscripten_glCreateShader: _emscripten_glCreateShader,
          emscripten_glCullFace: _emscripten_glCullFace,
          emscripten_glDeleteBuffers: _emscripten_glDeleteBuffers,
          emscripten_glDeleteFramebuffers: _emscripten_glDeleteFramebuffers,
          emscripten_glDeleteProgram: _emscripten_glDeleteProgram,
          emscripten_glDeleteQueriesEXT: _emscripten_glDeleteQueriesEXT,
          emscripten_glDeleteRenderbuffers: _emscripten_glDeleteRenderbuffers,
          emscripten_glDeleteShader: _emscripten_glDeleteShader,
          emscripten_glDeleteTextures: _emscripten_glDeleteTextures,
          emscripten_glDeleteVertexArrays: _emscripten_glDeleteVertexArrays,
          emscripten_glDeleteVertexArraysOES: _emscripten_glDeleteVertexArraysOES,
          emscripten_glDepthFunc: _emscripten_glDepthFunc,
          emscripten_glDepthMask: _emscripten_glDepthMask,
          emscripten_glDepthRange: _emscripten_glDepthRange,
          emscripten_glDepthRangef: _emscripten_glDepthRangef,
          emscripten_glDetachShader: _emscripten_glDetachShader,
          emscripten_glDisable: _emscripten_glDisable,
          emscripten_glDisableVertexAttribArray: _emscripten_glDisableVertexAttribArray,
          emscripten_glDrawArrays: _emscripten_glDrawArrays,
          emscripten_glDrawArraysInstanced: _emscripten_glDrawArraysInstanced,
          emscripten_glDrawArraysInstancedANGLE: _emscripten_glDrawArraysInstancedANGLE,
          emscripten_glDrawArraysInstancedARB: _emscripten_glDrawArraysInstancedARB,
          emscripten_glDrawArraysInstancedEXT: _emscripten_glDrawArraysInstancedEXT,
          emscripten_glDrawArraysInstancedNV: _emscripten_glDrawArraysInstancedNV,
          emscripten_glDrawBuffers: _emscripten_glDrawBuffers,
          emscripten_glDrawBuffersEXT: _emscripten_glDrawBuffersEXT,
          emscripten_glDrawBuffersWEBGL: _emscripten_glDrawBuffersWEBGL,
          emscripten_glDrawElements: _emscripten_glDrawElements,
          emscripten_glDrawElementsInstanced: _emscripten_glDrawElementsInstanced,
          emscripten_glDrawElementsInstancedANGLE: _emscripten_glDrawElementsInstancedANGLE,
          emscripten_glDrawElementsInstancedARB: _emscripten_glDrawElementsInstancedARB,
          emscripten_glDrawElementsInstancedEXT: _emscripten_glDrawElementsInstancedEXT,
          emscripten_glDrawElementsInstancedNV: _emscripten_glDrawElementsInstancedNV,
          emscripten_glEnable: _emscripten_glEnable,
          emscripten_glEnableVertexAttribArray: _emscripten_glEnableVertexAttribArray,
          emscripten_glEndQueryEXT: _emscripten_glEndQueryEXT,
          emscripten_glFinish: _emscripten_glFinish,
          emscripten_glFlush: _emscripten_glFlush,
          emscripten_glFramebufferRenderbuffer: _emscripten_glFramebufferRenderbuffer,
          emscripten_glFramebufferTexture2D: _emscripten_glFramebufferTexture2D,
          emscripten_glFrontFace: _emscripten_glFrontFace,
          emscripten_glGenBuffers: _emscripten_glGenBuffers,
          emscripten_glGenFramebuffers: _emscripten_glGenFramebuffers,
          emscripten_glGenQueriesEXT: _emscripten_glGenQueriesEXT,
          emscripten_glGenRenderbuffers: _emscripten_glGenRenderbuffers,
          emscripten_glGenTextures: _emscripten_glGenTextures,
          emscripten_glGenVertexArrays: _emscripten_glGenVertexArrays,
          emscripten_glGenVertexArraysOES: _emscripten_glGenVertexArraysOES,
          emscripten_glGenerateMipmap: _emscripten_glGenerateMipmap,
          emscripten_glGetActiveAttrib: _emscripten_glGetActiveAttrib,
          emscripten_glGetActiveUniform: _emscripten_glGetActiveUniform,
          emscripten_glGetAttachedShaders: _emscripten_glGetAttachedShaders,
          emscripten_glGetAttribLocation: _emscripten_glGetAttribLocation,
          emscripten_glGetBooleanv: _emscripten_glGetBooleanv,
          emscripten_glGetBufferParameteriv: _emscripten_glGetBufferParameteriv,
          emscripten_glGetError: _emscripten_glGetError,
          emscripten_glGetFloatv: _emscripten_glGetFloatv,
          emscripten_glGetFramebufferAttachmentParameteriv: _emscripten_glGetFramebufferAttachmentParameteriv,
          emscripten_glGetIntegerv: _emscripten_glGetIntegerv,
          emscripten_glGetProgramInfoLog: _emscripten_glGetProgramInfoLog,
          emscripten_glGetProgramiv: _emscripten_glGetProgramiv,
          emscripten_glGetQueryObjecti64vEXT: _emscripten_glGetQueryObjecti64vEXT,
          emscripten_glGetQueryObjectivEXT: _emscripten_glGetQueryObjectivEXT,
          emscripten_glGetQueryObjectui64vEXT: _emscripten_glGetQueryObjectui64vEXT,
          emscripten_glGetQueryObjectuivEXT: _emscripten_glGetQueryObjectuivEXT,
          emscripten_glGetQueryivEXT: _emscripten_glGetQueryivEXT,
          emscripten_glGetRenderbufferParameteriv: _emscripten_glGetRenderbufferParameteriv,
          emscripten_glGetShaderInfoLog: _emscripten_glGetShaderInfoLog,
          emscripten_glGetShaderPrecisionFormat: _emscripten_glGetShaderPrecisionFormat,
          emscripten_glGetShaderSource: _emscripten_glGetShaderSource,
          emscripten_glGetShaderiv: _emscripten_glGetShaderiv,
          emscripten_glGetString: _emscripten_glGetString,
          emscripten_glGetTexParameterfv: _emscripten_glGetTexParameterfv,
          emscripten_glGetTexParameteriv: _emscripten_glGetTexParameteriv,
          emscripten_glGetUniformLocation: _emscripten_glGetUniformLocation,
          emscripten_glGetUniformfv: _emscripten_glGetUniformfv,
          emscripten_glGetUniformiv: _emscripten_glGetUniformiv,
          emscripten_glGetVertexAttribPointerv: _emscripten_glGetVertexAttribPointerv,
          emscripten_glGetVertexAttribfv: _emscripten_glGetVertexAttribfv,
          emscripten_glGetVertexAttribiv: _emscripten_glGetVertexAttribiv,
          emscripten_glHint: _emscripten_glHint,
          emscripten_glIsBuffer: _emscripten_glIsBuffer,
          emscripten_glIsEnabled: _emscripten_glIsEnabled,
          emscripten_glIsFramebuffer: _emscripten_glIsFramebuffer,
          emscripten_glIsProgram: _emscripten_glIsProgram,
          emscripten_glIsQueryEXT: _emscripten_glIsQueryEXT,
          emscripten_glIsRenderbuffer: _emscripten_glIsRenderbuffer,
          emscripten_glIsShader: _emscripten_glIsShader,
          emscripten_glIsTexture: _emscripten_glIsTexture,
          emscripten_glIsVertexArray: _emscripten_glIsVertexArray,
          emscripten_glIsVertexArrayOES: _emscripten_glIsVertexArrayOES,
          emscripten_glLineWidth: _emscripten_glLineWidth,
          emscripten_glLinkProgram: _emscripten_glLinkProgram,
          emscripten_glLoadIdentity: _emscripten_glLoadIdentity,
          emscripten_glMatrixMode: _emscripten_glMatrixMode,
          emscripten_glMultiDrawArrays: _emscripten_glMultiDrawArrays,
          emscripten_glMultiDrawArraysANGLE: _emscripten_glMultiDrawArraysANGLE,
          emscripten_glMultiDrawArraysInstancedANGLE: _emscripten_glMultiDrawArraysInstancedANGLE,
          emscripten_glMultiDrawArraysInstancedWEBGL: _emscripten_glMultiDrawArraysInstancedWEBGL,
          emscripten_glMultiDrawArraysWEBGL: _emscripten_glMultiDrawArraysWEBGL,
          emscripten_glMultiDrawElements: _emscripten_glMultiDrawElements,
          emscripten_glMultiDrawElementsANGLE: _emscripten_glMultiDrawElementsANGLE,
          emscripten_glMultiDrawElementsInstancedANGLE: _emscripten_glMultiDrawElementsInstancedANGLE,
          emscripten_glMultiDrawElementsInstancedWEBGL: _emscripten_glMultiDrawElementsInstancedWEBGL,
          emscripten_glMultiDrawElementsWEBGL: _emscripten_glMultiDrawElementsWEBGL,
          emscripten_glPixelStorei: _emscripten_glPixelStorei,
          emscripten_glPolygonOffset: _emscripten_glPolygonOffset,
          emscripten_glQueryCounterEXT: _emscripten_glQueryCounterEXT,
          emscripten_glReadPixels: _emscripten_glReadPixels,
          emscripten_glReleaseShaderCompiler: _emscripten_glReleaseShaderCompiler,
          emscripten_glRenderbufferStorage: _emscripten_glRenderbufferStorage,
          emscripten_glSampleCoverage: _emscripten_glSampleCoverage,
          emscripten_glScissor: _emscripten_glScissor,
          emscripten_glShaderBinary: _emscripten_glShaderBinary,
          emscripten_glShaderSource: _emscripten_glShaderSource,
          emscripten_glStencilFunc: _emscripten_glStencilFunc,
          emscripten_glStencilFuncSeparate: _emscripten_glStencilFuncSeparate,
          emscripten_glStencilMask: _emscripten_glStencilMask,
          emscripten_glStencilMaskSeparate: _emscripten_glStencilMaskSeparate,
          emscripten_glStencilOp: _emscripten_glStencilOp,
          emscripten_glStencilOpSeparate: _emscripten_glStencilOpSeparate,
          emscripten_glTexImage2D: _emscripten_glTexImage2D,
          emscripten_glTexParameterf: _emscripten_glTexParameterf,
          emscripten_glTexParameterfv: _emscripten_glTexParameterfv,
          emscripten_glTexParameteri: _emscripten_glTexParameteri,
          emscripten_glTexParameteriv: _emscripten_glTexParameteriv,
          emscripten_glTexSubImage2D: _emscripten_glTexSubImage2D,
          emscripten_glUniform1f: _emscripten_glUniform1f,
          emscripten_glUniform1fv: _emscripten_glUniform1fv,
          emscripten_glUniform1i: _emscripten_glUniform1i,
          emscripten_glUniform1iv: _emscripten_glUniform1iv,
          emscripten_glUniform2f: _emscripten_glUniform2f,
          emscripten_glUniform2fv: _emscripten_glUniform2fv,
          emscripten_glUniform2i: _emscripten_glUniform2i,
          emscripten_glUniform2iv: _emscripten_glUniform2iv,
          emscripten_glUniform3f: _emscripten_glUniform3f,
          emscripten_glUniform3fv: _emscripten_glUniform3fv,
          emscripten_glUniform3i: _emscripten_glUniform3i,
          emscripten_glUniform3iv: _emscripten_glUniform3iv,
          emscripten_glUniform4f: _emscripten_glUniform4f,
          emscripten_glUniform4fv: _emscripten_glUniform4fv,
          emscripten_glUniform4i: _emscripten_glUniform4i,
          emscripten_glUniform4iv: _emscripten_glUniform4iv,
          emscripten_glUniformMatrix2fv: _emscripten_glUniformMatrix2fv,
          emscripten_glUniformMatrix3fv: _emscripten_glUniformMatrix3fv,
          emscripten_glUniformMatrix4fv: _emscripten_glUniformMatrix4fv,
          emscripten_glUseProgram: _emscripten_glUseProgram,
          emscripten_glValidateProgram: _emscripten_glValidateProgram,
          emscripten_glVertexAttrib1f: _emscripten_glVertexAttrib1f,
          emscripten_glVertexAttrib1fv: _emscripten_glVertexAttrib1fv,
          emscripten_glVertexAttrib2f: _emscripten_glVertexAttrib2f,
          emscripten_glVertexAttrib2fv: _emscripten_glVertexAttrib2fv,
          emscripten_glVertexAttrib3f: _emscripten_glVertexAttrib3f,
          emscripten_glVertexAttrib3fv: _emscripten_glVertexAttrib3fv,
          emscripten_glVertexAttrib4f: _emscripten_glVertexAttrib4f,
          emscripten_glVertexAttrib4fv: _emscripten_glVertexAttrib4fv,
          emscripten_glVertexAttribDivisor: _emscripten_glVertexAttribDivisor,
          emscripten_glVertexAttribDivisorANGLE: _emscripten_glVertexAttribDivisorANGLE,
          emscripten_glVertexAttribDivisorARB: _emscripten_glVertexAttribDivisorARB,
          emscripten_glVertexAttribDivisorEXT: _emscripten_glVertexAttribDivisorEXT,
          emscripten_glVertexAttribDivisorNV: _emscripten_glVertexAttribDivisorNV,
          emscripten_glVertexAttribPointer: _emscripten_glVertexAttribPointer,
          emscripten_glVertexPointer: _emscripten_glVertexPointer,
          emscripten_glViewport: _emscripten_glViewport,
          emscripten_has_asyncify: _emscripten_has_asyncify,
          emscripten_hide_mouse: _emscripten_hide_mouse,
          emscripten_html5_remove_all_event_listeners: _emscripten_html5_remove_all_event_listeners,
          emscripten_idb_async_clear: _emscripten_idb_async_clear,
          emscripten_idb_async_delete: _emscripten_idb_async_delete,
          emscripten_idb_async_exists: _emscripten_idb_async_exists,
          emscripten_idb_async_load: _emscripten_idb_async_load,
          emscripten_idb_async_store: _emscripten_idb_async_store,
          emscripten_idb_clear: _emscripten_idb_clear,
          emscripten_idb_delete: _emscripten_idb_delete,
          emscripten_idb_exists: _emscripten_idb_exists,
          emscripten_idb_load: _emscripten_idb_load,
          emscripten_idb_store: _emscripten_idb_store,
          emscripten_is_main_browser_thread: _emscripten_is_main_browser_thread,
          emscripten_is_webgl_context_lost: _emscripten_is_webgl_context_lost,
          emscripten_lock_orientation: _emscripten_lock_orientation,
          emscripten_log: _emscripten_log,
          emscripten_math_acos: _emscripten_math_acos,
          emscripten_math_acosh: _emscripten_math_acosh,
          emscripten_math_asin: _emscripten_math_asin,
          emscripten_math_asinh: _emscripten_math_asinh,
          emscripten_math_atan: _emscripten_math_atan,
          emscripten_math_atan2: _emscripten_math_atan2,
          emscripten_math_atanh: _emscripten_math_atanh,
          emscripten_math_cbrt: _emscripten_math_cbrt,
          emscripten_math_cos: _emscripten_math_cos,
          emscripten_math_cosh: _emscripten_math_cosh,
          emscripten_math_exp: _emscripten_math_exp,
          emscripten_math_expm1: _emscripten_math_expm1,
          emscripten_math_fmod: _emscripten_math_fmod,
          emscripten_math_hypot: _emscripten_math_hypot,
          emscripten_math_log: _emscripten_math_log,
          emscripten_math_log10: _emscripten_math_log10,
          emscripten_math_log1p: _emscripten_math_log1p,
          emscripten_math_log2: _emscripten_math_log2,
          emscripten_math_pow: _emscripten_math_pow,
          emscripten_math_random: _emscripten_math_random,
          emscripten_math_round: _emscripten_math_round,
          emscripten_math_sign: _emscripten_math_sign,
          emscripten_math_sin: _emscripten_math_sin,
          emscripten_math_sinh: _emscripten_math_sinh,
          emscripten_math_sqrt: _emscripten_math_sqrt,
          emscripten_math_tan: _emscripten_math_tan,
          emscripten_math_tanh: _emscripten_math_tanh,
          emscripten_memcpy_js: _emscripten_memcpy_js,
          emscripten_notify_memory_growth: _emscripten_notify_memory_growth,
          emscripten_out: _emscripten_out,
          emscripten_outn: _emscripten_outn,
          emscripten_pause_main_loop: _emscripten_pause_main_loop,
          emscripten_pc_get_column: _emscripten_pc_get_column,
          emscripten_pc_get_file: _emscripten_pc_get_file,
          emscripten_pc_get_function: _emscripten_pc_get_function,
          emscripten_pc_get_line: _emscripten_pc_get_line,
          emscripten_performance_now: _emscripten_performance_now,
          emscripten_print_double: _emscripten_print_double,
          emscripten_promise_all: _emscripten_promise_all,
          emscripten_promise_all_settled: _emscripten_promise_all_settled,
          emscripten_promise_any: _emscripten_promise_any,
          emscripten_promise_await: _emscripten_promise_await,
          emscripten_promise_create: _emscripten_promise_create,
          emscripten_promise_destroy: _emscripten_promise_destroy,
          emscripten_promise_race: _emscripten_promise_race,
          emscripten_promise_resolve: _emscripten_promise_resolve,
          emscripten_promise_then: _emscripten_promise_then,
          emscripten_random: _emscripten_random,
          emscripten_request_animation_frame: _emscripten_request_animation_frame,
          emscripten_request_animation_frame_loop: _emscripten_request_animation_frame_loop,
          emscripten_request_fullscreen: _emscripten_request_fullscreen,
          emscripten_request_fullscreen_strategy: _emscripten_request_fullscreen_strategy,
          emscripten_request_pointerlock: _emscripten_request_pointerlock,
          emscripten_resize_heap: _emscripten_resize_heap,
          emscripten_resume_main_loop: _emscripten_resume_main_loop,
          emscripten_return_address: _emscripten_return_address,
          emscripten_run_preload_plugins: _emscripten_run_preload_plugins,
          emscripten_run_preload_plugins_data: _emscripten_run_preload_plugins_data,
          emscripten_run_script: _emscripten_run_script,
          emscripten_run_script_int: _emscripten_run_script_int,
          emscripten_run_script_string: _emscripten_run_script_string,
          emscripten_runtime_keepalive_check: _emscripten_runtime_keepalive_check,
          emscripten_runtime_keepalive_pop: _emscripten_runtime_keepalive_pop,
          emscripten_runtime_keepalive_push: _emscripten_runtime_keepalive_push,
          emscripten_sample_gamepad_data: _emscripten_sample_gamepad_data,
          emscripten_scan_registers: _emscripten_scan_registers,
          emscripten_set_batterychargingchange_callback_on_thread: _emscripten_set_batterychargingchange_callback_on_thread,
          emscripten_set_batterylevelchange_callback_on_thread: _emscripten_set_batterylevelchange_callback_on_thread,
          emscripten_set_beforeunload_callback_on_thread: _emscripten_set_beforeunload_callback_on_thread,
          emscripten_set_blur_callback_on_thread: _emscripten_set_blur_callback_on_thread,
          emscripten_set_canvas_element_size: _emscripten_set_canvas_element_size,
          emscripten_set_canvas_size: _emscripten_set_canvas_size,
          emscripten_set_click_callback_on_thread: _emscripten_set_click_callback_on_thread,
          emscripten_set_dblclick_callback_on_thread: _emscripten_set_dblclick_callback_on_thread,
          emscripten_set_devicemotion_callback_on_thread: _emscripten_set_devicemotion_callback_on_thread,
          emscripten_set_deviceorientation_callback_on_thread: _emscripten_set_deviceorientation_callback_on_thread,
          emscripten_set_element_css_size: _emscripten_set_element_css_size,
          emscripten_set_focus_callback_on_thread: _emscripten_set_focus_callback_on_thread,
          emscripten_set_focusin_callback_on_thread: _emscripten_set_focusin_callback_on_thread,
          emscripten_set_focusout_callback_on_thread: _emscripten_set_focusout_callback_on_thread,
          emscripten_set_fullscreenchange_callback_on_thread: _emscripten_set_fullscreenchange_callback_on_thread,
          emscripten_set_gamepadconnected_callback_on_thread: _emscripten_set_gamepadconnected_callback_on_thread,
          emscripten_set_gamepaddisconnected_callback_on_thread: _emscripten_set_gamepaddisconnected_callback_on_thread,
          emscripten_set_immediate: _emscripten_set_immediate,
          emscripten_set_immediate_loop: _emscripten_set_immediate_loop,
          emscripten_set_interval: _emscripten_set_interval,
          emscripten_set_keydown_callback_on_thread: _emscripten_set_keydown_callback_on_thread,
          emscripten_set_keypress_callback_on_thread: _emscripten_set_keypress_callback_on_thread,
          emscripten_set_keyup_callback_on_thread: _emscripten_set_keyup_callback_on_thread,
          emscripten_set_main_loop: _emscripten_set_main_loop,
          emscripten_set_main_loop_arg: _emscripten_set_main_loop_arg,
          emscripten_set_main_loop_expected_blockers: _emscripten_set_main_loop_expected_blockers,
          emscripten_set_main_loop_timing: _emscripten_set_main_loop_timing,
          emscripten_set_mousedown_callback_on_thread: _emscripten_set_mousedown_callback_on_thread,
          emscripten_set_mouseenter_callback_on_thread: _emscripten_set_mouseenter_callback_on_thread,
          emscripten_set_mouseleave_callback_on_thread: _emscripten_set_mouseleave_callback_on_thread,
          emscripten_set_mousemove_callback_on_thread: _emscripten_set_mousemove_callback_on_thread,
          emscripten_set_mouseout_callback_on_thread: _emscripten_set_mouseout_callback_on_thread,
          emscripten_set_mouseover_callback_on_thread: _emscripten_set_mouseover_callback_on_thread,
          emscripten_set_mouseup_callback_on_thread: _emscripten_set_mouseup_callback_on_thread,
          emscripten_set_orientationchange_callback_on_thread: _emscripten_set_orientationchange_callback_on_thread,
          emscripten_set_pointerlockchange_callback_on_thread: _emscripten_set_pointerlockchange_callback_on_thread,
          emscripten_set_pointerlockerror_callback_on_thread: _emscripten_set_pointerlockerror_callback_on_thread,
          emscripten_set_resize_callback_on_thread: _emscripten_set_resize_callback_on_thread,
          emscripten_set_scroll_callback_on_thread: _emscripten_set_scroll_callback_on_thread,
          emscripten_set_socket_close_callback: _emscripten_set_socket_close_callback,
          emscripten_set_socket_connection_callback: _emscripten_set_socket_connection_callback,
          emscripten_set_socket_error_callback: _emscripten_set_socket_error_callback,
          emscripten_set_socket_listen_callback: _emscripten_set_socket_listen_callback,
          emscripten_set_socket_message_callback: _emscripten_set_socket_message_callback,
          emscripten_set_socket_open_callback: _emscripten_set_socket_open_callback,
          emscripten_set_timeout: _emscripten_set_timeout,
          emscripten_set_timeout_loop: _emscripten_set_timeout_loop,
          emscripten_set_touchcancel_callback_on_thread: _emscripten_set_touchcancel_callback_on_thread,
          emscripten_set_touchend_callback_on_thread: _emscripten_set_touchend_callback_on_thread,
          emscripten_set_touchmove_callback_on_thread: _emscripten_set_touchmove_callback_on_thread,
          emscripten_set_touchstart_callback_on_thread: _emscripten_set_touchstart_callback_on_thread,
          emscripten_set_visibilitychange_callback_on_thread: _emscripten_set_visibilitychange_callback_on_thread,
          emscripten_set_webglcontextlost_callback_on_thread: _emscripten_set_webglcontextlost_callback_on_thread,
          emscripten_set_webglcontextrestored_callback_on_thread: _emscripten_set_webglcontextrestored_callback_on_thread,
          emscripten_set_wheel_callback_on_thread: _emscripten_set_wheel_callback_on_thread,
          emscripten_set_window_title: _emscripten_set_window_title,
          emscripten_sleep: _emscripten_sleep,
          emscripten_stack_snapshot: _emscripten_stack_snapshot,
          emscripten_stack_unwind_buffer: _emscripten_stack_unwind_buffer,
          emscripten_supports_offscreencanvas: _emscripten_supports_offscreencanvas,
          emscripten_throw_number: _emscripten_throw_number,
          emscripten_throw_string: _emscripten_throw_string,
          emscripten_unlock_orientation: _emscripten_unlock_orientation,
          emscripten_unwind_to_js_event_loop: _emscripten_unwind_to_js_event_loop,
          emscripten_vibrate: _emscripten_vibrate,
          emscripten_vibrate_pattern: _emscripten_vibrate_pattern,
          emscripten_webgl_commit_frame: _emscripten_webgl_commit_frame,
          emscripten_webgl_create_context: _emscripten_webgl_create_context,
          emscripten_webgl_destroy_context: _emscripten_webgl_destroy_context,
          emscripten_webgl_do_commit_frame: _emscripten_webgl_do_commit_frame,
          emscripten_webgl_do_create_context: _emscripten_webgl_do_create_context,
          emscripten_webgl_do_get_current_context: _emscripten_webgl_do_get_current_context,
          emscripten_webgl_enable_ANGLE_instanced_arrays: _emscripten_webgl_enable_ANGLE_instanced_arrays,
          emscripten_webgl_enable_OES_vertex_array_object: _emscripten_webgl_enable_OES_vertex_array_object,
          emscripten_webgl_enable_WEBGL_draw_buffers: _emscripten_webgl_enable_WEBGL_draw_buffers,
          emscripten_webgl_enable_WEBGL_multi_draw: _emscripten_webgl_enable_WEBGL_multi_draw,
          emscripten_webgl_enable_extension: _emscripten_webgl_enable_extension,
          emscripten_webgl_get_context_attributes: _emscripten_webgl_get_context_attributes,
          emscripten_webgl_get_current_context: _emscripten_webgl_get_current_context,
          emscripten_webgl_get_drawing_buffer_size: _emscripten_webgl_get_drawing_buffer_size,
          emscripten_webgl_get_parameter_d: _emscripten_webgl_get_parameter_d,
          emscripten_webgl_get_parameter_i64v: _emscripten_webgl_get_parameter_i64v,
          emscripten_webgl_get_parameter_o: _emscripten_webgl_get_parameter_o,
          emscripten_webgl_get_parameter_utf8: _emscripten_webgl_get_parameter_utf8,
          emscripten_webgl_get_parameter_v: _emscripten_webgl_get_parameter_v,
          emscripten_webgl_get_program_info_log_utf8: _emscripten_webgl_get_program_info_log_utf8,
          emscripten_webgl_get_program_parameter_d: _emscripten_webgl_get_program_parameter_d,
          emscripten_webgl_get_shader_info_log_utf8: _emscripten_webgl_get_shader_info_log_utf8,
          emscripten_webgl_get_shader_parameter_d: _emscripten_webgl_get_shader_parameter_d,
          emscripten_webgl_get_shader_source_utf8: _emscripten_webgl_get_shader_source_utf8,
          emscripten_webgl_get_supported_extensions: _emscripten_webgl_get_supported_extensions,
          emscripten_webgl_get_uniform_d: _emscripten_webgl_get_uniform_d,
          emscripten_webgl_get_uniform_v: _emscripten_webgl_get_uniform_v,
          emscripten_webgl_get_vertex_attrib_d: _emscripten_webgl_get_vertex_attrib_d,
          emscripten_webgl_get_vertex_attrib_o: _emscripten_webgl_get_vertex_attrib_o,
          emscripten_webgl_get_vertex_attrib_v: _emscripten_webgl_get_vertex_attrib_v,
          emscripten_webgl_init_context_attributes: _emscripten_webgl_init_context_attributes,
          emscripten_webgl_make_context_current: _emscripten_webgl_make_context_current,
          emscripten_wget_data: _emscripten_wget_data,
          endprotoent: _endprotoent,
          environ_get: _environ_get,
          environ_sizes_get: _environ_sizes_get,
          exit: _exit,
          fd_close: _fd_close,
          fd_fdstat_get: _fd_fdstat_get,
          fd_pread: _fd_pread,
          fd_pwrite: _fd_pwrite,
          fd_read: _fd_read,
          fd_seek: _fd_seek,
          fd_sync: _fd_sync,
          fd_write: _fd_write,
          filledEllipseColor: _filledEllipseColor,
          filledEllipseRGBA: _filledEllipseRGBA,
          getaddrinfo: _getaddrinfo,
          getentropy: _getentropy,
          getnameinfo: _getnameinfo,
          getprotobyname: _getprotobyname,
          getprotobynumber: _getprotobynumber,
          getprotoent: _getprotoent,
          glActiveTexture: _glActiveTexture,
          glAttachShader: _glAttachShader,
          glBegin: _glBegin,
          glBeginQueryEXT: _glBeginQueryEXT,
          glBindAttribLocation: _glBindAttribLocation,
          glBindBuffer: _glBindBuffer,
          glBindFramebuffer: _glBindFramebuffer,
          glBindRenderbuffer: _glBindRenderbuffer,
          glBindTexture: _glBindTexture,
          glBindVertexArray: _glBindVertexArray,
          glBindVertexArrayOES: _glBindVertexArrayOES,
          glBlendColor: _glBlendColor,
          glBlendEquation: _glBlendEquation,
          glBlendEquationSeparate: _glBlendEquationSeparate,
          glBlendFunc: _glBlendFunc,
          glBlendFuncSeparate: _glBlendFuncSeparate,
          glBufferData: _glBufferData,
          glBufferSubData: _glBufferSubData,
          glCheckFramebufferStatus: _glCheckFramebufferStatus,
          glClear: _glClear,
          glClearColor: _glClearColor,
          glClearDepth: _glClearDepth,
          glClearDepthf: _glClearDepthf,
          glClearStencil: _glClearStencil,
          glColorMask: _glColorMask,
          glCompileShader: _glCompileShader,
          glCompressedTexImage2D: _glCompressedTexImage2D,
          glCompressedTexSubImage2D: _glCompressedTexSubImage2D,
          glCopyTexImage2D: _glCopyTexImage2D,
          glCopyTexSubImage2D: _glCopyTexSubImage2D,
          glCreateProgram: _glCreateProgram,
          glCreateShader: _glCreateShader,
          glCullFace: _glCullFace,
          glDeleteBuffers: _glDeleteBuffers,
          glDeleteFramebuffers: _glDeleteFramebuffers,
          glDeleteProgram: _glDeleteProgram,
          glDeleteQueriesEXT: _glDeleteQueriesEXT,
          glDeleteRenderbuffers: _glDeleteRenderbuffers,
          glDeleteShader: _glDeleteShader,
          glDeleteTextures: _glDeleteTextures,
          glDeleteVertexArrays: _glDeleteVertexArrays,
          glDeleteVertexArraysOES: _glDeleteVertexArraysOES,
          glDepthFunc: _glDepthFunc,
          glDepthMask: _glDepthMask,
          glDepthRange: _glDepthRange,
          glDepthRangef: _glDepthRangef,
          glDetachShader: _glDetachShader,
          glDisable: _glDisable,
          glDisableVertexAttribArray: _glDisableVertexAttribArray,
          glDrawArrays: _glDrawArrays,
          glDrawArraysInstanced: _glDrawArraysInstanced,
          glDrawArraysInstancedANGLE: _glDrawArraysInstancedANGLE,
          glDrawArraysInstancedARB: _glDrawArraysInstancedARB,
          glDrawArraysInstancedEXT: _glDrawArraysInstancedEXT,
          glDrawArraysInstancedNV: _glDrawArraysInstancedNV,
          glDrawBuffers: _glDrawBuffers,
          glDrawBuffersEXT: _glDrawBuffersEXT,
          glDrawBuffersWEBGL: _glDrawBuffersWEBGL,
          glDrawElements: _glDrawElements,
          glDrawElementsInstanced: _glDrawElementsInstanced,
          glDrawElementsInstancedANGLE: _glDrawElementsInstancedANGLE,
          glDrawElementsInstancedARB: _glDrawElementsInstancedARB,
          glDrawElementsInstancedEXT: _glDrawElementsInstancedEXT,
          glDrawElementsInstancedNV: _glDrawElementsInstancedNV,
          glEnable: _glEnable,
          glEnableVertexAttribArray: _glEnableVertexAttribArray,
          glEndQueryEXT: _glEndQueryEXT,
          glFinish: _glFinish,
          glFlush: _glFlush,
          glFramebufferRenderbuffer: _glFramebufferRenderbuffer,
          glFramebufferTexture2D: _glFramebufferTexture2D,
          glFrontFace: _glFrontFace,
          glGenBuffers: _glGenBuffers,
          glGenFramebuffers: _glGenFramebuffers,
          glGenQueriesEXT: _glGenQueriesEXT,
          glGenRenderbuffers: _glGenRenderbuffers,
          glGenTextures: _glGenTextures,
          glGenVertexArrays: _glGenVertexArrays,
          glGenVertexArraysOES: _glGenVertexArraysOES,
          glGenerateMipmap: _glGenerateMipmap,
          glGetActiveAttrib: _glGetActiveAttrib,
          glGetActiveUniform: _glGetActiveUniform,
          glGetAttachedShaders: _glGetAttachedShaders,
          glGetAttribLocation: _glGetAttribLocation,
          glGetBooleanv: _glGetBooleanv,
          glGetBufferParameteriv: _glGetBufferParameteriv,
          glGetError: _glGetError,
          glGetFloatv: _glGetFloatv,
          glGetFramebufferAttachmentParameteriv: _glGetFramebufferAttachmentParameteriv,
          glGetIntegerv: _glGetIntegerv,
          glGetProgramInfoLog: _glGetProgramInfoLog,
          glGetProgramiv: _glGetProgramiv,
          glGetQueryObjecti64vEXT: _glGetQueryObjecti64vEXT,
          glGetQueryObjectivEXT: _glGetQueryObjectivEXT,
          glGetQueryObjectui64vEXT: _glGetQueryObjectui64vEXT,
          glGetQueryObjectuivEXT: _glGetQueryObjectuivEXT,
          glGetQueryivEXT: _glGetQueryivEXT,
          glGetRenderbufferParameteriv: _glGetRenderbufferParameteriv,
          glGetShaderInfoLog: _glGetShaderInfoLog,
          glGetShaderPrecisionFormat: _glGetShaderPrecisionFormat,
          glGetShaderSource: _glGetShaderSource,
          glGetShaderiv: _glGetShaderiv,
          glGetString: _glGetString,
          glGetTexParameterfv: _glGetTexParameterfv,
          glGetTexParameteriv: _glGetTexParameteriv,
          glGetUniformLocation: _glGetUniformLocation,
          glGetUniformfv: _glGetUniformfv,
          glGetUniformiv: _glGetUniformiv,
          glGetVertexAttribPointerv: _glGetVertexAttribPointerv,
          glGetVertexAttribfv: _glGetVertexAttribfv,
          glGetVertexAttribiv: _glGetVertexAttribiv,
          glHint: _glHint,
          glIsBuffer: _glIsBuffer,
          glIsEnabled: _glIsEnabled,
          glIsFramebuffer: _glIsFramebuffer,
          glIsProgram: _glIsProgram,
          glIsQueryEXT: _glIsQueryEXT,
          glIsRenderbuffer: _glIsRenderbuffer,
          glIsShader: _glIsShader,
          glIsTexture: _glIsTexture,
          glIsVertexArray: _glIsVertexArray,
          glIsVertexArrayOES: _glIsVertexArrayOES,
          glLineWidth: _glLineWidth,
          glLinkProgram: _glLinkProgram,
          glLoadIdentity: _glLoadIdentity,
          glMatrixMode: _glMatrixMode,
          glMultiDrawArrays: _glMultiDrawArrays,
          glMultiDrawArraysANGLE: _glMultiDrawArraysANGLE,
          glMultiDrawArraysInstancedANGLE: _glMultiDrawArraysInstancedANGLE,
          glMultiDrawArraysInstancedWEBGL: _glMultiDrawArraysInstancedWEBGL,
          glMultiDrawArraysWEBGL: _glMultiDrawArraysWEBGL,
          glMultiDrawElements: _glMultiDrawElements,
          glMultiDrawElementsANGLE: _glMultiDrawElementsANGLE,
          glMultiDrawElementsInstancedANGLE: _glMultiDrawElementsInstancedANGLE,
          glMultiDrawElementsInstancedWEBGL: _glMultiDrawElementsInstancedWEBGL,
          glMultiDrawElementsWEBGL: _glMultiDrawElementsWEBGL,
          glPixelStorei: _glPixelStorei,
          glPolygonOffset: _glPolygonOffset,
          glQueryCounterEXT: _glQueryCounterEXT,
          glReadPixels: _glReadPixels,
          glReleaseShaderCompiler: _glReleaseShaderCompiler,
          glRenderbufferStorage: _glRenderbufferStorage,
          glSampleCoverage: _glSampleCoverage,
          glScissor: _glScissor,
          glShaderBinary: _glShaderBinary,
          glShaderSource: _glShaderSource,
          glStencilFunc: _glStencilFunc,
          glStencilFuncSeparate: _glStencilFuncSeparate,
          glStencilMask: _glStencilMask,
          glStencilMaskSeparate: _glStencilMaskSeparate,
          glStencilOp: _glStencilOp,
          glStencilOpSeparate: _glStencilOpSeparate,
          glTexImage2D: _glTexImage2D,
          glTexParameterf: _glTexParameterf,
          glTexParameterfv: _glTexParameterfv,
          glTexParameteri: _glTexParameteri,
          glTexParameteriv: _glTexParameteriv,
          glTexSubImage2D: _glTexSubImage2D,
          glUniform1f: _glUniform1f,
          glUniform1fv: _glUniform1fv,
          glUniform1i: _glUniform1i,
          glUniform1iv: _glUniform1iv,
          glUniform2f: _glUniform2f,
          glUniform2fv: _glUniform2fv,
          glUniform2i: _glUniform2i,
          glUniform2iv: _glUniform2iv,
          glUniform3f: _glUniform3f,
          glUniform3fv: _glUniform3fv,
          glUniform3i: _glUniform3i,
          glUniform3iv: _glUniform3iv,
          glUniform4f: _glUniform4f,
          glUniform4fv: _glUniform4fv,
          glUniform4i: _glUniform4i,
          glUniform4iv: _glUniform4iv,
          glUniformMatrix2fv: _glUniformMatrix2fv,
          glUniformMatrix3fv: _glUniformMatrix3fv,
          glUniformMatrix4fv: _glUniformMatrix4fv,
          glUseProgram: _glUseProgram,
          glValidateProgram: _glValidateProgram,
          glVertexAttrib1f: _glVertexAttrib1f,
          glVertexAttrib1fv: _glVertexAttrib1fv,
          glVertexAttrib2f: _glVertexAttrib2f,
          glVertexAttrib2fv: _glVertexAttrib2fv,
          glVertexAttrib3f: _glVertexAttrib3f,
          glVertexAttrib3fv: _glVertexAttrib3fv,
          glVertexAttrib4f: _glVertexAttrib4f,
          glVertexAttrib4fv: _glVertexAttrib4fv,
          glVertexAttribDivisor: _glVertexAttribDivisor,
          glVertexAttribDivisorANGLE: _glVertexAttribDivisorANGLE,
          glVertexAttribDivisorARB: _glVertexAttribDivisorARB,
          glVertexAttribDivisorEXT: _glVertexAttribDivisorEXT,
          glVertexAttribDivisorNV: _glVertexAttribDivisorNV,
          glVertexAttribPointer: _glVertexAttribPointer,
          glVertexPointer: _glVertexPointer,
          glViewport: _glViewport,
          glewGetErrorString: _glewGetErrorString,
          glewGetExtension: _glewGetExtension,
          glewGetString: _glewGetString,
          glewInit: _glewInit,
          glewIsSupported: _glewIsSupported,
          glutCreateWindow: _glutCreateWindow,
          glutDestroyWindow: _glutDestroyWindow,
          glutDisplayFunc: _glutDisplayFunc,
          glutFullScreen: _glutFullScreen,
          glutGet: _glutGet,
          glutGetModifiers: _glutGetModifiers,
          glutIdleFunc: _glutIdleFunc,
          glutInit: _glutInit,
          glutInitDisplayMode: _glutInitDisplayMode,
          glutInitWindowPosition: _glutInitWindowPosition,
          glutInitWindowSize: _glutInitWindowSize,
          glutKeyboardFunc: _glutKeyboardFunc,
          glutKeyboardUpFunc: _glutKeyboardUpFunc,
          glutMainLoop: _glutMainLoop,
          glutMotionFunc: _glutMotionFunc,
          glutMouseFunc: _glutMouseFunc,
          glutPassiveMotionFunc: _glutPassiveMotionFunc,
          glutPositionWindow: _glutPositionWindow,
          glutPostRedisplay: _glutPostRedisplay,
          glutReshapeFunc: _glutReshapeFunc,
          glutReshapeWindow: _glutReshapeWindow,
          glutSetCursor: _glutSetCursor,
          glutSpecialFunc: _glutSpecialFunc,
          glutSpecialUpFunc: _glutSpecialUpFunc,
          glutSwapBuffers: _glutSwapBuffers,
          glutTimerFunc: _glutTimerFunc,
          lineColor: _lineColor,
          lineRGBA: _lineRGBA,
          memory: wasmMemory,
          pixelRGBA: _pixelRGBA,
          proc_exit: _proc_exit,
          pthread_kill: _pthread_kill,
          random_get: _random_get,
          rectangleColor: _rectangleColor,
          rectangleRGBA: _rectangleRGBA,
          rotozoomSurface: _rotozoomSurface,
          setNetworkCallback: _setNetworkCallback,
          setprotoent: _setprotoent,
          strftime: _strftime,
          strftime_l: _strftime_l,
          strptime: _strptime,
          strptime_l: _strptime_l,
          uuid_clear: _uuid_clear,
          uuid_compare: _uuid_compare,
          uuid_copy: _uuid_copy,
          uuid_generate: _uuid_generate,
          uuid_is_null: _uuid_is_null,
          uuid_parse: _uuid_parse,
          uuid_type: _uuid_type,
          uuid_unparse: _uuid_unparse,
          uuid_unparse_lower: _uuid_unparse_lower,
          uuid_unparse_upper: _uuid_unparse_upper,
          uuid_variant: _uuid_variant,
          zoomSurface: _zoomSurface
        };
        var wasmExports = createWasm();
        var _main = Module["_main"] = (a0, a1) => (_main = Module["_main"] = wasmExports["main"])(a0, a1);
        var _malloc = Module["_malloc"] = (a0) => (_malloc = Module["_malloc"] = wasmExports["malloc"])(a0);
        var _free = Module["_free"] = (a0) => (_free = Module["_free"] = wasmExports["free"])(a0);
        var _duckdb_web_fs_glob_add_path = Module["_duckdb_web_fs_glob_add_path"] = (a0) => (_duckdb_web_fs_glob_add_path = Module["_duckdb_web_fs_glob_add_path"] = wasmExports["duckdb_web_fs_glob_add_path"])(a0);
        var _duckdb_web_clear_response = Module["_duckdb_web_clear_response"] = () => (_duckdb_web_clear_response = Module["_duckdb_web_clear_response"] = wasmExports["duckdb_web_clear_response"])();
        var _duckdb_web_fail_with = Module["_duckdb_web_fail_with"] = (a0) => (_duckdb_web_fail_with = Module["_duckdb_web_fail_with"] = wasmExports["duckdb_web_fail_with"])(a0);
        var _duckdb_web_reset = Module["_duckdb_web_reset"] = (a0) => (_duckdb_web_reset = Module["_duckdb_web_reset"] = wasmExports["duckdb_web_reset"])(a0);
        var _duckdb_web_connect = Module["_duckdb_web_connect"] = () => (_duckdb_web_connect = Module["_duckdb_web_connect"] = wasmExports["duckdb_web_connect"])();
        var _duckdb_web_disconnect = Module["_duckdb_web_disconnect"] = (a0) => (_duckdb_web_disconnect = Module["_duckdb_web_disconnect"] = wasmExports["duckdb_web_disconnect"])(a0);
        var _duckdb_web_access_buffer = Module["_duckdb_web_access_buffer"] = (a0, a1) => (_duckdb_web_access_buffer = Module["_duckdb_web_access_buffer"] = wasmExports["duckdb_web_access_buffer"])(a0, a1);
        var _duckdb_web_flush_files = Module["_duckdb_web_flush_files"] = () => (_duckdb_web_flush_files = Module["_duckdb_web_flush_files"] = wasmExports["duckdb_web_flush_files"])();
        var _duckdb_web_flush_file = Module["_duckdb_web_flush_file"] = (a0) => (_duckdb_web_flush_file = Module["_duckdb_web_flush_file"] = wasmExports["duckdb_web_flush_file"])(a0);
        var _duckdb_web_open = Module["_duckdb_web_open"] = (a0, a1) => (_duckdb_web_open = Module["_duckdb_web_open"] = wasmExports["duckdb_web_open"])(a0, a1);
        var _duckdb_web_get_global_file_info = Module["_duckdb_web_get_global_file_info"] = (a0, a1) => (_duckdb_web_get_global_file_info = Module["_duckdb_web_get_global_file_info"] = wasmExports["duckdb_web_get_global_file_info"])(a0, a1);
        var _duckdb_web_collect_file_stats = Module["_duckdb_web_collect_file_stats"] = (a0, a1, a2) => (_duckdb_web_collect_file_stats = Module["_duckdb_web_collect_file_stats"] = wasmExports["duckdb_web_collect_file_stats"])(a0, a1, a2);
        var _duckdb_web_export_file_stats = Module["_duckdb_web_export_file_stats"] = (a0, a1) => (_duckdb_web_export_file_stats = Module["_duckdb_web_export_file_stats"] = wasmExports["duckdb_web_export_file_stats"])(a0, a1);
        var _duckdb_web_fs_drop_file = Module["_duckdb_web_fs_drop_file"] = (a0, a1) => (_duckdb_web_fs_drop_file = Module["_duckdb_web_fs_drop_file"] = wasmExports["duckdb_web_fs_drop_file"])(a0, a1);
        var _duckdb_web_fs_drop_files = Module["_duckdb_web_fs_drop_files"] = (a0) => (_duckdb_web_fs_drop_files = Module["_duckdb_web_fs_drop_files"] = wasmExports["duckdb_web_fs_drop_files"])(a0);
        var _duckdb_web_fs_glob_file_infos = Module["_duckdb_web_fs_glob_file_infos"] = (a0, a1) => (_duckdb_web_fs_glob_file_infos = Module["_duckdb_web_fs_glob_file_infos"] = wasmExports["duckdb_web_fs_glob_file_infos"])(a0, a1);
        var _duckdb_web_fs_get_file_info_by_id = Module["_duckdb_web_fs_get_file_info_by_id"] = (a0, a1, a2) => (_duckdb_web_fs_get_file_info_by_id = Module["_duckdb_web_fs_get_file_info_by_id"] = wasmExports["duckdb_web_fs_get_file_info_by_id"])(a0, a1, a2);
        var _duckdb_web_fs_get_file_info_by_name = Module["_duckdb_web_fs_get_file_info_by_name"] = (a0, a1, a2) => (_duckdb_web_fs_get_file_info_by_name = Module["_duckdb_web_fs_get_file_info_by_name"] = wasmExports["duckdb_web_fs_get_file_info_by_name"])(a0, a1, a2);
        var _duckdb_web_fs_register_file_url = Module["_duckdb_web_fs_register_file_url"] = (a0, a1, a2, a3, a4) => (_duckdb_web_fs_register_file_url = Module["_duckdb_web_fs_register_file_url"] = wasmExports["duckdb_web_fs_register_file_url"])(a0, a1, a2, a3, a4);
        var _duckdb_web_fs_register_file_buffer = Module["_duckdb_web_fs_register_file_buffer"] = (a0, a1, a2, a3) => (_duckdb_web_fs_register_file_buffer = Module["_duckdb_web_fs_register_file_buffer"] = wasmExports["duckdb_web_fs_register_file_buffer"])(a0, a1, a2, a3);
        var _duckdb_web_copy_file_to_buffer = Module["_duckdb_web_copy_file_to_buffer"] = (a0, a1) => (_duckdb_web_copy_file_to_buffer = Module["_duckdb_web_copy_file_to_buffer"] = wasmExports["duckdb_web_copy_file_to_buffer"])(a0, a1);
        var _duckdb_web_copy_file_to_path = Module["_duckdb_web_copy_file_to_path"] = (a0, a1, a2) => (_duckdb_web_copy_file_to_path = Module["_duckdb_web_copy_file_to_path"] = wasmExports["duckdb_web_copy_file_to_path"])(a0, a1, a2);
        var _duckdb_web_get_version = Module["_duckdb_web_get_version"] = (a0) => (_duckdb_web_get_version = Module["_duckdb_web_get_version"] = wasmExports["duckdb_web_get_version"])(a0);
        var _duckdb_web_get_feature_flags = Module["_duckdb_web_get_feature_flags"] = () => (_duckdb_web_get_feature_flags = Module["_duckdb_web_get_feature_flags"] = wasmExports["duckdb_web_get_feature_flags"])();
        var _duckdb_web_tokenize = Module["_duckdb_web_tokenize"] = (a0, a1) => (_duckdb_web_tokenize = Module["_duckdb_web_tokenize"] = wasmExports["duckdb_web_tokenize"])(a0, a1);
        var _duckdb_web_udf_scalar_create = Module["_duckdb_web_udf_scalar_create"] = (a0, a1, a2) => (_duckdb_web_udf_scalar_create = Module["_duckdb_web_udf_scalar_create"] = wasmExports["duckdb_web_udf_scalar_create"])(a0, a1, a2);
        var _duckdb_web_prepared_create = Module["_duckdb_web_prepared_create"] = (a0, a1, a2) => (_duckdb_web_prepared_create = Module["_duckdb_web_prepared_create"] = wasmExports["duckdb_web_prepared_create"])(a0, a1, a2);
        var _duckdb_web_prepared_close = Module["_duckdb_web_prepared_close"] = (a0, a1, a2) => (_duckdb_web_prepared_close = Module["_duckdb_web_prepared_close"] = wasmExports["duckdb_web_prepared_close"])(a0, a1, a2);
        var _duckdb_web_prepared_run = Module["_duckdb_web_prepared_run"] = (a0, a1, a2, a3) => (_duckdb_web_prepared_run = Module["_duckdb_web_prepared_run"] = wasmExports["duckdb_web_prepared_run"])(a0, a1, a2, a3);
        var _duckdb_web_prepared_send = Module["_duckdb_web_prepared_send"] = (a0, a1, a2, a3) => (_duckdb_web_prepared_send = Module["_duckdb_web_prepared_send"] = wasmExports["duckdb_web_prepared_send"])(a0, a1, a2, a3);
        var _duckdb_web_query_run = Module["_duckdb_web_query_run"] = (a0, a1, a2) => (_duckdb_web_query_run = Module["_duckdb_web_query_run"] = wasmExports["duckdb_web_query_run"])(a0, a1, a2);
        var _duckdb_web_pending_query_start = Module["_duckdb_web_pending_query_start"] = (a0, a1, a2) => (_duckdb_web_pending_query_start = Module["_duckdb_web_pending_query_start"] = wasmExports["duckdb_web_pending_query_start"])(a0, a1, a2);
        var _duckdb_web_pending_query_poll = Module["_duckdb_web_pending_query_poll"] = (a0, a1, a2) => (_duckdb_web_pending_query_poll = Module["_duckdb_web_pending_query_poll"] = wasmExports["duckdb_web_pending_query_poll"])(a0, a1, a2);
        var _duckdb_web_pending_query_cancel = Module["_duckdb_web_pending_query_cancel"] = (a0, a1) => (_duckdb_web_pending_query_cancel = Module["_duckdb_web_pending_query_cancel"] = wasmExports["duckdb_web_pending_query_cancel"])(a0, a1);
        var _duckdb_web_query_fetch_results = Module["_duckdb_web_query_fetch_results"] = (a0, a1) => (_duckdb_web_query_fetch_results = Module["_duckdb_web_query_fetch_results"] = wasmExports["duckdb_web_query_fetch_results"])(a0, a1);
        var _duckdb_web_get_tablenames = Module["_duckdb_web_get_tablenames"] = (a0, a1, a2) => (_duckdb_web_get_tablenames = Module["_duckdb_web_get_tablenames"] = wasmExports["duckdb_web_get_tablenames"])(a0, a1, a2);
        var _duckdb_web_insert_arrow_from_ipc_stream = Module["_duckdb_web_insert_arrow_from_ipc_stream"] = (a0, a1, a2, a3, a4) => (_duckdb_web_insert_arrow_from_ipc_stream = Module["_duckdb_web_insert_arrow_from_ipc_stream"] = wasmExports["duckdb_web_insert_arrow_from_ipc_stream"])(a0, a1, a2, a3, a4);
        var _duckdb_web_insert_csv_from_path = Module["_duckdb_web_insert_csv_from_path"] = (a0, a1, a2, a3) => (_duckdb_web_insert_csv_from_path = Module["_duckdb_web_insert_csv_from_path"] = wasmExports["duckdb_web_insert_csv_from_path"])(a0, a1, a2, a3);
        var _duckdb_web_insert_json_from_path = Module["_duckdb_web_insert_json_from_path"] = (a0, a1, a2, a3) => (_duckdb_web_insert_json_from_path = Module["_duckdb_web_insert_json_from_path"] = wasmExports["duckdb_web_insert_json_from_path"])(a0, a1, a2, a3);
        var _duckdb_web_fts_init = Module["_duckdb_web_fts_init"] = (a0) => (_duckdb_web_fts_init = Module["_duckdb_web_fts_init"] = wasmExports["duckdb_web_fts_init"])(a0);
        var _duckdb_web_parquet_init = Module["_duckdb_web_parquet_init"] = (a0) => (_duckdb_web_parquet_init = Module["_duckdb_web_parquet_init"] = wasmExports["duckdb_web_parquet_init"])(a0);
        var _freeaddrinfo = Module["_freeaddrinfo"] = (a0) => (_freeaddrinfo = Module["_freeaddrinfo"] = wasmExports["freeaddrinfo"])(a0);
        var _freeifaddrs = Module["_freeifaddrs"] = (a0) => (_freeifaddrs = Module["_freeifaddrs"] = wasmExports["freeifaddrs"])(a0);
        var _freelocale = Module["_freelocale"] = (a0) => (_freelocale = Module["_freelocale"] = wasmExports["freelocale"])(a0);
        var _malloc_trim = Module["_malloc_trim"] = (a0) => (_malloc_trim = Module["_malloc_trim"] = wasmExports["malloc_trim"])(a0);
        var _malloc_usable_size = Module["_malloc_usable_size"] = (a0) => (_malloc_usable_size = Module["_malloc_usable_size"] = wasmExports["malloc_usable_size"])(a0);
        var _malloc_footprint = Module["_malloc_footprint"] = () => (_malloc_footprint = Module["_malloc_footprint"] = wasmExports["malloc_footprint"])();
        var _malloc_max_footprint = Module["_malloc_max_footprint"] = () => (_malloc_max_footprint = Module["_malloc_max_footprint"] = wasmExports["malloc_max_footprint"])();
        var _malloc_footprint_limit = Module["_malloc_footprint_limit"] = () => (_malloc_footprint_limit = Module["_malloc_footprint_limit"] = wasmExports["malloc_footprint_limit"])();
        var _malloc_set_footprint_limit = Module["_malloc_set_footprint_limit"] = (a0) => (_malloc_set_footprint_limit = Module["_malloc_set_footprint_limit"] = wasmExports["malloc_set_footprint_limit"])(a0);
        var stackSave = () => (stackSave = wasmExports["stackSave"])();
        var stackRestore = (a0) => (stackRestore = wasmExports["stackRestore"])(a0);
        var stackAlloc = (a0) => (stackAlloc = wasmExports["stackAlloc"])(a0);
        var __ZTINSt3__220__shared_ptr_emplaceIN6duckdb3web2io23FileStatisticsCollectorENS_9allocatorIS4_EEEE = Module["__ZTINSt3__220__shared_ptr_emplaceIN6duckdb3web2io23FileStatisticsCollectorENS_9allocatorIS4_EEEE"] = 1755e3;
        var __ZTSN6duckdb15CreateIndexInfoE = Module["__ZTSN6duckdb15CreateIndexInfoE"] = 457e3;
        var __ZTIN6duckdb18RepeatFunctionDataE = Module["__ZTIN6duckdb18RepeatFunctionDataE"] = 1961e3;
        var __ZTIN6duckdb21ParallelCSVLocalStateE = Module["__ZTIN6duckdb21ParallelCSVLocalStateE"] = 1962e3;
        var __ZTVN6duckdb17IEJoinGlobalStateE = Module["__ZTVN6duckdb17IEJoinGlobalStateE"] = 1991e3;
        var __ZTVN6duckdb19OrderLocalSinkStateE = Module["__ZTVN6duckdb19OrderLocalSinkStateE"] = 1992e3;
        var __ZTVN6duckdb17InsertSourceStateE = Module["__ZTVN6duckdb17InsertSourceStateE"] = 1995e3;
        var __ZTINSt3__210__function6__funcIZN14duckdb_httplib6detail21write_content_chunkedIZNS2_10ClientImpl27write_content_with_providerERNS2_6StreamERKNS2_7RequestERNS2_5ErrorEEUlvE_NS3_10compressorEEEbS7_RKNS_8functionIFbmmRNS2_8DataSinkEEEERKT_RT0_SC_EUlvE_NS_9allocatorISR_EEFvvEEE = Module["__ZTINSt3__210__function6__funcIZN14duckdb_httplib6detail21write_content_chunkedIZNS2_10ClientImpl27write_content_with_providerERNS2_6StreamERKNS2_7RequestERNS2_5ErrorEEUlvE_NS3_10compressorEEEbS7_RKNS_8functionIFbmmRNS2_8DataSinkEEEERKT_RT0_SC_EUlvE_NS_9allocatorISR_EEFvvEEE"] = 2003e3;
        var __ZTINSt3__220__shared_ptr_pointerIPN6duckdb18PipelineFinishTaskENS_14default_deleteIS2_EENS_9allocatorIS2_EEEE = Module["__ZTINSt3__220__shared_ptr_pointerIPN6duckdb18PipelineFinishTaskENS_14default_deleteIS2_EENS_9allocatorIS2_EEEE"] = 2011e3;
        var __ZTIN6duckdb17PatasAnalyzeStateIdEE = Module["__ZTIN6duckdb17PatasAnalyzeStateIdEE"] = 2014e3;
        var __ZTIN6duckdb18LogicalCreateTableE = Module["__ZTIN6duckdb18LogicalCreateTableE"] = 2016e3;
        var __ZTVN6duckdb21ParquetReadLocalStateE = Module["__ZTVN6duckdb21ParquetReadLocalStateE"] = 2035e3;
        var __ZTIN6duckdb21TemplatedColumnReaderINS_9hugeint_tENS_29DecimalParquetValueConversionIS1_Lb1EEEEE = Module["__ZTIN6duckdb21TemplatedColumnReaderINS_9hugeint_tENS_29DecimalParquetValueConversionIS1_Lb1EEEEE"] = 2039e3;
        var __ZTIN6duckdb21TemplatedColumnReaderIbNS_29BooleanParquetValueConversionEEE = Module["__ZTIN6duckdb21TemplatedColumnReaderIbNS_29BooleanParquetValueConversionEEE"] = 204e4;
        var __ZTIN6duckdb21TemplatedColumnReaderIfNS_31TemplatedParquetValueConversionIfEEEE = Module["__ZTIN6duckdb21TemplatedColumnReaderIfNS_31TemplatedParquetValueConversionIfEEEE"] = 2041e3;
        var __ZTIN6duckdb21TemplatedColumnReaderINS_6date_tENS_30CallbackParquetValueConversionIiS1_XadL_ZNS_16ParquetIntToDateERKiEEEEEE = Module["__ZTIN6duckdb21TemplatedColumnReaderINS_6date_tENS_30CallbackParquetValueConversionIiS1_XadL_ZNS_16ParquetIntToDateERKiEEEEEE"] = 2042e3;
        var __ZTIN6duckdb21TemplatedColumnReaderIxNS_31TemplatedParquetValueConversionIiEEEE = Module["__ZTIN6duckdb21TemplatedColumnReaderIxNS_31TemplatedParquetValueConversionIiEEEE"] = 2043e3;
        var __ZN11duckdb_zstd21ZSTDInternalConstants14ML_defaultNormE = Module["__ZN11duckdb_zstd21ZSTDInternalConstants14ML_defaultNormE"] = 125e4;
        var __ZTIN5arrow14TemporalScalarINS_17MonthIntervalTypeEEE = Module["__ZTIN5arrow14TemporalScalarINS_17MonthIntervalTypeEEE"] = 205e4;
        var __ZTVN5arrow14LargeListArrayE = Module["__ZTVN5arrow14LargeListArrayE"] = 2054e3;
        var __ZTSNSt3__220__shared_ptr_emplaceIN5arrow14LargeListArrayENS_9allocatorIS2_EEEE = Module["__ZTSNSt3__220__shared_ptr_emplaceIN5arrow14LargeListArrayENS_9allocatorIS2_EEEE"] = 1267e3;
        var __ZTIN5arrow20RunEndEncodedBuilderE = Module["__ZTIN5arrow20RunEndEncodedBuilderE"] = 2056e3;
        var __ZTIZN5arrow22ValueComparatorVisitor5VisitINS_9Int16TypeEEENS_6StatusERKT_EUlRKNS_5ArrayExS9_xE_ = Module["__ZTIZN5arrow22ValueComparatorVisitor5VisitINS_9Int16TypeEEENS_6StatusERKT_EUlRKNS_5ArrayExS9_xE_"] = 2057e3;
        var __ZTVN5arrow9FloatTypeE = Module["__ZTVN5arrow9FloatTypeE"] = 2076e3;
        var __ZTIN5arrow2io8internal29InputStreamConcurrencyWrapperINS0_21CompressedInputStreamEEE = Module["__ZTIN5arrow2io8internal29InputStreamConcurrencyWrapperINS0_21CompressedInputStreamEEE"] = 2081e3;
        var __ZTVZN5arrow7compute8internal22GetFunctionOptionsTypeINS0_11ModeOptionsEJNS_8internal18DataMemberPropertyIS3_xEENS5_IS3_bEENS5_IS3_jEEEEEPKNS0_19FunctionOptionsTypeEDpRKT0_E11OptionsType = Module["__ZTVZN5arrow7compute8internal22GetFunctionOptionsTypeINS0_11ModeOptionsEJNS_8internal18DataMemberPropertyIS3_xEENS5_IS3_bEENS5_IS3_jEEEEEPKNS0_19FunctionOptionsTypeEDpRKT0_E11OptionsType"] = 2099e3;
        var __ZN5arrow7compute19ReplaceSliceOptions9kTypeNameE = Module["__ZN5arrow7compute19ReplaceSliceOptions9kTypeNameE"] = 1374e3;
        var __ZTIN5arrow7compute11JoinOptionsE = Module["__ZTIN5arrow7compute11JoinOptionsE"] = 21e5;
        var __ZTVN5arrow7compute14SelectKOptionsE = Module["__ZTVN5arrow7compute14SelectKOptionsE"] = 2103e3;
        var __ZGVZN5arrow7compute8internal22GetFunctionOptionsTypeINS0_19RunEndEncodeOptionsEJNS_8internal18DataMemberPropertyIS3_NSt3__210shared_ptrINS_8DataTypeEEEEEEEEPKNS0_19FunctionOptionsTypeEDpRKT0_E8instance = Module["__ZGVZN5arrow7compute8internal22GetFunctionOptionsTypeINS0_19RunEndEncodeOptionsEJNS_8internal18DataMemberPropertyIS3_NSt3__210shared_ptrINS_8DataTypeEEEEEEEEPKNS0_19FunctionOptionsTypeEDpRKT0_E8instance"] = 2166e3;
        var __ZTSN5arrow7compute19RunEndEncodeOptionsE = Module["__ZTSN5arrow7compute19RunEndEncodeOptionsE"] = 1382e3;
        var __ZTVN5arrow7compute5match16PrimitiveMatcherE = Module["__ZTVN5arrow7compute5match16PrimitiveMatcherE"] = 2106e3;
        var __ZTVN5arrow8internal6FnOnceIFvRKNS_10FutureImplEEE6FnImplINS_6FutureINSt3__210shared_ptrINS_6BufferEEEE21WrapResultyOnComplete8CallbackIZNS0_8Executor10DoTransferISC_SD_NS_6ResultISC_EEEENS8_IT_EESL_bEUlRKSJ_E_EEEE = Module["__ZTVN5arrow8internal6FnOnceIFvRKNS_10FutureImplEEE6FnImplINS_6FutureINSt3__210shared_ptrINS_6BufferEEEE21WrapResultyOnComplete8CallbackIZNS0_8Executor10DoTransferISC_SD_NS_6ResultISC_EEEENS8_IT_EESL_bEUlRKSJ_E_EEEE"] = 2112e3;
        var __ZTINSt3__214codecvt_bynameIwc11__mbstate_tEE = Module["__ZTINSt3__214codecvt_bynameIwc11__mbstate_tEE"] = 2124e3;
        var __ZTVNSt3__23pmr26synchronized_pool_resourceE = Module["__ZTVNSt3__23pmr26synchronized_pool_resourceE"] = 2125e3;
        var __ZTVSt9type_info = Module["__ZTVSt9type_info"] = 2134e3;
        function applySignatureConversions(wasmExports2) {
          wasmExports2 = Object.assign({}, wasmExports2);
          var makeWrapper_pppp = (f) => (a0, a1, a2) => f(a0, a1, a2) >>> 0;
          var makeWrapper_pp = (f) => (a0) => f(a0) >>> 0;
          var makeWrapper_p = (f) => () => f() >>> 0;
          var makeWrapper_ppp = (f) => (a0, a1) => f(a0, a1) >>> 0;
          var makeWrapper_pP = (f) => (a0) => f(a0) >>> 0;
          wasmExports2["memcpy"] = makeWrapper_pppp(wasmExports2["memcpy"]);
          wasmExports2["malloc"] = makeWrapper_pp(wasmExports2["malloc"]);
          wasmExports2["__errno_location"] = makeWrapper_p(wasmExports2["__errno_location"]);
          wasmExports2["pthread_self"] = makeWrapper_p(wasmExports2["pthread_self"]);
          wasmExports2["__getTypeName"] = makeWrapper_pp(wasmExports2["__getTypeName"]);
          wasmExports2["emscripten_builtin_malloc"] = makeWrapper_pp(wasmExports2["emscripten_builtin_malloc"]);
          wasmExports2["emscripten_stack_get_base"] = makeWrapper_p(wasmExports2["emscripten_stack_get_base"]);
          wasmExports2["emscripten_stack_get_end"] = makeWrapper_p(wasmExports2["emscripten_stack_get_end"]);
          wasmExports2["emscripten_builtin_memalign"] = makeWrapper_ppp(wasmExports2["emscripten_builtin_memalign"]);
          wasmExports2["emscripten_stack_get_current"] = makeWrapper_p(wasmExports2["emscripten_stack_get_current"]);
          wasmExports2["emscripten_main_runtime_thread_id"] = makeWrapper_p(wasmExports2["emscripten_main_runtime_thread_id"]);
          wasmExports2["sbrk"] = makeWrapper_pP(wasmExports2["sbrk"]);
          wasmExports2["memalign"] = makeWrapper_ppp(wasmExports2["memalign"]);
          wasmExports2["stackSave"] = makeWrapper_p(wasmExports2["stackSave"]);
          wasmExports2["stackAlloc"] = makeWrapper_pp(wasmExports2["stackAlloc"]);
          return wasmExports2;
        }
        Module["stackAlloc"] = stackAlloc;
        Module["stackSave"] = stackSave;
        Module["stackRestore"] = stackRestore;
        Module["ccall"] = ccall;
        var calledRun;
        dependenciesFulfilled = function runCaller() {
          if (!calledRun)
            run();
          if (!calledRun)
            dependenciesFulfilled = runCaller;
        };
        function callMain(args2 = []) {
          var entryFunction = resolveGlobalSymbol("main").sym;
          if (!entryFunction)
            return;
          args2.unshift(thisProgram);
          var argc = args2.length;
          var argv = stackAlloc((argc + 1) * 4);
          var argv_ptr = argv;
          args2.forEach((arg) => {
            HEAPU32[argv_ptr >>> 2 >>> 0] = stringToUTF8OnStack(arg);
            argv_ptr += 4;
          });
          HEAPU32[argv_ptr >>> 2 >>> 0] = 0;
          try {
            var ret = entryFunction(argc, argv);
            exitJS(ret, true);
            return ret;
          } catch (e) {
            return handleException(e);
          }
        }
        function run(args2 = arguments_) {
          if (runDependencies > 0) {
            return;
          }
          preRun();
          if (runDependencies > 0) {
            return;
          }
          function doRun() {
            if (calledRun)
              return;
            calledRun = true;
            Module["calledRun"] = true;
            if (ABORT)
              return;
            initRuntime();
            preMain();
            readyPromiseResolve(Module);
            if (Module["onRuntimeInitialized"])
              Module["onRuntimeInitialized"]();
            if (shouldRunNow)
              callMain(args2);
            postRun();
          }
          if (Module["setStatus"]) {
            Module["setStatus"]("Running...");
            setTimeout(function() {
              setTimeout(function() {
                Module["setStatus"]("");
              }, 1);
              doRun();
            }, 1);
          } else {
            doRun();
          }
        }
        if (Module["preInit"]) {
          if (typeof Module["preInit"] == "function")
            Module["preInit"] = [Module["preInit"]];
          while (Module["preInit"].length > 0) {
            Module["preInit"].pop()();
          }
        }
        var shouldRunNow = true;
        if (Module["noInitialRun"])
          shouldRunNow = false;
        run();
        return moduleArg.ready;
      };
    })();
    if (typeof exports === "object" && typeof module === "object")
      module.exports = DuckDB;
    else if (typeof define === "function" && define["amd"])
      define([], () => DuckDB);
  }
});

// src/bindings/connection.ts
var arrow = __toESM(require("apache-arrow"));
var DuckDBConnection = class {
  /** Constructor */
  constructor(bindings, conn) {
    this._bindings = bindings;
    this._conn = conn;
  }
  /** Close a connection */
  close() {
    this._bindings.disconnect(this._conn);
  }
  /** Brave souls may use this function to consume the underlying connection id */
  useUnsafe(callback) {
    return callback(this._bindings, this._conn);
  }
  /** Run a query */
  query(text) {
    const buffer = this._bindings.runQuery(this._conn, text);
    const reader = arrow.RecordBatchReader.from(buffer);
    console.assert(reader.isSync());
    console.assert(reader.isFile());
    return new arrow.Table(reader);
  }
  /** Send a query */
  async send(text) {
    let header = this._bindings.startPendingQuery(this._conn, text);
    while (header == null) {
      header = await new Promise((resolve, reject) => {
        try {
          resolve(this._bindings.pollPendingQuery(this._conn));
        } catch (e) {
          console.log(e);
          reject(e);
        }
      });
    }
    const iter = new ResultStreamIterator(this._bindings, this._conn, header);
    const reader = arrow.RecordBatchReader.from(iter);
    console.assert(reader.isSync());
    console.assert(reader.isStream());
    return reader;
  }
  /** Cancel a query that was sent earlier */
  cancelSent() {
    return this._bindings.cancelPendingQuery(this._conn);
  }
  /** Get table names */
  getTableNames(query) {
    return this._bindings.getTableNames(this._conn, query);
  }
  /** Create a prepared statement */
  prepare(text) {
    const stmt = this._bindings.createPrepared(this._conn, text);
    return new PreparedStatement(this._bindings, this._conn, stmt);
  }
  /** Create a scalar function */
  createScalarFunction(name2, returns, func2) {
    this._bindings.createScalarFunction(this._conn, name2, returns, func2);
  }
  /** Insert an arrow table */
  insertArrowTable(table, options) {
    const buffer = arrow.tableToIPC(table, "stream");
    this.insertArrowFromIPCStream(buffer, options);
  }
  /** Insert an arrow table from an ipc stream */
  insertArrowFromIPCStream(buffer, options) {
    this._bindings.insertArrowFromIPCStream(this._conn, buffer, options);
  }
  /** Inesrt csv file from path */
  insertCSVFromPath(path2, options) {
    this._bindings.insertCSVFromPath(this._conn, path2, options);
  }
  /** Insert json file from path */
  insertJSONFromPath(path2, options) {
    this._bindings.insertJSONFromPath(this._conn, path2, options);
  }
};
var ResultStreamIterator = class {
  constructor(bindings, conn, header) {
    this.bindings = bindings;
    this.conn = conn;
    this.header = header;
    this._first = true;
    this._depleted = false;
  }
  next() {
    if (this._first) {
      this._first = false;
      return { done: false, value: this.header };
    }
    if (this._depleted) {
      return { done: true, value: null };
    }
    const bufferI8 = this.bindings.fetchQueryResults(this.conn);
    this._depleted = bufferI8.length == 0;
    return {
      done: this._depleted,
      value: bufferI8
    };
  }
  [Symbol.iterator]() {
    return this;
  }
};
var PreparedStatement = class {
  /** Constructor */
  constructor(bindings, connectionId, statementId) {
    this.bindings = bindings;
    this.connectionId = connectionId;
    this.statementId = statementId;
  }
  /** Close a prepared statement */
  close() {
    this.bindings.closePrepared(this.connectionId, this.statementId);
  }
  /** Run a prepared statement */
  query(...params) {
    const buffer = this.bindings.runPrepared(this.connectionId, this.statementId, params);
    const reader = arrow.RecordBatchReader.from(buffer);
    console.assert(reader.isSync());
    console.assert(reader.isFile());
    return new arrow.Table(reader);
  }
  /** Send a prepared statement */
  send(...params) {
    const header = this.bindings.sendPrepared(this.connectionId, this.statementId, params);
    const iter = new ResultStreamIterator(this.bindings, this.connectionId, header);
    const reader = arrow.RecordBatchReader.from(iter);
    console.assert(reader.isSync());
    console.assert(reader.isStream());
    return reader;
  }
};

// src/bindings/udf_runtime.ts
var TEXT_ENCODER = new TextEncoder();
var TEXT_DECODER = new TextDecoder("utf-8");
function storeError(mod, response, message) {
  const msgBuffer = TEXT_ENCODER.encode(message);
  const heapAddr = mod._malloc(msgBuffer.byteLength);
  const heapArray = mod.HEAPU8.subarray(heapAddr, heapAddr + msgBuffer.byteLength);
  heapArray.set(msgBuffer);
  mod.HEAPF64[(response >> 3) + 0] = 1;
  mod.HEAPF64[(response >> 3) + 1] = heapAddr;
  mod.HEAPF64[(response >> 3) + 2] = heapArray.byteLength;
}
function getTypeSize(ptype) {
  switch (ptype) {
    case "UINT8":
    case "INT8":
      return 1;
    case "INT32":
    case "FLOAT":
      return 4;
    case "INT64":
    case "UINT64":
    case "DOUBLE":
    case "VARCHAR":
      return 8;
    default:
      return 0;
  }
}
function ptrToArray(mod, ptr2, ptype, n) {
  const heap = mod.HEAPU8.subarray(ptr2, ptr2 + n * getTypeSize(ptype));
  switch (ptype) {
    case "UINT8":
      return new Uint8Array(heap.buffer, heap.byteOffset, n);
    case "INT8":
      return new Int8Array(heap.buffer, heap.byteOffset, n);
    case "INT32":
      return new Int32Array(heap.buffer, heap.byteOffset, n);
    case "FLOAT":
      return new Float32Array(heap.buffer, heap.byteOffset, n);
    case "DOUBLE":
      return new Float64Array(heap.buffer, heap.byteOffset, n);
    case "VARCHAR":
      return new Float64Array(heap.buffer, heap.byteOffset, n);
    default:
      return new Array(0);
  }
}
function ptrToUint8Array(mod, ptr2, n) {
  const heap = mod.HEAPU8.subarray(ptr2, ptr2 + n);
  return new Uint8Array(heap.buffer, heap.byteOffset, n);
}
function ptrToFloat64Array(mod, ptr2, n) {
  const heap = mod.HEAPU8.subarray(ptr2, ptr2 + n * 8);
  return new Float64Array(heap.buffer, heap.byteOffset, n);
}
function callScalarUDF(runtime2, mod, response, funcId, descPtr, descSize, ptrsPtr, ptrsSize) {
  try {
    const udf = runtime2._udfFunctions.get(funcId);
    if (!udf) {
      storeError(mod, response, "Unknown UDF with id: " + funcId);
      return;
    }
    const rawDesc = TEXT_DECODER.decode(mod.HEAPU8.subarray(descPtr, descPtr + descSize));
    const desc = JSON.parse(rawDesc);
    const ptrs = ptrToFloat64Array(mod, ptrsPtr, ptrsSize / 8);
    const buildResolver = (arg) => {
      var _a;
      let validity = null;
      if (arg.validityBuffer !== void 0) {
        validity = ptrToUint8Array(mod, ptrs[arg.validityBuffer], desc.rows);
      }
      switch (arg.physicalType) {
        case "VARCHAR": {
          if (arg.dataBuffer === null || arg.dataBuffer === void 0) {
            throw new Error("malformed data view, expected data buffer for VARCHAR argument");
          }
          if (arg.lengthBuffer === null || arg.lengthBuffer === void 0) {
            throw new Error("malformed data view, expected data length buffer for VARCHAR argument");
          }
          const raw = ptrToArray(mod, ptrs[arg.dataBuffer], arg.physicalType, desc.rows);
          const strings = [];
          const stringLengths = ptrToFloat64Array(mod, ptrs[arg.lengthBuffer], desc.rows);
          for (let j = 0; j < desc.rows; ++j) {
            if (validity != null && !validity[j]) {
              strings.push(null);
              continue;
            }
            const subarray = mod.HEAPU8.subarray(
              raw[j],
              raw[j] + stringLengths[j]
            );
            const str = TEXT_DECODER.decode(subarray);
            strings.push(str);
          }
          return (row) => strings[row];
        }
        case "STRUCT": {
          const tmp = {};
          const children = [];
          for (let j = 0; j < (((_a = arg.children) == null ? void 0 : _a.length) || 0); ++j) {
            const attr = arg.children[j];
            const child = buildResolver(attr);
            children.push((row) => {
              tmp[attr.name] = child(row);
            });
          }
          if (validity != null) {
            return (row) => {
              if (!validity[row]) {
                return null;
              }
              for (const resolver of children) {
                resolver(row);
              }
              return tmp;
            };
          } else {
            return (row) => {
              for (const resolver of children) {
                resolver(row);
              }
              return tmp;
            };
          }
        }
        default: {
          if (arg.dataBuffer === void 0) {
            throw new Error(
              "malformed data view, expected data buffer for argument of type: " + arg.physicalType
            );
          }
          const data2 = ptrToArray(mod, ptrs[arg.dataBuffer], arg.physicalType, desc.rows);
          if (validity != null) {
            return (row) => !validity[row] ? null : data2[row];
          } else {
            return (row) => data2[row];
          }
        }
      }
    };
    const argResolvers = [];
    for (let i2 = 0; i2 < desc.args.length; ++i2) {
      argResolvers.push(buildResolver(desc.args[i2]));
    }
    const resultDataLen = desc.rows * getTypeSize(desc.ret.physicalType);
    const resultDataPtr = mod._malloc(resultDataLen);
    const resultData = ptrToArray(mod, resultDataPtr, desc.ret.physicalType, desc.rows);
    const resultValidityPtr = mod._malloc(desc.rows);
    const resultValidity = ptrToUint8Array(mod, resultValidityPtr, desc.rows);
    if (resultData.length == 0 || resultValidity.length == 0) {
      storeError(mod, response, "Can't create physical arrays for result");
      return;
    }
    let rawResultData = resultData;
    if (desc.ret.physicalType == "VARCHAR") {
      rawResultData = new Array(desc.rows);
    }
    const args2 = [];
    for (let i2 = 0; i2 < desc.args.length; ++i2) {
      args2.push(null);
    }
    for (let i2 = 0; i2 < desc.rows; ++i2) {
      for (let j = 0; j < desc.args.length; ++j) {
        args2[j] = argResolvers[j](i2);
      }
      const res = udf.func(...args2);
      rawResultData[i2] = res;
      resultValidity[i2] = res === void 0 || res === null ? 0 : 1;
    }
    let resultLengthsPtr = 0;
    switch (desc.ret.physicalType) {
      case "VARCHAR": {
        const resultDataUTF8 = new Array(0);
        resultLengthsPtr = mod._malloc(desc.rows * getTypeSize("DOUBLE"));
        const resultLengths = ptrToFloat64Array(mod, resultLengthsPtr, desc.rows);
        let totalLength = 0;
        for (let row = 0; row < desc.rows; ++row) {
          const utf8 = TEXT_ENCODER.encode(rawResultData[row] || "");
          resultDataUTF8.push(utf8);
          resultLengths[row] = utf8.length;
          totalLength += utf8.length;
        }
        const resultStringPtr = mod._malloc(totalLength);
        const resultStringBuf = mod.HEAPU8.subarray(resultStringPtr, resultStringPtr + totalLength);
        let writerOffset = 0;
        for (let row = 0; row < desc.rows; ++row) {
          resultData[row] = writerOffset;
          const resultUTF8 = resultDataUTF8[row];
          const writer = resultStringBuf.subarray(writerOffset, writerOffset + resultUTF8.length);
          writer.set(resultUTF8);
          writerOffset += resultUTF8.length;
        }
      }
    }
    const retLen = 3 * 8;
    const retPtr = mod._malloc(retLen);
    const retBuffer = ptrToFloat64Array(mod, retPtr, 3);
    retBuffer[0] = resultDataPtr;
    retBuffer[1] = resultValidityPtr;
    retBuffer[2] = resultLengthsPtr;
    mod.HEAPF64[(response >> 3) + 0] = 0;
    mod.HEAPF64[(response >> 3) + 1] = retPtr;
    mod.HEAPF64[(response >> 3) + 2] = 0;
  } catch (e) {
    storeError(mod, response, e.toString());
  }
}

// src/bindings/runtime.ts
function TextDecoderWrapper() {
  const decoder2 = new TextDecoder();
  return (data2) => {
    if (typeof SharedArrayBuffer !== "undefined" && data2.buffer instanceof SharedArrayBuffer) {
      data2 = new Uint8Array(data2);
    }
    return decoder2.decode(data2);
  };
}
var decodeText = TextDecoderWrapper();
function failWith(mod, msg) {
  console.error(`FAIL WITH: ${msg}`);
  mod.ccall("duckdb_web_fail_with", null, ["string"], [msg]);
}
function copyBuffer(mod, begin, length) {
  const buffer = mod.HEAPU8.subarray(begin, begin + length);
  const copy = new Uint8Array(new ArrayBuffer(buffer.byteLength));
  copy.set(buffer);
  return copy;
}
function readString(mod, begin, length) {
  return decodeText(mod.HEAPU8.subarray(begin, begin + length));
}
function callSRet(mod, funcName, argTypes, args2) {
  const stackPointer = mod.stackSave();
  const response = mod.stackAlloc(3 * 8);
  argTypes.unshift("number");
  args2.unshift(response);
  mod.ccall(funcName, null, argTypes, args2);
  const status = mod.HEAPF64[(response >> 3) + 0];
  const data2 = mod.HEAPF64[(response >> 3) + 1];
  const dataSize = mod.HEAPF64[(response >> 3) + 2];
  mod.stackRestore(stackPointer);
  return [status, data2, dataSize];
}
function dropResponseBuffers(mod) {
  mod.ccall("duckdb_web_clear_response", null, [], []);
}

// src/bindings/file_stats.ts
var FileStatistics = class {
  constructor(u8array) {
    const f64 = new Float64Array(u8array.buffer, u8array.byteOffset, u8array.byteLength / 8);
    const blocks = new Uint8Array(new ArrayBuffer(u8array.byteLength));
    blocks.set(u8array.subarray(7 * 8));
    this.totalFileReadsCold = f64[0];
    this.totalFileReadsAhead = f64[1];
    this.totalFileReadsCached = f64[2];
    this.totalFileWrites = f64[3];
    this.totalPageAccesses = f64[4];
    this.totalPageLoads = f64[5];
    this.blockSize = f64[6];
    this.blockStats = blocks;
  }
  /** The block stats */
  getBlockStats(index, out2) {
    out2 = out2 || {
      file_reads_cold: 0,
      file_reads_ahead: 0,
      file_reads_cached: 0,
      file_writes: 0,
      page_accesses: 0,
      page_loads: 0
    };
    out2.file_writes = this.blockStats[index * 3 + 0] & 15;
    out2.file_reads_cold = this.blockStats[index * 3 + 0] >> 4;
    out2.file_reads_ahead = this.blockStats[index * 3 + 1] & 15;
    out2.file_reads_cached = this.blockStats[index * 3 + 1] >> 4;
    out2.page_accesses = this.blockStats[index * 3 + 1] & 15;
    out2.page_loads = this.blockStats[index * 3 + 1] >> 4;
    return out2;
  }
};

// src/json_typedef.ts
var arrow2 = __toESM(require("apache-arrow"));
function arrowToSQLType(type) {
  switch (type.typeId) {
    case arrow2.Type.Binary:
      return { sqlType: "binary" };
    case arrow2.Type.Bool:
      return { sqlType: "bool" };
    case arrow2.Type.Date:
      return { sqlType: "date" };
    case arrow2.Type.DateDay:
      return { sqlType: "date32[d]" };
    case arrow2.Type.DateMillisecond:
      return { sqlType: "date64[ms]" };
    case arrow2.Type.Decimal: {
      const dec = type;
      return { sqlType: "decimal", precision: dec.precision, scale: dec.scale };
    }
    case arrow2.Type.Float:
      return { sqlType: "float" };
    case arrow2.Type.Float16:
      return { sqlType: "float16" };
    case arrow2.Type.Float32:
      return { sqlType: "float32" };
    case arrow2.Type.Float64:
      return { sqlType: "float64" };
    case arrow2.Type.Int:
      return { sqlType: "int32" };
    case arrow2.Type.Int16:
      return { sqlType: "int16" };
    case arrow2.Type.Int32:
      return { sqlType: "int32" };
    case arrow2.Type.Int64:
      return { sqlType: "int64" };
    case arrow2.Type.Uint16:
      return { sqlType: "uint16" };
    case arrow2.Type.Uint32:
      return { sqlType: "uint32" };
    case arrow2.Type.Uint64:
      return { sqlType: "uint64" };
    case arrow2.Type.Uint8:
      return { sqlType: "uint8" };
    case arrow2.Type.IntervalDayTime:
      return { sqlType: "interval[dt]" };
    case arrow2.Type.IntervalYearMonth:
      return { sqlType: "interval[m]" };
    case arrow2.Type.List: {
      const list = type;
      return {
        sqlType: "list",
        valueType: arrowToSQLType(list.valueType)
      };
    }
    case arrow2.Type.FixedSizeBinary: {
      const bin = type;
      return { sqlType: "fixedsizebinary", byteWidth: bin.byteWidth };
    }
    case arrow2.Type.Null:
      return { sqlType: "null" };
    case arrow2.Type.Utf8:
      return { sqlType: "utf8" };
    case arrow2.Type.Struct: {
      const struct_ = type;
      return {
        sqlType: "struct",
        fields: struct_.children.map((c) => arrowToSQLField(c.name, c.type))
      };
    }
    case arrow2.Type.Map: {
      const map_ = type;
      return {
        sqlType: "map",
        keyType: arrowToSQLType(map_.keyType),
        valueType: arrowToSQLType(map_.valueType)
      };
    }
    case arrow2.Type.Time:
      return { sqlType: "time[s]" };
    case arrow2.Type.TimeMicrosecond:
      return { sqlType: "time[us]" };
    case arrow2.Type.TimeMillisecond:
      return { sqlType: "time[ms]" };
    case arrow2.Type.TimeNanosecond:
      return { sqlType: "time[ns]" };
    case arrow2.Type.TimeSecond:
      return { sqlType: "time[s]" };
    case arrow2.Type.Timestamp: {
      const ts = type;
      return { sqlType: "timestamp", timezone: ts.timezone || void 0 };
    }
    case arrow2.Type.TimestampSecond: {
      const ts = type;
      return { sqlType: "timestamp[s]", timezone: ts.timezone || void 0 };
    }
    case arrow2.Type.TimestampMicrosecond: {
      const ts = type;
      return { sqlType: "timestamp[us]", timezone: ts.timezone || void 0 };
    }
    case arrow2.Type.TimestampNanosecond: {
      const ts = type;
      return { sqlType: "timestamp[ns]", timezone: ts.timezone || void 0 };
    }
    case arrow2.Type.TimestampMillisecond: {
      const ts = type;
      return { sqlType: "timestamp[ms]", timezone: ts.timezone || void 0 };
    }
  }
  throw new Error(`unsupported arrow type: ${type.toString()}`);
}
function arrowToSQLField(name2, type) {
  const t = arrowToSQLType(type);
  t.name = name2;
  return t;
}

// src/bindings/bindings_base.ts
var TEXT_ENCODER2 = new TextEncoder();
var DuckDBBindingsBase = class {
  constructor(logger, runtime2) {
    /** The instance */
    this._instance = null;
    /** The loading promise */
    this._initPromise = null;
    /** The resolver for the open promise (called by onRuntimeInitialized) */
    this._initPromiseResolver = () => {
    };
    /** Instantiate the module */
    this.onInstantiationProgress = [];
    this._logger = logger;
    this._runtime = runtime2;
    this._nextUDFId = 1;
  }
  /** Get the logger */
  get logger() {
    return this._logger;
  }
  /** Get the instance */
  get mod() {
    return this._instance;
  }
  /** Get the instance */
  get pthread() {
    return this.mod.PThread || null;
  }
  /** Instantiate the database */
  async instantiate(onProgress = (_) => {
  }) {
    if (this._instance != null) {
      return this;
    }
    if (this._initPromise != null) {
      this.onInstantiationProgress.push(onProgress);
      await this._initPromise;
    }
    this._initPromise = new Promise((resolve) => {
      this._initPromiseResolver = resolve;
    });
    this.onInstantiationProgress = [onProgress];
    this._instance = await this.instantiateImpl({
      print: console.log.bind(console),
      printErr: console.log.bind(console),
      onRuntimeInitialized: this._initPromiseResolver
    });
    await this._initPromise;
    this._initPromise = null;
    this.onInstantiationProgress = this.onInstantiationProgress.filter((x) => x != onProgress);
    globalThis.DUCKDB_BINDINGS = this;
    return this;
  }
  /** Open a database with a config */
  open(config) {
    const [s2, d, n] = callSRet(this.mod, "duckdb_web_open", ["string"], [JSON.stringify(config)]);
    if (s2 !== 0 /* SUCCESS */) {
      throw new Error(readString(this.mod, d, n));
    }
    dropResponseBuffers(this.mod);
  }
  /** Reset the database */
  reset() {
    const [s2, d, n] = callSRet(this.mod, "duckdb_web_reset", [], []);
    if (s2 !== 0 /* SUCCESS */) {
      throw new Error(readString(this.mod, d, n));
    }
    dropResponseBuffers(this.mod);
  }
  /** Get the version */
  getVersion() {
    const [s2, d, n] = callSRet(this.mod, "duckdb_web_get_version", [], []);
    if (s2 !== 0 /* SUCCESS */) {
      throw new Error(readString(this.mod, d, n));
    }
    const version = readString(this.mod, d, n);
    dropResponseBuffers(this.mod);
    return version;
  }
  /** Get the feature flags */
  getFeatureFlags() {
    return this.mod.ccall("duckdb_web_get_feature_flags", "number", [], []);
  }
  /** Tokenize a script */
  tokenize(text) {
    const [s2, d, n] = callSRet(this.mod, "duckdb_web_tokenize", ["string"], [text]);
    if (s2 !== 0 /* SUCCESS */) {
      throw new Error(readString(this.mod, d, n));
    }
    const res = readString(this.mod, d, n);
    dropResponseBuffers(this.mod);
    return JSON.parse(res);
  }
  /** Connect to database */
  connect() {
    const conn = this.mod.ccall("duckdb_web_connect", "number", [], []);
    return new DuckDBConnection(this, conn);
  }
  /** Disconnect from database */
  disconnect(conn) {
    this.mod.ccall("duckdb_web_disconnect", null, ["number"], [conn]);
    if (this.pthread) {
      for (const worker2 of [...this.pthread.runningWorkers, ...this.pthread.unusedWorkers]) {
        worker2.postMessage({
          cmd: "dropUDFFunctions",
          connectionId: conn
        });
      }
    }
  }
  /** Send a query and return the full result */
  runQuery(conn, text) {
    const [s2, d, n] = callSRet(this.mod, "duckdb_web_query_run", ["number", "string"], [conn, text]);
    if (s2 !== 0 /* SUCCESS */) {
      throw new Error(readString(this.mod, d, n));
    }
    const res = copyBuffer(this.mod, d, n);
    dropResponseBuffers(this.mod);
    return res;
  }
  /**
   *  Start a pending query asynchronously.
   *  This method returns either the arrow ipc schema or null.
   *  On null, the query has to be executed using `pollPendingQuery` until that returns != null.
   *  Results can then be fetched using `fetchQueryResults`
   */
  startPendingQuery(conn, text) {
    const [s2, d, n] = callSRet(this.mod, "duckdb_web_pending_query_start", ["number", "string"], [conn, text]);
    if (s2 !== 0 /* SUCCESS */) {
      throw new Error(readString(this.mod, d, n));
    }
    if (d == 0) {
      return null;
    }
    const res = copyBuffer(this.mod, d, n);
    dropResponseBuffers(this.mod);
    return res;
  }
  /** Poll a pending query */
  pollPendingQuery(conn) {
    const [s2, d, n] = callSRet(this.mod, "duckdb_web_pending_query_poll", ["number"], [conn]);
    if (s2 !== 0 /* SUCCESS */) {
      throw new Error(readString(this.mod, d, n));
    }
    if (d == 0) {
      return null;
    }
    const res = copyBuffer(this.mod, d, n);
    dropResponseBuffers(this.mod);
    return res;
  }
  /** Cancel a pending query */
  cancelPendingQuery(conn) {
    return this.mod.ccall("duckdb_web_pending_query_cancel", "boolean", ["number"], [conn]);
  }
  /** Fetch query results */
  fetchQueryResults(conn) {
    const [s2, d, n] = callSRet(this.mod, "duckdb_web_query_fetch_results", ["number"], [conn]);
    if (s2 !== 0 /* SUCCESS */) {
      throw new Error(readString(this.mod, d, n));
    }
    const res = copyBuffer(this.mod, d, n);
    dropResponseBuffers(this.mod);
    return res;
  }
  /** Get table names */
  getTableNames(conn, text) {
    const [s2, d, n] = callSRet(this.mod, "duckdb_web_get_tablenames", ["number", "string"], [conn, text]);
    if (s2 !== 0 /* SUCCESS */) {
      throw new Error(readString(this.mod, d, n));
    }
    const res = readString(this.mod, d, n);
    dropResponseBuffers(this.mod);
    return JSON.parse(res);
  }
  /** Create a scalar function */
  createScalarFunction(conn, name2, returns, func2) {
    const decl = {
      functionId: this._nextUDFId,
      name: name2,
      returnType: arrowToSQLType(returns)
    };
    const def = {
      functionId: decl.functionId,
      connectionId: conn,
      name: name2,
      returnType: returns,
      func: func2
    };
    this._nextUDFId += 1;
    const [s2, d, n] = callSRet(
      this.mod,
      "duckdb_web_udf_scalar_create",
      ["number", "string"],
      [conn, JSON.stringify(decl)]
    );
    if (s2 !== 0 /* SUCCESS */) {
      throw new Error(readString(this.mod, d, n));
    }
    dropResponseBuffers(this.mod);
    globalThis.DUCKDB_RUNTIME._udfFunctions = (globalThis.DUCKDB_RUNTIME._udfFunctions || /* @__PURE__ */ new Map()).set(
      def.functionId,
      def
    );
    if (this.pthread) {
      for (const worker2 of [...this.pthread.runningWorkers, ...this.pthread.unusedWorkers]) {
        worker2.postMessage({
          cmd: "registerUDFFunction",
          udf: def
        });
      }
    }
  }
  /** Prepare a statement and return its identifier */
  createPrepared(conn, text) {
    const [s2, d, n] = callSRet(this.mod, "duckdb_web_prepared_create", ["number", "string"], [conn, text]);
    if (s2 !== 0 /* SUCCESS */) {
      throw new Error(readString(this.mod, d, n));
    }
    dropResponseBuffers(this.mod);
    return d;
  }
  /** Close a prepared statement */
  closePrepared(conn, statement) {
    const [s2, d, n] = callSRet(this.mod, "duckdb_web_prepared_close", ["number", "number"], [conn, statement]);
    if (s2 !== 0 /* SUCCESS */) {
      throw new Error(readString(this.mod, d, n));
    }
    dropResponseBuffers(this.mod);
  }
  /** Execute a prepared statement and return the full result */
  runPrepared(conn, statement, params) {
    const [s2, d, n] = callSRet(
      this.mod,
      "duckdb_web_prepared_run",
      ["number", "number", "string"],
      [conn, statement, JSON.stringify(params)]
    );
    if (s2 !== 0 /* SUCCESS */) {
      throw new Error(readString(this.mod, d, n));
    }
    const res = copyBuffer(this.mod, d, n);
    dropResponseBuffers(this.mod);
    return res;
  }
  /** Execute a prepared statement and stream the result */
  sendPrepared(conn, statement, params) {
    const [s2, d, n] = callSRet(
      this.mod,
      "duckdb_web_prepared_send",
      ["number", "number", "string"],
      [conn, statement, JSON.stringify(params)]
    );
    if (s2 !== 0 /* SUCCESS */) {
      throw new Error(readString(this.mod, d, n));
    }
    const res = copyBuffer(this.mod, d, n);
    dropResponseBuffers(this.mod);
    return res;
  }
  /** Insert record batches from an arrow ipc stream */
  insertArrowFromIPCStream(conn, buffer, options) {
    if (buffer.length == 0)
      return;
    const bufferPtr = this.mod._malloc(buffer.length);
    const bufferOfs = this.mod.HEAPU8.subarray(bufferPtr, bufferPtr + buffer.length);
    bufferOfs.set(buffer);
    const optJSON = options ? JSON.stringify(options) : "";
    const [s2, d, n] = callSRet(
      this.mod,
      "duckdb_web_insert_arrow_from_ipc_stream",
      ["number", "number", "number", "string"],
      [conn, bufferPtr, buffer.length, optJSON]
    );
    if (s2 !== 0 /* SUCCESS */) {
      throw new Error(readString(this.mod, d, n));
    }
  }
  /** Insert csv from path */
  insertCSVFromPath(conn, path2, options) {
    if (options.columns !== void 0) {
      options.columnsFlat = [];
      for (const k in options.columns) {
        options.columnsFlat.push(arrowToSQLField(k, options.columns[k]));
      }
    }
    const opt = { ...options };
    opt.columns = opt.columnsFlat;
    delete opt.columnsFlat;
    const optJSON = JSON.stringify(opt);
    const [s2, d, n] = callSRet(
      this.mod,
      "duckdb_web_insert_csv_from_path",
      ["number", "string", "string"],
      [conn, path2, optJSON]
    );
    if (s2 !== 0 /* SUCCESS */) {
      throw new Error(readString(this.mod, d, n));
    }
  }
  /** Insert json from path */
  insertJSONFromPath(conn, path2, options) {
    if (options.columns !== void 0) {
      options.columnsFlat = [];
      for (const k in options.columns) {
        options.columnsFlat.push(arrowToSQLField(k, options.columns[k]));
      }
    }
    const opt = { ...options };
    opt.columns = opt.columnsFlat;
    delete opt.columnsFlat;
    const optJSON = JSON.stringify(opt);
    const [s2, d, n] = callSRet(
      this.mod,
      "duckdb_web_insert_json_from_path",
      ["number", "string", "string"],
      [conn, path2, optJSON]
    );
    if (s2 !== 0 /* SUCCESS */) {
      throw new Error(readString(this.mod, d, n));
    }
  }
  /** Glob file infos */
  globFiles(path2) {
    const [s2, d, n] = callSRet(this.mod, "duckdb_web_fs_glob_file_infos", ["string"], [path2]);
    if (s2 !== 0 /* SUCCESS */) {
      throw new Error(readString(this.mod, d, n));
    }
    const infoStr = readString(this.mod, d, n);
    dropResponseBuffers(this.mod);
    const info2 = JSON.parse(infoStr);
    if (info2 == null) {
      return [];
    }
    return info2;
  }
  /** Register a file object URL */
  registerFileURL(name2, url2, proto, directIO = false) {
    if (url2 === void 0) {
      url2 = name2;
    }
    const [s2, d, n] = callSRet(
      this.mod,
      "duckdb_web_fs_register_file_url",
      ["string", "string"],
      [name2, url2, proto, directIO]
    );
    if (s2 !== 0 /* SUCCESS */) {
      throw new Error(readString(this.mod, d, n));
    }
    dropResponseBuffers(this.mod);
  }
  /** Register file text */
  registerFileText(name2, text) {
    const buffer = TEXT_ENCODER2.encode(text);
    this.registerFileBuffer(name2, buffer);
  }
  /** Register a file buffer */
  registerFileBuffer(name2, buffer) {
    const ptr2 = this.mod._malloc(buffer.length);
    const dst = this.mod.HEAPU8.subarray(ptr2, ptr2 + buffer.length);
    dst.set(buffer);
    const [s2, d, n] = callSRet(
      this.mod,
      "duckdb_web_fs_register_file_buffer",
      ["string", "number", "number"],
      [name2, ptr2, buffer.length]
    );
    if (s2 !== 0 /* SUCCESS */) {
      throw new Error(readString(this.mod, d, n));
    }
    dropResponseBuffers(this.mod);
  }
  /** Register a file object URL */
  registerFileHandle(name2, handle2, protocol, directIO) {
    const [s2, d, n] = callSRet(
      this.mod,
      "duckdb_web_fs_register_file_url",
      ["string", "string", "number", "boolean"],
      [name2, name2, protocol, directIO]
    );
    if (s2 !== 0 /* SUCCESS */) {
      throw new Error(readString(this.mod, d, n));
    }
    dropResponseBuffers(this.mod);
    globalThis.DUCKDB_RUNTIME._files = (globalThis.DUCKDB_RUNTIME._files || /* @__PURE__ */ new Map()).set(name2, handle2);
    if (this.pthread) {
      for (const worker2 of this.pthread.runningWorkers) {
        worker2.postMessage({
          cmd: "registerFileHandle",
          fileName: name2,
          fileHandle: handle2
        });
      }
      for (const worker2 of this.pthread.unusedWorkers) {
        worker2.postMessage({
          cmd: "dropFileHandle",
          fileName: name2
        });
      }
    }
  }
  /** Drop file */
  dropFile(name2) {
    const [s2, d, n] = callSRet(this.mod, "duckdb_web_fs_drop_file", ["string"], [name2]);
    if (s2 !== 0 /* SUCCESS */) {
      throw new Error(readString(this.mod, d, n));
    }
    dropResponseBuffers(this.mod);
  }
  /** Drop files */
  dropFiles() {
    const [s2, d, n] = callSRet(this.mod, "duckdb_web_fs_drop_files", [], []);
    if (s2 !== 0 /* SUCCESS */) {
      throw new Error(readString(this.mod, d, n));
    }
    dropResponseBuffers(this.mod);
  }
  /** Flush all files */
  flushFiles() {
    this.mod.ccall("duckdb_web_flush_files", null, [], []);
  }
  /** Write a file to a path */
  copyFileToPath(name2, path2) {
    const [s2, d, n] = callSRet(this.mod, "duckdb_web_copy_file_to_path", ["string", "string"], [name2, path2]);
    if (s2 !== 0 /* SUCCESS */) {
      throw new Error(readString(this.mod, d, n));
    }
    dropResponseBuffers(this.mod);
  }
  /** Write a file to a buffer */
  copyFileToBuffer(name2) {
    const [s2, d, n] = callSRet(this.mod, "duckdb_web_copy_file_to_buffer", ["string"], [name2]);
    if (s2 !== 0 /* SUCCESS */) {
      throw new Error(readString(this.mod, d, n));
    }
    const buffer = this.mod.HEAPU8.subarray(d, d + n);
    const copy = new Uint8Array(buffer.length);
    copy.set(buffer);
    dropResponseBuffers(this.mod);
    return copy;
  }
  /** Enable tracking of file statistics */
  collectFileStatistics(file, enable) {
    const [s2, d, n] = callSRet(this.mod, "duckdb_web_collect_file_stats", ["string", "boolean"], [file, enable]);
    if (s2 !== 0 /* SUCCESS */) {
      throw new Error(readString(this.mod, d, n));
    }
  }
  /** Export file statistics */
  exportFileStatistics(file) {
    const [s2, d, n] = callSRet(this.mod, "duckdb_web_export_file_stats", ["string"], [file]);
    if (s2 !== 0 /* SUCCESS */) {
      throw new Error(readString(this.mod, d, n));
    }
    return new FileStatistics(this.mod.HEAPU8.subarray(d, d + n));
  }
};

// src/log.ts
var VoidLogger = class {
  log(_entry) {
  }
};

// ../../node_modules/wasm-feature-detect/dist/esm/index.js
var bulkMemory = async () => WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 5, 3, 1, 0, 1, 10, 14, 1, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11]));
var exceptions = async () => WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 8, 1, 6, 0, 6, 64, 25, 11, 11]));
var simd = async () => WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 123, 3, 2, 1, 0, 10, 10, 1, 8, 0, 65, 0, 253, 15, 253, 98, 11]));
var threads = () => (async (e) => {
  try {
    return "undefined" != typeof MessageChannel && new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)), WebAssembly.validate(e);
  } catch (e2) {
    return false;
  }
})(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 5, 4, 1, 3, 1, 1, 10, 11, 1, 9, 0, 65, 0, 254, 16, 2, 0, 26, 11]));

// src/platform.ts
var isNode = () => typeof navigator === "undefined" ? true : false;
var bigInt64Array = null;
var wasmExceptions = null;
var wasmThreads = null;
var wasmSIMD = null;
var wasmBulkMemory = null;
async function getPlatformFeatures() {
  if (bigInt64Array == null) {
    bigInt64Array = typeof BigInt64Array != "undefined";
  }
  if (wasmExceptions == null) {
    wasmExceptions = await exceptions();
  }
  if (wasmThreads == null) {
    wasmThreads = await threads();
  }
  if (wasmSIMD == null) {
    wasmSIMD = await simd();
  }
  if (wasmBulkMemory == null) {
    wasmBulkMemory = await bulkMemory();
  }
  return {
    bigInt64Array,
    crossOriginIsolated: isNode() || globalThis.crossOriginIsolated || false,
    wasmExceptions,
    wasmSIMD,
    wasmThreads,
    wasmBulkMemory
  };
}
async function selectBundle(bundles) {
  const platform = await getPlatformFeatures();
  if (platform.wasmExceptions) {
    if (platform.wasmSIMD && platform.wasmThreads && platform.crossOriginIsolated && bundles.coi) {
      return {
        mainModule: bundles.coi.mainModule,
        mainWorker: bundles.coi.mainWorker,
        pthreadWorker: bundles.coi.pthreadWorker
      };
    }
    if (bundles.eh) {
      return {
        mainModule: bundles.eh.mainModule,
        mainWorker: bundles.eh.mainWorker,
        pthreadWorker: null
      };
    }
  }
  return {
    mainModule: bundles.mvp.mainModule,
    mainWorker: bundles.mvp.mainWorker,
    pthreadWorker: null
  };
}

// src/bindings/runtime_node.ts
var import_fs = __toESM(require("fs"));
var fg = __toESM(require_out4());
var NODE_RUNTIME = {
  _files: /* @__PURE__ */ new Map(),
  _filesById: /* @__PURE__ */ new Map(),
  _fileInfoCache: /* @__PURE__ */ new Map(),
  _udfFunctions: /* @__PURE__ */ new Map(),
  resolveFileInfo(mod, fileId) {
    try {
      const cached = NODE_RUNTIME._fileInfoCache.get(fileId);
      const [s2, d, n] = callSRet(
        mod,
        "duckdb_web_fs_get_file_info_by_id",
        ["number", "number"],
        [fileId, (cached == null ? void 0 : cached.cacheEpoch) || 0]
      );
      if (s2 !== 0 /* SUCCESS */) {
        failWith(mod, readString(mod, d, n));
        return null;
      } else if (n === 0) {
        dropResponseBuffers(mod);
        return cached;
      }
      const infoStr = readString(mod, d, n);
      dropResponseBuffers(mod);
      const info2 = JSON.parse(infoStr);
      if (info2 == null)
        return null;
      NODE_RUNTIME._fileInfoCache.set(fileId, info2);
      return info2;
    } catch (e) {
      console.log(e);
      failWith(mod, e.toString());
      return null;
    }
  },
  testPlatformFeature: (_mod, feature) => {
    switch (feature) {
      case 1:
        return typeof BigInt64Array !== "undefined";
      default:
        console.warn(`test for unknown feature: ${feature}`);
        return false;
    }
  },
  getDefaultDataProtocol(mod) {
    return 1 /* NODE_FS */;
  },
  openFile(mod, fileId, flags2) {
    var _a, _b;
    try {
      NODE_RUNTIME._fileInfoCache.delete(fileId);
      const file = NODE_RUNTIME.resolveFileInfo(mod, fileId);
      switch (file == null ? void 0 : file.dataProtocol) {
        case 1 /* NODE_FS */: {
          let fd = (_a = NODE_RUNTIME._files) == null ? void 0 : _a.get(file.dataUrl);
          if (fd === null || fd === void 0) {
            fd = import_fs.default.openSync(
              file.dataUrl,
              import_fs.default.constants.O_CREAT | import_fs.default.constants.O_RDWR,
              import_fs.default.constants.S_IRUSR | import_fs.default.constants.S_IWUSR
            );
            (_b = NODE_RUNTIME._filesById) == null ? void 0 : _b.set(file.fileId, fd);
          }
          const fileSize = import_fs.default.fstatSync(fd).size;
          const result = mod._malloc(2 * 8);
          mod.HEAPF64[(result >> 3) + 0] = +fileSize;
          mod.HEAPF64[(result >> 3) + 1] = 0;
          return result;
        }
        case 2 /* BROWSER_FILEREADER */:
        case 3 /* BROWSER_FSACCESS */:
        case 4 /* HTTP */:
        case 5 /* S3 */:
          failWith(mod, "Unsupported data protocol");
      }
    } catch (e) {
      console.log(e);
      failWith(mod, e.toString());
    }
    return 0;
  },
  syncFile: (_mod, _fileId) => {
  },
  closeFile: (mod, fileId) => {
    try {
      const fileInfo = NODE_RUNTIME._fileInfoCache.get(fileId);
      NODE_RUNTIME._fileInfoCache.delete(fileId);
      switch (fileInfo == null ? void 0 : fileInfo.dataProtocol) {
        case 1 /* NODE_FS */: {
          const fileHandle = NODE_RUNTIME._filesById.get(fileId);
          NODE_RUNTIME._filesById.delete(fileId);
          if (fileHandle !== null && fileHandle !== void 0) {
            import_fs.default.closeSync(fileHandle);
          }
          break;
        }
        case 2 /* BROWSER_FILEREADER */:
        case 3 /* BROWSER_FSACCESS */:
        case 4 /* HTTP */:
        case 5 /* S3 */:
          break;
      }
    } catch (e) {
      console.log(e);
      failWith(mod, e.toString());
    }
    return 0;
  },
  truncateFile: (mod, fileId, newSize) => {
    try {
      const file = NODE_RUNTIME.resolveFileInfo(mod, fileId);
      switch (file == null ? void 0 : file.dataProtocol) {
        case 1 /* NODE_FS */: {
          import_fs.default.truncateSync(file.dataUrl, newSize);
          break;
        }
        case 2 /* BROWSER_FILEREADER */:
        case 3 /* BROWSER_FSACCESS */:
        case 4 /* HTTP */:
        case 5 /* S3 */:
          failWith(mod, "Unsupported data protocol");
      }
    } catch (e) {
      console.log(e);
      failWith(mod, e.toString());
    }
    return 0;
  },
  readFile: (mod, fileId, buf, bytes, location) => {
    try {
      const file = NODE_RUNTIME.resolveFileInfo(mod, fileId);
      switch (file == null ? void 0 : file.dataProtocol) {
        case 1 /* NODE_FS */: {
          const fileHandle = NODE_RUNTIME._filesById.get(fileId);
          if (fileHandle === null || fileHandle === void 0) {
            failWith(mod, `File ${fileId} is missing a file descriptor`);
            return 0;
          }
          return import_fs.default.readSync(fileHandle, mod.HEAPU8, buf, bytes, location);
        }
        case 2 /* BROWSER_FILEREADER */:
        case 3 /* BROWSER_FSACCESS */:
        case 4 /* HTTP */:
        case 5 /* S3 */:
          failWith(mod, "Unsupported data protocol");
      }
    } catch (e) {
      console.log(e);
      failWith(mod, e.toString());
    }
    return 0;
  },
  writeFile: (mod, fileId, buf, bytes, location) => {
    try {
      const file = NODE_RUNTIME.resolveFileInfo(mod, fileId);
      switch (file == null ? void 0 : file.dataProtocol) {
        case 1 /* NODE_FS */: {
          const fileHandle = NODE_RUNTIME._filesById.get(fileId);
          if (fileHandle === null || fileHandle === void 0) {
            failWith(mod, `File ${fileId} is missing a file descriptor`);
            return 0;
          }
          const src = mod.HEAPU8.subarray(buf, buf + bytes);
          return import_fs.default.writeSync(fileHandle, src, 0, src.length, location);
        }
        case 2 /* BROWSER_FILEREADER */:
        case 3 /* BROWSER_FSACCESS */:
        case 4 /* HTTP */:
        case 5 /* S3 */:
          failWith(mod, "Unsupported data protocol");
      }
    } catch (e) {
      console.log(e);
      failWith(mod, e.toString());
    }
    return 0;
  },
  getLastFileModificationTime: (mod, fileId) => {
    try {
      const file = NODE_RUNTIME.resolveFileInfo(mod, fileId);
      switch (file == null ? void 0 : file.dataProtocol) {
        case 1 /* NODE_FS */: {
          const fileHandle = NODE_RUNTIME._filesById.get(fileId);
          if (fileHandle === null || fileHandle === void 0) {
            failWith(mod, `File ${fileId} is missing a file descriptor`);
            return 0;
          }
          return import_fs.default.fstatSync(fileHandle).mtime.getTime();
        }
        case 2 /* BROWSER_FILEREADER */:
        case 3 /* BROWSER_FSACCESS */:
        case 4 /* HTTP */:
        case 5 /* S3 */:
          failWith(mod, "Unsupported data protocol");
      }
    } catch (e) {
      console.log(e);
      failWith(mod, e.toString());
    }
    return 0;
  },
  checkDirectory: (mod, pathPtr, pathLen) => {
    try {
      const path2 = decodeText(mod.HEAPU8.subarray(pathPtr, pathPtr + pathLen));
      return import_fs.default.existsSync(path2);
    } catch (e) {
      console.log(e);
      failWith(mod, e.toString());
      return false;
    }
  },
  createDirectory: (mod, pathPtr, pathLen) => {
    try {
      const path2 = decodeText(mod.HEAPU8.subarray(pathPtr, pathPtr + pathLen));
      return import_fs.default.mkdirSync(path2);
    } catch (e) {
      console.log(e);
      failWith(mod, e.toString());
      return 0;
    }
  },
  removeDirectory: (mod, pathPtr, pathLen) => {
    try {
      const path2 = decodeText(mod.HEAPU8.subarray(pathPtr, pathPtr + pathLen));
      return import_fs.default.rmdirSync(path2);
    } catch (e) {
      console.log(e);
      failWith(mod, e.toString());
      return 0;
    }
  },
  listDirectoryEntries: (mod, _pathPtr, _pathLen) => {
    failWith(mod, "Not Implemented");
    return false;
  },
  glob: (mod, pathPtr, pathLen) => {
    try {
      const path2 = readString(mod, pathPtr, pathLen);
      const entries = fg.sync([path2], { dot: true });
      for (const entry of entries) {
        mod.ccall("duckdb_web_fs_glob_add_path", null, ["string"], [entry]);
      }
    } catch (e) {
      console.log(e);
      failWith(mod, e.toString());
      return 0;
    }
  },
  moveFile: (mod, fromPtr, fromLen, toPtr, toLen) => {
    var _a, _b;
    const from = readString(mod, fromPtr, fromLen);
    const to = readString(mod, toPtr, toLen);
    const handle2 = (_a = NODE_RUNTIME._files) == null ? void 0 : _a.get(from);
    if (handle2 !== void 0) {
      NODE_RUNTIME._files.delete(handle2);
      NODE_RUNTIME._files.set(to, handle2);
    }
    for (const [key, value] of ((_b = NODE_RUNTIME._fileInfoCache) == null ? void 0 : _b.entries()) || []) {
      if (value.dataUrl == from) {
        NODE_RUNTIME._fileInfoCache.delete(key);
        break;
      }
    }
    return true;
  },
  checkFile: (mod, pathPtr, pathLen) => {
    try {
      const path2 = decodeText(mod.HEAPU8.subarray(pathPtr, pathPtr + pathLen));
      return import_fs.default.existsSync(path2);
    } catch (e) {
      console.log(e);
      failWith(mod, e.toString());
      return false;
    }
  },
  removeFile: (mod, pathPtr, pathLen) => {
    try {
      const path2 = decodeText(mod.HEAPU8.subarray(pathPtr, pathPtr + pathLen));
      return import_fs.default.rmSync(path2);
    } catch (e) {
      console.log(e);
      failWith(mod, e.toString());
      return 0;
    }
  },
  callScalarUDF: (mod, response, funcId, descPtr, descSize, ptrsPtr, ptrsSize) => {
    callScalarUDF(NODE_RUNTIME, mod, response, funcId, descPtr, descSize, ptrsPtr, ptrsSize);
  }
};

// src/bindings/bindings_node_mvp.ts
var import_duckdb_mvp2 = __toESM(require_duckdb_mvp());

// src/bindings/bindings_node_base.ts
var import_duckdb_mvp = __toESM(require_duckdb_mvp());
var import_fs2 = __toESM(require("fs"));
var DuckDBNodeBindings = class extends DuckDBBindingsBase {
  /** Constructor */
  constructor(logger, runtime2, mainModulePath, pthreadWorkerPath) {
    super(logger, runtime2);
    this.mainModulePath = mainModulePath;
    this.pthreadWorkerPath = pthreadWorkerPath;
  }
  /** Locate a file */
  locateFile(path2, prefix) {
    if (path2.endsWith(".wasm")) {
      return this.mainModulePath;
    }
    if (path2.endsWith(".worker.js")) {
      if (!this.pthreadWorkerPath) {
        throw new Error("Missing DuckDB worker path!");
      }
      return this.pthreadWorkerPath;
    }
    throw new Error(`WASM instantiation requested unexpected file: prefix=${prefix} path=${path2}`);
  }
  /** Instantiate the wasm module */
  instantiateWasm(imports, success) {
    globalThis.DUCKDB_RUNTIME = {};
    for (const func2 of Object.getOwnPropertyNames(this._runtime)) {
      if (func2 == "constructor")
        continue;
      globalThis.DUCKDB_RUNTIME[func2] = Object.getOwnPropertyDescriptor(this._runtime, func2).value;
    }
    const buf = import_fs2.default.readFileSync(this.mainModulePath);
    WebAssembly.instantiate(buf, imports).then((output) => {
      success(output.instance, output.module);
    });
    return [];
  }
  /** Instantiate the bindings */
  instantiateImpl(moduleOverrides2) {
    return (0, import_duckdb_mvp.default)({
      ...moduleOverrides2,
      instantiateWasm: this.instantiateWasm.bind(this)
    });
  }
};

// src/bindings/bindings_node_mvp.ts
var DuckDB2 = class extends DuckDBNodeBindings {
  /** Constructor */
  constructor(logger, runtime2, mainModulePath, pthreadWorkerPath = null) {
    super(logger, runtime2, mainModulePath, pthreadWorkerPath);
  }
  /** Instantiate the bindings */
  instantiateImpl(moduleOverrides2) {
    return (0, import_duckdb_mvp2.default)({
      ...moduleOverrides2,
      instantiateWasm: this.instantiateWasm.bind(this),
      locateFile: this.locateFile.bind(this)
    });
  }
};

// src/bindings/bindings_node_eh.ts
var import_duckdb_eh = __toESM(require_duckdb_eh());
var DuckDB3 = class extends DuckDBNodeBindings {
  /** Constructor */
  constructor(logger, runtime2, mainModulePath, pthreadWorkerPath = null) {
    super(logger, runtime2, mainModulePath, pthreadWorkerPath);
  }
  /** Instantiate the bindings */
  instantiateImpl(moduleOverrides2) {
    return (0, import_duckdb_eh.default)({
      ...moduleOverrides2,
      instantiateWasm: this.instantiateWasm.bind(this),
      locateFile: this.locateFile.bind(this)
    });
  }
};

// src/targets/duckdb-node-blocking.ts
async function createDuckDB(bundles, logger, runtime2) {
  const platform = await getPlatformFeatures();
  if (platform.wasmExceptions) {
    if (bundles.eh) {
      return new DuckDB3(logger, runtime2, bundles.eh.mainModule);
    }
  }
  return new DuckDB2(logger, runtime2, bundles.mvp.mainModule);
}

// src/parallel/async_connection.ts
var arrow3 = __toESM(require("apache-arrow"));
var AsyncDuckDBConnection = class {
  constructor(bindings, conn) {
    this._bindings = bindings;
    this._conn = conn;
  }
  /** Access the database bindings */
  get bindings() {
    return this._bindings;
  }
  /** Disconnect from the database */
  async close() {
    return this._bindings.disconnect(this._conn);
  }
  /** Brave souls may use this function to consume the underlying connection id */
  useUnsafe(callback) {
    return callback(this._bindings, this._conn);
  }
  /** Run a query */
  async query(text) {
    this._bindings.logger.log({
      timestamp: /* @__PURE__ */ new Date(),
      level: 2 /* INFO */,
      origin: 4 /* ASYNC_DUCKDB */,
      topic: 4 /* QUERY */,
      event: 4 /* RUN */,
      value: text
    });
    const buffer = await this._bindings.runQuery(this._conn, text);
    const reader = arrow3.RecordBatchReader.from(buffer);
    console.assert(reader.isSync(), "Reader is not sync");
    console.assert(reader.isFile(), "Reader is not file");
    return new arrow3.Table(reader);
  }
  /** Send a query */
  async send(text) {
    this._bindings.logger.log({
      timestamp: /* @__PURE__ */ new Date(),
      level: 2 /* INFO */,
      origin: 4 /* ASYNC_DUCKDB */,
      topic: 4 /* QUERY */,
      event: 4 /* RUN */,
      value: text
    });
    let header = await this._bindings.startPendingQuery(this._conn, text);
    while (header == null) {
      header = await this._bindings.pollPendingQuery(this._conn);
    }
    const iter = new AsyncResultStreamIterator(this._bindings, this._conn, header);
    const reader = await arrow3.RecordBatchReader.from(iter);
    console.assert(reader.isAsync());
    console.assert(reader.isStream());
    return reader;
  }
  /** Cancel a query that was sent earlier */
  async cancelSent() {
    return await this._bindings.cancelPendingQuery(this._conn);
  }
  /** Get table names */
  async getTableNames(query) {
    return await this._bindings.getTableNames(this._conn, query);
  }
  /** Create a prepared statement */
  async prepare(text) {
    const stmt = await this._bindings.createPrepared(this._conn, text);
    return new AsyncPreparedStatement(this._bindings, this._conn, stmt);
  }
  /** Insert an arrow table */
  async insertArrowTable(table, options) {
    const buffer = arrow3.tableToIPC(table, "stream");
    await this.insertArrowFromIPCStream(buffer, options);
  }
  /** Insert an arrow table from an ipc stream */
  async insertArrowFromIPCStream(buffer, options) {
    await this._bindings.insertArrowFromIPCStream(this._conn, buffer, options);
  }
  /** Insert csv file from path */
  async insertCSVFromPath(text, options) {
    await this._bindings.insertCSVFromPath(this._conn, text, options);
  }
  /** Insert json file from path */
  async insertJSONFromPath(text, options) {
    await this._bindings.insertJSONFromPath(this._conn, text, options);
  }
};
var AsyncResultStreamIterator = class {
  constructor(db2, conn, header) {
    this.db = db2;
    this.conn = conn;
    this.header = header;
    this._first = true;
    this._depleted = false;
    this._inFlight = null;
  }
  async next() {
    if (this._first) {
      this._first = false;
      return { done: false, value: this.header };
    }
    if (this._depleted) {
      return { done: true, value: null };
    }
    let buffer;
    if (this._inFlight != null) {
      buffer = await this._inFlight;
      this._inFlight = null;
    } else {
      buffer = await this.db.fetchQueryResults(this.conn);
    }
    this._depleted = buffer.length == 0;
    if (!this._depleted) {
      this._inFlight = this.db.fetchQueryResults(this.conn);
    }
    return {
      done: this._depleted,
      value: buffer
    };
  }
  [Symbol.asyncIterator]() {
    return this;
  }
};
var AsyncPreparedStatement = class {
  /** Constructor */
  constructor(bindings, connectionId, statementId) {
    this.bindings = bindings;
    this.connectionId = connectionId;
    this.statementId = statementId;
  }
  /** Close a prepared statement */
  async close() {
    await this.bindings.closePrepared(this.connectionId, this.statementId);
  }
  /** Run a prepared statement */
  async query(...params) {
    const buffer = await this.bindings.runPrepared(this.connectionId, this.statementId, params);
    const reader = arrow3.RecordBatchReader.from(buffer);
    console.assert(reader.isSync());
    console.assert(reader.isFile());
    return new arrow3.Table(reader);
  }
  /** Send a prepared statement */
  async send(...params) {
    const header = await this.bindings.sendPrepared(this.connectionId, this.statementId, params);
    const iter = new AsyncResultStreamIterator(this.bindings, this.connectionId, header);
    const reader = await arrow3.RecordBatchReader.from(iter);
    console.assert(reader.isAsync());
    console.assert(reader.isStream());
    return reader;
  }
};

// src/parallel/worker_request.ts
var WorkerTask = class {
  constructor(type, data2) {
    this.promiseResolver = () => {
    };
    this.promiseRejecter = () => {
    };
    this.type = type;
    this.data = data2;
    this.promise = new Promise(
      (resolve, reject) => {
        this.promiseResolver = resolve;
        this.promiseRejecter = reject;
      }
    );
  }
};

// src/parallel/async_bindings.ts
var TEXT_ENCODER3 = new TextEncoder();
var AsyncDuckDB = class {
  constructor(logger, worker2 = null) {
    /** Instantiate the module */
    this._onInstantiationProgress = [];
    /** The worker */
    this._worker = null;
    /** The promise for the worker shutdown */
    this._workerShutdownPromise = null;
    /** Make the worker as terminated */
    this._workerShutdownResolver = () => {
    };
    /** The next message id */
    this._nextMessageId = 0;
    /** The pending requests */
    this._pendingRequests = /* @__PURE__ */ new Map();
    this._logger = logger;
    this._onMessageHandler = this.onMessage.bind(this);
    this._onErrorHandler = this.onError.bind(this);
    this._onCloseHandler = this.onClose.bind(this);
    if (worker2 != null)
      this.attach(worker2);
  }
  /** Get the logger */
  get logger() {
    return this._logger;
  }
  /** Attach to worker */
  attach(worker2) {
    this._worker = worker2;
    this._worker.addEventListener("message", this._onMessageHandler);
    this._worker.addEventListener("error", this._onErrorHandler);
    this._worker.addEventListener("close", this._onCloseHandler);
    this._workerShutdownPromise = new Promise(
      (resolve, _reject) => {
        this._workerShutdownResolver = resolve;
      }
    );
  }
  /** Detach from worker */
  detach() {
    if (!this._worker)
      return;
    this._worker.removeEventListener("message", this._onMessageHandler);
    this._worker.removeEventListener("error", this._onErrorHandler);
    this._worker.removeEventListener("close", this._onCloseHandler);
    this._worker = null;
    this._workerShutdownResolver(null);
    this._workerShutdownPromise = null;
    this._workerShutdownResolver = () => {
    };
  }
  /** Kill the worker */
  async terminate() {
    if (!this._worker)
      return;
    this._worker.terminate();
    this._worker = null;
    this._workerShutdownPromise = null;
    this._workerShutdownResolver = () => {
    };
  }
  /** Post a task */
  async postTask(task, transfer = []) {
    if (!this._worker) {
      console.error("cannot send a message since the worker is not set!");
      return void 0;
    }
    const mid = this._nextMessageId++;
    this._pendingRequests.set(mid, task);
    this._worker.postMessage(
      {
        messageId: mid,
        type: task.type,
        data: task.data
      },
      transfer
    );
    return await task.promise;
  }
  /** Received a message */
  onMessage(event2) {
    var _a;
    const response = event2.data;
    switch (response.type) {
      case "LOG" /* LOG */: {
        this._logger.log(response.data);
        return;
      }
      case "INSTANTIATE_PROGRESS" /* INSTANTIATE_PROGRESS */: {
        for (const p of this._onInstantiationProgress) {
          p(response.data);
        }
        return;
      }
    }
    const task = this._pendingRequests.get(response.requestId);
    if (!task) {
      console.warn(`unassociated response: [${response.requestId}, ${response.type.toString()}]`);
      return;
    }
    this._pendingRequests.delete(response.requestId);
    if (response.type == "ERROR" /* ERROR */) {
      const e = new Error(response.data.message);
      e.name = response.data.name;
      if ((_a = Object.getOwnPropertyDescriptor(e, "stack")) == null ? void 0 : _a.writable) {
        e.stack = response.data.stack;
      }
      task.promiseRejecter(e);
      return;
    }
    switch (task.type) {
      case "CLOSE_PREPARED" /* CLOSE_PREPARED */:
      case "COLLECT_FILE_STATISTICS" /* COLLECT_FILE_STATISTICS */:
      case "COPY_FILE_TO_PATH" /* COPY_FILE_TO_PATH */:
      case "DISCONNECT" /* DISCONNECT */:
      case "DROP_FILE" /* DROP_FILE */:
      case "DROP_FILES" /* DROP_FILES */:
      case "FLUSH_FILES" /* FLUSH_FILES */:
      case "INSERT_ARROW_FROM_IPC_STREAM" /* INSERT_ARROW_FROM_IPC_STREAM */:
      case "IMPORT_CSV_FROM_PATH" /* INSERT_CSV_FROM_PATH */:
      case "IMPORT_JSON_FROM_PATH" /* INSERT_JSON_FROM_PATH */:
      case "OPEN" /* OPEN */:
      case "PING" /* PING */:
      case "REGISTER_FILE_BUFFER" /* REGISTER_FILE_BUFFER */:
      case "REGISTER_FILE_HANDLE" /* REGISTER_FILE_HANDLE */:
      case "REGISTER_FILE_URL" /* REGISTER_FILE_URL */:
      case "RESET" /* RESET */:
        if (response.type == "OK" /* OK */) {
          task.promiseResolver(response.data);
          return;
        }
        break;
      case "INSTANTIATE" /* INSTANTIATE */:
        this._onInstantiationProgress = [];
        if (response.type == "OK" /* OK */) {
          task.promiseResolver(response.data);
          return;
        }
        break;
      case "GLOB_FILE_INFOS" /* GLOB_FILE_INFOS */:
        if (response.type == "FILE_INFOS" /* FILE_INFOS */) {
          task.promiseResolver(response.data);
          return;
        }
        break;
      case "GET_VERSION" /* GET_VERSION */:
        if (response.type == "VERSION_STRING" /* VERSION_STRING */) {
          task.promiseResolver(response.data);
          return;
        }
        break;
      case "GET_FEATURE_FLAGS" /* GET_FEATURE_FLAGS */:
        if (response.type == "FEATURE_FLAGS" /* FEATURE_FLAGS */) {
          task.promiseResolver(response.data);
          return;
        }
        break;
      case "GET_TABLE_NAMES" /* GET_TABLE_NAMES */:
        if (response.type == "TABLE_NAMES" /* TABLE_NAMES */) {
          task.promiseResolver(response.data);
          return;
        }
        break;
      case "TOKENIZE" /* TOKENIZE */:
        if (response.type == "SCRIPT_TOKENS" /* SCRIPT_TOKENS */) {
          task.promiseResolver(response.data);
          return;
        }
        break;
      case "COPY_FILE_TO_BUFFER" /* COPY_FILE_TO_BUFFER */:
        if (response.type == "FILE_BUFFER" /* FILE_BUFFER */) {
          task.promiseResolver(response.data);
          return;
        }
        break;
      case "EXPORT_FILE_STATISTICS" /* EXPORT_FILE_STATISTICS */:
        if (response.type == "FILE_STATISTICS" /* FILE_STATISTICS */) {
          task.promiseResolver(response.data);
          return;
        }
        break;
      case "CONNECT" /* CONNECT */:
        if (response.type == "CONNECTION_INFO" /* CONNECTION_INFO */) {
          task.promiseResolver(response.data);
          return;
        }
        break;
      case "RUN_PREPARED" /* RUN_PREPARED */:
      case "RUN_QUERY" /* RUN_QUERY */:
        if (response.type == "QUERY_RESULT" /* QUERY_RESULT */) {
          task.promiseResolver(response.data);
          return;
        }
        break;
      case "SEND_PREPARED" /* SEND_PREPARED */:
        if (response.type == "QUERY_RESULT_HEADER" /* QUERY_RESULT_HEADER */) {
          task.promiseResolver(response.data);
          return;
        }
        break;
      case "START_PENDING_QUERY" /* START_PENDING_QUERY */:
        if (response.type == "QUERY_RESULT_HEADER_OR_NULL" /* QUERY_RESULT_HEADER_OR_NULL */) {
          task.promiseResolver(response.data);
          return;
        }
        break;
      case "POLL_PENDING_QUERY" /* POLL_PENDING_QUERY */:
        if (response.type == "QUERY_RESULT_HEADER_OR_NULL" /* QUERY_RESULT_HEADER_OR_NULL */) {
          task.promiseResolver(response.data);
          return;
        }
        break;
      case "CANCEL_PENDING_QUERY" /* CANCEL_PENDING_QUERY */:
        this._onInstantiationProgress = [];
        if (response.type == "SUCCESS" /* SUCCESS */) {
          task.promiseResolver(response.data);
          return;
        }
        break;
      case "FETCH_QUERY_RESULTS" /* FETCH_QUERY_RESULTS */:
        if (response.type == "QUERY_RESULT_CHUNK" /* QUERY_RESULT_CHUNK */) {
          task.promiseResolver(response.data);
          return;
        }
        break;
      case "CREATE_PREPARED" /* CREATE_PREPARED */:
        if (response.type == "PREPARED_STATEMENT_ID" /* PREPARED_STATEMENT_ID */) {
          task.promiseResolver(response.data);
          return;
        }
        break;
    }
    task.promiseRejecter(new Error(`unexpected response type: ${response.type.toString()}`));
  }
  /** Received an error */
  onError(event2) {
    console.error(event2);
    console.error(`error in duckdb worker: ${event2.message}`);
    this._pendingRequests.clear();
  }
  /** The worker was closed */
  onClose() {
    this._workerShutdownResolver(null);
    if (this._pendingRequests.size != 0) {
      console.warn(`worker terminated with ${this._pendingRequests.size} pending requests`);
      return;
    }
    this._pendingRequests.clear();
  }
  /** Reset the duckdb */
  async reset() {
    const task = new WorkerTask("RESET" /* RESET */, null);
    return await this.postTask(task);
  }
  /** Ping the worker thread */
  async ping() {
    const task = new WorkerTask("PING" /* PING */, null);
    await this.postTask(task);
  }
  /** Try to drop a file */
  async dropFile(name2) {
    const task = new WorkerTask("DROP_FILE" /* DROP_FILE */, name2);
    return await this.postTask(task);
  }
  /** Try to drop files */
  async dropFiles() {
    const task = new WorkerTask("DROP_FILES" /* DROP_FILES */, null);
    return await this.postTask(task);
  }
  /** Flush all files */
  async flushFiles() {
    const task = new WorkerTask("FLUSH_FILES" /* FLUSH_FILES */, null);
    return await this.postTask(task);
  }
  /** Open the database */
  async instantiate(mainModuleURL, pthreadWorkerURL = null, progress = (_p) => {
  }) {
    this._onInstantiationProgress.push(progress);
    const task = new WorkerTask(
      "INSTANTIATE" /* INSTANTIATE */,
      [mainModuleURL, pthreadWorkerURL]
    );
    return await this.postTask(task);
  }
  /** Get the version */
  async getVersion() {
    const task = new WorkerTask("GET_VERSION" /* GET_VERSION */, null);
    const version = await this.postTask(task);
    return version;
  }
  /** Get the feature flags */
  async getFeatureFlags() {
    const task = new WorkerTask(
      "GET_FEATURE_FLAGS" /* GET_FEATURE_FLAGS */,
      null
    );
    const feature = await this.postTask(task);
    return feature;
  }
  /** Open a new database */
  async open(config) {
    const task = new WorkerTask("OPEN" /* OPEN */, config);
    await this.postTask(task);
  }
  /** Tokenize a script text */
  async tokenize(text) {
    const task = new WorkerTask("TOKENIZE" /* TOKENIZE */, text);
    const tokens = await this.postTask(task);
    return tokens;
  }
  /** Connect to the database */
  async connectInternal() {
    const task = new WorkerTask("CONNECT" /* CONNECT */, null);
    return await this.postTask(task);
  }
  /** Connect to the database */
  async connect() {
    const cid = await this.connectInternal();
    return new AsyncDuckDBConnection(this, cid);
  }
  /** Disconnect from the database */
  async disconnect(conn) {
    const task = new WorkerTask(
      "DISCONNECT" /* DISCONNECT */,
      conn
    );
    await this.postTask(task);
  }
  /** Run a query */
  async runQuery(conn, text) {
    const task = new WorkerTask(
      "RUN_QUERY" /* RUN_QUERY */,
      [conn, text]
    );
    return await this.postTask(task);
  }
  /** Start a pending query */
  async startPendingQuery(conn, text) {
    const task = new WorkerTask(
      "START_PENDING_QUERY" /* START_PENDING_QUERY */,
      [conn, text]
    );
    return await this.postTask(task);
  }
  /** Poll a pending query */
  async pollPendingQuery(conn) {
    const task = new WorkerTask(
      "POLL_PENDING_QUERY" /* POLL_PENDING_QUERY */,
      conn
    );
    return await this.postTask(task);
  }
  /** Cancel a pending query */
  async cancelPendingQuery(conn) {
    const task = new WorkerTask(
      "CANCEL_PENDING_QUERY" /* CANCEL_PENDING_QUERY */,
      conn
    );
    return await this.postTask(task);
  }
  /** Fetch query results */
  async fetchQueryResults(conn) {
    const task = new WorkerTask(
      "FETCH_QUERY_RESULTS" /* FETCH_QUERY_RESULTS */,
      conn
    );
    return await this.postTask(task);
  }
  /** Get table names */
  async getTableNames(conn, text) {
    const task = new WorkerTask(
      "GET_TABLE_NAMES" /* GET_TABLE_NAMES */,
      [conn, text]
    );
    return await this.postTask(task);
  }
  /** Prepare a statement and return its identifier */
  async createPrepared(conn, text) {
    const task = new WorkerTask(
      "CREATE_PREPARED" /* CREATE_PREPARED */,
      [conn, text]
    );
    return await this.postTask(task);
  }
  /** Close a prepared statement */
  async closePrepared(conn, statement) {
    const task = new WorkerTask(
      "CLOSE_PREPARED" /* CLOSE_PREPARED */,
      [conn, statement]
    );
    await this.postTask(task);
  }
  /** Execute a prepared statement and return the full result */
  async runPrepared(conn, statement, params) {
    const task = new WorkerTask(
      "RUN_PREPARED" /* RUN_PREPARED */,
      [conn, statement, params]
    );
    return await this.postTask(task);
  }
  /** Execute a prepared statement and stream the result */
  async sendPrepared(conn, statement, params) {
    const task = new WorkerTask(
      "SEND_PREPARED" /* SEND_PREPARED */,
      [conn, statement, params]
    );
    return await this.postTask(task);
  }
  /** Glob file infos */
  async globFiles(path2) {
    const task = new WorkerTask(
      "GLOB_FILE_INFOS" /* GLOB_FILE_INFOS */,
      path2
    );
    return await this.postTask(task);
  }
  /** Register file text */
  async registerFileText(name2, text) {
    const buffer = TEXT_ENCODER3.encode(text);
    await this.registerFileBuffer(name2, buffer);
  }
  /** Register a file path. */
  async registerFileURL(name2, url2, proto, directIO) {
    if (url2 === void 0) {
      url2 = name2;
    }
    const task = new WorkerTask("REGISTER_FILE_URL" /* REGISTER_FILE_URL */, [name2, url2, proto, directIO]);
    await this.postTask(task);
  }
  /** Register an empty file buffer. */
  async registerEmptyFileBuffer(name2) {
    const task = new WorkerTask(
      "REGISTER_FILE_BUFFER" /* REGISTER_FILE_BUFFER */,
      [name2, new Uint8Array()]
    );
    await this.postTask(task);
  }
  /** Register a file buffer. */
  async registerFileBuffer(name2, buffer) {
    const task = new WorkerTask(
      "REGISTER_FILE_BUFFER" /* REGISTER_FILE_BUFFER */,
      [name2, buffer]
    );
    await this.postTask(task, [buffer.buffer]);
  }
  /** Register a file handle. */
  async registerFileHandle(name2, handle2, protocol, directIO) {
    const task = new WorkerTask("REGISTER_FILE_HANDLE" /* REGISTER_FILE_HANDLE */, [name2, handle2, protocol, directIO]);
    await this.postTask(task, []);
  }
  /** Enable file statistics */
  async collectFileStatistics(name2, enable) {
    const task = new WorkerTask(
      "COLLECT_FILE_STATISTICS" /* COLLECT_FILE_STATISTICS */,
      [name2, enable]
    );
    await this.postTask(task, []);
  }
  /** Export file statistics */
  async exportFileStatistics(name2) {
    const task = new WorkerTask(
      "EXPORT_FILE_STATISTICS" /* EXPORT_FILE_STATISTICS */,
      name2
    );
    return await this.postTask(task, []);
  }
  /** Copy a file to a buffer. */
  async copyFileToBuffer(name2) {
    const task = new WorkerTask(
      "COPY_FILE_TO_BUFFER" /* COPY_FILE_TO_BUFFER */,
      name2
    );
    return await this.postTask(task);
  }
  /** Copy a file to a path. */
  async copyFileToPath(name2, path2) {
    const task = new WorkerTask(
      "COPY_FILE_TO_PATH" /* COPY_FILE_TO_PATH */,
      [name2, path2]
    );
    await this.postTask(task);
  }
  /** Insert arrow from an ipc stream */
  async insertArrowFromIPCStream(conn, buffer, options) {
    if (buffer.length == 0)
      return;
    const task = new WorkerTask("INSERT_ARROW_FROM_IPC_STREAM" /* INSERT_ARROW_FROM_IPC_STREAM */, [conn, buffer, options]);
    await this.postTask(task, [buffer.buffer]);
  }
  /** Insert a csv file */
  async insertCSVFromPath(conn, path2, options) {
    if (options.columns !== void 0) {
      const out2 = [];
      for (const k in options.columns) {
        const type = options.columns[k];
        out2.push(arrowToSQLField(k, type));
      }
      options.columnsFlat = out2;
      delete options.columns;
    }
    const task = new WorkerTask(
      "IMPORT_CSV_FROM_PATH" /* INSERT_CSV_FROM_PATH */,
      [conn, path2, options]
    );
    await this.postTask(task);
  }
  /** Insert a json file */
  async insertJSONFromPath(conn, path2, options) {
    if (options.columns !== void 0) {
      const out2 = [];
      for (const k in options.columns) {
        const type = options.columns[k];
        out2.push(arrowToSQLField(k, type));
      }
      options.columnsFlat = out2;
      delete options.columns;
    }
    const task = new WorkerTask(
      "IMPORT_JSON_FROM_PATH" /* INSERT_JSON_FROM_PATH */,
      [conn, path2, options]
    );
    await this.postTask(task);
  }
};

// test/index_node.ts
var import_path = __toESM(require("path"));
var import_web_worker = __toESM(require("web-worker"));
var import_fs3 = __toESM(require("fs"));

// test/all_types.test.ts
var import_apache_arrow = require("apache-arrow");
var MINIMUM_DATE_STR = "-271821-04-20";
var MINIMUM_DATE = new Date(Date.UTC(-271821, 3, 20));
var MAXIMUM_DATE_STR = "275760-09-13";
var MAXIMUM_DATE = new Date(Date.UTC(275760, 8, 13));
var NOT_IMPLEMENTED_TYPES = [
  "timestamp_s",
  "timestamp_ms",
  "timestamp_ns",
  "time_tz",
  "timestamp_tz",
  "hugeint",
  "dec_18_6",
  "dec38_10",
  "uuid",
  "map",
  "json",
  "date_array",
  "timestamp_array",
  "timestamptz_array"
];
var PARTIALLY_IMPLEMENTED_TYPES = ["date", "timestamp"];
var PARTIALLY_IMPLEMENTED_ANSWER_MAP = {
  date: [MINIMUM_DATE.valueOf(), MAXIMUM_DATE.valueOf(), null],
  timestamp: [MINIMUM_DATE.valueOf(), MAXIMUM_DATE.valueOf(), null]
};
var PARTIALLY_IMPLEMENTED_TYPES_SUBSTITUTIONS = [
  `(SELECT array_extract(['${MINIMUM_DATE_STR}'::Date,'${MAXIMUM_DATE_STR}'::Date,null],i + 1)) as date`,
  `(SELECT array_extract(['${MINIMUM_DATE_STR}'::Timestamp,'${MAXIMUM_DATE_STR}'::Timestamp,null],i + 1)) as timestamp`
];
var TYPES_REQUIRING_CUSTOM_CONFIG = ["dec_4_1", "dec_9_4"];
var FULLY_IMPLEMENTED_ANSWER_MAP = {
  bool: [false, true, null],
  tinyint: [-128, 127, null],
  smallint: [-32768, 32767, null],
  int: [-2147483648, 2147483647, null],
  utinyint: [0, 255, null],
  usmallint: [0, 65535, null],
  uint: [0, 4294967295, null],
  ubigint: [BigInt(0), BigInt("18446744073709551615"), null],
  bigint: [BigInt("-9223372036854775808"), BigInt("9223372036854775807"), null],
  // Note that we multiply by thousand (and add 999 for the max) because the value returned by DuckDB is in microseconds,
  // whereas the Date object is in milliseconds.
  time: [BigInt(0), BigInt((/* @__PURE__ */ new Date("1970-01-01T23:59:59.999+00:00")).valueOf()) * BigInt(1e3) + BigInt(999), null],
  interval: [new Int32Array([0, 0]), new Int32Array([0, 0]), null],
  float: [-34028234663852886e22, 34028234663852886e22, null],
  double: [-17976931348623157e292, 17976931348623157e292, null],
  varchar: ["\u{1F986}\u{1F986}\u{1F986}\u{1F986}\u{1F986}\u{1F986}", "goo\0se", null],
  small_enum: ["DUCK_DUCK_ENUM", "GOOSE", null],
  medium_enum: ["enum_0", "enum_299", null],
  large_enum: ["enum_0", "enum_69999", null],
  int_array: [[], [42, 999, null, null, -42], null],
  double_array: [[], [42, NaN, Infinity, -Infinity, null, -42], null],
  varchar_array: [[], ["\u{1F986}\u{1F986}\u{1F986}\u{1F986}\u{1F986}\u{1F986}", "goose", null, ""], null],
  nested_int_array: [[], [[], [42, 999, null, null, -42], null, [], [42, 999, null, null, -42]], null],
  struct: ['{"a":null,"b":null}', '{"a":42,"b":"\u{1F986}\u{1F986}\u{1F986}\u{1F986}\u{1F986}\u{1F986}"}', null],
  struct_of_arrays: [
    '{"a":null,"b":null}',
    '{"a":[42,999,null,null,-42],"b":["\u{1F986}\u{1F986}\u{1F986}\u{1F986}\u{1F986}\u{1F986}","goose",null,""]}',
    null
  ],
  array_of_structs: [[], ['{"a":null,"b":null}', '{"a":42,"b":"\u{1F986}\u{1F986}\u{1F986}\u{1F986}\u{1F986}\u{1F986}"}', null], null],
  // XXX sometimes throws
  // map: ['{}', '{"key1":"🦆🦆🦆🦆🦆🦆","key2":"goose"}', null],
  blob: [
    Uint8Array.from([
      116,
      104,
      105,
      115,
      105,
      115,
      97,
      108,
      111,
      110,
      103,
      98,
      108,
      111,
      98,
      0,
      119,
      105,
      116,
      104,
      110,
      117,
      108,
      108,
      98,
      121,
      116,
      101,
      115
    ]),
    Uint8Array.from([0, 0, 0, 97]),
    null
  ],
  union: ["Frank", 5, null]
};
var REPLACE_COLUMNS = PARTIALLY_IMPLEMENTED_TYPES.concat(NOT_IMPLEMENTED_TYPES).concat(TYPES_REQUIRING_CUSTOM_CONFIG);
function unpack(v) {
  if (v === null)
    return null;
  if (v instanceof import_apache_arrow.Vector) {
    const ret = Array.from(v.toArray());
    for (let i2 = 0; i2 < ret.length; i2++) {
      if (!v.isValid(i2)) {
        ret[i2] = null;
      }
    }
    return unpack(ret);
  } else if (v instanceof Array) {
    const ret = [];
    for (let i2 = 0; i2 < v.length; i2++) {
      ret[i2] = unpack(v[i2]);
    }
    return ret;
  } else if (v instanceof Uint8Array) {
    return v;
  } else if (v.toJSON instanceof Function) {
    return JSON.stringify(v.toJSON());
  }
  return v;
}
function getValue2(x) {
  if (typeof (x == null ? void 0 : x.valueOf) === "function") {
    return x.valueOf();
  } else {
    return x;
  }
}
var ALL_TYPES_TEST = [
  {
    name: "fully supported types",
    query: `SELECT * REPLACE('not_implemented' as map) FROM test_all_types()`,
    skip: REPLACE_COLUMNS,
    answerMap: FULLY_IMPLEMENTED_ANSWER_MAP,
    answerCount: REPLACE_COLUMNS.length + Object.keys(FULLY_IMPLEMENTED_ANSWER_MAP).length,
    queryConfig: null
  },
  {
    name: "partially supported types",
    query: `SELECT ${PARTIALLY_IMPLEMENTED_TYPES_SUBSTITUTIONS.join(", ")}
                FROM range(0, 3) tbl(i)`,
    skip: [],
    answerMap: PARTIALLY_IMPLEMENTED_ANSWER_MAP,
    answerCount: PARTIALLY_IMPLEMENTED_TYPES.length,
    queryConfig: null
  },
  {
    name: "types with custom config",
    query: `SELECT ${TYPES_REQUIRING_CUSTOM_CONFIG.join(",")} FROM test_all_types()`,
    skip: [],
    answerMap: {
      dec_4_1: [-999.9000000000001, 999.9000000000001, null],
      dec_9_4: [-99999.99990000001, 99999.99990000001, null]
    },
    answerCount: TYPES_REQUIRING_CUSTOM_CONFIG.length,
    queryConfig: {
      castDecimalToDouble: true
    }
  }
];
function testAllTypes(db2) {
  let conn;
  beforeEach(() => {
    db2().flushFiles();
  });
  afterEach(() => {
    if (conn) {
      conn.close();
      conn = null;
    }
    db2().flushFiles();
    db2().dropFiles();
  });
  describe("Test All Types", () => {
    for (const test of ALL_TYPES_TEST) {
      it(test.name, () => {
        if (test.queryConfig)
          db2().open({ query: test.queryConfig });
        conn = db2().connect();
        const results = conn.query(test.query);
        expect(results.numCols).toEqual(test.answerCount);
        const skip = /* @__PURE__ */ new Map();
        for (const s2 of test.skip) {
          skip.set(s2, true);
        }
        for (let i2 = 0; i2 < results.numCols; i2++) {
          const name2 = results.schema.fields[i2].name;
          if (name2 == "bit")
            continue;
          const col = results.getChildAt(i2);
          if (skip.get(name2))
            continue;
          expect(col).not.toBeNull();
          expect(col == null ? void 0 : col.length).not.toEqual(0);
          expect(unpack(getValue2(col.get(0)))).withContext(name2).toEqual(test.answerMap[name2][0]);
          expect(unpack(getValue2(col.get(1)))).withContext(name2).toEqual(test.answerMap[name2][1]);
          expect(col.get(2)).withContext(name2).toEqual(test.answerMap[name2][2]);
        }
      });
    }
  });
}
function testAllTypesAsync(db2) {
  let conn = null;
  beforeEach(async () => {
    await db2().flushFiles();
  });
  afterEach(async () => {
    if (conn) {
      await conn.close();
      conn = null;
    }
    await db2().flushFiles();
    await db2().dropFiles();
  });
  describe("Test All Types Async", () => {
    for (const test of ALL_TYPES_TEST) {
      it(test.name, async () => {
        if (test.queryConfig)
          db2().open({ query: test.queryConfig });
        conn = await db2().connect();
        const results = await conn.query(test.query);
        expect(results.numCols).toEqual(test.answerCount);
        const skip = /* @__PURE__ */ new Map();
        for (const s2 of test.skip) {
          skip.set(s2, true);
        }
        for (let i2 = 0; i2 < results.numCols; i2++) {
          const name2 = results.schema.fields[i2].name;
          if (name2 == "bit")
            continue;
          const col = results.getChildAt(i2);
          if (skip.get(name2))
            continue;
          expect(col).not.toBeNull();
          expect(col == null ? void 0 : col.length).not.toEqual(0);
          expect(Object.keys(test.answerMap)).toContain(name2);
          expect(unpack(getValue2(col.get(0)))).withContext(name2 + "|" + (col == null ? void 0 : col.toString()) + "|[0]").toEqual(test.answerMap[name2][0]);
          expect(unpack(getValue2(col.get(1)))).withContext(name2 + "|" + (col == null ? void 0 : col.toString()) + "|[1]").toEqual(test.answerMap[name2][1]);
          expect(col.get(2)).withContext(name2 + "|" + (col == null ? void 0 : col.toString()) + "|[2]").toEqual(test.answerMap[name2][2]);
        }
      });
    }
  });
}

// test/bindings.test.ts
var arrow4 = __toESM(require("apache-arrow"));
function testBindings(db2, baseURL) {
  let conn;
  beforeEach(() => {
    conn = db2().connect();
  });
  afterEach(() => {
    conn.close();
    db2().flushFiles();
    db2().dropFiles();
  });
  describe("DuckDBBindings", () => {
    describe("error handling", () => {
      it("INVALID SQL", async () => {
        let error = null;
        try {
          await conn.send("INVALID");
        } catch (e) {
          error = e;
        }
        expect(error).not.toBe(null);
      });
    });
    describe("Check version", () => {
      it("Version check", async () => {
        await db2().reset();
        conn = db2().connect();
        const version = conn.query(
          "select * from (select version()) where version() != 'v0.0.1-dev0';"
        );
        const rows = version.toArray();
        expect(rows.length).toEqual(1);
        await db2().reset();
      });
    });
    describe("Check platform", () => {
      it("Platform check", async () => {
        var _a;
        await db2().reset();
        conn = db2().connect();
        const version = conn.query(
          "PRAGMA platform;"
        );
        const rows = (_a = version.getChildAt(0)) == null ? void 0 : _a.toArray();
        expect(rows.length).toEqual(1);
        expect(rows[0].toString().substr(0, 5)).toEqual("wasm_");
        await db2().reset();
      });
    });
    describe("Reset", () => {
      it("table must disappear", async () => {
        var _a;
        await db2().reset();
        conn = db2().connect();
        conn.query("CREATE TABLE foo (a int)");
        let table = conn.query("PRAGMA show_tables;");
        let rows = table.toArray();
        expect(rows.length).toEqual(1);
        expect((_a = rows[0]) == null ? void 0 : _a.name).toEqual("foo");
        await db2().reset();
        conn = db2().connect();
        table = conn.query("PRAGMA show_tables;");
        rows = table.toArray();
        expect(rows.length).toEqual(0);
      });
    });
    describe("Prepared Statement", () => {
      it("Materialized", async () => {
        const stmt = conn.prepare("SELECT v::INTEGER + ? AS v FROM generate_series(0, 10000) as t(v);");
        const result = stmt.query(234);
        expect(result.numRows).toBe(10001);
        stmt.close();
      });
      it("Streaming", async () => {
        const stmt = conn.prepare("SELECT v::INTEGER + ? AS v FROM generate_series(0, 10000) as t(v);");
        const stream = stmt.send(234);
        let size = 0;
        for (const batch of stream) {
          size += batch.numRows;
        }
        expect(size).toBe(10001);
        conn.close();
      });
      it("Typecheck", async () => {
        conn.query(`CREATE TABLE typecheck (
                    a BOOLEAN DEFAULT NULL,
                    b TINYINT DEFAULT NULL,
                    c SMALLINT DEFAULT NULL,
                    d INTEGER DEFAULT NULL,
                    e BIGINT DEFAULT NULL,
                    f FLOAT DEFAULT NULL,
                    g DOUBLE DEFAULT NULL,
                    h CHAR(11) DEFAULT NULL,
                    i VARCHAR(11) DEFAULT NULL
                )`);
        const stmt = conn.prepare("INSERT INTO typecheck VALUES(?,?,?,?,?,?,?,?,?)");
        expect(
          () => stmt.query(true, 100, 1e4, 1e6, 5e9, 0.5, Math.PI, "hello world", "hi")
        ).not.toThrow();
        expect(
          () => stmt.query(
            "test",
            // varchar for bool
            100,
            1e4,
            1e6,
            5e9,
            0.5,
            Math.PI,
            "hello world",
            "hi"
          )
        ).toThrow();
        expect(
          () => stmt.query(
            true,
            1e4,
            // smallint for tinyint
            1e4,
            1e6,
            5e9,
            0.5,
            Math.PI,
            "hello world",
            "hi"
          )
        ).toThrow();
        expect(
          () => stmt.query(
            true,
            100,
            1e6,
            // int for smallint
            1e6,
            5e9,
            0.5,
            Math.PI,
            "hello world",
            "hi"
          )
        ).toThrow();
        expect(
          () => stmt.query(
            true,
            100,
            1e4,
            5e9,
            // bigint for int
            5e9,
            0.5,
            Math.PI,
            "hello world",
            "hi"
          )
        ).toThrow();
        conn.close();
      });
    });
  });
}
function testAsyncBindings(adb2, baseURL, baseDirProto) {
  beforeEach(async () => {
  });
  afterEach(async () => {
    await adb2().flushFiles();
    await adb2().dropFiles();
    await adb2().open({
      path: ":memory:"
    });
  });
  describe("Bindings", () => {
    describe("Open", () => {
      it("Remote TPCH 0_01", async () => {
        await adb2().registerFileURL("tpch_0_01.db", `${baseURL}/tpch/0_01/duckdb/db`, baseDirProto, false);
        await adb2().open({
          path: "tpch_0_01.db"
        });
      });
    });
    describe("Patching", () => {
      it("Count(*) Default", async () => {
        await adb2().open({
          path: ":memory:",
          query: {
            castBigIntToDouble: false
          }
        });
        const conn = await adb2().connect();
        const table = await conn.query("select 1::BIGINT");
        expect(table.schema.fields.length).toEqual(1);
        expect(table.schema.fields[0].typeId).toEqual(arrow4.Type.Int);
      });
      it("Count(*) No BigInt", async () => {
        await adb2().open({
          path: ":memory:",
          query: {
            castBigIntToDouble: true
          }
        });
        const conn = await adb2().connect();
        const table = await conn.query("select 1::BIGINT");
        expect(table.schema.fields.length).toEqual(1);
        expect(table.schema.fields[0].typeId).toEqual(arrow4.Type.Float);
      });
    });
    describe("Prepared Statement", () => {
      it("Materialized", async () => {
        const conn = await adb2().connect();
        const stmt = await conn.prepare("SELECT v + ? FROM generate_series(0, 10000) as t(v);");
        const result = await stmt.query(234);
        expect(result.numRows).toBe(10001);
        await stmt.close();
      });
      it("Streaming", async () => {
        const conn = await adb2().connect();
        const stmt = await conn.prepare("SELECT v::INTEGER + ? AS v FROM generate_series(0, 10000) as t(v);");
        const stream = await stmt.send(234);
        let size = 0;
        for await (const batch of stream) {
          size += batch.numRows;
        }
        expect(size).toBe(10001);
        await conn.close();
      });
      it("Typecheck", async () => {
        const conn = await adb2().connect();
        await conn.query(`CREATE TABLE typecheck (
                    a BOOLEAN DEFAULT NULL,
                    b TINYINT DEFAULT NULL,
                    c SMALLINT DEFAULT NULL,
                    d INTEGER DEFAULT NULL,
                    e BIGINT DEFAULT NULL,
                    f FLOAT DEFAULT NULL,
                    g DOUBLE DEFAULT NULL,
                    h CHAR(11) DEFAULT NULL,
                    i VARCHAR(11) DEFAULT NULL
                )`);
        const stmt = await conn.prepare("INSERT INTO typecheck VALUES(?,?,?,?,?,?,?,?,?)");
        const expectToThrow = async (fn) => {
          let throwed = false;
          try {
            await fn();
          } catch (e) {
            throwed = true;
          }
          expect(throwed).toBe(true);
        };
        expectToThrow(async () => {
          await stmt.query(
            "test",
            // varchar for bool
            100,
            1e4,
            1e6,
            5e9,
            0.5,
            Math.PI,
            "hello world",
            "hi"
          );
        });
        expectToThrow(async () => {
          await stmt.query(
            true,
            1e4,
            // smallint for tinyint
            1e4,
            1e6,
            5e9,
            0.5,
            Math.PI,
            "hello world",
            "hi"
          );
        });
        expectToThrow(async () => {
          await stmt.query(
            true,
            100,
            1e6,
            // int for smallint
            1e6,
            5e9,
            0.5,
            Math.PI,
            "hello world",
            "hi"
          );
        });
        expectToThrow(async () => {
          await stmt.query(
            true,
            100,
            1e4,
            5e9,
            // bigint for int
            5e9,
            0.5,
            Math.PI,
            "hello world",
            "hi"
          );
        });
        await conn.close();
      });
    });
    describe("AccessMode", () => {
      it("READ_ONLY", async () => {
        await expectAsync(
          adb2().open({
            accessMode: 2 /* READ_ONLY */
          })
        ).toBeRejectedWithError(/Cannot launch in-memory database in read-only mode/);
      });
      it("READ_WRITE", async () => {
        await expectAsync(
          adb2().open({
            accessMode: 3 /* READ_WRITE */
          })
        ).toBeResolved();
      });
    });
    describe("Cancellation", () => {
      it("hello cancel", async () => {
        await adb2().open({
          path: ":memory:",
          query: {
            queryPollingInterval: 0
          }
        });
        const conn = await adb2().connect();
        const result = await conn.useUnsafe(
          (db2, id) => db2.startPendingQuery(id, "SELECT SUM(i) FROM range(1000000) tbl(i);")
        );
        expect(result).toBeNull();
        const cancelOK = await conn.useUnsafe((db2, id) => db2.cancelPendingQuery(id));
        expect(cancelOK).toBeTrue();
        let polledHeader = null;
        let polledError = null;
        try {
          polledHeader = await conn.useUnsafe((db2, id) => db2.pollPendingQuery(id));
        } catch (e) {
          polledError = e;
        }
        expect(polledHeader).toBeNull();
        expect(polledError).not.toBeNull();
        expect(polledError.toString()).toEqual("Error: query was canceled");
        const canceledAgain = await conn.useUnsafe((db2, id) => db2.cancelPendingQuery(id));
        expect(canceledAgain).toBeFalse();
        const table = await conn.query("select 42::integer;");
        expect(table.schema.fields.length).toEqual(1);
      });
      it("noop cancel", async () => {
        await adb2().open({
          path: ":memory:",
          query: {
            queryPollingInterval: 0
          }
        });
        const conn = await adb2().connect();
        const result = await conn.useUnsafe(
          (db2, id) => db2.startPendingQuery(id, "SELECT SUM(i) FROM range(1000000) tbl(i);")
        );
        expect(result).toBeNull();
        let polledHeader = null;
        let polledError = null;
        try {
          while (polledHeader == null) {
            polledHeader = await conn.useUnsafe((db2, id) => db2.pollPendingQuery(id));
          }
        } catch (e) {
          polledError = e;
        }
        expect(polledHeader).not.toBeNull();
        expect(polledError).toBeNull();
        const cancelOK = await conn.useUnsafe((db2, id) => db2.cancelPendingQuery(id));
        expect(cancelOK).toBeFalse();
        const anotherOne = await conn.useUnsafe((db2, id) => db2.cancelPendingQuery(id));
        expect(anotherOne).toBeFalse();
      });
    });
  });
}

// test/batch_stream.test.ts
var testRows = 1e4;
function testBatchStream(db2) {
  let conn;
  beforeEach(() => {
    conn = db2().connect();
  });
  afterEach(() => {
    conn.close();
    db2().flushFiles();
    db2().dropFiles();
  });
  describe("Arrow Record-Batches Row-Major", () => {
    describe("single column", () => {
      it("TINYINT", async () => {
        const result = await conn.send(`
                    SELECT (v & 127)::TINYINT AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
        let i2 = 0;
        for (const batch of result) {
          expect(batch.numCols).toBe(1);
          for (const row of batch) {
            expect(row.v).toBe(i2++ & 127);
          }
        }
        expect(i2).toBe(testRows + 1);
      });
      it("SMALLINT", async () => {
        const result = await conn.send(`
                    SELECT (v & 32767)::SMALLINT AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
        let i2 = 0;
        for (const batch of result) {
          expect(batch.numCols).toBe(1);
          for (const row of batch) {
            expect(row.v).toBe(i2++ & 32767);
          }
        }
        expect(i2).toBe(testRows + 1);
      });
      it("INTEGER", async () => {
        const result = await conn.send(`
                    SELECT v::INTEGER AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
        let i2 = 0;
        for (const batch of result) {
          expect(batch.numCols).toBe(1);
          for (const row of batch) {
            expect(row.v).toBe(i2++);
          }
        }
        expect(i2).toBe(testRows + 1);
      });
      it("BIGINT", async () => {
        const result = await conn.send(`
                    SELECT v::BIGINT AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
        let i2 = 0;
        for (const batch of result) {
          expect(batch.numCols).toBe(1);
          for (const row of batch) {
            expect(row.v).toBe(BigInt(i2++));
          }
        }
        expect(i2).toBe(testRows + 1);
      });
      it("STRING", async () => {
        const result = await conn.send(`
                    SELECT v::VARCHAR AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
        let i2 = 0;
        for (const batch of result) {
          expect(batch.numCols).toBe(1);
          for (const row of batch) {
            expect(row.v).toBe(String(i2++));
          }
        }
        expect(i2).toBe(testRows + 1);
      });
    });
  });
  describe("Arrow Record-Batches Column-Major", () => {
    describe("single column", () => {
      it("TINYINT", async () => {
        const result = await conn.send(`
                    SELECT (v & 127)::TINYINT AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
        let i2 = 0;
        for (const batch of result) {
          expect(batch.numCols).toBe(1);
          for (const v of batch.getChildAt(0)) {
            expect(v).toBe(i2++ & 127);
          }
        }
        expect(i2).toBe(testRows + 1);
      });
      it("SMALLINT", async () => {
        const result = await conn.send(`
                    SELECT (v & 32767)::SMALLINT AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
        let i2 = 0;
        for (const batch of result) {
          expect(batch.numCols).toBe(1);
          for (const v of batch.getChildAt(0)) {
            expect(v).toBe(i2++ & 32767);
          }
        }
        expect(i2).toBe(testRows + 1);
      });
      it("INTEGER", async () => {
        const result = await conn.send(`
                    SELECT v::INTEGER AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
        let i2 = 0;
        for (const batch of result) {
          expect(batch.numCols).toBe(1);
          for (const v of batch.getChildAt(0)) {
            expect(v).toBe(i2++);
          }
        }
        expect(i2).toBe(testRows + 1);
      });
      it("BIGINT", async () => {
        const result = await conn.send(`
                    SELECT v::BIGINT AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
        let i2 = 0;
        for (const batch of result) {
          expect(batch.numCols).toBe(1);
          for (const v of batch.getChildAt(0)) {
            expect(v).toBe(BigInt(i2++));
          }
        }
        expect(i2).toBe(testRows + 1);
      });
      it("STRING", async () => {
        const result = await conn.send(`
                    SELECT v::VARCHAR AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
        let i2 = 0;
        for (const batch of result) {
          expect(batch.numCols).toBe(1);
          for (const v of batch.getChildAt(0)) {
            expect(v).toBe(String(i2++));
          }
        }
        expect(i2).toBe(testRows + 1);
      });
    });
  });
  describe("Arrow Table Row-Major", () => {
    describe("single column", () => {
      it("TINYINT", () => {
        const table = conn.query(`
                    SELECT (v & 127)::TINYINT AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
        let i2 = 0;
        for (const row of table) {
          expect(row == null ? void 0 : row.v).toBe(i2++ & 127);
        }
        expect(i2).toBe(testRows + 1);
      });
      it("SMALLINT", () => {
        const table = conn.query(`
                    SELECT (v & 32767)::SMALLINT AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
        let i2 = 0;
        for (const row of table) {
          expect(row == null ? void 0 : row.v).toBe(i2++ & 32767);
        }
        expect(i2).toBe(testRows + 1);
      });
      it("INTEGER", () => {
        const table = conn.query(`
                    SELECT v::INTEGER AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
        let i2 = 0;
        for (const row of table) {
          expect(row == null ? void 0 : row.v).toBe(i2++);
        }
        expect(i2).toBe(testRows + 1);
      });
      it("BIGINT", () => {
        const table = conn.query(`
                    SELECT v::BIGINT AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
        let i2 = 0;
        for (const row of table) {
          expect(row == null ? void 0 : row.v).toBe(BigInt(i2++));
        }
        expect(i2).toBe(testRows + 1);
      });
      it("STRING", () => {
        const table = conn.query(`
                    SELECT v::VARCHAR AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
        let i2 = 0;
        for (const row of table) {
          expect(row == null ? void 0 : row.v.valueOf()).toBe(String(i2++));
        }
        expect(i2).toBe(testRows + 1);
      });
    });
  });
  describe("Arrow Table Column-Major", () => {
    describe("single column", () => {
      it("TINYINT", () => {
        const table = conn.query(`
                    SELECT (v & 127)::TINYINT AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
        let i2 = 0;
        for (const v of table.getChildAt(0)) {
          expect(v).toBe(i2++ & 127);
        }
        expect(i2).toBe(testRows + 1);
      });
      it("SMALLINT", () => {
        const table = conn.query(`
                    SELECT (v & 32767)::SMALLINT AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
        let i2 = 0;
        for (const v of table.getChildAt(0)) {
          expect(v).toBe(i2++ & 32767);
        }
        expect(i2).toBe(testRows + 1);
      });
      it("INTEGER", () => {
        const table = conn.query(`
                    SELECT v::INTEGER AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
        let i2 = 0;
        for (const v of table.getChildAt(0)) {
          expect(v).toBe(i2++);
        }
        expect(i2).toBe(testRows + 1);
      });
      it("BIGINT", () => {
        const table = conn.query(`
                    SELECT v::BIGINT AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
        let i2 = 0;
        for (const v of table.getChildAt(0)) {
          expect(v).toBe(BigInt(i2++));
        }
        expect(i2).toBe(testRows + 1);
      });
      it("STRING", () => {
        const table = conn.query(`
                    SELECT v::VARCHAR AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
        let i2 = 0;
        for (const v of table.getChildAt(0)) {
          expect(v).toBe(String(i2++));
        }
        expect(i2).toBe(testRows + 1);
      });
    });
  });
}

// test/filesystem.test.ts
var arrow5 = __toESM(require("apache-arrow"));
var decoder = new TextDecoder();
function testFilesystem(db2, resolveData2, baseDir, baseDirProto) {
  let conn;
  beforeEach(async () => {
    conn = await db2().connect();
  });
  afterEach(async () => {
    await conn.close();
    await db2().flushFiles();
    await db2().dropFiles();
  });
  describe("File buffer registration", () => {
    const test = async () => {
      var _a;
      const result = await conn.send(`SELECT matrnr FROM parquet_scan('studenten.parquet');`);
      const batches = [];
      for await (const batch of result) {
        batches.push(batch);
      }
      const table = await new arrow5.Table(batches);
      expect((_a = table.getChildAt(0)) == null ? void 0 : _a.toArray()).toEqual(
        new Int32Array([24002, 25403, 26120, 26830, 27550, 28106, 29120, 29555])
      );
    };
    it("File buffer used once", async () => {
      const students = await resolveData2("/uni/studenten.parquet");
      expect(students).not.toBeNull();
      await db2().registerFileBuffer("studenten.parquet", students);
      await test();
    });
    it("File buffer registered twice", async () => {
      const students0 = await resolveData2("/uni/studenten.parquet");
      const students1 = await resolveData2("/uni/studenten.parquet");
      expect(students0).not.toBeNull();
      expect(students1).not.toBeNull();
      await db2().registerFileBuffer("studenten.parquet", students0);
      await test();
      await db2().registerFileBuffer("studenten.parquet", students1);
      await test();
    });
    it("File buffer used twice", async () => {
      const students = await resolveData2("/uni/studenten.parquet");
      expect(students).not.toBeNull();
      await db2().registerFileBuffer("studenten.parquet", students);
      await test();
      await test();
    });
  });
  describe("Parquet Scans", () => {
    it("single table from buffer", async () => {
      var _a;
      const students = await resolveData2("/uni/studenten.parquet");
      expect(students).not.toBeNull();
      await db2().registerFileBuffer("studenten.parquet", students);
      const result = await conn.send(`SELECT matrnr FROM parquet_scan('studenten.parquet');`);
      const batches = [];
      for await (const batch of result) {
        batches.push(batch);
      }
      const table = await new arrow5.Table(batches);
      expect((_a = table.getChildAt(0)) == null ? void 0 : _a.toArray()).toEqual(
        new Int32Array([24002, 25403, 26120, 26830, 27550, 28106, 29120, 29555])
      );
    });
    it("simple join", async () => {
      var _a;
      const students = await resolveData2("/uni/studenten.parquet");
      const hoeren = await resolveData2("/uni/hoeren.parquet");
      const vorlesungen = await resolveData2("/uni/vorlesungen.parquet");
      expect(students).not.toBeNull();
      expect(hoeren).not.toBeNull();
      expect(vorlesungen).not.toBeNull();
      await db2().registerFileBuffer("studenten.parquet", students);
      await db2().registerFileBuffer("hoeren.parquet", hoeren);
      await db2().registerFileBuffer("vorlesungen.parquet", vorlesungen);
      const result = await conn.send(`
                    SELECT students.matrnr, vorlesungen.titel
                    FROM parquet_scan('studenten.parquet') students
                    INNER JOIN parquet_scan('hoeren.parquet') hoeren ON (students.matrnr = hoeren.matrnr)
                    INNER JOIN parquet_scan('vorlesungen.parquet') vorlesungen ON (vorlesungen.vorlnr = hoeren.vorlnr);
                `);
      const batches = [];
      for await (const batch of result) {
        batches.push(batch);
      }
      const table = await new arrow5.Table(batches);
      expect(table.numCols).toBe(2);
      const flat = [];
      for (const row of table) {
        flat.push({
          matrnr: row == null ? void 0 : row.matrnr,
          titel: (_a = row == null ? void 0 : row.titel) == null ? void 0 : _a.toString()
        });
      }
      expect(flat).toEqual([
        { matrnr: 26120, titel: "Grundz\xFCge" },
        { matrnr: 27550, titel: "Grundz\xFCge" },
        { matrnr: 27550, titel: "Logik" },
        { matrnr: 28106, titel: "Ethik" },
        { matrnr: 28106, titel: "Wissenschaftstheorie" },
        { matrnr: 28106, titel: "Bioethik" },
        { matrnr: 28106, titel: "Der Wiener Kreis" },
        { matrnr: 29120, titel: "Grundz\xFCge" },
        { matrnr: 29120, titel: "Ethik" },
        { matrnr: 29120, titel: "M\xE4eutik" },
        { matrnr: 29555, titel: "Glaube und Wissen" },
        { matrnr: 25403, titel: "Glaube und Wissen" }
      ]);
    });
  });
  describe("Writing", () => {
    it("Copy To CSV Buffer", async () => {
      const students = await resolveData2("/uni/studenten.parquet");
      expect(students).not.toBeNull();
      await db2().registerFileBuffer("studenten.parquet", students);
      await db2().registerEmptyFileBuffer("students.csv");
      await conn.query(`CREATE TABLE students AS SELECT * FROM parquet_scan('studenten.parquet');`);
      await conn.query(`COPY students TO 'students.csv' WITH (HEADER 1, DELIMITER ';', FORMAT CSV);`);
      await conn.query(`DROP TABLE IF EXISTS students`);
      const outBuffer = await db2().copyFileToBuffer("students.csv");
      expect(outBuffer).not.toBeNull();
      const text = decoder.decode(outBuffer);
      expect(text).toBe(`matrnr;name;semester
24002;Xenokrates;18
25403;Jonas;12
26120;Fichte;10
26830;Aristoxenos;8
27550;Schopenhauer;6
28106;Carnap;3
29120;Theophrastos;2
29555;Feuerbach;2
`);
    });
    it("Copy To Parquet", async () => {
      const students = await resolveData2("/uni/studenten.parquet");
      expect(students).not.toBeNull();
      await db2().registerFileBuffer("studenten.parquet", students);
      await db2().registerEmptyFileBuffer("students2.parquet");
      await conn.query(`CREATE TABLE students2 AS SELECT * FROM parquet_scan('studenten.parquet');`);
      await conn.query(`COPY students2 TO 'students2.parquet' (FORMAT PARQUET);`);
      const url2 = await db2().copyFileToBuffer("students2.parquet");
      expect(url2).not.toBeNull();
    });
    it("Copy To Parquet And Load Again", async () => {
      var _a;
      const students = await resolveData2("/uni/studenten.parquet");
      expect(students).not.toBeNull();
      await db2().registerFileBuffer("studenten.parquet", students);
      await db2().registerEmptyFileBuffer("students3.parquet");
      await conn.query(`CREATE TABLE students3 AS SELECT * FROM parquet_scan('studenten.parquet');`);
      await conn.query(`COPY students3 TO 'students3.parquet' (FORMAT PARQUET);`);
      const url2 = await db2().copyFileToBuffer("students3.parquet");
      expect(url2).not.toBeNull();
      await conn.query(`CREATE TABLE students4 AS SELECT * FROM parquet_scan('students3.parquet');`);
      const result = await conn.send(`SELECT matrnr FROM students4;`);
      const batches = [];
      for await (const batch of result) {
        batches.push(batch);
      }
      const table = await new arrow5.Table(batches);
      expect((_a = table.getChildAt(0)) == null ? void 0 : _a.toArray()).toEqual(
        new Int32Array([24002, 25403, 26120, 26830, 27550, 28106, 29120, 29555])
      );
    });
  });
  describe("File access", () => {
    it("Small Parquet file", async () => {
      var _a;
      await db2().registerFileURL("studenten.parquet", `${baseDir}/uni/studenten.parquet`, baseDirProto, true);
      const result = await conn.send(`SELECT matrnr FROM parquet_scan('studenten.parquet');`);
      const batches = [];
      for await (const batch of result) {
        batches.push(batch);
      }
      const table = await new arrow5.Table(batches);
      expect((_a = table.getChildAt(0)) == null ? void 0 : _a.toArray()).toEqual(
        new Int32Array([24002, 25403, 26120, 26830, 27550, 28106, 29120, 29555])
      );
    });
    it("Large Parquet file", async () => {
      var _a;
      await db2().registerFileURL(
        "lineitem.parquet",
        `${baseDir}/tpch/0_01/parquet/lineitem.parquet`,
        baseDirProto,
        true
      );
      const result = await conn.send(`SELECT count(*)::INTEGER as cnt FROM parquet_scan('lineitem.parquet');`);
      const batches = [];
      for await (const batch of result) {
        batches.push(batch);
      }
      const table = await new arrow5.Table(batches);
      expect((_a = table.getChildAt(0)) == null ? void 0 : _a.get(0)).toBeGreaterThan(6e4);
    });
  });
  describe("Export", () => {
    it("Generate Series as CSV", async () => {
      await conn.query("CREATE TABLE foo AS SELECT * FROM generate_series(1, 5) t(v)");
      await conn.query(`EXPORT DATABASE '/tmp/duckdbexportcsv'`);
      const results = await db2().globFiles("/tmp/duckdbexportcsv/*");
      expect(results).not.toEqual([]);
      expect(results.length).toEqual(3);
      const filenames = results.map((file) => file.fileName).sort();
      expect(filenames).toEqual([
        "/tmp/duckdbexportcsv/foo.csv",
        "/tmp/duckdbexportcsv/load.sql",
        "/tmp/duckdbexportcsv/schema.sql"
      ]);
      const csv_buffer_utf8 = await db2().copyFileToBuffer("/tmp/duckdbexportcsv/foo.csv");
      const load_script_utf8 = await db2().copyFileToBuffer("/tmp/duckdbexportcsv/load.sql");
      const schema_script_utf8 = await db2().copyFileToBuffer("/tmp/duckdbexportcsv/schema.sql");
      expect(load_script_utf8.length).not.toEqual(0);
      expect(schema_script_utf8.length).not.toEqual(0);
      expect(csv_buffer_utf8.length).not.toEqual(0);
    });
    it("Generate Series as Parquet", async () => {
      var _a;
      await conn.query("CREATE TABLE foo AS SELECT * FROM generate_series(1, 5) t(v)");
      await conn.query(`EXPORT DATABASE '/tmp/duckdbexportparquet' (FORMAT PARQUET)`);
      const results = await db2().globFiles("/tmp/duckdbexportparquet/*");
      expect(results).not.toEqual([]);
      expect(results.length).toEqual(3);
      const filenames = results.map((file) => file.fileName).sort();
      expect(filenames).toEqual([
        "/tmp/duckdbexportparquet/foo.parquet",
        "/tmp/duckdbexportparquet/load.sql",
        "/tmp/duckdbexportparquet/schema.sql"
      ]);
      const parquet_buffer = await db2().copyFileToBuffer("/tmp/duckdbexportparquet/foo.parquet");
      const load_script_utf8 = await db2().copyFileToBuffer("/tmp/duckdbexportparquet/load.sql");
      const schema_script_utf8 = await db2().copyFileToBuffer("/tmp/duckdbexportparquet/schema.sql");
      expect(load_script_utf8.length).not.toEqual(0);
      expect(schema_script_utf8.length).not.toEqual(0);
      expect(parquet_buffer.length).not.toEqual(0);
      const content = await conn.query(
        `SELECT v::integer FROM parquet_scan('/tmp/duckdbexportparquet/foo.parquet')`
      );
      expect(content.nullCount).toEqual(0);
      expect(content.numRows).toEqual(5);
      expect((_a = content.getChildAt(0)) == null ? void 0 : _a.toArray()).toEqual(new Int32Array([1, 2, 3, 4, 5]));
    });
  });
  describe("Copy", () => {
    it("Generate Series as Parquet", async () => {
      var _a;
      await conn.query(
        `COPY (SELECT * FROM generate_series(1, 5) t(v)) TO '/tmp/duckdbcopytest.parquet' (FORMAT 'parquet')`
      );
      const results = await db2().globFiles("/tmp/duckdbcopytest*");
      expect(results).not.toEqual([]);
      expect(results.length).toEqual(1);
      const filenames = results.map((file) => file.fileName).sort();
      expect(filenames).toEqual(["/tmp/duckdbcopytest.parquet"]);
      const parquet_buffer = await db2().copyFileToBuffer("/tmp/duckdbcopytest.parquet");
      expect(parquet_buffer.length).not.toEqual(0);
      const content = await conn.query(`SELECT v::integer FROM parquet_scan('/tmp/duckdbcopytest.parquet')`);
      expect(content.numRows).toEqual(5);
      expect((_a = content.getChildAt(0)) == null ? void 0 : _a.toArray()).toEqual(new Int32Array([1, 2, 3, 4, 5]));
    });
  });
}

// test/batch_stream_async.test.ts
var testRows2 = 1e4;
function testAsyncBatchStream(db2) {
  let conn;
  beforeEach(async () => {
    conn = await db2().connect();
  });
  afterEach(async () => {
    await conn.close();
    await db2().flushFiles();
    await db2().dropFiles();
  });
  describe("AsyncDuckDB", () => {
    it("ping", async () => {
      await db2().ping();
    });
  });
  describe("Arrow Record-Batches Row-Major", () => {
    describe("single column", () => {
      it("TINYINT", async () => {
        const result = await conn.send(`
                    SELECT (v & 127)::TINYINT AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
        let i2 = 0;
        for await (const batch of result) {
          expect(batch.numCols).toBe(1);
          for (const row of batch) {
            expect(row.v).toBe(i2++ & 127);
          }
        }
        expect(i2).toBe(testRows2 + 1);
      });
      it("SMALLINT", async () => {
        const result = await conn.send(`
                    SELECT (v & 32767)::SMALLINT AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
        let i2 = 0;
        for await (const batch of result) {
          expect(batch.numCols).toBe(1);
          for (const v of batch.getChildAt(0)) {
            expect(v).toBe(i2++ & 32767);
          }
        }
        expect(i2).toBe(testRows2 + 1);
      });
      it("INTEGER", async () => {
        const result = await conn.send(`
                    SELECT v::INTEGER AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
        let i2 = 0;
        for await (const batch of result) {
          expect(batch.numCols).toBe(1);
          for (const v of batch.getChildAt(0)) {
            expect(v).toBe(i2++);
          }
        }
        expect(i2).toBe(testRows2 + 1);
      });
      it("BIGINT", async () => {
        const result = await conn.send(`
                    SELECT v::BIGINT AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
        let i2 = 0;
        for await (const batch of result) {
          expect(batch.numCols).toBe(1);
          for (const v of batch.getChildAt(0)) {
            expect(v).toBe(BigInt(i2++));
          }
        }
        expect(i2).toBe(testRows2 + 1);
      });
      it("STRING", async () => {
        const result = await conn.send(`
                    SELECT v::VARCHAR AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
        let i2 = 0;
        for await (const batch of result) {
          expect(batch.numCols).toBe(1);
          for (const v of batch.getChildAt(0)) {
            expect(v).toBe(String(i2++));
          }
        }
        expect(i2).toBe(testRows2 + 1);
      });
    });
    describe("scripts", () => {
      it("test1", async () => {
        const result = await conn.send(`
                    SELECT v::INTEGER AS x, (sin(v) * 100 + 100)::INTEGER AS y FROM generate_series(0, ${testRows2}) as t(v)
                `);
        let i2 = 0;
        for await (const batch of result) {
          expect(batch.numCols).toBe(2);
          for (const row of batch) {
            expect(row.x).toBe(i2++);
          }
        }
        expect(i2).toBe(testRows2 + 1);
      });
    });
  });
  describe("Arrow Record-Batches Column-Major", () => {
    describe("single column", () => {
      it("TINYINT", async () => {
        const result = await conn.send(`
                    SELECT (v & 127)::TINYINT AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
        let i2 = 0;
        for await (const batch of result) {
          expect(batch.numCols).toBe(1);
          for (const v of batch.getChildAt(0)) {
            expect(v).toBe(i2++ & 127);
          }
        }
        expect(i2).toBe(testRows2 + 1);
      });
      it("SMALLINT", async () => {
        const result = await conn.send(`
                    SELECT (v & 32767)::SMALLINT AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
        let i2 = 0;
        for await (const batch of result) {
          expect(batch.numCols).toBe(1);
          for (const v of batch.getChildAt(0)) {
            expect(v).toBe(i2++ & 32767);
          }
        }
        expect(i2).toBe(testRows2 + 1);
      });
      it("INTEGER", async () => {
        const result = await conn.send(`
                    SELECT v::INTEGER AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
        let i2 = 0;
        for await (const batch of result) {
          expect(batch.numCols).toBe(1);
          for (const v of batch.getChildAt(0)) {
            expect(v).toBe(i2++);
          }
        }
        expect(i2).toBe(testRows2 + 1);
      });
      it("BIGINT", async () => {
        const result = await conn.send(`
                    SELECT v::BIGINT AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
        let i2 = 0;
        for await (const batch of result) {
          expect(batch.numCols).toBe(1);
          for (const v of batch.getChildAt(0)) {
            expect(v).toBe(BigInt(i2++));
          }
        }
        expect(i2).toBe(testRows2 + 1);
      });
      it("STRING", async () => {
        const result = await conn.send(`
                    SELECT v::VARCHAR AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
        let i2 = 0;
        for await (const batch of result) {
          expect(batch.numCols).toBe(1);
          for (const v of batch.getChildAt(0)) {
            expect(v).toBe(String(i2++));
          }
        }
        expect(i2).toBe(testRows2 + 1);
      });
    });
  });
  describe("Arrow Table Row-Major", () => {
    describe("single column", () => {
      it("TINYINT", async () => {
        const table = await conn.query(`
                    SELECT (v & 127)::TINYINT AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
        let i2 = 0;
        for (const row of table) {
          expect(row == null ? void 0 : row.v).toBe(i2++ & 127);
        }
        expect(i2).toBe(testRows2 + 1);
      });
      it("SMALLINT", async () => {
        const table = await conn.query(`
                    SELECT (v & 32767)::SMALLINT AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
        let i2 = 0;
        for (const row of table) {
          expect(row == null ? void 0 : row.v).toBe(i2++ & 32767);
        }
        expect(i2).toBe(testRows2 + 1);
      });
      it("INTEGER", async () => {
        const table = await conn.query(`
                    SELECT v::INTEGER AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
        let i2 = 0;
        for (const row of table) {
          expect(row == null ? void 0 : row.v).toBe(i2++);
        }
        expect(i2).toBe(testRows2 + 1);
      });
      it("BIGINT", async () => {
        const table = await conn.query(`
                    SELECT v::BIGINT AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
        let i2 = 0;
        for (const row of table) {
          expect(row == null ? void 0 : row.v).toBe(BigInt(i2++));
        }
        expect(i2).toBe(testRows2 + 1);
      });
      it("STRING", async () => {
        const table = await conn.query(`
                    SELECT v::VARCHAR AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
        let i2 = 0;
        for (const row of table) {
          expect(row == null ? void 0 : row.v.valueOf()).toBe(String(i2++));
        }
        expect(i2).toBe(testRows2 + 1);
      });
    });
  });
  describe("Arrow Table Column-Major", () => {
    describe("single column", () => {
      it("TINYINT", async () => {
        const table = await conn.query(`
                    SELECT (v & 127)::TINYINT AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
        let i2 = 0;
        for (const v of table.getChildAt(0)) {
          expect(v).toBe(i2++ & 127);
        }
        expect(i2).toBe(testRows2 + 1);
      });
      it("SMALLINT", async () => {
        const table = await conn.query(`
                    SELECT (v & 32767)::SMALLINT AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
        let i2 = 0;
        for (const v of table.getChildAt(0)) {
          expect(v).toBe(i2++ & 32767);
        }
        expect(i2).toBe(testRows2 + 1);
      });
      it("INTEGER", async () => {
        const table = await conn.query(`
                    SELECT v::INTEGER AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
        let i2 = 0;
        for (const v of table.getChildAt(0)) {
          expect(v).toBe(i2++);
        }
        expect(i2).toBe(testRows2 + 1);
      });
      it("BIGINT", async () => {
        const table = await conn.query(`
                    SELECT v::BIGINT AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
        let i2 = 0;
        for (const v of table.getChildAt(0)) {
          expect(v).toBe(BigInt(i2++));
        }
        expect(i2).toBe(testRows2 + 1);
      });
      it("STRING", async () => {
        const table = await conn.query(`
                    SELECT v::VARCHAR AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
        let i2 = 0;
        for (const v of table.getChildAt(0)) {
          expect(v).toBe(String(i2++));
        }
        expect(i2).toBe(testRows2 + 1);
      });
    });
  });
}

// test/insert_arrow.test.ts
var arrow6 = __toESM(require("apache-arrow"));

// test/table_test.ts
function compareTable(table, expected) {
  var _a, _b;
  const colCount = expected.length;
  expect(table.numCols).toEqual(colCount);
  if (colCount == 0)
    return;
  const rowCount = expected[0].values.length;
  for (let i2 = 0; i2 < colCount; ++i2) {
    expect(expected[i2].values.length).toEqual(rowCount);
    expect((_a = table.getChildAt(i2)) == null ? void 0 : _a.length).toEqual(rowCount);
    expect((_b = table.schema.fields[i2]) == null ? void 0 : _b.name).toEqual(expected[i2].name);
  }
  for (let i2 = 0; i2 < colCount; ++i2) {
    const col = table.getChildAt(i2);
    const have = [];
    for (let j = 0; j < rowCount; ++j) {
      have.push(col.get(j));
    }
    expect(Number(have)).toEqual(Number(expected[i2].values));
  }
}

// test/insert_arrow.test.ts
var buildUtf8Array = (values) => {
  const builder = new arrow6.Utf8Builder({
    type: new arrow6.Utf8()
  });
  for (const v of values) {
    builder.append(v);
  }
  builder.finish();
  return builder.flush();
};
var ARROW_INSERT_TESTS = [
  {
    name: "integers_1",
    schema: new arrow6.Schema([
      new arrow6.Field("a", new arrow6.Int32()),
      new arrow6.Field("b", new arrow6.Int32()),
      new arrow6.Field("c", new arrow6.Int32())
    ]),
    batches: [
      {
        numRows: 3,
        columns: [
          arrow6.makeData({ type: new arrow6.Int32(), data: new Int32Array([1, 4, 7]) }),
          arrow6.makeData({ type: new arrow6.Int32(), data: new Int32Array([2, 5, 8]) }),
          arrow6.makeData({ type: new arrow6.Int32(), data: new Int32Array([3, 6, 9]) })
        ]
      }
    ],
    options: {
      schema: "main",
      name: "foo"
    },
    query: "SELECT * FROM main.foo",
    expectedColumns: [
      { name: "a", values: [1, 4, 7] },
      { name: "b", values: [2, 5, 8] },
      { name: "c", values: [3, 6, 9] }
    ]
  },
  {
    name: "combined_1",
    schema: new arrow6.Schema([
      new arrow6.Field("a", new arrow6.Int32()),
      new arrow6.Field("b", new arrow6.Int16()),
      new arrow6.Field("c", new arrow6.Utf8())
    ]),
    batches: [
      {
        numRows: 3,
        columns: [
          arrow6.makeData({ type: new arrow6.Int32(), data: new Int32Array([1, 4, 7]) }),
          arrow6.makeData({ type: new arrow6.Int16(), data: new Int16Array([2, 5, 8]) }),
          buildUtf8Array(["3", "6", "9"])
        ]
      }
    ],
    options: {
      schema: "main",
      name: "foo"
    },
    query: "SELECT * FROM main.foo",
    expectedColumns: [
      { name: "a", values: [1, 4, 7] },
      { name: "b", values: [2, 5, 8] },
      { name: "c", values: ["3", "6", "9"] }
    ]
  },
  {
    name: "combined_2",
    schema: new arrow6.Schema([
      new arrow6.Field("a", new arrow6.Int32()),
      new arrow6.Field("b", new arrow6.Int16()),
      new arrow6.Field("c", new arrow6.Utf8())
    ]),
    batches: [
      {
        numRows: 3,
        columns: [
          arrow6.makeData({ type: new arrow6.Int32(), data: new Int32Array([1, 4, 7]) }),
          arrow6.makeData({ type: new arrow6.Int16(), data: new Int16Array([2, 5, 8]) }),
          buildUtf8Array(["3", "6", "9"])
        ]
      },
      {
        numRows: 2,
        columns: [
          arrow6.makeData({ type: new arrow6.Int32(), data: new Int32Array([10, 13]) }),
          arrow6.makeData({ type: new arrow6.Int16(), data: new Int16Array([11, 14]) }),
          buildUtf8Array(["12", "15"])
        ]
      }
    ],
    options: {
      schema: "main",
      name: "foo"
    },
    query: "SELECT * FROM main.foo",
    expectedColumns: [
      { name: "a", values: [1, 4, 7, 10, 13] },
      { name: "b", values: [2, 5, 8, 11, 14] },
      { name: "c", values: ["3", "6", "9", "12", "15"] }
    ]
  }
];
function testArrowInsert(db2) {
  let conn;
  beforeEach(async () => {
    db2().flushFiles();
    conn = db2().connect();
  });
  afterEach(async () => {
    conn.close();
    await db2().flushFiles();
    await db2().dropFiles();
  });
  describe("Arrow insert from iterable", () => {
    for (const test of ARROW_INSERT_TESTS) {
      it(test.name, () => {
        conn.query(`DROP TABLE IF EXISTS ${test.options.schema || "main"}.${test.options.name}`);
        const batches = test.batches.map((b) => {
          const data2 = arrow6.makeData({
            type: new arrow6.Struct(test.schema.fields),
            children: b.columns
          });
          return new arrow6.RecordBatch(test.schema, data2);
        });
        const table = new arrow6.Table(test.schema, batches);
        conn.insertArrowTable(table, test.options);
        const results = conn.query(test.query);
        compareTable(results, test.expectedColumns);
      });
    }
  });
}
function testArrowInsertAsync(db2) {
  let conn;
  beforeEach(async () => {
    await db2().flushFiles();
    conn = await db2().connect();
  });
  afterEach(async () => {
    await conn.close();
    await db2().flushFiles();
    await db2().dropFiles();
  });
  describe("Arrow async insert from iterable", () => {
    for (const test of ARROW_INSERT_TESTS) {
      it(test.name, async () => {
        await conn.query(`DROP TABLE IF EXISTS ${test.options.schema || "main"}.${test.options.name}`);
        const batches = test.batches.map((b) => {
          const data2 = arrow6.makeData({
            type: new arrow6.Struct(test.schema.fields),
            children: b.columns
          });
          return new arrow6.RecordBatch(test.schema, data2);
        });
        const table = new arrow6.Table(test.schema, batches);
        await conn.insertArrowTable(table, test.options);
        const results = await conn.query(test.query);
        compareTable(results, test.expectedColumns);
      });
    }
  });
  describe("Arrow async insert from table", () => {
    it("simple integers", async () => {
      await conn.query(`DROP TABLE IF EXISTS insert_from_table`);
      const table = new arrow6.Table({
        a: arrow6.makeVector(new Int32Array([1, 4, 7])),
        b: arrow6.makeVector(new Int32Array([2, 5, 8])),
        c: arrow6.vectorFromArray(["3", "6", "9"])
      });
      await conn.insertArrowTable(table, {
        name: "insert_from_vectors"
      });
      const results = await conn.query("select * from insert_from_vectors");
      compareTable(results, [
        { name: "a", values: [1, 4, 7] },
        { name: "b", values: [2, 5, 8] },
        { name: "c", values: ["3", "6", "9"] }
      ]);
    });
  });
}

// test/insert_json.test.ts
var arrow7 = __toESM(require("apache-arrow"));
function describeBrowser(description, specDefinitions) {
  if (typeof window !== "undefined") {
    describe(description, specDefinitions);
  }
}
var encoder = new TextEncoder();
var JSON_INSERT_TESTS = [
  {
    name: "rows_integers",
    input: `[
            {"a":1, "b":2, "c":3},
            {"a":4, "b":5, "c":6},
            {"a":7, "b":8, "c":9},
        ]`,
    options: {
      schema: "main",
      name: "foo"
    },
    query: "SELECT * FROM main.foo",
    expectedColumns: [
      { name: "a", values: [1, 4, 7] },
      { name: "b", values: [2, 5, 8] },
      { name: "c", values: [3, 6, 9] }
    ]
  },
  {
    name: "cols_integers",
    input: `{
            "a": [1, 4, 7],
            "b": [2, 5, 8],
            "c": [3, 6, 9]
        }`,
    options: {
      schema: "main",
      name: "foo"
    },
    query: "SELECT * FROM main.foo",
    expectedColumns: [
      { name: "a", values: [1, 4, 7] },
      { name: "b", values: [2, 5, 8] },
      { name: "c", values: [3, 6, 9] }
    ]
  },
  {
    name: "options_1",
    input: `[
            {"a":1, "b":2, "c":3},
            {"a":4, "b":5, "c":6},
            {"a":7, "b":8, "c":9},
        ]`,
    options: {
      schema: "main",
      name: "foo",
      shape: "row-array" /* ROW_ARRAY */,
      columns: {
        a: new arrow7.Int16(),
        b: new arrow7.Int32(),
        c: new arrow7.Utf8()
      }
    },
    query: "SELECT * FROM main.foo",
    expectedColumns: [
      { name: "a", values: [1, 4, 7] },
      { name: "b", values: [2, 5, 8] },
      { name: "c", values: ["3", "6", "9"] }
    ]
  }
];
var TEST_FILE = "TEST";
function testJSONInsert(db2) {
  let conn;
  beforeEach(async () => {
    db2().flushFiles();
    conn = db2().connect();
  });
  afterEach(async () => {
    conn.close();
    await db2().flushFiles();
    await db2().dropFiles();
  });
  describe("JSON Insert Sync", () => {
    for (const test of JSON_INSERT_TESTS) {
      it(test.name, () => {
        conn.query(`DROP TABLE IF EXISTS ${test.options.schema || "main"}.${test.options.name}`);
        const buffer = encoder.encode(test.input);
        db2().registerFileBuffer(TEST_FILE, buffer);
        conn.insertJSONFromPath(TEST_FILE, test.options);
        const results = conn.query(test.query);
        compareTable(results, test.expectedColumns);
      });
    }
  });
}
function testJSONInsertAsync(db2) {
  let conn;
  beforeEach(async () => {
    await db2().flushFiles();
    conn = await db2().connect();
  });
  afterEach(async () => {
    await conn.close();
    await db2().flushFiles();
    await db2().dropFiles();
  });
  describe("JSON Insert Buffer Async", () => {
    for (const test of JSON_INSERT_TESTS) {
      it(test.name, async () => {
        await conn.query(`DROP TABLE IF EXISTS ${test.options.schema || "main"}.${test.options.name}`);
        const buffer = encoder.encode(test.input);
        await db2().registerFileBuffer(TEST_FILE, buffer);
        await conn.insertJSONFromPath(TEST_FILE, test.options);
        const results = await conn.query(test.query);
        compareTable(results, test.expectedColumns);
      });
    }
  });
  describeBrowser("JSON Insert Blob Async", () => {
    for (const test of JSON_INSERT_TESTS) {
      it(test.name, async () => {
        await conn.query(`DROP TABLE IF EXISTS ${test.options.schema || "main"}.${test.options.name}`);
        const buffer = encoder.encode(test.input);
        const blob = new Blob([buffer]);
        await db2().registerFileHandle(TEST_FILE, blob, 2 /* BROWSER_FILEREADER */, false);
        await conn.insertJSONFromPath(TEST_FILE, test.options);
        const results = await conn.query(test.query);
        compareTable(results, test.expectedColumns);
      });
    }
  });
}

// test/insert_csv.test.ts
var arrow8 = __toESM(require("apache-arrow"));
function describeBrowser2(description, specDefinitions) {
  if (typeof window !== "undefined") {
    describe(description, specDefinitions);
  }
}
var encoder2 = new TextEncoder();
var CSV_INSERT_TESTS = [
  {
    name: "integers_auto_1",
    input: `"a","b","c"
1,2,3
4,5,6
7,8,9
`,
    options: {
      schema: "main",
      name: "foo"
    },
    query: "SELECT * FROM main.foo",
    expectedColumns: [
      { name: "a", values: [1, 4, 7] },
      { name: "b", values: [2, 5, 8] },
      { name: "c", values: [3, 6, 9] }
    ]
  },
  {
    name: "integers_auto_2",
    input: `a,b,c
1,2,3
4,5,6
7,8,9
`,
    options: {
      schema: "main",
      name: "foo"
    },
    query: "SELECT * FROM main.foo",
    expectedColumns: [
      { name: "a", values: [1, 4, 7] },
      { name: "b", values: [2, 5, 8] },
      { name: "c", values: [3, 6, 9] }
    ]
  },
  {
    name: "integers_auto_3",
    input: `a,b,c`,
    options: {
      schema: "main",
      name: "foo"
    },
    query: "SELECT * FROM main.foo",
    expectedColumns: [
      { name: "column0", values: ["a"] },
      { name: "column1", values: ["b"] },
      { name: "column2", values: ["c"] }
    ]
  },
  {
    name: "integers_auto_2",
    input: `a
1
4
7
`,
    options: {
      schema: "main",
      name: "foo"
    },
    query: "SELECT * FROM main.foo",
    expectedColumns: [{ name: "a", values: [1, 4, 7] }]
  },
  {
    name: "options_1",
    input: `1,2,3
4,5,6
7,8,9
`,
    options: {
      schema: "main",
      name: "foo2",
      header: false,
      detect: false,
      columns: {
        a: new arrow8.Int16(),
        b: new arrow8.Int32(),
        c: new arrow8.Utf8()
      }
    },
    query: "SELECT * FROM main.foo2",
    expectedColumns: [
      { name: "a", values: [1, 4, 7] },
      { name: "b", values: [2, 5, 8] },
      { name: "c", values: ["3", "6", "9"] }
    ]
  },
  {
    name: "options_2",
    input: `1|2|01/02/2020
4|5|01/03/2020
7|8|01/04/2020
`,
    options: {
      schema: "main",
      name: "foo",
      detect: false,
      header: false,
      delimiter: "|",
      dateFormat: "%m/%d/%Y",
      columns: {
        a: new arrow8.Int16(),
        b: new arrow8.Int32(),
        c: new arrow8.DateDay()
      }
    },
    query: "SELECT * FROM main.foo",
    expectedColumns: [
      { name: "a", values: [1, 4, 7] },
      { name: "b", values: [2, 5, 8] },
      {
        name: "c",
        values: [
          new Date(Date.UTC(2020, 0, 2)),
          new Date(Date.UTC(2020, 0, 3)),
          new Date(Date.UTC(2020, 0, 4))
        ]
      }
    ]
  },
  {
    name: "options_3",
    input: `1|2|20:32:45 1992-03-02
4|5|20:32:50 1992-03-02
7|8|20:32:55 1992-03-02
`,
    options: {
      schema: "main",
      name: "foo",
      detect: false,
      header: false,
      delimiter: "|",
      quote: "'",
      timestampFormat: "%H:%M:%S %Y-%m-%d",
      columns: {
        a: new arrow8.Int16(),
        b: new arrow8.Int32(),
        c: new arrow8.TimestampSecond()
      }
    },
    query: "SELECT * FROM main.foo",
    expectedColumns: [
      { name: "a", values: [1, 4, 7] },
      { name: "b", values: [2, 5, 8] },
      {
        name: "c",
        values: [
          new Date(Date.UTC(1992, 2, 2, 20, 32, 45)).getTime(),
          new Date(Date.UTC(1992, 2, 2, 20, 32, 50)).getTime(),
          new Date(Date.UTC(1992, 2, 2, 20, 32, 55)).getTime()
        ]
      }
    ]
  }
];
var TEST_FILE2 = "TEST";
function testCSVInsert(db2) {
  let conn;
  beforeEach(async () => {
    db2().flushFiles();
    conn = db2().connect();
  });
  afterEach(async () => {
    conn.close();
    await db2().flushFiles();
    await db2().dropFiles();
  });
  describe("CSV Insert Sync", () => {
    for (const test of CSV_INSERT_TESTS) {
      it(test.name, () => {
        conn.query(`DROP TABLE IF EXISTS ${test.options.schema || "main"}.${test.options.name}`);
        const buffer = encoder2.encode(test.input);
        db2().registerFileBuffer(TEST_FILE2, buffer);
        conn.insertCSVFromPath(TEST_FILE2, test.options);
        const results = conn.query(test.query);
        compareTable(results, test.expectedColumns);
      });
    }
  });
}
function testCSVInsertAsync(db2) {
  let conn;
  beforeEach(async () => {
    await db2().flushFiles();
    conn = await db2().connect();
  });
  afterEach(async () => {
    await conn.close();
    await db2().flushFiles();
    await db2().dropFiles();
  });
  describe("CSV Insert Buffer Async", () => {
    for (const test of CSV_INSERT_TESTS) {
      it(test.name, async () => {
        await conn.query(`DROP TABLE IF EXISTS ${test.options.schema || "main"}.${test.options.name}`);
        const buffer = encoder2.encode(test.input);
        await db2().registerFileBuffer(TEST_FILE2, buffer);
        await conn.insertCSVFromPath(TEST_FILE2, test.options);
        const results = await conn.query(test.query);
        compareTable(results, test.expectedColumns);
      });
    }
  });
  describeBrowser2("CSV Insert Blob Async", () => {
    for (const test of CSV_INSERT_TESTS) {
      it(test.name, async () => {
        await conn.query(`DROP TABLE IF EXISTS ${test.options.schema || "main"}.${test.options.name}`);
        const buffer = encoder2.encode(test.input);
        const blob = new Blob([buffer]);
        await db2().registerFileHandle(TEST_FILE2, blob, 2 /* BROWSER_FILEREADER */, false);
        await conn.insertCSVFromPath(TEST_FILE2, test.options);
        const results = await conn.query(test.query);
        compareTable(results, test.expectedColumns);
      });
    }
  });
}

// test/tokenizer.test.ts
function testTokenization(db2) {
  describe("Tokenizer", () => {
    it("SELECT 1", async () => {
      expect(db2().tokenize("SELECT 1")).toEqual({
        offsets: [0, 7],
        types: [4, 1]
      });
    });
    it("SELECT * FROM region", async () => {
      expect(db2().tokenize("SELECT * FROM region")).toEqual({
        offsets: [0, 7, 9, 14],
        types: [4, 3, 4, 0]
      });
    });
  });
}
function testTokenizationAsync(db2) {
  describe("Tokenizer", () => {
    it("SELECT 1", async () => {
      expect(await db2().tokenize("SELECT 1")).toEqual({
        offsets: [0, 7],
        types: [4, 1]
      });
    });
    it("SELECT * FROM region", async () => {
      expect(await db2().tokenize("SELECT * FROM region")).toEqual({
        offsets: [0, 7, 9, 14],
        types: [4, 3, 4, 0]
      });
    });
  });
}

// test/tablenames.test.ts
var TABLENAME_TESTS = [
  {
    name: "standard",
    input: "SELECT * FROM my_table",
    tables: ["my_table"]
  },
  {
    name: "fetch_specific",
    input: "SELECT col_a FROM my_table",
    tables: ["my_table"]
  },
  {
    name: "multiple_tables",
    input: "SELECT * FROM my_table1, my_table2, my_table3",
    tables: ["my_table1", "my_table2", "my_table3"]
  },
  {
    name: "same_table_multiple_times",
    input: "SELECT col_a FROM my_table, my_table m2, my_table m3",
    tables: ["my_table"]
  },
  {
    name: "subqueries",
    input: "SELECT * FROM (SELECT * FROM (SELECT * FROM my_table) bla) bla3",
    tables: ["my_table"]
  },
  {
    name: "join",
    input: "SELECT col_a FROM my_table JOIN my_table2 ON (my_table.col_b=my_table2.col_d)",
    tables: ["my_table", "my_table2"]
  },
  {
    name: "scalar_subquery",
    input: "SELECT (SELECT COUNT(*) FROM my_table)",
    tables: ["my_table"]
  },
  {
    name: "set_operations",
    input: "SELECT * FROM my_table UNION ALL SELECT * FROM my_table2 INTERSECT SELECT * FROM my_table3",
    tables: ["my_table", "my_table2", "my_table3"]
  },
  {
    name: "window_functions",
    input: "SELECT row_number() OVER (ORDER BY (SELECT i+j FROM my_table2)) FROM my_table",
    tables: ["my_table", "my_table2"]
  }
];
function testTableNames(db2) {
  let conn;
  beforeEach(() => {
    conn = db2().connect();
  });
  afterEach(() => {
    conn.close();
  });
  describe("TableNames", () => {
    for (const test of TABLENAME_TESTS) {
      it(test.name, () => {
        const tables = conn.getTableNames(test.input);
        expect(tables).toEqual(test.tables);
      });
    }
  });
}
function testTableNamesAsync(db2) {
  let conn;
  beforeEach(async () => {
    conn = await db2().connect();
  });
  afterEach(async () => {
    await conn.close();
  });
  describe("TableNames Async", () => {
    for (const test of TABLENAME_TESTS) {
      it(test.name, async () => {
        const tables = await conn.getTableNames(test.input);
        expect(tables).toEqual(test.tables);
      });
    }
  });
}

// test/udf.test.ts
var import_apache_arrow2 = require("apache-arrow");
function testUDF(db2) {
  let conn;
  beforeEach(() => {
    conn = db2().connect();
  });
  afterEach(() => {
    conn.close();
    db2().flushFiles();
    db2().dropFiles();
  });
  describe("UDF", () => {
    it("simple", async () => {
      var _a, _b;
      conn.createScalarFunction("jsudf", new import_apache_arrow2.Int32(), (a) => a);
      const result = conn.query(
        "SELECT max(jsudf(v::INTEGER))::INTEGER as foo FROM generate_series(1, 10000) as t(v)"
      );
      expect(result.numRows).toEqual(1);
      expect(result.numCols).toEqual(1);
      expect((_a = result.getChildAt(0)) == null ? void 0 : _a.length).toEqual(1);
      expect((_b = result.getChildAt(0)) == null ? void 0 : _b.toArray()).toEqual(new Int32Array([1e4]));
    });
    it("double", async () => {
      var _a, _b;
      conn.createScalarFunction("jsudf2", new import_apache_arrow2.Float64(), (a) => a);
      const result = conn.query(
        "SELECT max(jsudf2(v::DOUBLE))::DOUBLE as foo FROM generate_series(1, 10000) as t(v)"
      );
      expect(result.numRows).toEqual(1);
      expect(result.numCols).toEqual(1);
      expect((_a = result.getChildAt(0)) == null ? void 0 : _a.length).toEqual(1);
      expect((_b = result.getChildAt(0)) == null ? void 0 : _b.toArray()).toEqual(new Float64Array([1e4]));
    });
    it("2 args", async () => {
      var _a, _b;
      conn.createScalarFunction("jsudf3", new import_apache_arrow2.Int32(), (a, b) => a + b);
      const result = conn.query(
        "SELECT max(jsudf3(v::INTEGER, v::INTEGER))::INTEGER as foo FROM generate_series(1, 10000) as t(v)"
      );
      expect(result.numRows).toEqual(1);
      expect(result.numCols).toEqual(1);
      expect((_a = result.getChildAt(0)) == null ? void 0 : _a.length).toEqual(1);
      expect((_b = result.getChildAt(0)) == null ? void 0 : _b.toArray()).toEqual(new Int32Array([2e4]));
    });
    it("3 args", async () => {
      var _a, _b;
      conn.createScalarFunction("jsudf3args", new import_apache_arrow2.Int32(), (a, b, c) => a + b + c);
      const result = conn.query(
        "SELECT max(jsudf3args(v::INTEGER, v::INTEGER, v::INTEGER))::INTEGER as foo FROM generate_series(1, 10000) as t(v)"
      );
      expect(result.numRows).toEqual(1);
      expect(result.numCols).toEqual(1);
      expect((_a = result.getChildAt(0)) == null ? void 0 : _a.length).toEqual(1);
      expect((_b = result.getChildAt(0)) == null ? void 0 : _b.toArray()).toEqual(new Int32Array([3e4]));
    });
    it("4 args", async () => {
      var _a, _b;
      conn.createScalarFunction("jsudf4args", new import_apache_arrow2.Int32(), (a, b, c, d) => a + b + c + d);
      const result = conn.query(
        "SELECT max(jsudf4args(v::INTEGER, v::INTEGER, v::INTEGER, v::INTEGER))::INTEGER as foo FROM generate_series(1, 10000) as t(v)"
      );
      expect(result.numRows).toEqual(1);
      expect(result.numCols).toEqual(1);
      expect((_a = result.getChildAt(0)) == null ? void 0 : _a.length).toEqual(1);
      expect((_b = result.getChildAt(0)) == null ? void 0 : _b.toArray()).toEqual(new Int32Array([4e4]));
    });
    it("noargs", async () => {
      var _a, _b;
      conn.createScalarFunction("jsudf4", new import_apache_arrow2.Int32(), () => 42);
      const result = conn.query("SELECT max(jsudf4())::INTEGER as foo FROM generate_series(1, 10000) as t(v)");
      expect(result.numRows).toEqual(1);
      expect(result.numCols).toEqual(1);
      expect((_a = result.getChildAt(0)) == null ? void 0 : _a.length).toEqual(1);
      expect((_b = result.getChildAt(0)) == null ? void 0 : _b.toArray()).toEqual(new Int32Array([42]));
    });
    it("withnulls", async () => {
      var _a, _b;
      conn.createScalarFunction("jsudf5", new import_apache_arrow2.Int32(), (a) => a == null ? -100 : a);
      const result = conn.query(
        "SELECT min(jsudf5((case when v % 2 = 0 then v else null end)::INTEGER))::INTEGER as foo FROM generate_series(1, 10000) as t(v)"
      );
      expect(result.numRows).toEqual(1);
      expect(result.numCols).toEqual(1);
      expect((_a = result.getChildAt(0)) == null ? void 0 : _a.length).toEqual(1);
      expect((_b = result.getChildAt(0)) == null ? void 0 : _b.toArray()).toEqual(new Int32Array([-100]));
    });
    it("stringparam", async () => {
      var _a, _b;
      function jsudf6(s2) {
        return s2.length;
      }
      conn.createScalarFunction("jsudf6", new import_apache_arrow2.Int32(), jsudf6);
      const result = conn.query(
        "SELECT max(jsudf6('str_' || v))::INTEGER as foo FROM generate_series(1, 10000) as t(v)"
      );
      expect(result.numRows).toEqual(1);
      expect(result.numCols).toEqual(1);
      expect((_a = result.getChildAt(0)) == null ? void 0 : _a.length).toEqual(1);
      expect((_b = result.getChildAt(0)) == null ? void 0 : _b.toArray()).toEqual(new Int32Array([9]));
    });
    it("stringparamnulls", async () => {
      var _a, _b;
      function jsudf7(s2) {
        if (s2 == void 0) {
          return 0;
        } else {
          return s2.length;
        }
      }
      conn.createScalarFunction("jsudf7", new import_apache_arrow2.Int32(), jsudf7);
      const result = conn.query(
        "SELECT max(jsudf7((case when v % 2 = 0 then 'str_' || v else null end)::VARCHAR))::INTEGER as foo FROM generate_series(1, 10000) as t(v)"
      );
      expect(result.numRows).toEqual(1);
      expect(result.numCols).toEqual(1);
      expect((_a = result.getChildAt(0)) == null ? void 0 : _a.length).toEqual(1);
      expect((_b = result.getChildAt(0)) == null ? void 0 : _b.toArray()).toEqual(new Int32Array([9]));
    });
    it("nullintreturn", async () => {
      var _a, _b;
      conn.createScalarFunction("jsudf8", new import_apache_arrow2.Int32(), (a) => void 0);
      const result = conn.query(
        "SELECT max(COALESCE(jsudf8(v::INTEGER), 42))::INTEGER as foo FROM generate_series(1, 10000) as t(v)"
      );
      expect(result.numRows).toEqual(1);
      expect(result.numCols).toEqual(1);
      expect((_a = result.getChildAt(0)) == null ? void 0 : _a.length).toEqual(1);
      expect((_b = result.getChildAt(0)) == null ? void 0 : _b.toArray()).toEqual(new Int32Array([42]));
    });
    it("stringreturn", async () => {
      var _a, _b;
      conn.createScalarFunction("jsudf9", new import_apache_arrow2.Utf8(), (a) => "Hello " + a);
      const result = conn.query(
        "SELECT max(LENGTH(jsudf9(v::INTEGER)))::INTEGER as foo FROM generate_series(1, 10000) as t(v)"
      );
      expect(result.numRows).toEqual(1);
      expect(result.numCols).toEqual(1);
      expect((_a = result.getChildAt(0)) == null ? void 0 : _a.length).toEqual(1);
      expect((_b = result.getChildAt(0)) == null ? void 0 : _b.toArray()).toEqual(new Int32Array([11]));
    });
    it("nullstringreturn", async () => {
      var _a, _b;
      conn.createScalarFunction("jsudf10", new import_apache_arrow2.Utf8(), (a) => a % 2 == 0 ? "Hello" : void 0);
      const result = conn.query(
        "SELECT COUNT(jsudf10(v::INTEGER))::INTEGER as foo FROM generate_series(1, 10000) as t(v)"
      );
      expect(result.numRows).toEqual(1);
      expect(result.numCols).toEqual(1);
      expect((_a = result.getChildAt(0)) == null ? void 0 : _a.length).toEqual(1);
      expect((_b = result.getChildAt(0)) == null ? void 0 : _b.toArray()).toEqual(new Int32Array([5e3]));
    });
    it("struct", async () => {
      var _a, _b;
      conn.createScalarFunction("jsudf11", new import_apache_arrow2.Int32(), (a) => a.x == null ? -100 : a.x);
      const result = conn.query(
        `SELECT min(jsudf11({'x': (case when v % 2 = 0 then v else null end)::INTEGER, 'y': 42}))::INTEGER as foo FROM generate_series(1, 10000) as t(v)`
      );
      expect(result.numRows).toEqual(1);
      expect(result.numCols).toEqual(1);
      expect((_a = result.getChildAt(0)) == null ? void 0 : _a.length).toEqual(1);
      expect((_b = result.getChildAt(0)) == null ? void 0 : _b.toArray()).toEqual(new Int32Array([-100]));
    });
    it("structnested", async () => {
      var _a, _b;
      conn.createScalarFunction("jsudf12", new import_apache_arrow2.Int32(), (a) => a.x.y == null ? -100 : a.x.y);
      const result = conn.query(
        `SELECT min(jsudf12({'x': {'y': (case when v % 2 = 0 then v else null end)::INTEGER }, 'z': 42}))::INTEGER as foo FROM generate_series(1, 10000) as t(v)`
      );
      expect(result.numRows).toEqual(1);
      expect(result.numCols).toEqual(1);
      expect((_a = result.getChildAt(0)) == null ? void 0 : _a.length).toEqual(1);
      expect((_b = result.getChildAt(0)) == null ? void 0 : _b.toArray()).toEqual(new Int32Array([-100]));
    });
    it("structnestednull", async () => {
      var _a, _b;
      conn.createScalarFunction("jsudf13", new import_apache_arrow2.Int32(), (a) => {
        var _a2;
        return ((_a2 = a.x) == null ? void 0 : _a2.y) == null ? -100 : a.x.y;
      });
      const result = conn.query(
        `SELECT min(jsudf13({'x': (case when v % 2 = 0 then {'y': v::INTEGER } else null end), 'z': 42}))::INTEGER as foo FROM generate_series(1, 10000) as t(v)`
      );
      expect(result.numRows).toEqual(1);
      expect(result.numCols).toEqual(1);
      expect((_a = result.getChildAt(0)) == null ? void 0 : _a.length).toEqual(1);
      expect((_b = result.getChildAt(0)) == null ? void 0 : _b.toArray()).toEqual(new Int32Array([-100]));
    });
  });
}

// test/regression/github_332.test.ts
function test332(db2) {
  let conn;
  beforeEach(async () => {
    await db2().flushFiles();
    conn = await db2().connect();
  });
  afterEach(async () => {
    await conn.close();
    await db2().flushFiles();
    await db2().dropFiles();
  });
  describe("GitHub issues", () => {
    it("332", async () => {
      await db2().registerFileText(
        "Products.csv",
        `ProductGroup,Product,Year,Quarter,Revenue,Units,Count,Product Key,Reseller,Product Info,QuarterAsNumber
Electronics,Phone,2018,Q1,103,7,1,2018-Q1,Sony,Format=XML; <Properties>\u2026,1
Electronics,Phone,2018,Q1,102,4,1,2018-Q1,Sony,Format=XML; <Properties>\u2026,1
Electronics,Phone,2019,Q1,98,12,1,2019-Q1,Sony,Format=XML; <Properties>\u2026,1
Electronics,Computer,2018,Q1,104,3,1,2018-Q1,Samsung,Format=XML; <Properties>\u2026,1
Electronics,Computer,2019,Q1,83,7,1,2019-Q1,Google,Format=XML; <Properties>\u2026,1
Media,Theater,2018,Q1,17,4,1,2018-Q1,Sony,Format=XML; <Properties>\u2026,1
Media,Theater,2019,Q1,20,7,1,2019-Q1,Sony,Format=XML; <Properties>\u2026,1
Media,Movies,2018,Q1,25,12,1,2018-Q1,Microsoft,Format=XML; <Properties>\u2026,1
Media,Movies,2019,Q1,26,13,1,2019-Q1,Sony,Format=XML; <Properties>\u2026,1
Electronics,Phone,2018,Q2,105,5,1,2018-Q2,Samsung,Format=XML; <Properties>\u2026,2
Electronics,Phone,2019,Q2,82,15,1,2019-Q2,LG,Format=XML; <Properties>\u2026,2
Electronics,Computer,2018,Q2,99,4,1,2018-Q2,LG,Format=XML; <Properties>\u2026,2
Electronics,Computer,2019,Q2,84,20,1,2019-Q2,Sony,Format=XML; <Properties>\u2026,2
Media,Theater,2018,Q2,17,4,1,2018-Q2,Microsoft,Format=XML; <Properties>\u2026,2
Media,Theater,2019,Q2,22,5,1,2019-Q2,Sony,Format=XML; <Properties>\u2026,2
Media,Movies,2018,Q2,25,12,1,2018-Q2,Samsung,Format=XML; <Properties>\u2026,2
Media,Movies,2019,Q2,26,14,1,2019-Q2,Google,Format=XML; <Properties>\u2026,2
Electronics,Phone,2000,Q1,103,7,1,2000-Q1,Sony,Format=XML; <Properties>\u2026,1
Electronics,Phone,2001,Q1,102,4,1,2001-Q1,Sony,Format=XML; <Properties>\u2026,1
Electronics,Phone,2002,Q1,98,12,1,2002-Q1,Microsoft,Format=XML; <Properties>\u2026,1
Electronics,Computer,2003,Q1,104,3,1,2003-Q1,Sony,Format=XML; <Properties>\u2026,1
Electronics,Computer,2004,Q1,83,7,1,2004-Q1,Samsung,Format=XML; <Properties>\u2026,1
Media,Theater,2005,Q1,17,4,1,2005-Q1,Google,Format=XML; <Properties>\u2026,1
Media,Theater,2006,Q1,20,7,1,2006-Q1,Sony,Format=XML; <Properties>\u2026,1
Media,Movies,2007,Q1,25,12,1,2007-Q1,Sony,Format=XML; <Properties>\u2026,1
Media,Movies,2008,Q1,26,13,1,2008-Q1,Microsoft,Format=XML; <Properties>\u2026,1
Electronics,Phone,2009,Q2,105,5,1,2009-Q2,Sony,Format=XML; <Properties>\u2026,2
Electronics,Phone,2010,Q2,82,15,1,2010-Q2,Sony,Format=XML; <Properties>\u2026,2
Electronics,Computer,2011,Q2,99,4,1,2011-Q2,Sony,Format=XML; <Properties>\u2026,2
Electronics,Computer,2012,Q2,84,20,1,2012-Q2,Sony,Format=XML; <Properties>\u2026,2
Media,Theater,2013,Q2,17,4,1,2013-Q2,Sony,Format=XML; <Properties>\u2026,2
Media,Theater,2014,Q2,22,5,1,2014-Q2,Sony,Format=XML; <Properties>\u2026,2
Media,Movies,2015,Q2,25,12,1,2015-Q2,Sony,Format=XML; <Properties>\u2026,2
Media,Movies,2016,Q2,26,14,1,2016-Q2,Samsung,Format=XML; <Properties>\u2026,2
Media,Movies,2017,Q1,26,13,1,2017-Q1,Google,Format=XML; <Properties>\u2026,1
Electronics,Phone,2018,Q2,105,5,1,2018-Q2,Sony,Format=XML; <Properties>\u2026,2
Electronics,Phone,2019,Q2,82,15,1,2019-Q2,Sony,Format=XML; <Properties>\u2026,2
Electronics,Computer,2020,Q2,99,4,1,2020-Q2,Microsoft,Format=XML; <Properties>\u2026,2
Electronics,Phone,2020,Q1,103,7,1,2020-Q1,Sony,Format=XML; <Properties>\u2026,1
Electronics,Phone,2020,Q2,102,4,1,2020-Q2,Samsung,Format=XML; <Properties>\u2026,2
Electronics,Phone,2020,Q3,98,12,1,2020-Q3,LG,Format=XML; <Properties>\u2026,3
Electronics,Computer,2020,Q4,104,3,1,2020-Q4,LG,Format=XML; <Properties>\u2026,4
Electronics,Computer,2020,Q1,83,7,1,2020-Q1,Sony,Format=XML; <Properties>\u2026,1
Media,Theater,2020,Q1,17,4,1,2020-Q1,Microsoft,Format=XML; <Properties>\u2026,1
Media,Theater,2020,Q1,20,7,1,2020-Q1,Sony,Format=XML; <Properties>\u2026,1
`
      );
      await conn.query("CREATE TABLE products AS SELECT * FROM 'Products.csv'");
      const all = await conn.query("SELECT * FROM products");
      expect(all.schema.fields.length).toBe(11);
      expect(all.schema.fields[0].name).toBe("ProductGroup");
      const insensitive = await conn.query("SELECT productgroup FROM products GROUP BY productgroup");
      expect(insensitive.schema.fields.length).toBe(1);
      expect(insensitive.schema.fields[0].name).toBe("ProductGroup");
      expect(insensitive.toArray().length).toEqual(2);
      await conn.query("DROP TABLE products");
    });
  });
}

// test/regression/github_334.test.ts
var arrow9 = __toESM(require("apache-arrow"));
function test334(adb2) {
  describe("GitHub issues", () => {
    describe("334", () => {
      it("CSV insert", async () => {
        await adb2().registerFileText(`data.csv`, "1|foo\n2|bar\n");
        const conn = await adb2().connect();
        await conn.insertCSVFromPath("data.csv", {
          schema: "main",
          name: "foo",
          detect: false,
          header: false,
          delimiter: "|",
          columns: {
            col1: new arrow9.Int32(),
            col2: new arrow9.Utf8()
          }
        });
        await conn.query("DROP TABLE IF EXISTS foo");
        await conn.close();
        await adb2().dropFile("data.csv");
      });
      it("JSON row insert", async () => {
        await adb2().registerFileText(
          "rows.json",
          `[
                    { "col1": 1, "col2": "foo" },
                    { "col1": 2, "col2": "bar" },
                ]`
        );
        const conn = await adb2().connect();
        await conn.insertJSONFromPath("rows.json", { name: "rows" });
        await conn.query("DROP TABLE IF EXISTS rows");
        await conn.close();
        await adb2().dropFile("rows.json");
      });
      it("JSON column insert", async () => {
        await adb2().registerFileText(
          "columns.json",
          `{
                    "col1": [1, 2],
                    "col2": ["foo", "bar"]
                }`
        );
        const conn = await adb2().connect();
        await conn.insertJSONFromPath("columns.json", { name: "columns" });
        await conn.query("DROP TABLE IF EXISTS columns");
        await conn.close();
        await adb2().dropFile("columns.json");
      });
      it("Query result materialized", async () => {
        const conn = await adb2().connect();
        await conn.query(`
                SELECT * FROM generate_series(1, 100) t(v)
            `);
        await conn.close();
      });
      it("Query result streamed", async () => {
        const conn = await adb2().connect();
        for await (const batch of await conn.send(`
                SELECT * FROM generate_series(1, 100) t(v)
            `)) {
          expect(batch.numRows).toBeGreaterThan(0);
        }
        await conn.close();
      });
      it("Prepared statement materialized", async () => {
        const conn = await adb2().connect();
        const stmt = await conn.prepare(`SELECT v + ? FROM generate_series(0, 10000) as t(v);`);
        await stmt.query(234);
        await stmt.close();
        await conn.close();
      });
      it("Prepared statement streamed", async () => {
        const conn = await adb2().connect();
        const stmt = await conn.prepare(`SELECT v + ? FROM generate_series(0, 10000) as t(v);`);
        for await (const batch of await stmt.send(234)) {
          expect(batch.numRows).toBeGreaterThan(0);
        }
        await stmt.close();
        await conn.close();
      });
    });
  });
}

// test/regression/github_393.test.ts
function test393(db2) {
  let conn = null;
  beforeEach(async () => {
    await db2().flushFiles();
  });
  afterEach(async () => {
    if (conn) {
      await conn.close();
      conn = null;
    }
    await db2().flushFiles();
    await db2().dropFiles();
  });
  describe("GitHub issues", () => {
    it("393", async () => {
      var _a, _b;
      await db2().open({
        path: ":memory:",
        query: {
          castTimestampToDate: false
        }
      });
      conn = await db2().connect();
      const resultWithoutCast = await conn.query(`SELECT TIMESTAMP '1992-03-22 01:02:03' as ts`);
      expect((_a = resultWithoutCast.toArray()[0]) == null ? void 0 : _a.ts).toEqual(new Date(Date.UTC(1992, 2, 22, 1, 2, 3)).getTime());
      await db2().open({
        path: ":memory:",
        query: {
          castTimestampToDate: true
        }
      });
      conn = await db2().connect();
      const resultWithCast = await conn.query(`SELECT TIMESTAMP '1992-03-22 01:02:03' as ts`);
      expect((_b = resultWithCast.toArray()[0]) == null ? void 0 : _b.ts).toEqual(new Date(Date.UTC(1992, 2, 22, 1, 2, 3)));
    });
  });
}

// test/regression/github_448.test.ts
function test448(db2) {
  let conn = null;
  beforeEach(async () => {
    await db2().flushFiles();
  });
  afterEach(async () => {
    if (conn) {
      await conn.close();
      conn = null;
    }
    await db2().flushFiles();
    await db2().dropFiles();
  });
  describe("GitHub issues", () => {
    it("448", async () => {
      var _a;
      conn = await db2().connect();
      await conn.query(`create temp table test448(i integer)`);
      await conn.query(`insert into test448 values (1),(2),(1)`);
      let result = await conn.query(`select * from test448`);
      expect(result.numCols).toBe(1);
      expect(result.numRows).toBe(3);
      expect((_a = result.getChildAt(0)) == null ? void 0 : _a.toArray()).toEqual(new Int32Array([1, 2, 1]));
      result = await conn.query(`select histogram(i) from test448`);
      expect(result.numCols).toBe(1);
      expect(result.numRows).toBe(1);
      const array = result.getChildAt(0).toArray();
      expect(array.length).toEqual(1);
      expect(array[0].toString()).toEqual("{1: 2, 2: 1}");
    });
  });
}

// test/regression/github_470.test.ts
function test470(db2) {
  let conn = null;
  beforeEach(async () => {
    await db2().flushFiles();
  });
  afterEach(async () => {
    if (conn) {
      await conn.close();
      conn = null;
    }
    await db2().flushFiles();
    await db2().dropFiles();
  });
  describe("GitHub issues", () => {
    it("470", async () => {
      var _a, _b, _c, _d, _e, _f;
      await db2().open({
        path: ":memory:",
        query: {
          castDurationToTime64: false
        }
      });
      conn = await db2().connect();
      const result1 = await conn.query(`SELECT INTERVAL '3' MONTH AS interval`);
      expect((_b = (_a = result1.toArray()[0]) == null ? void 0 : _a.interval) == null ? void 0 : _b.toString()).toEqual("0,3");
      await db2().open({
        path: ":memory:",
        query: {
          castDurationToTime64: true
        }
      });
      conn = await db2().connect();
      const resultWithCast = await conn.query(`SELECT INTERVAL '3' MONTH AS interval`);
      expect((_d = (_c = resultWithCast.toArray()[0]) == null ? void 0 : _c.interval) == null ? void 0 : _d.toString()).toEqual("0,3");
      await db2().open({
        path: ":memory:",
        query: {}
      });
      conn = await db2().connect();
      const resultWithDefault = await conn.query(`SELECT INTERVAL '3' MONTH AS interval`);
      expect((_f = (_e = resultWithDefault.toArray()[0]) == null ? void 0 : _e.interval) == null ? void 0 : _f.toString()).toEqual("0,3");
    });
  });
}

// test/regression/github_477.test.ts
function test477(db2) {
  let conn = null;
  beforeEach(async () => {
    await db2().flushFiles();
  });
  afterEach(async () => {
    if (conn) {
      await conn.close();
      conn = null;
    }
    await db2().flushFiles();
    await db2().dropFiles();
  });
  describe("GitHub issues", () => {
    it("477", async () => {
      var _a, _b;
      await db2().open({
        path: ":memory:",
        query: {}
      });
      conn = await db2().connect();
      const resultWithoutCast = await conn.query(`SELECT (-1.9)::DECIMAL(2,1) as decimal`);
      expect(resultWithoutCast.schema.fields[0].type.scale).toEqual(1);
      expect(resultWithoutCast.schema.fields[0].type.precision).toEqual(2);
      expect(((_a = resultWithoutCast.toArray()[0]) == null ? void 0 : _a.decimal) == -19).toBe(true);
      await db2().open({
        path: ":memory:",
        query: {
          castDecimalToDouble: true
        }
      });
      conn = await db2().connect();
      const resultWithCast = await conn.query(`SELECT (-1.9)::DECIMAL(2,1) as decimal`);
      expect((_b = resultWithCast.toArray()[0]) == null ? void 0 : _b.decimal).toEqual(-1.9000000000000001);
    });
  });
}

// test/regression/github_1467.test.ts
function test1467(db2) {
  let conn = null;
  beforeEach(async () => {
    await db2().flushFiles();
  });
  afterEach(async () => {
    if (conn) {
      await conn.close();
      conn = null;
    }
    await db2().flushFiles();
    await db2().dropFiles();
  });
  describe("GitHub issues", () => {
    it("1467", async () => {
      var _a;
      await db2().open({
        path: ":memory:",
        query: {}
      });
      conn = await db2().connect();
      const resultWithoutCast = await conn.query(`select substring('\u{1F986}\u{1F986}\u{1F986}' from 3) AS result;`);
      expect((_a = resultWithoutCast.toArray()[0]) == null ? void 0 : _a.result).toEqual("\u{1F986}");
    });
  });
}

// test/regression/index.ts
function testRegressionAsync(adb2) {
  test332(adb2);
  test334(adb2);
  test393(adb2);
  test448(adb2);
  test470(adb2);
  test477(adb2);
  test1467(adb2);
}

// test/fts.test.ts
function testFTS(db2) {
  let conn;
  beforeEach(() => {
    conn = db2().connect();
  });
  afterEach(() => {
    conn.close();
    db2().flushFiles();
    db2().dropFiles();
  });
  describe("FTS", () => {
    it("sample", async () => {
      var _a;
      await conn.query(
        "CREATE TABLE documents(document_identifier VARCHAR, text_content VARCHAR, author VARCHAR, doc_version INTEGER);"
      );
      await conn.query(
        "INSERT INTO documents VALUES ('doc1', 'The mallard is a dabbling duck that breeds throughout the temperate.','Hannes M\xFChleisen', 3), ('doc2', 'The cat is a domestic species of small carnivorous mammal.', 'Laurens Kuiper', 2);"
      );
      await conn.query("PRAGMA create_fts_index('documents', 'document_identifier', 'text_content', 'author');");
      const result = conn.query(
        "SELECT document_identifier, score\n            FROM (SELECT *, fts_main_documents.match_bm25(document_identifier, 'Muhleisen', fields := 'author') AS score\n            FROM documents) sq\n            WHERE score IS NOT NULL\n            AND doc_version > 2\n            ORDER BY score DESC;"
      );
      expect((_a = result.getChildAt(0)) == null ? void 0 : _a.toArray()).toEqual(["doc1"]);
    });
  });
}

// test/index_node.ts
jasmine.DEFAULT_TIMEOUT_INTERVAL = 6e4;
var dataDir = import_path.default.resolve(__dirname, "../../../data");
var resolveBuffer = (url2) => {
  const p = import_path.default.join(dataDir, url2);
  if (!import_fs3.default.existsSync(p))
    return null;
  return new Uint8Array(import_fs3.default.readFileSync(p));
};
var resolveData = async (url2) => {
  switch (url2) {
    case "/uni/all.zip":
      return await resolveBuffer("/uni/all.zip");
    case "/uni/assistenten.parquet":
      return await resolveBuffer("/uni/assistenten.parquet");
    case "/uni/studenten.parquet":
      return await resolveBuffer("/uni/studenten.parquet");
    case "/uni/hoeren.parquet":
      return await resolveBuffer("/uni/hoeren.parquet");
    case "/uni/vorlesungen.parquet":
      return await resolveBuffer("/uni/vorlesungen.parquet");
    default:
      return null;
  }
};
var db = null;
var adb = null;
var worker = null;
beforeAll(async () => {
  const DUCKDB_BUNDLES = {
    mvp: {
      mainModule: import_path.default.resolve(__dirname, "./duckdb-mvp.wasm"),
      mainWorker: import_path.default.resolve(__dirname, "./duckdb-node-mvp.worker.cjs")
    },
    eh: {
      mainModule: import_path.default.resolve(__dirname, "./duckdb-eh.wasm"),
      mainWorker: import_path.default.resolve(__dirname, "./duckdb-node-eh.worker.cjs")
    }
  };
  const DUCKDB_CONFIG = await selectBundle(DUCKDB_BUNDLES);
  const logger = new VoidLogger();
  db = await createDuckDB(DUCKDB_BUNDLES, logger, NODE_RUNTIME);
  await db.instantiate((_) => {
  });
  worker = new import_web_worker.default(DUCKDB_CONFIG.mainWorker);
  adb = new AsyncDuckDB(logger, worker);
  await adb.instantiate(DUCKDB_CONFIG.mainModule, DUCKDB_CONFIG.pthreadWorker);
});
afterAll(async () => {
  if (worker)
    worker.terminate();
});
testUDF(() => db);
testTableNames(() => db);
testTableNamesAsync(() => adb);
testRegressionAsync(() => adb);
testAllTypes(() => db);
testAllTypesAsync(() => adb);
testBindings(() => db, dataDir);
testAsyncBindings(() => adb, dataDir, 1 /* NODE_FS */);
testBatchStream(() => db);
testAsyncBatchStream(() => adb);
testFilesystem(() => adb, resolveData, dataDir, 1 /* NODE_FS */);
testArrowInsert(() => db);
testArrowInsertAsync(() => adb);
testJSONInsert(() => db);
testJSONInsertAsync(() => adb);
testCSVInsert(() => db);
testCSVInsertAsync(() => adb);
testTokenization(() => db);
testTokenizationAsync(() => adb);
testFTS(() => db);
/*! Bundled license information:

is-extglob/index.js:
  (*!
   * is-extglob <https://github.com/jonschlinkert/is-extglob>
   *
   * Copyright (c) 2014-2016, Jon Schlinkert.
   * Licensed under the MIT License.
   *)

is-glob/index.js:
  (*!
   * is-glob <https://github.com/jonschlinkert/is-glob>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)

is-number/index.js:
  (*!
   * is-number <https://github.com/jonschlinkert/is-number>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Released under the MIT License.
   *)

to-regex-range/index.js:
  (*!
   * to-regex-range <https://github.com/micromatch/to-regex-range>
   *
   * Copyright (c) 2015-present, Jon Schlinkert.
   * Released under the MIT License.
   *)

fill-range/index.js:
  (*!
   * fill-range <https://github.com/jonschlinkert/fill-range>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Licensed under the MIT License.
   *)

queue-microtask/index.js:
  (*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

run-parallel/index.js:
  (*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
//# sourceMappingURL=tests-node.cjs.map
